{
    "sourceFile": "node_modules/eslint-plugin-react/node_modules/resolve/test/resolver_sync.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892282836,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "var path = require('path');\nvar fs = require('fs');\nvar test = require('tape');\n\nvar resolve = require('../');\nvar sync = require('../sync');\n\nvar requireResolveSupportsPaths = require.resolve.length > 1\n    && !(/^v12\\.[012]\\./).test(process.version); // broken in v12.0-12.2, see https://github.com/nodejs/node/issues/27794\n\nvar requireResolveDefaultPathsBroken = (/^v8\\.9\\.|^v9\\.[01]\\.0|^v9\\.2\\./).test(process.version);\n// broken in node v8.9.x, v9.0, v9.1, v9.2.x. see https://github.com/nodejs/node/pull/17113\n\ntest('`./sync` entry point', function (t) {\n    t.equal(resolve.sync, sync, '`./sync` entry point is the same as `.sync` on `main`');\n    t.end();\n});\n\ntest('foo', function (t) {\n    var dir = path.join(__dirname, 'resolver');\n\n    t.equal(\n        resolve.sync('./foo', { basedir: dir }),\n        path.join(dir, 'foo.js'),\n        './foo'\n    );\n    if (requireResolveSupportsPaths) {\n        t.equal(\n            resolve.sync('./foo', { basedir: dir }),\n            require.resolve('./foo', { paths: [dir] }),\n            './foo: resolve.sync === require.resolve'\n        );\n    }\n\n    t.equal(\n        resolve.sync('./foo.js', { basedir: dir }),\n        path.join(dir, 'foo.js'),\n        './foo.js'\n    );\n    if (requireResolveSupportsPaths) {\n        t.equal(\n            resolve.sync('./foo.js', { basedir: dir }),\n            require.resolve('./foo.js', { paths: [dir] }),\n            './foo.js: resolve.sync === require.resolve'\n        );\n    }\n\n    t.equal(\n        resolve.sync('./foo.js', { basedir: dir, filename: path.join(dir, 'bar.js') }),\n        path.join(dir, 'foo.js')\n    );\n\n    t.throws(function () {\n        resolve.sync('foo', { basedir: dir });\n    });\n\n    // Test that filename is reported as the \"from\" value when passed.\n    t.throws(\n        function () {\n            resolve.sync('foo', { basedir: dir, filename: path.join(dir, 'bar.js') });\n        },\n        {\n            name: 'Error',\n            message: \"Cannot find module 'foo' from '\" + path.join(dir, 'bar.js') + \"'\"\n        }\n    );\n\n    t.end();\n});\n\ntest('bar', function (t) {\n    var dir = path.join(__dirname, 'resolver');\n\n    var basedir = path.join(dir, 'bar');\n\n    t.equal(\n        resolve.sync('foo', { basedir: basedir }),\n        path.join(dir, 'bar/node_modules/foo/index.js'),\n        'foo in bar'\n    );\n    if (!requireResolveDefaultPathsBroken && requireResolveSupportsPaths) {\n        t.equal(\n            resolve.sync('foo', { basedir: basedir }),\n            require.resolve('foo', { paths: [basedir] }),\n            'foo in bar: resolve.sync === require.resolve'\n        );\n    }\n\n    t.end();\n});\n\ntest('baz', function (t) {\n    var dir = path.join(__dirname, 'resolver');\n\n    t.equal(\n        resolve.sync('./baz', { basedir: dir }),\n        path.join(dir, 'baz/quux.js'),\n        './baz'\n    );\n    if (requireResolveSupportsPaths) {\n        t.equal(\n            resolve.sync('./baz', { basedir: dir }),\n            require.resolve('./baz', { paths: [dir] }),\n            './baz: resolve.sync === require.resolve'\n        );\n    }\n\n    t.end();\n});\n\ntest('biz', function (t) {\n    var dir = path.join(__dirname, 'resolver/biz/node_modules');\n\n    t.equal(\n        resolve.sync('./grux', { basedir: dir }),\n        path.join(dir, 'grux/index.js')\n    );\n    if (requireResolveSupportsPaths) {\n        t.equal(\n            resolve.sync('./grux', { basedir: dir }),\n            require.resolve('./grux', { paths: [dir] }),\n            './grux: resolve.sync === require.resolve'\n        );\n    }\n\n    var tivDir = path.join(dir, 'grux');\n    t.equal(\n        resolve.sync('tiv', { basedir: tivDir }),\n        path.join(dir, 'tiv/index.js')\n    );\n    if (!requireResolveDefaultPathsBroken && requireResolveSupportsPaths) {\n        t.equal(\n            resolve.sync('tiv', { basedir: tivDir }),\n            require.resolve('tiv', { paths: [tivDir] }),\n            'tiv: resolve.sync === require.resolve'\n        );\n    }\n\n    var gruxDir = path.join(dir, 'tiv');\n    t.equal(\n        resolve.sync('grux', { basedir: gruxDir }),\n        path.join(dir, 'grux/index.js')\n    );\n    if (!requireResolveDefaultPathsBroken && requireResolveSupportsPaths) {\n        t.equal(\n            resolve.sync('grux', { basedir: gruxDir }),\n            require.resolve('grux', { paths: [gruxDir] }),\n            'grux: resolve.sync === require.resolve'\n        );\n    }\n\n    t.end();\n});\n\ntest('normalize', function (t) {\n    var dir = path.join(__dirname, 'resolver/biz/node_modules/grux');\n\n    t.equal(\n        resolve.sync('../grux', { basedir: dir }),\n        path.join(dir, 'index.js')\n    );\n    if (requireResolveSupportsPaths) {\n        t.equal(\n            resolve.sync('../grux', { basedir: dir }),\n            require.resolve('../grux', { paths: [dir] }),\n            '../grux: resolve.sync === require.resolve'\n        );\n    }\n\n    t.end();\n});\n\ntest('cup', function (t) {\n    var dir = path.join(__dirname, 'resolver');\n\n    t.equal(\n        resolve.sync('./cup', {\n            basedir: dir,\n            extensions: ['.js', '.coffee']\n        }),\n        path.join(dir, 'cup.coffee'),\n        './cup -> ./cup.coffee'\n    );\n\n    t.equal(\n        resolve.sync('./cup.coffee', { basedir: dir }),\n        path.join(dir, 'cup.coffee'),\n        './cup.coffee'\n    );\n\n    t.throws(function () {\n        resolve.sync('./cup', {\n            basedir: dir,\n            extensions: ['.js']\n        });\n    });\n\n    if (requireResolveSupportsPaths) {\n        t.equal(\n            resolve.sync('./cup.coffee', { basedir: dir, extensions: ['.js', '.coffee'] }),\n            require.resolve('./cup.coffee', { paths: [dir] }),\n            './cup.coffee: resolve.sync === require.resolve'\n        );\n    }\n\n    t.end();\n});\n\ntest('mug', function (t) {\n    var dir = path.join(__dirname, 'resolver');\n\n    t.equal(\n        resolve.sync('./mug', { basedir: dir }),\n        path.join(dir, 'mug.js'),\n        './mug -> ./mug.js'\n    );\n    if (requireResolveSupportsPaths) {\n        t.equal(\n            resolve.sync('./mug', { basedir: dir }),\n            require.resolve('./mug', { paths: [dir] }),\n            './mug: resolve.sync === require.resolve'\n        );\n    }\n\n    t.equal(\n        resolve.sync('./mug', {\n            basedir: dir,\n            extensions: ['.coffee', '.js']\n        }),\n        path.join(dir, 'mug.coffee'),\n        './mug -> ./mug.coffee'\n    );\n\n    t.equal(\n        resolve.sync('./mug', {\n            basedir: dir,\n            extensions: ['.js', '.coffee']\n        }),\n        path.join(dir, 'mug.js'),\n        './mug -> ./mug.js'\n    );\n\n    t.end();\n});\n\ntest('other path', function (t) {\n    var resolverDir = path.join(__dirname, 'resolver');\n    var dir = path.join(resolverDir, 'bar');\n    var otherDir = path.join(resolverDir, 'other_path');\n\n    t.equal(\n        resolve.sync('root', {\n            basedir: dir,\n            paths: [otherDir]\n        }),\n        path.join(resolverDir, 'other_path/root.js')\n    );\n\n    t.equal(\n        resolve.sync('lib/other-lib', {\n            basedir: dir,\n            paths: [otherDir]\n        }),\n        path.join(resolverDir, 'other_path/lib/other-lib.js')\n    );\n\n    t.throws(function () {\n        resolve.sync('root', { basedir: dir });\n    });\n\n    t.throws(function () {\n        resolve.sync('zzz', {\n            basedir: dir,\n            paths: [otherDir]\n        });\n    });\n\n    t.end();\n});\n\ntest('path iterator', function (t) {\n    var resolverDir = path.join(__dirname, 'resolver');\n\n    var exactIterator = function (x, start, getPackageCandidates, opts) {\n        return [path.join(resolverDir, x)];\n    };\n\n    t.equal(\n        resolve.sync('baz', { packageIterator: exactIterator }),\n        path.join(resolverDir, 'baz/quux.js')\n    );\n\n    t.end();\n});\n\ntest('incorrect main', function (t) {\n    var resolverDir = path.join(__dirname, 'resolver');\n    var dir = path.join(resolverDir, 'incorrect_main');\n\n    t.equal(\n        resolve.sync('./incorrect_main', { basedir: resolverDir }),\n        path.join(dir, 'index.js')\n    );\n    if (requireResolveSupportsPaths) {\n        t.equal(\n            resolve.sync('./incorrect_main', { basedir: resolverDir }),\n            require.resolve('./incorrect_main', { paths: [resolverDir] }),\n            './incorrect_main: resolve.sync === require.resolve'\n        );\n    }\n\n    t.end();\n});\n\ntest('missing index', function (t) {\n    t.plan(requireResolveSupportsPaths ? 2 : 1);\n\n    var resolverDir = path.join(__dirname, 'resolver');\n    try {\n        resolve.sync('./missing_index', { basedir: resolverDir });\n        t.fail('did not fail');\n    } catch (err) {\n        t.equal(err && err.code, 'INCORRECT_PACKAGE_MAIN', 'error has correct error code');\n    }\n    if (requireResolveSupportsPaths) {\n        try {\n            require.resolve('./missing_index', { basedir: resolverDir });\n            t.fail('require.resolve did not fail');\n        } catch (err) {\n            t.equal(err && err.code, 'MODULE_NOT_FOUND', 'error has correct error code');\n        }\n    }\n});\n\ntest('missing main', function (t) {\n    var resolverDir = path.join(__dirname, 'resolver');\n    var dir = path.join(resolverDir, 'missing_main');\n\n    t.equal(\n        resolve.sync('./missing_main', { basedir: resolverDir }),\n        path.join(dir, 'index.js')\n    );\n    if (requireResolveSupportsPaths) {\n        t.equal(\n            resolve.sync('./missing_main', { basedir: resolverDir }),\n            require.resolve('./missing_main', { paths: [resolverDir] }),\n            '\"main\" missing: resolve.sync === require.resolve'\n        );\n    }\n\n    t.end();\n});\n\ntest('null main', function (t) {\n    var resolverDir = path.join(__dirname, 'resolver');\n    var dir = path.join(resolverDir, 'null_main');\n\n    t.equal(\n        resolve.sync('./null_main', { basedir: resolverDir }),\n        path.join(dir, 'index.js')\n    );\n    if (requireResolveSupportsPaths) {\n        t.equal(\n            resolve.sync('./null_main', { basedir: resolverDir }),\n            require.resolve('./null_main', { paths: [resolverDir] }),\n            '`\"main\": null`: resolve.sync === require.resolve'\n        );\n    }\n\n    t.end();\n});\n\ntest('main: false', function (t) {\n    var basedir = path.join(__dirname, 'resolver');\n    var dir = path.join(basedir, 'false_main');\n    t.equal(\n        resolve.sync('./false_main', { basedir: basedir }),\n        path.join(dir, 'index.js'),\n        '`\"main\": false`: resolves to `index.js`'\n    );\n    if (requireResolveSupportsPaths) {\n        t.equal(\n            resolve.sync('./false_main', { basedir: basedir }),\n            require.resolve('./false_main', { paths: [basedir] }),\n            '`\"main\": false`: resolve.sync === require.resolve'\n        );\n    }\n\n    t.end();\n});\n\nvar stubStatSync = function stubStatSync(fn) {\n    var statSync = fs.statSync;\n    try {\n        fs.statSync = function () {\n            throw new EvalError('Unknown Error');\n        };\n        return fn();\n    } finally {\n        fs.statSync = statSync;\n    }\n};\n\ntest('#79 - re-throw non ENOENT errors from stat', function (t) {\n    var dir = path.join(__dirname, 'resolver');\n\n    stubStatSync(function () {\n        t.throws(function () {\n            resolve.sync('foo', { basedir: dir });\n        }, /Unknown Error/);\n    });\n\n    t.end();\n});\n\ntest('#52 - incorrectly resolves module-paths like \"./someFolder/\" when there is a file of the same name', function (t) {\n    var dir = path.join(__dirname, 'resolver');\n    var basedir = path.join(dir, 'same_names');\n\n    t.equal(\n        resolve.sync('./foo', { basedir: basedir }),\n        path.join(dir, 'same_names/foo.js')\n    );\n    if (requireResolveSupportsPaths) {\n        t.equal(\n            resolve.sync('./foo', { basedir: basedir }),\n            require.resolve('./foo', { paths: [basedir] }),\n            './foo: resolve.sync === require.resolve'\n        );\n    }\n\n    t.equal(\n        resolve.sync('./foo/', { basedir: basedir }),\n        path.join(dir, 'same_names/foo/index.js')\n    );\n    if (requireResolveSupportsPaths) {\n        t.equal(\n            resolve.sync('./foo/', { basedir: basedir }),\n            require.resolve('./foo/', { paths: [basedir] }),\n            './foo/: resolve.sync === require.resolve'\n        );\n    }\n\n    t.end();\n});\n\ntest('#211 - incorrectly resolves module-paths like \".\" when from inside a folder with a sibling file of the same name', function (t) {\n    var dir = path.join(__dirname, 'resolver');\n    var basedir = path.join(dir, 'same_names/foo');\n\n    t.equal(\n        resolve.sync('./', { basedir: basedir }),\n        path.join(dir, 'same_names/foo/index.js'),\n        './'\n    );\n    if (requireResolveSupportsPaths) {\n        t.equal(\n            resolve.sync('./', { basedir: basedir }),\n            require.resolve('./', { paths: [basedir] }),\n            './: resolve.sync === require.resolve'\n        );\n    }\n\n    t.equal(\n        resolve.sync('.', { basedir: basedir }),\n        path.join(dir, 'same_names/foo/index.js'),\n        '.'\n    );\n    if (requireResolveSupportsPaths) {\n        t.equal(\n            resolve.sync('.', { basedir: basedir }),\n            require.resolve('.', { paths: [basedir] }),\n            '.: resolve.sync === require.resolve',\n            { todo: true }\n        );\n    }\n\n    t.end();\n});\n\ntest('sync: #121 - treating an existing file as a dir when no basedir', function (t) {\n    var testFile = path.basename(__filename);\n\n    t.test('sanity check', function (st) {\n        st.equal(\n            resolve.sync('./' + testFile),\n            __filename,\n            'sanity check'\n        );\n        st.equal(\n            resolve.sync('./' + testFile),\n            require.resolve('./' + testFile),\n            'sanity check: resolve.sync === require.resolve'\n        );\n\n        st.end();\n    });\n\n    t.test('with a fake directory', function (st) {\n        function run() { return resolve.sync('./' + testFile + '/blah'); }\n\n        st.throws(run, 'throws an error');\n\n        try {\n            run();\n        } catch (e) {\n            st.equal(e.code, 'MODULE_NOT_FOUND', 'error code matches require.resolve');\n            st.equal(\n                e.message,\n                'Cannot find module \\'./' + testFile + '/blah\\' from \\'' + __dirname + '\\'',\n                'can not find nonexistent module'\n            );\n        }\n\n        st.end();\n    });\n\n    t.end();\n});\n\ntest('sync dot main', function (t) {\n    var start = new Date();\n\n    t.equal(\n        resolve.sync('./resolver/dot_main'),\n        path.join(__dirname, 'resolver/dot_main/index.js'),\n        './resolver/dot_main'\n    );\n    t.equal(\n        resolve.sync('./resolver/dot_main'),\n        require.resolve('./resolver/dot_main'),\n        './resolver/dot_main: resolve.sync === require.resolve'\n    );\n\n    t.ok(new Date() - start < 50, 'resolve.sync timedout');\n\n    t.end();\n});\n\ntest('sync dot slash main', function (t) {\n    var start = new Date();\n\n    t.equal(\n        resolve.sync('./resolver/dot_slash_main'),\n        path.join(__dirname, 'resolver/dot_slash_main/index.js')\n    );\n    t.equal(\n        resolve.sync('./resolver/dot_slash_main'),\n        require.resolve('./resolver/dot_slash_main'),\n        './resolver/dot_slash_main: resolve.sync === require.resolve'\n    );\n\n    t.ok(new Date() - start < 50, 'resolve.sync timedout');\n\n    t.end();\n});\n\ntest('not a directory', function (t) {\n    var path = './foo';\n    try {\n        resolve.sync(path, { basedir: __filename });\n        t.fail();\n    } catch (err) {\n        t.ok(err, 'a non-directory errors');\n        t.equal(err && err.message, 'Provided basedir \"' + __filename + '\" is not a directory, or a symlink to a directory');\n        t.equal(err && err.code, 'INVALID_BASEDIR');\n    }\n    t.end();\n});\n\ntest('non-string \"main\" field in package.json', function (t) {\n    var dir = path.join(__dirname, 'resolver');\n    try {\n        var result = resolve.sync('./invalid_main', { basedir: dir });\n        t.equal(result, undefined, 'result should not exist');\n        t.fail('should not get here');\n    } catch (err) {\n        t.ok(err, 'errors on non-string main');\n        t.equal(err.message, 'package “invalid_main” `main` must be a string');\n        t.equal(err.code, 'INVALID_PACKAGE_MAIN');\n    }\n    t.end();\n});\n\ntest('non-string \"main\" field in package.json', function (t) {\n    var dir = path.join(__dirname, 'resolver');\n    try {\n        var result = resolve.sync('./invalid_main', { basedir: dir });\n        t.equal(result, undefined, 'result should not exist');\n        t.fail('should not get here');\n    } catch (err) {\n        t.ok(err, 'errors on non-string main');\n        t.equal(err.message, 'package “invalid_main” `main` must be a string');\n        t.equal(err.code, 'INVALID_PACKAGE_MAIN');\n    }\n    t.end();\n});\n\ntest('browser field in package.json', function (t) {\n    var dir = path.join(__dirname, 'resolver');\n    var res = resolve.sync('./browser_field', {\n        basedir: dir,\n        packageFilter: function packageFilter(pkg) {\n            if (pkg.browser) {\n                pkg.main = pkg.browser; // eslint-disable-line no-param-reassign\n                delete pkg.browser; // eslint-disable-line no-param-reassign\n            }\n            return pkg;\n        }\n    });\n    t.equal(res, path.join(dir, 'browser_field', 'b.js'));\n    t.end();\n});\n\ntest('absolute paths', function (t) {\n    var extensionless = __filename.slice(0, -path.extname(__filename).length);\n\n    t.equal(\n        resolve.sync(__filename),\n        __filename,\n        'absolute path to this file resolves'\n    );\n    t.equal(\n        resolve.sync(__filename),\n        require.resolve(__filename),\n        'absolute path to this file: resolve.sync === require.resolve'\n    );\n\n    t.equal(\n        resolve.sync(extensionless),\n        __filename,\n        'extensionless absolute path to this file resolves'\n    );\n    t.equal(\n        resolve.sync(__filename),\n        require.resolve(__filename),\n        'absolute path to this file: resolve.sync === require.resolve'\n    );\n\n    t.equal(\n        resolve.sync(__filename, { basedir: process.cwd() }),\n        __filename,\n        'absolute path to this file with a basedir resolves'\n    );\n    if (requireResolveSupportsPaths) {\n        t.equal(\n            resolve.sync(__filename, { basedir: process.cwd() }),\n            require.resolve(__filename, { paths: [process.cwd()] }),\n            'absolute path to this file + basedir: resolve.sync === require.resolve'\n        );\n    }\n\n    t.equal(\n        resolve.sync(extensionless, { basedir: process.cwd() }),\n        __filename,\n        'extensionless absolute path to this file with a basedir resolves'\n    );\n    if (requireResolveSupportsPaths) {\n        t.equal(\n            resolve.sync(extensionless, { basedir: process.cwd() }),\n            require.resolve(extensionless, { paths: [process.cwd()] }),\n            'extensionless absolute path to this file + basedir: resolve.sync === require.resolve'\n        );\n    }\n\n    t.end();\n});\n\nvar malformedDir = path.join(__dirname, 'resolver/malformed_package_json');\ntest('malformed package.json', { skip: !fs.existsSync(malformedDir) }, function (t) {\n    t.plan(5 + (requireResolveSupportsPaths ? 1 : 0));\n\n    var basedir = malformedDir;\n    var expected = path.join(basedir, 'index.js');\n\n    t.equal(\n        resolve.sync('./index.js', { basedir: basedir }),\n        expected,\n        'malformed package.json is silently ignored'\n    );\n    if (requireResolveSupportsPaths) {\n        t.equal(\n            resolve.sync('./index.js', { basedir: basedir }),\n            require.resolve('./index.js', { paths: [basedir] }),\n            'malformed package.json: resolve.sync === require.resolve'\n        );\n    }\n\n    var res1 = resolve.sync(\n        './index.js',\n        {\n            basedir: basedir,\n            packageFilter: function (pkg, pkgfile, dir) {\n                t.fail('should not reach here');\n            }\n        }\n    );\n\n    t.equal(\n        res1,\n        expected,\n        'with packageFilter: malformed package.json is silently ignored'\n    );\n\n    var res2 = resolve.sync(\n        './index.js',\n        {\n            basedir: basedir,\n            readPackageSync: function (readFileSync, pkgfile) {\n                t.equal(pkgfile, path.join(basedir, 'package.json'), 'readPackageSync: `pkgfile` is package.json path');\n                var result = String(readFileSync(pkgfile));\n                try {\n                    return JSON.parse(result);\n                } catch (e) {\n                    t.ok(e instanceof SyntaxError, 'readPackageSync: malformed package.json parses as a syntax error');\n                    throw e;\n                }\n            }\n        }\n    );\n\n    t.equal(\n        res2,\n        expected,\n        'with readPackageSync: malformed package.json is silently ignored'\n    );\n});\n"
        }
    ]
}