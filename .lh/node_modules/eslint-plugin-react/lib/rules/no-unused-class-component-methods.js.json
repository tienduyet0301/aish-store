{
    "sourceFile": "node_modules/eslint-plugin-react/lib/rules/no-unused-class-component-methods.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892275490,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Prevent declaring unused methods and properties of component class\n * @author PaweÅ‚ Nowak, Berton Zhu\n */\n\n'use strict';\n\nconst docsUrl = require('../util/docsUrl');\nconst componentUtil = require('../util/componentUtil');\nconst report = require('../util/report');\n\n// ------------------------------------------------------------------------------\n// Rule Definition\n// ------------------------------------------------------------------------------\n\nconst LIFECYCLE_METHODS = new Set([\n  'constructor',\n  'componentDidCatch',\n  'componentDidMount',\n  'componentDidUpdate',\n  'componentWillMount',\n  'componentWillReceiveProps',\n  'componentWillUnmount',\n  'componentWillUpdate',\n  'getChildContext',\n  'getSnapshotBeforeUpdate',\n  'render',\n  'shouldComponentUpdate',\n  'UNSAFE_componentWillMount',\n  'UNSAFE_componentWillReceiveProps',\n  'UNSAFE_componentWillUpdate',\n]);\n\nconst ES6_LIFECYCLE = new Set([\n  'state',\n]);\n\nconst ES5_LIFECYCLE = new Set([\n  'getInitialState',\n  'getDefaultProps',\n  'mixins',\n]);\n\nfunction isKeyLiteralLike(node, property) {\n  return property.type === 'Literal'\n     || (property.type === 'TemplateLiteral' && property.expressions.length === 0)\n     || (node.computed === false && property.type === 'Identifier');\n}\n\n// Descend through all wrapping TypeCastExpressions and return the expression\n// that was cast.\nfunction uncast(node) {\n  while (node.type === 'TypeCastExpression') {\n    node = node.expression;\n  }\n  return node;\n}\n\n// Return the name of an identifier or the string value of a literal. Useful\n// anywhere that a literal may be used as a key (e.g., member expressions,\n// method definitions, ObjectExpression property keys).\nfunction getName(node) {\n  node = uncast(node);\n  const type = node.type;\n\n  if (type === 'Identifier') {\n    return node.name;\n  }\n  if (type === 'Literal') {\n    return String(node.value);\n  }\n  if (type === 'TemplateLiteral' && node.expressions.length === 0) {\n    return node.quasis[0].value.raw;\n  }\n  return null;\n}\n\nfunction isThisExpression(node) {\n  return uncast(node).type === 'ThisExpression';\n}\n\nfunction getInitialClassInfo(node, isClass) {\n  return {\n    classNode: node,\n    isClass,\n    // Set of nodes where properties were defined.\n    properties: new Set(),\n\n    // Set of names of properties that we've seen used.\n    usedProperties: new Set(),\n\n    inStatic: false,\n  };\n}\n\nconst messages = {\n  unused: 'Unused method or property \"{{name}}\"',\n  unusedWithClass: 'Unused method or property \"{{name}}\" of class \"{{className}}\"',\n};\n\n/** @type {import('eslint').Rule.RuleModule} */\nmodule.exports = {\n  meta: {\n    docs: {\n      description: 'Disallow declaring unused methods of component class',\n      category: 'Best Practices',\n      recommended: false,\n      url: docsUrl('no-unused-class-component-methods'),\n    },\n    messages,\n    schema: [],\n  },\n\n  create: ((context) => {\n    let classInfo = null;\n\n    // Takes an ObjectExpression node and adds all named Property nodes to the\n    // current set of properties.\n    function addProperty(node) {\n      classInfo.properties.add(node);\n    }\n\n    // Adds the name of the given node as a used property if the node is an\n    // Identifier or a Literal. Other node types are ignored.\n    function addUsedProperty(node) {\n      const name = getName(node);\n      if (name) {\n        classInfo.usedProperties.add(name);\n      }\n    }\n\n    function reportUnusedProperties() {\n      // Report all unused properties.\n      for (const node of classInfo.properties) { // eslint-disable-line no-restricted-syntax\n        const name = getName(node);\n        if (\n          !classInfo.usedProperties.has(name)\n           && !LIFECYCLE_METHODS.has(name)\n           && (classInfo.isClass ? !ES6_LIFECYCLE.has(name) : !ES5_LIFECYCLE.has(name))\n        ) {\n          const className = (classInfo.classNode.id && classInfo.classNode.id.name) || '';\n\n          const messageID = className ? 'unusedWithClass' : 'unused';\n          report(\n            context,\n            messages[messageID],\n            messageID,\n            {\n              node,\n              data: {\n                name,\n                className,\n              },\n            }\n          );\n        }\n      }\n    }\n\n    function exitMethod() {\n      if (!classInfo || !classInfo.inStatic) {\n        return;\n      }\n\n      classInfo.inStatic = false;\n    }\n\n    return {\n      ClassDeclaration(node) {\n        if (componentUtil.isES6Component(node, context)) {\n          classInfo = getInitialClassInfo(node, true);\n        }\n      },\n\n      ObjectExpression(node) {\n        if (componentUtil.isES5Component(node, context)) {\n          classInfo = getInitialClassInfo(node, false);\n        }\n      },\n\n      'ClassDeclaration:exit'() {\n        if (!classInfo) {\n          return;\n        }\n        reportUnusedProperties();\n        classInfo = null;\n      },\n\n      'ObjectExpression:exit'(node) {\n        if (!classInfo || classInfo.classNode !== node) {\n          return;\n        }\n        reportUnusedProperties();\n        classInfo = null;\n      },\n\n      Property(node) {\n        if (!classInfo || classInfo.classNode !== node.parent) {\n          return;\n        }\n\n        if (isKeyLiteralLike(node, node.key)) {\n          addProperty(node.key);\n        }\n      },\n\n      'ClassProperty, MethodDefinition, PropertyDefinition'(node) {\n        if (!classInfo) {\n          return;\n        }\n\n        if (node.static) {\n          classInfo.inStatic = true;\n          return;\n        }\n\n        if (isKeyLiteralLike(node, node.key)) {\n          addProperty(node.key);\n        }\n      },\n\n      'ClassProperty:exit': exitMethod,\n      'MethodDefinition:exit': exitMethod,\n      'PropertyDefinition:exit': exitMethod,\n\n      MemberExpression(node) {\n        if (!classInfo || classInfo.inStatic) {\n          return;\n        }\n\n        if (isThisExpression(node.object) && isKeyLiteralLike(node, node.property)) {\n          if (node.parent.type === 'AssignmentExpression' && node.parent.left === node) {\n            // detect `this.property = xxx`\n            addProperty(node.property);\n          } else {\n            // detect `this.property()`, `x = this.property`, etc.\n            addUsedProperty(node.property);\n          }\n        }\n      },\n\n      VariableDeclarator(node) {\n        if (!classInfo || classInfo.inStatic) {\n          return;\n        }\n\n        // detect `{ foo, bar: baz } = this`\n        if (node.init && isThisExpression(node.init) && node.id.type === 'ObjectPattern') {\n          node.id.properties\n            .filter((prop) => prop.type === 'Property' && isKeyLiteralLike(prop, prop.key))\n            .forEach((prop) => {\n              addUsedProperty('key' in prop ? prop.key : undefined);\n            });\n        }\n      },\n    };\n  }),\n};\n"
        }
    ]
}