{
    "sourceFile": "node_modules/eslint-plugin-react/lib/rules/no-direct-mutation-state.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892274140,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Prevent direct mutation of this.state\n * @author David Petersen\n * @author Nicolas Fernandez <@burabure>\n */\n\n'use strict';\n\nconst values = require('object.values');\n\nconst Components = require('../util/Components');\nconst componentUtil = require('../util/componentUtil');\nconst docsUrl = require('../util/docsUrl');\nconst report = require('../util/report');\n\n// ------------------------------------------------------------------------------\n// Rule Definition\n// ------------------------------------------------------------------------------\n\nconst messages = {\n  noDirectMutation: 'Do not mutate state directly. Use setState().',\n};\n\n/** @type {import('eslint').Rule.RuleModule} */\nmodule.exports = {\n  meta: {\n    docs: {\n      description: 'Disallow direct mutation of this.state',\n      category: 'Possible Errors',\n      recommended: true,\n      url: docsUrl('no-direct-mutation-state'),\n    },\n\n    messages,\n  },\n\n  create: Components.detect((context, components, utils) => {\n    /**\n     * Checks if the component is valid\n     * @param {Object} component The component to process\n     * @returns {boolean} True if the component is valid, false if not.\n     */\n    function isValid(component) {\n      return !!component && !component.mutateSetState;\n    }\n\n    /**\n     * Reports undeclared proptypes for a given component\n     * @param {Object} component The component to process\n     */\n    function reportMutations(component) {\n      let mutation;\n      for (let i = 0, j = component.mutations.length; i < j; i++) {\n        mutation = component.mutations[i];\n        report(context, messages.noDirectMutation, 'noDirectMutation', {\n          node: mutation,\n        });\n      }\n    }\n\n    /**\n     * Walks through the MemberExpression to the top-most property.\n     * @param {Object} node The node to process\n     * @returns {Object} The outer-most MemberExpression\n     */\n    function getOuterMemberExpression(node) {\n      while (node.object && node.object.property) {\n        node = node.object;\n      }\n      return node;\n    }\n\n    /**\n     * Determine if we should currently ignore assignments in this component.\n     * @param {?Object} component The component to process\n     * @returns {boolean} True if we should skip assignment checks.\n     */\n    function shouldIgnoreComponent(component) {\n      return !component || (component.inConstructor && !component.inCallExpression);\n    }\n\n    // --------------------------------------------------------------------------\n    // Public\n    // --------------------------------------------------------------------------\n    return {\n      MethodDefinition(node) {\n        if (node.kind === 'constructor') {\n          components.set(node, {\n            inConstructor: true,\n          });\n        }\n      },\n\n      CallExpression(node) {\n        components.set(node, {\n          inCallExpression: true,\n        });\n      },\n\n      AssignmentExpression(node) {\n        const component = components.get(utils.getParentComponent(node));\n        if (shouldIgnoreComponent(component) || !node.left || !node.left.object) {\n          return;\n        }\n        const item = getOuterMemberExpression(node.left);\n        if (componentUtil.isStateMemberExpression(item)) {\n          const mutations = (component && component.mutations) || [];\n          mutations.push(node.left.object);\n          components.set(node, {\n            mutateSetState: true,\n            mutations,\n          });\n        }\n      },\n\n      UpdateExpression(node) {\n        const component = components.get(utils.getParentComponent(node));\n        if (shouldIgnoreComponent(component) || node.argument.type !== 'MemberExpression') {\n          return;\n        }\n        const item = getOuterMemberExpression(node.argument);\n        if (componentUtil.isStateMemberExpression(item)) {\n          const mutations = (component && component.mutations) || [];\n          mutations.push(item);\n          components.set(node, {\n            mutateSetState: true,\n            mutations,\n          });\n        }\n      },\n\n      'CallExpression:exit'(node) {\n        components.set(node, {\n          inCallExpression: false,\n        });\n      },\n\n      'MethodDefinition:exit'(node) {\n        if (node.kind === 'constructor') {\n          components.set(node, {\n            inConstructor: false,\n          });\n        }\n      },\n\n      'Program:exit'() {\n        values(components.list())\n          .filter((component) => !isValid(component))\n          .forEach((component) => {\n            reportMutations(component);\n          });\n      },\n    };\n  }),\n};\n"
        }
    ]
}