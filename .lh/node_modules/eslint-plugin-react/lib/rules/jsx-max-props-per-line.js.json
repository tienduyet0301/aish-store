{
    "sourceFile": "node_modules/eslint-plugin-react/lib/rules/jsx-max-props-per-line.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892270709,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Limit maximum of props on a single line in JSX\n * @author Yannick Croissant\n */\n\n'use strict';\n\nconst docsUrl = require('../util/docsUrl');\nconst getText = require('../util/eslint').getText;\nconst report = require('../util/report');\n\nfunction getPropName(context, propNode) {\n  if (propNode.type === 'JSXSpreadAttribute') {\n    return getText(context, propNode.argument);\n  }\n  return propNode.name.name;\n}\n\n// ------------------------------------------------------------------------------\n// Rule Definition\n// ------------------------------------------------------------------------------\n\nconst messages = {\n  newLine: 'Prop `{{prop}}` must be placed on a new line',\n};\n\n/** @type {import('eslint').Rule.RuleModule} */\nmodule.exports = {\n  meta: {\n    docs: {\n      description: 'Enforce maximum of props on a single line in JSX',\n      category: 'Stylistic Issues',\n      recommended: false,\n      url: docsUrl('jsx-max-props-per-line'),\n    },\n    fixable: 'code',\n\n    messages,\n\n    schema: [{\n      anyOf: [{\n        type: 'object',\n        properties: {\n          maximum: {\n            type: 'object',\n            properties: {\n              single: {\n                type: 'integer',\n                minimum: 1,\n              },\n              multi: {\n                type: 'integer',\n                minimum: 1,\n              },\n            },\n          },\n        },\n        additionalProperties: false,\n      }, {\n        type: 'object',\n        properties: {\n          maximum: {\n            type: 'number',\n            minimum: 1,\n          },\n          when: {\n            type: 'string',\n            enum: ['always', 'multiline'],\n          },\n        },\n        additionalProperties: false,\n      }],\n    }],\n  },\n\n  create(context) {\n    const configuration = context.options[0] || {};\n    const maximum = configuration.maximum || 1;\n\n    const maxConfig = typeof maximum === 'number'\n      ? {\n        single: configuration.when === 'multiline' ? Infinity : maximum,\n        multi: maximum,\n      }\n      : {\n        single: maximum.single || Infinity,\n        multi: maximum.multi || Infinity,\n      };\n\n    function generateFixFunction(line, max) {\n      const output = [];\n      const front = line[0].range[0];\n      const back = line[line.length - 1].range[1];\n\n      for (let i = 0; i < line.length; i += max) {\n        const nodes = line.slice(i, i + max);\n        output.push(nodes.reduce((prev, curr) => {\n          if (prev === '') {\n            return getText(context, curr);\n          }\n          return `${prev} ${getText(context, curr)}`;\n        }, ''));\n      }\n\n      const code = output.join('\\n');\n\n      return function fix(fixer) {\n        return fixer.replaceTextRange([front, back], code);\n      };\n    }\n\n    return {\n      JSXOpeningElement(node) {\n        if (!node.attributes.length) {\n          return;\n        }\n\n        const isSingleLineTag = node.loc.start.line === node.loc.end.line;\n\n        if ((isSingleLineTag ? maxConfig.single : maxConfig.multi) === Infinity) {\n          return;\n        }\n\n        const firstProp = node.attributes[0];\n        const linePartitionedProps = [[firstProp]];\n\n        node.attributes.reduce((last, decl) => {\n          if (last.loc.end.line === decl.loc.start.line) {\n            linePartitionedProps[linePartitionedProps.length - 1].push(decl);\n          } else {\n            linePartitionedProps.push([decl]);\n          }\n          return decl;\n        });\n\n        linePartitionedProps.forEach((propsInLine) => {\n          const maxPropsCountPerLine = isSingleLineTag && propsInLine[0].loc.start.line === node.loc.start.line\n            ? maxConfig.single\n            : maxConfig.multi;\n\n          if (propsInLine.length > maxPropsCountPerLine) {\n            const name = getPropName(context, propsInLine[maxPropsCountPerLine]);\n            report(context, messages.newLine, 'newLine', {\n              node: propsInLine[maxPropsCountPerLine],\n              data: {\n                prop: name,\n              },\n              fix: generateFixFunction(propsInLine, maxPropsCountPerLine),\n            });\n          }\n        });\n      },\n    };\n  },\n};\n"
        }
    ]
}