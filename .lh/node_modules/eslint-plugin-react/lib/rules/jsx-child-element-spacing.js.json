{
    "sourceFile": "node_modules/eslint-plugin-react/lib/rules/jsx-child-element-spacing.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892268218,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "'use strict';\n\nconst docsUrl = require('../util/docsUrl');\nconst report = require('../util/report');\n\n// This list is taken from https://developer.mozilla.org/en-US/docs/Web/HTML/Inline_elements\n\n// Note: 'br' is not included because whitespace around br tags is inconsequential to the rendered output\nconst INLINE_ELEMENTS = new Set([\n  'a',\n  'abbr',\n  'acronym',\n  'b',\n  'bdo',\n  'big',\n  'button',\n  'cite',\n  'code',\n  'dfn',\n  'em',\n  'i',\n  'img',\n  'input',\n  'kbd',\n  'label',\n  'map',\n  'object',\n  'q',\n  'samp',\n  'script',\n  'select',\n  'small',\n  'span',\n  'strong',\n  'sub',\n  'sup',\n  'textarea',\n  'tt',\n  'var',\n]);\n\nconst messages = {\n  spacingAfterPrev: 'Ambiguous spacing after previous element {{element}}',\n  spacingBeforeNext: 'Ambiguous spacing before next element {{element}}',\n};\n\n/** @type {import('eslint').Rule.RuleModule} */\nmodule.exports = {\n  meta: {\n    docs: {\n      description: 'Enforce or disallow spaces inside of curly braces in JSX attributes and expressions',\n      category: 'Stylistic Issues',\n      recommended: false,\n      url: docsUrl('jsx-child-element-spacing'),\n    },\n    fixable: null,\n\n    messages,\n\n    schema: [],\n  },\n  create(context) {\n    const TEXT_FOLLOWING_ELEMENT_PATTERN = /^\\s*\\n\\s*\\S/;\n    const TEXT_PRECEDING_ELEMENT_PATTERN = /\\S\\s*\\n\\s*$/;\n\n    const elementName = (node) => (\n      node.openingElement\n      && node.openingElement.name\n      && node.openingElement.name.type === 'JSXIdentifier'\n      && node.openingElement.name.name\n    );\n\n    const isInlineElement = (node) => (\n      node.type === 'JSXElement'\n      && INLINE_ELEMENTS.has(elementName(node))\n    );\n\n    const handleJSX = (node) => {\n      let lastChild = null;\n      let child = null;\n      (node.children.concat([null])).forEach((nextChild) => {\n        if (\n          (lastChild || nextChild)\n          && (!lastChild || isInlineElement(lastChild))\n          && (child && (child.type === 'Literal' || child.type === 'JSXText'))\n          && (!nextChild || isInlineElement(nextChild))\n          && true\n        ) {\n          if (lastChild && child.value.match(TEXT_FOLLOWING_ELEMENT_PATTERN)) {\n            report(context, messages.spacingAfterPrev, 'spacingAfterPrev', {\n              node: lastChild,\n              loc: lastChild.loc.end,\n              data: {\n                element: elementName(lastChild),\n              },\n            });\n          } else if (nextChild && child.value.match(TEXT_PRECEDING_ELEMENT_PATTERN)) {\n            report(context, messages.spacingBeforeNext, 'spacingBeforeNext', {\n              node: nextChild,\n              loc: nextChild.loc.start,\n              data: {\n                element: elementName(nextChild),\n              },\n            });\n          }\n        }\n        lastChild = child;\n        child = nextChild;\n      });\n    };\n\n    return {\n      JSXElement: handleJSX,\n      JSXFragment: handleJSX,\n    };\n  },\n};\n"
        }
    ]
}