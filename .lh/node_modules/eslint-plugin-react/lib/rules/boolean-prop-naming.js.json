{
    "sourceFile": "node_modules/eslint-plugin-react/lib/rules/boolean-prop-naming.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892265732,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Enforces consistent naming for boolean props\n * @author Ev Haus\n */\n\n'use strict';\n\nconst flatMap = require('array.prototype.flatmap');\nconst values = require('object.values');\n\nconst Components = require('../util/Components');\nconst propsUtil = require('../util/props');\nconst astUtil = require('../util/ast');\nconst docsUrl = require('../util/docsUrl');\nconst propWrapperUtil = require('../util/propWrapper');\nconst report = require('../util/report');\nconst eslintUtil = require('../util/eslint');\n\nconst getSourceCode = eslintUtil.getSourceCode;\nconst getText = eslintUtil.getText;\n\n/**\n * Checks if prop is nested\n * @param {Object} prop Property object, single prop type declaration\n * @returns {boolean}\n */\nfunction nestedPropTypes(prop) {\n  return (\n    prop.type === 'Property'\n    && astUtil.isCallExpression(prop.value)\n  );\n}\n\n// ------------------------------------------------------------------------------\n// Rule Definition\n// ------------------------------------------------------------------------------\n\nconst messages = {\n  patternMismatch: 'Prop name `{{propName}}` doesnâ€™t match rule `{{pattern}}`',\n};\n\n/** @type {import('eslint').Rule.RuleModule} */\nmodule.exports = {\n  meta: {\n    docs: {\n      category: 'Stylistic Issues',\n      description: 'Enforces consistent naming for boolean props',\n      recommended: false,\n      url: docsUrl('boolean-prop-naming'),\n    },\n\n    messages,\n\n    schema: [{\n      additionalProperties: false,\n      properties: {\n        propTypeNames: {\n          items: {\n            type: 'string',\n          },\n          minItems: 1,\n          type: 'array',\n          uniqueItems: true,\n        },\n        rule: {\n          default: '^(is|has)[A-Z]([A-Za-z0-9]?)+',\n          minLength: 1,\n          type: 'string',\n        },\n        message: {\n          minLength: 1,\n          type: 'string',\n        },\n        validateNested: {\n          default: false,\n          type: 'boolean',\n        },\n      },\n      type: 'object',\n    }],\n  },\n\n  create: Components.detect((context, components, utils) => {\n    const config = context.options[0] || {};\n    const rule = config.rule ? new RegExp(config.rule) : null;\n    const propTypeNames = config.propTypeNames || ['bool'];\n\n    // Remembers all Flowtype object definitions\n    const objectTypeAnnotations = new Map();\n\n    /**\n     * Returns the prop key to ensure we handle the following cases:\n     * propTypes: {\n     *   full: React.PropTypes.bool,\n     *   short: PropTypes.bool,\n     *   direct: bool,\n     *   required: PropTypes.bool.isRequired\n     * }\n     * @param {Object} node The node we're getting the name of\n     * @returns {string | null}\n     */\n    function getPropKey(node) {\n      // Check for `ExperimentalSpreadProperty` (eslint 3/4) and `SpreadElement` (eslint 5)\n      // so we can skip validation of those fields.\n      // Otherwise it will look for `node.value.property` which doesn't exist and breaks eslint.\n      if (node.type === 'ExperimentalSpreadProperty' || node.type === 'SpreadElement') {\n        return null;\n      }\n      if (node.value && node.value.property) {\n        const name = node.value.property.name;\n        if (name === 'isRequired') {\n          if (node.value.object && node.value.object.property) {\n            return node.value.object.property.name;\n          }\n          return null;\n        }\n        return name;\n      }\n      if (node.value && node.value.type === 'Identifier') {\n        return node.value.name;\n      }\n      return null;\n    }\n\n    /**\n     * Returns the name of the given node (prop)\n     * @param {Object} node The node we're getting the name of\n     * @returns {string}\n     */\n    function getPropName(node) {\n      // Due to this bug https://github.com/babel/babel-eslint/issues/307\n      // we can't get the name of the Flow object key name. So we have\n      // to hack around it for now.\n      if (node.type === 'ObjectTypeProperty') {\n        return getSourceCode(context).getFirstToken(node).value;\n      }\n\n      return node.key.name;\n    }\n\n    /**\n     * Checks if prop is declared in flow way\n     * @param {Object} prop Property object, single prop type declaration\n     * @returns {boolean}\n     */\n    function flowCheck(prop) {\n      return (\n        prop.type === 'ObjectTypeProperty'\n        && prop.value.type === 'BooleanTypeAnnotation'\n        && rule.test(getPropName(prop)) === false\n      );\n    }\n\n    /**\n     * Checks if prop is declared in regular way\n     * @param {Object} prop Property object, single prop type declaration\n     * @returns {boolean}\n     */\n    function regularCheck(prop) {\n      const propKey = getPropKey(prop);\n      return (\n        propKey\n        && propTypeNames.indexOf(propKey) >= 0\n        && rule.test(getPropName(prop)) === false\n      );\n    }\n\n    function tsCheck(prop) {\n      if (prop.type !== 'TSPropertySignature') return false;\n      const typeAnnotation = (prop.typeAnnotation || {}).typeAnnotation;\n      return (\n        typeAnnotation\n        && typeAnnotation.type === 'TSBooleanKeyword'\n        && rule.test(getPropName(prop)) === false\n      );\n    }\n\n    /**\n     * Runs recursive check on all proptypes\n     * @param {Array} proptypes A list of Property object (for each proptype defined)\n     * @param {Function} addInvalidProp callback to run for each error\n     */\n    function runCheck(proptypes, addInvalidProp) {\n      if (proptypes) {\n        proptypes.forEach((prop) => {\n          if (config.validateNested && nestedPropTypes(prop)) {\n            runCheck(prop.value.arguments[0].properties, addInvalidProp);\n            return;\n          }\n          if (flowCheck(prop) || regularCheck(prop) || tsCheck(prop)) {\n            addInvalidProp(prop);\n          }\n        });\n      }\n    }\n\n    /**\n     * Checks and mark props with invalid naming\n     * @param {Object} node The component node we're testing\n     * @param {Array} proptypes A list of Property object (for each proptype defined)\n     */\n    function validatePropNaming(node, proptypes) {\n      const component = components.get(node) || node;\n      const invalidProps = component.invalidProps || [];\n\n      runCheck(proptypes, (prop) => {\n        invalidProps.push(prop);\n      });\n\n      components.set(node, {\n        invalidProps,\n      });\n    }\n\n    /**\n     * Reports invalid prop naming\n     * @param {Object} component The component to process\n     */\n    function reportInvalidNaming(component) {\n      component.invalidProps.forEach((propNode) => {\n        const propName = getPropName(propNode);\n        report(context, config.message || messages.patternMismatch, !config.message && 'patternMismatch', {\n          node: propNode,\n          data: {\n            component: propName,\n            propName,\n            pattern: config.rule,\n          },\n        });\n      });\n    }\n\n    function checkPropWrapperArguments(node, args) {\n      if (!node || !Array.isArray(args)) {\n        return;\n      }\n      args.filter((arg) => arg.type === 'ObjectExpression').forEach((object) => validatePropNaming(node, object.properties));\n    }\n\n    function getComponentTypeAnnotation(component) {\n      // If this is a functional component that uses a global type, check it\n      if (\n        (component.node.type === 'FunctionDeclaration' || component.node.type === 'ArrowFunctionExpression')\n        && component.node.params\n        && component.node.params.length > 0\n        && component.node.params[0].typeAnnotation\n      ) {\n        return component.node.params[0].typeAnnotation.typeAnnotation;\n      }\n\n      if (\n        !component.node.parent\n        || component.node.parent.type !== 'VariableDeclarator'\n        || !component.node.parent.id\n        || component.node.parent.id.type !== 'Identifier'\n        || !component.node.parent.id.typeAnnotation\n        || !component.node.parent.id.typeAnnotation.typeAnnotation\n      ) {\n        return;\n      }\n\n      const annotationTypeArguments = propsUtil.getTypeArguments(\n        component.node.parent.id.typeAnnotation.typeAnnotation\n      );\n      if (\n        annotationTypeArguments && (\n          annotationTypeArguments.type === 'TSTypeParameterInstantiation'\n          || annotationTypeArguments.type === 'TypeParameterInstantiation'\n        )\n      ) {\n        return annotationTypeArguments.params.find(\n          (param) => param.type === 'TSTypeReference' || param.type === 'GenericTypeAnnotation'\n        );\n      }\n    }\n\n    function findAllTypeAnnotations(identifier, node) {\n      if (node.type === 'TSTypeLiteral' || node.type === 'ObjectTypeAnnotation' || node.type === 'TSInterfaceBody') {\n        const currentNode = [].concat(\n          objectTypeAnnotations.get(identifier.name) || [],\n          node\n        );\n        objectTypeAnnotations.set(identifier.name, currentNode);\n      } else if (\n        node.type === 'TSParenthesizedType'\n        && (\n          node.typeAnnotation.type === 'TSIntersectionType'\n          || node.typeAnnotation.type === 'TSUnionType'\n        )\n      ) {\n        node.typeAnnotation.types.forEach((type) => {\n          findAllTypeAnnotations(identifier, type);\n        });\n      } else if (\n        node.type === 'TSIntersectionType'\n        || node.type === 'TSUnionType'\n        || node.type === 'IntersectionTypeAnnotation'\n        || node.type === 'UnionTypeAnnotation'\n      ) {\n        node.types.forEach((type) => {\n          findAllTypeAnnotations(identifier, type);\n        });\n      }\n    }\n\n    // --------------------------------------------------------------------------\n    // Public\n    // --------------------------------------------------------------------------\n\n    return {\n      'ClassProperty, PropertyDefinition'(node) {\n        if (!rule || !propsUtil.isPropTypesDeclaration(node)) {\n          return;\n        }\n        if (\n          node.value\n          && astUtil.isCallExpression(node.value)\n          && propWrapperUtil.isPropWrapperFunction(\n            context,\n            getText(context, node.value.callee)\n          )\n        ) {\n          checkPropWrapperArguments(node, node.value.arguments);\n        }\n        if (node.value && node.value.properties) {\n          validatePropNaming(node, node.value.properties);\n        }\n        if (node.typeAnnotation && node.typeAnnotation.typeAnnotation) {\n          validatePropNaming(node, node.typeAnnotation.typeAnnotation.properties);\n        }\n      },\n\n      MemberExpression(node) {\n        if (!rule || !propsUtil.isPropTypesDeclaration(node)) {\n          return;\n        }\n        const component = utils.getRelatedComponent(node);\n        if (!component || !node.parent.right) {\n          return;\n        }\n        const right = node.parent.right;\n        if (\n          astUtil.isCallExpression(right)\n          && propWrapperUtil.isPropWrapperFunction(\n            context,\n            getText(context, right.callee)\n          )\n        ) {\n          checkPropWrapperArguments(component.node, right.arguments);\n          return;\n        }\n        validatePropNaming(component.node, node.parent.right.properties);\n      },\n\n      ObjectExpression(node) {\n        if (!rule) {\n          return;\n        }\n\n        // Search for the proptypes declaration\n        node.properties.forEach((property) => {\n          if (!propsUtil.isPropTypesDeclaration(property)) {\n            return;\n          }\n          validatePropNaming(node, property.value.properties);\n        });\n      },\n\n      TypeAlias(node) {\n        findAllTypeAnnotations(node.id, node.right);\n      },\n\n      TSTypeAliasDeclaration(node) {\n        findAllTypeAnnotations(node.id, node.typeAnnotation);\n      },\n\n      TSInterfaceDeclaration(node) {\n        findAllTypeAnnotations(node.id, node.body);\n      },\n\n      // eslint-disable-next-line object-shorthand\n      'Program:exit'() {\n        if (!rule) {\n          return;\n        }\n\n        values(components.list()).forEach((component) => {\n          const annotation = getComponentTypeAnnotation(component);\n\n          if (annotation) {\n            let propType;\n            if (annotation.type === 'GenericTypeAnnotation') {\n              propType = objectTypeAnnotations.get(annotation.id.name);\n            } else if (annotation.type === 'ObjectTypeAnnotation' || annotation.type === 'TSTypeLiteral') {\n              propType = annotation;\n            } else if (annotation.type === 'TSTypeReference') {\n              propType = objectTypeAnnotations.get(annotation.typeName.name);\n            } else if (annotation.type === 'TSIntersectionType') {\n              propType = flatMap(annotation.types, (type) => (\n                type.type === 'TSTypeReference'\n                  ? objectTypeAnnotations.get(type.typeName.name)\n                  : type\n              ));\n            }\n\n            if (propType) {\n              [].concat(propType).filter(Boolean).forEach((prop) => {\n                validatePropNaming(\n                  component.node,\n                  prop.properties || prop.members || prop.body\n                );\n              });\n            }\n          }\n\n          if (component.invalidProps && component.invalidProps.length > 0) {\n            reportInvalidNaming(component);\n          }\n        });\n\n        // Reset cache\n        objectTypeAnnotations.clear();\n      },\n    };\n  }),\n};\n"
        }
    ]
}