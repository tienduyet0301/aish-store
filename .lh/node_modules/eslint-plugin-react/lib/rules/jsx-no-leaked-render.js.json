{
    "sourceFile": "node_modules/eslint-plugin-react/lib/rules/jsx-no-leaked-render.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892271496,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Prevent problematic leaked values from being rendered\n * @author Mario BeltrÃ¡n\n */\n\n'use strict';\n\nconst find = require('es-iterator-helpers/Iterator.prototype.find');\nconst from = require('es-iterator-helpers/Iterator.from');\n\nconst getText = require('../util/eslint').getText;\nconst docsUrl = require('../util/docsUrl');\nconst report = require('../util/report');\nconst variableUtil = require('../util/variable');\nconst testReactVersion = require('../util/version').testReactVersion;\nconst isParenthesized = require('../util/ast').isParenthesized;\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nconst messages = {\n  noPotentialLeakedRender: 'Potential leaked value that might cause unintentionally rendered values or rendering crashes',\n};\n\nconst COERCE_STRATEGY = 'coerce';\nconst TERNARY_STRATEGY = 'ternary';\nconst DEFAULT_VALID_STRATEGIES = [TERNARY_STRATEGY, COERCE_STRATEGY];\nconst COERCE_VALID_LEFT_SIDE_EXPRESSIONS = ['UnaryExpression', 'BinaryExpression', 'CallExpression'];\nconst TERNARY_INVALID_ALTERNATE_VALUES = [undefined, null, false];\n\nfunction trimLeftNode(node) {\n  // Remove double unary expression (boolean coercion), so we avoid trimming valid negations\n  if (node.type === 'UnaryExpression' && node.argument.type === 'UnaryExpression') {\n    return trimLeftNode(node.argument.argument);\n  }\n\n  return node;\n}\n\nfunction getIsCoerceValidNestedLogicalExpression(node) {\n  if (node.type === 'LogicalExpression') {\n    return getIsCoerceValidNestedLogicalExpression(node.left) && getIsCoerceValidNestedLogicalExpression(node.right);\n  }\n\n  return COERCE_VALID_LEFT_SIDE_EXPRESSIONS.some((validExpression) => validExpression === node.type);\n}\n\nfunction extractExpressionBetweenLogicalAnds(node) {\n  if (node.type !== 'LogicalExpression') return [node];\n  if (node.operator !== '&&') return [node];\n  return [].concat(\n    extractExpressionBetweenLogicalAnds(node.left),\n    extractExpressionBetweenLogicalAnds(node.right)\n  );\n}\n\nfunction ruleFixer(context, fixStrategy, fixer, reportedNode, leftNode, rightNode) {\n  const rightSideText = getText(context, rightNode);\n\n  if (fixStrategy === COERCE_STRATEGY) {\n    const expressions = extractExpressionBetweenLogicalAnds(leftNode);\n    const newText = expressions.map((node) => {\n      let nodeText = getText(context, node);\n      if (isParenthesized(context, node)) {\n        nodeText = `(${nodeText})`;\n      }\n      if (node.parent && node.parent.type === 'ConditionalExpression' && node.parent.consequent.value === false) {\n        return `${getIsCoerceValidNestedLogicalExpression(node) ? '' : '!'}${nodeText}`;\n      }\n      return `${getIsCoerceValidNestedLogicalExpression(node) ? '' : '!!'}${nodeText}`;\n    }).join(' && ');\n\n    if (rightNode.parent && rightNode.parent.type === 'ConditionalExpression' && rightNode.parent.consequent.value === false) {\n      const consequentVal = rightNode.parent.consequent.raw || rightNode.parent.consequent.name;\n      const alternateVal = rightNode.parent.alternate.raw || rightNode.parent.alternate.name;\n      if (rightNode.parent.test && rightNode.parent.test.type === 'LogicalExpression') {\n        return fixer.replaceText(reportedNode, `${newText} ? ${consequentVal} : ${alternateVal}`);\n      }\n      return fixer.replaceText(reportedNode, `${newText} && ${alternateVal}`);\n    }\n\n    if (rightNode.type === 'ConditionalExpression' || rightNode.type === 'LogicalExpression') {\n      return fixer.replaceText(reportedNode, `${newText} && (${rightSideText})`);\n    }\n    if (rightNode.type === 'JSXElement') {\n      const rightSideTextLines = rightSideText.split('\\n');\n      if (rightSideTextLines.length > 1) {\n        const rightSideTextLastLine = rightSideTextLines[rightSideTextLines.length - 1];\n        const indentSpacesStart = ' '.repeat(rightSideTextLastLine.search(/\\S/));\n        const indentSpacesClose = ' '.repeat(rightSideTextLastLine.search(/\\S/) - 2);\n        return fixer.replaceText(reportedNode, `${newText} && (\\n${indentSpacesStart}${rightSideText}\\n${indentSpacesClose})`);\n      }\n    }\n    if (rightNode.type === 'Literal') {\n      return null;\n    }\n    return fixer.replaceText(reportedNode, `${newText} && ${rightSideText}`);\n  }\n\n  if (fixStrategy === TERNARY_STRATEGY) {\n    let leftSideText = getText(context, trimLeftNode(leftNode));\n    if (isParenthesized(context, leftNode)) {\n      leftSideText = `(${leftSideText})`;\n    }\n    return fixer.replaceText(reportedNode, `${leftSideText} ? ${rightSideText} : null`);\n  }\n\n  throw new TypeError('Invalid value for \"validStrategies\" option');\n}\n\n/** @type {import('eslint').Rule.RuleModule} */\nmodule.exports = {\n  meta: {\n    docs: {\n      description: 'Disallow problematic leaked values from being rendered',\n      category: 'Possible Errors',\n      recommended: false,\n      url: docsUrl('jsx-no-leaked-render'),\n    },\n\n    messages,\n\n    fixable: 'code',\n    schema: [\n      {\n        type: 'object',\n        properties: {\n          validStrategies: {\n            type: 'array',\n            items: {\n              enum: [\n                TERNARY_STRATEGY,\n                COERCE_STRATEGY,\n              ],\n            },\n            uniqueItems: true,\n            default: DEFAULT_VALID_STRATEGIES,\n          },\n        },\n        additionalProperties: false,\n      },\n    ],\n  },\n\n  create(context) {\n    const config = context.options[0] || {};\n    const validStrategies = new Set(config.validStrategies || DEFAULT_VALID_STRATEGIES);\n    const fixStrategy = find(from(validStrategies), () => true);\n\n    return {\n      'JSXExpressionContainer > LogicalExpression[operator=\"&&\"]'(node) {\n        const leftSide = node.left;\n\n        const isCoerceValidLeftSide = COERCE_VALID_LEFT_SIDE_EXPRESSIONS\n          .some((validExpression) => validExpression === leftSide.type);\n        if (validStrategies.has(COERCE_STRATEGY)) {\n          if (isCoerceValidLeftSide || getIsCoerceValidNestedLogicalExpression(leftSide)) {\n            return;\n          }\n          const leftSideVar = variableUtil.getVariableFromContext(context, node, leftSide.name);\n          if (leftSideVar) {\n            const leftSideValue = leftSideVar.defs\n              && leftSideVar.defs.length\n              && leftSideVar.defs[0].node.init\n              && leftSideVar.defs[0].node.init.value;\n            if (typeof leftSideValue === 'boolean') {\n              return;\n            }\n          }\n        }\n\n        if (testReactVersion(context, '>= 18') && leftSide.type === 'Literal' && leftSide.value === '') {\n          return;\n        }\n        report(context, messages.noPotentialLeakedRender, 'noPotentialLeakedRender', {\n          node,\n          fix(fixer) {\n            return ruleFixer(context, fixStrategy, fixer, node, leftSide, node.right);\n          },\n        });\n      },\n\n      'JSXExpressionContainer > ConditionalExpression'(node) {\n        if (validStrategies.has(TERNARY_STRATEGY)) {\n          return;\n        }\n\n        const isValidTernaryAlternate = TERNARY_INVALID_ALTERNATE_VALUES.indexOf(node.alternate.value) === -1;\n        const isJSXElementAlternate = node.alternate.type === 'JSXElement';\n        if (isValidTernaryAlternate || isJSXElementAlternate) {\n          return;\n        }\n\n        report(context, messages.noPotentialLeakedRender, 'noPotentialLeakedRender', {\n          node,\n          fix(fixer) {\n            return ruleFixer(context, fixStrategy, fixer, node, node.test, node.consequent);\n          },\n        });\n      },\n    };\n  },\n};\n"
        }
    ]
}