{
    "sourceFile": "node_modules/eslint-plugin-react/lib/rules/jsx-no-useless-fragment.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892271913,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Disallow useless fragments\n */\n\n'use strict';\n\nconst arrayIncludes = require('array-includes');\n\nconst pragmaUtil = require('../util/pragma');\nconst astUtil = require('../util/ast');\nconst jsxUtil = require('../util/jsx');\nconst docsUrl = require('../util/docsUrl');\nconst report = require('../util/report');\nconst getText = require('../util/eslint').getText;\n\nfunction isJSXText(node) {\n  return !!node && (node.type === 'JSXText' || node.type === 'Literal');\n}\n\n/**\n * @param {string} text\n * @returns {boolean}\n */\nfunction isOnlyWhitespace(text) {\n  return text.trim().length === 0;\n}\n\n/**\n * @param {ASTNode} node\n * @returns {boolean}\n */\nfunction isNonspaceJSXTextOrJSXCurly(node) {\n  return (isJSXText(node) && !isOnlyWhitespace(node.raw)) || node.type === 'JSXExpressionContainer';\n}\n\n/**\n * Somehow fragment like this is useful: <Foo content={<>ee eeee eeee ...</>} />\n * @param {ASTNode} node\n * @returns {boolean}\n */\nfunction isFragmentWithOnlyTextAndIsNotChild(node) {\n  return node.children.length === 1\n    && isJSXText(node.children[0])\n    && !(node.parent.type === 'JSXElement' || node.parent.type === 'JSXFragment');\n}\n\n/**\n * @param {string} text\n * @returns {string}\n */\nfunction trimLikeReact(text) {\n  const leadingSpaces = /^\\s*/.exec(text)[0];\n  const trailingSpaces = /\\s*$/.exec(text)[0];\n\n  const start = arrayIncludes(leadingSpaces, '\\n') ? leadingSpaces.length : 0;\n  const end = arrayIncludes(trailingSpaces, '\\n') ? text.length - trailingSpaces.length : text.length;\n\n  return text.slice(start, end);\n}\n\n/**\n * Test if node is like `<Fragment key={_}>_</Fragment>`\n * @param {JSXElement} node\n * @returns {boolean}\n */\nfunction isKeyedElement(node) {\n  return node.type === 'JSXElement'\n    && node.openingElement.attributes\n    && node.openingElement.attributes.some(jsxUtil.isJSXAttributeKey);\n}\n\n/**\n * @param {ASTNode} node\n * @returns {boolean}\n */\nfunction containsCallExpression(node) {\n  return node\n    && node.type === 'JSXExpressionContainer'\n    && astUtil.isCallExpression(node.expression);\n}\n\nconst messages = {\n  NeedsMoreChildren: 'Fragments should contain more than one child - otherwise, thereâ€™s no need for a Fragment at all.',\n  ChildOfHtmlElement: 'Passing a fragment to an HTML element is useless.',\n};\n\n/** @type {import('eslint').Rule.RuleModule} */\nmodule.exports = {\n  meta: {\n    type: 'suggestion',\n    fixable: 'code',\n    docs: {\n      description: 'Disallow unnecessary fragments',\n      category: 'Possible Errors',\n      recommended: false,\n      url: docsUrl('jsx-no-useless-fragment'),\n    },\n    messages,\n    schema: [{\n      type: 'object',\n      properties: {\n        allowExpressions: {\n          type: 'boolean',\n        },\n      },\n    }],\n  },\n\n  create(context) {\n    const config = context.options[0] || {};\n    const allowExpressions = config.allowExpressions || false;\n\n    const reactPragma = pragmaUtil.getFromContext(context);\n    const fragmentPragma = pragmaUtil.getFragmentFromContext(context);\n\n    /**\n     * Test whether a node is an padding spaces trimmed by react runtime.\n     * @param {ASTNode} node\n     * @returns {boolean}\n     */\n    function isPaddingSpaces(node) {\n      return isJSXText(node)\n        && isOnlyWhitespace(node.raw)\n        && arrayIncludes(node.raw, '\\n');\n    }\n\n    function isFragmentWithSingleExpression(node) {\n      const children = node && node.children.filter((child) => !isPaddingSpaces(child));\n      return (\n        children\n        && children.length === 1\n        && children[0].type === 'JSXExpressionContainer'\n      );\n    }\n\n    /**\n     * Test whether a JSXElement has less than two children, excluding paddings spaces.\n     * @param {JSXElement|JSXFragment} node\n     * @returns {boolean}\n     */\n    function hasLessThanTwoChildren(node) {\n      if (!node || !node.children) {\n        return true;\n      }\n\n      /** @type {ASTNode[]} */\n      const nonPaddingChildren = node.children.filter(\n        (child) => !isPaddingSpaces(child)\n      );\n\n      if (nonPaddingChildren.length < 2) {\n        return !containsCallExpression(nonPaddingChildren[0]);\n      }\n    }\n\n    /**\n     * @param {JSXElement|JSXFragment} node\n     * @returns {boolean}\n     */\n    function isChildOfHtmlElement(node) {\n      return node.parent.type === 'JSXElement'\n        && node.parent.openingElement.name.type === 'JSXIdentifier'\n        && /^[a-z]+$/.test(node.parent.openingElement.name.name);\n    }\n\n    /**\n     * @param {JSXElement|JSXFragment} node\n     * @return {boolean}\n     */\n    function isChildOfComponentElement(node) {\n      return node.parent.type === 'JSXElement'\n        && !isChildOfHtmlElement(node)\n        && !jsxUtil.isFragment(node.parent, reactPragma, fragmentPragma);\n    }\n\n    /**\n     * @param {ASTNode} node\n     * @returns {boolean}\n     */\n    function canFix(node) {\n      // Not safe to fix fragments without a jsx parent.\n      if (!(node.parent.type === 'JSXElement' || node.parent.type === 'JSXFragment')) {\n        // const a = <></>\n        if (node.children.length === 0) {\n          return false;\n        }\n\n        // const a = <>cat {meow}</>\n        if (node.children.some(isNonspaceJSXTextOrJSXCurly)) {\n          return false;\n        }\n      }\n\n      // Not safe to fix `<Eeee><>foo</></Eeee>` because `Eeee` might require its children be a ReactElement.\n      if (isChildOfComponentElement(node)) {\n        return false;\n      }\n\n      // old TS parser can't handle this one\n      if (node.type === 'JSXFragment' && (!node.openingFragment || !node.closingFragment)) {\n        return false;\n      }\n\n      return true;\n    }\n\n    /**\n     * @param {ASTNode} node\n     * @returns {Function | undefined}\n     */\n    function getFix(node) {\n      if (!canFix(node)) {\n        return undefined;\n      }\n\n      return function fix(fixer) {\n        const opener = node.type === 'JSXFragment' ? node.openingFragment : node.openingElement;\n        const closer = node.type === 'JSXFragment' ? node.closingFragment : node.closingElement;\n\n        const childrenText = opener.selfClosing ? '' : getText(context).slice(opener.range[1], closer.range[0]);\n\n        return fixer.replaceText(node, trimLikeReact(childrenText));\n      };\n    }\n\n    function checkNode(node) {\n      if (isKeyedElement(node)) {\n        return;\n      }\n\n      if (\n        hasLessThanTwoChildren(node)\n        && !isFragmentWithOnlyTextAndIsNotChild(node)\n        && !(allowExpressions && isFragmentWithSingleExpression(node))\n      ) {\n        report(context, messages.NeedsMoreChildren, 'NeedsMoreChildren', {\n          node,\n          fix: getFix(node),\n        });\n      }\n\n      if (isChildOfHtmlElement(node)) {\n        report(context, messages.ChildOfHtmlElement, 'ChildOfHtmlElement', {\n          node,\n          fix: getFix(node),\n        });\n      }\n    }\n\n    return {\n      JSXElement(node) {\n        if (jsxUtil.isFragment(node, reactPragma, fragmentPragma)) {\n          checkNode(node);\n        }\n      },\n      JSXFragment: checkNode,\n    };\n  },\n};\n"
        }
    ]
}