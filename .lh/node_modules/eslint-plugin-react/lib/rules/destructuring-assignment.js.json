{
    "sourceFile": "node_modules/eslint-plugin-react/lib/rules/destructuring-assignment.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892266130,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Enforce consistent usage of destructuring assignment of props, state, and context.\n */\n\n'use strict';\n\nconst Components = require('../util/Components');\nconst docsUrl = require('../util/docsUrl');\nconst eslintUtil = require('../util/eslint');\nconst isAssignmentLHS = require('../util/ast').isAssignmentLHS;\nconst report = require('../util/report');\n\nconst getScope = eslintUtil.getScope;\nconst getText = eslintUtil.getText;\n\nconst DEFAULT_OPTION = 'always';\n\nfunction createSFCParams() {\n  const queue = [];\n\n  return {\n    push(params) {\n      queue.unshift(params);\n    },\n    pop() {\n      queue.shift();\n    },\n    propsName() {\n      const found = queue.find((params) => {\n        const props = params[0];\n        return props && !props.destructuring && props.name;\n      });\n      return found && found[0] && found[0].name;\n    },\n    contextName() {\n      const found = queue.find((params) => {\n        const context = params[1];\n        return context && !context.destructuring && context.name;\n      });\n      return found && found[1] && found[1].name;\n    },\n  };\n}\n\nfunction evalParams(params) {\n  return params.map((param) => ({\n    destructuring: param.type === 'ObjectPattern',\n    name: param.type === 'Identifier' && param.name,\n  }));\n}\n\nconst messages = {\n  noDestructPropsInSFCArg: 'Must never use destructuring props assignment in SFC argument',\n  noDestructContextInSFCArg: 'Must never use destructuring context assignment in SFC argument',\n  noDestructAssignment: 'Must never use destructuring {{type}} assignment',\n  useDestructAssignment: 'Must use destructuring {{type}} assignment',\n  destructureInSignature: 'Must destructure props in the function signature.',\n};\n\n/** @type {import('eslint').Rule.RuleModule} */\nmodule.exports = {\n  meta: {\n    docs: {\n      description: 'Enforce consistent usage of destructuring assignment of props, state, and context',\n      category: 'Stylistic Issues',\n      recommended: false,\n      url: docsUrl('destructuring-assignment'),\n    },\n    fixable: 'code',\n    messages,\n\n    schema: [{\n      type: 'string',\n      enum: [\n        'always',\n        'never',\n      ],\n    }, {\n      type: 'object',\n      properties: {\n        ignoreClassFields: {\n          type: 'boolean',\n        },\n        destructureInSignature: {\n          type: 'string',\n          enum: [\n            'always',\n            'ignore',\n          ],\n        },\n      },\n      additionalProperties: false,\n    }],\n  },\n\n  create: Components.detect((context, components, utils) => {\n    const configuration = context.options[0] || DEFAULT_OPTION;\n    const ignoreClassFields = (context.options[1] && (context.options[1].ignoreClassFields === true)) || false;\n    const destructureInSignature = (context.options[1] && context.options[1].destructureInSignature) || 'ignore';\n    const sfcParams = createSFCParams();\n\n    /**\n     * @param {ASTNode} node We expect either an ArrowFunctionExpression,\n     *   FunctionDeclaration, or FunctionExpression\n     */\n    function handleStatelessComponent(node) {\n      const params = evalParams(node.params);\n\n      const SFCComponent = components.get(getScope(context, node).block);\n      if (!SFCComponent) {\n        return;\n      }\n      sfcParams.push(params);\n\n      if (params[0] && params[0].destructuring && components.get(node) && configuration === 'never') {\n        report(context, messages.noDestructPropsInSFCArg, 'noDestructPropsInSFCArg', {\n          node,\n        });\n      } else if (params[1] && params[1].destructuring && components.get(node) && configuration === 'never') {\n        report(context, messages.noDestructContextInSFCArg, 'noDestructContextInSFCArg', {\n          node,\n        });\n      }\n    }\n\n    function handleStatelessComponentExit(node) {\n      const SFCComponent = components.get(getScope(context, node).block);\n      if (SFCComponent) {\n        sfcParams.pop();\n      }\n    }\n\n    function handleSFCUsage(node) {\n      const propsName = sfcParams.propsName();\n      const contextName = sfcParams.contextName();\n      // props.aProp || context.aProp\n      const isPropUsed = (\n        (propsName && node.object.name === propsName)\n          || (contextName && node.object.name === contextName)\n      )\n        && !isAssignmentLHS(node);\n      if (isPropUsed && configuration === 'always' && !node.optional) {\n        report(context, messages.useDestructAssignment, 'useDestructAssignment', {\n          node,\n          data: {\n            type: node.object.name,\n          },\n        });\n      }\n    }\n\n    function isInClassProperty(node) {\n      let curNode = node.parent;\n      while (curNode) {\n        if (curNode.type === 'ClassProperty' || curNode.type === 'PropertyDefinition') {\n          return true;\n        }\n        curNode = curNode.parent;\n      }\n      return false;\n    }\n\n    function handleClassUsage(node) {\n      // this.props.Aprop || this.context.aProp || this.state.aState\n      const isPropUsed = (\n        node.object.type === 'MemberExpression' && node.object.object.type === 'ThisExpression'\n        && (node.object.property.name === 'props' || node.object.property.name === 'context' || node.object.property.name === 'state')\n        && !isAssignmentLHS(node)\n      );\n\n      if (\n        isPropUsed && configuration === 'always'\n        && !(ignoreClassFields && isInClassProperty(node))\n      ) {\n        report(context, messages.useDestructAssignment, 'useDestructAssignment', {\n          node,\n          data: {\n            type: node.object.property.name,\n          },\n        });\n      }\n    }\n\n    // valid-jsdoc cannot read function types\n    // eslint-disable-next-line valid-jsdoc\n    /**\n     * Find a parent that satisfy the given predicate\n     * @param {ASTNode} node\n     * @param {(node: ASTNode) => boolean} predicate\n     * @returns {ASTNode | undefined}\n     */\n    function findParent(node, predicate) {\n      let n = node;\n      while (n) {\n        if (predicate(n)) {\n          return n;\n        }\n        n = n.parent;\n      }\n      return undefined;\n    }\n\n    return {\n\n      FunctionDeclaration: handleStatelessComponent,\n\n      ArrowFunctionExpression: handleStatelessComponent,\n\n      FunctionExpression: handleStatelessComponent,\n\n      'FunctionDeclaration:exit': handleStatelessComponentExit,\n\n      'ArrowFunctionExpression:exit': handleStatelessComponentExit,\n\n      'FunctionExpression:exit': handleStatelessComponentExit,\n\n      MemberExpression(node) {\n        const SFCComponent = utils.getParentStatelessComponent(node);\n        if (SFCComponent) {\n          handleSFCUsage(node);\n        }\n\n        const classComponent = utils.getParentComponent(node);\n        if (classComponent) {\n          handleClassUsage(node);\n        }\n      },\n\n      TSQualifiedName(node) {\n        if (configuration !== 'always') {\n          return;\n        }\n        // handle `typeof props.a.b`\n        if (node.left.type === 'Identifier'\n          && node.left.name === sfcParams.propsName()\n          && findParent(node, (n) => n.type === 'TSTypeQuery')\n          && utils.getParentStatelessComponent(node)\n        ) {\n          report(context, messages.useDestructAssignment, 'useDestructAssignment', {\n            node,\n            data: {\n              type: 'props',\n            },\n          });\n        }\n      },\n\n      VariableDeclarator(node) {\n        const classComponent = utils.getParentComponent(node);\n        const SFCComponent = components.get(getScope(context, node).block);\n\n        const destructuring = (node.init && node.id && node.id.type === 'ObjectPattern');\n        // let {foo} = props;\n        const destructuringSFC = destructuring && (node.init.name === 'props' || node.init.name === 'context');\n        // let {foo} = this.props;\n        const destructuringClass = destructuring && node.init.object && node.init.object.type === 'ThisExpression' && (\n          node.init.property.name === 'props' || node.init.property.name === 'context' || node.init.property.name === 'state'\n        );\n\n        if (SFCComponent && destructuringSFC && configuration === 'never') {\n          report(context, messages.noDestructAssignment, 'noDestructAssignment', {\n            node,\n            data: {\n              type: node.init.name,\n            },\n          });\n        }\n\n        if (\n          classComponent && destructuringClass && configuration === 'never'\n          && !(ignoreClassFields && (node.parent.type === 'ClassProperty' || node.parent.type === 'PropertyDefinition'))\n        ) {\n          report(context, messages.noDestructAssignment, 'noDestructAssignment', {\n            node,\n            data: {\n              type: node.init.property.name,\n            },\n          });\n        }\n\n        if (\n          SFCComponent\n          && destructuringSFC\n          && configuration === 'always'\n          && destructureInSignature === 'always'\n          && node.init.name === 'props'\n        ) {\n          const scopeSetProps = getScope(context, node).set.get('props');\n          const propsRefs = scopeSetProps && scopeSetProps.references;\n          if (!propsRefs) {\n            return;\n          }\n\n          // Skip if props is used elsewhere\n          if (propsRefs.length > 1) {\n            return;\n          }\n          report(context, messages.destructureInSignature, 'destructureInSignature', {\n            node,\n            fix(fixer) {\n              const param = SFCComponent.node.params[0];\n              if (!param) {\n                return;\n              }\n              const replaceRange = [\n                param.range[0],\n                param.typeAnnotation ? param.typeAnnotation.range[0] : param.range[1],\n              ];\n              return [\n                fixer.replaceTextRange(replaceRange, getText(context, node.id)),\n                fixer.remove(node.parent),\n              ];\n            },\n          });\n        }\n      },\n    };\n  }),\n};\n"
        }
    ]
}