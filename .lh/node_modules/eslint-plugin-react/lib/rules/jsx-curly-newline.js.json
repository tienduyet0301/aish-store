{
    "sourceFile": "node_modules/eslint-plugin-react/lib/rules/jsx-curly-newline.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892268798,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview enforce consistent line breaks inside jsx curly\n */\n\n'use strict';\n\nconst docsUrl = require('../util/docsUrl');\nconst eslintUtil = require('../util/eslint');\nconst report = require('../util/report');\n\nconst getSourceCode = eslintUtil.getSourceCode;\nconst getText = eslintUtil.getText;\n\n// ------------------------------------------------------------------------------\n// Rule Definition\n// ------------------------------------------------------------------------------\n\nfunction getNormalizedOption(context) {\n  const rawOption = context.options[0] || 'consistent';\n\n  if (rawOption === 'consistent') {\n    return {\n      multiline: 'consistent',\n      singleline: 'consistent',\n    };\n  }\n\n  if (rawOption === 'never') {\n    return {\n      multiline: 'forbid',\n      singleline: 'forbid',\n    };\n  }\n\n  return {\n    multiline: rawOption.multiline || 'consistent',\n    singleline: rawOption.singleline || 'consistent',\n  };\n}\n\nconst messages = {\n  expectedBefore: 'Expected newline before \\'}\\'.',\n  expectedAfter: 'Expected newline after \\'{\\'.',\n  unexpectedBefore: 'Unexpected newline before \\'}\\'.',\n  unexpectedAfter: 'Unexpected newline after \\'{\\'.',\n};\n\n/** @type {import('eslint').Rule.RuleModule} */\nmodule.exports = {\n  meta: {\n    type: 'layout',\n\n    docs: {\n      description: 'Enforce consistent linebreaks in curly braces in JSX attributes and expressions',\n      category: 'Stylistic Issues',\n      recommended: false,\n      url: docsUrl('jsx-curly-newline'),\n    },\n\n    fixable: 'whitespace',\n\n    schema: [\n      {\n        anyOf: [\n          {\n            enum: ['consistent', 'never'],\n          },\n          {\n            type: 'object',\n            properties: {\n              singleline: { enum: ['consistent', 'require', 'forbid'] },\n              multiline: { enum: ['consistent', 'require', 'forbid'] },\n            },\n            additionalProperties: false,\n          },\n        ],\n      },\n    ],\n\n    messages,\n  },\n\n  create(context) {\n    const sourceCode = getSourceCode(context);\n    const option = getNormalizedOption(context);\n\n    // ----------------------------------------------------------------------\n    // Helpers\n    // ----------------------------------------------------------------------\n\n    /**\n     * Determines whether two adjacent tokens are on the same line.\n     * @param {Object} left - The left token object.\n     * @param {Object} right - The right token object.\n     * @returns {boolean} Whether or not the tokens are on the same line.\n     */\n    function isTokenOnSameLine(left, right) {\n      return left.loc.end.line === right.loc.start.line;\n    }\n\n    /**\n     * Determines whether there should be newlines inside curlys\n     * @param {ASTNode} expression The expression contained in the curlys\n     * @param {boolean} hasLeftNewline `true` if the left curly has a newline in the current code.\n     * @returns {boolean} `true` if there should be newlines inside the function curlys\n     */\n    function shouldHaveNewlines(expression, hasLeftNewline) {\n      const isMultiline = expression.loc.start.line !== expression.loc.end.line;\n\n      switch (isMultiline ? option.multiline : option.singleline) {\n        case 'forbid': return false;\n        case 'require': return true;\n        case 'consistent':\n        default: return hasLeftNewline;\n      }\n    }\n\n    /**\n     * Validates curlys\n     * @param {Object} curlys An object with keys `leftParen` for the left paren token, and `rightParen` for the right paren token\n     * @param {ASTNode} expression The expression inside the curly\n     * @returns {void}\n     */\n    function validateCurlys(curlys, expression) {\n      const leftCurly = curlys.leftCurly;\n      const rightCurly = curlys.rightCurly;\n      const tokenAfterLeftCurly = sourceCode.getTokenAfter(leftCurly);\n      const tokenBeforeRightCurly = sourceCode.getTokenBefore(rightCurly);\n      const hasLeftNewline = !isTokenOnSameLine(leftCurly, tokenAfterLeftCurly);\n      const hasRightNewline = !isTokenOnSameLine(tokenBeforeRightCurly, rightCurly);\n      const needsNewlines = shouldHaveNewlines(expression, hasLeftNewline);\n\n      if (hasLeftNewline && !needsNewlines) {\n        report(context, messages.unexpectedAfter, 'unexpectedAfter', {\n          node: leftCurly,\n          fix(fixer) {\n            return getText(context)\n              .slice(leftCurly.range[1], tokenAfterLeftCurly.range[0])\n              .trim()\n              ? null // If there is a comment between the { and the first element, don't do a fix.\n              : fixer.removeRange([leftCurly.range[1], tokenAfterLeftCurly.range[0]]);\n          },\n        });\n      } else if (!hasLeftNewline && needsNewlines) {\n        report(context, messages.expectedAfter, 'expectedAfter', {\n          node: leftCurly,\n          fix: (fixer) => fixer.insertTextAfter(leftCurly, '\\n'),\n        });\n      }\n\n      if (hasRightNewline && !needsNewlines) {\n        report(context, messages.unexpectedBefore, 'unexpectedBefore', {\n          node: rightCurly,\n          fix(fixer) {\n            return getText(context)\n              .slice(tokenBeforeRightCurly.range[1], rightCurly.range[0])\n              .trim()\n              ? null // If there is a comment between the last element and the }, don't do a fix.\n              : fixer.removeRange([\n                tokenBeforeRightCurly.range[1],\n                rightCurly.range[0],\n              ]);\n          },\n        });\n      } else if (!hasRightNewline && needsNewlines) {\n        report(context, messages.expectedBefore, 'expectedBefore', {\n          node: rightCurly,\n          fix: (fixer) => fixer.insertTextBefore(rightCurly, '\\n'),\n        });\n      }\n    }\n\n    // ----------------------------------------------------------------------\n    // Public\n    // ----------------------------------------------------------------------\n\n    return {\n      JSXExpressionContainer(node) {\n        const curlyTokens = {\n          leftCurly: sourceCode.getFirstToken(node),\n          rightCurly: sourceCode.getLastToken(node),\n        };\n        validateCurlys(curlyTokens, node.expression);\n      },\n    };\n  },\n};\n"
        }
    ]
}