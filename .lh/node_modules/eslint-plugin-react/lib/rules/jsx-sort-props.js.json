{
    "sourceFile": "node_modules/eslint-plugin-react/lib/rules/jsx-sort-props.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892272460,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Enforce props alphabetical sorting\n * @author Ilya Volodin, Yannick Croissant\n */\n\n'use strict';\n\nconst propName = require('jsx-ast-utils/propName');\nconst includes = require('array-includes');\nconst toSorted = require('array.prototype.tosorted');\n\nconst docsUrl = require('../util/docsUrl');\nconst jsxUtil = require('../util/jsx');\nconst report = require('../util/report');\nconst propTypesSortUtil = require('../util/propTypesSort');\nconst eslintUtil = require('../util/eslint');\n\nconst getText = eslintUtil.getText;\nconst getSourceCode = eslintUtil.getSourceCode;\n\n// ------------------------------------------------------------------------------\n// Rule Definition\n// ------------------------------------------------------------------------------\n\nfunction isMultilineProp(node) {\n  return node.loc.start.line !== node.loc.end.line;\n}\n\nconst messages = {\n  noUnreservedProps: 'A customized reserved first list must only contain a subset of React reserved props. Remove: {{unreservedWords}}',\n  listIsEmpty: 'A customized reserved first list must not be empty',\n  listReservedPropsFirst: 'Reserved props must be listed before all other props',\n  listCallbacksLast: 'Callbacks must be listed after all other props',\n  listShorthandFirst: 'Shorthand props must be listed before all other props',\n  listShorthandLast: 'Shorthand props must be listed after all other props',\n  listMultilineFirst: 'Multiline props must be listed before all other props',\n  listMultilineLast: 'Multiline props must be listed after all other props',\n  sortPropsByAlpha: 'Props should be sorted alphabetically',\n};\n\nconst RESERVED_PROPS_LIST = [\n  'children',\n  'dangerouslySetInnerHTML',\n  'key',\n  'ref',\n];\n\nfunction isReservedPropName(name, list) {\n  return list.indexOf(name) >= 0;\n}\n\nlet attributeMap;\n// attributeMap = { end: endrange, hasComment: true||false if comment in between nodes exists, it needs to be sorted to end }\n\nfunction shouldSortToEnd(node) {\n  const attr = attributeMap.get(node);\n  return !!attr && !!attr.hasComment;\n}\n\nfunction contextCompare(a, b, options) {\n  let aProp = propName(a);\n  let bProp = propName(b);\n\n  const aSortToEnd = shouldSortToEnd(a);\n  const bSortToEnd = shouldSortToEnd(b);\n  if (aSortToEnd && !bSortToEnd) {\n    return 1;\n  }\n  if (!aSortToEnd && bSortToEnd) {\n    return -1;\n  }\n\n  if (options.reservedFirst) {\n    const aIsReserved = isReservedPropName(aProp, options.reservedList);\n    const bIsReserved = isReservedPropName(bProp, options.reservedList);\n    if (aIsReserved && !bIsReserved) {\n      return -1;\n    }\n    if (!aIsReserved && bIsReserved) {\n      return 1;\n    }\n  }\n\n  if (options.callbacksLast) {\n    const aIsCallback = propTypesSortUtil.isCallbackPropName(aProp);\n    const bIsCallback = propTypesSortUtil.isCallbackPropName(bProp);\n    if (aIsCallback && !bIsCallback) {\n      return 1;\n    }\n    if (!aIsCallback && bIsCallback) {\n      return -1;\n    }\n  }\n\n  if (options.shorthandFirst || options.shorthandLast) {\n    const shorthandSign = options.shorthandFirst ? -1 : 1;\n    if (!a.value && b.value) {\n      return shorthandSign;\n    }\n    if (a.value && !b.value) {\n      return -shorthandSign;\n    }\n  }\n\n  if (options.multiline !== 'ignore') {\n    const multilineSign = options.multiline === 'first' ? -1 : 1;\n    const aIsMultiline = isMultilineProp(a);\n    const bIsMultiline = isMultilineProp(b);\n    if (aIsMultiline && !bIsMultiline) {\n      return multilineSign;\n    }\n    if (!aIsMultiline && bIsMultiline) {\n      return -multilineSign;\n    }\n  }\n\n  if (options.noSortAlphabetically) {\n    return 0;\n  }\n\n  const actualLocale = options.locale === 'auto' ? undefined : options.locale;\n\n  if (options.ignoreCase) {\n    aProp = aProp.toLowerCase();\n    bProp = bProp.toLowerCase();\n    return aProp.localeCompare(bProp, actualLocale);\n  }\n  if (aProp === bProp) {\n    return 0;\n  }\n  if (options.locale === 'auto') {\n    return aProp < bProp ? -1 : 1;\n  }\n  return aProp.localeCompare(bProp, actualLocale);\n}\n\n/**\n * Create an array of arrays where each subarray is composed of attributes\n * that are considered sortable.\n * @param {Array<JSXSpreadAttribute|JSXAttribute>} attributes\n * @param {Object} context The context of the rule\n * @return {Array<Array<JSXAttribute>>}\n */\nfunction getGroupsOfSortableAttributes(attributes, context) {\n  const sourceCode = getSourceCode(context);\n\n  const sortableAttributeGroups = [];\n  let groupCount = 0;\n  function addtoSortableAttributeGroups(attribute) {\n    sortableAttributeGroups[groupCount - 1].push(attribute);\n  }\n\n  for (let i = 0; i < attributes.length; i++) {\n    const attribute = attributes[i];\n    const nextAttribute = attributes[i + 1];\n    const attributeline = attribute.loc.start.line;\n    let comment = [];\n    try {\n      comment = sourceCode.getCommentsAfter(attribute);\n    } catch (e) { /**/ }\n    const lastAttr = attributes[i - 1];\n    const attrIsSpread = attribute.type === 'JSXSpreadAttribute';\n\n    // If we have no groups or if the last attribute was JSXSpreadAttribute\n    // then we start a new group. Append attributes to the group until we\n    // come across another JSXSpreadAttribute or exhaust the array.\n    if (\n      !lastAttr\n      || (lastAttr.type === 'JSXSpreadAttribute' && !attrIsSpread)\n    ) {\n      groupCount += 1;\n      sortableAttributeGroups[groupCount - 1] = [];\n    }\n    if (!attrIsSpread) {\n      if (comment.length === 0) {\n        attributeMap.set(attribute, { end: attribute.range[1], hasComment: false });\n        addtoSortableAttributeGroups(attribute);\n      } else {\n        const firstComment = comment[0];\n        const commentline = firstComment.loc.start.line;\n        if (comment.length === 1) {\n          if (attributeline + 1 === commentline && nextAttribute) {\n            attributeMap.set(attribute, { end: nextAttribute.range[1], hasComment: true });\n            addtoSortableAttributeGroups(attribute);\n            i += 1;\n          } else if (attributeline === commentline) {\n            if (firstComment.type === 'Block' && nextAttribute) {\n              attributeMap.set(attribute, { end: nextAttribute.range[1], hasComment: true });\n              i += 1;\n            } else if (firstComment.type === 'Block') {\n              attributeMap.set(attribute, { end: firstComment.range[1], hasComment: true });\n            } else {\n              attributeMap.set(attribute, { end: firstComment.range[1], hasComment: false });\n            }\n            addtoSortableAttributeGroups(attribute);\n          }\n        } else if (comment.length > 1 && attributeline + 1 === comment[1].loc.start.line && nextAttribute) {\n          const commentNextAttribute = sourceCode.getCommentsAfter(nextAttribute);\n          attributeMap.set(attribute, { end: nextAttribute.range[1], hasComment: true });\n          if (\n            commentNextAttribute.length === 1\n            && nextAttribute.loc.start.line === commentNextAttribute[0].loc.start.line\n          ) {\n            attributeMap.set(attribute, { end: commentNextAttribute[0].range[1], hasComment: true });\n          }\n          addtoSortableAttributeGroups(attribute);\n          i += 1;\n        }\n      }\n    }\n  }\n  return sortableAttributeGroups;\n}\n\nfunction generateFixerFunction(node, context, reservedList) {\n  const attributes = node.attributes.slice(0);\n  const configuration = context.options[0] || {};\n  const ignoreCase = configuration.ignoreCase || false;\n  const callbacksLast = configuration.callbacksLast || false;\n  const shorthandFirst = configuration.shorthandFirst || false;\n  const shorthandLast = configuration.shorthandLast || false;\n  const multiline = configuration.multiline || 'ignore';\n  const noSortAlphabetically = configuration.noSortAlphabetically || false;\n  const reservedFirst = configuration.reservedFirst || false;\n  const locale = configuration.locale || 'auto';\n\n  // Sort props according to the context. Only supports ignoreCase.\n  // Since we cannot safely move JSXSpreadAttribute (due to potential variable overrides),\n  // we only consider groups of sortable attributes.\n  const options = {\n    ignoreCase,\n    callbacksLast,\n    shorthandFirst,\n    shorthandLast,\n    multiline,\n    noSortAlphabetically,\n    reservedFirst,\n    reservedList,\n    locale,\n  };\n  const sortableAttributeGroups = getGroupsOfSortableAttributes(attributes, context);\n  const sortedAttributeGroups = sortableAttributeGroups\n    .slice(0)\n    .map((group) => toSorted(group, (a, b) => contextCompare(a, b, options)));\n\n  return function fixFunction(fixer) {\n    const fixers = [];\n    let source = getText(context);\n\n    sortableAttributeGroups.forEach((sortableGroup, ii) => {\n      sortableGroup.forEach((attr, jj) => {\n        const sortedAttr = sortedAttributeGroups[ii][jj];\n        const sortedAttrText = source.slice(sortedAttr.range[0], attributeMap.get(sortedAttr).end);\n        fixers.push({\n          range: [attr.range[0], attributeMap.get(attr).end],\n          text: sortedAttrText,\n        });\n      });\n    });\n\n    fixers.sort((a, b) => b.range[0] - a.range[0]);\n\n    const firstFixer = fixers[0];\n    const lastFixer = fixers[fixers.length - 1];\n    const rangeStart = lastFixer ? lastFixer.range[0] : 0;\n    const rangeEnd = firstFixer ? firstFixer.range[1] : -0;\n\n    fixers.forEach((fix) => {\n      source = `${source.slice(0, fix.range[0])}${fix.text}${source.slice(fix.range[1])}`;\n    });\n\n    return fixer.replaceTextRange([rangeStart, rangeEnd], source.slice(rangeStart, rangeEnd));\n  };\n}\n\n/**\n * Checks if the `reservedFirst` option is valid\n * @param {Object} context The context of the rule\n * @param {boolean | string[]} reservedFirst The `reservedFirst` option\n * @return {Function | undefined} If an error is detected, a function to generate the error message, otherwise, `undefined`\n */\n// eslint-disable-next-line consistent-return\nfunction validateReservedFirstConfig(context, reservedFirst) {\n  if (reservedFirst) {\n    if (Array.isArray(reservedFirst)) {\n      // Only allow a subset of reserved words in customized lists\n      const nonReservedWords = reservedFirst.filter((word) => !isReservedPropName(\n        word,\n        RESERVED_PROPS_LIST\n      ));\n\n      if (reservedFirst.length === 0) {\n        return function Report(decl) {\n          report(context, messages.listIsEmpty, 'listIsEmpty', {\n            node: decl,\n          });\n        };\n      }\n      if (nonReservedWords.length > 0) {\n        return function Report(decl) {\n          report(context, messages.noUnreservedProps, 'noUnreservedProps', {\n            node: decl,\n            data: {\n              unreservedWords: nonReservedWords.toString(),\n            },\n          });\n        };\n      }\n    }\n  }\n}\n\nconst reportedNodeAttributes = new WeakMap();\n/**\n * Check if the current node attribute has already been reported with the same error type\n * if that's the case then we don't report a new error\n * otherwise we report the error\n * @param {Object} nodeAttribute The node attribute to be reported\n * @param {string} errorType The error type to be reported\n * @param {Object} node The parent node for the node attribute\n * @param {Object} context The context of the rule\n * @param {Array<String>} reservedList The list of reserved props\n */\nfunction reportNodeAttribute(nodeAttribute, errorType, node, context, reservedList) {\n  const errors = reportedNodeAttributes.get(nodeAttribute) || [];\n\n  if (includes(errors, errorType)) {\n    return;\n  }\n\n  errors.push(errorType);\n\n  reportedNodeAttributes.set(nodeAttribute, errors);\n\n  report(context, messages[errorType], errorType, {\n    node: nodeAttribute.name,\n    fix: generateFixerFunction(node, context, reservedList),\n  });\n}\n\n/** @type {import('eslint').Rule.RuleModule} */\nmodule.exports = {\n  meta: {\n    docs: {\n      description: 'Enforce props alphabetical sorting',\n      category: 'Stylistic Issues',\n      recommended: false,\n      url: docsUrl('jsx-sort-props'),\n    },\n    fixable: 'code',\n\n    messages,\n\n    schema: [{\n      type: 'object',\n      properties: {\n        // Whether callbacks (prefixed with \"on\") should be listed at the very end,\n        // after all other props. Supersedes shorthandLast.\n        callbacksLast: {\n          type: 'boolean',\n        },\n        // Whether shorthand properties (without a value) should be listed first\n        shorthandFirst: {\n          type: 'boolean',\n        },\n        // Whether shorthand properties (without a value) should be listed last\n        shorthandLast: {\n          type: 'boolean',\n        },\n        // Whether multiline properties should be listed first or last\n        multiline: {\n          enum: ['ignore', 'first', 'last'],\n          default: 'ignore',\n        },\n        ignoreCase: {\n          type: 'boolean',\n        },\n        // Whether alphabetical sorting should be enforced\n        noSortAlphabetically: {\n          type: 'boolean',\n        },\n        reservedFirst: {\n          type: ['array', 'boolean'],\n        },\n        locale: {\n          type: 'string',\n          default: 'auto',\n        },\n      },\n      additionalProperties: false,\n    }],\n  },\n\n  create(context) {\n    const configuration = context.options[0] || {};\n    const ignoreCase = configuration.ignoreCase || false;\n    const callbacksLast = configuration.callbacksLast || false;\n    const shorthandFirst = configuration.shorthandFirst || false;\n    const shorthandLast = configuration.shorthandLast || false;\n    const multiline = configuration.multiline || 'ignore';\n    const noSortAlphabetically = configuration.noSortAlphabetically || false;\n    const reservedFirst = configuration.reservedFirst || false;\n    const reservedFirstError = validateReservedFirstConfig(context, reservedFirst);\n    const reservedList = Array.isArray(reservedFirst) ? reservedFirst : RESERVED_PROPS_LIST;\n    const locale = configuration.locale || 'auto';\n\n    return {\n      Program() {\n        attributeMap = new WeakMap();\n      },\n\n      JSXOpeningElement(node) {\n        // `dangerouslySetInnerHTML` is only \"reserved\" on DOM components\n        const nodeReservedList = reservedFirst && !jsxUtil.isDOMComponent(node) ? reservedList.filter((prop) => prop !== 'dangerouslySetInnerHTML') : reservedList;\n\n        node.attributes.reduce((memo, decl, idx, attrs) => {\n          if (decl.type === 'JSXSpreadAttribute') {\n            return attrs[idx + 1];\n          }\n\n          let previousPropName = propName(memo);\n          let currentPropName = propName(decl);\n          const previousValue = memo.value;\n          const currentValue = decl.value;\n          const previousIsCallback = propTypesSortUtil.isCallbackPropName(previousPropName);\n          const currentIsCallback = propTypesSortUtil.isCallbackPropName(currentPropName);\n\n          if (ignoreCase) {\n            previousPropName = previousPropName.toLowerCase();\n            currentPropName = currentPropName.toLowerCase();\n          }\n\n          if (reservedFirst) {\n            if (reservedFirstError) {\n              reservedFirstError(decl);\n              return memo;\n            }\n\n            const previousIsReserved = isReservedPropName(previousPropName, nodeReservedList);\n            const currentIsReserved = isReservedPropName(currentPropName, nodeReservedList);\n\n            if (previousIsReserved && !currentIsReserved) {\n              return decl;\n            }\n            if (!previousIsReserved && currentIsReserved) {\n              reportNodeAttribute(decl, 'listReservedPropsFirst', node, context, nodeReservedList);\n\n              return memo;\n            }\n          }\n\n          if (callbacksLast) {\n            if (!previousIsCallback && currentIsCallback) {\n              // Entering the callback prop section\n              return decl;\n            }\n            if (previousIsCallback && !currentIsCallback) {\n              // Encountered a non-callback prop after a callback prop\n              reportNodeAttribute(memo, 'listCallbacksLast', node, context, nodeReservedList);\n\n              return memo;\n            }\n          }\n\n          if (shorthandFirst) {\n            if (currentValue && !previousValue) {\n              return decl;\n            }\n            if (!currentValue && previousValue) {\n              reportNodeAttribute(decl, 'listShorthandFirst', node, context, nodeReservedList);\n\n              return memo;\n            }\n          }\n\n          if (shorthandLast) {\n            if (!currentValue && previousValue) {\n              return decl;\n            }\n            if (currentValue && !previousValue) {\n              reportNodeAttribute(memo, 'listShorthandLast', node, context, nodeReservedList);\n\n              return memo;\n            }\n          }\n\n          const previousIsMultiline = isMultilineProp(memo);\n          const currentIsMultiline = isMultilineProp(decl);\n          if (multiline === 'first') {\n            if (previousIsMultiline && !currentIsMultiline) {\n              // Exiting the multiline prop section\n              return decl;\n            }\n            if (!previousIsMultiline && currentIsMultiline) {\n              // Encountered a non-multiline prop before a multiline prop\n              reportNodeAttribute(decl, 'listMultilineFirst', node, context, nodeReservedList);\n\n              return memo;\n            }\n          } else if (multiline === 'last') {\n            if (!previousIsMultiline && currentIsMultiline) {\n              // Entering the multiline prop section\n              return decl;\n            }\n            if (previousIsMultiline && !currentIsMultiline) {\n              // Encountered a non-multiline prop after a multiline prop\n              reportNodeAttribute(memo, 'listMultilineLast', node, context, nodeReservedList);\n\n              return memo;\n            }\n          }\n\n          if (\n            !noSortAlphabetically\n            && (\n              (ignoreCase || locale !== 'auto')\n                ? previousPropName.localeCompare(currentPropName, locale === 'auto' ? undefined : locale) > 0\n                : previousPropName > currentPropName\n            )\n          ) {\n            reportNodeAttribute(decl, 'sortPropsByAlpha', node, context, nodeReservedList);\n\n            return memo;\n          }\n\n          return decl;\n        }, node.attributes[0]);\n      },\n    };\n  },\n};\n"
        }
    ]
}