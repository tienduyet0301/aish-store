{
    "sourceFile": "node_modules/eslint-plugin-react/lib/rules/no-access-state-in-setstate.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892273092,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Prevent usage of this.state within setState\n * @author Rolf Erik Lekang, JÃ¸rgen Aaberg\n */\n\n'use strict';\n\nconst docsUrl = require('../util/docsUrl');\nconst astUtil = require('../util/ast');\nconst componentUtil = require('../util/componentUtil');\nconst report = require('../util/report');\nconst getScope = require('../util/eslint').getScope;\n\n// ------------------------------------------------------------------------------\n// Rule Definition\n// ------------------------------------------------------------------------------\n\nconst messages = {\n  useCallback: 'Use callback in setState when referencing the previous state.',\n};\n\n/** @type {import('eslint').Rule.RuleModule} */\nmodule.exports = {\n  meta: {\n    docs: {\n      description: 'Disallow when this.state is accessed within setState',\n      category: 'Possible Errors',\n      recommended: false,\n      url: docsUrl('no-access-state-in-setstate'),\n    },\n\n    messages,\n  },\n\n  create(context) {\n    function isSetStateCall(node) {\n      return astUtil.isCallExpression(node)\n        && node.callee.property\n        && node.callee.property.name === 'setState'\n        && node.callee.object.type === 'ThisExpression';\n    }\n\n    function isFirstArgumentInSetStateCall(current, node) {\n      if (!isSetStateCall(current)) {\n        return false;\n      }\n      while (node && node.parent !== current) {\n        node = node.parent;\n      }\n      return current.arguments[0] === node;\n    }\n\n    /**\n     * @param {ASTNode} node\n     * @returns {boolean}\n     */\n    function isClassComponent(node) {\n      return !!(\n        componentUtil.getParentES6Component(context, node)\n        || componentUtil.getParentES5Component(context, node)\n      );\n    }\n\n    // The methods array contains all methods or functions that are using this.state\n    // or that are calling another method or function using this.state\n    const methods = [];\n    // The vars array contains all variables that contains this.state\n    const vars = [];\n    return {\n      CallExpression(node) {\n        if (!isClassComponent(node)) {\n          return;\n        }\n        // Appends all the methods that are calling another\n        // method containing this.state to the methods array\n        methods.forEach((method) => {\n          if ('name' in node.callee && node.callee.name === method.methodName) {\n            let current = node.parent;\n            while (current.type !== 'Program') {\n              if (current.type === 'MethodDefinition') {\n                methods.push({\n                  methodName: 'name' in current.key ? current.key.name : undefined,\n                  node: method.node,\n                });\n                break;\n              }\n              current = current.parent;\n            }\n          }\n        });\n\n        // Finding all CallExpressions that is inside a setState\n        // to further check if they contains this.state\n        let current = node.parent;\n        while (current.type !== 'Program') {\n          if (isFirstArgumentInSetStateCall(current, node)) {\n            const methodName = 'name' in node.callee ? node.callee.name : undefined;\n            methods.forEach((method) => {\n              if (method.methodName === methodName) {\n                report(context, messages.useCallback, 'useCallback', {\n                  node: method.node,\n                });\n              }\n            });\n\n            break;\n          }\n          current = current.parent;\n        }\n      },\n\n      MemberExpression(node) {\n        if (\n          'name' in node.property\n          && node.property.name === 'state'\n          && node.object.type === 'ThisExpression'\n          && isClassComponent(node)\n        ) {\n          /** @type {import('eslint').Rule.Node} */\n          let current = node;\n          while (current.type !== 'Program') {\n            // Reporting if this.state is directly within this.setState\n            if (isFirstArgumentInSetStateCall(current, node)) {\n              report(context, messages.useCallback, 'useCallback', {\n                node,\n              });\n              break;\n            }\n\n            // Storing all functions and methods that contains this.state\n            if (current.type === 'MethodDefinition') {\n              methods.push({\n                methodName: 'name' in current.key ? current.key.name : undefined,\n                node,\n              });\n              break;\n            } else if (\n              current.type === 'FunctionExpression'\n              && 'key' in current.parent\n              && current.parent.key\n            ) {\n              methods.push({\n                methodName: 'name' in current.parent.key ? current.parent.key.name : undefined,\n                node,\n              });\n              break;\n            }\n\n            // Storing all variables containing this.state\n            if (current.type === 'VariableDeclarator') {\n              vars.push({\n                node,\n                scope: getScope(context, node),\n                variableName: 'name' in current.id ? current.id.name : undefined,\n              });\n              break;\n            }\n\n            current = current.parent;\n          }\n        }\n      },\n\n      Identifier(node) {\n        // Checks if the identifier is a variable within an object\n        /** @type {import('eslint').Rule.Node} */\n        let current = node;\n        while (current.parent.type === 'BinaryExpression') {\n          current = current.parent;\n        }\n        if (\n          ('value' in current.parent && current.parent.value === current)\n          || ('object' in current.parent && current.parent.object === current)\n        ) {\n          while (current.type !== 'Program') {\n            if (isFirstArgumentInSetStateCall(current, node)) {\n              vars\n                .filter((v) => v.scope === getScope(context, node) && v.variableName === node.name)\n                .forEach((v) => {\n                  report(context, messages.useCallback, 'useCallback', {\n                    node: v.node,\n                  });\n                });\n            }\n            current = current.parent;\n          }\n        }\n      },\n\n      ObjectPattern(node) {\n        const isDerivedFromThis = 'init' in node.parent && node.parent.init && node.parent.init.type === 'ThisExpression';\n        node.properties.forEach((property) => {\n          if (\n            property\n            && 'key' in property\n            && property.key\n            && 'name' in property.key\n            && property.key.name === 'state'\n            && isDerivedFromThis\n          ) {\n            vars.push({\n              node: property.key,\n              scope: getScope(context, node),\n              variableName: property.key.name,\n            });\n          }\n        });\n      },\n    };\n  },\n};\n"
        }
    ]
}