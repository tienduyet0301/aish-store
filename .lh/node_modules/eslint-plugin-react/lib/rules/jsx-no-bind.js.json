{
    "sourceFile": "node_modules/eslint-plugin-react/lib/rules/jsx-no-bind.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892270997,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Prevents usage of Function.prototype.bind and arrow functions\n *               in React component props.\n * @author Daniel Lo Nigro <dan.cx>\n * @author Jacky Ho\n */\n\n'use strict';\n\nconst propName = require('jsx-ast-utils/propName');\nconst docsUrl = require('../util/docsUrl');\nconst astUtil = require('../util/ast');\nconst jsxUtil = require('../util/jsx');\nconst report = require('../util/report');\nconst getAncestors = require('../util/eslint').getAncestors;\n\n// -----------------------------------------------------------------------------\n// Rule Definition\n// -----------------------------------------------------------------------------\n\nconst messages = {\n  bindCall: 'JSX props should not use .bind()',\n  arrowFunc: 'JSX props should not use arrow functions',\n  bindExpression: 'JSX props should not use ::',\n  func: 'JSX props should not use functions',\n};\n\n/** @type {import('eslint').Rule.RuleModule} */\nmodule.exports = {\n  meta: {\n    docs: {\n      description: 'Disallow `.bind()` or arrow functions in JSX props',\n      category: 'Best Practices',\n      recommended: false,\n      url: docsUrl('jsx-no-bind'),\n    },\n\n    messages,\n\n    schema: [{\n      type: 'object',\n      properties: {\n        allowArrowFunctions: {\n          default: false,\n          type: 'boolean',\n        },\n        allowBind: {\n          default: false,\n          type: 'boolean',\n        },\n        allowFunctions: {\n          default: false,\n          type: 'boolean',\n        },\n        ignoreRefs: {\n          default: false,\n          type: 'boolean',\n        },\n        ignoreDOMComponents: {\n          default: false,\n          type: 'boolean',\n        },\n      },\n      additionalProperties: false,\n    }],\n  },\n\n  create(context) {\n    const configuration = context.options[0] || {};\n\n    // Keep track of all the variable names pointing to a bind call,\n    // bind expression or an arrow function in different block statements\n    const blockVariableNameSets = {};\n\n    /**\n     * @param {string | number} blockStart\n     */\n    function setBlockVariableNameSet(blockStart) {\n      blockVariableNameSets[blockStart] = {\n        arrowFunc: new Set(),\n        bindCall: new Set(),\n        bindExpression: new Set(),\n        func: new Set(),\n      };\n    }\n\n    function getNodeViolationType(node) {\n      if (\n        !configuration.allowBind\n        && astUtil.isCallExpression(node)\n        && node.callee.type === 'MemberExpression'\n        && node.callee.property.type === 'Identifier'\n        && node.callee.property.name === 'bind'\n      ) {\n        return 'bindCall';\n      }\n      if (node.type === 'ConditionalExpression') {\n        return getNodeViolationType(node.test)\n               || getNodeViolationType(node.consequent)\n               || getNodeViolationType(node.alternate);\n      }\n      if (!configuration.allowArrowFunctions && node.type === 'ArrowFunctionExpression') {\n        return 'arrowFunc';\n      }\n      if (\n        !configuration.allowFunctions\n        && (node.type === 'FunctionExpression' || node.type === 'FunctionDeclaration')\n      ) {\n        return 'func';\n      }\n      if (!configuration.allowBind && node.type === 'BindExpression') {\n        return 'bindExpression';\n      }\n\n      return null;\n    }\n\n    /**\n     * @param {string | number} violationType\n     * @param {unknown} variableName\n     * @param {string | number} blockStart\n     */\n    function addVariableNameToSet(violationType, variableName, blockStart) {\n      blockVariableNameSets[blockStart][violationType].add(variableName);\n    }\n\n    function getBlockStatementAncestors(node) {\n      return getAncestors(context, node).filter(\n        (ancestor) => ancestor.type === 'BlockStatement'\n      ).reverse();\n    }\n\n    function reportVariableViolation(node, name, blockStart) {\n      const blockSets = blockVariableNameSets[blockStart];\n      const violationTypes = Object.keys(blockSets);\n\n      return violationTypes.find((type) => {\n        if (blockSets[type].has(name)) {\n          report(context, messages[type], type, {\n            node,\n          });\n          return true;\n        }\n\n        return false;\n      });\n    }\n\n    function findVariableViolation(node, name) {\n      getBlockStatementAncestors(node).find(\n        (block) => reportVariableViolation(node, name, block.range[0])\n      );\n    }\n\n    return {\n      BlockStatement(node) {\n        setBlockVariableNameSet(node.range[0]);\n      },\n\n      FunctionDeclaration(node) {\n        const blockAncestors = getBlockStatementAncestors(node);\n        const variableViolationType = getNodeViolationType(node);\n\n        if (blockAncestors.length > 0 && variableViolationType) {\n          addVariableNameToSet(variableViolationType, node.id.name, blockAncestors[0].range[0]);\n        }\n      },\n\n      VariableDeclarator(node) {\n        if (!node.init) {\n          return;\n        }\n        const blockAncestors = getBlockStatementAncestors(node);\n        const variableViolationType = getNodeViolationType(node.init);\n\n        if (\n          blockAncestors.length > 0\n          && variableViolationType\n          && 'kind' in node.parent\n          && node.parent.kind === 'const' // only support const right now\n        ) {\n          addVariableNameToSet(variableViolationType, 'name' in node.id ? node.id.name : undefined, blockAncestors[0].range[0]);\n        }\n      },\n\n      JSXAttribute(node) {\n        const isRef = configuration.ignoreRefs && propName(node) === 'ref';\n        if (isRef || !node.value || !node.value.expression) {\n          return;\n        }\n        const isDOMComponent = jsxUtil.isDOMComponent(node.parent);\n        if (configuration.ignoreDOMComponents && isDOMComponent) {\n          return;\n        }\n        const valueNode = node.value.expression;\n        const valueNodeType = valueNode.type;\n        const nodeViolationType = getNodeViolationType(valueNode);\n\n        if (valueNodeType === 'Identifier') {\n          findVariableViolation(node, valueNode.name);\n        } else if (nodeViolationType) {\n          report(context, messages[nodeViolationType], nodeViolationType, {\n            node,\n          });\n        }\n      },\n    };\n  },\n};\n"
        }
    ]
}