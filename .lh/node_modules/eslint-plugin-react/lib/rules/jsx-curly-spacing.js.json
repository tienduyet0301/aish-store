{
    "sourceFile": "node_modules/eslint-plugin-react/lib/rules/jsx-curly-spacing.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892268919,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Enforce or disallow spaces inside of curly braces in JSX attributes.\n * @author Jamund Ferguson\n * @author Brandyn Bennett\n * @author Michael Ficarra\n * @author Vignesh Anand\n * @author Jamund Ferguson\n * @author Yannick Croissant\n * @author Erik Wendel\n */\n\n'use strict';\n\nconst has = require('hasown');\nconst docsUrl = require('../util/docsUrl');\nconst getSourceCode = require('../util/eslint').getSourceCode;\nconst report = require('../util/report');\n\n// ------------------------------------------------------------------------------\n// Rule Definition\n// ------------------------------------------------------------------------------\n\nconst SPACING = {\n  always: 'always',\n  never: 'never',\n};\nconst SPACING_VALUES = [SPACING.always, SPACING.never];\n\nconst messages = {\n  noNewlineAfter: 'There should be no newline after \\'{{token}}\\'',\n  noNewlineBefore: 'There should be no newline before \\'{{token}}\\'',\n  noSpaceAfter: 'There should be no space after \\'{{token}}\\'',\n  noSpaceBefore: 'There should be no space before \\'{{token}}\\'',\n  spaceNeededAfter: 'A space is required after \\'{{token}}\\'',\n  spaceNeededBefore: 'A space is required before \\'{{token}}\\'',\n};\n\n/** @type {import('eslint').Rule.RuleModule} */\nmodule.exports = {\n  meta: {\n    docs: {\n      description: 'Enforce or disallow spaces inside of curly braces in JSX attributes and expressions',\n      category: 'Stylistic Issues',\n      recommended: false,\n      url: docsUrl('jsx-curly-spacing'),\n    },\n    fixable: 'code',\n\n    messages,\n\n    schema: {\n      definitions: {\n        basicConfig: {\n          type: 'object',\n          properties: {\n            when: {\n              enum: SPACING_VALUES,\n            },\n            allowMultiline: {\n              type: 'boolean',\n            },\n            spacing: {\n              type: 'object',\n              properties: {\n                objectLiterals: {\n                  enum: SPACING_VALUES,\n                },\n              },\n            },\n          },\n        },\n        basicConfigOrBoolean: {\n          anyOf: [{\n            $ref: '#/definitions/basicConfig',\n          }, {\n            type: 'boolean',\n          }],\n        },\n      },\n      type: 'array',\n      items: [{\n        anyOf: [{\n          allOf: [{\n            $ref: '#/definitions/basicConfig',\n          }, {\n            type: 'object',\n            properties: {\n              attributes: {\n                $ref: '#/definitions/basicConfigOrBoolean',\n              },\n              children: {\n                $ref: '#/definitions/basicConfigOrBoolean',\n              },\n            },\n          }],\n        }, {\n          enum: SPACING_VALUES,\n        }],\n      }, {\n        type: 'object',\n        properties: {\n          allowMultiline: {\n            type: 'boolean',\n          },\n          spacing: {\n            type: 'object',\n            properties: {\n              objectLiterals: {\n                enum: SPACING_VALUES,\n              },\n            },\n          },\n        },\n        additionalProperties: false,\n      }],\n    },\n  },\n\n  create(context) {\n    function normalizeConfig(configOrTrue, defaults, lastPass) {\n      const config = configOrTrue === true ? {} : configOrTrue;\n      const when = config.when || defaults.when;\n      const allowMultiline = has(config, 'allowMultiline') ? config.allowMultiline : defaults.allowMultiline;\n      const spacing = config.spacing || {};\n      let objectLiteralSpaces = spacing.objectLiterals || defaults.objectLiteralSpaces;\n      if (lastPass) {\n        // On the final pass assign the values that should be derived from others if they are still undefined\n        objectLiteralSpaces = objectLiteralSpaces || when;\n      }\n\n      return {\n        when,\n        allowMultiline,\n        objectLiteralSpaces,\n      };\n    }\n\n    const DEFAULT_WHEN = SPACING.never;\n    const DEFAULT_ALLOW_MULTILINE = true;\n    const DEFAULT_ATTRIBUTES = true;\n    const DEFAULT_CHILDREN = false;\n\n    let originalConfig = context.options[0] || {};\n    if (SPACING_VALUES.indexOf(originalConfig) !== -1) {\n      originalConfig = Object.assign({ when: context.options[0] }, context.options[1]);\n    }\n    const defaultConfig = normalizeConfig(originalConfig, {\n      when: DEFAULT_WHEN,\n      allowMultiline: DEFAULT_ALLOW_MULTILINE,\n    });\n    const attributes = has(originalConfig, 'attributes') ? originalConfig.attributes : DEFAULT_ATTRIBUTES;\n    const attributesConfig = attributes ? normalizeConfig(attributes, defaultConfig, true) : null;\n    const children = has(originalConfig, 'children') ? originalConfig.children : DEFAULT_CHILDREN;\n    const childrenConfig = children ? normalizeConfig(children, defaultConfig, true) : null;\n\n    // --------------------------------------------------------------------------\n    // Helpers\n    // --------------------------------------------------------------------------\n\n    /**\n     * Determines whether two adjacent tokens have a newline between them.\n     * @param {Object} left - The left token object.\n     * @param {Object} right - The right token object.\n     * @returns {boolean} Whether or not there is a newline between the tokens.\n     */\n    function isMultiline(left, right) {\n      return left.loc.end.line !== right.loc.start.line;\n    }\n\n    /**\n     * Trims text of whitespace between two ranges\n     * @param {Fixer} fixer - the eslint fixer object\n     * @param {number} fromLoc - the start location\n     * @param {number} toLoc - the end location\n     * @param {string} mode - either 'start' or 'end'\n     * @param {string=} spacing - a spacing value that will optionally add a space to the removed text\n     * @returns {Object|*|{range, text}}\n     */\n    function fixByTrimmingWhitespace(fixer, fromLoc, toLoc, mode, spacing) {\n      let replacementText = getSourceCode(context).text.slice(fromLoc, toLoc);\n      if (mode === 'start') {\n        replacementText = replacementText.replace(/^\\s+/gm, '');\n      } else {\n        replacementText = replacementText.replace(/\\s+$/gm, '');\n      }\n      if (spacing === SPACING.always) {\n        if (mode === 'start') {\n          replacementText += ' ';\n        } else {\n          replacementText = ` ${replacementText}`;\n        }\n      }\n      return fixer.replaceTextRange([fromLoc, toLoc], replacementText);\n    }\n\n    /**\n    * Reports that there shouldn't be a newline after the first token\n    * @param {ASTNode} node - The node to report in the event of an error.\n    * @param {Token} token - The token to use for the report.\n    * @param {string} spacing\n    * @returns {void}\n    */\n    function reportNoBeginningNewline(node, token, spacing) {\n      report(context, messages.noNewlineAfter, 'noNewlineAfter', {\n        node,\n        loc: token.loc.start,\n        data: {\n          token: token.value,\n        },\n        fix(fixer) {\n          const nextToken = getSourceCode(context).getTokenAfter(token);\n          return fixByTrimmingWhitespace(fixer, token.range[1], nextToken.range[0], 'start', spacing);\n        },\n      });\n    }\n\n    /**\n    * Reports that there shouldn't be a newline before the last token\n    * @param {ASTNode} node - The node to report in the event of an error.\n    * @param {Token} token - The token to use for the report.\n    * @param {string} spacing\n    * @returns {void}\n    */\n    function reportNoEndingNewline(node, token, spacing) {\n      report(context, messages.noNewlineBefore, 'noNewlineBefore', {\n        node,\n        loc: token.loc.start,\n        data: {\n          token: token.value,\n        },\n        fix(fixer) {\n          const previousToken = getSourceCode(context).getTokenBefore(token);\n          return fixByTrimmingWhitespace(fixer, previousToken.range[1], token.range[0], 'end', spacing);\n        },\n      });\n    }\n\n    /**\n    * Reports that there shouldn't be a space after the first token\n    * @param {ASTNode} node - The node to report in the event of an error.\n    * @param {Token} token - The token to use for the report.\n    * @returns {void}\n    */\n    function reportNoBeginningSpace(node, token) {\n      report(context, messages.noSpaceAfter, 'noSpaceAfter', {\n        node,\n        loc: token.loc.start,\n        data: {\n          token: token.value,\n        },\n        fix(fixer) {\n          const sourceCode = getSourceCode(context);\n          const nextToken = sourceCode.getTokenAfter(token);\n          let nextComment;\n\n          // eslint >=4.x\n          if (sourceCode.getCommentsAfter) {\n            nextComment = sourceCode.getCommentsAfter(token);\n          // eslint 3.x\n          } else {\n            const potentialComment = sourceCode.getTokenAfter(token, { includeComments: true });\n            nextComment = nextToken === potentialComment ? [] : [potentialComment];\n          }\n\n          // Take comments into consideration to narrow the fix range to what is actually affected. (See #1414)\n          if (nextComment.length > 0) {\n            return fixByTrimmingWhitespace(fixer, token.range[1], Math.min(nextToken.range[0], nextComment[0].range[0]), 'start');\n          }\n\n          return fixByTrimmingWhitespace(fixer, token.range[1], nextToken.range[0], 'start');\n        },\n      });\n    }\n\n    /**\n    * Reports that there shouldn't be a space before the last token\n    * @param {ASTNode} node - The node to report in the event of an error.\n    * @param {Token} token - The token to use for the report.\n    * @returns {void}\n    */\n    function reportNoEndingSpace(node, token) {\n      report(context, messages.noSpaceBefore, 'noSpaceBefore', {\n        node,\n        loc: token.loc.start,\n        data: {\n          token: token.value,\n        },\n        fix(fixer) {\n          const sourceCode = getSourceCode(context);\n          const previousToken = sourceCode.getTokenBefore(token);\n          let previousComment;\n\n          // eslint >=4.x\n          if (sourceCode.getCommentsBefore) {\n            previousComment = sourceCode.getCommentsBefore(token);\n          // eslint 3.x\n          } else {\n            const potentialComment = sourceCode.getTokenBefore(token, { includeComments: true });\n            previousComment = previousToken === potentialComment ? [] : [potentialComment];\n          }\n\n          // Take comments into consideration to narrow the fix range to what is actually affected. (See #1414)\n          if (previousComment.length > 0) {\n            return fixByTrimmingWhitespace(fixer, Math.max(previousToken.range[1], previousComment[0].range[1]), token.range[0], 'end');\n          }\n\n          return fixByTrimmingWhitespace(fixer, previousToken.range[1], token.range[0], 'end');\n        },\n      });\n    }\n\n    /**\n    * Reports that there should be a space after the first token\n    * @param {ASTNode} node - The node to report in the event of an error.\n    * @param {Token} token - The token to use for the report.\n    * @returns {void}\n    */\n    function reportRequiredBeginningSpace(node, token) {\n      report(context, messages.spaceNeededAfter, 'spaceNeededAfter', {\n        node,\n        loc: token.loc.start,\n        data: {\n          token: token.value,\n        },\n        fix(fixer) {\n          return fixer.insertTextAfter(token, ' ');\n        },\n      });\n    }\n\n    /**\n    * Reports that there should be a space before the last token\n    * @param {ASTNode} node - The node to report in the event of an error.\n    * @param {Token} token - The token to use for the report.\n    * @returns {void}\n    */\n    function reportRequiredEndingSpace(node, token) {\n      report(context, messages.spaceNeededBefore, 'spaceNeededBefore', {\n        node,\n        loc: token.loc.start,\n        data: {\n          token: token.value,\n        },\n        fix(fixer) {\n          return fixer.insertTextBefore(token, ' ');\n        },\n      });\n    }\n\n    /**\n     * Determines if spacing in curly braces is valid.\n     * @param {ASTNode} node The AST node to check.\n     * @returns {void}\n     */\n    function validateBraceSpacing(node) {\n      let config;\n      switch (node.parent.type) {\n        case 'JSXAttribute':\n        case 'JSXOpeningElement':\n          config = attributesConfig;\n          break;\n\n        case 'JSXElement':\n        case 'JSXFragment':\n          config = childrenConfig;\n          break;\n\n        default:\n          return;\n      }\n      if (config === null) {\n        return;\n      }\n\n      const sourceCode = getSourceCode(context);\n      const first = sourceCode.getFirstToken(node);\n      const last = sourceCode.getLastToken(node);\n      let second = sourceCode.getTokenAfter(first, { includeComments: true });\n      let penultimate = sourceCode.getTokenBefore(last, { includeComments: true });\n\n      if (!second) {\n        second = sourceCode.getTokenAfter(first);\n        const leadingComments = sourceCode.getNodeByRangeIndex(second.range[0]).leadingComments;\n        second = leadingComments ? leadingComments[0] : second;\n      }\n      if (!penultimate) {\n        penultimate = sourceCode.getTokenBefore(last);\n        const trailingComments = sourceCode.getNodeByRangeIndex(penultimate.range[0]).trailingComments;\n        penultimate = trailingComments ? trailingComments[trailingComments.length - 1] : penultimate;\n      }\n\n      const isObjectLiteral = first.value === second.value;\n      const spacing = isObjectLiteral ? config.objectLiteralSpaces : config.when;\n      if (spacing === SPACING.always) {\n        if (!sourceCode.isSpaceBetweenTokens(first, second)) {\n          reportRequiredBeginningSpace(node, first);\n        } else if (!config.allowMultiline && isMultiline(first, second)) {\n          reportNoBeginningNewline(node, first, spacing);\n        }\n        if (!sourceCode.isSpaceBetweenTokens(penultimate, last)) {\n          reportRequiredEndingSpace(node, last);\n        } else if (!config.allowMultiline && isMultiline(penultimate, last)) {\n          reportNoEndingNewline(node, last, spacing);\n        }\n      } else if (spacing === SPACING.never) {\n        if (isMultiline(first, second)) {\n          if (!config.allowMultiline) {\n            reportNoBeginningNewline(node, first, spacing);\n          }\n        } else if (sourceCode.isSpaceBetweenTokens(first, second)) {\n          reportNoBeginningSpace(node, first);\n        }\n        if (isMultiline(penultimate, last)) {\n          if (!config.allowMultiline) {\n            reportNoEndingNewline(node, last, spacing);\n          }\n        } else if (sourceCode.isSpaceBetweenTokens(penultimate, last)) {\n          reportNoEndingSpace(node, last);\n        }\n      }\n    }\n\n    // --------------------------------------------------------------------------\n    // Public\n    // --------------------------------------------------------------------------\n\n    return {\n      JSXExpressionContainer: validateBraceSpacing,\n      JSXSpreadAttribute: validateBraceSpacing,\n    };\n  },\n};\n"
        }
    ]
}