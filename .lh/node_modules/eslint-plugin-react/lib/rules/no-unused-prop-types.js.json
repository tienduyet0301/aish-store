{
    "sourceFile": "node_modules/eslint-plugin-react/lib/rules/no-unused-prop-types.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892275564,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Prevent definitions of unused prop types\n * @author Evgueni Naverniouk\n */\n\n'use strict';\n\nconst values = require('object.values');\n\n// As for exceptions for props.children or props.className (and alike) look at\n// https://github.com/jsx-eslint/eslint-plugin-react/issues/7\n\nconst Components = require('../util/Components');\nconst docsUrl = require('../util/docsUrl');\nconst report = require('../util/report');\n\n/**\n * Checks if the component must be validated\n * @param {Object} component The component to process\n * @returns {boolean} True if the component must be validated, false if not.\n */\nfunction mustBeValidated(component) {\n  return !!component && !component.ignoreUnusedPropTypesValidation;\n}\n\n// ------------------------------------------------------------------------------\n// Rule Definition\n// ------------------------------------------------------------------------------\n\nconst messages = {\n  unusedPropType: '\\'{{name}}\\' PropType is defined but prop is never used',\n};\n\n/** @type {import('eslint').Rule.RuleModule} */\nmodule.exports = {\n  meta: {\n    docs: {\n      description: 'Disallow definitions of unused propTypes',\n      category: 'Best Practices',\n      recommended: false,\n      url: docsUrl('no-unused-prop-types'),\n    },\n\n    messages,\n\n    schema: [{\n      type: 'object',\n      properties: {\n        ignore: {\n          type: 'array',\n          items: {\n            type: 'string',\n          },\n          uniqueItems: true,\n        },\n        customValidators: {\n          type: 'array',\n          items: {\n            type: 'string',\n          },\n        },\n        skipShapeProps: {\n          type: 'boolean',\n        },\n      },\n      additionalProperties: false,\n    }],\n  },\n\n  create: Components.detect((context, components) => {\n    const defaults = { skipShapeProps: true, customValidators: [], ignore: [] };\n    const configuration = Object.assign({}, defaults, context.options[0] || {});\n\n    /**\n     * Checks if the prop is ignored\n     * @param {string} name Name of the prop to check.\n     * @returns {boolean} True if the prop is ignored, false if not.\n     */\n    function isIgnored(name) {\n      return configuration.ignore.indexOf(name) !== -1;\n    }\n\n    /**\n     * Checks if a prop is used\n     * @param {ASTNode} node The AST node being checked.\n     * @param {Object} prop Declared prop object\n     * @returns {boolean} True if the prop is used, false if not.\n     */\n    function isPropUsed(node, prop) {\n      const usedPropTypes = node.usedPropTypes || [];\n      for (let i = 0, l = usedPropTypes.length; i < l; i++) {\n        const usedProp = usedPropTypes[i];\n        if (\n          prop.type === 'shape'\n          || prop.type === 'exact'\n          || prop.name === '__ANY_KEY__'\n          || usedProp.name === prop.name\n        ) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n\n    /**\n     * Used to recursively loop through each declared prop type\n     * @param {Object} component The component to process\n     * @param {ASTNode[]|true} props List of props to validate\n     */\n    function reportUnusedPropType(component, props) {\n      // Skip props that check instances\n      if (props === true) {\n        return;\n      }\n\n      Object.keys(props || {}).forEach((key) => {\n        const prop = props[key];\n        // Skip props that check instances\n        if (prop === true) {\n          return;\n        }\n\n        if ((prop.type === 'shape' || prop.type === 'exact') && configuration.skipShapeProps) {\n          return;\n        }\n\n        if (prop.node && prop.node.typeAnnotation && prop.node.typeAnnotation.typeAnnotation\n          && prop.node.typeAnnotation.typeAnnotation.type === 'TSNeverKeyword') {\n          return;\n        }\n\n        if (prop.node && !isIgnored(prop.fullName) && !isPropUsed(component, prop)) {\n          report(context, messages.unusedPropType, 'unusedPropType', {\n            node: prop.node.key || prop.node,\n            data: {\n              name: prop.fullName,\n            },\n          });\n        }\n\n        if (prop.children) {\n          reportUnusedPropType(component, prop.children);\n        }\n      });\n    }\n\n    /**\n     * Reports unused proptypes for a given component\n     * @param {Object} component The component to process\n     */\n    function reportUnusedPropTypes(component) {\n      reportUnusedPropType(component, component.declaredPropTypes);\n    }\n\n    // --------------------------------------------------------------------------\n    // Public\n    // --------------------------------------------------------------------------\n\n    return {\n      'Program:exit'() {\n        // Report undeclared proptypes for all classes\n        values(components.list())\n          .filter((component) => mustBeValidated(component))\n          .forEach((component) => {\n            reportUnusedPropTypes(component);\n          });\n      },\n    };\n  }),\n};\n"
        }
    ]
}