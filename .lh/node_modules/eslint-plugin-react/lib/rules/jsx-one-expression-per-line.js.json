{
    "sourceFile": "node_modules/eslint-plugin-react/lib/rules/jsx-one-expression-per-line.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892271985,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Limit to one expression per line in JSX\n * @author Mark Ivan Allen <Vydia.com>\n */\n\n'use strict';\n\nconst docsUrl = require('../util/docsUrl');\nconst eslintUtil = require('../util/eslint');\nconst jsxUtil = require('../util/jsx');\nconst report = require('../util/report');\n\nconst getSourceCode = eslintUtil.getSourceCode;\nconst getText = eslintUtil.getText;\n\n// ------------------------------------------------------------------------------\n// Rule Definition\n// ------------------------------------------------------------------------------\n\nconst optionDefaults = {\n  allow: 'none',\n};\n\nconst messages = {\n  moveToNewLine: '`{{descriptor}}` must be placed on a new line',\n};\n\n/** @type {import('eslint').Rule.RuleModule} */\nmodule.exports = {\n  meta: {\n    docs: {\n      description: 'Require one JSX element per line',\n      category: 'Stylistic Issues',\n      recommended: false,\n      url: docsUrl('jsx-one-expression-per-line'),\n    },\n    fixable: 'whitespace',\n\n    messages,\n\n    schema: [\n      {\n        type: 'object',\n        properties: {\n          allow: {\n            enum: ['none', 'literal', 'single-child', 'non-jsx'],\n          },\n        },\n        default: optionDefaults,\n        additionalProperties: false,\n      },\n    ],\n  },\n\n  create(context) {\n    const options = Object.assign({}, optionDefaults, context.options[0]);\n\n    function nodeKey(node) {\n      return `${node.loc.start.line},${node.loc.start.column}`;\n    }\n\n    /**\n     * @param {ASTNode} n\n     * @returns {string}\n     */\n    function nodeDescriptor(n) {\n      return n.openingElement ? n.openingElement.name.name : getText(context, n).replace(/\\n/g, '');\n    }\n\n    function handleJSX(node) {\n      const children = node.children;\n\n      if (!children || !children.length) {\n        return;\n      }\n\n      if (\n        options.allow === 'non-jsx'\n        && !children.find((child) => (child.type === 'JSXFragment' || child.type === 'JSXElement'))\n      ) {\n        return;\n      }\n\n      const openingElement = node.openingElement || node.openingFragment;\n      const closingElement = node.closingElement || node.closingFragment;\n      const openingElementStartLine = openingElement.loc.start.line;\n      const openingElementEndLine = openingElement.loc.end.line;\n      const closingElementStartLine = closingElement.loc.start.line;\n      const closingElementEndLine = closingElement.loc.end.line;\n\n      if (children.length === 1) {\n        const child = children[0];\n        if (\n          openingElementStartLine === openingElementEndLine\n          && openingElementEndLine === closingElementStartLine\n          && closingElementStartLine === closingElementEndLine\n          && closingElementEndLine === child.loc.start.line\n          && child.loc.start.line === child.loc.end.line\n        ) {\n          if (\n            options.allow === 'single-child'\n            || (options.allow === 'literal' && (child.type === 'Literal' || child.type === 'JSXText'))\n          ) {\n            return;\n          }\n        }\n      }\n\n      const childrenGroupedByLine = {};\n      const fixDetailsByNode = {};\n\n      children.forEach((child) => {\n        let countNewLinesBeforeContent = 0;\n        let countNewLinesAfterContent = 0;\n\n        if (child.type === 'Literal' || child.type === 'JSXText') {\n          if (jsxUtil.isWhiteSpaces(child.raw)) {\n            return;\n          }\n\n          countNewLinesBeforeContent = (child.raw.match(/^\\s*\\n/g) || []).length;\n          countNewLinesAfterContent = (child.raw.match(/\\n\\s*$/g) || []).length;\n        }\n\n        const startLine = child.loc.start.line + countNewLinesBeforeContent;\n        const endLine = child.loc.end.line - countNewLinesAfterContent;\n\n        if (startLine === endLine) {\n          if (!childrenGroupedByLine[startLine]) {\n            childrenGroupedByLine[startLine] = [];\n          }\n          childrenGroupedByLine[startLine].push(child);\n        } else {\n          if (!childrenGroupedByLine[startLine]) {\n            childrenGroupedByLine[startLine] = [];\n          }\n          childrenGroupedByLine[startLine].push(child);\n          if (!childrenGroupedByLine[endLine]) {\n            childrenGroupedByLine[endLine] = [];\n          }\n          childrenGroupedByLine[endLine].push(child);\n        }\n      });\n\n      Object.keys(childrenGroupedByLine).forEach((_line) => {\n        const line = parseInt(_line, 10);\n        const firstIndex = 0;\n        const lastIndex = childrenGroupedByLine[line].length - 1;\n\n        childrenGroupedByLine[line].forEach((child, i) => {\n          let prevChild;\n          let nextChild;\n\n          if (i === firstIndex) {\n            if (line === openingElementEndLine) {\n              prevChild = openingElement;\n            }\n          } else {\n            prevChild = childrenGroupedByLine[line][i - 1];\n          }\n\n          if (i === lastIndex) {\n            if (line === closingElementStartLine) {\n              nextChild = closingElement;\n            }\n          } else {\n            // We don't need to append a trailing because the next child will prepend a leading.\n            // nextChild = childrenGroupedByLine[line][i + 1];\n          }\n\n          function spaceBetweenPrev() {\n            return ((prevChild.type === 'Literal' || prevChild.type === 'JSXText') && / $/.test(prevChild.raw))\n              || ((child.type === 'Literal' || child.type === 'JSXText') && /^ /.test(child.raw))\n              || getSourceCode(context).isSpaceBetweenTokens(prevChild, child);\n          }\n\n          function spaceBetweenNext() {\n            return ((nextChild.type === 'Literal' || nextChild.type === 'JSXText') && /^ /.test(nextChild.raw))\n              || ((child.type === 'Literal' || child.type === 'JSXText') && / $/.test(child.raw))\n              || getSourceCode(context).isSpaceBetweenTokens(child, nextChild);\n          }\n\n          if (!prevChild && !nextChild) {\n            return;\n          }\n\n          const source = getText(context, child);\n          const leadingSpace = !!(prevChild && spaceBetweenPrev());\n          const trailingSpace = !!(nextChild && spaceBetweenNext());\n          const leadingNewLine = !!prevChild;\n          const trailingNewLine = !!nextChild;\n\n          const key = nodeKey(child);\n\n          if (!fixDetailsByNode[key]) {\n            fixDetailsByNode[key] = {\n              node: child,\n              source,\n              descriptor: nodeDescriptor(child),\n            };\n          }\n\n          if (leadingSpace) {\n            fixDetailsByNode[key].leadingSpace = true;\n          }\n          if (leadingNewLine) {\n            fixDetailsByNode[key].leadingNewLine = true;\n          }\n          if (trailingNewLine) {\n            fixDetailsByNode[key].trailingNewLine = true;\n          }\n          if (trailingSpace) {\n            fixDetailsByNode[key].trailingSpace = true;\n          }\n        });\n      });\n\n      Object.keys(fixDetailsByNode).forEach((key) => {\n        const details = fixDetailsByNode[key];\n\n        const nodeToReport = details.node;\n        const descriptor = details.descriptor;\n        const source = details.source.replace(/(^ +| +(?=\\n)*$)/g, '');\n\n        const leadingSpaceString = details.leadingSpace ? '\\n{\\' \\'}' : '';\n        const trailingSpaceString = details.trailingSpace ? '{\\' \\'}\\n' : '';\n        const leadingNewLineString = details.leadingNewLine ? '\\n' : '';\n        const trailingNewLineString = details.trailingNewLine ? '\\n' : '';\n\n        const replaceText = `${leadingSpaceString}${leadingNewLineString}${source}${trailingNewLineString}${trailingSpaceString}`;\n\n        report(context, messages.moveToNewLine, 'moveToNewLine', {\n          node: nodeToReport,\n          data: {\n            descriptor,\n          },\n          fix(fixer) {\n            return fixer.replaceText(nodeToReport, replaceText);\n          },\n        });\n      });\n    }\n\n    return {\n      JSXElement: handleJSX,\n      JSXFragment: handleJSX,\n    };\n  },\n};\n"
        }
    ]
}