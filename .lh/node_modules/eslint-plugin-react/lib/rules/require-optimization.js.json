{
    "sourceFile": "node_modules/eslint-plugin-react/lib/rules/require-optimization.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892277040,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Enforce React components to have a shouldComponentUpdate method\n * @author Evgueni Naverniouk\n */\n\n'use strict';\n\nconst values = require('object.values');\n\nconst Components = require('../util/Components');\nconst componentUtil = require('../util/componentUtil');\nconst docsUrl = require('../util/docsUrl');\nconst report = require('../util/report');\nconst getScope = require('../util/eslint').getScope;\n\nconst messages = {\n  noShouldComponentUpdate: 'Component is not optimized. Please add a shouldComponentUpdate method.',\n};\n\n/** @type {import('eslint').Rule.RuleModule} */\nmodule.exports = {\n  meta: {\n    docs: {\n      description: 'Enforce React components to have a shouldComponentUpdate method',\n      category: 'Best Practices',\n      recommended: false,\n      url: docsUrl('require-optimization'),\n    },\n\n    messages,\n\n    schema: [{\n      type: 'object',\n      properties: {\n        allowDecorators: {\n          type: 'array',\n          items: {\n            type: 'string',\n          },\n        },\n      },\n      additionalProperties: false,\n    }],\n  },\n\n  create: Components.detect((context, components) => {\n    const configuration = context.options[0] || {};\n    const allowDecorators = configuration.allowDecorators || [];\n\n    /**\n     * Checks to see if our component is decorated by PureRenderMixin via reactMixin\n     * @param {ASTNode} node The AST node being checked.\n     * @returns {boolean} True if node is decorated with a PureRenderMixin, false if not.\n     */\n    function hasPureRenderDecorator(node) {\n      if (node.decorators && node.decorators.length) {\n        for (let i = 0, l = node.decorators.length; i < l; i++) {\n          if (\n            node.decorators[i].expression\n            && node.decorators[i].expression.callee\n            && node.decorators[i].expression.callee.object\n            && node.decorators[i].expression.callee.object.name === 'reactMixin'\n            && node.decorators[i].expression.callee.property\n            && node.decorators[i].expression.callee.property.name === 'decorate'\n            && node.decorators[i].expression.arguments\n            && node.decorators[i].expression.arguments.length\n            && node.decorators[i].expression.arguments[0].name === 'PureRenderMixin'\n          ) {\n            return true;\n          }\n        }\n      }\n\n      return false;\n    }\n\n    /**\n     * Checks to see if our component is custom decorated\n     * @param {ASTNode} node The AST node being checked.\n     * @returns {boolean} True if node is decorated name with a custom decorated, false if not.\n     */\n    function hasCustomDecorator(node) {\n      const allowLength = allowDecorators.length;\n\n      if (allowLength && node.decorators && node.decorators.length) {\n        for (let i = 0; i < allowLength; i++) {\n          for (let j = 0, l = node.decorators.length; j < l; j++) {\n            const expression = node.decorators[j].expression;\n            if (\n              expression\n              && expression.name === allowDecorators[i]\n            ) {\n              return true;\n            }\n          }\n        }\n      }\n\n      return false;\n    }\n\n    /**\n     * Checks if we are declaring a shouldComponentUpdate method\n     * @param {ASTNode} node The AST node being checked.\n     * @returns {boolean} True if we are declaring a shouldComponentUpdate method, false if not.\n     */\n    function isSCUDeclared(node) {\n      return !!node && node.name === 'shouldComponentUpdate';\n    }\n\n    /**\n     * Checks if we are declaring a PureRenderMixin mixin\n     * @param {ASTNode} node The AST node being checked.\n     * @returns {boolean} True if we are declaring a PureRenderMixin method, false if not.\n     */\n    function isPureRenderDeclared(node) {\n      let hasPR = false;\n      if (node.value && node.value.elements) {\n        for (let i = 0, l = node.value.elements.length; i < l; i++) {\n          if (node.value.elements[i] && node.value.elements[i].name === 'PureRenderMixin') {\n            hasPR = true;\n            break;\n          }\n        }\n      }\n\n      return (\n        !!node\n        && node.key.name === 'mixins'\n        && hasPR\n      );\n    }\n\n    /**\n     * Mark shouldComponentUpdate as declared\n     * @param {ASTNode} node The AST node being checked.\n     */\n    function markSCUAsDeclared(node) {\n      components.set(node, {\n        hasSCU: true,\n      });\n    }\n\n    /**\n     * Reports missing optimization for a given component\n     * @param {Object} component The component to process\n     */\n    function reportMissingOptimization(component) {\n      report(context, messages.noShouldComponentUpdate, 'noShouldComponentUpdate', {\n        node: component.node,\n      });\n    }\n\n    /**\n     * Checks if we are declaring function in class\n     * @param {ASTNode} node\n     * @returns {boolean} True if we are declaring function in class, false if not.\n     */\n    function isFunctionInClass(node) {\n      let blockNode;\n      let scope = getScope(context, node);\n      while (scope) {\n        blockNode = scope.block;\n        if (blockNode && blockNode.type === 'ClassDeclaration') {\n          return true;\n        }\n        scope = scope.upper;\n      }\n\n      return false;\n    }\n\n    return {\n      ArrowFunctionExpression(node) {\n        // Skip if the function is declared in the class\n        if (isFunctionInClass(node)) {\n          return;\n        }\n        // Stateless Functional Components cannot be optimized (yet)\n        markSCUAsDeclared(node);\n      },\n\n      ClassDeclaration(node) {\n        if (!(\n          hasPureRenderDecorator(node)\n          || hasCustomDecorator(node)\n          || componentUtil.isPureComponent(node, context)\n        )) {\n          return;\n        }\n        markSCUAsDeclared(node);\n      },\n\n      FunctionDeclaration(node) {\n        // Skip if the function is declared in the class\n        if (isFunctionInClass(node)) {\n          return;\n        }\n        // Stateless Functional Components cannot be optimized (yet)\n        markSCUAsDeclared(node);\n      },\n\n      FunctionExpression(node) {\n        // Skip if the function is declared in the class\n        if (isFunctionInClass(node)) {\n          return;\n        }\n        // Stateless Functional Components cannot be optimized (yet)\n        markSCUAsDeclared(node);\n      },\n\n      MethodDefinition(node) {\n        if (!isSCUDeclared(node.key)) {\n          return;\n        }\n        markSCUAsDeclared(node);\n      },\n\n      ObjectExpression(node) {\n        // Search for the shouldComponentUpdate declaration\n        const found = node.properties.some((property) => (\n          property.key\n          && (isSCUDeclared(property.key) || isPureRenderDeclared(property))\n        ));\n        if (found) {\n          markSCUAsDeclared(node);\n        }\n      },\n\n      'Program:exit'() {\n        // Report missing shouldComponentUpdate for all components\n        values(components.list())\n          .filter((component) => !component.hasSCU)\n          .forEach((component) => {\n            reportMissingOptimization(component);\n          });\n      },\n    };\n  }),\n};\n"
        }
    ]
}