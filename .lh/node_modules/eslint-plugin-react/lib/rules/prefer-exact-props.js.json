{
    "sourceFile": "node_modules/eslint-plugin-react/lib/rules/prefer-exact-props.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892275878,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Prefer exact proptype definitions\n */\n\n'use strict';\n\nconst Components = require('../util/Components');\nconst docsUrl = require('../util/docsUrl');\nconst astUtil = require('../util/ast');\nconst propsUtil = require('../util/props');\nconst propWrapperUtil = require('../util/propWrapper');\nconst variableUtil = require('../util/variable');\nconst report = require('../util/report');\nconst getText = require('../util/eslint').getText;\n\n// -----------------------------------------------------------------------------\n// Rule Definition\n// -----------------------------------------------------------------------------\n\nconst messages = {\n  propTypes: 'Component propTypes should be exact by using {{exactPropWrappers}}.',\n  flow: 'Component flow props should be set with exact objects.',\n};\n\n/** @type {import('eslint').Rule.RuleModule} */\nmodule.exports = {\n  meta: {\n    docs: {\n      description: 'Prefer exact proptype definitions',\n      category: 'Possible Errors',\n      recommended: false,\n      url: docsUrl('prefer-exact-props'),\n    },\n    messages,\n    schema: [],\n  },\n\n  create: Components.detect((context, components, utils) => {\n    const typeAliases = {};\n    const exactWrappers = propWrapperUtil.getExactPropWrapperFunctions(context);\n\n    function getPropTypesErrorMessage() {\n      const formattedWrappers = propWrapperUtil.formatPropWrapperFunctions(exactWrappers);\n      const message = exactWrappers.size > 1 ? `one of ${formattedWrappers}` : formattedWrappers;\n      return { exactPropWrappers: message };\n    }\n\n    function isNonExactObjectTypeAnnotation(node) {\n      return (\n        node\n        && node.type === 'ObjectTypeAnnotation'\n        && node.properties.length > 0\n        && !node.exact\n      );\n    }\n\n    function hasNonExactObjectTypeAnnotation(node) {\n      const typeAnnotation = node.typeAnnotation;\n      return (\n        typeAnnotation\n        && typeAnnotation.typeAnnotation\n        && isNonExactObjectTypeAnnotation(typeAnnotation.typeAnnotation)\n      );\n    }\n\n    function hasGenericTypeAnnotation(node) {\n      const typeAnnotation = node.typeAnnotation;\n      return (\n        typeAnnotation\n        && typeAnnotation.typeAnnotation\n        && typeAnnotation.typeAnnotation.type === 'GenericTypeAnnotation'\n      );\n    }\n\n    function isNonEmptyObjectExpression(node) {\n      return (\n        node\n        && node.type === 'ObjectExpression'\n        && node.properties.length > 0\n      );\n    }\n\n    function isNonExactPropWrapperFunction(node) {\n      return (\n        astUtil.isCallExpression(node)\n        && !propWrapperUtil.isExactPropWrapperFunction(context, getText(context, node.callee))\n      );\n    }\n\n    function reportPropTypesError(node) {\n      report(context, messages.propTypes, 'propTypes', {\n        node,\n        data: getPropTypesErrorMessage(),\n      });\n    }\n\n    function reportFlowError(node) {\n      report(context, messages.flow, 'flow', {\n        node,\n      });\n    }\n\n    return {\n      TypeAlias(node) {\n        // working around an issue with eslint@3 and babel-eslint not finding the TypeAlias in scope\n        typeAliases[node.id.name] = node;\n      },\n\n      'ClassProperty, PropertyDefinition'(node) {\n        if (!propsUtil.isPropTypesDeclaration(node)) {\n          return;\n        }\n\n        if (hasNonExactObjectTypeAnnotation(node)) {\n          reportFlowError(node);\n        } else if (exactWrappers.size > 0 && isNonEmptyObjectExpression(node.value)) {\n          reportPropTypesError(node);\n        } else if (exactWrappers.size > 0 && isNonExactPropWrapperFunction(node.value)) {\n          reportPropTypesError(node);\n        }\n      },\n\n      Identifier(node) {\n        if (!utils.getStatelessComponent(node.parent)) {\n          return;\n        }\n\n        if (hasNonExactObjectTypeAnnotation(node)) {\n          reportFlowError(node);\n        } else if (hasGenericTypeAnnotation(node)) {\n          const identifier = node.typeAnnotation.typeAnnotation.id.name;\n          const typeAlias = typeAliases[identifier];\n          const propsDefinition = typeAlias ? typeAlias.right : null;\n          if (isNonExactObjectTypeAnnotation(propsDefinition)) {\n            reportFlowError(node);\n          }\n        }\n      },\n\n      MemberExpression(node) {\n        if (!propsUtil.isPropTypesDeclaration(node) || exactWrappers.size === 0) {\n          return;\n        }\n\n        const right = node.parent.right;\n        if (isNonEmptyObjectExpression(right)) {\n          reportPropTypesError(node);\n        } else if (isNonExactPropWrapperFunction(right)) {\n          reportPropTypesError(node);\n        } else if (right.type === 'Identifier') {\n          const identifier = right.name;\n          const propsDefinition = variableUtil.findVariableByName(context, node, identifier);\n          if (isNonEmptyObjectExpression(propsDefinition)) {\n            reportPropTypesError(node);\n          } else if (isNonExactPropWrapperFunction(propsDefinition)) {\n            reportPropTypesError(node);\n          }\n        }\n      },\n    };\n  }),\n};\n"
        }
    ]
}