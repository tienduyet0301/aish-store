{
    "sourceFile": "node_modules/eslint-plugin-react/lib/rules/jsx-closing-tag-location.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892268522,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Validate closing tag location in JSX\n * @author Ross Solomon\n */\n\n'use strict';\n\nconst repeat = require('string.prototype.repeat');\nconst has = require('hasown');\n\nconst astUtil = require('../util/ast');\nconst docsUrl = require('../util/docsUrl');\nconst getSourceCode = require('../util/eslint').getSourceCode;\nconst report = require('../util/report');\n\n// ------------------------------------------------------------------------------\n// Rule Definition\n// ------------------------------------------------------------------------------\n\nconst messages = {\n  onOwnLine: 'Closing tag of a multiline JSX expression must be on its own line.',\n  matchIndent: 'Expected closing tag to match indentation of opening.',\n  alignWithOpening: 'Expected closing tag to be aligned with the line containing the opening tag',\n};\n\nconst defaultOption = 'tag-aligned';\n\nconst optionMessageMap = {\n  'tag-aligned': 'matchIndent',\n  'line-aligned': 'alignWithOpening',\n};\n\n/** @type {import('eslint').Rule.RuleModule} */\nmodule.exports = {\n  meta: {\n    docs: {\n      description: 'Enforce closing tag location for multiline JSX',\n      category: 'Stylistic Issues',\n      recommended: false,\n      url: docsUrl('jsx-closing-tag-location'),\n    },\n    fixable: 'whitespace',\n    messages,\n    schema: [{\n      anyOf: [\n        {\n          enum: ['tag-aligned', 'line-aligned'],\n        },\n        {\n          type: 'object',\n          properties: {\n            location: {\n              enum: ['tag-aligned', 'line-aligned'],\n            },\n          },\n          additionalProperties: false,\n        },\n      ],\n    }],\n  },\n\n  create(context) {\n    const config = context.options[0];\n    let option = defaultOption;\n\n    if (typeof config === 'string') {\n      option = config;\n    } else if (typeof config === 'object') {\n      if (has(config, 'location')) {\n        option = config.location;\n      }\n    }\n\n    function getIndentation(openingStartOfLine, opening) {\n      if (option === 'line-aligned') return openingStartOfLine.column;\n      if (option === 'tag-aligned') return opening.loc.start.column;\n    }\n\n    function handleClosingElement(node) {\n      if (!node.parent) {\n        return;\n      }\n      const sourceCode = getSourceCode(context);\n\n      const opening = node.parent.openingElement || node.parent.openingFragment;\n      const openingLoc = sourceCode.getFirstToken(opening).loc.start;\n      const openingLine = sourceCode.lines[openingLoc.line - 1];\n\n      const openingStartOfLine = {\n        column: /^\\s*/.exec(openingLine)[0].length,\n        line: openingLoc.line,\n      };\n\n      if (opening.loc.start.line === node.loc.start.line) {\n        return;\n      }\n\n      if (\n        opening.loc.start.column === node.loc.start.column\n        && option === 'tag-aligned'\n      ) {\n        return;\n      }\n\n      if (\n        openingStartOfLine.column === node.loc.start.column\n        && option === 'line-aligned'\n      ) {\n        return;\n      }\n\n      const messageId = astUtil.isNodeFirstInLine(context, node)\n        ? optionMessageMap[option]\n        : 'onOwnLine';\n\n      report(context, messages[messageId], messageId, {\n        node,\n        loc: node.loc,\n        fix(fixer) {\n          const indent = repeat(\n            ' ',\n            getIndentation(openingStartOfLine, opening)\n          );\n\n          if (astUtil.isNodeFirstInLine(context, node)) {\n            return fixer.replaceTextRange(\n              [node.range[0] - node.loc.start.column, node.range[0]],\n              indent\n            );\n          }\n\n          return fixer.insertTextBefore(node, `\\n${indent}`);\n        },\n      });\n    }\n\n    return {\n      JSXClosingElement: handleClosingElement,\n      JSXClosingFragment: handleClosingElement,\n    };\n  },\n};\n"
        }
    ]
}