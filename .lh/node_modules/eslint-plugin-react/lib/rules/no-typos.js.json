{
    "sourceFile": "node_modules/eslint-plugin-react/lib/rules/no-typos.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892275109,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Prevent common casing typos\n */\n\n'use strict';\n\nconst PROP_TYPES = Object.keys(require('prop-types'));\nconst Components = require('../util/Components');\nconst docsUrl = require('../util/docsUrl');\nconst astUtil = require('../util/ast');\nconst componentUtil = require('../util/componentUtil');\nconst report = require('../util/report');\nconst lifecycleMethods = require('../util/lifecycleMethods');\n\n// ------------------------------------------------------------------------------\n// Rule Definition\n// ------------------------------------------------------------------------------\n\nconst STATIC_CLASS_PROPERTIES = ['propTypes', 'contextTypes', 'childContextTypes', 'defaultProps'];\n\nconst messages = {\n  typoPropTypeChain: 'Typo in prop type chain qualifier: {{name}}',\n  typoPropType: 'Typo in declared prop type: {{name}}',\n  typoStaticClassProp: 'Typo in static class property declaration',\n  typoPropDeclaration: 'Typo in property declaration',\n  typoLifecycleMethod: 'Typo in component lifecycle method declaration: {{actual}} should be {{expected}}',\n  staticLifecycleMethod: 'Lifecycle method should be static: {{method}}',\n  noPropTypesBinding: '`\\'prop-types\\'` imported without a local `PropTypes` binding.',\n  noReactBinding: '`\\'react\\'` imported without a local `React` binding.',\n};\n\n/** @type {import('eslint').Rule.RuleModule} */\nmodule.exports = {\n  meta: {\n    docs: {\n      description: 'Disallow common typos',\n      category: 'Stylistic Issues',\n      recommended: false,\n      url: docsUrl('no-typos'),\n    },\n\n    messages,\n\n    schema: [],\n  },\n\n  create: Components.detect((context, components, utils) => {\n    let propTypesPackageName = null;\n    let reactPackageName = null;\n\n    function checkValidPropTypeQualifier(node) {\n      if (node.name !== 'isRequired') {\n        report(context, messages.typoPropTypeChain, 'typoPropTypeChain', {\n          node,\n          data: { name: node.name },\n        });\n      }\n    }\n\n    function checkValidPropType(node) {\n      if (node.name && !PROP_TYPES.some((propTypeName) => propTypeName === node.name)) {\n        report(context, messages.typoPropType, 'typoPropType', {\n          node,\n          data: { name: node.name },\n        });\n      }\n    }\n\n    function isPropTypesPackage(node) {\n      return (\n        node.type === 'Identifier'\n        && node.name === propTypesPackageName\n      ) || (\n        node.type === 'MemberExpression'\n        && node.property.name === 'PropTypes'\n        && node.object.name === reactPackageName\n      );\n    }\n\n    /* eslint-disable no-use-before-define */\n\n    function checkValidCallExpression(node) {\n      const callee = node.callee;\n      if (callee.type === 'MemberExpression' && callee.property.name === 'shape') {\n        checkValidPropObject(node.arguments[0]);\n      } else if (callee.type === 'MemberExpression' && callee.property.name === 'oneOfType') {\n        const args = node.arguments[0];\n        if (args && args.type === 'ArrayExpression') {\n          args.elements.forEach((el) => {\n            checkValidProp(el);\n          });\n        }\n      }\n    }\n\n    function checkValidProp(node) {\n      if ((!propTypesPackageName && !reactPackageName) || !node) {\n        return;\n      }\n\n      if (node.type === 'MemberExpression') {\n        if (\n          node.object.type === 'MemberExpression'\n          && isPropTypesPackage(node.object.object)\n        ) { // PropTypes.myProp.isRequired\n          checkValidPropType(node.object.property);\n          checkValidPropTypeQualifier(node.property);\n        } else if (\n          isPropTypesPackage(node.object)\n          && node.property.name !== 'isRequired'\n        ) { // PropTypes.myProp\n          checkValidPropType(node.property);\n        } else if (astUtil.isCallExpression(node.object)) {\n          checkValidPropTypeQualifier(node.property);\n          checkValidCallExpression(node.object);\n        }\n      } else if (astUtil.isCallExpression(node)) {\n        checkValidCallExpression(node);\n      }\n    }\n\n    /* eslint-enable no-use-before-define */\n\n    function checkValidPropObject(node) {\n      if (node && node.type === 'ObjectExpression') {\n        node.properties.forEach((prop) => checkValidProp(prop.value));\n      }\n    }\n\n    function reportErrorIfPropertyCasingTypo(propertyValue, propertyKey, isClassProperty) {\n      const propertyName = propertyKey.name;\n      if (propertyName === 'propTypes' || propertyName === 'contextTypes' || propertyName === 'childContextTypes') {\n        checkValidPropObject(propertyValue);\n      }\n      STATIC_CLASS_PROPERTIES.forEach((CLASS_PROP) => {\n        if (propertyName && CLASS_PROP.toLowerCase() === propertyName.toLowerCase() && CLASS_PROP !== propertyName) {\n          const messageId = isClassProperty\n            ? 'typoStaticClassProp'\n            : 'typoPropDeclaration';\n          report(context, messages[messageId], messageId, {\n            node: propertyKey,\n          });\n        }\n      });\n    }\n\n    function reportErrorIfLifecycleMethodCasingTypo(node) {\n      const key = node.key;\n      let nodeKeyName = key.name;\n      if (key.type === 'Literal') {\n        nodeKeyName = key.value;\n      }\n      if (key.type === 'PrivateName' || (node.computed && typeof nodeKeyName !== 'string')) {\n        return;\n      }\n\n      lifecycleMethods.static.forEach((method) => {\n        if (!node.static && nodeKeyName && nodeKeyName.toLowerCase() === method.toLowerCase()) {\n          report(context, messages.staticLifecycleMethod, 'staticLifecycleMethod', {\n            node,\n            data: {\n              method: nodeKeyName,\n            },\n          });\n        }\n      });\n\n      lifecycleMethods.instance.concat(lifecycleMethods.static).forEach((method) => {\n        if (nodeKeyName && method.toLowerCase() === nodeKeyName.toLowerCase() && method !== nodeKeyName) {\n          report(context, messages.typoLifecycleMethod, 'typoLifecycleMethod', {\n            node,\n            data: { actual: nodeKeyName, expected: method },\n          });\n        }\n      });\n    }\n\n    return {\n      ImportDeclaration(node) {\n        if (node.source && node.source.value === 'prop-types') { // import PropType from \"prop-types\"\n          if (node.specifiers.length > 0) {\n            propTypesPackageName = node.specifiers[0].local.name;\n          } else {\n            report(context, messages.noPropTypesBinding, 'noPropTypesBinding', {\n              node,\n            });\n          }\n        } else if (node.source && node.source.value === 'react') { // import { PropTypes } from \"react\"\n          if (node.specifiers.length > 0) {\n            reactPackageName = node.specifiers[0].local.name; // guard against accidental anonymous `import \"react\"`\n          } else {\n            report(context, messages.noReactBinding, 'noReactBinding', {\n              node,\n            });\n          }\n          if (node.specifiers.length >= 1) {\n            const propTypesSpecifier = node.specifiers.find((specifier) => (\n              specifier.imported\n              && specifier.imported.name === 'PropTypes'\n            ));\n            if (propTypesSpecifier) {\n              propTypesPackageName = propTypesSpecifier.local.name;\n            }\n          }\n        }\n      },\n\n      'ClassProperty, PropertyDefinition'(node) {\n        if (!node.static || !componentUtil.isES6Component(node.parent.parent, context)) {\n          return;\n        }\n\n        reportErrorIfPropertyCasingTypo(node.value, node.key, true);\n      },\n\n      MemberExpression(node) {\n        const propertyName = node.property.name;\n\n        if (\n          !propertyName\n          || STATIC_CLASS_PROPERTIES.map((prop) => prop.toLocaleLowerCase()).indexOf(propertyName.toLowerCase()) === -1\n        ) {\n          return;\n        }\n\n        const relatedComponent = utils.getRelatedComponent(node);\n\n        if (\n          relatedComponent\n            && (componentUtil.isES6Component(relatedComponent.node, context) || (\n              relatedComponent.node.type !== 'ClassDeclaration' && utils.isReturningJSX(relatedComponent.node)))\n            && (node.parent && node.parent.type === 'AssignmentExpression' && node.parent.right)\n        ) {\n          reportErrorIfPropertyCasingTypo(node.parent.right, node.property, true);\n        }\n      },\n\n      MethodDefinition(node) {\n        if (!componentUtil.isES6Component(node.parent.parent, context)) {\n          return;\n        }\n\n        reportErrorIfLifecycleMethodCasingTypo(node);\n      },\n\n      ObjectExpression(node) {\n        const component = componentUtil.isES5Component(node, context) && components.get(node);\n\n        if (!component) {\n          return;\n        }\n\n        node.properties.filter((property) => property.type !== 'SpreadElement').forEach((property) => {\n          reportErrorIfPropertyCasingTypo(property.value, property.key, false);\n          reportErrorIfLifecycleMethodCasingTypo(property);\n        });\n      },\n    };\n  }),\n};\n"
        }
    ]
}