{
    "sourceFile": "node_modules/eslint-plugin-react/lib/rules/no-unstable-nested-components.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892275403,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Prevent creating unstable components inside components\n * @author Ari Perkkiö\n */\n\n'use strict';\n\nconst minimatch = require('minimatch');\nconst Components = require('../util/Components');\nconst docsUrl = require('../util/docsUrl');\nconst astUtil = require('../util/ast');\nconst isCreateElement = require('../util/isCreateElement');\nconst report = require('../util/report');\n\n// ------------------------------------------------------------------------------\n// Constants\n// ------------------------------------------------------------------------------\n\nconst COMPONENT_AS_PROPS_INFO = ' If you want to allow component creation in props, set allowAsProps option to true.';\nconst HOOK_REGEXP = /^use[A-Z0-9].*$/;\n\n// ------------------------------------------------------------------------------\n// Helpers\n// ------------------------------------------------------------------------------\n\n/**\n * Generate error message with given parent component name\n * @param {string} parentName Name of the parent component, if known\n * @returns {string} Error message with parent component name\n */\nfunction generateErrorMessageWithParentName(parentName) {\n  return `Do not define components during render. React will see a new component type on every render and destroy the entire subtree’s DOM nodes and state (https://reactjs.org/docs/reconciliation.html#elements-of-different-types). Instead, move this component definition out of the parent component${parentName ? ` “${parentName}” ` : ' '}and pass data as props.`;\n}\n\n/**\n * Check whether given text matches the pattern passed in.\n * @param {string} text Text to validate\n * @param {string} pattern Pattern to match against\n * @returns {boolean}\n */\nfunction propMatchesRenderPropPattern(text, pattern) {\n  return typeof text === 'string' && minimatch(text, pattern);\n}\n\n/**\n * Get closest parent matching given matcher\n * @param {ASTNode} node The AST node\n * @param {Context} context eslint context\n * @param {Function} matcher Method used to match the parent\n * @returns {ASTNode} The matching parent node, if any\n */\nfunction getClosestMatchingParent(node, context, matcher) {\n  if (!node || !node.parent || node.parent.type === 'Program') {\n    return;\n  }\n\n  if (matcher(node.parent, context)) {\n    return node.parent;\n  }\n\n  return getClosestMatchingParent(node.parent, context, matcher);\n}\n\n/**\n * Matcher used to check whether given node is a `createElement` call\n * @param {ASTNode} node The AST node\n * @param {Context} context eslint context\n * @returns {boolean} True if node is a `createElement` call, false if not\n */\nfunction isCreateElementMatcher(node, context) {\n  return (\n    astUtil.isCallExpression(node)\n    && isCreateElement(context, node)\n  );\n}\n\n/**\n * Matcher used to check whether given node is a `ObjectExpression`\n * @param {ASTNode} node The AST node\n * @returns {boolean} True if node is a `ObjectExpression`, false if not\n */\nfunction isObjectExpressionMatcher(node) {\n  return node && node.type === 'ObjectExpression';\n}\n\n/**\n * Matcher used to check whether given node is a `JSXExpressionContainer`\n * @param {ASTNode} node The AST node\n * @returns {boolean} True if node is a `JSXExpressionContainer`, false if not\n */\nfunction isJSXExpressionContainerMatcher(node) {\n  return node && node.type === 'JSXExpressionContainer';\n}\n\n/**\n * Matcher used to check whether given node is a `JSXAttribute` of `JSXExpressionContainer`\n * @param {ASTNode} node The AST node\n * @returns {boolean} True if node is a `JSXAttribute` of `JSXExpressionContainer`, false if not\n */\nfunction isJSXAttributeOfExpressionContainerMatcher(node) {\n  return (\n    node\n    && node.type === 'JSXAttribute'\n    && node.value\n    && node.value.type === 'JSXExpressionContainer'\n  );\n}\n\n/**\n * Matcher used to check whether given node is an object `Property`\n * @param {ASTNode} node The AST node\n * @returns {boolean} True if node is a `Property`, false if not\n */\nfunction isPropertyOfObjectExpressionMatcher(node) {\n  return (\n    node\n    && node.parent\n    && node.parent.type === 'Property'\n  );\n}\n\n/**\n * Check whether given node or its parent is directly inside `map` call\n * ```jsx\n * {items.map(item => <li />)}\n * ```\n * @param {ASTNode} node The AST node\n * @returns {boolean} True if node is directly inside `map` call, false if not\n */\nfunction isMapCall(node) {\n  return (\n    node\n    && node.callee\n    && node.callee.property\n    && node.callee.property.name === 'map'\n  );\n}\n\n/**\n * Check whether given node is `ReturnStatement` of a React hook\n * @param {ASTNode} node The AST node\n * @param {Context} context eslint context\n * @returns {boolean} True if node is a `ReturnStatement` of a React hook, false if not\n */\nfunction isReturnStatementOfHook(node, context) {\n  if (\n    !node\n    || !node.parent\n    || node.parent.type !== 'ReturnStatement'\n  ) {\n    return false;\n  }\n\n  const callExpression = getClosestMatchingParent(node, context, astUtil.isCallExpression);\n  return (\n    callExpression\n    && callExpression.callee\n    && HOOK_REGEXP.test(callExpression.callee.name)\n  );\n}\n\n/**\n * Check whether given node is declared inside a render prop\n * ```jsx\n * <Component renderFooter={() => <div />} />\n * <Component>{() => <div />}</Component>\n * ```\n * @param {ASTNode} node The AST node\n * @param {Context} context eslint context\n * @param {string} propNamePattern a pattern to match render props against\n * @returns {boolean} True if component is declared inside a render prop, false if not\n */\nfunction isComponentInRenderProp(node, context, propNamePattern) {\n  if (\n    node\n    && node.parent\n    && node.parent.type === 'Property'\n    && node.parent.key\n    && propMatchesRenderPropPattern(node.parent.key.name, propNamePattern)\n  ) {\n    return true;\n  }\n\n  // Check whether component is a render prop used as direct children, e.g. <Component>{() => <div />}</Component>\n  if (\n    node\n    && node.parent\n    && node.parent.type === 'JSXExpressionContainer'\n    && node.parent.parent\n    && node.parent.parent.type === 'JSXElement'\n  ) {\n    return true;\n  }\n\n  const jsxExpressionContainer = getClosestMatchingParent(node, context, isJSXExpressionContainerMatcher);\n\n  // Check whether prop name indicates accepted patterns\n  if (\n    jsxExpressionContainer\n    && jsxExpressionContainer.parent\n    && jsxExpressionContainer.parent.type === 'JSXAttribute'\n    && jsxExpressionContainer.parent.name\n    && jsxExpressionContainer.parent.name.type === 'JSXIdentifier'\n  ) {\n    const propName = jsxExpressionContainer.parent.name.name;\n\n    // Starts with render, e.g. <Component renderFooter={() => <div />} />\n    if (propMatchesRenderPropPattern(propName, propNamePattern)) {\n      return true;\n    }\n\n    // Uses children prop explicitly, e.g. <Component children={() => <div />} />\n    if (propName === 'children') {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n/**\n * Check whether given node is declared directly inside a render property\n * ```jsx\n * const rows = { render: () => <div /> }\n * <Component rows={ [{ render: () => <div /> }] } />\n *  ```\n * @param {ASTNode} node The AST node\n * @param {string} propNamePattern The pattern to match render props against\n * @returns {boolean} True if component is declared inside a render property, false if not\n */\nfunction isDirectValueOfRenderProperty(node, propNamePattern) {\n  return (\n    node\n    && node.parent\n    && node.parent.type === 'Property'\n    && node.parent.key\n    && node.parent.key.type === 'Identifier'\n    && propMatchesRenderPropPattern(node.parent.key.name, propNamePattern)\n  );\n}\n\n/**\n * Resolve the component name of given node\n * @param {ASTNode} node The AST node of the component\n * @returns {string} Name of the component, if any\n */\nfunction resolveComponentName(node) {\n  const parentName = node.id && node.id.name;\n  if (parentName) return parentName;\n\n  return (\n    node.type === 'ArrowFunctionExpression'\n    && node.parent\n    && node.parent.id\n    && node.parent.id.name\n  );\n}\n\n// ------------------------------------------------------------------------------\n// Rule Definition\n// ------------------------------------------------------------------------------\n\n/** @type {import('eslint').Rule.RuleModule} */\nmodule.exports = {\n  meta: {\n    docs: {\n      description: 'Disallow creating unstable components inside components',\n      category: 'Possible Errors',\n      recommended: false,\n      url: docsUrl('no-unstable-nested-components'),\n    },\n    schema: [{\n      type: 'object',\n      properties: {\n        customValidators: {\n          type: 'array',\n          items: {\n            type: 'string',\n          },\n        },\n        allowAsProps: {\n          type: 'boolean',\n        },\n        propNamePattern: {\n          type: 'string',\n        },\n      },\n      additionalProperties: false,\n    }],\n  },\n\n  create: Components.detect((context, components, utils) => {\n    const allowAsProps = context.options.some((option) => option && option.allowAsProps);\n    const propNamePattern = (context.options[0] || {}).propNamePattern || 'render*';\n\n    /**\n     * Check whether given node is declared inside class component's render block\n     * ```jsx\n     * class Component extends React.Component {\n     *   render() {\n     *     class NestedClassComponent extends React.Component {\n     * ...\n     * ```\n     * @param {ASTNode} node The AST node being checked\n     * @returns {boolean} True if node is inside class component's render block, false if not\n     */\n    function isInsideRenderMethod(node) {\n      const parentComponent = utils.getParentComponent(node);\n\n      if (!parentComponent || parentComponent.type !== 'ClassDeclaration') {\n        return false;\n      }\n\n      return (\n        node\n        && node.parent\n        && node.parent.type === 'MethodDefinition'\n        && node.parent.key\n        && node.parent.key.name === 'render'\n      );\n    }\n\n    /**\n     * Check whether given node is a function component declared inside class component.\n     * Util's component detection fails to detect function components inside class components.\n     * ```jsx\n     * class Component extends React.Component {\n     *  render() {\n     *    const NestedComponent = () => <div />;\n     * ...\n     * ```\n     * @param {ASTNode} node The AST node being checked\n     * @returns {boolean} True if given node a function component declared inside class component, false if not\n     */\n    function isFunctionComponentInsideClassComponent(node) {\n      const parentComponent = utils.getParentComponent(node);\n      const parentStatelessComponent = utils.getParentStatelessComponent(node);\n\n      return (\n        parentComponent\n        && parentStatelessComponent\n        && parentComponent.type === 'ClassDeclaration'\n        && utils.getStatelessComponent(parentStatelessComponent)\n        && utils.isReturningJSX(node)\n      );\n    }\n\n    /**\n     * Check whether given node is declared inside `createElement` call's props\n     * ```js\n     * React.createElement(Component, {\n     *   footer: () => React.createElement(\"div\", null)\n     * })\n     * ```\n     * @param {ASTNode} node The AST node\n     * @returns {boolean} True if node is declare inside `createElement` call's props, false if not\n     */\n    function isComponentInsideCreateElementsProp(node) {\n      if (!components.get(node)) {\n        return false;\n      }\n\n      const createElementParent = getClosestMatchingParent(node, context, isCreateElementMatcher);\n\n      return (\n        createElementParent\n        && createElementParent.arguments\n        && createElementParent.arguments[1] === getClosestMatchingParent(node, context, isObjectExpressionMatcher)\n      );\n    }\n\n    /**\n     * Check whether given node is declared inside a component/object prop.\n     * ```jsx\n     * <Component footer={() => <div />} />\n     * { footer: () => <div /> }\n     * ```\n     * @param {ASTNode} node The AST node being checked\n     * @returns {boolean} True if node is a component declared inside prop, false if not\n     */\n    function isComponentInProp(node) {\n      if (isPropertyOfObjectExpressionMatcher(node)) {\n        return utils.isReturningJSX(node);\n      }\n\n      const jsxAttribute = getClosestMatchingParent(node, context, isJSXAttributeOfExpressionContainerMatcher);\n\n      if (!jsxAttribute) {\n        return isComponentInsideCreateElementsProp(node);\n      }\n\n      return utils.isReturningJSX(node);\n    }\n\n    /**\n     * Check whether given node is a stateless component returning non-JSX\n     * ```jsx\n     * {{ a: () => null }}\n     * ```\n     * @param {ASTNode} node The AST node being checked\n     * @returns {boolean} True if node is a stateless component returning non-JSX, false if not\n     */\n    function isStatelessComponentReturningNull(node) {\n      const component = utils.getStatelessComponent(node);\n\n      return component && !utils.isReturningJSX(component);\n    }\n\n    /**\n     * Check whether given node is a unstable nested component\n     * @param {ASTNode} node The AST node being checked\n     */\n    function validate(node) {\n      if (!node || !node.parent) {\n        return;\n      }\n\n      const isDeclaredInsideProps = isComponentInProp(node);\n\n      if (\n        !components.get(node)\n        && !isFunctionComponentInsideClassComponent(node)\n        && !isDeclaredInsideProps) {\n        return;\n      }\n\n      if (\n        // Support allowAsProps option\n        (isDeclaredInsideProps && (allowAsProps || isComponentInRenderProp(node, context, propNamePattern)))\n\n        // Prevent reporting components created inside Array.map calls\n        || isMapCall(node)\n        || isMapCall(node.parent)\n\n        // Do not mark components declared inside hooks (or falsy '() => null' clean-up methods)\n        || isReturnStatementOfHook(node, context)\n\n        // Do not mark objects containing render methods\n        || isDirectValueOfRenderProperty(node, propNamePattern)\n\n        // Prevent reporting nested class components twice\n        || isInsideRenderMethod(node)\n\n        // Prevent falsely reporting detected \"components\" which do not return JSX\n        || isStatelessComponentReturningNull(node)\n      ) {\n        return;\n      }\n\n      // Get the closest parent component\n      const parentComponent = getClosestMatchingParent(\n        node,\n        context,\n        (nodeToMatch) => components.get(nodeToMatch)\n      );\n\n      if (parentComponent) {\n        const parentName = resolveComponentName(parentComponent);\n\n        // Exclude lowercase parents, e.g. function createTestComponent()\n        // React-dom prevents creating lowercase components\n        if (parentName && parentName[0] === parentName[0].toLowerCase()) {\n          return;\n        }\n\n        let message = generateErrorMessageWithParentName(parentName);\n\n        // Add information about allowAsProps option when component is declared inside prop\n        if (isDeclaredInsideProps && !allowAsProps) {\n          message += COMPONENT_AS_PROPS_INFO;\n        }\n\n        report(context, message, null, {\n          node,\n        });\n      }\n    }\n\n    // --------------------------------------------------------------------------\n    // Public\n    // --------------------------------------------------------------------------\n\n    return {\n      FunctionDeclaration(node) { validate(node); },\n      ArrowFunctionExpression(node) { validate(node); },\n      FunctionExpression(node) { validate(node); },\n      ClassDeclaration(node) { validate(node); },\n      CallExpression(node) { validate(node); },\n    };\n  }),\n};\n"
        }
    ]
}