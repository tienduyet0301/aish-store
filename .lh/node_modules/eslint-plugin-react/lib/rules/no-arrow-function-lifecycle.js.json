{
    "sourceFile": "node_modules/eslint-plugin-react/lib/rules/no-arrow-function-lifecycle.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892273429,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Lifecycle methods should be methods on the prototype, not class fields\n * @author Tan Nguyen\n */\n\n'use strict';\n\nconst values = require('object.values');\n\nconst Components = require('../util/Components');\nconst astUtil = require('../util/ast');\nconst componentUtil = require('../util/componentUtil');\nconst docsUrl = require('../util/docsUrl');\nconst lifecycleMethods = require('../util/lifecycleMethods');\nconst report = require('../util/report');\nconst eslintUtil = require('../util/eslint');\n\nconst getSourceCode = eslintUtil.getSourceCode;\nconst getText = eslintUtil.getText;\n\nfunction getRuleText(node) {\n  const params = node.value.params.map((p) => p.name);\n\n  if (node.type === 'Property') {\n    return `: function(${params.join(', ')}) `;\n  }\n\n  if (node.type === 'ClassProperty' || node.type === 'PropertyDefinition') {\n    return `(${params.join(', ')}) `;\n  }\n\n  return null;\n}\n\nconst messages = {\n  lifecycle: '{{propertyName}} is a React lifecycle method, and should not be an arrow function or in a class field. Use an instance method instead.',\n};\n\n/** @type {import('eslint').Rule.RuleModule} */\nmodule.exports = {\n  meta: {\n    docs: {\n      description: 'Lifecycle methods should be methods on the prototype, not class fields',\n      category: 'Best Practices',\n      recommended: false,\n      url: docsUrl('no-arrow-function-lifecycle'),\n    },\n    messages,\n    schema: [],\n    fixable: 'code',\n  },\n\n  create: Components.detect((context, components) => {\n    /**\n     * @param {Array} properties list of component properties\n     */\n    function reportNoArrowFunctionLifecycle(properties) {\n      properties.forEach((node) => {\n        if (!node || !node.value) {\n          return;\n        }\n\n        const propertyName = astUtil.getPropertyName(node);\n        const nodeType = node.value.type;\n        const isLifecycleMethod = (\n          node.static && !componentUtil.isES5Component(node, context)\n            ? lifecycleMethods.static\n            : lifecycleMethods.instance\n        ).indexOf(propertyName) > -1;\n\n        if (nodeType === 'ArrowFunctionExpression' && isLifecycleMethod) {\n          const body = node.value.body;\n          const isBlockBody = body.type === 'BlockStatement';\n          const sourceCode = getSourceCode(context);\n\n          let nextComment = [];\n          let previousComment = [];\n          let bodyRange;\n          if (!isBlockBody) {\n            const previousToken = sourceCode.getTokenBefore(body);\n\n            if (sourceCode.getCommentsBefore) {\n              // eslint >=4.x\n              previousComment = sourceCode.getCommentsBefore(body);\n            } else {\n              // eslint 3.x\n              const potentialComment = sourceCode.getTokenBefore(body, { includeComments: true });\n              previousComment = previousToken === potentialComment ? [] : [potentialComment];\n            }\n\n            if (sourceCode.getCommentsAfter) {\n              // eslint >=4.x\n              nextComment = sourceCode.getCommentsAfter(body);\n            } else {\n              // eslint 3.x\n              const potentialComment = sourceCode.getTokenAfter(body, { includeComments: true });\n              const nextToken = sourceCode.getTokenAfter(body);\n              nextComment = nextToken === potentialComment ? [] : [potentialComment];\n            }\n            bodyRange = [\n              (previousComment.length > 0 ? previousComment[0] : body).range[0],\n              (nextComment.length > 0 ? nextComment[nextComment.length - 1] : body).range[1]\n                + (node.value.body.type === 'ObjectExpression' ? 1 : 0), // to account for a wrapped end paren\n            ];\n          }\n          const headRange = [\n            node.key.range[1],\n            (previousComment.length > 0 ? previousComment[0] : body).range[0],\n          ];\n          const hasSemi = node.value.expression && getText(context, node).slice(node.value.range[1] - node.range[0]) === ';';\n\n          report(\n            context,\n            messages.lifecycle,\n            'lifecycle',\n            {\n              node,\n              data: {\n                propertyName,\n              },\n              fix(fixer) {\n                if (!sourceCode.getCommentsAfter) {\n                  // eslint 3.x\n                  return isBlockBody && fixer.replaceTextRange(headRange, getRuleText(node));\n                }\n                return [].concat(\n                  fixer.replaceTextRange(headRange, getRuleText(node)),\n                  isBlockBody ? [] : fixer.replaceTextRange(\n                    [bodyRange[0], bodyRange[1] + (hasSemi ? 1 : 0)],\n                    `{ return ${previousComment.map((x) => getText(context, x)).join('')}${getText(context, body)}${nextComment.map((x) => getText(context, x)).join('')}; }`\n                  )\n                );\n              },\n            }\n          );\n        }\n      });\n    }\n\n    return {\n      'Program:exit'() {\n        values(components.list()).forEach((component) => {\n          const properties = astUtil.getComponentProperties(component.node);\n          reportNoArrowFunctionLifecycle(properties);\n        });\n      },\n    };\n  }),\n};\n"
        }
    ]
}