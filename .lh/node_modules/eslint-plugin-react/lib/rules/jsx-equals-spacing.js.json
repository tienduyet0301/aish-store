{
    "sourceFile": "node_modules/eslint-plugin-react/lib/rules/jsx-equals-spacing.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892269037,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Disallow or enforce spaces around equal signs in JSX attributes.\n * @author ryym\n */\n\n'use strict';\n\nconst docsUrl = require('../util/docsUrl');\nconst getSourceCode = require('../util/eslint').getSourceCode;\nconst report = require('../util/report');\n\n// ------------------------------------------------------------------------------\n// Rule Definition\n// ------------------------------------------------------------------------------\n\nconst messages = {\n  noSpaceBefore: 'There should be no space before \\'=\\'',\n  noSpaceAfter: 'There should be no space after \\'=\\'',\n  needSpaceBefore: 'A space is required before \\'=\\'',\n  needSpaceAfter: 'A space is required after \\'=\\'',\n};\n\n/** @type {import('eslint').Rule.RuleModule} */\nmodule.exports = {\n  meta: {\n    docs: {\n      description: 'Enforce or disallow spaces around equal signs in JSX attributes',\n      category: 'Stylistic Issues',\n      recommended: false,\n      url: docsUrl('jsx-equals-spacing'),\n    },\n    fixable: 'code',\n\n    messages,\n\n    schema: [{\n      enum: ['always', 'never'],\n    }],\n  },\n\n  create(context) {\n    const config = context.options[0] || 'never';\n\n    /**\n     * Determines a given attribute node has an equal sign.\n     * @param {ASTNode} attrNode - The attribute node.\n     * @returns {boolean} Whether or not the attriute node has an equal sign.\n     */\n    function hasEqual(attrNode) {\n      return attrNode.type !== 'JSXSpreadAttribute' && attrNode.value !== null;\n    }\n\n    // --------------------------------------------------------------------------\n    // Public\n    // --------------------------------------------------------------------------\n\n    return {\n      JSXOpeningElement(node) {\n        node.attributes.forEach((attrNode) => {\n          if (!hasEqual(attrNode)) {\n            return;\n          }\n\n          const sourceCode = getSourceCode(context);\n          const equalToken = sourceCode.getTokenAfter(attrNode.name);\n          const spacedBefore = sourceCode.isSpaceBetweenTokens(attrNode.name, equalToken);\n          const spacedAfter = sourceCode.isSpaceBetweenTokens(equalToken, attrNode.value);\n\n          if (config === 'never') {\n            if (spacedBefore) {\n              report(context, messages.noSpaceBefore, 'noSpaceBefore', {\n                node: attrNode,\n                loc: equalToken.loc.start,\n                fix(fixer) {\n                  return fixer.removeRange([attrNode.name.range[1], equalToken.range[0]]);\n                },\n              });\n            }\n            if (spacedAfter) {\n              report(context, messages.noSpaceAfter, 'noSpaceAfter', {\n                node: attrNode,\n                loc: equalToken.loc.start,\n                fix(fixer) {\n                  return fixer.removeRange([equalToken.range[1], attrNode.value.range[0]]);\n                },\n              });\n            }\n          } else if (config === 'always') {\n            if (!spacedBefore) {\n              report(context, messages.needSpaceBefore, 'needSpaceBefore', {\n                node: attrNode,\n                loc: equalToken.loc.start,\n                fix(fixer) {\n                  return fixer.insertTextBefore(equalToken, ' ');\n                },\n              });\n            }\n            if (!spacedAfter) {\n              report(context, messages.needSpaceAfter, 'needSpaceAfter', {\n                node: attrNode,\n                loc: equalToken.loc.start,\n                fix(fixer) {\n                  return fixer.insertTextAfter(equalToken, ' ');\n                },\n              });\n            }\n          }\n        });\n      },\n    };\n  },\n};\n"
        }
    ]
}