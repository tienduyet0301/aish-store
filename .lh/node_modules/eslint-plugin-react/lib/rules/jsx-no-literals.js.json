{
    "sourceFile": "node_modules/eslint-plugin-react/lib/rules/jsx-no-literals.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892271590,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Prevent using string literals in React component definition\n * @author Caleb Morris\n * @author David Buchan-Swanson\n */\n\n'use strict';\n\nconst iterFrom = require('es-iterator-helpers/Iterator.from');\nconst map = require('es-iterator-helpers/Iterator.prototype.map');\nconst some = require('es-iterator-helpers/Iterator.prototype.some');\nconst flatMap = require('es-iterator-helpers/Iterator.prototype.flatMap');\nconst fromEntries = require('object.fromentries');\nconst entries = require('object.entries');\n\nconst docsUrl = require('../util/docsUrl');\nconst report = require('../util/report');\nconst getText = require('../util/eslint').getText;\n\n/** @typedef {import('eslint').Rule.RuleModule} RuleModule */\n\n/** @typedef {import('../../types/rules/jsx-no-literals').Config} Config */\n/** @typedef {import('../../types/rules/jsx-no-literals').RawConfig} RawConfig */\n/** @typedef {import('../../types/rules/jsx-no-literals').ResolvedConfig} ResolvedConfig */\n/** @typedef {import('../../types/rules/jsx-no-literals').OverrideConfig} OverrideConfig */\n/** @typedef {import('../../types/rules/jsx-no-literals').ElementConfig} ElementConfig */\n\n// ------------------------------------------------------------------------------\n// Rule Definition\n// ------------------------------------------------------------------------------\n\n/**\n * @param {unknown} value\n * @returns {string | unknown}\n */\nfunction trimIfString(value) {\n  return typeof value === 'string' ? value.trim() : value;\n}\n\nconst reOverridableElement = /^[A-Z][\\w.]*$/;\nconst reIsWhiteSpace = /^[\\s]+$/;\nconst jsxElementTypes = new Set(['JSXElement', 'JSXFragment']);\nconst standardJSXNodeParentTypes = new Set(['JSXAttribute', 'JSXElement', 'JSXExpressionContainer', 'JSXFragment']);\n\nconst messages = {\n  invalidPropValue: 'Invalid prop value: \"{{text}}\"',\n  invalidPropValueInElement: 'Invalid prop value: \"{{text}}\" in {{element}}',\n  noStringsInAttributes: 'Strings not allowed in attributes: \"{{text}}\"',\n  noStringsInAttributesInElement: 'Strings not allowed in attributes: \"{{text}}\" in {{element}}',\n  noStringsInJSX: 'Strings not allowed in JSX files: \"{{text}}\"',\n  noStringsInJSXInElement: 'Strings not allowed in JSX files: \"{{text}}\" in {{element}}',\n  literalNotInJSXExpression: 'Missing JSX expression container around literal string: \"{{text}}\"',\n  literalNotInJSXExpressionInElement: 'Missing JSX expression container around literal string: \"{{text}}\" in {{element}}',\n};\n\n/** @type {Exclude<RuleModule['meta']['schema'], unknown[] | false>['properties']} */\nconst commonPropertiesSchema = {\n  noStrings: {\n    type: 'boolean',\n  },\n  allowedStrings: {\n    type: 'array',\n    uniqueItems: true,\n    items: {\n      type: 'string',\n    },\n  },\n  ignoreProps: {\n    type: 'boolean',\n  },\n  noAttributeStrings: {\n    type: 'boolean',\n  },\n};\n\n// eslint-disable-next-line valid-jsdoc\n/**\n * Normalizes the element portion of the config\n * @param {RawConfig} config\n * @returns {ElementConfig}\n */\nfunction normalizeElementConfig(config) {\n  return {\n    type: 'element',\n    noStrings: !!config.noStrings,\n    allowedStrings: config.allowedStrings\n      ? new Set(map(iterFrom(config.allowedStrings), trimIfString))\n      : new Set(),\n    ignoreProps: !!config.ignoreProps,\n    noAttributeStrings: !!config.noAttributeStrings,\n  };\n}\n\n// eslint-disable-next-line valid-jsdoc\n/**\n * Normalizes the config and applies default values to all config options\n * @param {RawConfig} config\n * @returns {Config}\n */\nfunction normalizeConfig(config) {\n  /** @type {Config} */\n  const normalizedConfig = Object.assign(normalizeElementConfig(config), {\n    elementOverrides: {},\n  });\n\n  if (config.elementOverrides) {\n    normalizedConfig.elementOverrides = fromEntries(\n      flatMap(\n        iterFrom(entries(config.elementOverrides)),\n        (entry) => {\n          const elementName = entry[0];\n          const rawElementConfig = entry[1];\n\n          if (!reOverridableElement.test(elementName)) {\n            return [];\n          }\n\n          return [[\n            elementName,\n            Object.assign(normalizeElementConfig(rawElementConfig), {\n              type: 'override',\n              name: elementName,\n              allowElement: !!rawElementConfig.allowElement,\n              applyToNestedElements: typeof rawElementConfig.applyToNestedElements === 'undefined' || !!rawElementConfig.applyToNestedElements,\n            }),\n          ]];\n        }\n      )\n    );\n  }\n\n  return normalizedConfig;\n}\n\nconst elementOverrides = {\n  type: 'object',\n  patternProperties: {\n    [reOverridableElement.source]: {\n      type: 'object',\n      properties: Object.assign(\n        { applyToNestedElements: { type: 'boolean' } },\n        commonPropertiesSchema\n      ),\n\n    },\n  },\n};\n\n/** @type {RuleModule} */\nmodule.exports = {\n  meta: /** @type {RuleModule['meta']} */ ({\n    docs: {\n      description: 'Disallow usage of string literals in JSX',\n      category: 'Stylistic Issues',\n      recommended: false,\n      url: docsUrl('jsx-no-literals'),\n    },\n\n    messages,\n\n    schema: [{\n      type: 'object',\n      properties: Object.assign(\n        { elementOverrides },\n        commonPropertiesSchema\n      ),\n      additionalProperties: false,\n    }],\n  }),\n\n  create(context) {\n    /** @type {RawConfig} */\n    const rawConfig = (context.options.length && context.options[0]) || {};\n    const config = normalizeConfig(rawConfig);\n\n    const hasElementOverrides = Object.keys(config.elementOverrides).length > 0;\n\n    /** @type {Map<string, string>} */\n    const renamedImportMap = new Map();\n\n    /**\n     * Determines if the given expression is a require statement. Supports\n     * nested MemberExpresions. ie `require('foo').nested.property`\n     * @param {ASTNode} node\n     * @returns {boolean}\n     */\n    function isRequireStatement(node) {\n      if (node.type === 'CallExpression') {\n        if (node.callee.type === 'Identifier') {\n          return node.callee.name === 'require';\n        }\n      }\n      if (node.type === 'MemberExpression') {\n        return isRequireStatement(node.object);\n      }\n\n      return false;\n    }\n\n    /** @typedef {{ name: string, compoundName?: string }} ElementNameFragment */\n\n    /**\n     * Gets the name of the given JSX element. Supports nested\n     * JSXMemeberExpressions. ie `<Namesapce.Component.SubComponent />`\n     * @param {ASTNode} node\n     * @returns {ElementNameFragment | undefined}\n     */\n    function getJSXElementName(node) {\n      if (node.openingElement.name.type === 'JSXIdentifier') {\n        const name = node.openingElement.name.name;\n        return {\n          name: renamedImportMap.get(name) || name,\n          compoundName: undefined,\n        };\n      }\n\n      /** @type {string[]} */\n      const nameFragments = [];\n\n      if (node.openingElement.name.type === 'JSXMemberExpression') {\n        /** @type {ASTNode} */\n        let current = node.openingElement.name;\n        while (current.type === 'JSXMemberExpression') {\n          if (current.property.type === 'JSXIdentifier') {\n            nameFragments.unshift(current.property.name);\n          }\n\n          current = current.object;\n        }\n\n        if (current.type === 'JSXIdentifier') {\n          nameFragments.unshift(current.name);\n\n          const rootFragment = nameFragments[0];\n          if (rootFragment) {\n            const rootFragmentRenamed = renamedImportMap.get(rootFragment);\n            if (rootFragmentRenamed) {\n              nameFragments[0] = rootFragmentRenamed;\n            }\n          }\n\n          const nameFragment = nameFragments[nameFragments.length - 1];\n          if (nameFragment) {\n            return {\n              name: nameFragment,\n              compoundName: nameFragments.join('.'),\n            };\n          }\n        }\n      }\n    }\n\n    /**\n     * Gets all JSXElement ancestor nodes for the given node\n     * @param {ASTNode} node\n     * @returns {ASTNode[]}\n     */\n    function getJSXElementAncestors(node) {\n      /** @type {ASTNode[]} */\n      const ancestors = [];\n\n      let current = node;\n      while (current) {\n        if (current.type === 'JSXElement') {\n          ancestors.push(current);\n        }\n\n        current = current.parent;\n      }\n\n      return ancestors;\n    }\n\n    /**\n     * @param {ASTNode} node\n     * @returns {ASTNode}\n     */\n    function getParentIgnoringBinaryExpressions(node) {\n      let current = node;\n      while (current.parent.type === 'BinaryExpression') {\n        current = current.parent;\n      }\n      return current.parent;\n    }\n\n    /**\n     * @param {ASTNode} node\n     * @returns {{ parent: ASTNode, grandParent: ASTNode }}\n     */\n    function getParentAndGrandParent(node) {\n      const parent = getParentIgnoringBinaryExpressions(node);\n      return {\n        parent,\n        grandParent: parent.parent,\n      };\n    }\n\n    /**\n     * @param {ASTNode} node\n     * @returns {boolean}\n     */\n    function hasJSXElementParentOrGrandParent(node) {\n      const ancestors = getParentAndGrandParent(node);\n      return some(iterFrom([ancestors.parent, ancestors.grandParent]), (parent) => jsxElementTypes.has(parent.type));\n    }\n\n    // eslint-disable-next-line valid-jsdoc\n    /**\n     * Determines whether a given node's value and its immediate parent are\n     * viable text nodes that can/should be reported on\n     * @param {ASTNode} node\n     * @param {ResolvedConfig} resolvedConfig\n     * @returns {boolean}\n     */\n    function isViableTextNode(node, resolvedConfig) {\n      const textValues = iterFrom([trimIfString(node.raw), trimIfString(node.value)]);\n      if (some(textValues, (value) => resolvedConfig.allowedStrings.has(value))) {\n        return false;\n      }\n\n      const parent = getParentIgnoringBinaryExpressions(node);\n\n      let isStandardJSXNode = false;\n      if (typeof node.value === 'string' && !reIsWhiteSpace.test(node.value) && standardJSXNodeParentTypes.has(parent.type)) {\n        if (resolvedConfig.noAttributeStrings) {\n          isStandardJSXNode = parent.type === 'JSXAttribute' || parent.type === 'JSXElement';\n        } else {\n          isStandardJSXNode = parent.type !== 'JSXAttribute';\n        }\n      }\n\n      if (resolvedConfig.noStrings) {\n        return isStandardJSXNode;\n      }\n\n      return isStandardJSXNode && parent.type !== 'JSXExpressionContainer';\n    }\n\n    // eslint-disable-next-line valid-jsdoc\n    /**\n     * Gets an override config for a given node. For any given node, we also\n     * need to traverse the ancestor tree to determine if an ancestor's config\n     * will also apply to the current node.\n     * @param {ASTNode} node\n     * @returns {OverrideConfig | undefined}\n     */\n    function getOverrideConfig(node) {\n      if (!hasElementOverrides) {\n        return;\n      }\n\n      const allAncestorElements = getJSXElementAncestors(node);\n      if (!allAncestorElements.length) {\n        return;\n      }\n\n      for (const ancestorElement of allAncestorElements) {\n        const isClosestJSXAncestor = ancestorElement === allAncestorElements[0];\n\n        const ancestor = getJSXElementName(ancestorElement);\n        if (ancestor) {\n          if (ancestor.name) {\n            const ancestorElements = config.elementOverrides[ancestor.name];\n            const ancestorConfig = ancestor.compoundName\n              ? config.elementOverrides[ancestor.compoundName] || ancestorElements\n              : ancestorElements;\n\n            if (ancestorConfig) {\n              if (isClosestJSXAncestor || ancestorConfig.applyToNestedElements) {\n                return ancestorConfig;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    // eslint-disable-next-line valid-jsdoc\n    /**\n     * @param {ResolvedConfig} resolvedConfig\n     * @returns {boolean}\n     */\n    function shouldAllowElement(resolvedConfig) {\n      return resolvedConfig.type === 'override' && 'allowElement' in resolvedConfig && !!resolvedConfig.allowElement;\n    }\n\n    // eslint-disable-next-line valid-jsdoc\n    /**\n     * @param {boolean} ancestorIsJSXElement\n     * @param {ResolvedConfig} resolvedConfig\n     * @returns {string}\n     */\n    function defaultMessageId(ancestorIsJSXElement, resolvedConfig) {\n      if (resolvedConfig.noAttributeStrings && !ancestorIsJSXElement) {\n        return resolvedConfig.type === 'override' ? 'noStringsInAttributesInElement' : 'noStringsInAttributes';\n      }\n\n      if (resolvedConfig.noStrings) {\n        return resolvedConfig.type === 'override' ? 'noStringsInJSXInElement' : 'noStringsInJSX';\n      }\n\n      return resolvedConfig.type === 'override' ? 'literalNotInJSXExpressionInElement' : 'literalNotInJSXExpression';\n    }\n\n    // eslint-disable-next-line valid-jsdoc\n    /**\n     * @param {ASTNode} node\n     * @param {string} messageId\n     * @param {ResolvedConfig} resolvedConfig\n     */\n    function reportLiteralNode(node, messageId, resolvedConfig) {\n      report(context, messages[messageId], messageId, {\n        node,\n        data: {\n          text: getText(context, node).trim(),\n          element: resolvedConfig.type === 'override' && 'name' in resolvedConfig ? resolvedConfig.name : undefined,\n        },\n      });\n    }\n\n    // --------------------------------------------------------------------------\n    // Public\n    // --------------------------------------------------------------------------\n\n    return Object.assign(hasElementOverrides ? {\n      // Get renamed import local names mapped to their imported name\n      ImportDeclaration(node) {\n        node.specifiers\n          .filter((s) => s.type === 'ImportSpecifier')\n          .forEach((specifier) => {\n            renamedImportMap.set(\n              (specifier.local || specifier.imported).name,\n              specifier.imported.name\n            );\n          });\n      },\n\n      // Get renamed destructured local names mapped to their imported name\n      VariableDeclaration(node) {\n        node.declarations\n          .filter((d) => (\n            d.type === 'VariableDeclarator'\n            && isRequireStatement(d.init)\n            && d.id.type === 'ObjectPattern'\n          ))\n          .forEach((declaration) => {\n            declaration.id.properties\n              .filter((property) => (\n                property.type === 'Property'\n                && property.key.type === 'Identifier'\n                && property.value.type === 'Identifier'\n              ))\n              .forEach((property) => {\n                renamedImportMap.set(property.value.name, property.key.name);\n              });\n          });\n      },\n    } : false, {\n      Literal(node) {\n        const resolvedConfig = getOverrideConfig(node) || config;\n\n        const hasJSXParentOrGrandParent = hasJSXElementParentOrGrandParent(node);\n        if (hasJSXParentOrGrandParent && shouldAllowElement(resolvedConfig)) {\n          return;\n        }\n\n        if (isViableTextNode(node, resolvedConfig)) {\n          if (hasJSXParentOrGrandParent || !config.ignoreProps) {\n            reportLiteralNode(node, defaultMessageId(hasJSXParentOrGrandParent, resolvedConfig), resolvedConfig);\n          }\n        }\n      },\n\n      JSXAttribute(node) {\n        const isLiteralString = node.value && node.value.type === 'Literal'\n          && typeof node.value.value === 'string';\n        const isStringLiteral = node.value && node.value.type === 'StringLiteral';\n\n        if (isLiteralString || isStringLiteral) {\n          const resolvedConfig = getOverrideConfig(node) || config;\n\n          if (\n            resolvedConfig.noStrings\n            && !resolvedConfig.ignoreProps\n            && !resolvedConfig.allowedStrings.has(node.value.value)\n          ) {\n            const messageId = resolvedConfig.type === 'override' ? 'invalidPropValueInElement' : 'invalidPropValue';\n            reportLiteralNode(node, messageId, resolvedConfig);\n          }\n        }\n      },\n\n      JSXText(node) {\n        const resolvedConfig = getOverrideConfig(node) || config;\n\n        if (shouldAllowElement(resolvedConfig)) {\n          return;\n        }\n\n        if (isViableTextNode(node, resolvedConfig)) {\n          const hasJSXParendOrGrantParent = hasJSXElementParentOrGrandParent(node);\n          reportLiteralNode(node, defaultMessageId(hasJSXParendOrGrantParent, resolvedConfig), resolvedConfig);\n        }\n      },\n\n      TemplateLiteral(node) {\n        const ancestors = getParentAndGrandParent(node);\n        const isParentJSXExpressionCont = ancestors.parent.type === 'JSXExpressionContainer';\n        const isParentJSXElement = ancestors.grandParent.type === 'JSXElement';\n\n        if (isParentJSXExpressionCont) {\n          const resolvedConfig = getOverrideConfig(node) || config;\n\n          if (\n            resolvedConfig.noStrings\n            && (isParentJSXElement || !resolvedConfig.ignoreProps)\n          ) {\n            reportLiteralNode(node, defaultMessageId(isParentJSXElement, resolvedConfig), resolvedConfig);\n          }\n        }\n      },\n    });\n  },\n};\n"
        }
    ]
}