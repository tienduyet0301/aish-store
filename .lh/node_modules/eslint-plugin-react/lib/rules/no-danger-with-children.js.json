{
    "sourceFile": "node_modules/eslint-plugin-react/lib/rules/no-danger-with-children.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892273648,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Report when a DOM element is using both children and dangerouslySetInnerHTML\n * @author David Petersen\n */\n\n'use strict';\n\nconst variableUtil = require('../util/variable');\nconst jsxUtil = require('../util/jsx');\nconst docsUrl = require('../util/docsUrl');\nconst report = require('../util/report');\n\n// ------------------------------------------------------------------------------\n// Rule Definition\n// ------------------------------------------------------------------------------\nconst messages = {\n  dangerWithChildren: 'Only set one of `children` or `props.dangerouslySetInnerHTML`',\n};\n\n/** @type {import('eslint').Rule.RuleModule} */\nmodule.exports = {\n  meta: {\n    docs: {\n      description: 'Disallow when a DOM element is using both children and dangerouslySetInnerHTML',\n      category: 'Possible Errors',\n      recommended: true,\n      url: docsUrl('no-danger-with-children'),\n    },\n\n    messages,\n\n    schema: [], // no options\n  },\n  create(context) {\n    function findSpreadVariable(node, name) {\n      return variableUtil.getVariableFromContext(context, node, name);\n    }\n    /**\n     * Takes a ObjectExpression and returns the value of the prop if it has it\n     * @param {object} node - ObjectExpression node\n     * @param {string} propName - name of the prop to look for\n     * @param {string[]} seenProps\n     * @returns {object | boolean}\n     */\n    function findObjectProp(node, propName, seenProps) {\n      if (!node.properties) {\n        return false;\n      }\n      return node.properties.find((prop) => {\n        if (prop.type === 'Property') {\n          return prop.key.name === propName;\n        }\n        if (prop.type === 'ExperimentalSpreadProperty' || prop.type === 'SpreadElement') {\n          const variable = findSpreadVariable(node, prop.argument.name);\n          if (variable && variable.defs.length && variable.defs[0].node.init) {\n            if (seenProps.indexOf(prop.argument.name) > -1) {\n              return false;\n            }\n            const newSeenProps = seenProps.concat(prop.argument.name || []);\n            return findObjectProp(variable.defs[0].node.init, propName, newSeenProps);\n          }\n        }\n        return false;\n      });\n    }\n\n    /**\n     * Takes a JSXElement and returns the value of the prop if it has it\n     * @param {object} node - JSXElement node\n     * @param {string} propName - name of the prop to look for\n     * @returns {object | boolean}\n     */\n    function findJsxProp(node, propName) {\n      const attributes = node.openingElement.attributes;\n      return attributes.find((attribute) => {\n        if (attribute.type === 'JSXSpreadAttribute') {\n          const variable = findSpreadVariable(node, attribute.argument.name);\n          if (variable && variable.defs.length && variable.defs[0].node.init) {\n            return findObjectProp(variable.defs[0].node.init, propName, []);\n          }\n        }\n        return attribute.name && attribute.name.name === propName;\n      });\n    }\n\n    /**\n     * Checks to see if a node is a line break\n     * @param {ASTNode} node The AST node being checked\n     * @returns {boolean} True if node is a line break, false if not\n     */\n    function isLineBreak(node) {\n      const isLiteral = node.type === 'Literal' || node.type === 'JSXText';\n      const isMultiline = node.loc.start.line !== node.loc.end.line;\n      const isWhiteSpaces = jsxUtil.isWhiteSpaces(node.value);\n\n      return isLiteral && isMultiline && isWhiteSpaces;\n    }\n\n    return {\n      JSXElement(node) {\n        let hasChildren = false;\n\n        if (node.children.length && !isLineBreak(node.children[0])) {\n          hasChildren = true;\n        } else if (findJsxProp(node, 'children')) {\n          hasChildren = true;\n        }\n\n        if (\n          node.openingElement.attributes\n          && hasChildren\n          && findJsxProp(node, 'dangerouslySetInnerHTML')\n        ) {\n          report(context, messages.dangerWithChildren, 'dangerWithChildren', {\n            node,\n          });\n        }\n      },\n      CallExpression(node) {\n        if (\n          node.callee\n          && node.callee.type === 'MemberExpression'\n          && 'name' in node.callee.property\n          && node.callee.property.name === 'createElement'\n          && node.arguments.length > 1\n        ) {\n          let hasChildren = false;\n\n          let props = node.arguments[1];\n\n          if (props.type === 'Identifier') {\n            const variable = variableUtil.getVariableFromContext(context, node, props.name);\n            if (variable && variable.defs.length && variable.defs[0].node.init) {\n              props = variable.defs[0].node.init;\n            }\n          }\n\n          const dangerously = findObjectProp(props, 'dangerouslySetInnerHTML', []);\n\n          if (node.arguments.length === 2) {\n            if (findObjectProp(props, 'children', [])) {\n              hasChildren = true;\n            }\n          } else {\n            hasChildren = true;\n          }\n\n          if (dangerously && hasChildren) {\n            report(context, messages.dangerWithChildren, 'dangerWithChildren', {\n              node,\n            });\n          }\n        }\n      },\n    };\n  },\n};\n"
        }
    ]
}