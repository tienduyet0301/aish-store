{
    "sourceFile": "node_modules/eslint-plugin-react/lib/rules/display-name.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892266278,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Prevent missing displayName in a React component definition\n * @author Yannick Croissant\n */\n\n'use strict';\n\nconst values = require('object.values');\nconst filter = require('es-iterator-helpers/Iterator.prototype.filter');\nconst forEach = require('es-iterator-helpers/Iterator.prototype.forEach');\n\nconst Components = require('../util/Components');\nconst isCreateContext = require('../util/isCreateContext');\nconst astUtil = require('../util/ast');\nconst componentUtil = require('../util/componentUtil');\nconst docsUrl = require('../util/docsUrl');\nconst testReactVersion = require('../util/version').testReactVersion;\nconst propsUtil = require('../util/props');\nconst report = require('../util/report');\n\n// ------------------------------------------------------------------------------\n// Rule Definition\n// ------------------------------------------------------------------------------\n\nconst messages = {\n  noDisplayName: 'Component definition is missing display name',\n  noContextDisplayName: 'Context definition is missing display name',\n};\n\n/** @type {import('eslint').Rule.RuleModule} */\nmodule.exports = {\n  meta: {\n    docs: {\n      description: 'Disallow missing displayName in a React component definition',\n      category: 'Best Practices',\n      recommended: true,\n      url: docsUrl('display-name'),\n    },\n\n    messages,\n\n    schema: [{\n      type: 'object',\n      properties: {\n        ignoreTranspilerName: {\n          type: 'boolean',\n        },\n        checkContextObjects: {\n          type: 'boolean',\n        },\n      },\n      additionalProperties: false,\n    }],\n  },\n\n  create: Components.detect((context, components, utils) => {\n    const config = context.options[0] || {};\n    const ignoreTranspilerName = config.ignoreTranspilerName || false;\n    const checkContextObjects = (config.checkContextObjects || false) && testReactVersion(context, '>= 16.3.0');\n\n    const contextObjects = new Map();\n\n    /**\n     * Mark a prop type as declared\n     * @param {ASTNode} node The AST node being checked.\n     */\n    function markDisplayNameAsDeclared(node) {\n      components.set(node, {\n        hasDisplayName: true,\n      });\n    }\n\n    /**\n     * Checks if React.forwardRef is nested inside React.memo\n     * @param {ASTNode} node The AST node being checked.\n     * @returns {boolean} True if React.forwardRef is nested inside React.memo, false if not.\n     */\n    function isNestedMemo(node) {\n      return astUtil.isCallExpression(node)\n        && node.arguments\n        && astUtil.isCallExpression(node.arguments[0])\n        && utils.isPragmaComponentWrapper(node);\n    }\n\n    /**\n     * Reports missing display name for a given component\n     * @param {Object} component The component to process\n     */\n    function reportMissingDisplayName(component) {\n      if (\n        testReactVersion(context, '^0.14.10 || ^15.7.0 || >= 16.12.0')\n        && isNestedMemo(component.node)\n      ) {\n        return;\n      }\n\n      report(context, messages.noDisplayName, 'noDisplayName', {\n        node: component.node,\n      });\n    }\n\n    /**\n     * Reports missing display name for a given context object\n     * @param {Object} contextObj The context object to process\n     */\n    function reportMissingContextDisplayName(contextObj) {\n      report(context, messages.noContextDisplayName, 'noContextDisplayName', {\n        node: contextObj.node,\n      });\n    }\n\n    /**\n     * Checks if the component have a name set by the transpiler\n     * @param {ASTNode} node The AST node being checked.\n     * @returns {boolean} True if component has a name, false if not.\n     */\n    function hasTranspilerName(node) {\n      const namedObjectAssignment = (\n        node.type === 'ObjectExpression'\n        && node.parent\n        && node.parent.parent\n        && node.parent.parent.type === 'AssignmentExpression'\n        && (\n          !node.parent.parent.left.object\n          || node.parent.parent.left.object.name !== 'module'\n          || node.parent.parent.left.property.name !== 'exports'\n        )\n      );\n      const namedObjectDeclaration = (\n        node.type === 'ObjectExpression'\n        && node.parent\n        && node.parent.parent\n        && node.parent.parent.type === 'VariableDeclarator'\n      );\n      const namedClass = (\n        (node.type === 'ClassDeclaration' || node.type === 'ClassExpression')\n        && node.id\n        && !!node.id.name\n      );\n\n      const namedFunctionDeclaration = (\n        (node.type === 'FunctionDeclaration' || node.type === 'FunctionExpression')\n        && node.id\n        && !!node.id.name\n      );\n\n      const namedFunctionExpression = (\n        astUtil.isFunctionLikeExpression(node)\n        && node.parent\n        && (node.parent.type === 'VariableDeclarator' || node.parent.type === 'Property' || node.parent.method === true)\n        && (!node.parent.parent || !componentUtil.isES5Component(node.parent.parent, context))\n      );\n\n      if (\n        namedObjectAssignment || namedObjectDeclaration\n        || namedClass\n        || namedFunctionDeclaration || namedFunctionExpression\n      ) {\n        return true;\n      }\n      return false;\n    }\n\n    // --------------------------------------------------------------------------\n    // Public\n    // --------------------------------------------------------------------------\n\n    return {\n      ExpressionStatement(node) {\n        if (checkContextObjects && isCreateContext(node)) {\n          contextObjects.set(node.expression.left.name, { node, hasDisplayName: false });\n        }\n      },\n      VariableDeclarator(node) {\n        if (checkContextObjects && isCreateContext(node)) {\n          contextObjects.set(node.id.name, { node, hasDisplayName: false });\n        }\n      },\n      'ClassProperty, PropertyDefinition'(node) {\n        if (!propsUtil.isDisplayNameDeclaration(node)) {\n          return;\n        }\n        markDisplayNameAsDeclared(node);\n      },\n\n      MemberExpression(node) {\n        if (!propsUtil.isDisplayNameDeclaration(node.property)) {\n          return;\n        }\n        if (\n          checkContextObjects\n          && node.object\n          && node.object.name\n          && contextObjects.has(node.object.name)\n        ) {\n          contextObjects.get(node.object.name).hasDisplayName = true;\n        }\n        const component = utils.getRelatedComponent(node);\n        if (!component) {\n          return;\n        }\n        markDisplayNameAsDeclared(astUtil.unwrapTSAsExpression(component.node));\n      },\n\n      'FunctionExpression, FunctionDeclaration, ArrowFunctionExpression'(node) {\n        if (ignoreTranspilerName || !hasTranspilerName(node)) {\n          return;\n        }\n        if (components.get(node)) {\n          markDisplayNameAsDeclared(node);\n        }\n      },\n\n      MethodDefinition(node) {\n        if (!propsUtil.isDisplayNameDeclaration(node.key)) {\n          return;\n        }\n        markDisplayNameAsDeclared(node);\n      },\n\n      'ClassExpression, ClassDeclaration'(node) {\n        if (ignoreTranspilerName || !hasTranspilerName(node)) {\n          return;\n        }\n        markDisplayNameAsDeclared(node);\n      },\n\n      ObjectExpression(node) {\n        if (!componentUtil.isES5Component(node, context)) {\n          return;\n        }\n        if (ignoreTranspilerName || !hasTranspilerName(node)) {\n          // Search for the displayName declaration\n          node.properties.forEach((property) => {\n            if (!property.key || !propsUtil.isDisplayNameDeclaration(property.key)) {\n              return;\n            }\n            markDisplayNameAsDeclared(node);\n          });\n          return;\n        }\n        markDisplayNameAsDeclared(node);\n      },\n\n      CallExpression(node) {\n        if (!utils.isPragmaComponentWrapper(node)) {\n          return;\n        }\n\n        if (node.arguments.length > 0 && astUtil.isFunctionLikeExpression(node.arguments[0])) {\n          // Skip over React.forwardRef declarations that are embedded within\n          // a React.memo i.e. React.memo(React.forwardRef(/* ... */))\n          // This means that we raise a single error for the call to React.memo\n          // instead of one for React.memo and one for React.forwardRef\n          const isWrappedInAnotherPragma = utils.getPragmaComponentWrapper(node);\n          if (\n            !isWrappedInAnotherPragma\n            && (ignoreTranspilerName || !hasTranspilerName(node.arguments[0]))\n          ) {\n            return;\n          }\n\n          if (components.get(node)) {\n            markDisplayNameAsDeclared(node);\n          }\n        }\n      },\n\n      'Program:exit'() {\n        const list = components.list();\n        // Report missing display name for all components\n        values(list).filter((component) => !component.hasDisplayName).forEach((component) => {\n          reportMissingDisplayName(component);\n        });\n        if (checkContextObjects) {\n          // Report missing display name for all context objects\n          forEach(\n            filter(contextObjects.values(), (v) => !v.hasDisplayName),\n            (contextObj) => reportMissingContextDisplayName(contextObj)\n          );\n        }\n      },\n    };\n  }),\n};\n"
        }
    ]
}