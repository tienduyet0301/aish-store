{
    "sourceFile": "node_modules/eslint-plugin-react/lib/rules/button-has-type.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892265801,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Forbid \"button\" element without an explicit \"type\" attribute\n * @author Filipp Riabchun\n */\n\n'use strict';\n\nconst getProp = require('jsx-ast-utils/getProp');\nconst getLiteralPropValue = require('jsx-ast-utils/getLiteralPropValue');\nconst docsUrl = require('../util/docsUrl');\nconst isCreateElement = require('../util/isCreateElement');\nconst report = require('../util/report');\n\n// ------------------------------------------------------------------------------\n// Rule Definition\n// ------------------------------------------------------------------------------\n\nconst optionDefaults = {\n  button: true,\n  submit: true,\n  reset: true,\n};\n\nconst messages = {\n  missingType: 'Missing an explicit type attribute for button',\n  complexType: 'The button type attribute must be specified by a static string or a trivial ternary expression',\n  invalidValue: '\"{{value}}\" is an invalid value for button type attribute',\n  forbiddenValue: '\"{{value}}\" is an invalid value for button type attribute',\n};\n\n/** @type {import('eslint').Rule.RuleModule} */\nmodule.exports = {\n  meta: {\n    docs: {\n      description: 'Disallow usage of `button` elements without an explicit `type` attribute',\n      category: 'Possible Errors',\n      recommended: false,\n      url: docsUrl('button-has-type'),\n    },\n\n    messages,\n\n    schema: [{\n      type: 'object',\n      properties: {\n        button: {\n          default: optionDefaults.button,\n          type: 'boolean',\n        },\n        submit: {\n          default: optionDefaults.submit,\n          type: 'boolean',\n        },\n        reset: {\n          default: optionDefaults.reset,\n          type: 'boolean',\n        },\n      },\n      additionalProperties: false,\n    }],\n  },\n\n  create(context) {\n    const configuration = Object.assign({}, optionDefaults, context.options[0]);\n\n    function reportMissing(node) {\n      report(context, messages.missingType, 'missingType', {\n        node,\n      });\n    }\n\n    function reportComplex(node) {\n      report(context, messages.complexType, 'complexType', {\n        node,\n      });\n    }\n\n    function checkValue(node, value) {\n      if (!(value in configuration)) {\n        report(context, messages.invalidValue, 'invalidValue', {\n          node,\n          data: {\n            value,\n          },\n        });\n      } else if (!configuration[value]) {\n        report(context, messages.forbiddenValue, 'forbiddenValue', {\n          node,\n          data: {\n            value,\n          },\n        });\n      }\n    }\n\n    function checkExpression(node, expression) {\n      switch (expression.type) {\n        case 'Literal':\n          checkValue(node, expression.value);\n          return;\n        case 'TemplateLiteral':\n          if (expression.expressions.length === 0) {\n            checkValue(node, expression.quasis[0].value.raw);\n          } else {\n            reportComplex(expression);\n          }\n          return;\n        case 'ConditionalExpression':\n          checkExpression(node, expression.consequent);\n          checkExpression(node, expression.alternate);\n          return;\n        default:\n          reportComplex(expression);\n      }\n    }\n\n    return {\n      JSXElement(node) {\n        if (node.openingElement.name.name !== 'button') {\n          return;\n        }\n\n        const typeProp = getProp(node.openingElement.attributes, 'type');\n\n        if (!typeProp) {\n          reportMissing(node);\n          return;\n        }\n\n        if (typeProp.value && typeProp.value.type === 'JSXExpressionContainer') {\n          checkExpression(node, typeProp.value.expression);\n          return;\n        }\n\n        const propValue = getLiteralPropValue(typeProp);\n        checkValue(node, propValue);\n      },\n      CallExpression(node) {\n        if (!isCreateElement(context, node) || node.arguments.length < 1) {\n          return;\n        }\n\n        if (node.arguments[0].type !== 'Literal' || node.arguments[0].value !== 'button') {\n          return;\n        }\n\n        if (!node.arguments[1] || node.arguments[1].type !== 'ObjectExpression') {\n          reportMissing(node);\n          return;\n        }\n\n        const props = node.arguments[1].properties;\n        const typeProp = props.find((prop) => (\n          'key' in prop\n          && prop.key\n          && 'name' in prop.key\n          && prop.key.name === 'type'\n        ));\n\n        if (!typeProp) {\n          reportMissing(node);\n          return;\n        }\n\n        checkExpression(node, 'value' in typeProp ? typeProp.value : undefined);\n      },\n    };\n  },\n};\n"
        }
    ]
}