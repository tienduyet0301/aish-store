{
    "sourceFile": "node_modules/eslint-plugin-react/lib/rules/prop-types.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892276134,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Prevent missing props validation in a React component definition\n * @author Yannick Croissant\n */\n\n'use strict';\n\n// As for exceptions for props.children or props.className (and alike) look at\n// https://github.com/jsx-eslint/eslint-plugin-react/issues/7\n\nconst values = require('object.values');\n\nconst Components = require('../util/Components');\nconst docsUrl = require('../util/docsUrl');\nconst report = require('../util/report');\n\n// ------------------------------------------------------------------------------\n// Rule Definition\n// ------------------------------------------------------------------------------\n\nconst messages = {\n  missingPropType: '\\'{{name}}\\' is missing in props validation',\n};\n\n/** @type {import('eslint').Rule.RuleModule} */\nmodule.exports = {\n  meta: {\n    docs: {\n      description: 'Disallow missing props validation in a React component definition',\n      category: 'Best Practices',\n      recommended: true,\n      url: docsUrl('prop-types'),\n    },\n\n    messages,\n\n    schema: [{\n      type: 'object',\n      properties: {\n        ignore: {\n          type: 'array',\n          items: {\n            type: 'string',\n          },\n        },\n        customValidators: {\n          type: 'array',\n          items: {\n            type: 'string',\n          },\n        },\n        skipUndeclared: {\n          type: 'boolean',\n        },\n      },\n      additionalProperties: false,\n    }],\n  },\n\n  create: Components.detect((context, components) => {\n    const configuration = context.options[0] || {};\n    const ignored = configuration.ignore || [];\n    const skipUndeclared = configuration.skipUndeclared || false;\n\n    /**\n     * Checks if the prop is ignored\n     * @param {string} name Name of the prop to check.\n     * @returns {boolean} True if the prop is ignored, false if not.\n     */\n    function isIgnored(name) {\n      return ignored.indexOf(name) !== -1;\n    }\n\n    /**\n     * Checks if the component must be validated\n     * @param {Object} component The component to process\n     * @returns {boolean} True if the component must be validated, false if not.\n     */\n    function mustBeValidated(component) {\n      const isSkippedByConfig = skipUndeclared && typeof component.declaredPropTypes === 'undefined';\n      return !!(\n        component\n        && component.usedPropTypes\n        && !component.ignorePropsValidation\n        && !isSkippedByConfig\n      );\n    }\n\n    /**\n     * Internal: Checks if the prop is declared\n     * @param {Object} declaredPropTypes Description of propTypes declared in the current component\n     * @param {string[]} keyList Dot separated name of the prop to check.\n     * @returns {boolean} True if the prop is declared, false if not.\n     */\n    function internalIsDeclaredInComponent(declaredPropTypes, keyList) {\n      for (let i = 0, j = keyList.length; i < j; i++) {\n        const key = keyList[i];\n        const propType = (\n          declaredPropTypes && (\n            // Check if this key is declared\n            (declaredPropTypes[key] // If not, check if this type accepts any key\n            || declaredPropTypes.__ANY_KEY__) // eslint-disable-line no-underscore-dangle\n          )\n        );\n\n        if (!propType) {\n          // If it's a computed property, we can't make any further analysis, but is valid\n          return key === '__COMPUTED_PROP__';\n        }\n        if (typeof propType === 'object' && !propType.type) {\n          return true;\n        }\n        // Consider every children as declared\n        if (propType.children === true || propType.containsUnresolvedSpread || propType.containsIndexers) {\n          return true;\n        }\n        if (propType.acceptedProperties) {\n          return key in propType.acceptedProperties;\n        }\n        if (propType.type === 'union') {\n          // If we fall in this case, we know there is at least one complex type in the union\n          if (i + 1 >= j) {\n            // this is the last key, accept everything\n            return true;\n          }\n          // non trivial, check all of them\n          const unionTypes = propType.children;\n          const unionPropType = {};\n          for (let k = 0, z = unionTypes.length; k < z; k++) {\n            unionPropType[key] = unionTypes[k];\n            const isValid = internalIsDeclaredInComponent(\n              unionPropType,\n              keyList.slice(i)\n            );\n            if (isValid) {\n              return true;\n            }\n          }\n\n          // every possible union were invalid\n          return false;\n        }\n        declaredPropTypes = propType.children;\n      }\n      return true;\n    }\n\n    /**\n     * Checks if the prop is declared\n     * @param {ASTNode} node The AST node being checked.\n     * @param {string[]} names List of names of the prop to check.\n     * @returns {boolean} True if the prop is declared, false if not.\n     */\n    function isDeclaredInComponent(node, names) {\n      while (node) {\n        const component = components.get(node);\n\n        const isDeclared = component && component.confidence >= 2\n          && internalIsDeclaredInComponent(component.declaredPropTypes || {}, names);\n\n        if (isDeclared) {\n          return true;\n        }\n\n        node = node.parent;\n      }\n      return false;\n    }\n\n    /**\n     * Reports undeclared proptypes for a given component\n     * @param {Object} component The component to process\n     */\n    function reportUndeclaredPropTypes(component) {\n      const undeclareds = component.usedPropTypes.filter((propType) => (\n        propType.node\n        && !isIgnored(propType.allNames[0])\n        && !isDeclaredInComponent(component.node, propType.allNames)\n      ));\n      undeclareds.forEach((propType) => {\n        report(context, messages.missingPropType, 'missingPropType', {\n          node: propType.node,\n          data: {\n            name: propType.allNames.join('.').replace(/\\.__COMPUTED_PROP__/g, '[]'),\n          },\n        });\n      });\n    }\n\n    /**\n     * @param {Object} component The current component to process\n     * @param {Array} list The all components to process\n     * @returns {boolean} True if the component is nested False if not.\n     */\n    function checkNestedComponent(component, list) {\n      const componentIsMemo = component.node.callee && component.node.callee.name === 'memo';\n      const argumentIsForwardRef = component.node.arguments && component.node.arguments[0].callee && component.node.arguments[0].callee.name === 'forwardRef';\n      if (componentIsMemo && argumentIsForwardRef) {\n        const forwardComponent = list.find(\n          (innerComponent) => (\n            innerComponent.node.range[0] === component.node.arguments[0].range[0]\n            && innerComponent.node.range[0] === component.node.arguments[0].range[0]\n          ));\n\n        const isValidated = mustBeValidated(forwardComponent);\n        const isIgnorePropsValidation = forwardComponent.ignorePropsValidation;\n\n        return isIgnorePropsValidation || isValidated;\n      }\n    }\n\n    return {\n      'Program:exit'() {\n        const list = components.list();\n        // Report undeclared proptypes for all classes\n        values(list)\n          .filter((component) => mustBeValidated(component))\n          .forEach((component) => {\n            if (checkNestedComponent(component, values(list))) return;\n            reportUndeclaredPropTypes(component);\n          });\n      },\n    };\n  }),\n};\n"
        }
    ]
}