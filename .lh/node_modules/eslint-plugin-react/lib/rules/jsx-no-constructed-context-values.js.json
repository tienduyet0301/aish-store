{
    "sourceFile": "node_modules/eslint-plugin-react/lib/rules/jsx-no-constructed-context-values.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892271292,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Prevents jsx context provider values from taking values that\n *               will cause needless rerenders.\n * @author Dylan Oshima\n */\n\n'use strict';\n\nconst Components = require('../util/Components');\nconst docsUrl = require('../util/docsUrl');\nconst getScope = require('../util/eslint').getScope;\nconst report = require('../util/report');\n\n// ------------------------------------------------------------------------------\n// Helpers\n// ------------------------------------------------------------------------------\n\n// Recursively checks if an element is a construction.\n// A construction is a variable that changes identity every render.\nfunction isConstruction(node, callScope) {\n  switch (node.type) {\n    case 'Literal':\n      if (node.regex != null) {\n        return { type: 'regular expression', node };\n      }\n      return null;\n    case 'Identifier': {\n      const variableScoping = callScope.set.get(node.name);\n\n      if (variableScoping == null || variableScoping.defs == null) {\n        // If it's not in scope, we don't care.\n        return null; // Handled\n      }\n\n      // Gets the last variable identity\n      const variableDefs = variableScoping.defs;\n      const def = variableDefs[variableDefs.length - 1];\n      if (def != null\n        && def.type !== 'Variable'\n        && def.type !== 'FunctionName'\n      ) {\n        // Parameter or an unusual pattern. Bail out.\n        return null; // Unhandled\n      }\n\n      if (def.node.type === 'FunctionDeclaration') {\n        return { type: 'function declaration', node: def.node, usage: node };\n      }\n\n      const init = def.node.init;\n      if (init == null) {\n        return null;\n      }\n\n      const initConstruction = isConstruction(init, callScope);\n      if (initConstruction == null) {\n        return null;\n      }\n\n      return {\n        type: initConstruction.type,\n        node: initConstruction.node,\n        usage: node,\n      };\n    }\n    case 'ObjectExpression':\n      // Any object initialized inline will create a new identity\n      return { type: 'object', node };\n    case 'ArrayExpression':\n      return { type: 'array', node };\n    case 'ArrowFunctionExpression':\n    case 'FunctionExpression':\n      // Functions that are initialized inline will have a new identity\n      return { type: 'function expression', node };\n    case 'ClassExpression':\n      return { type: 'class expression', node };\n    case 'NewExpression':\n      // `const a = new SomeClass();` is a construction\n      return { type: 'new expression', node };\n    case 'ConditionalExpression':\n      return (isConstruction(node.consequent, callScope)\n        || isConstruction(node.alternate, callScope)\n      );\n    case 'LogicalExpression':\n      return (isConstruction(node.left, callScope)\n        || isConstruction(node.right, callScope)\n      );\n    case 'MemberExpression': {\n      const objConstruction = isConstruction(node.object, callScope);\n      if (objConstruction == null) {\n        return null;\n      }\n      return {\n        type: objConstruction.type,\n        node: objConstruction.node,\n        usage: node.object,\n      };\n    }\n    case 'JSXFragment':\n      return { type: 'JSX fragment', node };\n    case 'JSXElement':\n      return { type: 'JSX element', node };\n    case 'AssignmentExpression': {\n      const construct = isConstruction(node.right, callScope);\n      if (construct != null) {\n        return {\n          type: 'assignment expression',\n          node: construct.node,\n          usage: node,\n        };\n      }\n      return null;\n    }\n    case 'TypeCastExpression':\n    case 'TSAsExpression':\n      return isConstruction(node.expression, callScope);\n    default:\n      return null;\n  }\n}\n\n// ------------------------------------------------------------------------------\n// Rule Definition\n// ------------------------------------------------------------------------------\n\nconst messages = {\n  withIdentifierMsg: \"The '{{variableName}}' {{type}} (at line {{nodeLine}}) passed as the value prop to the Context provider (at line {{usageLine}}) changes every render. To fix this consider wrapping it in a useMemo hook.\",\n  withIdentifierMsgFunc: \"The '{{variableName}}' {{type}} (at line {{nodeLine}}) passed as the value prop to the Context provider (at line {{usageLine}}) changes every render. To fix this consider wrapping it in a useCallback hook.\",\n  defaultMsg: 'The {{type}} passed as the value prop to the Context provider (at line {{nodeLine}}) changes every render. To fix this consider wrapping it in a useMemo hook.',\n  defaultMsgFunc: 'The {{type}} passed as the value prop to the Context provider (at line {{nodeLine}}) changes every render. To fix this consider wrapping it in a useCallback hook.',\n};\n\n/** @type {import('eslint').Rule.RuleModule} */\nmodule.exports = {\n  meta: {\n    docs: {\n      description: 'Disallows JSX context provider values from taking values that will cause needless rerenders',\n      category: 'Best Practices',\n      recommended: false,\n      url: docsUrl('jsx-no-constructed-context-values'),\n    },\n    messages,\n    schema: false,\n  },\n\n  // eslint-disable-next-line arrow-body-style\n  create: Components.detect((context, components, utils) => {\n    return {\n      JSXOpeningElement(node) {\n        const openingElementName = node.name;\n        if (openingElementName.type !== 'JSXMemberExpression') {\n          // Has no member\n          return;\n        }\n\n        const isJsxContext = openingElementName.property.name === 'Provider';\n        if (!isJsxContext) {\n          // Member is not Provider\n          return;\n        }\n\n        // Contexts can take in more than just a value prop\n        // so we need to iterate through all of them\n        const jsxValueAttribute = node.attributes.find(\n          (attribute) => attribute.type === 'JSXAttribute' && attribute.name.name === 'value'\n        );\n\n        if (jsxValueAttribute == null) {\n          // No value prop was passed\n          return;\n        }\n\n        const valueNode = jsxValueAttribute.value;\n        if (!valueNode) {\n          // attribute is a boolean shorthand\n          return;\n        }\n        if (valueNode.type !== 'JSXExpressionContainer') {\n          // value could be a literal\n          return;\n        }\n\n        const valueExpression = valueNode.expression;\n        const invocationScope = getScope(context, node);\n\n        // Check if the value prop is a construction\n        const constructInfo = isConstruction(valueExpression, invocationScope);\n        if (constructInfo == null) {\n          return;\n        }\n\n        if (!utils.getParentComponent(node)) {\n          return;\n        }\n\n        // Report found error\n        const constructType = constructInfo.type;\n        const constructNode = constructInfo.node;\n        const constructUsage = constructInfo.usage;\n        const data = {\n          type: constructType, nodeLine: constructNode.loc.start.line,\n        };\n        let messageId = 'defaultMsg';\n\n        // Variable passed to value prop\n        if (constructUsage != null) {\n          messageId = 'withIdentifierMsg';\n          data.usageLine = constructUsage.loc.start.line;\n          data.variableName = constructUsage.name;\n        }\n\n        // Type of expression\n        if (\n          constructType === 'function expression'\n          || constructType === 'function declaration'\n        ) {\n          messageId += 'Func';\n        }\n\n        report(context, messages[messageId], messageId, {\n          node: constructNode,\n          data,\n        });\n      },\n    };\n  }),\n};\n"
        }
    ]
}