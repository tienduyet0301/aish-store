{
    "sourceFile": "node_modules/eslint-plugin-react/lib/rules/jsx-max-depth.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892270569,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Validate JSX maximum depth\n * @author Chris<wfsr@foxmail.com>\n */\n\n'use strict';\n\nconst has = require('hasown');\nconst includes = require('array-includes');\nconst variableUtil = require('../util/variable');\nconst jsxUtil = require('../util/jsx');\nconst docsUrl = require('../util/docsUrl');\nconst reportC = require('../util/report');\n\n// ------------------------------------------------------------------------------\n// Rule Definition\n// ------------------------------------------------------------------------------\n\nconst messages = {\n  wrongDepth: 'Expected the depth of nested jsx elements to be <= {{needed}}, but found {{found}}.',\n};\n\n/** @type {import('eslint').Rule.RuleModule} */\nmodule.exports = {\n  meta: {\n    docs: {\n      description: 'Enforce JSX maximum depth',\n      category: 'Stylistic Issues',\n      recommended: false,\n      url: docsUrl('jsx-max-depth'),\n    },\n\n    messages,\n\n    schema: [\n      {\n        type: 'object',\n        properties: {\n          max: {\n            type: 'integer',\n            minimum: 0,\n          },\n        },\n        additionalProperties: false,\n      },\n    ],\n  },\n  create(context) {\n    const DEFAULT_DEPTH = 2;\n\n    const option = context.options[0] || {};\n    const maxDepth = has(option, 'max') ? option.max : DEFAULT_DEPTH;\n\n    function isExpression(node) {\n      return node.type === 'JSXExpressionContainer';\n    }\n\n    function hasJSX(node) {\n      return jsxUtil.isJSX(node) || (isExpression(node) && jsxUtil.isJSX(node.expression));\n    }\n\n    function isLeaf(node) {\n      const children = node.children;\n\n      return !children || children.length === 0 || !children.some(hasJSX);\n    }\n\n    function getDepth(node) {\n      let count = 0;\n\n      while (jsxUtil.isJSX(node.parent) || isExpression(node.parent)) {\n        node = node.parent;\n        if (jsxUtil.isJSX(node)) {\n          count += 1;\n        }\n      }\n\n      return count;\n    }\n\n    function report(node, depth) {\n      reportC(context, messages.wrongDepth, 'wrongDepth', {\n        node,\n        data: {\n          found: depth,\n          needed: maxDepth,\n        },\n      });\n    }\n\n    function findJSXElementOrFragment(startNode, name, previousReferences) {\n      function find(refs, prevRefs) {\n        for (let i = refs.length - 1; i >= 0; i--) {\n          if (typeof refs[i].writeExpr !== 'undefined') {\n            const writeExpr = refs[i].writeExpr;\n\n            return (jsxUtil.isJSX(writeExpr)\n              && writeExpr)\n              || ((writeExpr && writeExpr.type === 'Identifier')\n              && findJSXElementOrFragment(startNode, writeExpr.name, prevRefs));\n          }\n        }\n\n        return null;\n      }\n\n      const variable = variableUtil.getVariableFromContext(context, startNode, name);\n      if (variable && variable.references) {\n        const containDuplicates = previousReferences.some((ref) => includes(variable.references, ref));\n\n        // Prevent getting stuck in circular references\n        if (containDuplicates) {\n          return false;\n        }\n\n        return find(variable.references, previousReferences.concat(variable.references));\n      }\n\n      return false;\n    }\n\n    function checkDescendant(baseDepth, children) {\n      baseDepth += 1;\n      (children || []).filter((node) => hasJSX(node)).forEach((node) => {\n        if (baseDepth > maxDepth) {\n          report(node, baseDepth);\n        } else if (!isLeaf(node)) {\n          checkDescendant(baseDepth, node.children);\n        }\n      });\n    }\n\n    function handleJSX(node) {\n      if (!isLeaf(node)) {\n        return;\n      }\n\n      const depth = getDepth(node);\n      if (depth > maxDepth) {\n        report(node, depth);\n      }\n    }\n\n    return {\n      JSXElement: handleJSX,\n      JSXFragment: handleJSX,\n\n      JSXExpressionContainer(node) {\n        if (node.expression.type !== 'Identifier') {\n          return;\n        }\n\n        const element = findJSXElementOrFragment(node, node.expression.name, []);\n\n        if (element) {\n          const baseDepth = getDepth(node);\n          checkDescendant(baseDepth, element.children);\n        }\n      },\n    };\n  },\n};\n"
        }
    ]
}