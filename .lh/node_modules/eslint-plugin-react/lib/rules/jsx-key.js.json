{
    "sourceFile": "node_modules/eslint-plugin-react/lib/rules/jsx-key.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892270431,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Report missing `key` props in iterators/collection literals.\n * @author Ben Mosher\n */\n\n'use strict';\n\nconst hasProp = require('jsx-ast-utils/hasProp');\nconst propName = require('jsx-ast-utils/propName');\nconst values = require('object.values');\nconst docsUrl = require('../util/docsUrl');\nconst pragmaUtil = require('../util/pragma');\nconst report = require('../util/report');\nconst astUtil = require('../util/ast');\nconst getText = require('../util/eslint').getText;\n\n// ------------------------------------------------------------------------------\n// Rule Definition\n// ------------------------------------------------------------------------------\n\nconst defaultOptions = {\n  checkFragmentShorthand: false,\n  checkKeyMustBeforeSpread: false,\n  warnOnDuplicates: false,\n};\n\nconst messages = {\n  missingIterKey: 'Missing \"key\" prop for element in iterator',\n  missingIterKeyUsePrag: 'Missing \"key\" prop for element in iterator. Shorthand fragment syntax does not support providing keys. Use {{reactPrag}}.{{fragPrag}} instead',\n  missingArrayKey: 'Missing \"key\" prop for element in array',\n  missingArrayKeyUsePrag: 'Missing \"key\" prop for element in array. Shorthand fragment syntax does not support providing keys. Use {{reactPrag}}.{{fragPrag}} instead',\n  keyBeforeSpread: '`key` prop must be placed before any `{...spread}, to avoid conflicting with Reactâ€™s new JSX transform: https://reactjs.org/blog/2020/09/22/introducing-the-new-jsx-transform.html`',\n  nonUniqueKeys: '`key` prop must be unique',\n};\n\n/** @type {import('eslint').Rule.RuleModule} */\nmodule.exports = {\n  meta: {\n    docs: {\n      description: 'Disallow missing `key` props in iterators/collection literals',\n      category: 'Possible Errors',\n      recommended: true,\n      url: docsUrl('jsx-key'),\n    },\n\n    messages,\n\n    schema: [{\n      type: 'object',\n      properties: {\n        checkFragmentShorthand: {\n          type: 'boolean',\n          default: defaultOptions.checkFragmentShorthand,\n        },\n        checkKeyMustBeforeSpread: {\n          type: 'boolean',\n          default: defaultOptions.checkKeyMustBeforeSpread,\n        },\n        warnOnDuplicates: {\n          type: 'boolean',\n          default: defaultOptions.warnOnDuplicates,\n        },\n      },\n      additionalProperties: false,\n    }],\n  },\n\n  create(context) {\n    const options = Object.assign({}, defaultOptions, context.options[0]);\n    const checkFragmentShorthand = options.checkFragmentShorthand;\n    const checkKeyMustBeforeSpread = options.checkKeyMustBeforeSpread;\n    const warnOnDuplicates = options.warnOnDuplicates;\n    const reactPragma = pragmaUtil.getFromContext(context);\n    const fragmentPragma = pragmaUtil.getFragmentFromContext(context);\n\n    function isKeyAfterSpread(attributes) {\n      let hasFoundSpread = false;\n      return attributes.some((attribute) => {\n        if (attribute.type === 'JSXSpreadAttribute') {\n          hasFoundSpread = true;\n          return false;\n        }\n        if (attribute.type !== 'JSXAttribute') {\n          return false;\n        }\n        return hasFoundSpread && propName(attribute) === 'key';\n      });\n    }\n\n    function checkIteratorElement(node) {\n      if (node.type === 'JSXElement') {\n        if (!hasProp(node.openingElement.attributes, 'key')) {\n          report(context, messages.missingIterKey, 'missingIterKey', { node });\n        } else {\n          const attrs = node.openingElement.attributes;\n\n          if (checkKeyMustBeforeSpread && isKeyAfterSpread(attrs)) {\n            report(context, messages.keyBeforeSpread, 'keyBeforeSpread', { node });\n          }\n        }\n      } else if (checkFragmentShorthand && node.type === 'JSXFragment') {\n        report(context, messages.missingIterKeyUsePrag, 'missingIterKeyUsePrag', {\n          node,\n          data: {\n            reactPrag: reactPragma,\n            fragPrag: fragmentPragma,\n          },\n        });\n      }\n    }\n\n    function getReturnStatements(node) {\n      const returnStatements = arguments[1] || [];\n      if (node.type === 'IfStatement') {\n        if (node.consequent) {\n          getReturnStatements(node.consequent, returnStatements);\n        }\n        if (node.alternate) {\n          getReturnStatements(node.alternate, returnStatements);\n        }\n      } else if (node.type === 'ReturnStatement') {\n        returnStatements.push(node);\n      } else if (Array.isArray(node.body)) {\n        node.body.forEach((item) => {\n          if (item.type === 'IfStatement') {\n            getReturnStatements(item, returnStatements);\n          }\n\n          if (item.type === 'ReturnStatement') {\n            returnStatements.push(item);\n          }\n        });\n      }\n\n      return returnStatements;\n    }\n\n    /**\n     * Checks if the given node is a function expression or arrow function,\n     * and checks if there is a missing key prop in return statement's arguments\n     * @param {ASTNode} node\n     */\n    function checkFunctionsBlockStatement(node) {\n      if (astUtil.isFunctionLikeExpression(node)) {\n        if (node.body.type === 'BlockStatement') {\n          getReturnStatements(node.body)\n            .filter((returnStatement) => returnStatement && returnStatement.argument)\n            .forEach((returnStatement) => {\n              checkIteratorElement(returnStatement.argument);\n            });\n        }\n      }\n    }\n\n    /**\n     * Checks if the given node is an arrow function that has an JSX Element or JSX Fragment in its body,\n     * and the JSX is missing a key prop\n     * @param {ASTNode} node\n     */\n    function checkArrowFunctionWithJSX(node) {\n      const isArrFn = node && node.type === 'ArrowFunctionExpression';\n      const shouldCheckNode = (n) => n && (n.type === 'JSXElement' || n.type === 'JSXFragment');\n      if (isArrFn && shouldCheckNode(node.body)) {\n        checkIteratorElement(node.body);\n      }\n      if (node.body.type === 'ConditionalExpression') {\n        if (shouldCheckNode(node.body.consequent)) {\n          checkIteratorElement(node.body.consequent);\n        }\n        if (shouldCheckNode(node.body.alternate)) {\n          checkIteratorElement(node.body.alternate);\n        }\n      } else if (node.body.type === 'LogicalExpression' && shouldCheckNode(node.body.right)) {\n        checkIteratorElement(node.body.right);\n      }\n    }\n\n    const childrenToArraySelector = `:matches(\n      CallExpression\n        [callee.object.object.name=${reactPragma}]\n        [callee.object.property.name=Children]\n        [callee.property.name=toArray],\n      CallExpression\n        [callee.object.name=Children]\n        [callee.property.name=toArray]\n    )`.replace(/\\s/g, '');\n    let isWithinChildrenToArray = false;\n\n    const seen = new WeakSet();\n\n    return {\n      [childrenToArraySelector]() {\n        isWithinChildrenToArray = true;\n      },\n\n      [`${childrenToArraySelector}:exit`]() {\n        isWithinChildrenToArray = false;\n      },\n\n      'ArrayExpression, JSXElement > JSXElement'(node) {\n        if (isWithinChildrenToArray) {\n          return;\n        }\n\n        const jsx = (node.type === 'ArrayExpression' ? node.elements : node.parent.children).filter((x) => x && x.type === 'JSXElement');\n        if (jsx.length === 0) {\n          return;\n        }\n\n        const map = {};\n        jsx.forEach((element) => {\n          const attrs = element.openingElement.attributes;\n          const keys = attrs.filter((x) => x.name && x.name.name === 'key');\n\n          if (keys.length === 0) {\n            if (node.type === 'ArrayExpression') {\n              report(context, messages.missingArrayKey, 'missingArrayKey', {\n                node: element,\n              });\n            }\n          } else {\n            keys.forEach((attr) => {\n              const value = getText(context, attr.value);\n              if (!map[value]) { map[value] = []; }\n              map[value].push(attr);\n\n              if (checkKeyMustBeforeSpread && isKeyAfterSpread(attrs)) {\n                report(context, messages.keyBeforeSpread, 'keyBeforeSpread', {\n                  node: node.type === 'ArrayExpression' ? node : node.parent,\n                });\n              }\n            });\n          }\n        });\n\n        if (warnOnDuplicates) {\n          values(map).filter((v) => v.length > 1).forEach((v) => {\n            v.forEach((n) => {\n              if (!seen.has(n)) {\n                seen.add(n);\n                report(context, messages.nonUniqueKeys, 'nonUniqueKeys', {\n                  node: n,\n                });\n              }\n            });\n          });\n        }\n      },\n\n      JSXFragment(node) {\n        if (!checkFragmentShorthand || isWithinChildrenToArray) {\n          return;\n        }\n\n        if (node.parent.type === 'ArrayExpression') {\n          report(context, messages.missingArrayKeyUsePrag, 'missingArrayKeyUsePrag', {\n            node,\n            data: {\n              reactPrag: reactPragma,\n              fragPrag: fragmentPragma,\n            },\n          });\n        }\n      },\n\n      // Array.prototype.map\n      // eslint-disable-next-line no-multi-str\n      'CallExpression[callee.type=\"MemberExpression\"][callee.property.name=\"map\"],\\\n       CallExpression[callee.type=\"OptionalMemberExpression\"][callee.property.name=\"map\"],\\\n       OptionalCallExpression[callee.type=\"MemberExpression\"][callee.property.name=\"map\"],\\\n       OptionalCallExpression[callee.type=\"OptionalMemberExpression\"][callee.property.name=\"map\"]'(node) {\n        if (isWithinChildrenToArray) {\n          return;\n        }\n\n        const fn = node.arguments.length > 0 && node.arguments[0];\n        if (!fn || !astUtil.isFunctionLikeExpression(fn)) {\n          return;\n        }\n\n        checkArrowFunctionWithJSX(fn);\n\n        checkFunctionsBlockStatement(fn);\n      },\n\n      // Array.from\n      'CallExpression[callee.type=\"MemberExpression\"][callee.property.name=\"from\"]'(node) {\n        if (isWithinChildrenToArray) {\n          return;\n        }\n\n        const fn = node.arguments.length > 1 && node.arguments[1];\n        if (!astUtil.isFunctionLikeExpression(fn)) {\n          return;\n        }\n\n        checkArrowFunctionWithJSX(fn);\n\n        checkFunctionsBlockStatement(fn);\n      },\n    };\n  },\n};\n"
        }
    ]
}