{
    "sourceFile": "node_modules/eslint-plugin-react/lib/rules/prefer-stateless-function.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892276052,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Enforce stateless components to be written as a pure function\n * @author Yannick Croissant\n * @author Alberto Rodríguez\n * @copyright 2015 Alberto Rodríguez. All rights reserved.\n */\n\n'use strict';\n\nconst values = require('object.values');\n\nconst Components = require('../util/Components');\nconst testReactVersion = require('../util/version').testReactVersion;\nconst astUtil = require('../util/ast');\nconst componentUtil = require('../util/componentUtil');\nconst docsUrl = require('../util/docsUrl');\nconst report = require('../util/report');\nconst eslintUtil = require('../util/eslint');\n\nconst getScope = eslintUtil.getScope;\nconst getText = eslintUtil.getText;\n\n// ------------------------------------------------------------------------------\n// Rule Definition\n// ------------------------------------------------------------------------------\n\nconst messages = {\n  componentShouldBePure: 'Component should be written as a pure function',\n};\n\n/** @type {import('eslint').Rule.RuleModule} */\nmodule.exports = {\n  meta: {\n    docs: {\n      description: 'Enforce stateless components to be written as a pure function',\n      category: 'Stylistic Issues',\n      recommended: false,\n      url: docsUrl('prefer-stateless-function'),\n    },\n\n    messages,\n\n    schema: [{\n      type: 'object',\n      properties: {\n        ignorePureComponents: {\n          default: false,\n          type: 'boolean',\n        },\n      },\n      additionalProperties: false,\n    }],\n  },\n\n  create: Components.detect((context, components, utils) => {\n    const configuration = context.options[0] || {};\n    const ignorePureComponents = configuration.ignorePureComponents || false;\n\n    // --------------------------------------------------------------------------\n    // Public\n    // --------------------------------------------------------------------------\n\n    /**\n     * Checks whether a given array of statements is a single call of `super`.\n     * @see eslint no-useless-constructor rule\n     * @param {ASTNode[]} body - An array of statements to check.\n     * @returns {boolean} `true` if the body is a single call of `super`.\n     */\n    function isSingleSuperCall(body) {\n      return (\n        body.length === 1\n        && body[0].type === 'ExpressionStatement'\n        && astUtil.isCallExpression(body[0].expression)\n        && body[0].expression.callee.type === 'Super'\n      );\n    }\n\n    /**\n     * Checks whether a given node is a pattern which doesn't have any side effects.\n     * Default parameters and Destructuring parameters can have side effects.\n     * @see eslint no-useless-constructor rule\n     * @param {ASTNode} node - A pattern node.\n     * @returns {boolean} `true` if the node doesn't have any side effects.\n     */\n    function isSimple(node) {\n      return node.type === 'Identifier' || node.type === 'RestElement';\n    }\n\n    /**\n     * Checks whether a given array of expressions is `...arguments` or not.\n     * `super(...arguments)` passes all arguments through.\n     * @see eslint no-useless-constructor rule\n     * @param {ASTNode[]} superArgs - An array of expressions to check.\n     * @returns {boolean} `true` if the superArgs is `...arguments`.\n     */\n    function isSpreadArguments(superArgs) {\n      return (\n        superArgs.length === 1\n        && superArgs[0].type === 'SpreadElement'\n        && superArgs[0].argument.type === 'Identifier'\n        && superArgs[0].argument.name === 'arguments'\n      );\n    }\n\n    /**\n     * Checks whether given 2 nodes are identifiers which have the same name or not.\n     * @see eslint no-useless-constructor rule\n     * @param {ASTNode} ctorParam - A node to check.\n     * @param {ASTNode} superArg - A node to check.\n     * @returns {boolean} `true` if the nodes are identifiers which have the same\n     *      name.\n     */\n    function isValidIdentifierPair(ctorParam, superArg) {\n      return (\n        ctorParam.type === 'Identifier'\n        && superArg.type === 'Identifier'\n        && ctorParam.name === superArg.name\n      );\n    }\n\n    /**\n     * Checks whether given 2 nodes are a rest/spread pair which has the same values.\n     * @see eslint no-useless-constructor rule\n     * @param {ASTNode} ctorParam - A node to check.\n     * @param {ASTNode} superArg - A node to check.\n     * @returns {boolean} `true` if the nodes are a rest/spread pair which has the\n     *      same values.\n     */\n    function isValidRestSpreadPair(ctorParam, superArg) {\n      return (\n        ctorParam.type === 'RestElement'\n        && superArg.type === 'SpreadElement'\n        && isValidIdentifierPair(ctorParam.argument, superArg.argument)\n      );\n    }\n\n    /**\n     * Checks whether given 2 nodes have the same value or not.\n     * @see eslint no-useless-constructor rule\n     * @param {ASTNode} ctorParam - A node to check.\n     * @param {ASTNode} superArg - A node to check.\n     * @returns {boolean} `true` if the nodes have the same value or not.\n     */\n    function isValidPair(ctorParam, superArg) {\n      return (\n        isValidIdentifierPair(ctorParam, superArg)\n        || isValidRestSpreadPair(ctorParam, superArg)\n      );\n    }\n\n    /**\n     * Checks whether the parameters of a constructor and the arguments of `super()`\n     * have the same values or not.\n     * @see eslint no-useless-constructor rule\n     * @param {ASTNode[]} ctorParams - The parameters of a constructor to check.\n     * @param {ASTNode} superArgs - The arguments of `super()` to check.\n     * @returns {boolean} `true` if those have the same values.\n     */\n    function isPassingThrough(ctorParams, superArgs) {\n      if (ctorParams.length !== superArgs.length) {\n        return false;\n      }\n\n      for (let i = 0; i < ctorParams.length; ++i) {\n        if (!isValidPair(ctorParams[i], superArgs[i])) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n\n    /**\n     * Checks whether the constructor body is a redundant super call.\n     * @see eslint no-useless-constructor rule\n     * @param {Array} body - constructor body content.\n     * @param {Array} ctorParams - The params to check against super call.\n     * @returns {boolean} true if the constructor body is redundant\n     */\n    function isRedundantSuperCall(body, ctorParams) {\n      return (\n        isSingleSuperCall(body)\n        && ctorParams.every(isSimple)\n        && (\n          isSpreadArguments(body[0].expression.arguments)\n          || isPassingThrough(ctorParams, body[0].expression.arguments)\n        )\n      );\n    }\n\n    /**\n     * Check if a given AST node have any other properties the ones available in stateless components\n     * @param {ASTNode} node The AST node being checked.\n     * @returns {boolean} True if the node has at least one other property, false if not.\n     */\n    function hasOtherProperties(node) {\n      const properties = astUtil.getComponentProperties(node);\n      return properties.some((property) => {\n        const name = astUtil.getPropertyName(property);\n        const isDisplayName = name === 'displayName';\n        const isPropTypes = name === 'propTypes' || ((name === 'props') && property.typeAnnotation);\n        const contextTypes = name === 'contextTypes';\n        const defaultProps = name === 'defaultProps';\n        const isUselessConstructor = property.kind === 'constructor'\n          && !!property.value.body\n          && isRedundantSuperCall(property.value.body.body, property.value.params);\n        const isRender = name === 'render';\n        return !isDisplayName && !isPropTypes && !contextTypes && !defaultProps && !isUselessConstructor && !isRender;\n      });\n    }\n\n    /**\n     * Mark component as pure as declared\n     * @param {ASTNode} node The AST node being checked.\n     */\n    function markSCUAsDeclared(node) {\n      components.set(node, {\n        hasSCU: true,\n      });\n    }\n\n    /**\n     * Mark childContextTypes as declared\n     * @param {ASTNode} node The AST node being checked.\n     */\n    function markChildContextTypesAsDeclared(node) {\n      components.set(node, {\n        hasChildContextTypes: true,\n      });\n    }\n\n    /**\n     * Mark a setState as used\n     * @param {ASTNode} node The AST node being checked.\n     */\n    function markThisAsUsed(node) {\n      components.set(node, {\n        useThis: true,\n      });\n    }\n\n    /**\n     * Mark a props or context as used\n     * @param {ASTNode} node The AST node being checked.\n     */\n    function markPropsOrContextAsUsed(node) {\n      components.set(node, {\n        usePropsOrContext: true,\n      });\n    }\n\n    /**\n     * Mark a ref as used\n     * @param {ASTNode} node The AST node being checked.\n     */\n    function markRefAsUsed(node) {\n      components.set(node, {\n        useRef: true,\n      });\n    }\n\n    /**\n     * Mark return as invalid\n     * @param {ASTNode} node The AST node being checked.\n     */\n    function markReturnAsInvalid(node) {\n      components.set(node, {\n        invalidReturn: true,\n      });\n    }\n\n    /**\n     * Mark a ClassDeclaration as having used decorators\n     * @param {ASTNode} node The AST node being checked.\n     */\n    function markDecoratorsAsUsed(node) {\n      components.set(node, {\n        useDecorators: true,\n      });\n    }\n\n    function visitClass(node) {\n      if (ignorePureComponents && componentUtil.isPureComponent(node, context)) {\n        markSCUAsDeclared(node);\n      }\n\n      if (node.decorators && node.decorators.length) {\n        markDecoratorsAsUsed(node);\n      }\n    }\n\n    return {\n      ClassDeclaration: visitClass,\n      ClassExpression: visitClass,\n\n      // Mark `this` destructuring as a usage of `this`\n      VariableDeclarator(node) {\n        // Ignore destructuring on other than `this`\n        if (!node.id || node.id.type !== 'ObjectPattern' || !node.init || node.init.type !== 'ThisExpression') {\n          return;\n        }\n        // Ignore `props` and `context`\n        const useThis = node.id.properties.some((property) => {\n          const name = astUtil.getPropertyName(property);\n          return name !== 'props' && name !== 'context';\n        });\n        if (!useThis) {\n          markPropsOrContextAsUsed(node);\n          return;\n        }\n        markThisAsUsed(node);\n      },\n\n      // Mark `this` usage\n      MemberExpression(node) {\n        if (node.object.type !== 'ThisExpression') {\n          if (node.property && node.property.name === 'childContextTypes') {\n            const component = utils.getRelatedComponent(node);\n            if (!component) {\n              return;\n            }\n            markChildContextTypesAsDeclared(component.node);\n          }\n          return;\n        // Ignore calls to `this.props` and `this.context`\n        }\n        if (\n          (node.property.name || node.property.value) === 'props'\n          || (node.property.name || node.property.value) === 'context'\n        ) {\n          markPropsOrContextAsUsed(node);\n          return;\n        }\n        markThisAsUsed(node);\n      },\n\n      // Mark `ref` usage\n      JSXAttribute(node) {\n        const name = getText(context, node.name);\n        if (name !== 'ref') {\n          return;\n        }\n        markRefAsUsed(node);\n      },\n\n      // Mark `render` that do not return some JSX\n      ReturnStatement(node) {\n        let blockNode;\n        let scope = getScope(context, node);\n        while (scope) {\n          blockNode = scope.block && scope.block.parent;\n          if (blockNode && (blockNode.type === 'MethodDefinition' || blockNode.type === 'Property')) {\n            break;\n          }\n          scope = scope.upper;\n        }\n        const isRender = blockNode\n          && blockNode.key\n          && blockNode.key.name === 'render';\n        const allowNull = testReactVersion(context, '>= 15.0.0'); // Stateless components can return null since React 15\n        const isReturningJSX = utils.isReturningJSX(node, !allowNull);\n        const isReturningNull = node.argument && (node.argument.value === null || node.argument.value === false);\n        if (\n          !isRender\n          || (allowNull && (isReturningJSX || isReturningNull))\n          || (!allowNull && isReturningJSX)\n        ) {\n          return;\n        }\n        markReturnAsInvalid(node);\n      },\n\n      'Program:exit'() {\n        const list = components.list();\n        values(list)\n          .filter((component) => (\n            !hasOtherProperties(component.node)\n            && !component.useThis\n            && !component.useRef\n            && !component.invalidReturn\n            && !component.hasChildContextTypes\n            && !component.useDecorators\n            && !component.hasSCU\n            && (\n              componentUtil.isES5Component(component.node, context)\n              || componentUtil.isES6Component(component.node, context)\n            )\n          ))\n          .forEach((component) => {\n            report(context, messages.componentShouldBePure, 'componentShouldBePure', {\n              node: component.node,\n            });\n          });\n      },\n    };\n  }),\n};\n"
        }
    ]
}