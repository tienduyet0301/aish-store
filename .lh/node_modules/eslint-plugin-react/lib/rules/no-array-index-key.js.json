{
    "sourceFile": "node_modules/eslint-plugin-react/lib/rules/no-array-index-key.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892273301,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Prevent usage of Array index in keys\n * @author Joe Lencioni\n */\n\n'use strict';\n\nconst has = require('hasown');\nconst astUtil = require('../util/ast');\nconst docsUrl = require('../util/docsUrl');\nconst pragma = require('../util/pragma');\nconst report = require('../util/report');\nconst variableUtil = require('../util/variable');\n\n// ------------------------------------------------------------------------------\n// Rule Definition\n// ------------------------------------------------------------------------------\n\nfunction isCreateCloneElement(node, context) {\n  if (!node) {\n    return false;\n  }\n\n  if (node.type === 'MemberExpression' || node.type === 'OptionalMemberExpression') {\n    return node.object\n      && node.object.name === pragma.getFromContext(context)\n      && ['createElement', 'cloneElement'].indexOf(node.property.name) !== -1;\n  }\n\n  if (node.type === 'Identifier') {\n    const variable = variableUtil.findVariableByName(context, node, node.name);\n    if (variable && variable.type === 'ImportSpecifier') {\n      return variable.parent.source.value === 'react';\n    }\n  }\n\n  return false;\n}\n\nconst messages = {\n  noArrayIndex: 'Do not use Array index in keys',\n};\n\n/** @type {import('eslint').Rule.RuleModule} */\nmodule.exports = {\n  meta: {\n    docs: {\n      description: 'Disallow usage of Array index in keys',\n      category: 'Best Practices',\n      recommended: false,\n      url: docsUrl('no-array-index-key'),\n    },\n\n    messages,\n\n    schema: [],\n  },\n\n  create(context) {\n    // --------------------------------------------------------------------------\n    // Public\n    // --------------------------------------------------------------------------\n    const indexParamNames = [];\n    const iteratorFunctionsToIndexParamPosition = {\n      every: 1,\n      filter: 1,\n      find: 1,\n      findIndex: 1,\n      flatMap: 1,\n      forEach: 1,\n      map: 1,\n      reduce: 2,\n      reduceRight: 2,\n      some: 1,\n    };\n\n    function isArrayIndex(node) {\n      return node.type === 'Identifier'\n        && indexParamNames.indexOf(node.name) !== -1;\n    }\n\n    function isUsingReactChildren(node) {\n      const callee = node.callee;\n      if (\n        !callee\n        || !callee.property\n        || !callee.object\n      ) {\n        return null;\n      }\n\n      const isReactChildMethod = ['map', 'forEach'].indexOf(callee.property.name) > -1;\n      if (!isReactChildMethod) {\n        return null;\n      }\n\n      const obj = callee.object;\n      if (obj && obj.name === 'Children') {\n        return true;\n      }\n      if (obj && obj.object && obj.object.name === pragma.getFromContext(context)) {\n        return true;\n      }\n\n      return false;\n    }\n\n    function getMapIndexParamName(node) {\n      const callee = node.callee;\n      if (callee.type !== 'MemberExpression' && callee.type !== 'OptionalMemberExpression') {\n        return null;\n      }\n      if (callee.property.type !== 'Identifier') {\n        return null;\n      }\n      if (!has(iteratorFunctionsToIndexParamPosition, callee.property.name)) {\n        return null;\n      }\n\n      const name = /** @type {keyof iteratorFunctionsToIndexParamPosition} */ (callee.property.name);\n\n      const callbackArg = isUsingReactChildren(node)\n        ? node.arguments[1]\n        : node.arguments[0];\n\n      if (!callbackArg) {\n        return null;\n      }\n\n      if (!astUtil.isFunctionLikeExpression(callbackArg)) {\n        return null;\n      }\n\n      const params = callbackArg.params;\n\n      const indexParamPosition = iteratorFunctionsToIndexParamPosition[name];\n      if (params.length < indexParamPosition + 1) {\n        return null;\n      }\n\n      return params[indexParamPosition].name;\n    }\n\n    function getIdentifiersFromBinaryExpression(side) {\n      if (side.type === 'Identifier') {\n        return side;\n      }\n\n      if (side.type === 'BinaryExpression') {\n        // recurse\n        const left = getIdentifiersFromBinaryExpression(side.left);\n        const right = getIdentifiersFromBinaryExpression(side.right);\n        return [].concat(left, right).filter(Boolean);\n      }\n\n      return null;\n    }\n\n    function checkPropValue(node) {\n      if (isArrayIndex(node)) {\n        // key={bar}\n        report(context, messages.noArrayIndex, 'noArrayIndex', {\n          node,\n        });\n        return;\n      }\n\n      if (node.type === 'TemplateLiteral') {\n        // key={`foo-${bar}`}\n        node.expressions.filter(isArrayIndex).forEach(() => {\n          report(context, messages.noArrayIndex, 'noArrayIndex', {\n            node,\n          });\n        });\n\n        return;\n      }\n\n      if (node.type === 'BinaryExpression') {\n        // key={'foo' + bar}\n        const identifiers = getIdentifiersFromBinaryExpression(node);\n\n        identifiers.filter(isArrayIndex).forEach(() => {\n          report(context, messages.noArrayIndex, 'noArrayIndex', {\n            node,\n          });\n        });\n\n        return;\n      }\n\n      if (\n        astUtil.isCallExpression(node)\n        && node.callee\n        && node.callee.type === 'MemberExpression'\n        && node.callee.object\n        && isArrayIndex(node.callee.object)\n        && node.callee.property\n        && node.callee.property.type === 'Identifier'\n        && node.callee.property.name === 'toString'\n      ) {\n        // key={bar.toString()}\n        report(context, messages.noArrayIndex, 'noArrayIndex', {\n          node,\n        });\n        return;\n      }\n\n      if (\n        astUtil.isCallExpression(node)\n        && node.callee\n        && node.callee.type === 'Identifier'\n        && node.callee.name === 'String'\n        && Array.isArray(node.arguments)\n        && node.arguments.length > 0\n        && isArrayIndex(node.arguments[0])\n      ) {\n        // key={String(bar)}\n        report(context, messages.noArrayIndex, 'noArrayIndex', {\n          node: node.arguments[0],\n        });\n      }\n    }\n\n    function popIndex(node) {\n      const mapIndexParamName = getMapIndexParamName(node);\n      if (!mapIndexParamName) {\n        return;\n      }\n\n      indexParamNames.pop();\n    }\n\n    return {\n      'CallExpression, OptionalCallExpression'(node) {\n        if (isCreateCloneElement(node.callee, context) && node.arguments.length > 1) {\n          // React.createElement\n          if (!indexParamNames.length) {\n            return;\n          }\n\n          const props = node.arguments[1];\n\n          if (props.type !== 'ObjectExpression') {\n            return;\n          }\n\n          props.properties.forEach((prop) => {\n            if (!prop.key || prop.key.name !== 'key') {\n              // { ...foo }\n              // { foo: bar }\n              return;\n            }\n\n            checkPropValue(prop.value);\n          });\n\n          return;\n        }\n\n        const mapIndexParamName = getMapIndexParamName(node);\n        if (!mapIndexParamName) {\n          return;\n        }\n\n        indexParamNames.push(mapIndexParamName);\n      },\n\n      JSXAttribute(node) {\n        if (node.name.name !== 'key') {\n          // foo={bar}\n          return;\n        }\n\n        if (!indexParamNames.length) {\n          // Not inside a call expression that we think has an index param.\n          return;\n        }\n\n        const value = node.value;\n        if (!value || value.type !== 'JSXExpressionContainer') {\n          // key='foo' or just simply 'key'\n          return;\n        }\n\n        checkPropValue(value.expression);\n      },\n\n      'CallExpression:exit': popIndex,\n      'OptionalCallExpression:exit': popIndex,\n    };\n  },\n};\n"
        }
    ]
}