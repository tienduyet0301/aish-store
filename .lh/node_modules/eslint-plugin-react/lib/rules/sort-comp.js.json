{
    "sourceFile": "node_modules/eslint-plugin-react/lib/rules/sort-comp.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892277372,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Enforce component methods order\n * @author Yannick Croissant\n */\n\n'use strict';\n\nconst has = require('hasown');\nconst entries = require('object.entries');\nconst values = require('object.values');\nconst arrayIncludes = require('array-includes');\n\nconst Components = require('../util/Components');\nconst astUtil = require('../util/ast');\nconst docsUrl = require('../util/docsUrl');\nconst report = require('../util/report');\n\nconst defaultConfig = {\n  order: [\n    'static-methods',\n    'lifecycle',\n    'everything-else',\n    'render',\n  ],\n  groups: {\n    lifecycle: [\n      'displayName',\n      'propTypes',\n      'contextTypes',\n      'childContextTypes',\n      'mixins',\n      'statics',\n      'defaultProps',\n      'constructor',\n      'getDefaultProps',\n      'state',\n      'getInitialState',\n      'getChildContext',\n      'getDerivedStateFromProps',\n      'componentWillMount',\n      'UNSAFE_componentWillMount',\n      'componentDidMount',\n      'componentWillReceiveProps',\n      'UNSAFE_componentWillReceiveProps',\n      'shouldComponentUpdate',\n      'componentWillUpdate',\n      'UNSAFE_componentWillUpdate',\n      'getSnapshotBeforeUpdate',\n      'componentDidUpdate',\n      'componentDidCatch',\n      'componentWillUnmount',\n    ],\n  },\n};\n\n/**\n * Get the methods order from the default config and the user config\n * @param {Object} userConfig The user configuration.\n * @returns {Array} Methods order\n */\nfunction getMethodsOrder(userConfig) {\n  userConfig = userConfig || {};\n\n  const groups = Object.assign({}, defaultConfig.groups, userConfig.groups);\n  const order = userConfig.order || defaultConfig.order;\n\n  let config = [];\n  let entry;\n  for (let i = 0, j = order.length; i < j; i++) {\n    entry = order[i];\n    if (has(groups, entry)) {\n      config = config.concat(groups[entry]);\n    } else {\n      config.push(entry);\n    }\n  }\n\n  return config;\n}\n\n// ------------------------------------------------------------------------------\n// Rule Definition\n// ------------------------------------------------------------------------------\n\nconst messages = {\n  unsortedProps: '{{propA}} should be placed {{position}} {{propB}}',\n};\n\n/** @type {import('eslint').Rule.RuleModule} */\nmodule.exports = {\n  meta: {\n    docs: {\n      description: 'Enforce component methods order',\n      category: 'Stylistic Issues',\n      recommended: false,\n      url: docsUrl('sort-comp'),\n    },\n\n    messages,\n\n    schema: [{\n      type: 'object',\n      properties: {\n        order: {\n          type: 'array',\n          items: {\n            type: 'string',\n          },\n        },\n        groups: {\n          type: 'object',\n          patternProperties: {\n            '^.*$': {\n              type: 'array',\n              items: {\n                type: 'string',\n              },\n            },\n          },\n        },\n      },\n      additionalProperties: false,\n    }],\n  },\n\n  create: Components.detect((context, components) => {\n    /** @satisfies {Record<string, { node: ASTNode, score: number, closest: { distance: number, ref: { node: null | ASTNode, index: number } } }>} */\n    const errors = {};\n    const methodsOrder = getMethodsOrder(context.options[0]);\n\n    // --------------------------------------------------------------------------\n    // Public\n    // --------------------------------------------------------------------------\n\n    const regExpRegExp = /\\/(.*)\\/([gimsuy]*)/;\n\n    /**\n     * Get indexes of the matching patterns in methods order configuration\n     * @param {Object} method - Method metadata.\n     * @returns {Array} The matching patterns indexes. Return [Infinity] if there is no match.\n     */\n    function getRefPropIndexes(method) {\n      const methodGroupIndexes = [];\n\n      methodsOrder.forEach((currentGroup, groupIndex) => {\n        if (currentGroup === 'getters') {\n          if (method.getter) {\n            methodGroupIndexes.push(groupIndex);\n          }\n        } else if (currentGroup === 'setters') {\n          if (method.setter) {\n            methodGroupIndexes.push(groupIndex);\n          }\n        } else if (currentGroup === 'type-annotations') {\n          if (method.typeAnnotation) {\n            methodGroupIndexes.push(groupIndex);\n          }\n        } else if (currentGroup === 'static-variables') {\n          if (method.staticVariable) {\n            methodGroupIndexes.push(groupIndex);\n          }\n        } else if (currentGroup === 'static-methods') {\n          if (method.staticMethod) {\n            methodGroupIndexes.push(groupIndex);\n          }\n        } else if (currentGroup === 'instance-variables') {\n          if (method.instanceVariable) {\n            methodGroupIndexes.push(groupIndex);\n          }\n        } else if (currentGroup === 'instance-methods') {\n          if (method.instanceMethod) {\n            methodGroupIndexes.push(groupIndex);\n          }\n        } else if (arrayIncludes([\n          'displayName',\n          'propTypes',\n          'contextTypes',\n          'childContextTypes',\n          'mixins',\n          'statics',\n          'defaultProps',\n          'constructor',\n          'getDefaultProps',\n          'state',\n          'getInitialState',\n          'getChildContext',\n          'getDerivedStateFromProps',\n          'componentWillMount',\n          'UNSAFE_componentWillMount',\n          'componentDidMount',\n          'componentWillReceiveProps',\n          'UNSAFE_componentWillReceiveProps',\n          'shouldComponentUpdate',\n          'componentWillUpdate',\n          'UNSAFE_componentWillUpdate',\n          'getSnapshotBeforeUpdate',\n          'componentDidUpdate',\n          'componentDidCatch',\n          'componentWillUnmount',\n          'render',\n        ], currentGroup)) {\n          if (currentGroup === method.name) {\n            methodGroupIndexes.push(groupIndex);\n          }\n        } else {\n          // Is the group a regex?\n          const isRegExp = currentGroup.match(regExpRegExp);\n          if (isRegExp) {\n            const isMatching = new RegExp(isRegExp[1], isRegExp[2]).test(method.name);\n            if (isMatching) {\n              methodGroupIndexes.push(groupIndex);\n            }\n          } else if (currentGroup === method.name) {\n            methodGroupIndexes.push(groupIndex);\n          }\n        }\n      });\n\n      // No matching pattern, return 'everything-else' index\n      if (methodGroupIndexes.length === 0) {\n        const everythingElseIndex = methodsOrder.indexOf('everything-else');\n\n        if (everythingElseIndex !== -1) {\n          methodGroupIndexes.push(everythingElseIndex);\n        } else {\n          // No matching pattern and no 'everything-else' group\n          methodGroupIndexes.push(Infinity);\n        }\n      }\n\n      return methodGroupIndexes;\n    }\n\n    /**\n     * Get properties name\n     * @param {Object} node - Property.\n     * @returns {string} Property name.\n     */\n    function getPropertyName(node) {\n      if (node.kind === 'get') {\n        return 'getter functions';\n      }\n\n      if (node.kind === 'set') {\n        return 'setter functions';\n      }\n\n      return astUtil.getPropertyName(node);\n    }\n\n    /**\n     * Store a new error in the error list\n     * @param {Object} propA - Mispositioned property.\n     * @param {Object} propB - Reference property.\n     */\n    function storeError(propA, propB) {\n      // Initialize the error object if needed\n      if (!errors[propA.index]) {\n        errors[propA.index] = {\n          node: propA.node,\n          score: 0,\n          closest: {\n            distance: Infinity,\n            ref: {\n              node: null,\n              index: 0,\n            },\n          },\n        };\n      }\n      // Increment the prop score\n      errors[propA.index].score += 1;\n      // Stop here if we already have pushed another node at this position\n      if (getPropertyName(errors[propA.index].node) !== getPropertyName(propA.node)) {\n        return;\n      }\n      // Stop here if we already have a closer reference\n      if (Math.abs(propA.index - propB.index) > errors[propA.index].closest.distance) {\n        return;\n      }\n      // Update the closest reference\n      errors[propA.index].closest.distance = Math.abs(propA.index - propB.index);\n      errors[propA.index].closest.ref.node = propB.node;\n      errors[propA.index].closest.ref.index = propB.index;\n    }\n\n    /**\n     * Dedupe errors, only keep the ones with the highest score and delete the others\n     */\n    function dedupeErrors() {\n      entries(errors).forEach((entry) => {\n        const i = entry[0];\n        const error = entry[1];\n\n        const index = error.closest.ref.index;\n        if (errors[index]) {\n          if (error.score > errors[index].score) {\n            delete errors[index];\n          } else {\n            delete errors[i];\n          }\n        }\n      });\n    }\n\n    /**\n     * Report errors\n     */\n    function reportErrors() {\n      dedupeErrors();\n\n      entries(errors).forEach((entry) => {\n        const nodeA = entry[1].node;\n        const nodeB = entry[1].closest.ref.node;\n        const indexA = entry[0];\n        const indexB = entry[1].closest.ref.index;\n\n        report(context, messages.unsortedProps, 'unsortedProps', {\n          node: nodeA,\n          data: {\n            propA: getPropertyName(nodeA),\n            propB: getPropertyName(nodeB),\n            position: indexA < indexB ? 'before' : 'after',\n          },\n        });\n      });\n    }\n\n    /**\n     * Compare two properties and find out if they are in the right order\n     * @param {Array} propertiesInfos Array containing all the properties metadata.\n     * @param {Object} propA First property name and metadata\n     * @param {Object} propB Second property name.\n     * @returns {Object} Object containing a correct true/false flag and the correct indexes for the two properties.\n     */\n    function comparePropsOrder(propertiesInfos, propA, propB) {\n      let i;\n      let j;\n      let k;\n      let l;\n      let refIndexA;\n      let refIndexB;\n\n      // Get references indexes (the correct position) for given properties\n      const refIndexesA = getRefPropIndexes(propA);\n      const refIndexesB = getRefPropIndexes(propB);\n\n      // Get current indexes for given properties\n      const classIndexA = propertiesInfos.indexOf(propA);\n      const classIndexB = propertiesInfos.indexOf(propB);\n\n      // Loop around the references indexes for the 1st property\n      for (i = 0, j = refIndexesA.length; i < j; i++) {\n        refIndexA = refIndexesA[i];\n\n        // Loop around the properties for the 2nd property (for comparison)\n        for (k = 0, l = refIndexesB.length; k < l; k++) {\n          refIndexB = refIndexesB[k];\n\n          if (\n            // Comparing the same properties\n            refIndexA === refIndexB\n            // 1st property is placed before the 2nd one in reference and in current component\n            || ((refIndexA < refIndexB) && (classIndexA < classIndexB))\n            // 1st property is placed after the 2nd one in reference and in current component\n            || ((refIndexA > refIndexB) && (classIndexA > classIndexB))\n          ) {\n            return {\n              correct: true,\n              indexA: classIndexA,\n              indexB: classIndexB,\n            };\n          }\n        }\n      }\n\n      // We did not find any correct match between reference and current component\n      return {\n        correct: false,\n        indexA: refIndexA,\n        indexB: refIndexB,\n      };\n    }\n\n    /**\n     * Check properties order from a properties list and store the eventual errors\n     * @param {Array} properties Array containing all the properties.\n     */\n    function checkPropsOrder(properties) {\n      const propertiesInfos = properties.map((node) => ({\n        name: getPropertyName(node),\n        getter: node.kind === 'get',\n        setter: node.kind === 'set',\n        staticVariable: node.static\n          && (node.type === 'ClassProperty' || node.type === 'PropertyDefinition')\n          && (!node.value || !astUtil.isFunctionLikeExpression(node.value)),\n        staticMethod: node.static\n          && (node.type === 'ClassProperty' || node.type === 'PropertyDefinition' || node.type === 'MethodDefinition')\n          && node.value\n          && (astUtil.isFunctionLikeExpression(node.value)),\n        instanceVariable: !node.static\n          && (node.type === 'ClassProperty' || node.type === 'PropertyDefinition')\n          && (!node.value || !astUtil.isFunctionLikeExpression(node.value)),\n        instanceMethod: !node.static\n          && (node.type === 'ClassProperty' || node.type === 'PropertyDefinition')\n          && node.value\n          && (astUtil.isFunctionLikeExpression(node.value)),\n        typeAnnotation: !!node.typeAnnotation && node.value === null,\n      }));\n\n      // Loop around the properties\n      propertiesInfos.forEach((propA, i) => {\n        // Loop around the properties a second time (for comparison)\n        propertiesInfos.forEach((propB, k) => {\n          if (i === k) {\n            return;\n          }\n\n          // Compare the properties order\n          const order = comparePropsOrder(propertiesInfos, propA, propB);\n\n          if (!order.correct) {\n            // Store an error if the order is incorrect\n            storeError({\n              node: properties[i],\n              index: order.indexA,\n            }, {\n              node: properties[k],\n              index: order.indexB,\n            });\n          }\n        });\n      });\n    }\n\n    return {\n      'Program:exit'() {\n        values(components.list()).forEach((component) => {\n          const properties = astUtil.getComponentProperties(component.node);\n          checkPropsOrder(properties);\n        });\n\n        reportErrors();\n      },\n    };\n  }),\n\n  defaultConfig,\n};\n"
        }
    ]
}