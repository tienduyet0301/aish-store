{
    "sourceFile": "node_modules/eslint-plugin-react/lib/rules/function-component-definition.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892267449,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Standardize the way function component get defined\n * @author Stefan Wullems\n */\n\n'use strict';\n\nconst arrayIncludes = require('array-includes');\nconst Components = require('../util/Components');\nconst docsUrl = require('../util/docsUrl');\nconst reportC = require('../util/report');\nconst getText = require('../util/eslint').getText;\nconst propsUtil = require('../util/props');\n\n// ------------------------------------------------------------------------------\n// Rule Definition\n// ------------------------------------------------------------------------------\n\nfunction buildFunction(template, parts) {\n  return Object.keys(parts).reduce(\n    (acc, key) => acc.replace(`{${key}}`, () => parts[key] || ''),\n    template\n  );\n}\n\nconst NAMED_FUNCTION_TEMPLATES = {\n  'function-declaration': 'function {name}{typeParams}({params}){returnType} {body}',\n  'arrow-function': '{varType} {name}{typeAnnotation} = {typeParams}({params}){returnType} => {body}',\n  'function-expression': '{varType} {name}{typeAnnotation} = function{typeParams}({params}){returnType} {body}',\n};\n\nconst UNNAMED_FUNCTION_TEMPLATES = {\n  'function-expression': 'function{typeParams}({params}){returnType} {body}',\n  'arrow-function': '{typeParams}({params}){returnType} => {body}',\n};\n\nfunction hasOneUnconstrainedTypeParam(node) {\n  const nodeTypeArguments = propsUtil.getTypeArguments(node);\n\n  return nodeTypeArguments\n    && nodeTypeArguments.params\n    && nodeTypeArguments.params.length === 1\n    && !nodeTypeArguments.params[0].constraint;\n}\n\nfunction hasName(node) {\n  return (\n    node.type === 'FunctionDeclaration'\n    || node.parent.type === 'VariableDeclarator'\n  );\n}\n\nfunction getNodeText(prop, source) {\n  if (!prop) return null;\n  return source.slice(prop.range[0], prop.range[1]);\n}\n\nfunction getName(node) {\n  if (node.type === 'FunctionDeclaration') {\n    return node.id.name;\n  }\n\n  if (\n    node.type === 'ArrowFunctionExpression'\n    || node.type === 'FunctionExpression'\n  ) {\n    return hasName(node) && node.parent.id.name;\n  }\n}\n\nfunction getParams(node, source) {\n  if (node.params.length === 0) return null;\n  return source.slice(\n    node.params[0].range[0],\n    node.params[node.params.length - 1].range[1]\n  );\n}\n\nfunction getBody(node, source) {\n  const range = node.body.range;\n\n  if (node.body.type !== 'BlockStatement') {\n    return ['{', `  return ${source.slice(range[0], range[1])}`, '}'].join('\\n');\n  }\n\n  return source.slice(range[0], range[1]);\n}\n\nfunction getTypeAnnotation(node, source) {\n  if (!hasName(node) || node.type === 'FunctionDeclaration') return;\n\n  if (\n    node.type === 'ArrowFunctionExpression'\n    || node.type === 'FunctionExpression'\n  ) {\n    return getNodeText(node.parent.id.typeAnnotation, source);\n  }\n}\n\nfunction isUnfixableBecauseOfExport(node) {\n  return (\n    node.type === 'FunctionDeclaration'\n    && node.parent\n    && node.parent.type === 'ExportDefaultDeclaration'\n  );\n}\n\nfunction isFunctionExpressionWithName(node) {\n  return node.type === 'FunctionExpression' && node.id && node.id.name;\n}\n\nconst messages = {\n  'function-declaration': 'Function component is not a function declaration',\n  'function-expression': 'Function component is not a function expression',\n  'arrow-function': 'Function component is not an arrow function',\n};\n\n/** @type {import('eslint').Rule.RuleModule} */\nmodule.exports = {\n  meta: {\n    docs: {\n      description: 'Enforce a specific function type for function components',\n      category: 'Stylistic Issues',\n      recommended: false,\n      url: docsUrl('function-component-definition'),\n    },\n    fixable: 'code',\n\n    messages,\n\n    schema: [\n      {\n        type: 'object',\n        properties: {\n          namedComponents: {\n            anyOf: [\n              {\n                enum: [\n                  'function-declaration',\n                  'arrow-function',\n                  'function-expression',\n                ],\n              },\n              {\n                type: 'array',\n                items: {\n                  type: 'string',\n                  enum: [\n                    'function-declaration',\n                    'arrow-function',\n                    'function-expression',\n                  ],\n                },\n              },\n            ],\n          },\n          unnamedComponents: {\n            anyOf: [\n              { enum: ['arrow-function', 'function-expression'] },\n              {\n                type: 'array',\n                items: {\n                  type: 'string',\n                  enum: ['arrow-function', 'function-expression'],\n                },\n              },\n            ],\n          },\n        },\n      },\n    ],\n  },\n\n  create: Components.detect((context, components) => {\n    const configuration = context.options[0] || {};\n    let fileVarType = 'var';\n\n    const namedConfig = [].concat(\n      configuration.namedComponents || 'function-declaration'\n    );\n    const unnamedConfig = [].concat(\n      configuration.unnamedComponents || 'function-expression'\n    );\n\n    function getFixer(node, options) {\n      const source = getText(context);\n\n      const typeAnnotation = getTypeAnnotation(node, source);\n\n      if (options.type === 'function-declaration' && typeAnnotation) {\n        return;\n      }\n      if (options.type === 'arrow-function' && hasOneUnconstrainedTypeParam(node)) {\n        return;\n      }\n      if (isUnfixableBecauseOfExport(node)) return;\n      if (isFunctionExpressionWithName(node)) return;\n      let varType = fileVarType;\n      if (\n        (node.type === 'FunctionExpression' || node.type === 'ArrowFunctionExpression')\n        && node.parent.type === 'VariableDeclarator'\n      ) {\n        varType = node.parent.parent.kind;\n      }\n\n      const nodeTypeArguments = propsUtil.getTypeArguments(node);\n      return (fixer) => fixer.replaceTextRange(\n        options.range,\n        buildFunction(options.template, {\n          typeAnnotation,\n          typeParams: getNodeText(nodeTypeArguments, source),\n          params: getParams(node, source),\n          returnType: getNodeText(node.returnType, source),\n          body: getBody(node, source),\n          name: getName(node),\n          varType,\n        })\n      );\n    }\n\n    function report(node, options) {\n      reportC(context, messages[options.messageId], options.messageId, {\n        node,\n        fix: getFixer(node, options.fixerOptions),\n      });\n    }\n\n    function validate(node, functionType) {\n      if (!components.get(node)) return;\n\n      if (node.parent && node.parent.type === 'Property') return;\n\n      if (hasName(node) && !arrayIncludes(namedConfig, functionType)) {\n        report(node, {\n          messageId: namedConfig[0],\n          fixerOptions: {\n            type: namedConfig[0],\n            template: NAMED_FUNCTION_TEMPLATES[namedConfig[0]],\n            range:\n              node.type === 'FunctionDeclaration'\n                ? node.range\n                : node.parent.parent.range,\n          },\n        });\n      }\n      if (!hasName(node) && !arrayIncludes(unnamedConfig, functionType)) {\n        report(node, {\n          messageId: unnamedConfig[0],\n          fixerOptions: {\n            type: unnamedConfig[0],\n            template: UNNAMED_FUNCTION_TEMPLATES[unnamedConfig[0]],\n            range: node.range,\n          },\n        });\n      }\n    }\n\n    // --------------------------------------------------------------------------\n    // Public\n    // --------------------------------------------------------------------------\n    const validatePairs = [];\n    let hasES6OrJsx = false;\n    return {\n      FunctionDeclaration(node) {\n        validatePairs.push([node, 'function-declaration']);\n      },\n      ArrowFunctionExpression(node) {\n        validatePairs.push([node, 'arrow-function']);\n      },\n      FunctionExpression(node) {\n        validatePairs.push([node, 'function-expression']);\n      },\n      VariableDeclaration(node) {\n        hasES6OrJsx = hasES6OrJsx || node.kind === 'const' || node.kind === 'let';\n      },\n      'Program:exit'() {\n        if (hasES6OrJsx) fileVarType = 'const';\n        validatePairs.forEach((pair) => validate(pair[0], pair[1]));\n      },\n      'ImportDeclaration, ExportNamedDeclaration, ExportDefaultDeclaration, ExportAllDeclaration, ExportSpecifier, ExportDefaultSpecifier, JSXElement, TSExportAssignment, TSImportEqualsDeclaration'() {\n        hasES6OrJsx = true;\n      },\n    };\n  }),\n};\n"
        }
    ]
}