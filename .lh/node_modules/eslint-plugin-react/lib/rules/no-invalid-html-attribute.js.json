{
    "sourceFile": "node_modules/eslint-plugin-react/lib/rules/no-invalid-html-attribute.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892274313,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Check if tag attributes to have non-valid value\n * @author Sebastian Malton\n */\n\n'use strict';\n\nconst matchAll = require('string.prototype.matchall');\nconst docsUrl = require('../util/docsUrl');\nconst report = require('../util/report');\n\n// ------------------------------------------------------------------------------\n// Rule Definition\n// ------------------------------------------------------------------------------\n\nconst rel = new Map([\n  ['alternate', new Set(['link', 'area', 'a'])],\n  ['apple-touch-icon', new Set(['link'])],\n  ['apple-touch-startup-image', new Set(['link'])],\n  ['author', new Set(['link', 'area', 'a'])],\n  ['bookmark', new Set(['area', 'a'])],\n  ['canonical', new Set(['link'])],\n  ['dns-prefetch', new Set(['link'])],\n  ['external', new Set(['area', 'a', 'form'])],\n  ['help', new Set(['link', 'area', 'a', 'form'])],\n  ['icon', new Set(['link'])],\n  ['license', new Set(['link', 'area', 'a', 'form'])],\n  ['manifest', new Set(['link'])],\n  ['mask-icon', new Set(['link'])],\n  ['modulepreload', new Set(['link'])],\n  ['next', new Set(['link', 'area', 'a', 'form'])],\n  ['nofollow', new Set(['area', 'a', 'form'])],\n  ['noopener', new Set(['area', 'a', 'form'])],\n  ['noreferrer', new Set(['area', 'a', 'form'])],\n  ['opener', new Set(['area', 'a', 'form'])],\n  ['pingback', new Set(['link'])],\n  ['preconnect', new Set(['link'])],\n  ['prefetch', new Set(['link'])],\n  ['preload', new Set(['link'])],\n  ['prerender', new Set(['link'])],\n  ['prev', new Set(['link', 'area', 'a', 'form'])],\n  ['search', new Set(['link', 'area', 'a', 'form'])],\n  ['shortcut', new Set(['link'])], // generally allowed but needs pair with \"icon\"\n  ['shortcut\\u0020icon', new Set(['link'])],\n  ['stylesheet', new Set(['link'])],\n  ['tag', new Set(['area', 'a'])],\n]);\n\nconst pairs = new Map([\n  ['shortcut', new Set(['icon'])],\n]);\n\n/**\n * Map between attributes and a mapping between valid values and a set of tags they are valid on\n * @type {Map<string, Map<string, Set<string>>>}\n */\nconst VALID_VALUES = new Map([\n  ['rel', rel],\n]);\n\n/**\n * Map between attributes and a mapping between pair-values and a set of values they are valid with\n * @type {Map<string, Map<string, Set<string>>>}\n */\nconst VALID_PAIR_VALUES = new Map([\n  ['rel', pairs],\n]);\n\n/**\n * The set of all possible HTML elements. Used for skipping custom types\n * @type {Set<string>}\n */\nconst HTML_ELEMENTS = new Set([\n  'a',\n  'abbr',\n  'acronym',\n  'address',\n  'applet',\n  'area',\n  'article',\n  'aside',\n  'audio',\n  'b',\n  'base',\n  'basefont',\n  'bdi',\n  'bdo',\n  'bgsound',\n  'big',\n  'blink',\n  'blockquote',\n  'body',\n  'br',\n  'button',\n  'canvas',\n  'caption',\n  'center',\n  'cite',\n  'code',\n  'col',\n  'colgroup',\n  'content',\n  'data',\n  'datalist',\n  'dd',\n  'del',\n  'details',\n  'dfn',\n  'dialog',\n  'dir',\n  'div',\n  'dl',\n  'dt',\n  'em',\n  'embed',\n  'fieldset',\n  'figcaption',\n  'figure',\n  'font',\n  'footer',\n  'form',\n  'frame',\n  'frameset',\n  'h1',\n  'h2',\n  'h3',\n  'h4',\n  'h5',\n  'h6',\n  'head',\n  'header',\n  'hgroup',\n  'hr',\n  'html',\n  'i',\n  'iframe',\n  'image',\n  'img',\n  'input',\n  'ins',\n  'kbd',\n  'keygen',\n  'label',\n  'legend',\n  'li',\n  'link',\n  'main',\n  'map',\n  'mark',\n  'marquee',\n  'math',\n  'menu',\n  'menuitem',\n  'meta',\n  'meter',\n  'nav',\n  'nobr',\n  'noembed',\n  'noframes',\n  'noscript',\n  'object',\n  'ol',\n  'optgroup',\n  'option',\n  'output',\n  'p',\n  'param',\n  'picture',\n  'plaintext',\n  'portal',\n  'pre',\n  'progress',\n  'q',\n  'rb',\n  'rp',\n  'rt',\n  'rtc',\n  'ruby',\n  's',\n  'samp',\n  'script',\n  'section',\n  'select',\n  'shadow',\n  'slot',\n  'small',\n  'source',\n  'spacer',\n  'span',\n  'strike',\n  'strong',\n  'style',\n  'sub',\n  'summary',\n  'sup',\n  'svg',\n  'table',\n  'tbody',\n  'td',\n  'template',\n  'textarea',\n  'tfoot',\n  'th',\n  'thead',\n  'time',\n  'title',\n  'tr',\n  'track',\n  'tt',\n  'u',\n  'ul',\n  'var',\n  'video',\n  'wbr',\n  'xmp',\n]);\n\n/**\n* Map between attributes and set of tags that the attribute is valid on\n* @type {Map<string, Set<string>>}\n*/\nconst COMPONENT_ATTRIBUTE_MAP = new Map([\n  ['rel', new Set(['link', 'a', 'area', 'form'])],\n]);\n\n/* eslint-disable eslint-plugin/no-unused-message-ids -- false positives, these messageIds are used */\nconst messages = {\n  emptyIsMeaningless: 'An empty “{{attributeName}}” attribute is meaningless.',\n  neverValid: '“{{reportingValue}}” is never a valid “{{attributeName}}” attribute value.',\n  noEmpty: 'An empty “{{attributeName}}” attribute is meaningless.',\n  noMethod: 'The ”{{attributeName}}“ attribute cannot be a method.',\n  notAlone: '“{{reportingValue}}” must be directly followed by “{{missingValue}}”.',\n  notPaired: '“{{reportingValue}}” can not be directly followed by “{{secondValue}}” without “{{missingValue}}”.',\n  notValidFor: '“{{reportingValue}}” is not a valid “{{attributeName}}” attribute value for <{{elementName}}>.',\n  onlyMeaningfulFor: 'The ”{{attributeName}}“ attribute only has meaning on the tags: {{tagNames}}',\n  onlyStrings: '“{{attributeName}}” attribute only supports strings.',\n  spaceDelimited: '”{{attributeName}}“ attribute values should be space delimited.',\n  suggestRemoveDefault: '\"remove {{attributeName}}\"',\n  suggestRemoveEmpty: '\"remove empty attribute {{attributeName}}\"',\n  suggestRemoveInvalid: '“remove invalid attribute {{reportingValue}}”',\n  suggestRemoveWhitespaces: 'remove whitespaces in “{{attributeName}}”',\n  suggestRemoveNonString: 'remove non-string value in “{{attributeName}}”',\n};\n\nfunction splitIntoRangedParts(node, regex) {\n  const valueRangeStart = node.range[0] + 1; // the plus one is for the initial quote\n\n  return Array.from(matchAll(node.value, regex), (match) => {\n    const start = match.index + valueRangeStart;\n    const end = start + match[0].length;\n\n    return {\n      reportingValue: `${match[1]}`,\n      value: match[1],\n      range: [start, end],\n    };\n  });\n}\n\nfunction checkLiteralValueNode(context, attributeName, node, parentNode, parentNodeName) {\n  if (typeof node.value !== 'string') {\n    const data = { attributeName, reportingValue: node.value };\n\n    report(context, messages.onlyStrings, 'onlyStrings', {\n      node,\n      data,\n      suggest: [{\n        messageId: 'suggestRemoveNonString',\n        data,\n        fix(fixer) { return fixer.remove(parentNode); },\n      }],\n    });\n    return;\n  }\n\n  if (!node.value.trim()) {\n    const data = { attributeName, reportingValue: node.value };\n\n    report(context, messages.noEmpty, 'noEmpty', {\n      node,\n      data,\n      suggest: [{\n        messageId: 'suggestRemoveEmpty',\n        data,\n        fix(fixer) { return fixer.remove(node.parent); },\n      }],\n    });\n    return;\n  }\n\n  const singleAttributeParts = splitIntoRangedParts(node, /(\\S+)/g);\n  singleAttributeParts.forEach((singlePart) => {\n    const allowedTags = VALID_VALUES.get(attributeName).get(singlePart.value);\n    const reportingValue = singlePart.reportingValue;\n\n    if (!allowedTags) {\n      const data = {\n        attributeName,\n        reportingValue,\n      };\n\n      const suggest = [{\n        messageId: 'suggestRemoveInvalid',\n        data,\n        fix(fixer) { return fixer.removeRange(singlePart.range); },\n      }];\n\n      report(context, messages.neverValid, 'neverValid', {\n        node,\n        data,\n        suggest,\n      });\n    } else if (!allowedTags.has(parentNodeName)) {\n      const data = {\n        attributeName,\n        reportingValue,\n        elementName: parentNodeName,\n      };\n\n      const suggest = [{\n        messageId: 'suggestRemoveInvalid',\n        data,\n        fix(fixer) { return fixer.removeRange(singlePart.range); },\n      }];\n\n      report(context, messages.notValidFor, 'notValidFor', {\n        node,\n        data,\n        suggest,\n      });\n    }\n  });\n\n  const allowedPairsForAttribute = VALID_PAIR_VALUES.get(attributeName);\n  if (allowedPairsForAttribute) {\n    const pairAttributeParts = splitIntoRangedParts(node, /(?=(\\b\\S+\\s*\\S+))/g);\n    pairAttributeParts.forEach((pairPart) => {\n      allowedPairsForAttribute.forEach((siblings, pairing) => {\n        const attributes = pairPart.reportingValue.split('\\u0020');\n        const firstValue = attributes[0];\n        const secondValue = attributes[1];\n        if (firstValue === pairing) {\n          const lastValue = attributes[attributes.length - 1]; // in case of multiple white spaces\n          if (!siblings.has(lastValue)) {\n            const message = secondValue ? messages.notPaired : messages.notAlone;\n            const messageId = secondValue ? 'notPaired' : 'notAlone';\n            report(context, message, messageId, {\n              node,\n              data: {\n                reportingValue: firstValue,\n                secondValue,\n                missingValue: Array.from(siblings).join(', '),\n              },\n              suggest: false,\n            });\n          }\n        }\n      });\n    });\n  }\n\n  const whitespaceParts = splitIntoRangedParts(node, /(\\s+)/g);\n  whitespaceParts.forEach((whitespacePart) => {\n    const data = { attributeName };\n\n    if (whitespacePart.range[0] === (node.range[0] + 1) || whitespacePart.range[1] === (node.range[1] - 1)) {\n      report(context, messages.spaceDelimited, 'spaceDelimited', {\n        node,\n        data,\n        suggest: [{\n          messageId: 'suggestRemoveWhitespaces',\n          data,\n          fix(fixer) { return fixer.removeRange(whitespacePart.range); },\n        }],\n      });\n    } else if (whitespacePart.value !== '\\u0020') {\n      report(context, messages.spaceDelimited, 'spaceDelimited', {\n        node,\n        data,\n        suggest: [{\n          messageId: 'suggestRemoveWhitespaces',\n          data,\n          fix(fixer) { return fixer.replaceTextRange(whitespacePart.range, '\\u0020'); },\n        }],\n      });\n    }\n  });\n}\n\nconst DEFAULT_ATTRIBUTES = ['rel'];\n\nfunction checkAttribute(context, node) {\n  const attribute = node.name.name;\n\n  const parentNodeName = node.parent.name.name;\n  if (!COMPONENT_ATTRIBUTE_MAP.has(attribute) || !COMPONENT_ATTRIBUTE_MAP.get(attribute).has(parentNodeName)) {\n    const tagNames = Array.from(\n      COMPONENT_ATTRIBUTE_MAP.get(attribute).values(),\n      (tagName) => `\"<${tagName}>\"`\n    ).join(', ');\n    const data = {\n      attributeName: attribute,\n      tagNames,\n    };\n\n    report(context, messages.onlyMeaningfulFor, 'onlyMeaningfulFor', {\n      node: node.name,\n      data,\n      suggest: [{\n        messageId: 'suggestRemoveDefault',\n        data,\n        fix(fixer) { return fixer.remove(node); },\n      }],\n    });\n    return;\n  }\n\n  function fix(fixer) { return fixer.remove(node); }\n\n  if (!node.value) {\n    const data = { attributeName: attribute };\n\n    report(context, messages.emptyIsMeaningless, 'emptyIsMeaningless', {\n      node: node.name,\n      data,\n      suggest: [{\n        messageId: 'suggestRemoveEmpty',\n        data,\n        fix,\n      }],\n    });\n    return;\n  }\n\n  if (node.value.type === 'Literal') {\n    return checkLiteralValueNode(context, attribute, node.value, node, parentNodeName);\n  }\n\n  if (node.value.expression.type === 'Literal') {\n    return checkLiteralValueNode(context, attribute, node.value.expression, node, parentNodeName);\n  }\n\n  if (node.value.type !== 'JSXExpressionContainer') {\n    return;\n  }\n\n  if (node.value.expression.type === 'ObjectExpression') {\n    const data = { attributeName: attribute };\n\n    report(context, messages.onlyStrings, 'onlyStrings', {\n      node: node.value,\n      data,\n      suggest: [{\n        messageId: 'suggestRemoveDefault',\n        data,\n        fix,\n      }],\n    });\n  } else if (node.value.expression.type === 'Identifier' && node.value.expression.name === 'undefined') {\n    const data = { attributeName: attribute };\n\n    report(context, messages.onlyStrings, 'onlyStrings', {\n      node: node.value,\n      data,\n      suggest: [{\n        messageId: 'suggestRemoveDefault',\n        data,\n        fix,\n      }],\n    });\n  }\n}\n\nfunction isValidCreateElement(node) {\n  return node.callee\n    && node.callee.type === 'MemberExpression'\n    && node.callee.object.name === 'React'\n    && node.callee.property.name === 'createElement'\n    && node.arguments.length > 0;\n}\n\nfunction checkPropValidValue(context, node, value, attribute) {\n  const validTags = VALID_VALUES.get(attribute);\n\n  if (value.type !== 'Literal') {\n    return; // cannot check non-literals\n  }\n\n  const validTagSet = validTags.get(value.value);\n  if (!validTagSet) {\n    const data = {\n      attributeName: attribute,\n      reportingValue: value.value,\n    };\n\n    report(context, messages.neverValid, 'neverValid', {\n      node: value,\n      data,\n      suggest: [{\n        messageId: 'suggestRemoveInvalid',\n        data,\n        fix(fixer) { return fixer.replaceText(value, value.raw.replace(value.value, '')); },\n      }],\n    });\n  } else if (!validTagSet.has(node.arguments[0].value)) {\n    report(context, messages.notValidFor, 'notValidFor', {\n      node: value,\n      data: {\n        attributeName: attribute,\n        reportingValue: value.raw,\n        elementName: node.arguments[0].value,\n      },\n      suggest: false,\n    });\n  }\n}\n\n/**\n *\n * @param {*} context\n * @param {*} node\n * @param {string} attribute\n */\nfunction checkCreateProps(context, node, attribute) {\n  const propsArg = node.arguments[1];\n\n  if (!propsArg || propsArg.type !== 'ObjectExpression') {\n    return; // can't check variables, computed, or shorthands\n  }\n\n  for (const prop of propsArg.properties) {\n    if (!prop.key || prop.key.type !== 'Identifier') {\n      // eslint-disable-next-line no-continue\n      continue; // cannot check computed keys\n    }\n\n    if (prop.key.name !== attribute) {\n      // eslint-disable-next-line no-continue\n      continue; // ignore not this attribute\n    }\n\n    if (!COMPONENT_ATTRIBUTE_MAP.get(attribute).has(node.arguments[0].value)) {\n      const tagNames = Array.from(\n        COMPONENT_ATTRIBUTE_MAP.get(attribute).values(),\n        (tagName) => `\"<${tagName}>\"`\n      ).join(', ');\n\n      report(context, messages.onlyMeaningfulFor, 'onlyMeaningfulFor', {\n        node: prop.key,\n        data: {\n          attributeName: attribute,\n          tagNames,\n        },\n        suggest: false,\n      });\n\n      // eslint-disable-next-line no-continue\n      continue;\n    }\n\n    if (prop.method) {\n      report(context, messages.noMethod, 'noMethod', {\n        node: prop,\n        data: {\n          attributeName: attribute,\n        },\n        suggest: false,\n      });\n\n      // eslint-disable-next-line no-continue\n      continue;\n    }\n\n    if (prop.shorthand || prop.computed) {\n      // eslint-disable-next-line no-continue\n      continue; // cannot check these\n    }\n\n    if (prop.value.type === 'ArrayExpression') {\n      prop.value.elements.forEach((value) => {\n        checkPropValidValue(context, node, value, attribute);\n      });\n\n      // eslint-disable-next-line no-continue\n      continue;\n    }\n\n    checkPropValidValue(context, node, prop.value, attribute);\n  }\n}\n\n/** @type {import('eslint').Rule.RuleModule} */\nmodule.exports = {\n  meta: {\n    docs: {\n      description: 'Disallow usage of invalid attributes',\n      category: 'Possible Errors',\n      url: docsUrl('no-invalid-html-attribute'),\n    },\n    messages,\n    schema: [{\n      type: 'array',\n      uniqueItems: true,\n      items: {\n        enum: ['rel'],\n      },\n    }],\n    type: 'suggestion',\n    hasSuggestions: true, // eslint-disable-line eslint-plugin/require-meta-has-suggestions\n  },\n\n  create(context) {\n    return {\n      JSXAttribute(node) {\n        const attributes = new Set(context.options[0] || DEFAULT_ATTRIBUTES);\n\n        // ignore attributes that aren't configured to be checked\n        if (!attributes.has(node.name.name)) {\n          return;\n        }\n\n        // ignore non-HTML elements\n        if (!HTML_ELEMENTS.has(node.parent.name.name)) {\n          return;\n        }\n\n        checkAttribute(context, node);\n      },\n\n      CallExpression(node) {\n        if (!isValidCreateElement(node)) {\n          return;\n        }\n\n        const elemNameArg = node.arguments[0];\n\n        if (!elemNameArg || elemNameArg.type !== 'Literal') {\n          return; // can only check literals\n        }\n\n        // ignore non-HTML elements\n        if (typeof elemNameArg.value === 'string' && !HTML_ELEMENTS.has(elemNameArg.value)) {\n          return;\n        }\n\n        const attributes = new Set(context.options[0] || DEFAULT_ATTRIBUTES);\n\n        attributes.forEach((attribute) => {\n          checkCreateProps(context, node, attribute);\n        });\n      },\n    };\n  },\n};\n"
        }
    ]
}