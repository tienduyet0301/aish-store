{
    "sourceFile": "node_modules/eslint-plugin-react/lib/rules/jsx-wrap-multilines.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892273014,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Prevent missing parentheses around multilines JSX\n * @author Yannick Croissant\n */\n\n'use strict';\n\nconst has = require('hasown');\nconst docsUrl = require('../util/docsUrl');\nconst eslintUtil = require('../util/eslint');\nconst jsxUtil = require('../util/jsx');\nconst reportC = require('../util/report');\nconst isParenthesized = require('../util/ast').isParenthesized;\n\nconst getSourceCode = eslintUtil.getSourceCode;\nconst getText = eslintUtil.getText;\n\n// ------------------------------------------------------------------------------\n// Constants\n// ------------------------------------------------------------------------------\n\nconst DEFAULTS = {\n  declaration: 'parens',\n  assignment: 'parens',\n  return: 'parens',\n  arrow: 'parens',\n  condition: 'ignore',\n  logical: 'ignore',\n  prop: 'ignore',\n};\n\n// ------------------------------------------------------------------------------\n// Rule Definition\n// ------------------------------------------------------------------------------\n\nconst messages = {\n  missingParens: 'Missing parentheses around multilines JSX',\n  extraParens: 'Expected no parentheses around multilines JSX',\n  parensOnNewLines: 'Parentheses around JSX should be on separate lines',\n};\n\n/** @type {import('eslint').Rule.RuleModule} */\nmodule.exports = {\n  meta: {\n    docs: {\n      description: 'Disallow missing parentheses around multiline JSX',\n      category: 'Stylistic Issues',\n      recommended: false,\n      url: docsUrl('jsx-wrap-multilines'),\n    },\n    fixable: 'code',\n\n    messages,\n\n    schema: [{\n      type: 'object',\n      // true/false are for backwards compatibility\n      properties: {\n        declaration: {\n          enum: [true, false, 'ignore', 'parens', 'parens-new-line', 'never'],\n        },\n        assignment: {\n          enum: [true, false, 'ignore', 'parens', 'parens-new-line', 'never'],\n        },\n        return: {\n          enum: [true, false, 'ignore', 'parens', 'parens-new-line', 'never'],\n        },\n        arrow: {\n          enum: [true, false, 'ignore', 'parens', 'parens-new-line', 'never'],\n        },\n        condition: {\n          enum: [true, false, 'ignore', 'parens', 'parens-new-line', 'never'],\n        },\n        logical: {\n          enum: [true, false, 'ignore', 'parens', 'parens-new-line', 'never'],\n        },\n        prop: {\n          enum: [true, false, 'ignore', 'parens', 'parens-new-line', 'never'],\n        },\n      },\n      additionalProperties: false,\n    }],\n  },\n\n  create(context) {\n    function getOption(type) {\n      const userOptions = context.options[0] || {};\n      if (has(userOptions, type)) {\n        return userOptions[type];\n      }\n      return DEFAULTS[type];\n    }\n\n    function isEnabled(type) {\n      const option = getOption(type);\n      return option && option !== 'ignore';\n    }\n\n    function needsOpeningNewLine(node) {\n      const previousToken = getSourceCode(context).getTokenBefore(node);\n\n      if (!isParenthesized(context, node)) {\n        return false;\n      }\n\n      if (previousToken.loc.end.line === node.loc.start.line) {\n        return true;\n      }\n\n      return false;\n    }\n\n    function needsClosingNewLine(node) {\n      const nextToken = getSourceCode(context).getTokenAfter(node);\n\n      if (!isParenthesized(context, node)) {\n        return false;\n      }\n\n      if (node.loc.end.line === nextToken.loc.end.line) {\n        return true;\n      }\n\n      return false;\n    }\n\n    function isMultilines(node) {\n      return node.loc.start.line !== node.loc.end.line;\n    }\n\n    function report(node, messageId, fix) {\n      reportC(context, messages[messageId], messageId, {\n        node,\n        fix,\n      });\n    }\n\n    function trimTokenBeforeNewline(node, tokenBefore) {\n      // if the token before the jsx is a bracket or curly brace\n      // we don't want a space between the opening parentheses and the multiline jsx\n      const isBracket = tokenBefore.value === '{' || tokenBefore.value === '[';\n      return `${tokenBefore.value.trim()}${isBracket ? '' : ' '}`;\n    }\n\n    function check(node, type) {\n      if (!node || !jsxUtil.isJSX(node)) {\n        return;\n      }\n\n      const sourceCode = getSourceCode(context);\n      const option = getOption(type);\n\n      if ((option === true || option === 'parens') && !isParenthesized(context, node) && isMultilines(node)) {\n        report(node, 'missingParens', (fixer) => fixer.replaceText(node, `(${getText(context, node)})`));\n      }\n\n      if (option === 'parens-new-line' && isMultilines(node)) {\n        if (!isParenthesized(context, node)) {\n          const tokenBefore = sourceCode.getTokenBefore(node, { includeComments: true });\n          const tokenAfter = sourceCode.getTokenAfter(node, { includeComments: true });\n          const start = node.loc.start;\n          if (tokenBefore.loc.end.line < start.line) {\n            // Strip newline after operator if parens newline is specified\n            report(\n              node,\n              'missingParens',\n              (fixer) => fixer.replaceTextRange(\n                [tokenBefore.range[0], tokenAfter && (tokenAfter.value === ';' || tokenAfter.value === '}') ? tokenAfter.range[0] : node.range[1]],\n                `${trimTokenBeforeNewline(node, tokenBefore)}(\\n${start.column > 0 ? ' '.repeat(start.column) : ''}${getText(context, node)}\\n${start.column > 0 ? ' '.repeat(start.column - 2) : ''})`\n              )\n            );\n          } else {\n            report(node, 'missingParens', (fixer) => fixer.replaceText(node, `(\\n${getText(context, node)}\\n)`));\n          }\n        } else {\n          const needsOpening = needsOpeningNewLine(node);\n          const needsClosing = needsClosingNewLine(node);\n          if (needsOpening || needsClosing) {\n            report(node, 'parensOnNewLines', (fixer) => {\n              const text = getText(context, node);\n              let fixed = text;\n              if (needsOpening) {\n                fixed = `\\n${fixed}`;\n              }\n              if (needsClosing) {\n                fixed = `${fixed}\\n`;\n              }\n              return fixer.replaceText(node, fixed);\n            });\n          }\n        }\n      }\n\n      if (option === 'never' && isParenthesized(context, node)) {\n        const tokenBefore = sourceCode.getTokenBefore(node);\n        const tokenAfter = sourceCode.getTokenAfter(node);\n        report(node, 'extraParens', (fixer) => fixer.replaceTextRange(\n          [tokenBefore.range[0], tokenAfter.range[1]],\n          getText(context, node)\n        ));\n      }\n    }\n\n    // --------------------------------------------------------------------------\n    // Public\n    // --------------------------------------------------------------------------\n\n    return {\n\n      VariableDeclarator(node) {\n        const type = 'declaration';\n        if (!isEnabled(type)) {\n          return;\n        }\n        if (!isEnabled('condition') && node.init && node.init.type === 'ConditionalExpression') {\n          check(node.init.consequent, type);\n          check(node.init.alternate, type);\n          return;\n        }\n        check(node.init, type);\n      },\n\n      AssignmentExpression(node) {\n        const type = 'assignment';\n        if (!isEnabled(type)) {\n          return;\n        }\n        if (!isEnabled('condition') && node.right.type === 'ConditionalExpression') {\n          check(node.right.consequent, type);\n          check(node.right.alternate, type);\n          return;\n        }\n        check(node.right, type);\n      },\n\n      ReturnStatement(node) {\n        const type = 'return';\n        if (isEnabled(type)) {\n          check(node.argument, type);\n        }\n      },\n\n      'ArrowFunctionExpression:exit': (node) => {\n        const arrowBody = node.body;\n        const type = 'arrow';\n\n        if (isEnabled(type) && arrowBody.type !== 'BlockStatement') {\n          check(arrowBody, type);\n        }\n      },\n\n      ConditionalExpression(node) {\n        const type = 'condition';\n        if (isEnabled(type)) {\n          check(node.consequent, type);\n          check(node.alternate, type);\n        }\n      },\n\n      LogicalExpression(node) {\n        const type = 'logical';\n        if (isEnabled(type)) {\n          check(node.right, type);\n        }\n      },\n\n      JSXAttribute(node) {\n        const type = 'prop';\n        if (isEnabled(type) && node.value && node.value.type === 'JSXExpressionContainer') {\n          check(node.value.expression, type);\n        }\n      },\n    };\n  },\n};\n"
        }
    ]
}