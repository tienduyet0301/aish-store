{
    "sourceFile": "node_modules/eslint-plugin-react/lib/rules/sort-prop-types.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892277589,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Enforce propTypes declarations alphabetical sorting\n */\n\n'use strict';\n\nconst astUtil = require('../util/ast');\nconst variableUtil = require('../util/variable');\nconst propsUtil = require('../util/props');\nconst docsUrl = require('../util/docsUrl');\nconst propWrapperUtil = require('../util/propWrapper');\nconst propTypesSortUtil = require('../util/propTypesSort');\nconst report = require('../util/report');\nconst eslintUtil = require('../util/eslint');\n\nconst getSourceCode = eslintUtil.getSourceCode;\nconst getText = eslintUtil.getText;\n\n// ------------------------------------------------------------------------------\n// Rule Definition\n// ------------------------------------------------------------------------------\n\nconst messages = {\n  requiredPropsFirst: 'Required prop types must be listed before all other prop types',\n  callbackPropsLast: 'Callback prop types must be listed after all other prop types',\n  propsNotSorted: 'Prop types declarations should be sorted alphabetically',\n};\n\nfunction getKey(context, node) {\n  if (node.type === 'ObjectTypeProperty') {\n    return getSourceCode(context).getFirstToken(node).value;\n  }\n  if (node.key && node.key.value) {\n    return node.key.value;\n  }\n  return getText(context, node.key || node.argument);\n}\n\n/** @type {import('eslint').Rule.RuleModule} */\nmodule.exports = {\n  meta: {\n    docs: {\n      description: 'Enforce propTypes declarations alphabetical sorting',\n      category: 'Stylistic Issues',\n      recommended: false,\n      url: docsUrl('sort-prop-types'),\n    },\n    fixable: 'code',\n\n    messages,\n\n    schema: [{\n      type: 'object',\n      properties: {\n        requiredFirst: {\n          type: 'boolean',\n        },\n        callbacksLast: {\n          type: 'boolean',\n        },\n        ignoreCase: {\n          type: 'boolean',\n        },\n        // Whether alphabetical sorting should be enforced\n        noSortAlphabetically: {\n          type: 'boolean',\n        },\n        sortShapeProp: {\n          type: 'boolean',\n        },\n        checkTypes: {\n          type: 'boolean',\n        },\n      },\n      additionalProperties: false,\n    }],\n  },\n\n  create(context) {\n    const configuration = context.options[0] || {};\n    const requiredFirst = configuration.requiredFirst || false;\n    const callbacksLast = configuration.callbacksLast || false;\n    const ignoreCase = configuration.ignoreCase || false;\n    const noSortAlphabetically = configuration.noSortAlphabetically || false;\n    const sortShapeProp = configuration.sortShapeProp || false;\n    const checkTypes = configuration.checkTypes || false;\n\n    const typeAnnotations = new Map();\n\n    /**\n     * Checks if propTypes declarations are sorted\n     * @param {Array} declarations The array of AST nodes being checked.\n     * @returns {void}\n     */\n    function checkSorted(declarations) {\n      // Declarations will be `undefined` if the `shape` is not a literal. For\n      // example, if it is a propType imported from another file.\n      if (!declarations) {\n        return;\n      }\n\n      function fix(fixer) {\n        return propTypesSortUtil.fixPropTypesSort(\n          context,\n          fixer,\n          declarations,\n          ignoreCase,\n          requiredFirst,\n          callbacksLast,\n          noSortAlphabetically,\n          sortShapeProp,\n          checkTypes\n        );\n      }\n\n      const callbackPropsLastSeen = new WeakSet();\n      const requiredPropsFirstSeen = new WeakSet();\n      const propsNotSortedSeen = new WeakSet();\n\n      declarations.reduce((prev, curr, idx, decls) => {\n        if (curr.type === 'ExperimentalSpreadProperty' || curr.type === 'SpreadElement') {\n          return decls[idx + 1];\n        }\n\n        let prevPropName = getKey(context, prev);\n        let currentPropName = getKey(context, curr);\n        const previousIsRequired = propTypesSortUtil.isRequiredProp(prev);\n        const currentIsRequired = propTypesSortUtil.isRequiredProp(curr);\n        const previousIsCallback = propTypesSortUtil.isCallbackPropName(prevPropName);\n        const currentIsCallback = propTypesSortUtil.isCallbackPropName(currentPropName);\n\n        if (ignoreCase) {\n          prevPropName = String(prevPropName).toLowerCase();\n          currentPropName = String(currentPropName).toLowerCase();\n        }\n\n        if (requiredFirst) {\n          if (previousIsRequired && !currentIsRequired) {\n            // Transition between required and non-required. Don't compare for alphabetical.\n            return curr;\n          }\n          if (!previousIsRequired && currentIsRequired) {\n            // Encountered a non-required prop after a required prop\n            if (!requiredPropsFirstSeen.has(curr)) {\n              requiredPropsFirstSeen.add(curr);\n              report(context, messages.requiredPropsFirst, 'requiredPropsFirst', {\n                node: curr,\n                fix,\n              });\n            }\n            return curr;\n          }\n        }\n\n        if (callbacksLast) {\n          if (!previousIsCallback && currentIsCallback) {\n            // Entering the callback prop section\n            return curr;\n          }\n          if (previousIsCallback && !currentIsCallback) {\n            // Encountered a non-callback prop after a callback prop\n            if (!callbackPropsLastSeen.has(prev)) {\n              callbackPropsLastSeen.add(prev);\n              report(context, messages.callbackPropsLast, 'callbackPropsLast', {\n                node: prev,\n                fix,\n              });\n            }\n            return prev;\n          }\n        }\n\n        if (!noSortAlphabetically && currentPropName < prevPropName) {\n          if (!propsNotSortedSeen.has(curr)) {\n            propsNotSortedSeen.add(curr);\n            report(context, messages.propsNotSorted, 'propsNotSorted', {\n              node: curr,\n              fix,\n            });\n          }\n          return prev;\n        }\n\n        return curr;\n      }, declarations[0]);\n    }\n\n    function checkNode(node) {\n      if (!node) {\n        return;\n      }\n\n      if (node.type === 'ObjectExpression') {\n        checkSorted(node.properties);\n      } else if (node.type === 'Identifier') {\n        const propTypesObject = variableUtil.findVariableByName(context, node, node.name);\n        if (propTypesObject && propTypesObject.properties) {\n          checkSorted(propTypesObject.properties);\n        }\n      } else if (astUtil.isCallExpression(node)) {\n        const innerNode = node.arguments && node.arguments[0];\n        if (propWrapperUtil.isPropWrapperFunction(context, node.callee.name) && innerNode) {\n          checkNode(innerNode);\n        }\n      }\n    }\n\n    function handleFunctionComponent(node) {\n      const firstArg = node.params\n        && node.params.length > 0\n        && node.params[0].typeAnnotation\n        && node.params[0].typeAnnotation.typeAnnotation;\n      if (firstArg && firstArg.type === 'TSTypeReference') {\n        const propType = typeAnnotations.get(firstArg.typeName.name)\n          && typeAnnotations.get(firstArg.typeName.name)[0];\n        if (propType && propType.members) {\n          checkSorted(propType.members);\n        }\n      } else if (firstArg && firstArg.type === 'TSTypeLiteral') {\n        if (firstArg.members) {\n          checkSorted(firstArg.members);\n        }\n      } else if (firstArg && firstArg.type === 'GenericTypeAnnotation') {\n        const propType = typeAnnotations.get(firstArg.id.name)\n          && typeAnnotations.get(firstArg.id.name)[0];\n        if (propType && propType.properties) {\n          checkSorted(propType.properties);\n        }\n      } else if (firstArg && firstArg.type === 'ObjectTypeAnnotation') {\n        if (firstArg.properties) {\n          checkSorted(firstArg.properties);\n        }\n      }\n    }\n\n    return Object.assign({\n      CallExpression(node) {\n        if (!sortShapeProp || !propTypesSortUtil.isShapeProp(node) || !(node.arguments && node.arguments[0])) {\n          return;\n        }\n\n        const firstArg = node.arguments[0];\n        if (firstArg.properties) {\n          checkSorted(firstArg.properties);\n        } else if (firstArg.type === 'Identifier') {\n          const variable = variableUtil.findVariableByName(context, node, firstArg.name);\n          if (variable && variable.properties) {\n            checkSorted(variable.properties);\n          }\n        }\n      },\n\n      'ClassProperty, PropertyDefinition'(node) {\n        if (!propsUtil.isPropTypesDeclaration(node)) {\n          return;\n        }\n        checkNode(node.value);\n      },\n\n      MemberExpression(node) {\n        if (!propsUtil.isPropTypesDeclaration(node)) {\n          return;\n        }\n\n        checkNode(node.parent.right);\n      },\n\n      ObjectExpression(node) {\n        node.properties.forEach((property) => {\n          if (!property.key) {\n            return;\n          }\n\n          if (!propsUtil.isPropTypesDeclaration(property)) {\n            return;\n          }\n          if (property.value.type === 'ObjectExpression') {\n            checkSorted(property.value.properties);\n          }\n        });\n      },\n    }, checkTypes ? {\n      TSTypeLiteral(node) {\n        if (node && node.parent.id) {\n          const currentNode = [].concat(\n            typeAnnotations.get(node.parent.id.name) || [],\n            node\n          );\n          typeAnnotations.set(node.parent.id.name, currentNode);\n        }\n      },\n\n      TypeAlias(node) {\n        if (node.right.type === 'ObjectTypeAnnotation') {\n          const currentNode = [].concat(\n            typeAnnotations.get(node.id.name) || [],\n            node.right\n          );\n          typeAnnotations.set(node.id.name, currentNode);\n        }\n      },\n\n      TSTypeAliasDeclaration(node) {\n        if (node.typeAnnotation.type === 'TSTypeLiteral' || node.typeAnnotation.type === 'ObjectTypeAnnotation') {\n          const currentNode = [].concat(\n            typeAnnotations.get(node.id.name) || [],\n            node.typeAnnotation\n          );\n          typeAnnotations.set(node.id.name, currentNode);\n        }\n      },\n      FunctionDeclaration: handleFunctionComponent,\n      ArrowFunctionExpression: handleFunctionComponent,\n    } : null);\n  },\n};\n"
        }
    ]
}