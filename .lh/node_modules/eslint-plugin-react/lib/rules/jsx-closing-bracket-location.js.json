{
    "sourceFile": "node_modules/eslint-plugin-react/lib/rules/jsx-closing-bracket-location.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892268370,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Validate closing bracket location in JSX\n * @author Yannick Croissant\n */\n\n'use strict';\n\nconst has = require('hasown');\nconst repeat = require('string.prototype.repeat');\n\nconst docsUrl = require('../util/docsUrl');\nconst getSourceCode = require('../util/eslint').getSourceCode;\nconst report = require('../util/report');\n\n// ------------------------------------------------------------------------------\n// Rule Definition\n// ------------------------------------------------------------------------------\n\nconst messages = {\n  bracketLocation: 'The closing bracket must be {{location}}{{details}}',\n};\n\n/** @type {import('eslint').Rule.RuleModule} */\nmodule.exports = {\n  meta: {\n    docs: {\n      description: 'Enforce closing bracket location in JSX',\n      category: 'Stylistic Issues',\n      recommended: false,\n      url: docsUrl('jsx-closing-bracket-location'),\n    },\n    fixable: 'code',\n\n    messages,\n\n    schema: [{\n      anyOf: [\n        {\n          enum: ['after-props', 'props-aligned', 'tag-aligned', 'line-aligned'],\n        },\n        {\n          type: 'object',\n          properties: {\n            location: {\n              enum: ['after-props', 'props-aligned', 'tag-aligned', 'line-aligned'],\n            },\n          },\n          additionalProperties: false,\n        }, {\n          type: 'object',\n          properties: {\n            nonEmpty: {\n              enum: ['after-props', 'props-aligned', 'tag-aligned', 'line-aligned', false],\n            },\n            selfClosing: {\n              enum: ['after-props', 'props-aligned', 'tag-aligned', 'line-aligned', false],\n            },\n          },\n          additionalProperties: false,\n        },\n      ],\n    }],\n  },\n\n  create(context) {\n    const MESSAGE_LOCATION = {\n      'after-props': 'placed after the last prop',\n      'after-tag': 'placed after the opening tag',\n      'props-aligned': 'aligned with the last prop',\n      'tag-aligned': 'aligned with the opening tag',\n      'line-aligned': 'aligned with the line containing the opening tag',\n    };\n    const DEFAULT_LOCATION = 'tag-aligned';\n\n    const config = context.options[0];\n    const options = {\n      nonEmpty: DEFAULT_LOCATION,\n      selfClosing: DEFAULT_LOCATION,\n    };\n\n    if (typeof config === 'string') {\n      // simple shorthand [1, 'something']\n      options.nonEmpty = config;\n      options.selfClosing = config;\n    } else if (typeof config === 'object') {\n      // [1, {location: 'something'}] (back-compat)\n      if (has(config, 'location')) {\n        options.nonEmpty = config.location;\n        options.selfClosing = config.location;\n      }\n      // [1, {nonEmpty: 'something'}]\n      if (has(config, 'nonEmpty')) {\n        options.nonEmpty = config.nonEmpty;\n      }\n      // [1, {selfClosing: 'something'}]\n      if (has(config, 'selfClosing')) {\n        options.selfClosing = config.selfClosing;\n      }\n    }\n\n    /**\n     * Get expected location for the closing bracket\n     * @param {Object} tokens Locations of the opening bracket, closing bracket and last prop\n     * @return {string} Expected location for the closing bracket\n     */\n    function getExpectedLocation(tokens) {\n      let location;\n      // Is always after the opening tag if there is no props\n      if (typeof tokens.lastProp === 'undefined') {\n        location = 'after-tag';\n      // Is always after the last prop if this one is on the same line as the opening bracket\n      } else if (tokens.opening.line === tokens.lastProp.lastLine) {\n        location = 'after-props';\n      // Else use configuration dependent on selfClosing property\n      } else {\n        location = tokens.selfClosing ? options.selfClosing : options.nonEmpty;\n      }\n      return location;\n    }\n\n    /**\n     * Get the correct 0-indexed column for the closing bracket, given the\n     * expected location.\n     * @param {Object} tokens Locations of the opening bracket, closing bracket and last prop\n     * @param {string} expectedLocation Expected location for the closing bracket\n     * @return {?Number} The correct column for the closing bracket, or null\n     */\n    function getCorrectColumn(tokens, expectedLocation) {\n      switch (expectedLocation) {\n        case 'props-aligned':\n          return tokens.lastProp.column;\n        case 'tag-aligned':\n          return tokens.opening.column;\n        case 'line-aligned':\n          return tokens.openingStartOfLine.column;\n        default:\n          return null;\n      }\n    }\n\n    /**\n     * Check if the closing bracket is correctly located\n     * @param {Object} tokens Locations of the opening bracket, closing bracket and last prop\n     * @param {string} expectedLocation Expected location for the closing bracket\n     * @return {boolean} True if the closing bracket is correctly located, false if not\n     */\n    function hasCorrectLocation(tokens, expectedLocation) {\n      switch (expectedLocation) {\n        case 'after-tag':\n          return tokens.tag.line === tokens.closing.line;\n        case 'after-props':\n          return tokens.lastProp.lastLine === tokens.closing.line;\n        case 'props-aligned':\n        case 'tag-aligned':\n        case 'line-aligned': {\n          const correctColumn = getCorrectColumn(tokens, expectedLocation);\n          return correctColumn === tokens.closing.column;\n        }\n        default:\n          return true;\n      }\n    }\n\n    /**\n     * Get the characters used for indentation on the line to be matched\n     * @param {Object} tokens Locations of the opening bracket, closing bracket and last prop\n     * @param {string} expectedLocation Expected location for the closing bracket\n     * @param {number} [correctColumn] Expected column for the closing bracket. Default to 0\n     * @return {string} The characters used for indentation\n     */\n    function getIndentation(tokens, expectedLocation, correctColumn) {\n      const newColumn = correctColumn || 0;\n      let indentation;\n      let spaces = '';\n      switch (expectedLocation) {\n        case 'props-aligned':\n          indentation = /^\\s*/.exec(getSourceCode(context).lines[tokens.lastProp.firstLine - 1])[0];\n          break;\n        case 'tag-aligned':\n        case 'line-aligned':\n          indentation = /^\\s*/.exec(getSourceCode(context).lines[tokens.opening.line - 1])[0];\n          break;\n        default:\n          indentation = '';\n      }\n      if (indentation.length + 1 < newColumn) {\n        // Non-whitespace characters were included in the column offset\n        spaces = repeat(' ', +correctColumn - indentation.length);\n      }\n      return indentation + spaces;\n    }\n\n    /**\n     * Get the locations of the opening bracket, closing bracket, last prop, and\n     * start of opening line.\n     * @param {ASTNode} node The node to check\n     * @return {Object} Locations of the opening bracket, closing bracket, last\n     * prop and start of opening line.\n     */\n    function getTokensLocations(node) {\n      const sourceCode = getSourceCode(context);\n      const opening = sourceCode.getFirstToken(node).loc.start;\n      const closing = sourceCode.getLastTokens(node, node.selfClosing ? 2 : 1)[0].loc.start;\n      const tag = sourceCode.getFirstToken(node.name).loc.start;\n      let lastProp;\n      if (node.attributes.length) {\n        lastProp = node.attributes[node.attributes.length - 1];\n        lastProp = {\n          column: sourceCode.getFirstToken(lastProp).loc.start.column,\n          firstLine: sourceCode.getFirstToken(lastProp).loc.start.line,\n          lastLine: sourceCode.getLastToken(lastProp).loc.end.line,\n        };\n      }\n      const openingLine = sourceCode.lines[opening.line - 1];\n      const closingLine = sourceCode.lines[closing.line - 1];\n      const isTab = {\n        openTab: /^\\t/.test(openingLine),\n        closeTab: /^\\t/.test(closingLine),\n      };\n      const openingStartOfLine = {\n        column: /^\\s*/.exec(openingLine)[0].length,\n        line: opening.line,\n      };\n      return {\n        isTab,\n        tag,\n        opening,\n        closing,\n        lastProp,\n        selfClosing: node.selfClosing,\n        openingStartOfLine,\n      };\n    }\n\n    /**\n     * Get an unique ID for a given JSXOpeningElement\n     *\n     * @param {ASTNode} node The AST node being checked.\n     * @returns {string} Unique ID (based on its range)\n     */\n    function getOpeningElementId(node) {\n      return node.range.join(':');\n    }\n\n    const lastAttributeNode = {};\n\n    return {\n      JSXAttribute(node) {\n        lastAttributeNode[getOpeningElementId(node.parent)] = node;\n      },\n\n      JSXSpreadAttribute(node) {\n        lastAttributeNode[getOpeningElementId(node.parent)] = node;\n      },\n\n      'JSXOpeningElement:exit'(node) {\n        const attributeNode = lastAttributeNode[getOpeningElementId(node)];\n        const cachedLastAttributeEndPos = attributeNode ? attributeNode.range[1] : null;\n\n        let expectedNextLine;\n        const tokens = getTokensLocations(node);\n        const expectedLocation = getExpectedLocation(tokens);\n        let usingSameIndentation = true;\n\n        if (expectedLocation === 'tag-aligned') {\n          usingSameIndentation = tokens.isTab.openTab === tokens.isTab.closeTab;\n        }\n\n        if (hasCorrectLocation(tokens, expectedLocation) && usingSameIndentation) {\n          return;\n        }\n\n        const data = {\n          location: MESSAGE_LOCATION[expectedLocation],\n          details: '',\n        };\n        const correctColumn = getCorrectColumn(tokens, expectedLocation);\n\n        if (correctColumn !== null) {\n          expectedNextLine = tokens.lastProp\n            && (tokens.lastProp.lastLine === tokens.closing.line);\n          data.details = ` (expected column ${correctColumn + 1}${expectedNextLine ? ' on the next line)' : ')'}`;\n        }\n\n        report(context, messages.bracketLocation, 'bracketLocation', {\n          node,\n          loc: tokens.closing,\n          data,\n          fix(fixer) {\n            const closingTag = tokens.selfClosing ? '/>' : '>';\n            switch (expectedLocation) {\n              case 'after-tag':\n                if (cachedLastAttributeEndPos) {\n                  return fixer.replaceTextRange([cachedLastAttributeEndPos, node.range[1]],\n                    (expectedNextLine ? '\\n' : '') + closingTag);\n                }\n                return fixer.replaceTextRange([node.name.range[1], node.range[1]],\n                  (expectedNextLine ? '\\n' : ' ') + closingTag);\n              case 'after-props':\n                return fixer.replaceTextRange([cachedLastAttributeEndPos, node.range[1]],\n                  (expectedNextLine ? '\\n' : '') + closingTag);\n              case 'props-aligned':\n              case 'tag-aligned':\n              case 'line-aligned':\n                return fixer.replaceTextRange([cachedLastAttributeEndPos, node.range[1]],\n                  `\\n${getIndentation(tokens, expectedLocation, correctColumn)}${closingTag}`);\n              default:\n                return true;\n            }\n          },\n        });\n      },\n    };\n  },\n};\n"
        }
    ]
}