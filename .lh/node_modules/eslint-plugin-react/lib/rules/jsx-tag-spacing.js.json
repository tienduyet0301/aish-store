{
    "sourceFile": "node_modules/eslint-plugin-react/lib/rules/jsx-tag-spacing.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892272777,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Validates whitespace in and around the JSX opening and closing brackets\n * @author Diogo Franco (Kovensky)\n */\n\n'use strict';\n\nconst getTokenBeforeClosingBracket = require('../util/getTokenBeforeClosingBracket');\nconst docsUrl = require('../util/docsUrl');\nconst report = require('../util/report');\nconst eslintUtil = require('../util/eslint');\n\nconst getFirstTokens = eslintUtil.getFirstTokens;\nconst getSourceCode = eslintUtil.getSourceCode;\n\nconst messages = {\n  selfCloseSlashNoSpace: 'Whitespace is forbidden between `/` and `>`; write `/>`',\n  selfCloseSlashNeedSpace: 'Whitespace is required between `/` and `>`; write `/ >`',\n  closeSlashNoSpace: 'Whitespace is forbidden between `<` and `/`; write `</`',\n  closeSlashNeedSpace: 'Whitespace is required between `<` and `/`; write `< /`',\n  beforeSelfCloseNoSpace: 'A space is forbidden before closing bracket',\n  beforeSelfCloseNeedSpace: 'A space is required before closing bracket',\n  beforeSelfCloseNeedNewline: 'A newline is required before closing bracket',\n  afterOpenNoSpace: 'A space is forbidden after opening bracket',\n  afterOpenNeedSpace: 'A space is required after opening bracket',\n  beforeCloseNoSpace: 'A space is forbidden before closing bracket',\n  beforeCloseNeedSpace: 'Whitespace is required before closing bracket',\n  beforeCloseNeedNewline: 'A newline is required before closing bracket',\n};\n\n// ------------------------------------------------------------------------------\n// Validators\n// ------------------------------------------------------------------------------\n\nfunction validateClosingSlash(context, node, option) {\n  const sourceCode = getSourceCode(context);\n\n  let adjacent;\n\n  if (node.selfClosing) {\n    const lastTokens = sourceCode.getLastTokens(node, 2);\n\n    adjacent = !sourceCode.isSpaceBetweenTokens(lastTokens[0], lastTokens[1]);\n\n    if (option === 'never') {\n      if (!adjacent) {\n        report(context, messages.selfCloseSlashNoSpace, 'selfCloseSlashNoSpace', {\n          node,\n          loc: {\n            start: lastTokens[0].loc.start,\n            end: lastTokens[1].loc.end,\n          },\n          fix(fixer) {\n            return fixer.removeRange([lastTokens[0].range[1], lastTokens[1].range[0]]);\n          },\n        });\n      }\n    } else if (option === 'always' && adjacent) {\n      report(context, messages.selfCloseSlashNeedSpace, 'selfCloseSlashNeedSpace', {\n        node,\n        loc: {\n          start: lastTokens[0].loc.start,\n          end: lastTokens[1].loc.end,\n        },\n        fix(fixer) {\n          return fixer.insertTextBefore(lastTokens[1], ' ');\n        },\n      });\n    }\n  } else {\n    const firstTokens = getFirstTokens(context, node, 2);\n\n    adjacent = !sourceCode.isSpaceBetweenTokens(firstTokens[0], firstTokens[1]);\n\n    if (option === 'never') {\n      if (!adjacent) {\n        report(context, messages.closeSlashNoSpace, 'closeSlashNoSpace', {\n          node,\n          loc: {\n            start: firstTokens[0].loc.start,\n            end: firstTokens[1].loc.end,\n          },\n          fix(fixer) {\n            return fixer.removeRange([firstTokens[0].range[1], firstTokens[1].range[0]]);\n          },\n        });\n      }\n    } else if (option === 'always' && adjacent) {\n      report(context, messages.closeSlashNeedSpace, 'closeSlashNeedSpace', {\n        node,\n        loc: {\n          start: firstTokens[0].loc.start,\n          end: firstTokens[1].loc.end,\n        },\n        fix(fixer) {\n          return fixer.insertTextBefore(firstTokens[1], ' ');\n        },\n      });\n    }\n  }\n}\n\nfunction validateBeforeSelfClosing(context, node, option) {\n  const sourceCode = getSourceCode(context);\n  const leftToken = getTokenBeforeClosingBracket(node);\n  const closingSlash = sourceCode.getTokenAfter(leftToken);\n\n  if (node.loc.start.line !== node.loc.end.line && option === 'proportional-always') {\n    if (leftToken.loc.end.line === closingSlash.loc.start.line) {\n      report(context, messages.beforeSelfCloseNeedNewline, 'beforeSelfCloseNeedNewline', {\n        node,\n        loc: leftToken.loc.end,\n        fix(fixer) {\n          return fixer.insertTextBefore(closingSlash, '\\n');\n        },\n      });\n      return;\n    }\n  }\n\n  if (leftToken.loc.end.line !== closingSlash.loc.start.line) {\n    return;\n  }\n\n  const adjacent = !sourceCode.isSpaceBetweenTokens(leftToken, closingSlash);\n\n  if ((option === 'always' || option === 'proportional-always') && adjacent) {\n    report(context, messages.beforeSelfCloseNeedSpace, 'beforeSelfCloseNeedSpace', {\n      node,\n      loc: closingSlash.loc.start,\n      fix(fixer) {\n        return fixer.insertTextBefore(closingSlash, ' ');\n      },\n    });\n  } else if (option === 'never' && !adjacent) {\n    report(context, messages.beforeSelfCloseNoSpace, 'beforeSelfCloseNoSpace', {\n      node,\n      loc: closingSlash.loc.start,\n      fix(fixer) {\n        const previousToken = sourceCode.getTokenBefore(closingSlash);\n        return fixer.removeRange([previousToken.range[1], closingSlash.range[0]]);\n      },\n    });\n  }\n}\n\nfunction validateAfterOpening(context, node, option) {\n  const sourceCode = getSourceCode(context);\n  const openingToken = sourceCode.getTokenBefore(node.name);\n\n  if (option === 'allow-multiline') {\n    if (openingToken.loc.start.line !== node.name.loc.start.line) {\n      return;\n    }\n  }\n\n  const adjacent = !sourceCode.isSpaceBetweenTokens(openingToken, node.name);\n\n  if (option === 'never' || option === 'allow-multiline') {\n    if (!adjacent) {\n      report(context, messages.afterOpenNoSpace, 'afterOpenNoSpace', {\n        node,\n        loc: {\n          start: openingToken.loc.start,\n          end: node.name.loc.start,\n        },\n        fix(fixer) {\n          return fixer.removeRange([openingToken.range[1], node.name.range[0]]);\n        },\n      });\n    }\n  } else if (option === 'always' && adjacent) {\n    report(context, messages.afterOpenNeedSpace, 'afterOpenNeedSpace', {\n      node,\n      loc: {\n        start: openingToken.loc.start,\n        end: node.name.loc.start,\n      },\n      fix(fixer) {\n        return fixer.insertTextBefore(node.name, ' ');\n      },\n    });\n  }\n}\n\nfunction validateBeforeClosing(context, node, option) {\n  // Don't enforce this rule for self closing tags\n  if (!node.selfClosing) {\n    const sourceCode = getSourceCode(context);\n    const leftToken = option === 'proportional-always'\n      ? getTokenBeforeClosingBracket(node)\n      : sourceCode.getLastTokens(node, 2)[0];\n    const closingToken = sourceCode.getTokenAfter(leftToken);\n\n    if (node.loc.start.line !== node.loc.end.line && option === 'proportional-always') {\n      if (leftToken.loc.end.line === closingToken.loc.start.line) {\n        report(context, messages.beforeCloseNeedNewline, 'beforeCloseNeedNewline', {\n          node,\n          loc: leftToken.loc.end,\n          fix(fixer) {\n            return fixer.insertTextBefore(closingToken, '\\n');\n          },\n        });\n        return;\n      }\n    }\n\n    if (leftToken.loc.start.line !== closingToken.loc.start.line) {\n      return;\n    }\n\n    const adjacent = !sourceCode.isSpaceBetweenTokens(leftToken, closingToken);\n\n    if (option === 'never' && !adjacent) {\n      report(context, messages.beforeCloseNoSpace, 'beforeCloseNoSpace', {\n        node,\n        loc: {\n          start: leftToken.loc.end,\n          end: closingToken.loc.start,\n        },\n        fix(fixer) {\n          return fixer.removeRange([leftToken.range[1], closingToken.range[0]]);\n        },\n      });\n    } else if (option === 'always' && adjacent) {\n      report(context, messages.beforeCloseNeedSpace, 'beforeCloseNeedSpace', {\n        node,\n        loc: {\n          start: leftToken.loc.end,\n          end: closingToken.loc.start,\n        },\n        fix(fixer) {\n          return fixer.insertTextBefore(closingToken, ' ');\n        },\n      });\n    } else if (option === 'proportional-always' && node.type === 'JSXOpeningElement' && adjacent !== (node.loc.start.line === node.loc.end.line)) {\n      report(context, messages.beforeCloseNeedSpace, 'beforeCloseNeedSpace', {\n        node,\n        loc: {\n          start: leftToken.loc.end,\n          end: closingToken.loc.start,\n        },\n        fix(fixer) {\n          return fixer.insertTextBefore(closingToken, ' ');\n        },\n      });\n    }\n  }\n}\n\n// ------------------------------------------------------------------------------\n// Rule Definition\n// ------------------------------------------------------------------------------\n\nconst optionDefaults = {\n  closingSlash: 'never',\n  beforeSelfClosing: 'always',\n  afterOpening: 'never',\n  beforeClosing: 'allow',\n};\n\n/** @type {import('eslint').Rule.RuleModule} */\nmodule.exports = {\n  meta: {\n    docs: {\n      description: 'Enforce whitespace in and around the JSX opening and closing brackets',\n      category: 'Stylistic Issues',\n      recommended: false,\n      url: docsUrl('jsx-tag-spacing'),\n    },\n    fixable: 'whitespace',\n\n    messages,\n\n    schema: [\n      {\n        type: 'object',\n        properties: {\n          closingSlash: {\n            enum: ['always', 'never', 'allow'],\n          },\n          beforeSelfClosing: {\n            enum: ['always', 'proportional-always', 'never', 'allow'],\n          },\n          afterOpening: {\n            enum: ['always', 'allow-multiline', 'never', 'allow'],\n          },\n          beforeClosing: {\n            enum: ['always', 'proportional-always', 'never', 'allow'],\n          },\n        },\n        default: optionDefaults,\n        additionalProperties: false,\n      },\n    ],\n  },\n  create(context) {\n    const options = Object.assign({}, optionDefaults, context.options[0]);\n\n    return {\n      JSXOpeningElement(node) {\n        if (options.closingSlash !== 'allow' && node.selfClosing) {\n          validateClosingSlash(context, node, options.closingSlash);\n        }\n        if (options.afterOpening !== 'allow') {\n          validateAfterOpening(context, node, options.afterOpening);\n        }\n        if (options.beforeSelfClosing !== 'allow' && node.selfClosing) {\n          validateBeforeSelfClosing(context, node, options.beforeSelfClosing);\n        }\n        if (options.beforeClosing !== 'allow') {\n          validateBeforeClosing(context, node, options.beforeClosing);\n        }\n      },\n      JSXClosingElement(node) {\n        if (options.afterOpening !== 'allow') {\n          validateAfterOpening(context, node, options.afterOpening);\n        }\n        if (options.closingSlash !== 'allow') {\n          validateClosingSlash(context, node, options.closingSlash);\n        }\n        if (options.beforeClosing !== 'allow') {\n          validateBeforeClosing(context, node, options.beforeClosing);\n        }\n      },\n    };\n  },\n};\n"
        }
    ]
}