{
    "sourceFile": "node_modules/eslint-plugin-react/lib/rules/jsx-curly-brace-presence.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892268675,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Enforce curly braces or disallow unnecessary curly brace in JSX\n * @author Jacky Ho\n * @author Simon Lydell\n */\n\n'use strict';\n\nconst arrayIncludes = require('array-includes');\n\nconst docsUrl = require('../util/docsUrl');\nconst jsxUtil = require('../util/jsx');\nconst report = require('../util/report');\nconst eslintUtil = require('../util/eslint');\n\nconst getSourceCode = eslintUtil.getSourceCode;\nconst getText = eslintUtil.getText;\n\n// ------------------------------------------------------------------------------\n// Constants\n// ------------------------------------------------------------------------------\n\nconst OPTION_ALWAYS = 'always';\nconst OPTION_NEVER = 'never';\nconst OPTION_IGNORE = 'ignore';\n\nconst OPTION_VALUES = [\n  OPTION_ALWAYS,\n  OPTION_NEVER,\n  OPTION_IGNORE,\n];\nconst DEFAULT_CONFIG = { props: OPTION_NEVER, children: OPTION_NEVER, propElementValues: OPTION_IGNORE };\n\nconst HTML_ENTITY_REGEX = () => /&[A-Za-z\\d#]+;/g;\n\nfunction containsLineTerminators(rawStringValue) {\n  return /[\\n\\r\\u2028\\u2029]/.test(rawStringValue);\n}\n\nfunction containsBackslash(rawStringValue) {\n  return arrayIncludes(rawStringValue, '\\\\');\n}\n\nfunction containsHTMLEntity(rawStringValue) {\n  return HTML_ENTITY_REGEX().test(rawStringValue);\n}\n\nfunction containsOnlyHtmlEntities(rawStringValue) {\n  return rawStringValue.replace(HTML_ENTITY_REGEX(), '').trim() === '';\n}\n\nfunction containsDisallowedJSXTextChars(rawStringValue) {\n  return /[{<>}]/.test(rawStringValue);\n}\n\nfunction containsQuoteCharacters(value) {\n  return /['\"]/.test(value);\n}\n\nfunction containsMultilineComment(value) {\n  return /\\/\\*/.test(value);\n}\n\nfunction escapeDoubleQuotes(rawStringValue) {\n  return rawStringValue.replace(/\\\\\"/g, '\"').replace(/\"/g, '\\\\\"');\n}\n\nfunction escapeBackslashes(rawStringValue) {\n  return rawStringValue.replace(/\\\\/g, '\\\\\\\\');\n}\n\nfunction needToEscapeCharacterForJSX(raw, node) {\n  return (\n    containsBackslash(raw)\n    || containsHTMLEntity(raw)\n    || (node.parent.type !== 'JSXAttribute' && containsDisallowedJSXTextChars(raw))\n  );\n}\n\nfunction containsWhitespaceExpression(child) {\n  if (child.type === 'JSXExpressionContainer') {\n    const value = child.expression.value;\n    return value ? jsxUtil.isWhiteSpaces(value) : false;\n  }\n  return false;\n}\n\nfunction isLineBreak(text) {\n  return containsLineTerminators(text) && text.trim() === '';\n}\n\nfunction wrapNonHTMLEntities(text) {\n  const HTML_ENTITY = '<HTML_ENTITY>';\n  const withCurlyBraces = text.split(HTML_ENTITY_REGEX()).map((word) => (\n    word === '' ? '' : `{${JSON.stringify(word)}}`\n  )).join(HTML_ENTITY);\n\n  const htmlEntities = text.match(HTML_ENTITY_REGEX());\n  return htmlEntities.reduce((acc, htmlEntity) => (\n    acc.replace(HTML_ENTITY, htmlEntity)\n  ), withCurlyBraces);\n}\n\nfunction wrapWithCurlyBraces(rawText) {\n  if (!containsLineTerminators(rawText)) {\n    return `{${JSON.stringify(rawText)}}`;\n  }\n\n  return rawText.split('\\n').map((line) => {\n    if (line.trim() === '') {\n      return line;\n    }\n    const firstCharIndex = line.search(/[^\\s]/);\n    const leftWhitespace = line.slice(0, firstCharIndex);\n    const text = line.slice(firstCharIndex);\n\n    if (containsHTMLEntity(line)) {\n      return `${leftWhitespace}${wrapNonHTMLEntities(text)}`;\n    }\n    return `${leftWhitespace}{${JSON.stringify(text)}}`;\n  }).join('\\n');\n}\n\nfunction isWhiteSpaceLiteral(node) {\n  return node.type && node.type === 'Literal' && node.value && jsxUtil.isWhiteSpaces(node.value);\n}\n\nfunction isStringWithTrailingWhiteSpaces(value) {\n  return /^\\s|\\s$/.test(value);\n}\n\nfunction isLiteralWithTrailingWhiteSpaces(node) {\n  return node.type && node.type === 'Literal' && node.value && isStringWithTrailingWhiteSpaces(node.value);\n}\n\n// ------------------------------------------------------------------------------\n// Rule Definition\n// ------------------------------------------------------------------------------\n\nconst messages = {\n  unnecessaryCurly: 'Curly braces are unnecessary here.',\n  missingCurly: 'Need to wrap this literal in a JSX expression.',\n};\n\n/** @type {import('eslint').Rule.RuleModule} */\nmodule.exports = {\n  meta: {\n    docs: {\n      description: 'Disallow unnecessary JSX expressions when literals alone are sufficient or enforce JSX expressions on literals in JSX children or attributes',\n      category: 'Stylistic Issues',\n      recommended: false,\n      url: docsUrl('jsx-curly-brace-presence'),\n    },\n    fixable: 'code',\n\n    messages,\n\n    schema: [\n      {\n        anyOf: [\n          {\n            type: 'object',\n            properties: {\n              props: { enum: OPTION_VALUES },\n              children: { enum: OPTION_VALUES },\n              propElementValues: { enum: OPTION_VALUES },\n            },\n            additionalProperties: false,\n          },\n          {\n            enum: OPTION_VALUES,\n          },\n        ],\n      },\n    ],\n  },\n\n  create(context) {\n    const ruleOptions = context.options[0];\n    const userConfig = typeof ruleOptions === 'string'\n      ? { props: ruleOptions, children: ruleOptions, propElementValues: OPTION_IGNORE }\n      : Object.assign({}, DEFAULT_CONFIG, ruleOptions);\n\n    /**\n     * Report and fix an unnecessary curly brace violation on a node\n     * @param {ASTNode} JSXExpressionNode - The AST node with an unnecessary JSX expression\n     */\n    function reportUnnecessaryCurly(JSXExpressionNode) {\n      report(context, messages.unnecessaryCurly, 'unnecessaryCurly', {\n        node: JSXExpressionNode,\n        fix(fixer) {\n          const expression = JSXExpressionNode.expression;\n\n          let textToReplace;\n          if (jsxUtil.isJSX(expression)) {\n            textToReplace = getText(context, expression);\n          } else {\n            const expressionType = expression && expression.type;\n            const parentType = JSXExpressionNode.parent.type;\n\n            if (parentType === 'JSXAttribute') {\n              if (expressionType !== 'TemplateLiteral' && /[\"]/.test(expression.raw.slice(1, -1))) {\n                textToReplace = expression.raw;\n              } else {\n                textToReplace = `\"${expressionType === 'TemplateLiteral'\n                  ? expression.quasis[0].value.raw\n                  : expression.raw.slice(1, -1)\n                }\"`;\n              }\n            } else if (jsxUtil.isJSX(expression)) {\n              textToReplace = getText(context, expression);\n            } else {\n              textToReplace = expressionType === 'TemplateLiteral'\n                ? expression.quasis[0].value.cooked : expression.value;\n            }\n          }\n\n          return fixer.replaceText(JSXExpressionNode, textToReplace);\n        },\n      });\n    }\n\n    function reportMissingCurly(literalNode) {\n      report(context, messages.missingCurly, 'missingCurly', {\n        node: literalNode,\n        fix(fixer) {\n          if (jsxUtil.isJSX(literalNode)) {\n            return fixer.replaceText(literalNode, `{${getText(context, literalNode)}}`);\n          }\n\n          // If a HTML entity name is found, bail out because it can be fixed\n          // by either using the real character or the unicode equivalent.\n          // If it contains any line terminator character, bail out as well.\n          if (\n            containsOnlyHtmlEntities(literalNode.raw)\n            || (literalNode.parent.type === 'JSXAttribute' && containsLineTerminators(literalNode.raw))\n            || isLineBreak(literalNode.raw)\n          ) {\n            return null;\n          }\n\n          const expression = literalNode.parent.type === 'JSXAttribute'\n            ? `{\"${escapeDoubleQuotes(escapeBackslashes(\n              literalNode.raw.slice(1, -1)\n            ))}\"}`\n            : wrapWithCurlyBraces(literalNode.raw);\n\n          return fixer.replaceText(literalNode, expression);\n        },\n      });\n    }\n\n    // Bail out if there is any character that needs to be escaped in JSX\n    // because escaping decreases readability and the original code may be more\n    // readable anyway or intentional for other specific reasons\n    function lintUnnecessaryCurly(JSXExpressionNode) {\n      const expression = JSXExpressionNode.expression;\n      const expressionType = expression.type;\n\n      const sourceCode = getSourceCode(context);\n      // Curly braces containing comments are necessary\n      if (sourceCode.getCommentsInside && sourceCode.getCommentsInside(JSXExpressionNode).length > 0) {\n        return;\n      }\n\n      if (\n        (expressionType === 'Literal' || expressionType === 'JSXText')\n          && typeof expression.value === 'string'\n          && (\n            (JSXExpressionNode.parent.type === 'JSXAttribute' && !isWhiteSpaceLiteral(expression))\n            || !isLiteralWithTrailingWhiteSpaces(expression)\n          )\n          && !containsMultilineComment(expression.value)\n          && !needToEscapeCharacterForJSX(expression.raw, JSXExpressionNode) && (\n          jsxUtil.isJSX(JSXExpressionNode.parent)\n          || (!containsQuoteCharacters(expression.value) || typeof expression.value === 'string')\n        )\n      ) {\n        reportUnnecessaryCurly(JSXExpressionNode);\n      } else if (\n        expressionType === 'TemplateLiteral'\n        && expression.expressions.length === 0\n        && expression.quasis[0].value.raw.indexOf('\\n') === -1\n        && !isStringWithTrailingWhiteSpaces(expression.quasis[0].value.raw)\n        && !needToEscapeCharacterForJSX(expression.quasis[0].value.raw, JSXExpressionNode)\n        && !containsQuoteCharacters(expression.quasis[0].value.cooked)\n      ) {\n        reportUnnecessaryCurly(JSXExpressionNode);\n      } else if (jsxUtil.isJSX(expression)) {\n        reportUnnecessaryCurly(JSXExpressionNode);\n      }\n    }\n\n    function areRuleConditionsSatisfied(parent, config, ruleCondition) {\n      return (\n        parent.type === 'JSXAttribute'\n          && typeof config.props === 'string'\n          && config.props === ruleCondition\n      ) || (\n        jsxUtil.isJSX(parent)\n          && typeof config.children === 'string'\n          && config.children === ruleCondition\n      );\n    }\n\n    function getAdjacentSiblings(node, children) {\n      for (let i = 1; i < children.length - 1; i++) {\n        const child = children[i];\n        if (node === child) {\n          return [children[i - 1], children[i + 1]];\n        }\n      }\n      if (node === children[0] && children[1]) {\n        return [children[1]];\n      }\n      if (node === children[children.length - 1] && children[children.length - 2]) {\n        return [children[children.length - 2]];\n      }\n      return [];\n    }\n\n    function hasAdjacentJsxExpressionContainers(node, children) {\n      if (!children) {\n        return false;\n      }\n      const childrenExcludingWhitespaceLiteral = children.filter((child) => !isWhiteSpaceLiteral(child));\n      const adjSiblings = getAdjacentSiblings(node, childrenExcludingWhitespaceLiteral);\n\n      return adjSiblings.some((x) => x.type && x.type === 'JSXExpressionContainer');\n    }\n    function hasAdjacentJsx(node, children) {\n      if (!children) {\n        return false;\n      }\n      const childrenExcludingWhitespaceLiteral = children.filter((child) => !isWhiteSpaceLiteral(child));\n      const adjSiblings = getAdjacentSiblings(node, childrenExcludingWhitespaceLiteral);\n\n      return adjSiblings.some((x) => x.type && arrayIncludes(['JSXExpressionContainer', 'JSXElement'], x.type));\n    }\n    function shouldCheckForUnnecessaryCurly(node, config) {\n      const parent = node.parent;\n      // Bail out if the parent is a JSXAttribute & its contents aren't\n      // StringLiteral or TemplateLiteral since e.g\n      // <App prop1={<CustomEl />} prop2={<CustomEl>...</CustomEl>} />\n\n      if (\n        parent.type && parent.type === 'JSXAttribute'\n        && (node.expression && node.expression.type\n          && node.expression.type !== 'Literal'\n          && node.expression.type !== 'StringLiteral'\n          && node.expression.type !== 'TemplateLiteral')\n      ) {\n        return false;\n      }\n\n      // If there are adjacent `JsxExpressionContainer` then there is no need,\n      // to check for unnecessary curly braces.\n      if (jsxUtil.isJSX(parent) && hasAdjacentJsxExpressionContainers(node, parent.children)) {\n        return false;\n      }\n      if (containsWhitespaceExpression(node) && hasAdjacentJsx(node, parent.children)) {\n        return false;\n      }\n      if (\n        parent.children\n        && parent.children.length === 1\n        && containsWhitespaceExpression(node)\n      ) {\n        return false;\n      }\n\n      return areRuleConditionsSatisfied(parent, config, OPTION_NEVER);\n    }\n\n    function shouldCheckForMissingCurly(node, config) {\n      if (jsxUtil.isJSX(node)) {\n        return config.propElementValues !== OPTION_IGNORE;\n      }\n      if (\n        isLineBreak(node.raw)\n        || containsOnlyHtmlEntities(node.raw)\n      ) {\n        return false;\n      }\n      const parent = node.parent;\n      if (\n        parent.children\n        && parent.children.length === 1\n        && containsWhitespaceExpression(parent.children[0])\n      ) {\n        return false;\n      }\n\n      return areRuleConditionsSatisfied(parent, config, OPTION_ALWAYS);\n    }\n\n    // --------------------------------------------------------------------------\n    // Public\n    // --------------------------------------------------------------------------\n\n    return {\n      'JSXAttribute > JSXExpressionContainer > JSXElement'(node) {\n        if (userConfig.propElementValues === OPTION_NEVER) {\n          reportUnnecessaryCurly(node.parent);\n        }\n      },\n\n      JSXExpressionContainer(node) {\n        if (shouldCheckForUnnecessaryCurly(node, userConfig)) {\n          lintUnnecessaryCurly(node);\n        }\n      },\n\n      'JSXAttribute > JSXElement, Literal, JSXText'(node) {\n        if (shouldCheckForMissingCurly(node, userConfig)) {\n          reportMissingCurly(node);\n        }\n      },\n    };\n  },\n};\n"
        }
    ]
}