{
    "sourceFile": "node_modules/eslint-plugin-react/lib/rules/jsx-newline.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892270835,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Require or prevent a new line after jsx elements and expressions.\n * @author Johnny Zabala\n * @author Joseph Stiles\n */\n\n'use strict';\n\nconst docsUrl = require('../util/docsUrl');\nconst getText = require('../util/eslint').getText;\nconst report = require('../util/report');\n\n// ------------------------------------------------------------------------------\n// Rule Definition\n// ------------------------------------------------------------------------------\n\nconst messages = {\n  require: 'JSX element should start in a new line',\n  prevent: 'JSX element should not start in a new line',\n  allowMultilines: 'Multiline JSX elements should start in a new line',\n};\n\nfunction isMultilined(node) {\n  return node && node.loc.start.line !== node.loc.end.line;\n}\n\n/** @type {import('eslint').Rule.RuleModule} */\nmodule.exports = {\n  meta: {\n    docs: {\n      description: 'Require or prevent a new line after jsx elements and expressions.',\n      category: 'Stylistic Issues',\n      recommended: false,\n      url: docsUrl('jsx-newline'),\n    },\n    fixable: 'code',\n\n    messages,\n    schema: [\n      {\n        type: 'object',\n        properties: {\n          prevent: {\n            default: false,\n            type: 'boolean',\n          },\n          allowMultilines: {\n            default: false,\n            type: 'boolean',\n          },\n        },\n        additionalProperties: false,\n        if: {\n          properties: {\n            allowMultilines: {\n              const: true,\n            },\n          },\n        },\n        then: {\n          properties: {\n            prevent: {\n              const: true,\n            },\n          },\n          required: [\n            'prevent',\n          ],\n        },\n      },\n    ],\n  },\n  create(context) {\n    const jsxElementParents = new Set();\n\n    function isBlockCommentInCurlyBraces(element) {\n      const elementRawValue = getText(context, element);\n      return /^\\s*{\\/\\*/.test(elementRawValue);\n    }\n\n    function isNonBlockComment(element) {\n      return !isBlockCommentInCurlyBraces(element) && (element.type === 'JSXElement' || element.type === 'JSXExpressionContainer');\n    }\n\n    return {\n      'Program:exit'() {\n        jsxElementParents.forEach((parent) => {\n          parent.children.forEach((element, index, elements) => {\n            if (element.type === 'JSXElement' || element.type === 'JSXExpressionContainer') {\n              const configuration = context.options[0] || {};\n              const prevent = configuration.prevent || false;\n              const allowMultilines = configuration.allowMultilines || false;\n\n              const firstAdjacentSibling = elements[index + 1];\n              const secondAdjacentSibling = elements[index + 2];\n\n              const hasSibling = firstAdjacentSibling\n              && secondAdjacentSibling\n              && (firstAdjacentSibling.type === 'Literal' || firstAdjacentSibling.type === 'JSXText');\n\n              if (!hasSibling) return;\n\n              // Check adjacent sibling has the proper amount of newlines\n              const isWithoutNewLine = !/\\n\\s*\\n/.test(firstAdjacentSibling.value);\n\n              if (isBlockCommentInCurlyBraces(element)) return;\n              if (\n                allowMultilines\n                && (\n                  isMultilined(element)\n                  || isMultilined(elements.slice(index + 2).find(isNonBlockComment))\n                )\n              ) {\n                if (!isWithoutNewLine) return;\n\n                const regex = /(\\n)(?!.*\\1)/g;\n                const replacement = '\\n\\n';\n                const messageId = 'allowMultilines';\n\n                report(context, messages[messageId], messageId, {\n                  node: secondAdjacentSibling,\n                  fix(fixer) {\n                    return fixer.replaceText(\n                      firstAdjacentSibling,\n                      getText(context, firstAdjacentSibling).replace(regex, replacement)\n                    );\n                  },\n                });\n\n                return;\n              }\n\n              if (isWithoutNewLine === prevent) return;\n\n              const messageId = prevent\n                ? 'prevent'\n                : 'require';\n\n              const regex = prevent\n                ? /(\\n\\n)(?!.*\\1)/g\n                : /(\\n)(?!.*\\1)/g;\n\n              const replacement = prevent\n                ? '\\n'\n                : '\\n\\n';\n\n              report(context, messages[messageId], messageId, {\n                node: secondAdjacentSibling,\n                fix(fixer) {\n                  return fixer.replaceText(\n                    firstAdjacentSibling,\n                    // double or remove the last newline\n                    getText(context, firstAdjacentSibling).replace(regex, replacement)\n                  );\n                },\n              });\n            }\n          });\n        });\n      },\n      ':matches(JSXElement, JSXFragment) > :matches(JSXElement, JSXExpressionContainer)': (node) => {\n        jsxElementParents.add(node.parent);\n      },\n    };\n  },\n};\n"
        }
    ]
}