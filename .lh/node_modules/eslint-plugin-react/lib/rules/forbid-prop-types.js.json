{
    "sourceFile": "node_modules/eslint-plugin-react/lib/rules/forbid-prop-types.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892267070,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Forbid certain propTypes\n */\n\n'use strict';\n\nconst variableUtil = require('../util/variable');\nconst propsUtil = require('../util/props');\nconst astUtil = require('../util/ast');\nconst docsUrl = require('../util/docsUrl');\nconst propWrapperUtil = require('../util/propWrapper');\nconst report = require('../util/report');\nconst getText = require('../util/eslint').getText;\n\n// ------------------------------------------------------------------------------\n// Constants\n// ------------------------------------------------------------------------------\n\nconst DEFAULTS = ['any', 'array', 'object'];\n\n// ------------------------------------------------------------------------------\n// Rule Definition\n// ------------------------------------------------------------------------------\n\nconst messages = {\n  forbiddenPropType: 'Prop type \"{{target}}\" is forbidden',\n};\n\n/** @type {import('eslint').Rule.RuleModule} */\nmodule.exports = {\n  meta: {\n    docs: {\n      description: 'Disallow certain propTypes',\n      category: 'Best Practices',\n      recommended: false,\n      url: docsUrl('forbid-prop-types'),\n    },\n\n    messages,\n\n    schema: [{\n      type: 'object',\n      properties: {\n        forbid: {\n          type: 'array',\n          items: {\n            type: 'string',\n          },\n        },\n        checkContextTypes: {\n          type: 'boolean',\n        },\n        checkChildContextTypes: {\n          type: 'boolean',\n        },\n      },\n      additionalProperties: true,\n    }],\n  },\n\n  create(context) {\n    const configuration = context.options[0] || {};\n    const checkContextTypes = configuration.checkContextTypes || false;\n    const checkChildContextTypes = configuration.checkChildContextTypes || false;\n    let propTypesPackageName = null;\n    let reactPackageName = null;\n    let isForeignPropTypesPackage = false;\n\n    function isPropTypesPackage(node) {\n      return (\n        node.type === 'Identifier'\n        && (\n          node.name === null\n          || node.name === propTypesPackageName\n          || !isForeignPropTypesPackage\n        )\n      ) || (\n        node.type === 'MemberExpression'\n        && (\n          node.object.name === null\n          || node.object.name === reactPackageName\n          || !isForeignPropTypesPackage\n        )\n      );\n    }\n\n    function isForbidden(type) {\n      const forbid = configuration.forbid || DEFAULTS;\n      return forbid.indexOf(type) >= 0;\n    }\n\n    function reportIfForbidden(type, declaration, target) {\n      if (isForbidden(type)) {\n        report(context, messages.forbiddenPropType, 'forbiddenPropType', {\n          node: declaration,\n          data: {\n            target,\n          },\n        });\n      }\n    }\n\n    function shouldCheckContextTypes(node) {\n      if (checkContextTypes && propsUtil.isContextTypesDeclaration(node)) {\n        return true;\n      }\n      return false;\n    }\n\n    function shouldCheckChildContextTypes(node) {\n      if (checkChildContextTypes && propsUtil.isChildContextTypesDeclaration(node)) {\n        return true;\n      }\n      return false;\n    }\n\n    /**\n     * Checks if propTypes declarations are forbidden\n     * @param {Array} declarations The array of AST nodes being checked.\n     * @returns {void}\n     */\n    function checkProperties(declarations) {\n      if (declarations) {\n        declarations.forEach((declaration) => {\n          if (declaration.type !== 'Property') {\n            return;\n          }\n          let target;\n          let value = declaration.value;\n          if (\n            value.type === 'MemberExpression'\n            && value.property\n            && value.property.name\n            && value.property.name === 'isRequired'\n          ) {\n            value = value.object;\n          }\n          if (astUtil.isCallExpression(value)) {\n            if (!isPropTypesPackage(value.callee)) {\n              return;\n            }\n            value.arguments.forEach((arg) => {\n              const name = arg.type === 'MemberExpression' ? arg.property.name : arg.name;\n              reportIfForbidden(name, declaration, name);\n            });\n            value = value.callee;\n          }\n          if (!isPropTypesPackage(value)) {\n            return;\n          }\n          if (value.property) {\n            target = value.property.name;\n          } else if (value.type === 'Identifier') {\n            target = value.name;\n          }\n          reportIfForbidden(target, declaration, target);\n        });\n      }\n    }\n\n    function checkNode(node) {\n      if (!node) {\n        return;\n      }\n\n      if (node.type === 'ObjectExpression') {\n        checkProperties(node.properties);\n      } else if (node.type === 'Identifier') {\n        const propTypesObject = variableUtil.findVariableByName(context, node, node.name);\n        if (propTypesObject && propTypesObject.properties) {\n          checkProperties(propTypesObject.properties);\n        }\n      } else if (astUtil.isCallExpression(node)) {\n        const innerNode = node.arguments && node.arguments[0];\n        if (\n          propWrapperUtil.isPropWrapperFunction(context, getText(context, node.callee))\n            && innerNode\n        ) {\n          checkNode(innerNode);\n        }\n      }\n    }\n\n    return {\n      ImportDeclaration(node) {\n        if (node.source && node.source.value === 'prop-types') { // import PropType from \"prop-types\"\n          if (node.specifiers.length > 0) {\n            propTypesPackageName = node.specifiers[0].local.name;\n          }\n        } else if (node.source && node.source.value === 'react') { // import { PropTypes } from \"react\"\n          if (node.specifiers.length > 0) {\n            reactPackageName = node.specifiers[0].local.name; // guard against accidental anonymous `import \"react\"`\n          }\n          if (node.specifiers.length >= 1) {\n            const propTypesSpecifier = node.specifiers.find((specifier) => (\n              'imported' in specifier\n              && specifier.imported\n              && 'name' in specifier.imported\n              && specifier.imported.name === 'PropTypes'\n            ));\n            if (propTypesSpecifier) {\n              propTypesPackageName = propTypesSpecifier.local.name;\n            }\n          }\n        } else { // package is not imported from \"react\" or \"prop-types\"\n          // eslint-disable-next-line no-lonely-if\n          if (node.specifiers.some((x) => x.local.name === 'PropTypes')) { // assert: node.specifiers.length > 1\n            isForeignPropTypesPackage = true;\n          }\n        }\n      },\n\n      'ClassProperty, PropertyDefinition'(node) {\n        if (\n          !propsUtil.isPropTypesDeclaration(node)\n          && !isPropTypesPackage(node)\n          && !shouldCheckContextTypes(node)\n          && !shouldCheckChildContextTypes(node)\n        ) {\n          return;\n        }\n        checkNode(node.value);\n      },\n\n      MemberExpression(node) {\n        if (\n          !propsUtil.isPropTypesDeclaration(node)\n          && !isPropTypesPackage(node)\n          && !shouldCheckContextTypes(node)\n          && !shouldCheckChildContextTypes(node)\n        ) {\n          return;\n        }\n\n        checkNode('right' in node.parent && node.parent.right);\n      },\n\n      CallExpression(node) {\n        if (\n          node.callee.type === 'MemberExpression'\n          && node.callee.object\n          && !isPropTypesPackage(node.callee.object)\n          && !propsUtil.isPropTypesDeclaration(node.callee)\n        ) {\n          return;\n        }\n\n        if (\n          node.arguments.length > 0\n          && (\n            ('name' in node.callee && node.callee.name === 'shape')\n            || astUtil.getPropertyName(node.callee) === 'shape'\n          )\n        ) {\n          checkProperties('properties' in node.arguments[0] && node.arguments[0].properties);\n        }\n      },\n\n      MethodDefinition(node) {\n        if (\n          !propsUtil.isPropTypesDeclaration(node)\n          && !isPropTypesPackage(node)\n          && !shouldCheckContextTypes(node)\n          && !shouldCheckChildContextTypes(node)\n        ) {\n          return;\n        }\n\n        const returnStatement = astUtil.findReturnStatement(node);\n\n        if (returnStatement && returnStatement.argument) {\n          checkNode(returnStatement.argument);\n        }\n      },\n\n      ObjectExpression(node) {\n        node.properties.forEach((property) => {\n          if (!('key' in property) || !property.key) {\n            return;\n          }\n\n          if (\n            !propsUtil.isPropTypesDeclaration(property)\n            && !isPropTypesPackage(property)\n            && !shouldCheckContextTypes(property)\n            && !shouldCheckChildContextTypes(property)\n          ) {\n            return;\n          }\n          if (property.value.type === 'ObjectExpression') {\n            checkProperties(property.value.properties);\n          }\n        });\n      },\n\n    };\n  },\n};\n"
        }
    ]
}