{
    "sourceFile": "node_modules/eslint-plugin-react/lib/rules/hook-use-state.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892267614,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Ensure symmetric naming of useState hook value and setter variables\n * @author Duncan Beevers\n */\n\n'use strict';\n\nconst Components = require('../util/Components');\nconst docsUrl = require('../util/docsUrl');\nconst report = require('../util/report');\nconst getMessageData = require('../util/message');\nconst getText = require('../util/eslint').getText;\n\n// ------------------------------------------------------------------------------\n// Rule Definition\n// ------------------------------------------------------------------------------\n\nfunction isNodeDestructuring(node) {\n  return node && (node.type === 'ArrayPattern' || node.type === 'ObjectPattern');\n}\n\nconst messages = {\n  useStateErrorMessage: 'useState call is not destructured into value + setter pair',\n  useStateErrorMessageOrAddOption: 'useState call is not destructured into value + setter pair (you can allow destructuring by enabling \"allowDestructuredState\" option)',\n  suggestPair: 'Destructure useState call into value + setter pair',\n  suggestMemo: 'Replace useState call with useMemo',\n};\n\n/** @type {import('eslint').Rule.RuleModule} */\nmodule.exports = {\n  meta: {\n    docs: {\n      description: 'Ensure destructuring and symmetric naming of useState hook value and setter variables',\n      category: 'Best Practices',\n      recommended: false,\n      url: docsUrl('hook-use-state'),\n    },\n    messages,\n    schema: [{\n      type: 'object',\n      properties: {\n        allowDestructuredState: {\n          default: false,\n          type: 'boolean',\n        },\n      },\n      additionalProperties: false,\n    }],\n    type: 'suggestion',\n    hasSuggestions: true,\n  },\n\n  create: Components.detect((context, components, util) => {\n    const configuration = context.options[0] || {};\n    const allowDestructuredState = configuration.allowDestructuredState || false;\n\n    return {\n      CallExpression(node) {\n        const isImmediateReturn = node.parent\n          && node.parent.type === 'ReturnStatement';\n\n        if (isImmediateReturn || !util.isReactHookCall(node, ['useState'])) {\n          return;\n        }\n\n        const isDestructuringDeclarator = node.parent\n          && node.parent.type === 'VariableDeclarator'\n          && node.parent.id.type === 'ArrayPattern';\n\n        if (!isDestructuringDeclarator) {\n          report(\n            context,\n            messages.useStateErrorMessage,\n            'useStateErrorMessage',\n            {\n              node,\n              suggest: false,\n            }\n          );\n          return;\n        }\n\n        const variableNodes = node.parent.id.elements;\n        const valueVariable = variableNodes[0];\n        const setterVariable = variableNodes[1];\n        const isOnlyValueDestructuring = isNodeDestructuring(valueVariable) && !isNodeDestructuring(setterVariable);\n\n        if (allowDestructuredState && isOnlyValueDestructuring) {\n          return;\n        }\n\n        const valueVariableName = valueVariable\n          ? valueVariable.name\n          : undefined;\n\n        const setterVariableName = setterVariable\n          ? setterVariable.name\n          : undefined;\n\n        const caseCandidateMatch = valueVariableName ? valueVariableName.match(/(^[a-z]+)(.*)/) : undefined;\n        const upperCaseCandidatePrefix = caseCandidateMatch ? caseCandidateMatch[1] : undefined;\n        const caseCandidateSuffix = caseCandidateMatch ? caseCandidateMatch[2] : undefined;\n        const expectedSetterVariableNames = upperCaseCandidatePrefix ? [\n          `set${upperCaseCandidatePrefix.charAt(0).toUpperCase()}${upperCaseCandidatePrefix.slice(1)}${caseCandidateSuffix}`,\n          `set${upperCaseCandidatePrefix.toUpperCase()}${caseCandidateSuffix}`,\n        ] : [];\n\n        const isSymmetricGetterSetterPair = valueVariable\n          && setterVariable\n          && expectedSetterVariableNames.indexOf(setterVariableName) !== -1\n          && variableNodes.length === 2;\n\n        if (!isSymmetricGetterSetterPair) {\n          const suggestions = [\n            Object.assign(\n              getMessageData('suggestPair', messages.suggestPair),\n              {\n                fix(fixer) {\n                  if (expectedSetterVariableNames.length > 0) {\n                    return fixer.replaceTextRange(\n                      node.parent.id.range,\n                      `[${valueVariableName}, ${expectedSetterVariableNames[0]}]`\n                    );\n                  }\n                },\n              }\n            ),\n          ];\n\n          const defaultReactImports = components.getDefaultReactImports();\n          const defaultReactImportSpecifier = defaultReactImports\n            ? defaultReactImports[0]\n            : undefined;\n\n          const defaultReactImportName = defaultReactImportSpecifier\n            ? defaultReactImportSpecifier.local.name\n            : undefined;\n\n          const namedReactImports = components.getNamedReactImports();\n          const useStateReactImportSpecifier = namedReactImports\n            ? namedReactImports.find((specifier) => specifier.imported.name === 'useState')\n            : undefined;\n\n          const isSingleGetter = valueVariable && variableNodes.length === 1;\n          const isUseStateCalledWithSingleArgument = node.arguments.length === 1;\n          if (isSingleGetter && isUseStateCalledWithSingleArgument) {\n            const useMemoReactImportSpecifier = namedReactImports\n              && namedReactImports.find((specifier) => specifier.imported.name === 'useMemo');\n\n            let useMemoCode;\n            if (useMemoReactImportSpecifier) {\n              useMemoCode = useMemoReactImportSpecifier.local.name;\n            } else if (defaultReactImportName) {\n              useMemoCode = `${defaultReactImportName}.useMemo`;\n            } else {\n              useMemoCode = 'useMemo';\n            }\n\n            suggestions.unshift(Object.assign(\n              getMessageData('suggestMemo', messages.suggestMemo),\n              {\n                fix: (fixer) => [\n                  // Add useMemo import, if necessary\n                  useStateReactImportSpecifier\n                    && (!useMemoReactImportSpecifier || defaultReactImportName)\n                    && fixer.insertTextAfter(useStateReactImportSpecifier, ', useMemo'),\n                  // Convert single-value destructure to simple assignment\n                  fixer.replaceTextRange(node.parent.id.range, valueVariableName),\n                  // Convert useState call to useMemo + arrow function + dependency array\n                  fixer.replaceTextRange(\n                    node.range,\n                    `${useMemoCode}(() => ${getText(context, node.arguments[0])}, [])`\n                  ),\n                ].filter(Boolean),\n              }\n            ));\n          }\n\n          if (isOnlyValueDestructuring) {\n            report(\n              context,\n              messages.useStateErrorMessageOrAddOption,\n              'useStateErrorMessageOrAddOption',\n              {\n                node: node.parent.id,\n                suggest: false,\n              }\n            );\n            return;\n          }\n\n          report(\n            context,\n            messages.useStateErrorMessage,\n            'useStateErrorMessage',\n            {\n              node: node.parent.id,\n              suggest: suggestions,\n            }\n          );\n        }\n      },\n    };\n  }),\n};\n"
        }
    ]
}