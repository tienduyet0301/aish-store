{
    "sourceFile": "node_modules/eslint-plugin-react/lib/rules/require-default-props.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892276905,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileOverview Enforce a defaultProps definition for every prop that is not a required prop.\n * @author Vitor Balocco\n */\n\n'use strict';\n\nconst entries = require('object.entries');\nconst values = require('object.values');\nconst Components = require('../util/Components');\nconst docsUrl = require('../util/docsUrl');\nconst astUtil = require('../util/ast');\nconst report = require('../util/report');\n\n// ------------------------------------------------------------------------------\n// Rule Definition\n// ------------------------------------------------------------------------------\n\nconst messages = {\n  noDefaultWithRequired: 'propType \"{{name}}\" is required and should not have a defaultProps declaration.',\n  shouldHaveDefault: 'propType \"{{name}}\" is not required, but has no corresponding defaultProps declaration.',\n  noDefaultPropsWithFunction: 'Donâ€™t use defaultProps with function components.',\n  shouldAssignObjectDefault: 'propType \"{{name}}\" is not required, but has no corresponding default argument value.',\n  destructureInSignature: 'Must destructure props in the function signature to initialize an optional prop.',\n};\n\nfunction isPropWithNoDefaulVal(prop) {\n  if (prop.type === 'RestElement' || prop.type === 'ExperimentalRestProperty') {\n    return false;\n  }\n  return prop.value.type !== 'AssignmentPattern';\n}\n\n/** @type {import('eslint').Rule.RuleModule} */\nmodule.exports = {\n  meta: {\n    docs: {\n      description: 'Enforce a defaultProps definition for every prop that is not a required prop',\n      category: 'Best Practices',\n      url: docsUrl('require-default-props'),\n    },\n\n    messages,\n\n    schema: [{\n      type: 'object',\n      properties: {\n        forbidDefaultForRequired: {\n          type: 'boolean',\n        },\n        classes: {\n          enum: ['defaultProps', 'ignore'],\n        },\n        functions: {\n          enum: ['defaultArguments', 'defaultProps', 'ignore'],\n        },\n        /**\n         * @deprecated\n         */\n        ignoreFunctionalComponents: {\n          type: 'boolean',\n        },\n      },\n      additionalProperties: false,\n    }],\n  },\n\n  create: Components.detect((context, components) => {\n    const configuration = context.options[0] || {};\n    const forbidDefaultForRequired = configuration.forbidDefaultForRequired || false;\n    const classes = configuration.classes || 'defaultProps';\n    /**\n     * @todo\n     * - Remove ignoreFunctionalComponents\n     * - Change default to 'defaultArguments'\n     */\n    const functions = configuration.ignoreFunctionalComponents\n      ? 'ignore'\n      : configuration.functions || 'defaultProps';\n\n    /**\n     * Reports all propTypes passed in that don't have a defaultProps counterpart.\n     * @param  {Object[]} propTypes    List of propTypes to check.\n     * @param  {Object}   defaultProps Object of defaultProps to check. Keys are the props names.\n     * @return {void}\n     */\n    function reportPropTypesWithoutDefault(propTypes, defaultProps) {\n      entries(propTypes).forEach((propType) => {\n        const propName = propType[0];\n        const prop = propType[1];\n\n        if (!prop.node) {\n          return;\n        }\n        if (prop.isRequired) {\n          if (forbidDefaultForRequired && defaultProps[propName]) {\n            report(context, messages.noDefaultWithRequired, 'noDefaultWithRequired', {\n              node: prop.node,\n              data: { name: propName },\n            });\n          }\n          return;\n        }\n\n        if (defaultProps[propName]) {\n          return;\n        }\n\n        report(context, messages.shouldHaveDefault, 'shouldHaveDefault', {\n          node: prop.node,\n          data: { name: propName },\n        });\n      });\n    }\n\n    /**\n     * If functions option is 'defaultArguments', reports defaultProps is used and all params that doesn't initialized.\n     * @param {Object} componentNode Node of component.\n     * @param {Object[]} declaredPropTypes List of propTypes to check `isRequired`.\n     * @param {Object} defaultProps Object of defaultProps to check used.\n     */\n    function reportFunctionComponent(componentNode, declaredPropTypes, defaultProps) {\n      if (defaultProps) {\n        report(context, messages.noDefaultPropsWithFunction, 'noDefaultPropsWithFunction', {\n          node: componentNode,\n        });\n      }\n\n      const props = componentNode.params[0];\n      const propTypes = declaredPropTypes;\n\n      if (!props) {\n        return;\n      }\n\n      if (props.type === 'Identifier') {\n        const hasOptionalProp = values(propTypes).some((propType) => !propType.isRequired);\n        if (hasOptionalProp) {\n          report(context, messages.destructureInSignature, 'destructureInSignature', {\n            node: props,\n          });\n        }\n      } else if (props.type === 'ObjectPattern') {\n        // Filter required props with default value and report error\n        props.properties.filter((prop) => {\n          const propName = prop && prop.key && prop.key.name;\n          const isPropRequired = propTypes[propName] && propTypes[propName].isRequired;\n          return propTypes[propName] && isPropRequired && !isPropWithNoDefaulVal(prop);\n        }).forEach((prop) => {\n          report(context, messages.noDefaultWithRequired, 'noDefaultWithRequired', {\n            node: prop,\n            data: { name: prop.key.name },\n          });\n        });\n\n        // Filter non required props with no default value and report error\n        props.properties.filter((prop) => {\n          const propName = prop && prop.key && prop.key.name;\n          const isPropRequired = propTypes[propName] && propTypes[propName].isRequired;\n          return propTypes[propName] && !isPropRequired && isPropWithNoDefaulVal(prop);\n        }).forEach((prop) => {\n          report(context, messages.shouldAssignObjectDefault, 'shouldAssignObjectDefault', {\n            node: prop,\n            data: { name: prop.key.name },\n          });\n        });\n      }\n    }\n\n    // --------------------------------------------------------------------------\n    // Public API\n    // --------------------------------------------------------------------------\n\n    return {\n      'Program:exit'() {\n        const list = components.list();\n\n        values(list).filter((component) => {\n          if (functions === 'ignore' && astUtil.isFunctionLike(component.node)) {\n            return false;\n          }\n          if (classes === 'ignore' && astUtil.isClass(component.node)) {\n            return false;\n          }\n\n          // If this defaultProps is \"unresolved\", then we should ignore this component and not report\n          // any errors for it, to avoid false-positives with e.g. external defaultProps declarations or spread operators.\n          if (component.defaultProps === 'unresolved') {\n            return false;\n          }\n          return component.declaredPropTypes !== undefined;\n        }).forEach((component) => {\n          if (functions === 'defaultArguments' && astUtil.isFunctionLike(component.node)) {\n            reportFunctionComponent(\n              component.node,\n              component.declaredPropTypes,\n              component.defaultProps\n            );\n          } else {\n            reportPropTypesWithoutDefault(\n              component.declaredPropTypes,\n              component.defaultProps || {}\n            );\n          }\n        });\n      },\n    };\n  }),\n};\n"
        }
    ]
}