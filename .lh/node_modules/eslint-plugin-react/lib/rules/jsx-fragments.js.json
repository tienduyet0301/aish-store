{
    "sourceFile": "node_modules/eslint-plugin-react/lib/rules/jsx-fragments.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892269741,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Enforce shorthand or standard form for React fragments.\n * @author Alex Zherdev\n */\n\n'use strict';\n\nconst elementType = require('jsx-ast-utils/elementType');\nconst pragmaUtil = require('../util/pragma');\nconst variableUtil = require('../util/variable');\nconst testReactVersion = require('../util/version').testReactVersion;\nconst docsUrl = require('../util/docsUrl');\nconst report = require('../util/report');\nconst getText = require('../util/eslint').getText;\n\n// ------------------------------------------------------------------------------\n// Rule Definition\n// ------------------------------------------------------------------------------\n\nfunction replaceNode(source, node, text) {\n  return `${source.slice(0, node.range[0])}${text}${source.slice(node.range[1])}`;\n}\n\nconst messages = {\n  fragmentsNotSupported: 'Fragments are only supported starting from React v16.2. Please disable the `react/jsx-fragments` rule in `eslint` settings or upgrade your version of React.',\n  preferPragma: 'Prefer {{react}}.{{fragment}} over fragment shorthand',\n  preferFragment: 'Prefer fragment shorthand over {{react}}.{{fragment}}',\n};\n\n/** @type {import('eslint').Rule.RuleModule} */\nmodule.exports = {\n  meta: {\n    docs: {\n      description: 'Enforce shorthand or standard form for React fragments',\n      category: 'Stylistic Issues',\n      recommended: false,\n      url: docsUrl('jsx-fragments'),\n    },\n    fixable: 'code',\n\n    messages,\n\n    schema: [{\n      enum: ['syntax', 'element'],\n    }],\n  },\n\n  create(context) {\n    const configuration = context.options[0] || 'syntax';\n    const reactPragma = pragmaUtil.getFromContext(context);\n    const fragmentPragma = pragmaUtil.getFragmentFromContext(context);\n    const openFragShort = '<>';\n    const closeFragShort = '</>';\n    const openFragLong = `<${reactPragma}.${fragmentPragma}>`;\n    const closeFragLong = `</${reactPragma}.${fragmentPragma}>`;\n\n    function reportOnReactVersion(node) {\n      if (!testReactVersion(context, '>= 16.2.0')) {\n        report(context, messages.fragmentsNotSupported, 'fragmentsNotSupported', {\n          node,\n        });\n        return true;\n      }\n\n      return false;\n    }\n\n    function getFixerToLong(jsxFragment) {\n      if (!jsxFragment.closingFragment || !jsxFragment.openingFragment) {\n        // the old TS parser crashes here\n        // TODO: FIXME: can we fake these two descriptors?\n        return null;\n      }\n      return function fix(fixer) {\n        let source = getText(context);\n        source = replaceNode(source, jsxFragment.closingFragment, closeFragLong);\n        source = replaceNode(source, jsxFragment.openingFragment, openFragLong);\n        const lengthDiff = openFragLong.length - getText(context, jsxFragment.openingFragment).length\n          + closeFragLong.length - getText(context, jsxFragment.closingFragment).length;\n        const range = jsxFragment.range;\n        return fixer.replaceTextRange(range, source.slice(range[0], range[1] + lengthDiff));\n      };\n    }\n\n    function getFixerToShort(jsxElement) {\n      return function fix(fixer) {\n        let source = getText(context);\n        let lengthDiff;\n        if (jsxElement.closingElement) {\n          source = replaceNode(source, jsxElement.closingElement, closeFragShort);\n          source = replaceNode(source, jsxElement.openingElement, openFragShort);\n          lengthDiff = getText(context, jsxElement.openingElement).length - openFragShort.length\n            + getText(context, jsxElement.closingElement).length - closeFragShort.length;\n        } else {\n          source = replaceNode(source, jsxElement.openingElement, `${openFragShort}${closeFragShort}`);\n          lengthDiff = getText(context, jsxElement.openingElement).length - openFragShort.length\n            - closeFragShort.length;\n        }\n\n        const range = jsxElement.range;\n        return fixer.replaceTextRange(range, source.slice(range[0], range[1] - lengthDiff));\n      };\n    }\n\n    function refersToReactFragment(node, name) {\n      const variableInit = variableUtil.findVariableByName(context, node, name);\n      if (!variableInit) {\n        return false;\n      }\n\n      // const { Fragment } = React;\n      if (variableInit.type === 'Identifier' && variableInit.name === reactPragma) {\n        return true;\n      }\n\n      // const Fragment = React.Fragment;\n      if (\n        variableInit.type === 'MemberExpression'\n        && variableInit.object.type === 'Identifier'\n        && variableInit.object.name === reactPragma\n        && variableInit.property.type === 'Identifier'\n        && variableInit.property.name === fragmentPragma\n      ) {\n        return true;\n      }\n\n      // const { Fragment } = require('react');\n      if (\n        variableInit.callee\n        && variableInit.callee.name === 'require'\n        && variableInit.arguments\n        && variableInit.arguments[0]\n        && variableInit.arguments[0].value === 'react'\n      ) {\n        return true;\n      }\n\n      return false;\n    }\n\n    const jsxElements = [];\n    const fragmentNames = new Set([`${reactPragma}.${fragmentPragma}`]);\n\n    // --------------------------------------------------------------------------\n    // Public\n    // --------------------------------------------------------------------------\n\n    return {\n      JSXElement(node) {\n        jsxElements.push(node);\n      },\n\n      JSXFragment(node) {\n        if (reportOnReactVersion(node)) {\n          return;\n        }\n\n        if (configuration === 'element') {\n          report(context, messages.preferPragma, 'preferPragma', {\n            node,\n            data: {\n              react: reactPragma,\n              fragment: fragmentPragma,\n            },\n            fix: getFixerToLong(node),\n          });\n        }\n      },\n\n      ImportDeclaration(node) {\n        if (node.source && node.source.value === 'react') {\n          node.specifiers.forEach((spec) => {\n            if (\n              'imported' in spec\n              && spec.imported\n              && 'name' in spec.imported\n              && spec.imported.name === fragmentPragma\n            ) {\n              if (spec.local) {\n                fragmentNames.add(spec.local.name);\n              }\n            }\n          });\n        }\n      },\n\n      'Program:exit'() {\n        jsxElements.forEach((node) => {\n          const openingEl = node.openingElement;\n          const elName = elementType(openingEl);\n\n          if (fragmentNames.has(elName) || refersToReactFragment(node, elName)) {\n            if (reportOnReactVersion(node)) {\n              return;\n            }\n\n            const attrs = openingEl.attributes;\n            if (configuration === 'syntax' && !(attrs && attrs.length > 0)) {\n              report(context, messages.preferFragment, 'preferFragment', {\n                node,\n                data: {\n                  react: reactPragma,\n                  fragment: fragmentPragma,\n                },\n                fix: getFixerToShort(node),\n              });\n            }\n          }\n        });\n      },\n    };\n  },\n};\n"
        }
    ]
}