{
    "sourceFile": "node_modules/eslint-plugin-react/lib/rules/jsx-props-no-multi-spaces.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892272122,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Disallow multiple spaces between inline JSX props\n * @author Adrian Moennich\n */\n\n'use strict';\n\nconst docsUrl = require('../util/docsUrl');\nconst eslintUtil = require('../util/eslint');\nconst report = require('../util/report');\nconst propsUtil = require('../util/props');\n\nconst getSourceCode = eslintUtil.getSourceCode;\nconst getText = eslintUtil.getText;\n\n// ------------------------------------------------------------------------------\n// Rule Definition\n// ------------------------------------------------------------------------------\n\nconst messages = {\n  noLineGap: 'Expected no line gap between “{{prop1}}” and “{{prop2}}”',\n  onlyOneSpace: 'Expected only one space between “{{prop1}}” and “{{prop2}}”',\n};\n\n/** @type {import('eslint').Rule.RuleModule} */\nmodule.exports = {\n  meta: {\n    docs: {\n      description: 'Disallow multiple spaces between inline JSX props',\n      category: 'Stylistic Issues',\n      recommended: false,\n      url: docsUrl('jsx-props-no-multi-spaces'),\n    },\n    fixable: 'code',\n\n    messages,\n\n    schema: [],\n  },\n\n  create(context) {\n    const sourceCode = getSourceCode(context);\n\n    function getPropName(propNode) {\n      switch (propNode.type) {\n        case 'JSXSpreadAttribute':\n          return getText(context, propNode.argument);\n        case 'JSXIdentifier':\n          return propNode.name;\n        case 'JSXMemberExpression':\n          return `${getPropName(propNode.object)}.${propNode.property.name}`;\n        default:\n          return propNode.name\n            ? propNode.name.name\n            : `${getText(context, propNode.object)}.${propNode.property.name}`; // needed for typescript-eslint parser\n      }\n    }\n\n    // First and second must be adjacent nodes\n    function hasEmptyLines(first, second) {\n      const comments = sourceCode.getCommentsBefore ? sourceCode.getCommentsBefore(second) : [];\n      const nodes = [].concat(first, comments, second);\n\n      for (let i = 1; i < nodes.length; i += 1) {\n        const prev = nodes[i - 1];\n        const curr = nodes[i];\n        if (curr.loc.start.line - prev.loc.end.line >= 2) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n\n    function checkSpacing(prev, node) {\n      if (hasEmptyLines(prev, node)) {\n        report(context, messages.noLineGap, 'noLineGap', {\n          node,\n          data: {\n            prop1: getPropName(prev),\n            prop2: getPropName(node),\n          },\n        });\n      }\n\n      if (prev.loc.end.line !== node.loc.end.line) {\n        return;\n      }\n\n      const between = getSourceCode(context).text.slice(prev.range[1], node.range[0]);\n\n      if (between !== ' ') {\n        report(context, messages.onlyOneSpace, 'onlyOneSpace', {\n          node,\n          data: {\n            prop1: getPropName(prev),\n            prop2: getPropName(node),\n          },\n          fix(fixer) {\n            return fixer.replaceTextRange([prev.range[1], node.range[0]], ' ');\n          },\n        });\n      }\n    }\n\n    function containsGenericType(node) {\n      const nodeTypeArguments = propsUtil.getTypeArguments(node);\n      if (typeof nodeTypeArguments === 'undefined') {\n        return false;\n      }\n\n      return nodeTypeArguments.type === 'TSTypeParameterInstantiation';\n    }\n\n    function getGenericNode(node) {\n      const name = node.name;\n      if (containsGenericType(node)) {\n        const nodeTypeArguments = propsUtil.getTypeArguments(node);\n\n        return Object.assign(\n          {},\n          node,\n          {\n            range: [\n              name.range[0],\n              nodeTypeArguments.range[1],\n            ],\n          }\n        );\n      }\n\n      return name;\n    }\n\n    return {\n      JSXOpeningElement(node) {\n        node.attributes.reduce((prev, prop) => {\n          checkSpacing(prev, prop);\n          return prop;\n        }, getGenericNode(node));\n      },\n    };\n  },\n};\n"
        }
    ]
}