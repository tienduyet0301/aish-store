{
    "sourceFile": "node_modules/eslint-plugin-react/lib/rules/no-unused-state.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892275634,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview  Attempts to discover all state fields in a React component and\n * warn if any of them are never read.\n *\n * State field definitions are collected from `this.state = {}` assignments in\n * the constructor, objects passed to `this.setState()`, and `state = {}` class\n * property assignments.\n */\n\n'use strict';\n\nconst docsUrl = require('../util/docsUrl');\nconst astUtil = require('../util/ast');\nconst componentUtil = require('../util/componentUtil');\nconst report = require('../util/report');\nconst getScope = require('../util/eslint').getScope;\n\n// Descend through all wrapping TypeCastExpressions and return the expression\n// that was cast.\nfunction uncast(node) {\n  while (node.type === 'TypeCastExpression') {\n    node = node.expression;\n  }\n  return node;\n}\n\n// Return the name of an identifier or the string value of a literal. Useful\n// anywhere that a literal may be used as a key (e.g., member expressions,\n// method definitions, ObjectExpression property keys).\nfunction getName(node) {\n  node = uncast(node);\n  const type = node.type;\n\n  if (type === 'Identifier') {\n    return node.name;\n  }\n  if (type === 'Literal') {\n    return String(node.value);\n  }\n  if (type === 'TemplateLiteral' && node.expressions.length === 0) {\n    return node.quasis[0].value.raw;\n  }\n  return null;\n}\n\nfunction isThisExpression(node) {\n  return astUtil.unwrapTSAsExpression(uncast(node)).type === 'ThisExpression';\n}\n\nfunction getInitialClassInfo() {\n  return {\n    // Set of nodes where state fields were defined.\n    stateFields: new Set(),\n\n    // Set of names of state fields that we've seen used.\n    usedStateFields: new Set(),\n\n    // Names of local variables that may be pointing to this.state. To\n    // track this properly, we would need to keep track of all locals,\n    // shadowing, assignments, etc. To keep things simple, we only\n    // maintain one set of aliases per method and accept that it will\n    // produce some false negatives.\n    aliases: null,\n  };\n}\n\nfunction isSetStateCall(node) {\n  const unwrappedCalleeNode = astUtil.unwrapTSAsExpression(node.callee);\n\n  return (\n    unwrappedCalleeNode.type === 'MemberExpression'\n    && isThisExpression(unwrappedCalleeNode.object)\n    && getName(unwrappedCalleeNode.property) === 'setState'\n  );\n}\n\nconst messages = {\n  unusedStateField: 'Unused state field: \\'{{name}}\\'',\n};\n\n/** @type {import('eslint').Rule.RuleModule} */\nmodule.exports = {\n  meta: {\n    docs: {\n      description: 'Disallow definitions of unused state',\n      category: 'Best Practices',\n      recommended: false,\n      url: docsUrl('no-unused-state'),\n    },\n\n    messages,\n\n    schema: [],\n  },\n\n  create(context) {\n    // Non-null when we are inside a React component ClassDeclaration and we have\n    // not yet encountered any use of this.state which we have chosen not to\n    // analyze. If we encounter any such usage (like this.state being spread as\n    // JSX attributes), then this is again set to null.\n    let classInfo = null;\n\n    function isStateParameterReference(node) {\n      const classMethods = [\n        'shouldComponentUpdate',\n        'componentWillUpdate',\n        'UNSAFE_componentWillUpdate',\n        'getSnapshotBeforeUpdate',\n        'componentDidUpdate',\n      ];\n\n      let scope = getScope(context, node);\n      while (scope) {\n        const parent = scope.block && scope.block.parent;\n        if (\n          parent\n          && parent.type === 'MethodDefinition' && (\n            (parent.static && parent.key.name === 'getDerivedStateFromProps')\n            || classMethods.indexOf(parent.key.name) !== -1\n          )\n          && parent.value.type === 'FunctionExpression'\n          && parent.value.params[1]\n          && parent.value.params[1].name === node.name\n        ) {\n          return true;\n        }\n        scope = scope.upper;\n      }\n\n      return false;\n    }\n\n    // Returns true if the given node is possibly a reference to `this.state` or the state parameter of\n    // a lifecycle method.\n    function isStateReference(node) {\n      node = uncast(node);\n\n      const isDirectStateReference = node.type === 'MemberExpression'\n        && isThisExpression(node.object)\n        && node.property.name === 'state';\n\n      const isAliasedStateReference = node.type === 'Identifier'\n        && classInfo.aliases\n        && classInfo.aliases.has(node.name);\n\n      return isDirectStateReference || isAliasedStateReference || isStateParameterReference(node);\n    }\n\n    // Takes an ObjectExpression node and adds all named Property nodes to the\n    // current set of state fields.\n    function addStateFields(node) {\n      node.properties.filter((prop) => (\n        prop.type === 'Property'\n          && (prop.key.type === 'Literal'\n          || (prop.key.type === 'TemplateLiteral' && prop.key.expressions.length === 0)\n          || (prop.computed === false && prop.key.type === 'Identifier'))\n          && getName(prop.key) !== null\n      )).forEach((prop) => {\n        classInfo.stateFields.add(prop);\n      });\n    }\n\n    // Adds the name of the given node as a used state field if the node is an\n    // Identifier or a Literal. Other node types are ignored.\n    function addUsedStateField(node) {\n      if (!classInfo) {\n        return;\n      }\n      const name = getName(node);\n      if (name) {\n        classInfo.usedStateFields.add(name);\n      }\n    }\n\n    // Records used state fields and new aliases for an ObjectPattern which\n    // destructures `this.state`.\n    function handleStateDestructuring(node) {\n      node.properties.forEach((prop) => {\n        if (prop.type === 'Property') {\n          addUsedStateField(prop.key);\n        } else if (\n          (prop.type === 'ExperimentalRestProperty' || prop.type === 'RestElement')\n          && classInfo.aliases\n        ) {\n          classInfo.aliases.add(getName(prop.argument));\n        }\n      });\n    }\n\n    // Used to record used state fields and new aliases for both\n    // AssignmentExpressions and VariableDeclarators.\n    function handleAssignment(left, right) {\n      const unwrappedRight = astUtil.unwrapTSAsExpression(right);\n\n      switch (left.type) {\n        case 'Identifier':\n          if (isStateReference(unwrappedRight) && classInfo.aliases) {\n            classInfo.aliases.add(left.name);\n          }\n          break;\n        case 'ObjectPattern':\n          if (isStateReference(unwrappedRight)) {\n            handleStateDestructuring(left);\n          } else if (isThisExpression(unwrappedRight) && classInfo.aliases) {\n            left.properties.forEach((prop) => {\n              if (prop.type === 'Property' && getName(prop.key) === 'state') {\n                const name = getName(prop.value);\n                if (name) {\n                  classInfo.aliases.add(name);\n                } else if (prop.value.type === 'ObjectPattern') {\n                  handleStateDestructuring(prop.value);\n                }\n              }\n            });\n          }\n          break;\n        default:\n        // pass\n      }\n    }\n\n    function reportUnusedFields() {\n      // Report all unused state fields.\n      classInfo.stateFields.forEach((node) => {\n        const name = getName(node.key);\n        if (!classInfo.usedStateFields.has(name)) {\n          report(context, messages.unusedStateField, 'unusedStateField', {\n            node,\n            data: {\n              name,\n            },\n          });\n        }\n      });\n    }\n\n    function handleES6ComponentEnter(node) {\n      if (componentUtil.isES6Component(node, context)) {\n        classInfo = getInitialClassInfo();\n      }\n    }\n\n    function handleES6ComponentExit() {\n      if (!classInfo) {\n        return;\n      }\n      reportUnusedFields();\n      classInfo = null;\n    }\n\n    function isGDSFP(node) {\n      const name = getName(node.key);\n      if (\n        !node.static\n        || name !== 'getDerivedStateFromProps'\n        || !node.value\n        || !node.value.params\n        || node.value.params.length < 2 // no `state` argument\n      ) {\n        return false;\n      }\n      return true;\n    }\n\n    return {\n      ClassDeclaration: handleES6ComponentEnter,\n\n      'ClassDeclaration:exit': handleES6ComponentExit,\n\n      ClassExpression: handleES6ComponentEnter,\n\n      'ClassExpression:exit': handleES6ComponentExit,\n\n      ObjectExpression(node) {\n        if (componentUtil.isES5Component(node, context)) {\n          classInfo = getInitialClassInfo();\n        }\n      },\n\n      'ObjectExpression:exit'(node) {\n        if (!classInfo) {\n          return;\n        }\n\n        if (componentUtil.isES5Component(node, context)) {\n          reportUnusedFields();\n          classInfo = null;\n        }\n      },\n\n      CallExpression(node) {\n        if (!classInfo) {\n          return;\n        }\n\n        const unwrappedNode = astUtil.unwrapTSAsExpression(node);\n        const unwrappedArgumentNode = astUtil.unwrapTSAsExpression(unwrappedNode.arguments[0]);\n\n        // If we're looking at a `this.setState({})` invocation, record all the\n        // properties as state fields.\n        if (\n          isSetStateCall(unwrappedNode)\n          && unwrappedNode.arguments.length > 0\n          && unwrappedArgumentNode.type === 'ObjectExpression'\n        ) {\n          addStateFields(unwrappedArgumentNode);\n        } else if (\n          isSetStateCall(unwrappedNode)\n          && unwrappedNode.arguments.length > 0\n          && unwrappedArgumentNode.type === 'ArrowFunctionExpression'\n        ) {\n          const unwrappedBodyNode = astUtil.unwrapTSAsExpression(unwrappedArgumentNode.body);\n\n          if (unwrappedBodyNode.type === 'ObjectExpression') {\n            addStateFields(unwrappedBodyNode);\n          }\n          if (unwrappedArgumentNode.params.length > 0 && classInfo.aliases) {\n            const firstParam = unwrappedArgumentNode.params[0];\n            if (firstParam.type === 'ObjectPattern') {\n              handleStateDestructuring(firstParam);\n            } else {\n              classInfo.aliases.add(getName(firstParam));\n            }\n          }\n        }\n      },\n\n      'ClassProperty, PropertyDefinition'(node) {\n        if (!classInfo) {\n          return;\n        }\n        // If we see state being assigned as a class property using an object\n        // expression, record all the fields of that object as state fields.\n        const unwrappedValueNode = astUtil.unwrapTSAsExpression(node.value);\n\n        const name = getName(node.key);\n        if (\n          name === 'state'\n          && !node.static\n          && unwrappedValueNode\n          && unwrappedValueNode.type === 'ObjectExpression'\n        ) {\n          addStateFields(unwrappedValueNode);\n        }\n\n        if (\n          !node.static\n          && unwrappedValueNode\n          && unwrappedValueNode.type === 'ArrowFunctionExpression'\n        ) {\n          // Create a new set for this.state aliases local to this method.\n          classInfo.aliases = new Set();\n        }\n      },\n\n      'ClassProperty:exit'(node) {\n        if (\n          classInfo\n          && !node.static\n          && node.value\n          && node.value.type === 'ArrowFunctionExpression'\n        ) {\n          // Forget our set of local aliases.\n          classInfo.aliases = null;\n        }\n      },\n\n      'PropertyDefinition, ClassProperty'(node) {\n        if (!isGDSFP(node)) {\n          return;\n        }\n\n        const childScope = getScope(context, node).childScopes.find((x) => x.block === node.value);\n        if (!childScope) {\n          return;\n        }\n        const scope = childScope.variableScope.childScopes.find((x) => x.block === node.value);\n        const stateArg = node.value.params[1]; // probably \"state\"\n        if (!scope || !scope.variables) {\n          return;\n        }\n        const argVar = scope.variables.find((x) => x.name === stateArg.name);\n\n        if (argVar) {\n          const stateRefs = argVar.references;\n\n          stateRefs.forEach((ref) => {\n            const identifier = ref.identifier;\n            if (identifier && identifier.parent && identifier.parent.type === 'MemberExpression') {\n              addUsedStateField(identifier.parent.property);\n            }\n          });\n        }\n      },\n\n      'PropertyDefinition:exit'(node) {\n        if (\n          classInfo\n          && !node.static\n          && node.value\n          && node.value.type === 'ArrowFunctionExpression'\n          && !isGDSFP(node)\n        ) {\n          // Forget our set of local aliases.\n          classInfo.aliases = null;\n        }\n      },\n\n      MethodDefinition() {\n        if (!classInfo) {\n          return;\n        }\n        // Create a new set for this.state aliases local to this method.\n        classInfo.aliases = new Set();\n      },\n\n      'MethodDefinition:exit'() {\n        if (!classInfo) {\n          return;\n        }\n        // Forget our set of local aliases.\n        classInfo.aliases = null;\n      },\n\n      FunctionExpression(node) {\n        if (!classInfo) {\n          return;\n        }\n\n        const parent = node.parent;\n        if (!componentUtil.isES5Component(parent.parent, context)) {\n          return;\n        }\n\n        if (\n          'key' in parent\n          && 'name' in parent.key\n          && parent.key.name === 'getInitialState'\n        ) {\n          const body = node.body.body;\n          const lastBodyNode = body[body.length - 1];\n\n          if (\n            lastBodyNode.type === 'ReturnStatement'\n            && lastBodyNode.argument.type === 'ObjectExpression'\n          ) {\n            addStateFields(lastBodyNode.argument);\n          }\n        } else {\n          // Create a new set for this.state aliases local to this method.\n          classInfo.aliases = new Set();\n        }\n      },\n\n      AssignmentExpression(node) {\n        if (!classInfo) {\n          return;\n        }\n\n        const unwrappedLeft = astUtil.unwrapTSAsExpression(node.left);\n        const unwrappedRight = astUtil.unwrapTSAsExpression(node.right);\n\n        // Check for assignments like `this.state = {}`\n        if (\n          unwrappedLeft.type === 'MemberExpression'\n          && isThisExpression(unwrappedLeft.object)\n          && getName(unwrappedLeft.property) === 'state'\n          && unwrappedRight.type === 'ObjectExpression'\n        ) {\n          // Find the nearest function expression containing this assignment.\n          /** @type {import('eslint').Rule.Node} */\n          let fn = node;\n          while (fn.type !== 'FunctionExpression' && fn.parent) {\n            fn = fn.parent;\n          }\n          // If the nearest containing function is the constructor, then we want\n          // to record all the assigned properties as state fields.\n          if (\n            fn.parent\n            && fn.parent.type === 'MethodDefinition'\n            && fn.parent.kind === 'constructor'\n          ) {\n            addStateFields(unwrappedRight);\n          }\n        } else {\n          // Check for assignments like `alias = this.state` and record the alias.\n          handleAssignment(unwrappedLeft, unwrappedRight);\n        }\n      },\n\n      VariableDeclarator(node) {\n        if (!classInfo || !node.init) {\n          return;\n        }\n        handleAssignment(node.id, node.init);\n      },\n\n      'MemberExpression, OptionalMemberExpression'(node) {\n        if (!classInfo) {\n          return;\n        }\n        if (isStateReference(astUtil.unwrapTSAsExpression(node.object))) {\n          // If we see this.state[foo] access, give up.\n          if (node.computed && node.property.type !== 'Literal') {\n            classInfo = null;\n            return;\n          }\n          // Otherwise, record that we saw this property being accessed.\n          addUsedStateField(node.property);\n        // If we see a `this.state` access in a CallExpression, give up.\n        } else if (isStateReference(node) && astUtil.isCallExpression(node.parent)) {\n          classInfo = null;\n        }\n      },\n\n      JSXSpreadAttribute(node) {\n        if (classInfo && isStateReference(node.argument)) {\n          classInfo = null;\n        }\n      },\n\n      'ExperimentalSpreadProperty, SpreadElement'(node) {\n        if (classInfo && isStateReference(node.argument)) {\n          classInfo = null;\n        }\n      },\n    };\n  },\n};\n"
        }
    ]
}