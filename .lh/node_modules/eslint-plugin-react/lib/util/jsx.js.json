{
    "sourceFile": "node_modules/eslint-plugin-react/lib/util/jsx.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892279343,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Utility functions for JSX\n */\n\n'use strict';\n\nconst elementType = require('jsx-ast-utils/elementType');\n\nconst astUtil = require('./ast');\nconst isCreateElement = require('./isCreateElement');\nconst variableUtil = require('./variable');\n\n// See https://github.com/babel/babel/blob/ce420ba51c68591e057696ef43e028f41c6e04cd/packages/babel-types/src/validators/react/isCompatTag.js\n// for why we only test for the first character\nconst COMPAT_TAG_REGEX = /^[a-z]/;\n\n/**\n * Checks if a node represents a DOM element according to React.\n * @param {object} node - JSXOpeningElement to check.\n * @returns {boolean} Whether or not the node corresponds to a DOM element.\n */\nfunction isDOMComponent(node) {\n  const name = elementType(node);\n  return COMPAT_TAG_REGEX.test(name);\n}\n\n/**\n * Test whether a JSXElement is a fragment\n * @param {JSXElement} node\n * @param {string} reactPragma\n * @param {string} fragmentPragma\n * @returns {boolean}\n */\nfunction isFragment(node, reactPragma, fragmentPragma) {\n  const name = node.openingElement.name;\n\n  // <Fragment>\n  if (name.type === 'JSXIdentifier' && name.name === fragmentPragma) {\n    return true;\n  }\n\n  // <React.Fragment>\n  if (\n    name.type === 'JSXMemberExpression'\n    && name.object.type === 'JSXIdentifier'\n    && name.object.name === reactPragma\n    && name.property.type === 'JSXIdentifier'\n    && name.property.name === fragmentPragma\n  ) {\n    return true;\n  }\n\n  return false;\n}\n\n/**\n * Checks if a node represents a JSX element or fragment.\n * @param {object} node - node to check.\n * @returns {boolean} Whether or not the node if a JSX element or fragment.\n */\nfunction isJSX(node) {\n  return node && ['JSXElement', 'JSXFragment'].indexOf(node.type) >= 0;\n}\n\n/**\n * Check if node is like `key={...}` as in `<Foo key={...} />`\n * @param {ASTNode} node\n * @returns {boolean}\n */\nfunction isJSXAttributeKey(node) {\n  return node.type === 'JSXAttribute'\n    && node.name\n    && node.name.type === 'JSXIdentifier'\n    && node.name.name === 'key';\n}\n\n/**\n * Check if value has only whitespaces\n * @param {unknown} value\n * @returns {boolean}\n */\nfunction isWhiteSpaces(value) {\n  return typeof value === 'string' ? /^\\s*$/.test(value) : false;\n}\n\n/**\n * Check if the node is returning JSX or null\n *\n * @param {Context} context The context of `ASTNode`.\n * @param {ASTNode} ASTnode The AST node being checked\n * @param {boolean} [strict] If true, in a ternary condition the node must return JSX in both cases\n * @param {boolean} [ignoreNull] If true, null return values will be ignored\n * @returns {boolean} True if the node is returning JSX or null, false if not\n */\nfunction isReturningJSX(context, ASTnode, strict, ignoreNull) {\n  const isJSXValue = (node) => {\n    if (!node) {\n      return false;\n    }\n    switch (node.type) {\n      case 'ConditionalExpression':\n        if (strict) {\n          return isJSXValue(node.consequent) && isJSXValue(node.alternate);\n        }\n        return isJSXValue(node.consequent) || isJSXValue(node.alternate);\n      case 'LogicalExpression':\n        if (strict) {\n          return isJSXValue(node.left) && isJSXValue(node.right);\n        }\n        return isJSXValue(node.left) || isJSXValue(node.right);\n      case 'SequenceExpression':\n        return isJSXValue(node.expressions[node.expressions.length - 1]);\n      case 'JSXElement':\n      case 'JSXFragment':\n        return true;\n      case 'CallExpression':\n        return isCreateElement(context, node);\n      case 'Literal':\n        if (!ignoreNull && node.value === null) {\n          return true;\n        }\n        return false;\n      case 'Identifier': {\n        const variable = variableUtil.findVariableByName(context, node, node.name);\n        return isJSX(variable);\n      }\n      default:\n        return false;\n    }\n  };\n\n  let found = false;\n  astUtil.traverseReturns(ASTnode, context, (node, breakTraverse) => {\n    if (isJSXValue(node)) {\n      found = true;\n      breakTraverse();\n    }\n  });\n\n  return found;\n}\n\n/**\n * Check if the node is returning only null values\n *\n * @param {ASTNode} ASTnode The AST node being checked\n * @param {Context} context The context of `ASTNode`.\n * @returns {boolean} True if the node is returning only null values\n */\nfunction isReturningOnlyNull(ASTnode, context) {\n  let found = false;\n  let foundSomethingElse = false;\n  astUtil.traverseReturns(ASTnode, context, (node) => {\n    // Traverse return statement\n    astUtil.traverse(node, {\n      enter(childNode) {\n        const setFound = () => {\n          found = true;\n          this.skip();\n        };\n        const setFoundSomethingElse = () => {\n          foundSomethingElse = true;\n          this.skip();\n        };\n        switch (childNode.type) {\n          case 'ReturnStatement':\n            break;\n          case 'ConditionalExpression':\n            if (childNode.consequent.value === null && childNode.alternate.value === null) {\n              setFound();\n            }\n            break;\n          case 'Literal':\n            if (childNode.value === null) {\n              setFound();\n            }\n            break;\n          default:\n            setFoundSomethingElse();\n        }\n      },\n    });\n  });\n\n  return found && !foundSomethingElse;\n}\n\nmodule.exports = {\n  isDOMComponent,\n  isFragment,\n  isJSX,\n  isJSXAttributeKey,\n  isWhiteSpaces,\n  isReturningJSX,\n  isReturningOnlyNull,\n};\n"
        }
    ]
}