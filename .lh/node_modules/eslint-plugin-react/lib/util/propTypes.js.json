{
    "sourceFile": "node_modules/eslint-plugin-react/lib/util/propTypes.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892279948,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Common propTypes detection functionality.\n */\n\n'use strict';\n\nconst flatMap = require('array.prototype.flatmap');\n\nconst annotations = require('./annotations');\nconst propsUtil = require('./props');\nconst variableUtil = require('./variable');\nconst testFlowVersion = require('./version').testFlowVersion;\nconst propWrapperUtil = require('./propWrapper');\nconst astUtil = require('./ast');\nconst isFirstLetterCapitalized = require('./isFirstLetterCapitalized');\nconst eslintUtil = require('./eslint');\n\nconst getFirstTokens = eslintUtil.getFirstTokens;\nconst getScope = eslintUtil.getScope;\nconst getSourceCode = eslintUtil.getSourceCode;\nconst getText = eslintUtil.getText;\n\n/**\n * Check if node is function type.\n * @param {ASTNode} node\n * @returns {boolean}\n */\nfunction isFunctionType(node) {\n  if (!node) return false;\n  const nodeType = node.type;\n  return nodeType === 'FunctionDeclaration'\n    || nodeType === 'FunctionExpression'\n    || nodeType === 'ArrowFunctionExpression';\n}\n\n/**\n * Checks if we are declaring a props as a generic type in a flow-annotated class.\n *\n * @param {ASTNode} node  the AST node being checked.\n * @returns {boolean} True if the node is a class with generic prop types, false if not.\n */\nfunction isSuperTypeParameterPropsDeclaration(node) {\n  if (node && (node.type === 'ClassDeclaration' || node.type === 'ClassExpression')) {\n    const parameters = propsUtil.getSuperTypeArguments(node);\n    if (parameters && parameters.params.length > 0) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Iterates through a properties node, like a customized forEach.\n * @param {Object} context Array of properties to iterate.\n * @param {Object[]} properties Array of properties to iterate.\n * @param {Function} fn Function to call on each property, receives property key\n    and property value. (key, value) => void\n  * @param {Function} [handleSpreadFn] Function to call on each ObjectTypeSpreadProperty, receives the\n    argument\n */\nfunction iterateProperties(context, properties, fn, handleSpreadFn) {\n  if (properties && properties.length && typeof fn === 'function') {\n    for (let i = 0, j = properties.length; i < j; i++) {\n      const node = properties[i];\n      const key = astUtil.getKeyValue(context, node);\n\n      if (node.type === 'ObjectTypeSpreadProperty' && typeof handleSpreadFn === 'function') {\n        handleSpreadFn(node.argument);\n      }\n\n      const value = node.value;\n      fn(key, value, node);\n    }\n  }\n}\n\n/**\n * Checks if a node is inside a class body.\n *\n * @param {ASTNode} node the AST node being checked.\n * @returns {boolean} True if the node has a ClassBody ancestor, false if not.\n */\nfunction isInsideClassBody(node) {\n  let parent = node.parent;\n  while (parent) {\n    if (parent.type === 'ClassBody') {\n      return true;\n    }\n    parent = parent.parent;\n  }\n  return false;\n}\n\nfunction startWithCapitalizedLetter(node) {\n  return (\n    node.parent.type === 'VariableDeclarator'\n    && !isFirstLetterCapitalized(node.parent.id.name)\n  );\n}\n\nmodule.exports = function propTypesInstructions(context, components, utils) {\n  // Used to track the type annotations in scope.\n  // Necessary because babel's scopes do not track type annotations.\n  let stack = null;\n\n  const classExpressions = [];\n  const defaults = { customValidators: [] };\n  const configuration = Object.assign({}, defaults, context.options[0] || {});\n  const customValidators = configuration.customValidators;\n  const allowedGenericTypes = new Set(['ComponentProps', 'ComponentPropsWithoutRef', 'forwardRef', 'ForwardRefRenderFunction', 'VFC', 'VoidFunctionComponent', 'PropsWithChildren', 'SFC', 'StatelessComponent', 'FunctionComponent', 'FC']);\n  const genericTypeParamIndexWherePropsArePresent = {\n    ComponentProps: 0,\n    ComponentPropsWithoutRef: 0,\n    ForwardRefRenderFunction: 1,\n    forwardRef: 1,\n    VoidFunctionComponent: 0,\n    VFC: 0,\n    PropsWithChildren: 0,\n    SFC: 0,\n    StatelessComponent: 0,\n    FunctionComponent: 0,\n    FC: 0,\n  };\n  const genericReactTypesImport = new Set();\n  // import { FC as X } from 'react' -> localToImportedMap = { x: FC }\n  const localToImportedMap = {};\n\n  /**\n   * Returns the full scope.\n   * @returns {Object} The whole scope.\n   */\n  function typeScope() {\n    return stack[stack.length - 1];\n  }\n\n  /**\n   * Gets a node from the scope.\n   * @param {string} key The name of the identifier to access.\n   * @returns {ASTNode} The ASTNode associated with the given identifier.\n   */\n  function getInTypeScope(key) {\n    return stack[stack.length - 1][key];\n  }\n\n  /**\n   * Sets the new value in the scope.\n   * @param {string} key The name of the identifier to access\n   * @param {ASTNode} value The new value for the identifier.\n   * @returns {ASTNode} The ASTNode associated with the given identifier.\n   */\n  function setInTypeScope(key, value) {\n    stack[stack.length - 1][key] = value;\n    return value;\n  }\n\n  /**\n   * Checks if prop should be validated by plugin-react-proptypes\n   * @param {string} validator Name of validator to check.\n   * @returns {boolean} True if validator should be checked by custom validator.\n   */\n  function hasCustomValidator(validator) {\n    return customValidators.indexOf(validator) !== -1;\n  }\n\n  /* eslint-disable no-use-before-define */\n  /** @type {TypeDeclarationBuilders} */\n  const typeDeclarationBuilders = {\n    GenericTypeAnnotation(annotation, parentName, seen) {\n      if (getInTypeScope(annotation.id.name)) {\n        return buildTypeAnnotationDeclarationTypes(getInTypeScope(annotation.id.name), parentName, seen);\n      }\n      return {};\n    },\n\n    ObjectTypeAnnotation(annotation, parentName, seen) {\n      let containsUnresolvedObjectTypeSpread = false;\n      let containsSpread = false;\n      const containsIndexers = !!annotation.indexers && annotation.indexers.length > 0;\n      const shapeTypeDefinition = {\n        type: 'shape',\n        children: {},\n      };\n      iterateProperties(\n        context,\n        annotation.properties,\n        (childKey, childValue, propNode) => {\n          const fullName = [parentName, childKey].join('.');\n          if (childKey || childValue) {\n            const types = buildTypeAnnotationDeclarationTypes(childValue, fullName, seen);\n            types.fullName = fullName;\n            types.name = childKey;\n            types.node = propNode;\n            types.isRequired = !childValue.optional;\n            shapeTypeDefinition.children[childKey] = types;\n          }\n        },\n        (spreadNode) => {\n          const key = astUtil.getKeyValue(context, spreadNode);\n          const types = buildTypeAnnotationDeclarationTypes(spreadNode, key, seen);\n          if (!types.children) {\n            containsUnresolvedObjectTypeSpread = true;\n          } else {\n            Object.assign(shapeTypeDefinition, types.children);\n          }\n          containsSpread = true;\n        }\n      );\n\n      // Mark if this shape has spread or an indexer. We will know to consider all props from this shape as having propTypes,\n      // but still have the ability to detect unused children of this shape.\n      shapeTypeDefinition.containsUnresolvedSpread = containsUnresolvedObjectTypeSpread;\n      shapeTypeDefinition.containsIndexers = containsIndexers;\n      // Deprecated: containsSpread is not used anymore in the codebase, ensure to keep API backward compatibility\n      shapeTypeDefinition.containsSpread = containsSpread;\n\n      return shapeTypeDefinition;\n    },\n\n    UnionTypeAnnotation(annotation, parentName, seen) {\n      /** @type {UnionTypeDefinition} */\n      const unionTypeDefinition = {\n        type: 'union',\n        children: annotation.types.map((type) => buildTypeAnnotationDeclarationTypes(type, parentName, seen)),\n      };\n      if (unionTypeDefinition.children.length === 0) {\n        // no complex type found, simply accept everything\n        return {};\n      }\n      return unionTypeDefinition;\n    },\n\n    ArrayTypeAnnotation(annotation, parentName, seen) {\n      const fullName = [parentName, '*'].join('.');\n      const child = buildTypeAnnotationDeclarationTypes(annotation.elementType, fullName, seen);\n      child.fullName = fullName;\n      child.name = '__ANY_KEY__';\n      child.node = annotation;\n      return {\n        type: 'object',\n        children: {\n          __ANY_KEY__: child,\n        },\n      };\n    },\n  };\n  /* eslint-enable no-use-before-define */\n\n  /**\n   * Resolve the type annotation for a given node.\n   * Flow annotations are sometimes wrapped in outer `TypeAnnotation`\n   * and `NullableTypeAnnotation` nodes which obscure the annotation we're\n   * interested in.\n   * This method also resolves type aliases where possible.\n   *\n   * @param {ASTNode} node The annotation or a node containing the type annotation.\n   * @returns {ASTNode} The resolved type annotation for the node.\n   */\n  function resolveTypeAnnotation(node) {\n    let annotation = (node.left && node.left.typeAnnotation) || node.typeAnnotation || node;\n    while (annotation && (annotation.type === 'TypeAnnotation' || annotation.type === 'NullableTypeAnnotation')) {\n      annotation = annotation.typeAnnotation;\n    }\n    if (annotation.type === 'GenericTypeAnnotation' && getInTypeScope(annotation.id.name)) {\n      return getInTypeScope(annotation.id.name);\n    }\n    return annotation;\n  }\n\n  /**\n   * Creates the representation of the React props type annotation for the component.\n   * The representation is used to verify nested used properties.\n   * @param {ASTNode} annotation Type annotation for the props class property.\n   * @param {string} parentName\n   * @param {Set<ASTNode>} [seen]\n   * @return {Object} The representation of the declaration, empty object means\n   *    the property is declared without the need for further analysis.\n   */\n  function buildTypeAnnotationDeclarationTypes(annotation, parentName, seen) {\n    if (typeof seen === 'undefined') {\n      // Keeps track of annotations we've already seen to\n      // prevent problems with recursive types.\n      seen = new Set();\n    }\n    if (seen.has(annotation)) {\n      // This must be a recursive type annotation, so just accept anything.\n      return {};\n    }\n    seen.add(annotation);\n\n    if (annotation.type in typeDeclarationBuilders) {\n      return typeDeclarationBuilders[annotation.type](annotation, parentName, seen);\n    }\n    return {};\n  }\n\n  /**\n   * Marks all props found inside ObjectTypeAnnotation as declared.\n   *\n   * Modifies the declaredProperties object\n   * @param {ASTNode} propTypes\n   * @param {Object} declaredPropTypes\n   * @returns {boolean} True if propTypes should be ignored (e.g. when a type can't be resolved, when it is imported)\n   */\n  function declarePropTypesForObjectTypeAnnotation(propTypes, declaredPropTypes) {\n    let ignorePropsValidation = false;\n\n    iterateProperties(context, propTypes.properties, (key, value, propNode) => {\n      if (!value) {\n        ignorePropsValidation = ignorePropsValidation || propNode.type !== 'ObjectTypeSpreadProperty';\n        return;\n      }\n\n      const types = buildTypeAnnotationDeclarationTypes(value, key);\n      types.fullName = key;\n      types.name = key;\n      types.node = propNode;\n      types.isRequired = !propNode.optional;\n      declaredPropTypes[key] = types;\n    }, (spreadNode) => {\n      const key = astUtil.getKeyValue(context, spreadNode);\n      const spreadAnnotation = getInTypeScope(key);\n      if (!spreadAnnotation) {\n        ignorePropsValidation = true;\n      } else {\n        const spreadIgnoreValidation = declarePropTypesForObjectTypeAnnotation(spreadAnnotation, declaredPropTypes);\n        ignorePropsValidation = ignorePropsValidation || spreadIgnoreValidation;\n      }\n    });\n\n    return ignorePropsValidation;\n  }\n\n  /**\n   * Marks all props found inside IntersectionTypeAnnotation as declared.\n   * Since InterSectionTypeAnnotations can be nested, this handles recursively.\n   *\n   * Modifies the declaredPropTypes object\n   * @param {ASTNode} propTypes\n   * @param {Object} declaredPropTypes\n   * @returns {boolean} True if propTypes should be ignored (e.g. when a type can't be resolved, when it is imported)\n   */\n  function declarePropTypesForIntersectionTypeAnnotation(propTypes, declaredPropTypes) {\n    return propTypes.types.some((annotation) => {\n      if (annotation.type === 'ObjectTypeAnnotation') {\n        return declarePropTypesForObjectTypeAnnotation(annotation, declaredPropTypes);\n      }\n\n      if (annotation.type === 'UnionTypeAnnotation') {\n        return true;\n      }\n\n      // Type can't be resolved\n      if (!annotation.id) {\n        return true;\n      }\n\n      const typeNode = getInTypeScope(annotation.id.name);\n\n      if (!typeNode) {\n        return true;\n      }\n      if (typeNode.type === 'IntersectionTypeAnnotation') {\n        return declarePropTypesForIntersectionTypeAnnotation(typeNode, declaredPropTypes);\n      }\n\n      return declarePropTypesForObjectTypeAnnotation(typeNode, declaredPropTypes);\n    });\n  }\n\n  /**\n   * Resolve node of type Identifier when building declaration types.\n   * @param {ASTNode} node\n   * @param {ASTNode} rootNode\n   * @param {Function} callback called with the resolved value only if resolved.\n   */\n  function resolveValueForIdentifierNode(node, rootNode, callback) {\n    if (\n      rootNode\n      && node\n      && node.type === 'Identifier'\n    ) {\n      const scope = getScope(context, rootNode);\n      const identVariable = scope.variableScope.variables.find(\n        (variable) => variable.name === node.name\n      );\n      if (identVariable) {\n        const definition = identVariable.defs[identVariable.defs.length - 1];\n        callback(definition.node.init);\n      }\n    }\n  }\n\n  /**\n   * Creates the representation of the React propTypes for the component.\n   * The representation is used to verify nested used properties.\n   * @param {ASTNode} value Node of the PropTypes for the desired property\n   * @param {string} parentName\n   * @param {ASTNode} rootNode\n   * @return {Object} The representation of the declaration, empty object means\n   *    the property is declared without the need for further analysis.\n   */\n  function buildReactDeclarationTypes(value, parentName, rootNode) {\n    if (\n      value\n      && value.callee\n      && value.callee.object\n      && hasCustomValidator(value.callee.object.name)\n    ) {\n      return {};\n    }\n\n    let identNodeResolved = false;\n    // Resolve identifier node for cases where isRequired is set in\n    // the variable declaration or not at all.\n    // const variableType = PropTypes.shape({ foo: ... }).isRequired\n    // propTypes = {\n    //   example: variableType\n    // }\n    // --------\n    // const variableType = PropTypes.shape({ foo: ... })\n    // propTypes = {\n    //   example: variableType\n    // }\n    resolveValueForIdentifierNode(value, rootNode, (newValue) => {\n      identNodeResolved = true;\n      value = newValue;\n    });\n\n    if (\n      value\n      && value.type === 'MemberExpression'\n      && value.property\n      && value.property.name === 'isRequired'\n    ) {\n      value = value.object;\n    }\n\n    // Resolve identifier node for cases where isRequired is set in\n    // the prop types.\n    // const variableType = PropTypes.shape({ foo: ... })\n    // propTypes = {\n    //   example: variableType.isRequired\n    // }\n    if (!identNodeResolved) {\n      resolveValueForIdentifierNode(value, rootNode, (newValue) => {\n        value = newValue;\n      });\n    }\n\n    // Verify PropTypes that are functions\n    if (\n      astUtil.isCallExpression(value)\n      && value.callee\n      && value.callee.property\n      && value.callee.property.name\n      && value.arguments\n      && value.arguments.length > 0\n    ) {\n      const callName = value.callee.property.name;\n      const argument = value.arguments[0];\n      switch (callName) {\n        case 'shape':\n        case 'exact': {\n          if (argument.type !== 'ObjectExpression') {\n            // Invalid proptype or cannot analyse statically\n            return {};\n          }\n          const shapeTypeDefinition = {\n            type: callName,\n            children: {},\n          };\n          iterateProperties(context, argument.properties, (childKey, childValue, propNode) => {\n            if (childValue) { // skip spread propTypes\n              const fullName = [parentName, childKey].join('.');\n              const types = buildReactDeclarationTypes(childValue, fullName, rootNode);\n              types.fullName = fullName;\n              types.name = childKey;\n              types.node = propNode;\n              shapeTypeDefinition.children[childKey] = types;\n            }\n          });\n          return shapeTypeDefinition;\n        }\n        case 'arrayOf':\n        case 'objectOf': {\n          const fullName = [parentName, '*'].join('.');\n          const child = buildReactDeclarationTypes(argument, fullName, rootNode);\n          child.fullName = fullName;\n          child.name = '__ANY_KEY__';\n          child.node = argument;\n          return {\n            type: 'object',\n            children: {\n              __ANY_KEY__: child,\n            },\n          };\n        }\n        case 'oneOfType': {\n          if (\n            !argument.elements\n            || argument.elements.length === 0\n          ) {\n            // Invalid proptype or cannot analyse statically\n            return {};\n          }\n\n          /** @type {UnionTypeDefinition} */\n          const unionTypeDefinition = {\n            type: 'union',\n            children: argument.elements.map((element) => buildReactDeclarationTypes(element, parentName, rootNode)),\n          };\n          if (unionTypeDefinition.children.length === 0) {\n            // no complex type found, simply accept everything\n            return {};\n          }\n          return unionTypeDefinition;\n        }\n        default:\n          return {};\n      }\n    }\n    // Unknown property or accepts everything (any, object, ...)\n    return {};\n  }\n\n  function isValidReactGenericTypeAnnotation(annotation) {\n    if (annotation.typeName) {\n      if (annotation.typeName.name) { // if FC<Props>\n        const typeName = annotation.typeName.name;\n        if (!genericReactTypesImport.has(typeName)) {\n          return false;\n        }\n      } else if (annotation.typeName.right.name) { // if React.FC<Props>\n        const right = annotation.typeName.right.name;\n        const left = annotation.typeName.left.name;\n\n        if (!genericReactTypesImport.has(left) || !allowedGenericTypes.has(right)) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Returns the left most typeName of a node, e.g: FC<Props>, React.FC<Props>\n   * The representation is used to verify nested used properties.\n   * @param {ASTNode} node\n   * @return {string | undefined}\n   */\n  function getLeftMostTypeName(node) {\n    if (node.name) return node.name;\n    if (node.left) return getLeftMostTypeName(node.left);\n  }\n\n  function getRightMostTypeName(node) {\n    if (node.name) return node.name;\n    if (node.right) return getRightMostTypeName(node.right);\n  }\n\n  /**\n   * Returns true if the node is either a interface or type alias declaration\n   * @param {ASTNode} node\n   * @return {boolean}\n   */\n  function filterInterfaceOrTypeAlias(node) {\n    return (\n      astUtil.isTSInterfaceDeclaration(node) || astUtil.isTSTypeAliasDeclaration(node)\n    );\n  }\n\n  /**\n   * Returns true if the interface or type alias declaration node name matches the type-name str\n   * @param {ASTNode} node\n   * @param {string} typeName\n   * @return {boolean}\n   */\n  function filterInterfaceOrAliasByName(node, typeName) {\n    return (\n      node.id\n      && node.id.name === typeName\n    ) || (\n      node.declaration\n      && node.declaration.id\n      && node.declaration.id.name === typeName\n    );\n  }\n\n  class DeclarePropTypesForTSTypeAnnotation {\n    constructor(propTypes, declaredPropTypes, rootNode) {\n      this.propTypes = propTypes;\n      this.declaredPropTypes = declaredPropTypes;\n      this.foundDeclaredPropertiesList = [];\n      this.referenceNameMap = new Set();\n      this.sourceCode = getSourceCode(context);\n      this.shouldIgnorePropTypes = false;\n      this.rootNode = rootNode;\n      this.visitTSNode(this.propTypes);\n      this.endAndStructDeclaredPropTypes();\n    }\n\n    /**\n     * The node will be distribute to different function.\n     * @param {ASTNode} node\n     */\n    visitTSNode(node) {\n      if (!node) return;\n      if (astUtil.isTSTypeAnnotation(node)) {\n        const typeAnnotation = node.typeAnnotation;\n        this.visitTSNode(typeAnnotation);\n      } else if (astUtil.isTSTypeReference(node)) {\n        this.searchDeclarationByName(node);\n      } else if (astUtil.isTSInterfaceHeritage(node)) {\n        this.searchDeclarationByName(node);\n      } else if (astUtil.isTSTypeLiteral(node)) {\n        // Check node is an object literal\n        if (Array.isArray(node.members)) {\n          this.foundDeclaredPropertiesList = this.foundDeclaredPropertiesList.concat(node.members);\n        }\n      } else if (astUtil.isTSIntersectionType(node)) {\n        this.convertIntersectionTypeToPropTypes(node);\n      } else if (astUtil.isTSParenthesizedType(node)) {\n        const typeAnnotation = node.typeAnnotation;\n        this.visitTSNode(typeAnnotation);\n      } else if (astUtil.isTSTypeParameterInstantiation(node)) {\n        if (Array.isArray(node.params)) {\n          node.params.forEach((x) => this.visitTSNode(x));\n        }\n      } else {\n        this.shouldIgnorePropTypes = true;\n      }\n    }\n\n    /**\n     * Search TSInterfaceDeclaration or TSTypeAliasDeclaration,\n     * by using TSTypeReference and TSInterfaceHeritage name.\n     * @param {ASTNode} node\n     */\n    searchDeclarationByName(node) {\n      let typeName;\n      if (astUtil.isTSTypeReference(node)) {\n        typeName = node.typeName.name;\n        const leftMostName = getLeftMostTypeName(node.typeName);\n        const shouldTraverseTypeParams = genericReactTypesImport.has(leftMostName);\n        const nodeTypeArguments = propsUtil.getTypeArguments(node);\n        if (shouldTraverseTypeParams && nodeTypeArguments && nodeTypeArguments.length !== 0) {\n          // All react Generic types are derived from:\n          // type PropsWithChildren<P> = P & { children?: ReactNode | undefined }\n          // So we should construct an optional children prop\n          this.shouldSpecifyOptionalChildrenProps = true;\n\n          const rightMostName = getRightMostTypeName(node.typeName);\n          if (\n            leftMostName === 'React'\n            && (\n              rightMostName === 'HTMLAttributes'\n              || rightMostName === 'HTMLElement'\n              || rightMostName === 'HTMLProps'\n            )\n          ) {\n            this.shouldSpecifyClassNameProp = true;\n          }\n\n          const importedName = localToImportedMap[rightMostName];\n          const idx = genericTypeParamIndexWherePropsArePresent[\n            leftMostName !== rightMostName ? rightMostName : importedName\n          ];\n          const nextNode = nodeTypeArguments.params[idx];\n          this.visitTSNode(nextNode);\n          return;\n        }\n      } else if (astUtil.isTSInterfaceHeritage(node)) {\n        if (!node.expression && node.id) {\n          typeName = node.id.name;\n        } else {\n          typeName = node.expression.name;\n        }\n      }\n      if (!typeName) {\n        this.shouldIgnorePropTypes = true;\n        return;\n      }\n      if (typeName === 'ReturnType') {\n        this.convertReturnTypeToPropTypes(node, this.rootNode);\n        return;\n      }\n      // Prevent recursive inheritance will cause maximum callstack.\n      if (this.referenceNameMap.has(typeName)) {\n        this.shouldIgnorePropTypes = true;\n        return;\n      }\n      // Add typeName to Set and consider it as traversed.\n      this.referenceNameMap.add(typeName);\n\n      /**\n       * From line 577 to line 581, and line 588 to line 590 are trying to handle typescript-eslint-parser\n       * Need to be deprecated after remove typescript-eslint-parser support.\n       */\n      const candidateTypes = this.sourceCode.ast.body.filter((item) => astUtil.isTSTypeDeclaration(item));\n\n      const declarations = flatMap(\n        candidateTypes,\n        (type) => (\n          type.declarations\n          || (\n            type.declaration\n            && type.declaration.declarations\n          )\n          || type.declaration\n        )\n      );\n\n      // we tried to find either an interface or a type with the TypeReference name\n      const typeDeclaration = declarations.filter((dec) => dec.id.name === typeName);\n\n      const interfaceDeclarations = this.sourceCode.ast.body\n        .filter(filterInterfaceOrTypeAlias)\n        .filter((item) => filterInterfaceOrAliasByName(item, typeName))\n        .map((item) => (item.declaration || item));\n\n      if (typeDeclaration.length !== 0) {\n        typeDeclaration.map((t) => t.init || t.typeAnnotation).forEach(this.visitTSNode, this);\n      } else if (interfaceDeclarations.length !== 0) {\n        interfaceDeclarations.forEach(this.traverseDeclaredInterfaceOrTypeAlias, this);\n      } else {\n        this.shouldIgnorePropTypes = true;\n      }\n    }\n\n    /**\n     * Traverse TSInterfaceDeclaration and TSTypeAliasDeclaration\n     * which retrieve from function searchDeclarationByName;\n     * @param {ASTNode} node\n     */\n    traverseDeclaredInterfaceOrTypeAlias(node) {\n      if (astUtil.isTSInterfaceDeclaration(node)) {\n        // Handle TSInterfaceDeclaration interface Props { name: string, id: number}, should put in properties list directly;\n        this.foundDeclaredPropertiesList = this.foundDeclaredPropertiesList.concat(node.body.body);\n      }\n      // Handle TSTypeAliasDeclaration type Props = {name:string}\n      if (astUtil.isTSTypeAliasDeclaration(node)) {\n        const typeAnnotation = node.typeAnnotation;\n        this.visitTSNode(typeAnnotation);\n      }\n      if (Array.isArray(node.extends)) {\n        node.extends.forEach((x) => this.visitTSNode(x));\n        // This line is trying to handle typescript-eslint-parser\n        // typescript-eslint-parser extension is name as heritage\n      } else if (Array.isArray(node.heritage)) {\n        node.heritage.forEach((x) => this.visitTSNode(x));\n      }\n    }\n\n    convertIntersectionTypeToPropTypes(node) {\n      if (!node) return;\n      if (Array.isArray(node.types)) {\n        node.types.forEach((x) => this.visitTSNode(x));\n      } else {\n        this.shouldIgnorePropTypes = true;\n      }\n    }\n\n    convertReturnTypeToPropTypes(node, rootNode) {\n      // ReturnType<T> should always have one parameter\n      const nodeTypeArguments = propsUtil.getTypeArguments(node);\n      if (nodeTypeArguments) {\n        if (nodeTypeArguments.params.length === 1) {\n          let returnType = nodeTypeArguments.params[0];\n          // This line is trying to handle typescript-eslint-parser\n          // typescript-eslint-parser TSTypeQuery is wrapped by TSTypeReference\n          if (astUtil.isTSTypeReference(returnType)) {\n            returnType = returnType.typeName;\n          }\n          // Handle ReturnType<typeof mapStateToProps>\n          if (astUtil.isTSTypeQuery(returnType)) {\n            const returnTypeFunction = flatMap(this.sourceCode.ast.body\n              .filter((item) => item.type === 'VariableDeclaration'\n                && item.declarations.find((dec) => dec.id.name === returnType.exprName.name)\n              ), (type) => type.declarations).map((dec) => dec.init);\n\n            if (Array.isArray(returnTypeFunction)) {\n              if (returnTypeFunction.length === 0) {\n                // Cannot find identifier in current scope. It might be an exported type.\n                this.shouldIgnorePropTypes = true;\n                return;\n              }\n              returnTypeFunction.forEach((func) => {\n                if (isFunctionType(func)) {\n                  let res = func.body;\n                  if (res.type === 'BlockStatement') {\n                    res = astUtil.findReturnStatement(func);\n                    if (res) {\n                      res = res.argument;\n                    }\n                  }\n                  switch (res.type) {\n                    case 'ObjectExpression':\n                      iterateProperties(context, res.properties, (key, value, propNode) => {\n                        if (propNode && astUtil.isCallExpression(propNode.argument)) {\n                          const propNodeTypeArguments = propsUtil.getTypeArguments(propNode.argument);\n                          if (propNodeTypeArguments) {\n                            this.visitTSNode(propNodeTypeArguments);\n                          } else {\n                            // Ignore this CallExpression return value since it doesn't have any typeParameters to let us know it's types.\n                            this.shouldIgnorePropTypes = true;\n                            return;\n                          }\n                        }\n                        if (!value) {\n                          this.shouldIgnorePropTypes = true;\n                          return;\n                        }\n                        const types = buildReactDeclarationTypes(value, key, rootNode);\n                        types.fullName = key;\n                        types.name = key;\n                        types.node = propNode;\n                        types.isRequired = propsUtil.isRequiredPropType(value);\n                        this.declaredPropTypes[key] = types;\n                      });\n                      break;\n                    case 'CallExpression':\n                      if (propsUtil.getTypeArguments(res)) {\n                        this.visitTSNode(propsUtil.getTypeArguments(res));\n                      } else {\n                        // Ignore this CallExpression return value since it doesn't have any typeParameters to let us know it's types.\n                        this.shouldIgnorePropTypes = true;\n                      }\n                      break;\n                    default:\n                  }\n                }\n              });\n              return;\n            }\n          }\n          // Handle ReturnType<()=>returnType>\n          if (astUtil.isTSFunctionType(returnType)) {\n            if (astUtil.isTSTypeAnnotation(returnType.returnType)) {\n              this.visitTSNode(returnType.returnType);\n              return;\n            }\n            // This line is trying to handle typescript-eslint-parser\n            // typescript-eslint-parser TSFunction name returnType as typeAnnotation\n            if (astUtil.isTSTypeAnnotation(returnType.typeAnnotation)) {\n              this.visitTSNode(returnType.typeAnnotation);\n              return;\n            }\n          }\n        }\n      }\n      this.shouldIgnorePropTypes = true;\n    }\n\n    endAndStructDeclaredPropTypes() {\n      if (this.shouldSpecifyOptionalChildrenProps) {\n        this.declaredPropTypes.children = {\n          fullName: 'children',\n          name: 'children',\n          isRequired: false,\n        };\n      }\n      if (this.shouldSpecifyClassNameProp) {\n        this.declaredPropTypes.className = {\n          fullName: 'className',\n          name: 'className',\n          isRequired: false,\n        };\n      }\n\n      this.foundDeclaredPropertiesList.forEach((tsInterfaceBody) => {\n        if (tsInterfaceBody && (tsInterfaceBody.type === 'TSPropertySignature' || tsInterfaceBody.type === 'TSMethodSignature')) {\n          let accessor = 'name';\n          if (tsInterfaceBody.key.type === 'Literal') {\n            if (typeof tsInterfaceBody.key.value === 'number') {\n              accessor = 'raw';\n            } else {\n              accessor = 'value';\n            }\n          }\n          this.declaredPropTypes[tsInterfaceBody.key[accessor]] = {\n            fullName: tsInterfaceBody.key[accessor],\n            name: tsInterfaceBody.key[accessor],\n            node: tsInterfaceBody,\n            isRequired: !tsInterfaceBody.optional,\n          };\n        }\n      });\n    }\n  }\n\n  /**\n   * Mark a prop type as declared\n   * @param {ASTNode} node The AST node being checked.\n   * @param {ASTNode} propTypes The AST node containing the proptypes\n   * @param {ASTNode} rootNode\n   */\n  function markPropTypesAsDeclared(node, propTypes, rootNode) {\n    let componentNode = node;\n    while (componentNode && !components.get(componentNode)) {\n      componentNode = componentNode.parent;\n    }\n    const component = components.get(componentNode);\n    let declaredPropTypes = (component && component.declaredPropTypes) || {};\n    let ignorePropsValidation = (component && component.ignorePropsValidation) || false;\n    switch (propTypes && propTypes.type) {\n      case 'ObjectTypeAnnotation':\n        ignorePropsValidation = declarePropTypesForObjectTypeAnnotation(propTypes, declaredPropTypes);\n        break;\n      case 'ObjectExpression':\n        iterateProperties(context, propTypes.properties, (key, value, propNode) => {\n          if (!value) {\n            ignorePropsValidation = true;\n            return;\n          }\n          const types = buildReactDeclarationTypes(value, key, rootNode);\n          types.fullName = key;\n          types.name = key;\n          types.node = propNode;\n          types.isRequired = propsUtil.isRequiredPropType(value);\n          declaredPropTypes[key] = types;\n        });\n        break;\n      case 'MemberExpression': {\n        let curDeclaredPropTypes = declaredPropTypes;\n        // Walk the list of properties, until we reach the assignment\n        // ie: ClassX.propTypes.a.b.c = ...\n        while (\n          propTypes\n          && propTypes.parent\n          && propTypes.parent.type !== 'AssignmentExpression'\n          && propTypes.property\n          && curDeclaredPropTypes\n        ) {\n          const propName = propTypes.property.name;\n          if (propName in curDeclaredPropTypes) {\n            curDeclaredPropTypes = curDeclaredPropTypes[propName].children;\n            propTypes = propTypes.parent;\n          } else {\n            // This will crash at runtime because we haven't seen this key before\n            // stop this and do not declare it\n            propTypes = null;\n          }\n        }\n        if (propTypes && propTypes.parent && propTypes.property) {\n          if (!(propTypes === propTypes.parent.left && propTypes.parent.left.object)) {\n            ignorePropsValidation = true;\n            break;\n          }\n          const parentProp = getText(context, propTypes.parent.left.object).replace(/^.*\\.propTypes\\./, '');\n          const types = buildReactDeclarationTypes(\n            propTypes.parent.right,\n            parentProp,\n            rootNode\n          );\n\n          types.name = propTypes.property.name;\n          types.fullName = [parentProp, propTypes.property.name].join('.');\n          types.node = propTypes.parent;\n          types.isRequired = propsUtil.isRequiredPropType(propTypes.parent.right);\n          curDeclaredPropTypes[propTypes.property.name] = types;\n        } else {\n          let isUsedInPropTypes = false;\n          let n = propTypes;\n          while (n) {\n            if (((n.type === 'AssignmentExpression') && propsUtil.isPropTypesDeclaration(n.left))\n              || ((n.type === 'ClassProperty' || n.type === 'PropertyDefinition' || n.type === 'Property') && propsUtil.isPropTypesDeclaration(n))) {\n              // Found a propType used inside of another propType. This is not considered usage, we'll still validate\n              // this component.\n              isUsedInPropTypes = true;\n              break;\n            }\n            n = n.parent;\n          }\n          if (!isUsedInPropTypes) {\n            ignorePropsValidation = true;\n          }\n        }\n        break;\n      }\n      case 'Identifier': {\n        const firstMatchingVariable = variableUtil.getVariableFromContext(context, node, propTypes.name);\n        if (firstMatchingVariable) {\n          const defInScope = firstMatchingVariable.defs[firstMatchingVariable.defs.length - 1];\n          markPropTypesAsDeclared(node, defInScope.node && defInScope.node.init, rootNode);\n          return;\n        }\n        ignorePropsValidation = true;\n        break;\n      }\n      case 'CallExpression': {\n        if (\n          propWrapperUtil.isPropWrapperFunction(\n            context,\n            getText(context, propTypes.callee)\n          )\n          && propTypes.arguments && propTypes.arguments[0]\n        ) {\n          markPropTypesAsDeclared(node, propTypes.arguments[0], rootNode);\n          return;\n        }\n        break;\n      }\n      case 'IntersectionTypeAnnotation':\n        ignorePropsValidation = declarePropTypesForIntersectionTypeAnnotation(propTypes, declaredPropTypes);\n        break;\n      case 'GenericTypeAnnotation':\n        if (propTypes.id.name === '$ReadOnly') {\n          const propTypeArguments = propsUtil.getTypeArguments(propTypes);\n          ignorePropsValidation = declarePropTypesForObjectTypeAnnotation(\n            propTypeArguments.params[0],\n            declaredPropTypes\n          );\n        } else {\n          ignorePropsValidation = true;\n        }\n        break;\n      case 'TSTypeReference':\n      case 'TSTypeAnnotation': {\n        const tsTypeAnnotation = new DeclarePropTypesForTSTypeAnnotation(propTypes, declaredPropTypes, rootNode);\n        ignorePropsValidation = tsTypeAnnotation.shouldIgnorePropTypes;\n        declaredPropTypes = tsTypeAnnotation.declaredPropTypes;\n      }\n        break;\n      case null:\n        break;\n      default:\n        ignorePropsValidation = true;\n        break;\n    }\n\n    components.set(node, {\n      declaredPropTypes,\n      ignorePropsValidation,\n    });\n  }\n\n  /**\n   * @param {ASTNode} node We expect either an ArrowFunctionExpression,\n   *   FunctionDeclaration, or FunctionExpression\n   * @param {ASTNode} rootNode\n   */\n  function markAnnotatedFunctionArgumentsAsDeclared(node, rootNode) {\n    if (!node.params || !node.params.length) {\n      return;\n    }\n\n    let propTypesArguments = null;\n    if (node.parent) {\n      propTypesArguments = propsUtil.getTypeArguments(node.parent);\n    }\n\n    if (\n      node.parent\n      && node.parent.callee\n      && propTypesArguments\n      && propTypesArguments.params\n      && (\n        node.parent.callee.name === 'forwardRef' || (\n          node.parent.callee.object\n          && node.parent.callee.property\n          && node.parent.callee.object.name === 'React'\n          && node.parent.callee.property.name === 'forwardRef'\n        )\n      )\n    ) {\n      const declaredPropTypes = {};\n      const obj = new DeclarePropTypesForTSTypeAnnotation(propTypesArguments.params[1], declaredPropTypes, rootNode);\n      components.set(node, {\n        declaredPropTypes: obj.declaredPropTypes,\n        ignorePropsValidation: obj.shouldIgnorePropTypes,\n      });\n      return;\n    }\n\n    const siblingIdentifier = node.parent && node.parent.id;\n    const siblingHasTypeAnnotation = siblingIdentifier && siblingIdentifier.typeAnnotation;\n    const isNodeAnnotated = annotations.isAnnotatedFunctionPropsDeclaration(node, context);\n\n    if (!isNodeAnnotated && !siblingHasTypeAnnotation) {\n      return;\n    }\n\n    // https://github.com/jsx-eslint/eslint-plugin-react/issues/2784\n    if (isInsideClassBody(node) && !astUtil.isFunction(node)) {\n      return;\n    }\n\n    // Should ignore function that not return JSXElement\n    if (!utils.isReturningJSXOrNull(node) || startWithCapitalizedLetter(node)) {\n      return;\n    }\n\n    if (isNodeAnnotated) {\n      const param = node.params[0];\n      if (param.typeAnnotation && param.typeAnnotation.typeAnnotation && param.typeAnnotation.typeAnnotation.type === 'UnionTypeAnnotation') {\n        param.typeAnnotation.typeAnnotation.types.forEach((annotation) => {\n          if (annotation.type === 'GenericTypeAnnotation') {\n            markPropTypesAsDeclared(node, resolveTypeAnnotation(annotation), rootNode);\n          } else {\n            markPropTypesAsDeclared(node, annotation, rootNode);\n          }\n        });\n      } else {\n        markPropTypesAsDeclared(node, resolveTypeAnnotation(param), rootNode);\n      }\n    } else {\n      // implements what's discussed here: https://github.com/jsx-eslint/eslint-plugin-react/issues/2777#issuecomment-683944481\n      const annotation = siblingIdentifier.typeAnnotation.typeAnnotation;\n\n      if (\n        annotation\n        && annotation.type !== 'TSTypeReference'\n        && propsUtil.getTypeArguments(annotation) == null\n      ) {\n        return;\n      }\n\n      if (!isValidReactGenericTypeAnnotation(annotation)) return;\n\n      markPropTypesAsDeclared(node, resolveTypeAnnotation(siblingIdentifier), rootNode);\n    }\n  }\n\n  /**\n   * Resolve the type annotation for a given class declaration node.\n   *\n   * @param {ASTNode} node The annotation or a node containing the type annotation.\n   * @returns {ASTNode} The resolved type annotation for the node.\n   */\n  function resolveSuperParameterPropsType(node) {\n    let propsParameterPosition;\n    const parameters = propsUtil.getSuperTypeArguments(node);\n\n    try {\n      // Flow <=0.52 had 3 required TypedParameters of which the second one is the Props.\n      // Flow >=0.53 has 2 optional TypedParameters of which the first one is the Props.\n      propsParameterPosition = testFlowVersion(context, '>= 0.53.0') ? 0 : 1;\n    } catch (e) {\n      // In case there is no flow version defined, we can safely assume that when there are 3 Props we are dealing with version <= 0.52\n      propsParameterPosition = parameters.params.length <= 2 ? 0 : 1;\n    }\n\n    let annotation = parameters.params[propsParameterPosition];\n    while (annotation && (annotation.type === 'TypeAnnotation' || annotation.type === 'NullableTypeAnnotation')) {\n      annotation = annotation.typeAnnotation;\n    }\n\n    if (annotation && annotation.type === 'GenericTypeAnnotation' && getInTypeScope(annotation.id.name)) {\n      return getInTypeScope(annotation.id.name);\n    }\n    return annotation;\n  }\n\n  /**\n   * Checks if we are declaring a `props` class property with a flow type annotation.\n   * @param {ASTNode} node The AST node being checked.\n   * @returns {boolean} True if the node is a type annotated props declaration, false if not.\n   */\n  function isAnnotatedClassPropsDeclaration(node) {\n    if (node && (node.type === 'ClassProperty' || node.type === 'PropertyDefinition')) {\n      const tokens = getFirstTokens(context, node, 2);\n      if (\n        node.typeAnnotation && (\n          tokens[0].value === 'props'\n          || (tokens[1] && tokens[1].value === 'props')\n        )\n      ) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  return {\n    ClassExpression(node) {\n      // TypeParameterDeclaration need to be added to typeScope in order to handle ClassExpressions.\n      // This visitor is executed before TypeParameterDeclaration are scoped, therefore we postpone\n      // processing class expressions until when the program exists.\n      classExpressions.push(node);\n    },\n\n    ClassDeclaration(node) {\n      if (isSuperTypeParameterPropsDeclaration(node)) {\n        markPropTypesAsDeclared(node, resolveSuperParameterPropsType(node), node);\n      }\n    },\n\n    'ClassProperty, PropertyDefinition'(node) {\n      if (isAnnotatedClassPropsDeclaration(node)) {\n        markPropTypesAsDeclared(node, resolveTypeAnnotation(node), node);\n      } else if (propsUtil.isPropTypesDeclaration(node)) {\n        markPropTypesAsDeclared(node, node.value, node);\n      }\n    },\n\n    ObjectExpression(node) {\n      // Search for the proptypes declaration\n      node.properties.forEach((property) => {\n        if (!propsUtil.isPropTypesDeclaration(property)) {\n          return;\n        }\n        markPropTypesAsDeclared(node, property.value, node);\n      });\n    },\n\n    FunctionExpression(node) {\n      if (node.parent.type !== 'MethodDefinition') {\n        markAnnotatedFunctionArgumentsAsDeclared(node, node);\n      }\n    },\n\n    ImportDeclaration(node) {\n      // parse `import ... from 'react`\n      if (node.source.value === 'react') {\n        node.specifiers.forEach((specifier) => {\n          if (\n            // handles import * as X from 'react'\n            specifier.type === 'ImportNamespaceSpecifier'\n            // handles import React from 'react'\n            || specifier.type === 'ImportDefaultSpecifier'\n          ) {\n            genericReactTypesImport.add(specifier.local.name);\n          }\n\n          // handles import { FC } from 'react' or import { FC as X } from 'react'\n          if (specifier.type === 'ImportSpecifier' && allowedGenericTypes.has(specifier.imported.name)) {\n            genericReactTypesImport.add(specifier.local.name);\n            localToImportedMap[specifier.local.name] = specifier.imported.name;\n          }\n        });\n      }\n    },\n\n    FunctionDeclaration: markAnnotatedFunctionArgumentsAsDeclared,\n\n    ArrowFunctionExpression: markAnnotatedFunctionArgumentsAsDeclared,\n\n    MemberExpression(node) {\n      if (propsUtil.isPropTypesDeclaration(node)) {\n        const component = utils.getRelatedComponent(node);\n        if (!component) {\n          return;\n        }\n        try {\n          markPropTypesAsDeclared(component.node, node.parent.right || node.parent, node);\n        } catch (e) {\n          if (e.constructor !== RangeError) { throw e; }\n        }\n      }\n    },\n\n    MethodDefinition(node) {\n      if (!node.static || node.kind !== 'get' || !propsUtil.isPropTypesDeclaration(node)) {\n        return;\n      }\n\n      let i = node.value.body.body.length - 1;\n      for (; i >= 0; i--) {\n        if (node.value.body.body[i].type === 'ReturnStatement') {\n          break;\n        }\n      }\n\n      if (i >= 0) {\n        markPropTypesAsDeclared(node, node.value.body.body[i].argument, node);\n      }\n    },\n\n    TypeAlias(node) {\n      setInTypeScope(node.id.name, node.right);\n    },\n\n    TypeParameterDeclaration(node) {\n      const identifier = node.params[0];\n\n      if (identifier.typeAnnotation) {\n        setInTypeScope(identifier.name, identifier.typeAnnotation.typeAnnotation);\n      }\n    },\n\n    Program() {\n      stack = [{}];\n    },\n\n    BlockStatement() {\n      stack.push(Object.create(typeScope()));\n    },\n\n    'BlockStatement:exit'() {\n      stack.pop();\n    },\n\n    'Program:exit'() {\n      classExpressions.forEach((node) => {\n        if (isSuperTypeParameterPropsDeclaration(node)) {\n          markPropTypesAsDeclared(node, resolveSuperParameterPropsType(node), node);\n        }\n      });\n    },\n  };\n};\n"
        }
    ]
}