{
    "sourceFile": "node_modules/eslint-plugin-react/lib/util/Components.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892278489,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Utility class and functions for React components detection\n * @author Yannick Croissant\n */\n\n'use strict';\n\nconst arrayIncludes = require('array-includes');\nconst fromEntries = require('object.fromentries');\nconst values = require('object.values');\nconst iterFrom = require('es-iterator-helpers/Iterator.from');\nconst map = require('es-iterator-helpers/Iterator.prototype.map');\n\nconst variableUtil = require('./variable');\nconst pragmaUtil = require('./pragma');\nconst astUtil = require('./ast');\nconst componentUtil = require('./componentUtil');\nconst propTypesUtil = require('./propTypes');\nconst jsxUtil = require('./jsx');\nconst usedPropTypesUtil = require('./usedPropTypes');\nconst defaultPropsUtil = require('./defaultProps');\nconst isFirstLetterCapitalized = require('./isFirstLetterCapitalized');\nconst isDestructuredFromPragmaImport = require('./isDestructuredFromPragmaImport');\nconst eslintUtil = require('./eslint');\n\nconst getScope = eslintUtil.getScope;\nconst getText = eslintUtil.getText;\n\nfunction getId(node) {\n  return node ? `${node.range[0]}:${node.range[1]}` : '';\n}\n\nfunction usedPropTypesAreEquivalent(propA, propB) {\n  if (propA.name === propB.name) {\n    if (!propA.allNames && !propB.allNames) {\n      return true;\n    }\n    if (Array.isArray(propA.allNames) && Array.isArray(propB.allNames) && propA.allNames.join('') === propB.allNames.join('')) {\n      return true;\n    }\n    return false;\n  }\n  return false;\n}\n\nfunction mergeUsedPropTypes(propsList, newPropsList) {\n  const propsToAdd = newPropsList.filter((newProp) => {\n    const newPropIsAlreadyInTheList = propsList.some((prop) => usedPropTypesAreEquivalent(prop, newProp));\n    return !newPropIsAlreadyInTheList;\n  });\n\n  return propsList.concat(propsToAdd);\n}\n\nconst USE_HOOK_PREFIX_REGEX = /^use[A-Z]/;\n\nconst Lists = new WeakMap();\nconst ReactImports = new WeakMap();\n\n/**\n * Components\n */\nclass Components {\n  constructor() {\n    Lists.set(this, {});\n    ReactImports.set(this, {});\n  }\n\n  /**\n   * Add a node to the components list, or update it if it's already in the list\n   *\n   * @param {ASTNode} node The AST node being added.\n   * @param {number} confidence Confidence in the component detection (0=banned, 1=maybe, 2=yes)\n   * @returns {Object} Added component object\n   */\n  add(node, confidence) {\n    const id = getId(node);\n    const list = Lists.get(this);\n    if (list[id]) {\n      if (confidence === 0 || list[id].confidence === 0) {\n        list[id].confidence = 0;\n      } else {\n        list[id].confidence = Math.max(list[id].confidence, confidence);\n      }\n      return list[id];\n    }\n    list[id] = {\n      node,\n      confidence,\n    };\n    return list[id];\n  }\n\n  /**\n   * Find a component in the list using its node\n   *\n   * @param {ASTNode} node The AST node being searched.\n   * @returns {Object} Component object, undefined if the component is not found or has confidence value of 0.\n   */\n  get(node) {\n    const id = getId(node);\n    const item = Lists.get(this)[id];\n    if (item && item.confidence >= 1) {\n      return item;\n    }\n    return null;\n  }\n\n  /**\n   * Update a component in the list\n   *\n   * @param {ASTNode} node The AST node being updated.\n   * @param {Object} props Additional properties to add to the component.\n   */\n  set(node, props) {\n    const list = Lists.get(this);\n    let component = list[getId(node)];\n    while (!component || component.confidence < 1) {\n      node = node.parent;\n      if (!node) {\n        return;\n      }\n      component = list[getId(node)];\n    }\n\n    Object.assign(\n      component,\n      props,\n      {\n        usedPropTypes: mergeUsedPropTypes(\n          component.usedPropTypes || [],\n          props.usedPropTypes || []\n        ),\n      }\n    );\n  }\n\n  /**\n   * Return the components list\n   * Components for which we are not confident are not returned\n   *\n   * @returns {Object} Components list\n   */\n  list() {\n    const thisList = Lists.get(this);\n    const list = {};\n    const usedPropTypes = {};\n\n    // Find props used in components for which we are not confident\n    Object.keys(thisList).filter((i) => thisList[i].confidence < 2).forEach((i) => {\n      let component = null;\n      let node = null;\n      node = thisList[i].node;\n      while (!component && node.parent) {\n        node = node.parent;\n        // Stop moving up if we reach a decorator\n        if (node.type === 'Decorator') {\n          break;\n        }\n        component = this.get(node);\n      }\n      if (component) {\n        const newUsedProps = (thisList[i].usedPropTypes || []).filter((propType) => !propType.node || propType.node.kind !== 'init');\n\n        const componentId = getId(component.node);\n\n        usedPropTypes[componentId] = mergeUsedPropTypes(usedPropTypes[componentId] || [], newUsedProps);\n      }\n    });\n\n    // Assign used props in not confident components to the parent component\n    Object.keys(thisList).filter((j) => thisList[j].confidence >= 2).forEach((j) => {\n      const id = getId(thisList[j].node);\n      list[j] = thisList[j];\n      if (usedPropTypes[id]) {\n        list[j].usedPropTypes = mergeUsedPropTypes(list[j].usedPropTypes || [], usedPropTypes[id]);\n      }\n    });\n    return list;\n  }\n\n  /**\n   * Return the length of the components list\n   * Components for which we are not confident are not counted\n   *\n   * @returns {number} Components list length\n   */\n  length() {\n    const list = Lists.get(this);\n    return values(list).filter((component) => component.confidence >= 2).length;\n  }\n\n  /**\n   * Return the node naming the default React import\n   * It can be used to determine the local name of import, even if it's imported\n   * with an unusual name.\n   *\n   * @returns {ASTNode} React default import node\n   */\n  getDefaultReactImports() {\n    return ReactImports.get(this).defaultReactImports;\n  }\n\n  /**\n   * Return the nodes of all React named imports\n   *\n   * @returns {Object} The list of React named imports\n   */\n  getNamedReactImports() {\n    return ReactImports.get(this).namedReactImports;\n  }\n\n  /**\n   * Add the default React import specifier to the scope\n   *\n   * @param {ASTNode} specifier The AST Node of the default React import\n   * @returns {void}\n   */\n  addDefaultReactImport(specifier) {\n    const info = ReactImports.get(this);\n    ReactImports.set(this, Object.assign({}, info, {\n      defaultReactImports: (info.defaultReactImports || []).concat(specifier),\n    }));\n  }\n\n  /**\n   * Add a named React import specifier to the scope\n   *\n   * @param {ASTNode} specifier The AST Node of a named React import\n   * @returns {void}\n   */\n  addNamedReactImport(specifier) {\n    const info = ReactImports.get(this);\n    ReactImports.set(this, Object.assign({}, info, {\n      namedReactImports: (info.namedReactImports || []).concat(specifier),\n    }));\n  }\n}\n\nfunction getWrapperFunctions(context, pragma) {\n  const componentWrapperFunctions = context.settings.componentWrapperFunctions || [];\n\n  // eslint-disable-next-line arrow-body-style\n  return componentWrapperFunctions.map((wrapperFunction) => {\n    return typeof wrapperFunction === 'string'\n      ? { property: wrapperFunction }\n      : Object.assign({}, wrapperFunction, {\n        object: wrapperFunction.object === '<pragma>' ? pragma : wrapperFunction.object,\n      });\n  }).concat([\n    { property: 'forwardRef', object: pragma },\n    { property: 'memo', object: pragma },\n  ]);\n}\n\n// eslint-disable-next-line valid-jsdoc\n/**\n * Merge many eslint rules into one\n * @param {{[_: string]: Function}[]} rules the returned values for eslint rule.create(context)\n * @returns {{[_: string]: Function}} merged rule\n */\nfunction mergeRules(rules) {\n  /** @type {Map<string, Function[]>} */\n  const handlersByKey = new Map();\n  rules.forEach((rule) => {\n    Object.keys(rule).forEach((key) => {\n      const fns = handlersByKey.get(key);\n      if (!fns) {\n        handlersByKey.set(key, [rule[key]]);\n      } else {\n        fns.push(rule[key]);\n      }\n    });\n  });\n\n  /** @type {{ [key: string]: Function }} */\n  return fromEntries(map(iterFrom(handlersByKey), (entry) => [\n    entry[0],\n    function mergedHandler(node) {\n      entry[1].forEach((fn) => {\n        fn(node);\n      });\n    },\n  ]));\n}\n\nfunction componentRule(rule, context) {\n  const pragma = pragmaUtil.getFromContext(context);\n  const components = new Components();\n  const wrapperFunctions = getWrapperFunctions(context, pragma);\n\n  // Utilities for component detection\n  const utils = {\n    /**\n     * Check if variable is destructured from pragma import\n     *\n     * @param {ASTNode} node The AST node to check\n     * @param {string} variable The variable name to check\n     * @returns {boolean} True if createElement is destructured from the pragma\n     */\n    isDestructuredFromPragmaImport(node, variable) {\n      return isDestructuredFromPragmaImport(context, node, variable);\n    },\n\n    /**\n     * @param {ASTNode} node\n     * @param {boolean=} strict\n     * @returns {boolean}\n     */\n    isReturningJSX(node, strict) {\n      return jsxUtil.isReturningJSX(context, node, strict, true);\n    },\n\n    isReturningJSXOrNull(node, strict) {\n      return jsxUtil.isReturningJSX(context, node, strict);\n    },\n\n    isReturningOnlyNull(node) {\n      return jsxUtil.isReturningOnlyNull(node, context);\n    },\n\n    getPragmaComponentWrapper(node) {\n      let isPragmaComponentWrapper;\n      let currentNode = node;\n      let prevNode;\n      do {\n        currentNode = currentNode.parent;\n        isPragmaComponentWrapper = this.isPragmaComponentWrapper(currentNode);\n        if (isPragmaComponentWrapper) {\n          prevNode = currentNode;\n        }\n      } while (isPragmaComponentWrapper);\n\n      return prevNode;\n    },\n\n    getComponentNameFromJSXElement(node) {\n      if (node.type !== 'JSXElement') {\n        return null;\n      }\n      if (node.openingElement && node.openingElement.name && node.openingElement.name.name) {\n        return node.openingElement.name.name;\n      }\n      return null;\n    },\n\n    /**\n     * Getting the first JSX element's name.\n     * @param {object} node\n     * @returns {string | null}\n     */\n    getNameOfWrappedComponent(node) {\n      if (node.length < 1) {\n        return null;\n      }\n      const body = node[0].body;\n      if (!body) {\n        return null;\n      }\n      if (body.type === 'JSXElement') {\n        return this.getComponentNameFromJSXElement(body);\n      }\n      if (body.type === 'BlockStatement') {\n        const jsxElement = body.body.find((item) => item.type === 'ReturnStatement');\n        return jsxElement\n          && jsxElement.argument\n          && this.getComponentNameFromJSXElement(jsxElement.argument);\n      }\n      return null;\n    },\n\n    /**\n     * Get the list of names of components created till now\n     * @returns {string | boolean}\n     */\n    getDetectedComponents() {\n      const list = components.list();\n      return values(list).filter((val) => {\n        if (val.node.type === 'ClassDeclaration') {\n          return true;\n        }\n        if (\n          val.node.type === 'ArrowFunctionExpression'\n          && val.node.parent\n          && val.node.parent.type === 'VariableDeclarator'\n          && val.node.parent.id\n        ) {\n          return true;\n        }\n        return false;\n      }).map((val) => {\n        if (val.node.type === 'ArrowFunctionExpression') return val.node.parent.id.name;\n        return val.node.id && val.node.id.name;\n      });\n    },\n\n    /**\n     * It will check whether memo/forwardRef is wrapping existing component or\n     * creating a new one.\n     * @param {object} node\n     * @returns {boolean}\n     */\n    nodeWrapsComponent(node) {\n      const childComponent = this.getNameOfWrappedComponent(node.arguments);\n      const componentList = this.getDetectedComponents();\n      return !!childComponent && arrayIncludes(componentList, childComponent);\n    },\n\n    isPragmaComponentWrapper(node) {\n      if (!astUtil.isCallExpression(node)) {\n        return false;\n      }\n\n      return wrapperFunctions.some((wrapperFunction) => {\n        if (node.callee.type === 'MemberExpression') {\n          return wrapperFunction.object\n            && wrapperFunction.object === node.callee.object.name\n            && wrapperFunction.property === node.callee.property.name\n            && !this.nodeWrapsComponent(node);\n        }\n        return wrapperFunction.property === node.callee.name\n          && (!wrapperFunction.object\n            // Functions coming from the current pragma need special handling\n            || (wrapperFunction.object === pragma && this.isDestructuredFromPragmaImport(node, node.callee.name))\n          );\n      });\n    },\n\n    /**\n     * Find a return statement in the current node\n     *\n     * @param {ASTNode} node The AST node being checked\n     */\n    findReturnStatement: astUtil.findReturnStatement,\n\n    /**\n     * Get the parent component node from the current scope\n     * @param {ASTNode} node\n     *\n     * @returns {ASTNode} component node, null if we are not in a component\n     */\n    getParentComponent(node) {\n      return (\n        componentUtil.getParentES6Component(context, node)\n        || componentUtil.getParentES5Component(context, node)\n        || utils.getParentStatelessComponent(node)\n      );\n    },\n\n    /**\n     * @param {ASTNode} node\n     * @returns {boolean}\n     */\n    isInAllowedPositionForComponent(node) {\n      switch (node.parent.type) {\n        case 'VariableDeclarator':\n        case 'AssignmentExpression':\n        case 'Property':\n        case 'ReturnStatement':\n        case 'ExportDefaultDeclaration':\n        case 'ArrowFunctionExpression': {\n          return true;\n        }\n        case 'SequenceExpression': {\n          return utils.isInAllowedPositionForComponent(node.parent)\n            && node === node.parent.expressions[node.parent.expressions.length - 1];\n        }\n        default:\n          return false;\n      }\n    },\n\n    /**\n     * Get node if node is a stateless component, or node.parent in cases like\n     * `React.memo` or `React.forwardRef`. Otherwise returns `undefined`.\n     * @param {ASTNode} node\n     * @returns {ASTNode | undefined}\n     */\n    getStatelessComponent(node) {\n      const parent = node.parent;\n      if (\n        node.type === 'FunctionDeclaration'\n        && (!node.id || isFirstLetterCapitalized(node.id.name))\n        && utils.isReturningJSXOrNull(node)\n      ) {\n        return node;\n      }\n\n      if (node.type === 'FunctionExpression' || node.type === 'ArrowFunctionExpression') {\n        const isPropertyAssignment = parent.type === 'AssignmentExpression'\n          && parent.left.type === 'MemberExpression';\n        const isModuleExportsAssignment = isPropertyAssignment\n          && parent.left.object.name === 'module'\n          && parent.left.property.name === 'exports';\n\n        if (node.parent.type === 'ExportDefaultDeclaration') {\n          if (utils.isReturningJSX(node)) {\n            return node;\n          }\n          return undefined;\n        }\n\n        if (node.parent.type === 'VariableDeclarator' && utils.isReturningJSXOrNull(node)) {\n          if (isFirstLetterCapitalized(node.parent.id.name)) {\n            return node;\n          }\n          return undefined;\n        }\n\n        // case: const any = () => { return (props) => null }\n        // case: const any = () => (props) => null\n        if (\n          (node.parent.type === 'ReturnStatement' || (node.parent.type === 'ArrowFunctionExpression' && node.parent.expression))\n          && !utils.isReturningJSX(node)\n        ) {\n          return undefined;\n        }\n\n        // case: any = () => { return => null }\n        // case: any = () => null\n        if (node.parent.type === 'AssignmentExpression' && !isPropertyAssignment && utils.isReturningJSXOrNull(node)) {\n          if (isFirstLetterCapitalized(node.parent.left.name)) {\n            return node;\n          }\n          return undefined;\n        }\n\n        // case: any = () => () => null\n        if (node.parent.type === 'ArrowFunctionExpression' && node.parent.parent.type === 'AssignmentExpression' && !isPropertyAssignment && utils.isReturningJSXOrNull(node)) {\n          if (isFirstLetterCapitalized(node.parent.parent.left.name)) {\n            return node;\n          }\n          return undefined;\n        }\n\n        // case: { any: () => () => null }\n        if (node.parent.type === 'ArrowFunctionExpression' && node.parent.parent.type === 'Property' && !isPropertyAssignment && utils.isReturningJSXOrNull(node)) {\n          if (isFirstLetterCapitalized(node.parent.parent.key.name)) {\n            return node;\n          }\n          return undefined;\n        }\n\n        // case: any = function() {return function() {return null;};}\n        if (node.parent.type === 'ReturnStatement') {\n          if (isFirstLetterCapitalized(node.id && node.id.name)) {\n            return node;\n          }\n          const functionExpr = node.parent.parent.parent;\n          if (functionExpr.parent.type === 'AssignmentExpression' && !isPropertyAssignment && utils.isReturningJSXOrNull(node)) {\n            if (isFirstLetterCapitalized(functionExpr.parent.left.name)) {\n              return node;\n            }\n            return undefined;\n          }\n        }\n\n        // case: { any: function() {return function() {return null;};} }\n        if (node.parent.type === 'ReturnStatement') {\n          const functionExpr = node.parent.parent.parent;\n          if (functionExpr.parent.type === 'Property' && !isPropertyAssignment && utils.isReturningJSXOrNull(node)) {\n            if (isFirstLetterCapitalized(functionExpr.parent.key.name)) {\n              return node;\n            }\n            return undefined;\n          }\n        }\n\n        // for case abc = { [someobject.somekey]: props => { ... return not-jsx } }\n        if (\n          node.parent\n          && node.parent.key\n          && node.parent.key.type === 'MemberExpression'\n          && !utils.isReturningJSX(node)\n          && !utils.isReturningOnlyNull(node)\n        ) {\n          return undefined;\n        }\n\n        if (\n          node.parent.type === 'Property' && (\n            (node.parent.method && !node.parent.computed) // case: { f() { return ... } }\n            || (!node.id && !node.parent.computed) // case: { f: () => ... }\n          )\n        ) {\n          if (\n            isFirstLetterCapitalized(node.parent.key.name)\n            && utils.isReturningJSX(node)\n          ) {\n            return node;\n          }\n          return undefined;\n        }\n\n        // Case like `React.memo(() => <></>)` or `React.forwardRef(...)`\n        const pragmaComponentWrapper = utils.getPragmaComponentWrapper(node);\n        if (pragmaComponentWrapper && utils.isReturningJSXOrNull(node)) {\n          return pragmaComponentWrapper;\n        }\n\n        if (!(utils.isInAllowedPositionForComponent(node) && utils.isReturningJSXOrNull(node))) {\n          return undefined;\n        }\n\n        if (utils.isParentComponentNotStatelessComponent(node)) {\n          return undefined;\n        }\n\n        if (node.id) {\n          return isFirstLetterCapitalized(node.id.name) ? node : undefined;\n        }\n\n        if (\n          isPropertyAssignment\n          && !isModuleExportsAssignment\n          && !isFirstLetterCapitalized(parent.left.property.name)\n        ) {\n          return undefined;\n        }\n\n        if (parent.type === 'Property' && utils.isReturningOnlyNull(node)) {\n          return undefined;\n        }\n\n        return node;\n      }\n\n      return undefined;\n    },\n\n    /**\n     * Get the parent stateless component node from the current scope\n     *\n     * @param {ASTNode} node The AST node being checked\n     * @returns {ASTNode} component node, null if we are not in a component\n     */\n    getParentStatelessComponent(node) {\n      let scope = getScope(context, node);\n      while (scope) {\n        const statelessComponent = utils.getStatelessComponent(scope.block);\n        if (statelessComponent) {\n          return statelessComponent;\n        }\n        scope = scope.upper;\n      }\n      return null;\n    },\n\n    /**\n     * Get the related component from a node\n     *\n     * @param {ASTNode} node The AST node being checked (must be a MemberExpression).\n     * @returns {ASTNode | null} component node, null if we cannot find the component\n     */\n    getRelatedComponent(node) {\n      let i;\n      let j;\n      let k;\n      let l;\n      let componentNode;\n      // Get the component path\n      const componentPath = [];\n      let nodeTemp = node;\n      while (nodeTemp) {\n        if (nodeTemp.property && nodeTemp.property.type === 'Identifier') {\n          componentPath.push(nodeTemp.property.name);\n        }\n        if (nodeTemp.object && nodeTemp.object.type === 'Identifier') {\n          componentPath.push(nodeTemp.object.name);\n        }\n        nodeTemp = nodeTemp.object;\n      }\n      componentPath.reverse();\n      const componentName = componentPath.slice(0, componentPath.length - 1).join('.');\n\n      // Find the variable in the current scope\n      const variableName = componentPath.shift();\n      if (!variableName) {\n        return null;\n      }\n      const variableInScope = variableUtil.getVariableFromContext(context, node, variableName);\n      if (!variableInScope) {\n        return null;\n      }\n\n      // Try to find the component using variable references\n      variableInScope.references.some((ref) => {\n        let refId = ref.identifier;\n        if (refId.parent && refId.parent.type === 'MemberExpression') {\n          refId = refId.parent;\n        }\n        if (getText(context, refId) !== componentName) {\n          return false;\n        }\n        if (refId.type === 'MemberExpression') {\n          componentNode = refId.parent.right;\n        } else if (\n          refId.parent\n          && refId.parent.type === 'VariableDeclarator'\n          && refId.parent.init\n          && refId.parent.init.type !== 'Identifier'\n        ) {\n          componentNode = refId.parent.init;\n        }\n        return true;\n      });\n\n      if (componentNode) {\n        // Return the component\n        return components.add(componentNode, 1);\n      }\n\n      // Try to find the component using variable declarations\n      const defs = variableInScope.defs;\n      const defInScope = defs.find((def) => (\n        def.type === 'ClassName'\n        || def.type === 'FunctionName'\n        || def.type === 'Variable'\n      ));\n      if (!defInScope || !defInScope.node) {\n        return null;\n      }\n      componentNode = defInScope.node.init || defInScope.node;\n\n      // Traverse the node properties to the component declaration\n      for (i = 0, j = componentPath.length; i < j; i++) {\n        if (!componentNode.properties) {\n          continue; // eslint-disable-line no-continue\n        }\n        for (k = 0, l = componentNode.properties.length; k < l; k++) {\n          if (componentNode.properties[k].key && componentNode.properties[k].key.name === componentPath[i]) {\n            componentNode = componentNode.properties[k];\n            break;\n          }\n        }\n        if (!componentNode || !componentNode.value) {\n          return null;\n        }\n        componentNode = componentNode.value;\n      }\n\n      // Return the component\n      return components.add(componentNode, 1);\n    },\n\n    isParentComponentNotStatelessComponent(node) {\n      return !!(\n        node.parent\n        && node.parent.key\n        && node.parent.key.type === 'Identifier'\n        // custom component functions must start with a capital letter (returns false otherwise)\n        && node.parent.key.name.charAt(0) === node.parent.key.name.charAt(0).toLowerCase()\n        // react render function cannot have params\n        && !!(node.params || []).length\n      );\n    },\n\n    /**\n     * Identify whether a node (CallExpression) is a call to a React hook\n     *\n     * @param {ASTNode} node The AST node being searched. (expects CallExpression)\n     * @param {('useCallback'|'useContext'|'useDebugValue'|'useEffect'|'useImperativeHandle'|'useLayoutEffect'|'useMemo'|'useReducer'|'useRef'|'useState')[]} [expectedHookNames] React hook names to which search is limited.\n     * @returns {boolean} True if the node is a call to a React hook\n     */\n    isReactHookCall(node, expectedHookNames) {\n      if (!astUtil.isCallExpression(node)) {\n        return false;\n      }\n\n      const defaultReactImports = components.getDefaultReactImports();\n      const namedReactImports = components.getNamedReactImports();\n\n      const defaultReactImportName = defaultReactImports\n        && defaultReactImports[0]\n        && defaultReactImports[0].local.name;\n      const reactHookImportSpecifiers = namedReactImports\n        && namedReactImports.filter((specifier) => USE_HOOK_PREFIX_REGEX.test(specifier.imported.name));\n      const reactHookImportNames = reactHookImportSpecifiers\n        && fromEntries(reactHookImportSpecifiers.map((specifier) => [specifier.local.name, specifier.imported.name]));\n\n      const isPotentialReactHookCall = defaultReactImportName\n        && node.callee.type === 'MemberExpression'\n        && node.callee.object.type === 'Identifier'\n        && node.callee.object.name === defaultReactImportName\n        && node.callee.property.type === 'Identifier'\n        && node.callee.property.name.match(USE_HOOK_PREFIX_REGEX);\n\n      const isPotentialHookCall = reactHookImportNames\n        && node.callee.type === 'Identifier'\n        && node.callee.name.match(USE_HOOK_PREFIX_REGEX);\n\n      const scope = (isPotentialReactHookCall || isPotentialHookCall) && getScope(context, node);\n\n      const reactResolvedDefs = isPotentialReactHookCall\n        && scope.references\n        && scope.references.find(\n          (reference) => reference.identifier.name === defaultReactImportName\n        ).resolved.defs;\n\n      const isReactShadowed = isPotentialReactHookCall && reactResolvedDefs\n        && reactResolvedDefs.some((reactDef) => reactDef.type !== 'ImportBinding');\n\n      const potentialHookReference = isPotentialHookCall\n        && scope.references\n        && scope.references.find(\n          (reference) => reactHookImportNames[reference.identifier.name]\n        );\n\n      const hookResolvedDefs = potentialHookReference && potentialHookReference.resolved.defs;\n      const localHookName = (\n        isPotentialReactHookCall\n        && node.callee.property.name\n      ) || (\n        isPotentialHookCall\n        && potentialHookReference\n        && node.callee.name\n      );\n      const isHookShadowed = isPotentialHookCall\n        && hookResolvedDefs\n        && hookResolvedDefs.some(\n          (hookDef) => hookDef.name.name === localHookName\n          && hookDef.type !== 'ImportBinding'\n        );\n\n      const isHookCall = (isPotentialReactHookCall && !isReactShadowed)\n        || (isPotentialHookCall && localHookName && !isHookShadowed);\n\n      if (!isHookCall) {\n        return false;\n      }\n\n      if (!expectedHookNames) {\n        return true;\n      }\n\n      return arrayIncludes(\n        expectedHookNames,\n        (reactHookImportNames && reactHookImportNames[localHookName]) || localHookName\n      );\n    },\n  };\n\n  // Component detection instructions\n  const detectionInstructions = {\n    CallExpression(node) {\n      if (!utils.isPragmaComponentWrapper(node)) {\n        return;\n      }\n      if (node.arguments.length > 0 && astUtil.isFunctionLikeExpression(node.arguments[0])) {\n        components.add(node, 2);\n      }\n    },\n\n    ClassExpression(node) {\n      if (!componentUtil.isES6Component(node, context)) {\n        return;\n      }\n      components.add(node, 2);\n    },\n\n    ClassDeclaration(node) {\n      if (!componentUtil.isES6Component(node, context)) {\n        return;\n      }\n      components.add(node, 2);\n    },\n\n    ObjectExpression(node) {\n      if (!componentUtil.isES5Component(node, context)) {\n        return;\n      }\n      components.add(node, 2);\n    },\n\n    FunctionExpression(node) {\n      if (node.async && node.generator) {\n        components.add(node, 0);\n        return;\n      }\n\n      const component = utils.getStatelessComponent(node);\n      if (!component) {\n        return;\n      }\n      components.add(component, 2);\n    },\n\n    FunctionDeclaration(node) {\n      if (node.async && node.generator) {\n        components.add(node, 0);\n        return;\n      }\n\n      const cNode = utils.getStatelessComponent(node);\n      if (!cNode) {\n        return;\n      }\n      components.add(cNode, 2);\n    },\n\n    ArrowFunctionExpression(node) {\n      const component = utils.getStatelessComponent(node);\n      if (!component) {\n        return;\n      }\n      components.add(component, 2);\n    },\n\n    ThisExpression(node) {\n      const component = utils.getParentStatelessComponent(node);\n      if (!component || !/Function/.test(component.type) || !node.parent.property) {\n        return;\n      }\n      // Ban functions accessing a property on a ThisExpression\n      components.add(node, 0);\n    },\n  };\n\n  // Detect React import specifiers\n  const reactImportInstructions = {\n    ImportDeclaration(node) {\n      const isReactImported = node.source.type === 'Literal' && node.source.value === 'react';\n      if (!isReactImported) {\n        return;\n      }\n\n      node.specifiers.forEach((specifier) => {\n        if (specifier.type === 'ImportDefaultSpecifier') {\n          components.addDefaultReactImport(specifier);\n        }\n        if (specifier.type === 'ImportSpecifier') {\n          components.addNamedReactImport(specifier);\n        }\n      });\n    },\n  };\n\n  const ruleInstructions = rule(context, components, utils);\n  const propTypesInstructions = propTypesUtil(context, components, utils);\n  const usedPropTypesInstructions = usedPropTypesUtil(context, components, utils);\n  const defaultPropsInstructions = defaultPropsUtil(context, components, utils);\n\n  const mergedRule = mergeRules([\n    detectionInstructions,\n    propTypesInstructions,\n    usedPropTypesInstructions,\n    defaultPropsInstructions,\n    reactImportInstructions,\n    ruleInstructions,\n  ]);\n\n  return mergedRule;\n}\n\nmodule.exports = Object.assign(Components, {\n  detect(rule) {\n    return componentRule.bind(this, rule);\n  },\n});\n"
        }
    ]
}