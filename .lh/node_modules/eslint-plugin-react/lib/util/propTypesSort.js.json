{
    "sourceFile": "node_modules/eslint-plugin-react/lib/util/propTypesSort.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892280013,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Common propTypes sorting functionality.\n */\n\n'use strict';\n\nconst toSorted = require('array.prototype.tosorted');\n\nconst astUtil = require('./ast');\nconst eslintUtil = require('./eslint');\n\nconst getSourceCode = eslintUtil.getSourceCode;\nconst getText = eslintUtil.getText;\n\n/**\n * Returns the value name of a node.\n *\n * @param {ASTNode} node the node to check.\n * @returns {string} The name of the node.\n */\nfunction getValueName(node) {\n  return node.type === 'Property'\n    && node.value.property\n    && node.value.property.name;\n}\n\n/**\n * Checks if the prop is required or not.\n *\n * @param {ASTNode} node the prop to check.\n * @returns {boolean} true if the prop is required.\n */\nfunction isRequiredProp(node) {\n  return getValueName(node) === 'isRequired';\n}\n\n/**\n * Checks if the proptype is a callback by checking if it starts with 'on'.\n *\n * @param {string} propName the name of the proptype to check.\n * @returns {boolean} true if the proptype is a callback.\n */\nfunction isCallbackPropName(propName) {\n  return /^on[A-Z]/.test(propName);\n}\n\n/**\n * Checks if the prop is PropTypes.shape.\n *\n * @param {ASTNode} node the prop to check.\n * @returns {boolean} true if the prop is PropTypes.shape.\n */\nfunction isShapeProp(node) {\n  return !!(\n    node\n    && node.callee\n    && node.callee.property\n    && node.callee.property.name === 'shape'\n  );\n}\n\n/**\n * Returns the properties of a PropTypes.shape.\n *\n * @param {ASTNode} node the prop to check.\n * @returns {Array} the properties of the PropTypes.shape node.\n */\nfunction getShapeProperties(node) {\n  return node.arguments\n    && node.arguments[0]\n    && node.arguments[0].properties;\n}\n\n/**\n * Compares two elements.\n *\n * @param {ASTNode} a the first element to compare.\n * @param {ASTNode} b the second element to compare.\n * @param {Context} context The context of the two nodes.\n * @param {boolean=} ignoreCase whether or not to ignore case when comparing the two elements.\n * @param {boolean=} requiredFirst whether or not to sort required elements first.\n * @param {boolean=} callbacksLast whether or not to sort callbacks after everything else.\n * @param {boolean=} noSortAlphabetically whether or not to disable alphabetical sorting of the elements.\n * @returns {number} the sort order of the two elements.\n */\nfunction sorter(a, b, context, ignoreCase, requiredFirst, callbacksLast, noSortAlphabetically) {\n  const aKey = String(astUtil.getKeyValue(context, a));\n  const bKey = String(astUtil.getKeyValue(context, b));\n\n  if (requiredFirst) {\n    if (isRequiredProp(a) && !isRequiredProp(b)) {\n      return -1;\n    }\n    if (!isRequiredProp(a) && isRequiredProp(b)) {\n      return 1;\n    }\n  }\n\n  if (callbacksLast) {\n    if (isCallbackPropName(aKey) && !isCallbackPropName(bKey)) {\n      return 1;\n    }\n    if (!isCallbackPropName(aKey) && isCallbackPropName(bKey)) {\n      return -1;\n    }\n  }\n\n  if (!noSortAlphabetically) {\n    if (ignoreCase) {\n      return aKey.localeCompare(bKey);\n    }\n\n    if (aKey < bKey) {\n      return -1;\n    }\n    if (aKey > bKey) {\n      return 1;\n    }\n  }\n  return 0;\n}\n\nconst commentnodeMap = new WeakMap(); // all nodes reference WeakMap for start and end range\n\n/**\n * Fixes sort order of prop types.\n *\n * @param {Context} context the second element to compare.\n * @param {Fixer} fixer the first element to compare.\n * @param {Array} declarations The context of the two nodes.\n * @param {boolean=} ignoreCase whether or not to ignore case when comparing the two elements.\n * @param {boolean=} requiredFirst whether or not to sort required elements first.\n * @param {boolean=} callbacksLast whether or not to sort callbacks after everything else.\n * @param {boolean=} noSortAlphabetically whether or not to disable alphabetical sorting of the elements.\n * @param {boolean=} sortShapeProp whether or not to sort propTypes defined in PropTypes.shape.\n * @param {boolean=} checkTypes whether or not sorting of prop type definitions are checked.\n * @returns {Object|*|{range, text}} the sort order of the two elements.\n */\nfunction fixPropTypesSort(\n  context,\n  fixer,\n  declarations,\n  ignoreCase,\n  requiredFirst,\n  callbacksLast,\n  noSortAlphabetically,\n  sortShapeProp,\n  checkTypes\n) {\n  function sortInSource(allNodes, source) {\n    const originalSource = source;\n    const sourceCode = getSourceCode(context);\n    for (let i = 0; i < allNodes.length; i++) {\n      const node = allNodes[i];\n      let commentAfter = [];\n      let commentBefore = [];\n      let newStart = 0;\n      let newEnd = 0;\n      try {\n        commentBefore = sourceCode.getCommentsBefore(node);\n        commentAfter = sourceCode.getCommentsAfter(node);\n      } catch (e) { /**/ }\n\n      if (commentAfter.length === 0 || commentBefore.length === 0) {\n        newStart = node.range[0];\n        newEnd = node.range[1];\n      }\n\n      const firstCommentBefore = commentBefore[0];\n      if (commentBefore.length >= 1) {\n        newStart = firstCommentBefore.range[0];\n      }\n      const lastCommentAfter = commentAfter[commentAfter.length - 1];\n      if (commentAfter.length >= 1) {\n        newEnd = lastCommentAfter.range[1];\n      }\n      commentnodeMap.set(node, { start: newStart, end: newEnd, hasComment: true });\n    }\n    const nodeGroups = allNodes.reduce((acc, curr) => {\n      if (curr.type === 'ExperimentalSpreadProperty' || curr.type === 'SpreadElement') {\n        acc.push([]);\n      } else {\n        acc[acc.length - 1].push(curr);\n      }\n      return acc;\n    }, [[]]);\n\n    nodeGroups.forEach((nodes) => {\n      const sortedAttributes = toSorted(\n        nodes,\n        (a, b) => sorter(a, b, context, ignoreCase, requiredFirst, callbacksLast, noSortAlphabetically)\n      );\n\n      const sourceCodeText = getText(context);\n      let separator = '';\n      source = nodes.reduceRight((acc, attr, index) => {\n        const sortedAttr = sortedAttributes[index];\n        const commentNode = commentnodeMap.get(sortedAttr);\n        let sortedAttrText = sourceCodeText.slice(commentNode.start, commentNode.end);\n        const sortedAttrTextLastChar = sortedAttrText[sortedAttrText.length - 1];\n        if (!separator && [';', ','].some((allowedSep) => sortedAttrTextLastChar === allowedSep)) {\n          separator = sortedAttrTextLastChar;\n        }\n        if (sortShapeProp && isShapeProp(sortedAttr.value)) {\n          const shape = getShapeProperties(sortedAttr.value);\n          if (shape) {\n            const attrSource = sortInSource(\n              shape,\n              originalSource\n            );\n            sortedAttrText = attrSource.slice(sortedAttr.range[0], sortedAttr.range[1]);\n          }\n        }\n        const sortedAttrTextVal = checkTypes && !sortedAttrText.endsWith(separator) ? `${sortedAttrText}${separator}` : sortedAttrText;\n        return `${acc.slice(0, commentnodeMap.get(attr).start)}${sortedAttrTextVal}${acc.slice(commentnodeMap.get(attr).end)}`;\n      }, source);\n    });\n    return source;\n  }\n\n  const source = sortInSource(declarations, getText(context));\n\n  const rangeStart = commentnodeMap.get(declarations[0]).start;\n  const rangeEnd = commentnodeMap.get(declarations[declarations.length - 1]).end;\n  return fixer.replaceTextRange([rangeStart, rangeEnd], source.slice(rangeStart, rangeEnd));\n}\n\nmodule.exports = {\n  fixPropTypesSort,\n  isCallbackPropName,\n  isRequiredProp,\n  isShapeProp,\n};\n"
        }
    ]
}