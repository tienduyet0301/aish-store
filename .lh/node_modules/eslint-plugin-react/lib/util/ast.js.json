{
    "sourceFile": "node_modules/eslint-plugin-react/lib/util/ast.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892278404,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Utility functions for AST\n */\n\n'use strict';\n\nconst estraverse = require('estraverse');\nconst eslintUtil = require('./eslint');\n\nconst getFirstTokens = eslintUtil.getFirstTokens;\nconst getScope = eslintUtil.getScope;\nconst getSourceCode = eslintUtil.getSourceCode;\n// const pragmaUtil = require('./pragma');\n\n/**\n * Wrapper for estraverse.traverse\n *\n * @param {ASTNode} ASTnode The AST node being checked\n * @param {Object} visitor Visitor Object for estraverse\n */\nfunction traverse(ASTnode, visitor) {\n  const opts = Object.assign({}, {\n    fallback(node) {\n      return Object.keys(node).filter((key) => key === 'children' || key === 'argument');\n    },\n  }, visitor);\n\n  opts.keys = Object.assign({}, visitor.keys, {\n    JSXElement: ['children'],\n    JSXFragment: ['children'],\n  });\n\n  estraverse.traverse(ASTnode, opts);\n}\n\nfunction loopNodes(nodes) {\n  for (let i = nodes.length - 1; i >= 0; i--) {\n    if (nodes[i].type === 'ReturnStatement') {\n      return nodes[i];\n    }\n    if (nodes[i].type === 'SwitchStatement') {\n      const j = nodes[i].cases.length - 1;\n      if (j >= 0) {\n        return loopNodes(nodes[i].cases[j].consequent);\n      }\n    }\n  }\n  return false;\n}\n\n/**\n * Find a return statement in the current node\n *\n * @param {ASTNode} node The AST node being checked\n * @returns {ASTNode | false}\n */\nfunction findReturnStatement(node) {\n  if (\n    (!node.value || !node.value.body || !node.value.body.body)\n    && (!node.body || !node.body.body)\n  ) {\n    return false;\n  }\n\n  const bodyNodes = node.value ? node.value.body.body : node.body.body;\n\n  return loopNodes(bodyNodes);\n}\n\n// eslint-disable-next-line valid-jsdoc -- valid-jsdoc cannot parse function types.\n/**\n * Helper function for traversing \"returns\" (return statements or the\n * returned expression in the case of an arrow function) of a function\n *\n * @param {ASTNode} ASTNode The AST node being checked\n * @param {Context} context The context of `ASTNode`.\n * @param {(returnValue: ASTNode, breakTraverse: () => void) => void} onReturn\n *   Function to execute for each returnStatement found\n * @returns {undefined}\n */\nfunction traverseReturns(ASTNode, context, onReturn) {\n  const nodeType = ASTNode.type;\n\n  if (nodeType === 'ReturnStatement') {\n    onReturn(ASTNode.argument, () => {});\n    return;\n  }\n\n  if (nodeType === 'ArrowFunctionExpression' && ASTNode.expression) {\n    onReturn(ASTNode.body, () => {});\n    return;\n  }\n\n  /* TODO: properly warn on React.forwardRefs having typo properties\n  if (astUtil.isCallExpression(ASTNode)) {\n    const callee = ASTNode.callee;\n    const pragma = pragmaUtil.getFromContext(context);\n    if (\n      callee.type === 'MemberExpression'\n      && callee.object.type === 'Identifier'\n      && callee.object.name === pragma\n      && callee.property.type === 'Identifier'\n      && callee.property.name === 'forwardRef'\n      && ASTNode.arguments.length > 0\n    ) {\n      return enterFunc(ASTNode.arguments[0]);\n    }\n    return;\n  }\n  */\n\n  if (\n    nodeType !== 'FunctionExpression'\n    && nodeType !== 'FunctionDeclaration'\n    && nodeType !== 'ArrowFunctionExpression'\n    && nodeType !== 'MethodDefinition'\n  ) {\n    return;\n  }\n\n  traverse(ASTNode.body, {\n    enter(node) {\n      const breakTraverse = () => {\n        this.break();\n      };\n      switch (node.type) {\n        case 'ReturnStatement':\n          this.skip();\n          onReturn(node.argument, breakTraverse);\n          return;\n        case 'BlockStatement':\n        case 'IfStatement':\n        case 'ForStatement':\n        case 'WhileStatement':\n        case 'SwitchStatement':\n        case 'SwitchCase':\n          return;\n        default:\n          this.skip();\n      }\n    },\n  });\n}\n\n/**\n * Get node with property's name\n * @param {Object} node - Property.\n * @returns {Object} Property name node.\n */\nfunction getPropertyNameNode(node) {\n  if (\n    node.key\n    || node.type === 'MethodDefinition'\n    || node.type === 'Property'\n  ) {\n    return node.key;\n  }\n  if (node.type === 'MemberExpression') {\n    return node.property;\n  }\n  return null;\n}\n\n/**\n * Get properties name\n * @param {Object} node - Property.\n * @returns {string} Property name.\n */\nfunction getPropertyName(node) {\n  const nameNode = getPropertyNameNode(node);\n  return nameNode ? nameNode.name : '';\n}\n\n/**\n * Get properties for a given AST node\n * @param {ASTNode} node The AST node being checked.\n * @returns {Array} Properties array.\n */\nfunction getComponentProperties(node) {\n  switch (node.type) {\n    case 'ClassDeclaration':\n    case 'ClassExpression':\n      return node.body.body;\n    case 'ObjectExpression':\n      return node.properties;\n    default:\n      return [];\n  }\n}\n\n/**\n * Gets the first node in a line from the initial node, excluding whitespace.\n * @param {Object} context The node to check\n * @param {ASTNode} node The node to check\n * @return {ASTNode} the first node in the line\n */\nfunction getFirstNodeInLine(context, node) {\n  const sourceCode = getSourceCode(context);\n  let token = node;\n  let lines;\n  do {\n    token = sourceCode.getTokenBefore(token);\n    lines = token.type === 'JSXText'\n      ? token.value.split('\\n')\n      : null;\n  } while (\n    token.type === 'JSXText'\n        && /^\\s*$/.test(lines[lines.length - 1])\n  );\n  return token;\n}\n\n/**\n * Checks if the node is the first in its line, excluding whitespace.\n * @param {Object} context The node to check\n * @param {ASTNode} node The node to check\n * @return {boolean} true if it's the first node in its line\n */\nfunction isNodeFirstInLine(context, node) {\n  const token = getFirstNodeInLine(context, node);\n  const startLine = node.loc.start.line;\n  const endLine = token ? token.loc.end.line : -1;\n  return startLine !== endLine;\n}\n\n/**\n * Checks if the node is a function or arrow function expression.\n * @param {ASTNode} node The node to check\n * @return {boolean} true if it's a function-like expression\n */\nfunction isFunctionLikeExpression(node) {\n  return node.type === 'FunctionExpression' || node.type === 'ArrowFunctionExpression';\n}\n\n/**\n * Checks if the node is a function.\n * @param {ASTNode} node The node to check\n * @return {boolean} true if it's a function\n */\nfunction isFunction(node) {\n  return node.type === 'FunctionExpression' || node.type === 'FunctionDeclaration';\n}\n\n/**\n * Checks if node is a function declaration or expression or arrow function.\n * @param {ASTNode} node The node to check\n * @return {boolean} true if it's a function-like\n */\nfunction isFunctionLike(node) {\n  return node.type === 'FunctionDeclaration' || isFunctionLikeExpression(node);\n}\n\n/**\n * Checks if the node is a class.\n * @param {ASTNode} node The node to check\n * @return {boolean} true if it's a class\n */\nfunction isClass(node) {\n  return node.type === 'ClassDeclaration' || node.type === 'ClassExpression';\n}\n\n/**\n * Check if we are in a class constructor\n * @param {Context} context\n * @param {ASTNode} node The AST node being checked.\n * @return {boolean}\n */\nfunction inConstructor(context, node) {\n  let scope = getScope(context, node);\n  while (scope) {\n    // @ts-ignore\n    if (scope.block && scope.block.parent && scope.block.parent.kind === 'constructor') {\n      return true;\n    }\n    scope = scope.upper;\n  }\n  return false;\n}\n\n/**\n * Removes quotes from around an identifier.\n * @param {string} string the identifier to strip\n * @returns {string}\n */\nfunction stripQuotes(string) {\n  return string.replace(/^'|'$/g, '');\n}\n\n/**\n * Retrieve the name of a key node\n * @param {Context} context The AST node with the key.\n * @param {any} node The AST node with the key.\n * @return {string | undefined} the name of the key\n */\nfunction getKeyValue(context, node) {\n  if (node.type === 'ObjectTypeProperty') {\n    const tokens = getFirstTokens(context, node, 2);\n    return (tokens[0].value === '+' || tokens[0].value === '-'\n      ? tokens[1].value\n      : stripQuotes(tokens[0].value)\n    );\n  }\n  if (node.type === 'GenericTypeAnnotation') {\n    return node.id.name;\n  }\n  if (node.type === 'ObjectTypeAnnotation') {\n    return;\n  }\n  const key = node.key || node.argument;\n  if (!key) {\n    return;\n  }\n  return key.type === 'Identifier' ? key.name : key.value;\n}\n\n/**\n * Checks if a node is surrounded by parenthesis.\n *\n * @param {object} context - Context from the rule\n * @param {ASTNode} node - Node to be checked\n * @returns {boolean}\n */\nfunction isParenthesized(context, node) {\n  const sourceCode = getSourceCode(context);\n  const previousToken = sourceCode.getTokenBefore(node);\n  const nextToken = sourceCode.getTokenAfter(node);\n\n  return !!previousToken && !!nextToken\n    && previousToken.value === '(' && previousToken.range[1] <= node.range[0]\n    && nextToken.value === ')' && nextToken.range[0] >= node.range[1];\n}\n\n/**\n * Checks if a node is being assigned a value: props.bar = 'bar'\n * @param {ASTNode} node The AST node being checked.\n * @returns {boolean}\n */\nfunction isAssignmentLHS(node) {\n  return (\n    node.parent\n    && node.parent.type === 'AssignmentExpression'\n    && node.parent.left === node\n  );\n}\n\nfunction isTSAsExpression(node) {\n  return node && node.type === 'TSAsExpression';\n}\n\n/**\n * Matcher used to check whether given node is a `CallExpression`\n * @param {ASTNode} node The AST node\n * @returns {boolean} True if node is a `CallExpression`, false if not\n */\nfunction isCallExpression(node) {\n  return node && node.type === 'CallExpression';\n}\n\n/**\n * Extracts the expression node that is wrapped inside a TS type assertion\n *\n * @param {ASTNode} node - potential TS node\n * @returns {ASTNode} - unwrapped expression node\n */\nfunction unwrapTSAsExpression(node) {\n  return isTSAsExpression(node) ? node.expression : node;\n}\n\nfunction isTSTypeReference(node) {\n  if (!node) return false;\n\n  return node.type === 'TSTypeReference';\n}\n\nfunction isTSTypeAnnotation(node) {\n  if (!node) { return false; }\n\n  return node.type === 'TSTypeAnnotation';\n}\n\nfunction isTSTypeLiteral(node) {\n  if (!node) { return false; }\n\n  return node.type === 'TSTypeLiteral';\n}\n\nfunction isTSIntersectionType(node) {\n  if (!node) { return false; }\n\n  return node.type === 'TSIntersectionType';\n}\n\nfunction isTSInterfaceHeritage(node) {\n  if (!node) { return false; }\n\n  return node.type === 'TSInterfaceHeritage';\n}\n\nfunction isTSInterfaceDeclaration(node) {\n  if (!node) { return false; }\n\n  return (node.type === 'ExportNamedDeclaration' && node.declaration\n    ? node.declaration.type\n    : node.type\n  ) === 'TSInterfaceDeclaration';\n}\n\nfunction isTSTypeDeclaration(node) {\n  if (!node) { return false; }\n\n  const nodeToCheck = node.type === 'ExportNamedDeclaration' && node.declaration\n    ? node.declaration\n    : node;\n\n  return nodeToCheck.type === 'VariableDeclaration' && nodeToCheck.kind === 'type';\n}\n\nfunction isTSTypeAliasDeclaration(node) {\n  if (!node) { return false; }\n\n  if (node.type === 'ExportNamedDeclaration' && node.declaration) {\n    return node.declaration.type === 'TSTypeAliasDeclaration' && node.exportKind === 'type';\n  }\n  return node.type === 'TSTypeAliasDeclaration';\n}\n\nfunction isTSParenthesizedType(node) {\n  if (!node) { return false; }\n\n  return node.type === 'TSTypeAliasDeclaration';\n}\n\nfunction isTSFunctionType(node) {\n  if (!node) { return false; }\n\n  return node.type === 'TSFunctionType';\n}\n\nfunction isTSTypeQuery(node) {\n  if (!node) { return false; }\n\n  return node.type === 'TSTypeQuery';\n}\n\nfunction isTSTypeParameterInstantiation(node) {\n  if (!node) { return false; }\n\n  return node.type === 'TSTypeParameterInstantiation';\n}\n\nmodule.exports = {\n  findReturnStatement,\n  getComponentProperties,\n  getFirstNodeInLine,\n  getKeyValue,\n  getPropertyName,\n  getPropertyNameNode,\n  inConstructor,\n  isAssignmentLHS,\n  isCallExpression,\n  isClass,\n  isFunction,\n  isFunctionLike,\n  isFunctionLikeExpression,\n  isNodeFirstInLine,\n  isParenthesized,\n  isTSAsExpression,\n  isTSFunctionType,\n  isTSInterfaceDeclaration,\n  isTSInterfaceHeritage,\n  isTSIntersectionType,\n  isTSParenthesizedType,\n  isTSTypeAliasDeclaration,\n  isTSTypeAnnotation,\n  isTSTypeDeclaration,\n  isTSTypeLiteral,\n  isTSTypeParameterInstantiation,\n  isTSTypeQuery,\n  isTSTypeReference,\n  traverse,\n  traverseReturns,\n  unwrapTSAsExpression,\n};\n"
        }
    ]
}