{
    "sourceFile": "node_modules/eslint-plugin-react/lib/util/usedPropTypes.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892280221,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Common used propTypes detection functionality.\n */\n\n'use strict';\n\nconst values = require('object.values');\n\nconst astUtil = require('./ast');\nconst componentUtil = require('./componentUtil');\nconst testReactVersion = require('./version').testReactVersion;\nconst ast = require('./ast');\nconst eslintUtil = require('./eslint');\n\nconst getScope = eslintUtil.getScope;\nconst getSourceCode = eslintUtil.getSourceCode;\n\n// ------------------------------------------------------------------------------\n// Constants\n// ------------------------------------------------------------------------------\n\nconst LIFE_CYCLE_METHODS = ['componentWillReceiveProps', 'shouldComponentUpdate', 'componentWillUpdate', 'componentDidUpdate'];\nconst ASYNC_SAFE_LIFE_CYCLE_METHODS = ['getDerivedStateFromProps', 'getSnapshotBeforeUpdate', 'UNSAFE_componentWillReceiveProps', 'UNSAFE_componentWillUpdate'];\n\nfunction createPropVariables() {\n  /** @type {Map<string, string[]>} Maps the variable to its definition. `props.a.b` is stored as `['a', 'b']` */\n  let propVariables = new Map();\n  let hasBeenWritten = false;\n  const stack = [{ propVariables, hasBeenWritten }];\n  return {\n    pushScope() {\n      // popVariables is not copied until first write.\n      stack.push({ propVariables, hasBeenWritten: false });\n    },\n    popScope() {\n      stack.pop();\n      propVariables = stack[stack.length - 1].propVariables;\n      hasBeenWritten = stack[stack.length - 1].hasBeenWritten;\n    },\n    /**\n     * Add a variable name to the current scope\n     * @param {string} name\n     * @param {string[]} allNames Example: `props.a.b` should be formatted as `['a', 'b']`\n     * @returns {Map<string, string[]>}\n     */\n    set(name, allNames) {\n      if (!hasBeenWritten) {\n        // copy on write\n        propVariables = new Map(propVariables);\n        Object.assign(stack[stack.length - 1], { propVariables, hasBeenWritten: true });\n        stack[stack.length - 1].hasBeenWritten = true;\n      }\n      return propVariables.set(name, allNames);\n    },\n    /**\n     * Get the definition of a variable.\n     * @param {string} name\n     * @returns {string[]} Example: `props.a.b` is represented by `['a', 'b']`\n     */\n    get(name) {\n      return propVariables.get(name);\n    },\n  };\n}\n\n/**\n * Checks if the string is one of `props`, `nextProps`, or `prevProps`\n * @param {string} name The AST node being checked.\n * @returns {boolean} True if the prop name matches\n */\nfunction isCommonVariableNameForProps(name) {\n  return name === 'props' || name === 'nextProps' || name === 'prevProps';\n}\n\n/**\n * Checks if the component must be validated\n * @param {Object} component The component to process\n * @returns {boolean} True if the component must be validated, false if not.\n */\nfunction mustBeValidated(component) {\n  return !!(component && !component.ignorePropsValidation);\n}\n\n/**\n * Check if we are in a lifecycle method\n * @param {object} context\n * @param {ASTNode} node The AST node being checked.\n * @param {boolean} checkAsyncSafeLifeCycles\n * @return {boolean} true if we are in a class constructor, false if not\n */\nfunction inLifeCycleMethod(context, node, checkAsyncSafeLifeCycles) {\n  let scope = getScope(context, node);\n  while (scope) {\n    if (scope.block && scope.block.parent && scope.block.parent.key) {\n      const name = scope.block.parent.key.name;\n\n      if (LIFE_CYCLE_METHODS.indexOf(name) >= 0) {\n        return true;\n      }\n      if (checkAsyncSafeLifeCycles && ASYNC_SAFE_LIFE_CYCLE_METHODS.indexOf(name) >= 0) {\n        return true;\n      }\n    }\n    scope = scope.upper;\n  }\n  return false;\n}\n\n/**\n * Returns true if the given node is a React Component lifecycle method\n * @param {ASTNode} node The AST node being checked.\n * @param {boolean} checkAsyncSafeLifeCycles\n * @return {boolean} True if the node is a lifecycle method\n */\nfunction isNodeALifeCycleMethod(node, checkAsyncSafeLifeCycles) {\n  if (node.key) {\n    if (node.kind === 'constructor') {\n      return true;\n    }\n\n    const nodeKeyName = node.key.name;\n\n    if (typeof nodeKeyName !== 'string') {\n      return false;\n    }\n\n    if (LIFE_CYCLE_METHODS.indexOf(nodeKeyName) >= 0) {\n      return true;\n    }\n    if (checkAsyncSafeLifeCycles && ASYNC_SAFE_LIFE_CYCLE_METHODS.indexOf(nodeKeyName) >= 0) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n/**\n * Returns true if the given node is inside a React Component lifecycle\n * method.\n * @param {ASTNode} node The AST node being checked.\n * @param {boolean} checkAsyncSafeLifeCycles\n * @return {boolean} True if the node is inside a lifecycle method\n */\nfunction isInLifeCycleMethod(node, checkAsyncSafeLifeCycles) {\n  if (\n    (node.type === 'MethodDefinition' || node.type === 'Property')\n    && isNodeALifeCycleMethod(node, checkAsyncSafeLifeCycles)\n  ) {\n    return true;\n  }\n\n  if (node.parent) {\n    return isInLifeCycleMethod(node.parent, checkAsyncSafeLifeCycles);\n  }\n\n  return false;\n}\n\n/**\n * Check if a function node is a setState updater\n * @param {ASTNode} node a function node\n * @return {boolean}\n */\nfunction isSetStateUpdater(node) {\n  const unwrappedParentCalleeNode = astUtil.isCallExpression(node.parent)\n    && ast.unwrapTSAsExpression(node.parent.callee);\n\n  return unwrappedParentCalleeNode\n    && unwrappedParentCalleeNode.property\n    && unwrappedParentCalleeNode.property.name === 'setState'\n    // Make sure we are in the updater not the callback\n    && node.parent.arguments[0] === node;\n}\n\nfunction isPropArgumentInSetStateUpdater(context, node, name) {\n  if (typeof name !== 'string') {\n    return;\n  }\n  let scope = getScope(context, node);\n  while (scope) {\n    const unwrappedParentCalleeNode = scope.block\n      && astUtil.isCallExpression(scope.block.parent)\n      && ast.unwrapTSAsExpression(scope.block.parent.callee);\n    if (\n      unwrappedParentCalleeNode\n      && unwrappedParentCalleeNode.property\n      && unwrappedParentCalleeNode.property.name === 'setState'\n      // Make sure we are in the updater not the callback\n      && scope.block.parent.arguments[0].range[0] === scope.block.range[0]\n      && scope.block.parent.arguments[0].params\n      && scope.block.parent.arguments[0].params.length > 1\n    ) {\n      return scope.block.parent.arguments[0].params[1].name === name;\n    }\n    scope = scope.upper;\n  }\n  return false;\n}\n\n/**\n * @param {Context} context\n * @param {ASTNode} node\n * @returns {boolean}\n */\nfunction isInClassComponent(context, node) {\n  return !!(componentUtil.getParentES6Component(context, node) || componentUtil.getParentES5Component(context, node));\n}\n\n/**\n * Checks if the node is `this.props`\n * @param {ASTNode|undefined} node\n * @returns {boolean}\n */\nfunction isThisDotProps(node) {\n  return !!node\n    && node.type === 'MemberExpression'\n    && ast.unwrapTSAsExpression(node.object).type === 'ThisExpression'\n    && node.property.name === 'props';\n}\n\n/**\n * Checks if the prop has spread operator.\n * @param {object} context\n * @param {ASTNode} node The AST node being marked.\n * @returns {boolean} True if the prop has spread operator, false if not.\n */\nfunction hasSpreadOperator(context, node) {\n  const tokens = getSourceCode(context).getTokens(node);\n  return tokens.length && tokens[0].value === '...';\n}\n\n/**\n * Checks if the node is a propTypes usage of the form `this.props.*`, `props.*`, `prevProps.*`, or `nextProps.*`.\n * @param {Context} context\n * @param {ASTNode} node\n * @param {Object} utils\n * @param {boolean} checkAsyncSafeLifeCycles\n * @returns {boolean}\n */\nfunction isPropTypesUsageByMemberExpression(context, node, utils, checkAsyncSafeLifeCycles) {\n  const unwrappedObjectNode = ast.unwrapTSAsExpression(node.object);\n\n  if (isInClassComponent(context, node)) {\n    // this.props.*\n    if (isThisDotProps(unwrappedObjectNode)) {\n      return true;\n    }\n    // props.* or prevProps.* or nextProps.*\n    if (\n      isCommonVariableNameForProps(unwrappedObjectNode.name)\n      && (inLifeCycleMethod(context, node, checkAsyncSafeLifeCycles) || astUtil.inConstructor(context, node))\n    ) {\n      return true;\n    }\n    // this.setState((_, props) => props.*))\n    if (isPropArgumentInSetStateUpdater(context, node, unwrappedObjectNode.name)) {\n      return true;\n    }\n    return false;\n  }\n  // props.* in function component\n  return unwrappedObjectNode.name === 'props' && !ast.isAssignmentLHS(node);\n}\n\n/**\n * Retrieve the name of a property node\n * @param {Context} context\n * @param {ASTNode} node The AST node with the property.\n * @param {Object} utils\n * @param {boolean} checkAsyncSafeLifeCycles\n * @return {string|undefined} the name of the property or undefined if not found\n */\nfunction getPropertyName(context, node, utils, checkAsyncSafeLifeCycles) {\n  const property = node.property;\n  if (property) {\n    switch (property.type) {\n      case 'Identifier':\n        if (node.computed) {\n          return '__COMPUTED_PROP__';\n        }\n        return property.name;\n      case 'MemberExpression':\n        return;\n      case 'Literal':\n        // Accept computed properties that are literal strings\n        if (typeof property.value === 'string') {\n          return property.value;\n        }\n        // Accept number as well but only accept props[123]\n        if (typeof property.value === 'number') {\n          if (isPropTypesUsageByMemberExpression(context, node, utils, checkAsyncSafeLifeCycles)) {\n            return property.raw;\n          }\n        }\n        // falls through\n      default:\n        if (node.computed) {\n          return '__COMPUTED_PROP__';\n        }\n        break;\n    }\n  }\n}\n\nmodule.exports = function usedPropTypesInstructions(context, components, utils) {\n  const checkAsyncSafeLifeCycles = testReactVersion(context, '>= 16.3.0');\n\n  const propVariables = createPropVariables();\n  const pushScope = propVariables.pushScope;\n  const popScope = propVariables.popScope;\n\n  /**\n   * Mark a prop type as used\n   * @param {ASTNode} node The AST node being marked.\n   * @param {string[]} [parentNames]\n   */\n  function markPropTypesAsUsed(node, parentNames) {\n    parentNames = parentNames || [];\n    let type;\n    let name;\n    let allNames;\n    let properties;\n    switch (node.type) {\n      case 'OptionalMemberExpression':\n      case 'MemberExpression':\n        name = getPropertyName(context, node, utils, checkAsyncSafeLifeCycles);\n        if (name) {\n          allNames = parentNames.concat(name);\n          if (\n            // Match props.foo.bar, don't match bar[props.foo]\n            node.parent.type === 'MemberExpression'\n            && node.parent.object === node\n          ) {\n            markPropTypesAsUsed(node.parent, allNames);\n          }\n          // Handle the destructuring part of `const {foo} = props.a.b`\n          if (\n            node.parent.type === 'VariableDeclarator'\n            && node.parent.id.type === 'ObjectPattern'\n          ) {\n            node.parent.id.parent = node.parent; // patch for bug in eslint@4 in which ObjectPattern has no parent\n            markPropTypesAsUsed(node.parent.id, allNames);\n          }\n\n          // const a = props.a\n          if (\n            node.parent.type === 'VariableDeclarator'\n            && node.parent.id.type === 'Identifier'\n          ) {\n            propVariables.set(node.parent.id.name, allNames);\n          }\n          // Do not mark computed props as used.\n          type = name !== '__COMPUTED_PROP__' ? 'direct' : null;\n        }\n        break;\n      case 'ArrowFunctionExpression':\n      case 'FunctionDeclaration':\n      case 'FunctionExpression': {\n        if (node.params.length === 0) {\n          break;\n        }\n        type = 'destructuring';\n        const propParam = isSetStateUpdater(node) ? node.params[1] : node.params[0];\n        properties = propParam.type === 'AssignmentPattern'\n          ? propParam.left.properties\n          : propParam.properties;\n        break;\n      }\n      case 'ObjectPattern':\n        type = 'destructuring';\n        properties = node.properties;\n        break;\n      case 'TSEmptyBodyFunctionExpression':\n        break;\n      default:\n        throw new Error(`${node.type} ASTNodes are not handled by markPropTypesAsUsed`);\n    }\n\n    const component = components.get(utils.getParentComponent(node));\n    const usedPropTypes = (component && component.usedPropTypes) || [];\n    let ignoreUnusedPropTypesValidation = (component && component.ignoreUnusedPropTypesValidation) || false;\n\n    switch (type) {\n      case 'direct': {\n        // Ignore Object methods\n        if (name in Object.prototype) {\n          break;\n        }\n\n        const reportedNode = node.property;\n        usedPropTypes.push({\n          name,\n          allNames,\n          node: reportedNode,\n        });\n        break;\n      }\n      case 'destructuring': {\n        for (let k = 0, l = (properties || []).length; k < l; k++) {\n          if (hasSpreadOperator(context, properties[k]) || properties[k].computed) {\n            ignoreUnusedPropTypesValidation = true;\n            break;\n          }\n          const propName = ast.getKeyValue(context, properties[k]);\n\n          if (!propName || properties[k].type !== 'Property') {\n            break;\n          }\n\n          usedPropTypes.push({\n            allNames: parentNames.concat([propName]),\n            name: propName,\n            node: properties[k],\n          });\n\n          if (properties[k].value.type === 'ObjectPattern') {\n            markPropTypesAsUsed(properties[k].value, parentNames.concat([propName]));\n          } else if (properties[k].value.type === 'Identifier') {\n            propVariables.set(properties[k].value.name, parentNames.concat(propName));\n          }\n        }\n        break;\n      }\n      default:\n        break;\n    }\n\n    components.set(component ? component.node : node, {\n      usedPropTypes,\n      ignoreUnusedPropTypesValidation,\n    });\n  }\n\n  /**\n   * @param {ASTNode} node We expect either an ArrowFunctionExpression,\n   *   FunctionDeclaration, or FunctionExpression\n   */\n  function markDestructuredFunctionArgumentsAsUsed(node) {\n    const param = node.params && isSetStateUpdater(node) ? node.params[1] : node.params[0];\n\n    const destructuring = param && (\n      param.type === 'ObjectPattern'\n      || ((param.type === 'AssignmentPattern') && (param.left.type === 'ObjectPattern'))\n    );\n\n    if (destructuring && (components.get(node) || components.get(node.parent))) {\n      markPropTypesAsUsed(node);\n    }\n  }\n\n  function handleSetStateUpdater(node) {\n    if (!node.params || node.params.length < 2 || !isSetStateUpdater(node)) {\n      return;\n    }\n    markPropTypesAsUsed(node);\n  }\n\n  /**\n   * Handle both stateless functions and setState updater functions.\n   * @param {ASTNode} node We expect either an ArrowFunctionExpression,\n   *   FunctionDeclaration, or FunctionExpression\n   */\n  function handleFunctionLikeExpressions(node) {\n    pushScope();\n    handleSetStateUpdater(node);\n    markDestructuredFunctionArgumentsAsUsed(node);\n  }\n\n  function handleCustomValidators(component) {\n    const propTypes = component.declaredPropTypes;\n    if (!propTypes) {\n      return;\n    }\n\n    Object.keys(propTypes).forEach((key) => {\n      const node = propTypes[key].node;\n\n      if (node && node.value && astUtil.isFunctionLikeExpression(node.value)) {\n        markPropTypesAsUsed(node.value);\n      }\n    });\n  }\n\n  return {\n    VariableDeclarator(node) {\n      const unwrappedInitNode = ast.unwrapTSAsExpression(node.init);\n\n      // let props = this.props\n      if (isThisDotProps(unwrappedInitNode) && isInClassComponent(context, node) && node.id.type === 'Identifier') {\n        propVariables.set(node.id.name, []);\n      }\n\n      // Only handles destructuring\n      if (node.id.type !== 'ObjectPattern' || !unwrappedInitNode) {\n        return;\n      }\n\n      // let {props: {firstname}} = this\n      const propsProperty = node.id.properties.find((property) => (\n        property.key\n        && (property.key.name === 'props' || property.key.value === 'props')\n      ));\n\n      if (unwrappedInitNode.type === 'ThisExpression' && propsProperty && propsProperty.value.type === 'ObjectPattern') {\n        markPropTypesAsUsed(propsProperty.value);\n        return;\n      }\n\n      // let {props} = this\n      if (unwrappedInitNode.type === 'ThisExpression' && propsProperty && propsProperty.value.name === 'props') {\n        propVariables.set('props', []);\n        return;\n      }\n\n      // let {firstname} = props\n      if (\n        isCommonVariableNameForProps(unwrappedInitNode.name)\n        && (utils.getParentStatelessComponent(node) || isInLifeCycleMethod(node, checkAsyncSafeLifeCycles))\n      ) {\n        markPropTypesAsUsed(node.id);\n        return;\n      }\n\n      // let {firstname} = this.props\n      if (isThisDotProps(unwrappedInitNode) && isInClassComponent(context, node)) {\n        markPropTypesAsUsed(node.id);\n        return;\n      }\n\n      // let {firstname} = thing, where thing is defined by const thing = this.props.**.*\n      if (propVariables.get(unwrappedInitNode.name)) {\n        markPropTypesAsUsed(node.id, propVariables.get(unwrappedInitNode.name));\n      }\n    },\n\n    FunctionDeclaration: handleFunctionLikeExpressions,\n\n    ArrowFunctionExpression: handleFunctionLikeExpressions,\n\n    FunctionExpression: handleFunctionLikeExpressions,\n\n    'FunctionDeclaration:exit': popScope,\n\n    'ArrowFunctionExpression:exit': popScope,\n\n    'FunctionExpression:exit': popScope,\n\n    JSXSpreadAttribute(node) {\n      const component = components.get(utils.getParentComponent(node));\n      components.set(component ? component.node : node, {\n        ignoreUnusedPropTypesValidation: node.argument.type !== 'ObjectExpression',\n      });\n    },\n\n    'MemberExpression, OptionalMemberExpression'(node) {\n      if (isPropTypesUsageByMemberExpression(context, node, utils, checkAsyncSafeLifeCycles)) {\n        markPropTypesAsUsed(node);\n        return;\n      }\n\n      const propVariable = propVariables.get(ast.unwrapTSAsExpression(node.object).name);\n      if (propVariable) {\n        markPropTypesAsUsed(node, propVariable);\n      }\n    },\n\n    ObjectPattern(node) {\n      // If the object pattern is a destructured props object in a lifecycle\n      // method -- mark it for used props.\n      if (isNodeALifeCycleMethod(node.parent.parent, checkAsyncSafeLifeCycles) && node.properties.length > 0) {\n        markPropTypesAsUsed(node.parent);\n      }\n    },\n\n    'Program:exit'() {\n      values(components.list())\n        .filter((component) => mustBeValidated(component))\n        .forEach((component) => {\n          handleCustomValidators(component);\n        });\n    },\n  };\n};\n"
        }
    ]
}