{
    "sourceFile": "node_modules/eslint-plugin-react/lib/util/defaultProps.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892278677,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Common defaultProps detection functionality.\n */\n\n'use strict';\n\nconst fromEntries = require('object.fromentries');\nconst astUtil = require('./ast');\nconst componentUtil = require('./componentUtil');\nconst propsUtil = require('./props');\nconst variableUtil = require('./variable');\nconst propWrapperUtil = require('./propWrapper');\nconst getText = require('./eslint').getText;\n\nconst QUOTES_REGEX = /^[\"']|[\"']$/g;\n\nmodule.exports = function defaultPropsInstructions(context, components, utils) {\n  /**\n   * Try to resolve the node passed in to a variable in the current scope. If the node passed in is not\n   * an Identifier, then the node is simply returned.\n   * @param   {ASTNode} node The node to resolve.\n   * @returns {ASTNode|null} Return null if the value could not be resolved, ASTNode otherwise.\n   */\n  function resolveNodeValue(node) {\n    if (node.type === 'Identifier') {\n      return variableUtil.findVariableByName(context, node, node.name);\n    }\n    if (\n      astUtil.isCallExpression(node)\n      && propWrapperUtil.isPropWrapperFunction(context, node.callee.name)\n      && node.arguments && node.arguments[0]\n    ) {\n      return resolveNodeValue(node.arguments[0]);\n    }\n    return node;\n  }\n\n  /**\n   * Extracts a DefaultProp from an ObjectExpression node.\n   * @param   {ASTNode} objectExpression ObjectExpression node.\n   * @returns {Object|string}            Object representation of a defaultProp, to be consumed by\n   *                                     `addDefaultPropsToComponent`, or string \"unresolved\", if the defaultProps\n   *                                     from this ObjectExpression can't be resolved.\n   */\n  function getDefaultPropsFromObjectExpression(objectExpression) {\n    const hasSpread = objectExpression.properties.find((property) => property.type === 'ExperimentalSpreadProperty' || property.type === 'SpreadElement');\n\n    if (hasSpread) {\n      return 'unresolved';\n    }\n\n    return objectExpression.properties.map((defaultProp) => ({\n      name: getText(context, defaultProp.key).replace(QUOTES_REGEX, ''),\n      node: defaultProp,\n    }));\n  }\n\n  /**\n   * Marks a component's DefaultProps declaration as \"unresolved\". A component's DefaultProps is\n   * marked as \"unresolved\" if we cannot safely infer the values of its defaultProps declarations\n   * without risking false negatives.\n   * @param   {Object} component The component to mark.\n   * @returns {void}\n   */\n  function markDefaultPropsAsUnresolved(component) {\n    components.set(component.node, {\n      defaultProps: 'unresolved',\n    });\n  }\n\n  /**\n   * Adds defaultProps to the component passed in.\n   * @param   {ASTNode}         component    The component to add the defaultProps to.\n   * @param   {Object[]|'unresolved'} defaultProps defaultProps to add to the component or the string \"unresolved\"\n   *                                         if this component has defaultProps that can't be resolved.\n   * @returns {void}\n   */\n  function addDefaultPropsToComponent(component, defaultProps) {\n    // Early return if this component's defaultProps is already marked as \"unresolved\".\n    if (component.defaultProps === 'unresolved') {\n      return;\n    }\n\n    if (defaultProps === 'unresolved') {\n      markDefaultPropsAsUnresolved(component);\n      return;\n    }\n\n    const defaults = component.defaultProps || {};\n    const newDefaultProps = Object.assign(\n      {},\n      defaults,\n      fromEntries(defaultProps.map((prop) => [prop.name, prop]))\n    );\n\n    components.set(component.node, {\n      defaultProps: newDefaultProps,\n    });\n  }\n\n  return {\n    MemberExpression(node) {\n      const isDefaultProp = propsUtil.isDefaultPropsDeclaration(node);\n\n      if (!isDefaultProp) {\n        return;\n      }\n\n      // find component this defaultProps belongs to\n      const component = utils.getRelatedComponent(node);\n      if (!component) {\n        return;\n      }\n\n      // e.g.:\n      // MyComponent.propTypes = {\n      //   foo: React.PropTypes.string.isRequired,\n      //   bar: React.PropTypes.string\n      // };\n      //\n      // or:\n      //\n      // MyComponent.propTypes = myPropTypes;\n      if (node.parent.type === 'AssignmentExpression') {\n        const expression = resolveNodeValue(node.parent.right);\n        if (!expression || expression.type !== 'ObjectExpression') {\n          // If a value can't be found, we mark the defaultProps declaration as \"unresolved\", because\n          // we should ignore this component and not report any errors for it, to avoid false-positives\n          // with e.g. external defaultProps declarations.\n          if (isDefaultProp) {\n            markDefaultPropsAsUnresolved(component);\n          }\n\n          return;\n        }\n\n        addDefaultPropsToComponent(component, getDefaultPropsFromObjectExpression(expression));\n\n        return;\n      }\n\n      // e.g.:\n      // MyComponent.propTypes.baz = React.PropTypes.string;\n      if (node.parent.type === 'MemberExpression' && node.parent.parent\n        && node.parent.parent.type === 'AssignmentExpression') {\n        addDefaultPropsToComponent(component, [{\n          name: node.parent.property.name,\n          node: node.parent.parent,\n        }]);\n      }\n    },\n\n    // e.g.:\n    // class Hello extends React.Component {\n    //   static get defaultProps() {\n    //     return {\n    //       name: 'Dean'\n    //     };\n    //   }\n    //   render() {\n    //     return <div>Hello {this.props.name}</div>;\n    //   }\n    // }\n    MethodDefinition(node) {\n      if (!node.static || node.kind !== 'get') {\n        return;\n      }\n\n      if (!propsUtil.isDefaultPropsDeclaration(node)) {\n        return;\n      }\n\n      // find component this propTypes/defaultProps belongs to\n      const component = components.get(componentUtil.getParentES6Component(context, node));\n      if (!component) {\n        return;\n      }\n\n      const returnStatement = utils.findReturnStatement(node);\n      if (!returnStatement) {\n        return;\n      }\n\n      const expression = resolveNodeValue(returnStatement.argument);\n      if (!expression || expression.type !== 'ObjectExpression') {\n        return;\n      }\n\n      addDefaultPropsToComponent(component, getDefaultPropsFromObjectExpression(expression));\n    },\n\n    // e.g.:\n    // class Greeting extends React.Component {\n    //   render() {\n    //     return (\n    //       <h1>Hello, {this.props.foo} {this.props.bar}</h1>\n    //     );\n    //   }\n    //   static defaultProps = {\n    //     foo: 'bar',\n    //     bar: 'baz'\n    //   };\n    // }\n    'ClassProperty, PropertyDefinition'(node) {\n      if (!(node.static && node.value)) {\n        return;\n      }\n\n      const propName = astUtil.getPropertyName(node);\n      const isDefaultProp = propName === 'defaultProps' || propName === 'getDefaultProps';\n\n      if (!isDefaultProp) {\n        return;\n      }\n\n      // find component this propTypes/defaultProps belongs to\n      const component = components.get(componentUtil.getParentES6Component(context, node));\n      if (!component) {\n        return;\n      }\n\n      const expression = resolveNodeValue(node.value);\n      if (!expression || expression.type !== 'ObjectExpression') {\n        return;\n      }\n\n      addDefaultPropsToComponent(component, getDefaultPropsFromObjectExpression(expression));\n    },\n\n    // e.g.:\n    // React.createClass({\n    //   render: function() {\n    //     return <div>{this.props.foo}</div>;\n    //   },\n    //   getDefaultProps: function() {\n    //     return {\n    //       foo: 'default'\n    //     };\n    //   }\n    // });\n    ObjectExpression(node) {\n      // find component this propTypes/defaultProps belongs to\n      const component = componentUtil.isES5Component(node, context) && components.get(node);\n      if (!component) {\n        return;\n      }\n\n      // Search for the proptypes declaration\n      node.properties.forEach((property) => {\n        if (property.type === 'ExperimentalSpreadProperty' || property.type === 'SpreadElement') {\n          return;\n        }\n\n        const isDefaultProp = propsUtil.isDefaultPropsDeclaration(property);\n\n        if (isDefaultProp && property.value.type === 'FunctionExpression') {\n          const returnStatement = utils.findReturnStatement(property);\n          if (!returnStatement || returnStatement.argument.type !== 'ObjectExpression') {\n            return;\n          }\n\n          addDefaultPropsToComponent(component, getDefaultPropsFromObjectExpression(returnStatement.argument));\n        }\n      });\n    },\n  };\n};\n"
        }
    ]
}