{
    "sourceFile": "node_modules/eslint-plugin-import/docs/rules/no-named-as-default-member.md",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892250998,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "# import/no-named-as-default-member\n\n‚ö†Ô∏è This rule _warns_ in the following configs: ‚òëÔ∏è `recommended`, üö∏ `warnings`.\n\n<!-- end auto-generated rule header -->\n\nReports use of an exported name as a property on the default export.\n\nRationale: Accessing a property that has a name that is shared by an exported\nname from the same module is likely to be a mistake.\n\nNamed import syntax looks very similar to destructuring assignment. It's easy to\nmake the (incorrect) assumption that named exports are also accessible as\nproperties of the default export.\n\nFurthermore, [in Babel 5 this is actually how things worked][blog]. This was\nfixed in Babel 6. Before upgrading an existing codebase to Babel 6, it can be\nuseful to run this lint rule.\n\n[blog]: https://kentcdodds.com/blog/misunderstanding-es6-modules-upgrading-babel-tears-and-a-solution\n\n## Rule Details\n\nGiven:\n\n```js\n// foo.js\nexport default 'foo';\nexport const bar = 'baz';\n```\n\n...this would be valid:\n\n```js\nimport foo, {bar} from './foo.js';\n```\n\n...and the following would be reported:\n\n```js\n// Caution: `foo` also has a named export `bar`.\n// Check if you meant to write `import {bar} from './foo.js'` instead.\nimport foo from './foo.js';\nconst bar = foo.bar;\n```\n\n```js\n// Caution: `foo` also has a named export `bar`.\n// Check if you meant to write `import {bar} from './foo.js'` instead.\nimport foo from './foo.js';\nconst {bar} = foo;\n```\n"
        }
    ]
}