{
    "sourceFile": "node_modules/eslint-plugin-import/docs/rules/namespace.md",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892250167,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "# import/namespace\n\nüíº This rule is enabled in the following configs: ‚ùó `errors`, ‚òëÔ∏è `recommended`.\n\n<!-- end auto-generated rule header -->\n\nEnforces names exist at the time they are dereferenced, when imported as a full namespace (i.e. `import * as foo from './foo'; foo.bar();` will report if `bar` is not exported by `./foo`.).\n\nWill report at the import declaration if there are _no_ exported names found.\n\nAlso, will report for computed references (i.e. `foo[\"bar\"]()`).\n\nReports on assignment to a member of an imported namespace.\n\nNote: for packages, the plugin will find exported names\nfrom [`jsnext:main`], if present in `package.json`.\nRedux's npm module includes this key, and thereby is lintable, for example.\n\nA module path that is [ignored] or not [unambiguously an ES module] will not be reported when imported.\n\n[ignored]: ../README.md#importignore\n[unambiguously an ES module]: https://github.com/bmeck/UnambiguousJavaScriptGrammar\n\n## Rule Details\n\nCurrently, this rule does not check for possible\nredefinition of the namespace in an intermediate scope. Adherence to the ESLint\n`no-shadow` rule for namespaces will prevent this from being a problem.\n\nFor [ES7], reports if an exported namespace would be empty (no names exported from the referenced module.)\n\nGiven:\n\n```js\n// @module ./named-exports\nexport const a = 1\nconst b = 2\nexport { b }\n\nconst c = 3\nexport { c as d }\n\nexport class ExportedClass { }\n\n// ES7\nexport * as deep from './deep'\n```\n\nand:\n\n```js\n// @module ./deep\nexport const e = \"MC2\"\n```\n\nSee what is valid and reported:\n\n```js\n// @module ./foo\nimport * as names from './named-exports'\n\nfunction great() {\n  return names.a + names.b  // so great https://youtu.be/ei7mb8UxEl8\n}\n\nfunction notGreat() {\n  doSomethingWith(names.c) // Reported: 'c' not found in imported namespace 'names'.\n\n  const { a, b, c } = names // also reported, only for 'c'\n}\n\n// also tunnels through re-exported namespaces!\nfunction deepTrouble() {\n  doSomethingWith(names.deep.e) // fine\n  doSomethingWith(names.deep.f) // Reported: 'f' not found in deeply imported namespace 'names.deep'.\n}\n\n```\n\n### Options\n\n#### `allowComputed`\n\nDefaults to `false`. When false, will report the following:\n\n```js\n/*eslint import/namespace: [2, { allowComputed: false }]*/\nimport * as a from './a'\n\nfunction f(x) {\n  return a[x] // Unable to validate computed reference to imported namespace 'a'.\n}\n```\n\nWhen set to `true`, the above computed namespace member reference is allowed, but\nstill can't be statically analyzed any further.\n\n## Further Reading\n\n - Lee Byron's [ES7] export proposal\n - [`import/ignore`] setting\n - [`jsnext:main`](Rollup)\n\n[ES7]: https://github.com/leebyron/ecmascript-more-export-from\n[`import/ignore`]: ../../README.md#importignore\n[`jsnext:main`]: https://github.com/rollup/rollup/wiki/jsnext:main\n"
        }
    ]
}