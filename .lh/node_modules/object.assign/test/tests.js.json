{
    "sourceFile": "node_modules/object.assign/test/tests.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892946230,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "'use strict';\n\nvar hasSymbols = require('has-symbols/shams')();\nvar forEach = require('for-each');\nvar hasOwn = require('hasown');\nvar mockProperty = require('mock-property');\n\nmodule.exports = function (assign, t) {\n\tt.test('error cases', function (st) {\n\t\tst['throws'](function () { assign(null); }, TypeError, 'target must be an object');\n\t\tst['throws'](function () { assign(undefined); }, TypeError, 'target must be an object');\n\t\tst['throws'](function () { assign(null, {}); }, TypeError, 'target must be an object');\n\t\tst['throws'](function () { assign(undefined, {}); }, TypeError, 'target must be an object');\n\t\tst.end();\n\t});\n\n\tt.test('non-object target, no sources', function (st) {\n\t\tvar bool = assign(true);\n\t\tst.equal(typeof bool, 'object', 'bool is object');\n\t\tst.equal(Boolean.prototype.valueOf.call(bool), true, 'bool coerces to `true`');\n\n\t\tvar number = assign(1);\n\t\tst.equal(typeof number, 'object', 'number is object');\n\t\tst.equal(Number.prototype.valueOf.call(number), 1, 'number coerces to `1`');\n\n\t\tvar string = assign('1');\n\t\tst.equal(typeof string, 'object', 'number is object');\n\t\tst.equal(String.prototype.valueOf.call(string), '1', 'number coerces to `\"1\"`');\n\n\t\tst.end();\n\t});\n\n\tt.test('non-object target, with sources', function (st) {\n\t\tvar signal = {};\n\n\t\tst.test('boolean', function (st2) {\n\t\t\tvar bool = assign(true, { a: signal });\n\t\t\tst2.equal(typeof bool, 'object', 'bool is object');\n\t\t\tst2.equal(Boolean.prototype.valueOf.call(bool), true, 'bool coerces to `true`');\n\t\t\tst2.equal(bool.a, signal, 'source properties copied');\n\t\t\tst2.end();\n\t\t});\n\n\t\tst.test('number', function (st2) {\n\t\t\tvar number = assign(1, { a: signal });\n\t\t\tst2.equal(typeof number, 'object', 'number is object');\n\t\t\tst2.equal(Number.prototype.valueOf.call(number), 1, 'number coerces to `1`');\n\t\t\tst2.equal(number.a, signal, 'source properties copied');\n\t\t\tst2.end();\n\t\t});\n\n\t\tst.test('string', function (st2) {\n\t\t\tvar string = assign('1', { a: signal });\n\t\t\tst2.equal(typeof string, 'object', 'number is object');\n\t\t\tst2.equal(String.prototype.valueOf.call(string), '1', 'number coerces to `\"1\"`');\n\t\t\tst2.equal(string.a, signal, 'source properties copied');\n\t\t\tst2.end();\n\t\t});\n\n\t\tst.end();\n\t});\n\n\tt.test('non-object sources', function (st) {\n\t\tst.deepEqual(assign({ a: 1 }, null, { b: 2 }), { a: 1, b: 2 }, 'ignores null source');\n\t\tst.deepEqual(assign({ a: 1 }, { b: 2 }, undefined), { a: 1, b: 2 }, 'ignores undefined source');\n\t\tst.end();\n\t});\n\n\tt.test('returns the modified target object', function (st) {\n\t\tvar target = {};\n\t\tvar returned = assign(target, { a: 1 });\n\t\tst.equal(returned, target, 'returned object is the same reference as the target object');\n\t\tst.end();\n\t});\n\n\tt.test('has the right length', function (st) {\n\t\tst.equal(assign.length, 2, 'length is 2 => 2 required arguments');\n\t\tst.end();\n\t});\n\n\tt.test('merge two objects', function (st) {\n\t\tvar target = { a: 1 };\n\t\tvar returned = assign(target, { b: 2 });\n\t\tst.deepEqual(returned, { a: 1, b: 2 }, 'returned object has properties from both');\n\t\tst.end();\n\t});\n\n\tt.test('works with functions', function (st) {\n\t\tvar target = function () {};\n\t\ttarget.a = 1;\n\t\tvar returned = assign(target, { b: 2 });\n\t\tst.equal(target, returned, 'returned object is target');\n\t\tst.equal(returned.a, 1);\n\t\tst.equal(returned.b, 2);\n\t\tst.end();\n\t});\n\n\tt.test('works with primitives', function (st) {\n\t\tvar target = 2;\n\t\tvar source = { b: 42 };\n\t\tvar returned = assign(target, source);\n\t\tst.equal(Object.prototype.toString.call(returned), '[object Number]', 'returned is object form of number primitive');\n\t\tst.equal(Number(returned), target, 'returned and target have same valueOf');\n\t\tst.equal(returned.b, source.b);\n\t\tst.end();\n\t});\n\n\t/* globals window */\n\tt.test('works with window.location', { skip: typeof window === 'undefined' }, function (st) {\n\t\tvar target = {};\n\t\tassign(target, window.location);\n\t\tfor (var prop in window.location) {\n\t\t\tif (hasOwn(window.location, prop)) {\n\t\t\t\tst.deepEqual(target[prop], window.location[prop], prop + ' is copied');\n\t\t\t}\n\t\t}\n\t\tst.end();\n\t});\n\n\tt.test('merge N objects', function (st) {\n\t\tvar target = { a: 1 };\n\t\tvar source1 = { b: 2 };\n\t\tvar source2 = { c: 3 };\n\t\tvar returned = assign(target, source1, source2);\n\t\tst.deepEqual(returned, { a: 1, b: 2, c: 3 }, 'returned object has properties from all sources');\n\t\tst.end();\n\t});\n\n\tt.test('only iterates over own keys', function (st) {\n\t\tvar Foo = function () {};\n\t\tFoo.prototype.bar = true;\n\t\tvar foo = new Foo();\n\t\tfoo.baz = true;\n\t\tvar target = { a: 1 };\n\t\tvar returned = assign(target, foo);\n\t\tst.equal(returned, target, 'returned object is the same reference as the target object');\n\t\tst.deepEqual(target, { a: 1, baz: true }, 'returned object has only own properties from both');\n\t\tst.end();\n\t});\n\n\tt.test('includes enumerable symbols, after keys', { skip: !hasSymbols }, function (st) {\n\t\tvar visited = [];\n\t\tvar obj = {};\n\t\tObject.defineProperty(obj, 'a', { enumerable: true, get: function () { visited.push('a'); return 42; } });\n\t\tvar symbol = Symbol('enumerable');\n\t\tObject.defineProperty(obj, symbol, {\n\t\t\tenumerable: true,\n\t\t\tget: function () { visited.push(symbol); return Infinity; }\n\t\t});\n\t\tvar nonEnumSymbol = Symbol('non-enumerable');\n\t\tObject.defineProperty(obj, nonEnumSymbol, {\n\t\t\tenumerable: false,\n\t\t\tget: function () { visited.push(nonEnumSymbol); return -Infinity; }\n\t\t});\n\t\tvar target = assign({}, obj);\n\t\tst.deepEqual(visited, ['a', symbol], 'key is visited first, then symbol');\n\t\tst.equal(target.a, 42, 'target.a is 42');\n\t\tst.equal(target[symbol], Infinity, 'target[symbol] is Infinity');\n\t\tst.notEqual(target[nonEnumSymbol], -Infinity, 'target[nonEnumSymbol] is not -Infinity');\n\t\tst.end();\n\t});\n\n\tt.test('does not fail when symbols are not present', { skip: !Object.isFrozen || Object.isFrozen(Object) }, function (st) {\n\t\tst.teardown(mockProperty(Object, 'getOwnPropertySymbols', { 'delete': true }));\n\n\t\tvar visited = [];\n\t\tvar obj = {};\n\t\tObject.defineProperty(obj, 'a', { enumerable: true, get: function () { visited.push('a'); return 42; } });\n\t\tvar keys = ['a'];\n\t\tif (hasSymbols) {\n\t\t\tvar symbol = Symbol('sym');\n\t\t\tObject.defineProperty(obj, symbol, {\n\t\t\t\tenumerable: true,\n\t\t\t\tget: function () { visited.push(symbol); return Infinity; }\n\t\t\t});\n\t\t\tkeys.push(symbol);\n\t\t}\n\t\tvar target = assign({}, obj);\n\t\tst.deepEqual(visited, keys, 'assign visits expected keys');\n\t\tst.equal(target.a, 42, 'target.a is 42');\n\n\t\tif (hasSymbols) {\n\t\t\tst.equal(target[symbol], Infinity);\n\t\t}\n\t\tst.end();\n\t});\n\n\tt.test('preserves correct property enumeration order', function (st) {\n\t\tvar str = 'abcdefghijklmnopqrst';\n\t\tvar letters = {};\n\t\tforEach(str.split(''), function (letter) {\n\t\t\tletters[letter] = letter;\n\t\t});\n\n\t\tvar n = 5;\n\t\tst.comment('run the next test ' + n + ' times');\n\t\tvar object = assign({}, letters);\n\t\tvar actual = '';\n\t\tfor (var k in object) {\n\t\t\tactual += k;\n\t\t}\n\t\tfor (var i = 0; i < n; ++i) {\n\t\t\tst.equal(actual, str, 'property enumeration order should be followed');\n\t\t}\n\t\tst.end();\n\t});\n\n\tt.test('checks enumerability and existence, in case of modification during [[Get]]', { skip: !Object.defineProperty }, function (st) {\n\t\tvar targetBvalue = {};\n\t\tvar targetCvalue = {};\n\t\tvar target = { b: targetBvalue, c: targetCvalue };\n\t\tvar source = {};\n\t\tObject.defineProperty(source, 'a', {\n\t\t\tenumerable: true,\n\t\t\tget: function () {\n\t\t\t\tdelete this.b;\n\t\t\t\tObject.defineProperty(this, 'c', { enumerable: false });\n\t\t\t\treturn 'a';\n\t\t\t}\n\t\t});\n\t\tvar sourceBvalue = {};\n\t\tvar sourceCvalue = {};\n\t\tsource.b = sourceBvalue;\n\t\tsource.c = sourceCvalue;\n\t\tvar result = assign(target, source);\n\t\tst.equal(result, target, 'sanity check: result is === target');\n\t\tst.equal(result.b, targetBvalue, 'target key not overwritten by deleted source key');\n\t\tst.equal(result.c, targetCvalue, 'target key not overwritten by non-enumerable source key');\n\n\t\tst.end();\n\t});\n};\n"
        }
    ]
}