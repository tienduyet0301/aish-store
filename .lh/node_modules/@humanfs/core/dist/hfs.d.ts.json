{
    "sourceFile": "node_modules/@humanfs/core/dist/hfs.d.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891878642,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * Error to represent when a method is missing on an impl.\n */\nexport class NoSuchMethodError extends Error {\n    /**\n     * Creates a new instance.\n     * @param {string} methodName The name of the method that was missing.\n     */\n    constructor(methodName: string);\n}\n/**\n * Error to represent when a method is not supported on an impl. This happens\n * when a method on `Hfs` is called with one name and the corresponding method\n * on the impl has a different name. (Example: `text()` and `bytes()`.)\n */\nexport class MethodNotSupportedError extends Error {\n    /**\n     * Creates a new instance.\n     * @param {string} methodName The name of the method that was missing.\n     */\n    constructor(methodName: string);\n}\n/**\n * Error to represent when an impl is already set.\n */\nexport class ImplAlreadySetError extends Error {\n    /**\n     * Creates a new instance.\n     */\n    constructor();\n}\n/**\n * A class representing a log entry.\n */\nexport class LogEntry {\n    /**\n     * Creates a new instance.\n     * @param {string} type The type of log entry.\n     * @param {any} [data] The data associated with the log entry.\n     */\n    constructor(type: string, data?: any);\n    /**\n     * The type of log entry.\n     * @type {string}\n     */\n    type: string;\n    /**\n     * The data associated with the log entry.\n     * @type {any}\n     */\n    data: any;\n    /**\n     * The time at which the log entry was created.\n     * @type {number}\n     */\n    timestamp: number;\n}\n/**\n * A class representing a file system utility library.\n * @implements {HfsImpl}\n */\nexport class Hfs implements HfsImpl {\n    /**\n     * Creates a new instance.\n     * @param {object} options The options for the instance.\n     * @param {HfsImpl} options.impl The implementation to use.\n     */\n    constructor({ impl }: {\n        impl: HfsImpl;\n    });\n    /**\n     * Starts a new log with the given name.\n     * @param {string} name The name of the log to start;\n     * @returns {void}\n     * @throws {Error} When the log already exists.\n     * @throws {TypeError} When the name is not a non-empty string.\n     */\n    logStart(name: string): void;\n    /**\n     * Ends a log with the given name and returns the entries.\n     * @param {string} name The name of the log to end.\n     * @returns {Array<LogEntry>} The entries in the log.\n     * @throws {Error} When the log does not exist.\n     */\n    logEnd(name: string): Array<LogEntry>;\n    /**\n     * Determines if the current implementation is the base implementation.\n     * @returns {boolean} True if the current implementation is the base implementation.\n     */\n    isBaseImpl(): boolean;\n    /**\n     * Sets the implementation for this instance.\n     * @param {object} impl The implementation to use.\n     * @returns {void}\n     */\n    setImpl(impl: object): void;\n    /**\n     * Resets the implementation for this instance back to its original.\n     * @returns {void}\n     */\n    resetImpl(): void;\n    /**\n     * Reads the given file and returns the contents as text. Assumes UTF-8 encoding.\n     * @param {string|URL} filePath The file to read.\n     * @returns {Promise<string|undefined>} The contents of the file.\n     * @throws {NoSuchMethodError} When the method does not exist on the current implementation.\n     * @throws {TypeError} When the file path is not a non-empty string.\n     */\n    text(filePath: string | URL): Promise<string | undefined>;\n    /**\n     * Reads the given file and returns the contents as JSON. Assumes UTF-8 encoding.\n     * @param {string|URL} filePath The file to read.\n     * @returns {Promise<any|undefined>} The contents of the file as JSON.\n     * @throws {NoSuchMethodError} When the method does not exist on the current implementation.\n     * @throws {SyntaxError} When the file contents are not valid JSON.\n     * @throws {TypeError} When the file path is not a non-empty string.\n     */\n    json(filePath: string | URL): Promise<any | undefined>;\n    /**\n     * Reads the given file and returns the contents as an ArrayBuffer.\n     * @param {string|URL} filePath The file to read.\n     * @returns {Promise<ArrayBuffer|undefined>} The contents of the file as an ArrayBuffer.\n     * @throws {NoSuchMethodError} When the method does not exist on the current implementation.\n     * @throws {TypeError} When the file path is not a non-empty string.\n     * @deprecated Use bytes() instead.\n     */\n    arrayBuffer(filePath: string | URL): Promise<ArrayBuffer | undefined>;\n    /**\n     * Reads the given file and returns the contents as an Uint8Array.\n     * @param {string|URL} filePath The file to read.\n     * @returns {Promise<Uint8Array|undefined>} The contents of the file as an Uint8Array.\n     * @throws {NoSuchMethodError} When the method does not exist on the current implementation.\n     * @throws {TypeError} When the file path is not a non-empty string.\n     */\n    bytes(filePath: string | URL): Promise<Uint8Array | undefined>;\n    /**\n     * Writes the given data to the given file. Creates any necessary directories along the way.\n     * If the data is a string, UTF-8 encoding is used.\n     * @param {string|URL} filePath The file to write.\n     * @param {string|ArrayBuffer|ArrayBufferView} contents The data to write.\n     * @returns {Promise<void>} A promise that resolves when the file is written.\n     * @throws {NoSuchMethodError} When the method does not exist on the current implementation.\n     * @throws {TypeError} When the file path is not a non-empty string.\n     */\n    write(filePath: string | URL, contents: string | ArrayBuffer | ArrayBufferView): Promise<void>;\n    /**\n     * Appends the given data to the given file. Creates any necessary directories along the way.\n     * If the data is a string, UTF-8 encoding is used.\n     * @param {string|URL} filePath The file to append to.\n     * @param {string|ArrayBuffer|ArrayBufferView} contents The data to append.\n     * @returns {Promise<void>} A promise that resolves when the file is appended to.\n     * @throws {NoSuchMethodError} When the method does not exist on the current implementation.\n     * @throws {TypeError} When the file path is not a non-empty string.\n     * @throws {TypeError} When the file contents are not a string or ArrayBuffer.\n     * @throws {Error} When the file cannot be appended to.\n     */\n    append(filePath: string | URL, contents: string | ArrayBuffer | ArrayBufferView): Promise<void>;\n    /**\n     * Determines if the given file exists.\n     * @param {string|URL} filePath The file to check.\n     * @returns {Promise<boolean>} True if the file exists.\n     * @throws {NoSuchMethodError} When the method does not exist on the current implementation.\n     * @throws {TypeError} When the file path is not a non-empty string.\n     */\n    isFile(filePath: string | URL): Promise<boolean>;\n    /**\n     * Determines if the given directory exists.\n     * @param {string|URL} dirPath The directory to check.\n     * @returns {Promise<boolean>} True if the directory exists.\n     * @throws {NoSuchMethodError} When the method does not exist on the current implementation.\n     * @throws {TypeError} When the directory path is not a non-empty string.\n     */\n    isDirectory(dirPath: string | URL): Promise<boolean>;\n    /**\n     * Creates the given directory.\n     * @param {string|URL} dirPath The directory to create.\n     * @returns {Promise<void>} A promise that resolves when the directory is created.\n     * @throws {NoSuchMethodError} When the method does not exist on the current implementation.\n     * @throws {TypeError} When the directory path is not a non-empty string.\n     */\n    createDirectory(dirPath: string | URL): Promise<void>;\n    /**\n     * Deletes the given file or empty directory.\n     * @param {string|URL} filePath The file to delete.\n     * @returns {Promise<boolean>} A promise that resolves when the file or\n     *   directory is deleted, true if the file or directory is deleted, false\n     *   if the file or directory does not exist.\n     * @throws {NoSuchMethodError} When the method does not exist on the current implementation.\n     * @throws {TypeError} When the file path is not a non-empty string.\n     */\n    delete(filePath: string | URL): Promise<boolean>;\n    /**\n     * Deletes the given file or directory recursively.\n     * @param {string|URL} dirPath The directory to delete.\n     * @returns {Promise<boolean>} A promise that resolves when the file or\n     *   directory is deleted, true if the file or directory is deleted, false\n     *   if the file or directory does not exist.\n     * @throws {NoSuchMethodError} When the method does not exist on the current implementation.\n     * @throws {TypeError} When the directory path is not a non-empty string.\n     */\n    deleteAll(dirPath: string | URL): Promise<boolean>;\n    /**\n     * Returns a list of directory entries for the given path.\n     * @param {string|URL} dirPath The path to the directory to read.\n     * @returns {AsyncIterable<HfsDirectoryEntry>} A promise that resolves with the\n     *   directory entries.\n     * @throws {TypeError} If the directory path is not a string or URL.\n     * @throws {Error} If the directory cannot be read.\n     */\n    list(dirPath: string | URL): AsyncIterable<HfsDirectoryEntry>;\n    /**\n     * Walks a directory using a depth-first traversal and returns the entries\n     * from the traversal.\n     * @param {string|URL} dirPath The path to the directory to walk.\n     * @param {Object} [options] The options for the walk.\n     * @param {(entry:HfsWalkEntry) => Promise<boolean>|boolean} [options.directoryFilter] A filter function to determine\n     * \tif a directory's entries should be included in the walk.\n     * @param {(entry:HfsWalkEntry) => Promise<boolean>|boolean} [options.entryFilter] A filter function to determine if\n     * \tan entry should be included in the walk.\n     * @returns {AsyncIterable<HfsWalkEntry>} A promise that resolves with the\n     * \tdirectory entries.\n     * @throws {TypeError} If the directory path is not a string or URL.\n     * @throws {Error} If the directory cannot be read.\n     */\n    walk(dirPath: string | URL, { directoryFilter, entryFilter }?: {\n        directoryFilter?: (entry: HfsWalkEntry) => Promise<boolean> | boolean;\n        entryFilter?: (entry: HfsWalkEntry) => Promise<boolean> | boolean;\n    }): AsyncIterable<HfsWalkEntry>;\n    /**\n     * Returns the size of the given file.\n     * @param {string|URL} filePath The path to the file to read.\n     * @returns {Promise<number>} A promise that resolves with the size of the file.\n     * @throws {TypeError} If the file path is not a string or URL.\n     * @throws {Error} If the file cannot be read.\n     */\n    size(filePath: string | URL): Promise<number>;\n    /**\n     * Returns the last modified timestamp of the given file or directory.\n     * @param {string|URL} fileOrDirPath The path to the file or directory.\n     * @returns {Promise<Date|undefined>} A promise that resolves with the last modified date\n     *  or undefined if the file or directory does not exist.\n     * @throws {TypeError} If the path is not a string or URL.\n     */\n    lastModified(fileOrDirPath: string | URL): Promise<Date | undefined>;\n    /**\n     * Copys a file from one location to another.\n     * @param {string|URL} source The path to the file to copy.\n     * @param {string|URL} destination The path to the new file.\n     * @returns {Promise<void>} A promise that resolves when the file is copied.\n     * @throws {TypeError} If the file path is not a string or URL.\n     * @throws {Error} If the file cannot be copied.\n     */\n    copy(source: string | URL, destination: string | URL): Promise<void>;\n    /**\n     * Copies a file or directory from one location to another.\n     * @param {string|URL} source The path to the file or directory to copy.\n     * @param {string|URL} destination The path to copy the file or directory to.\n     * @returns {Promise<void>} A promise that resolves when the file or directory is\n     * copied.\n     * @throws {TypeError} If the directory path is not a string or URL.\n     * @throws {Error} If the directory cannot be copied.\n     */\n    copyAll(source: string | URL, destination: string | URL): Promise<void>;\n    /**\n     * Moves a file from the source path to the destination path.\n     * @param {string|URL} source The location of the file to move.\n     * @param {string|URL} destination The destination of the file to move.\n     * @returns {Promise<void>} A promise that resolves when the move is complete.\n     * @throws {TypeError} If the file or directory paths are not strings.\n     * @throws {Error} If the file or directory cannot be moved.\n     */\n    move(source: string | URL, destination: string | URL): Promise<void>;\n    /**\n     * Moves a file or directory from one location to another.\n     * @param {string|URL} source The path to the file or directory to move.\n     * @param {string|URL} destination The path to move the file or directory to.\n     * @returns {Promise<void>} A promise that resolves when the file or directory is\n     * moved.\n     * @throws {TypeError} If the source is not a string or URL.\n     * @throws {TypeError} If the destination is not a string or URL.\n     * @throws {Error} If the file or directory cannot be moved.\n     */\n    moveAll(source: string | URL, destination: string | URL): Promise<void>;\n    #private;\n}\nexport type HfsImpl = import(\"@humanfs/types\").HfsImpl;\nexport type HfsDirectoryEntry = import(\"@humanfs/types\").HfsDirectoryEntry;\nexport type HfsWalkEntry = import(\"@humanfs/types\").HfsWalkEntry;\n"
        }
    ]
}