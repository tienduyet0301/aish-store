{
    "sourceFile": "node_modules/@humanfs/core/dist/path.d.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891878682,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "export class Path {\n    /**\n     * Creates a new path based on the argument type. If the argument is a string,\n     * it is assumed to be a file or directory path and is converted to a Path\n     * instance. If the argument is a URL, it is assumed to be a file URL and is\n     * converted to a Path instance. If the argument is a Path instance, it is\n     * copied into a new Path instance. If the argument is an array, it is assumed\n     * to be the steps of a path and is used to create a new Path instance.\n     * @param {string|URL|Path|Array<string>} pathish The value to convert to a Path instance.\n     * @returns {Path} A new Path instance.\n     * @throws {TypeError} When pathish is not a string, URL, Path, or Array.\n     * @throws {TypeError} When pathish is a string and is empty.\n     */\n    static from(pathish: string | URL | Path | Array<string>): Path;\n    /**\n     * Creates a new Path instance from a string.\n     * @param {string} fileOrDirPath The file or directory path to convert.\n     * @returns {Path} A new Path instance.\n     * @deprecated Use Path.from() instead.\n     */\n    static fromString(fileOrDirPath: string): Path;\n    /**\n     * Creates a new Path instance from a URL.\n     * @param {URL} url The URL to convert.\n     * @returns {Path} A new Path instance.\n     * @throws {TypeError} When url is not a URL instance.\n     * @throws {TypeError} When url.pathname is empty.\n     * @throws {TypeError} When url.protocol is not \"file:\".\n     * @deprecated Use Path.from() instead.\n     */\n    static fromURL(url: URL): Path;\n    /**\n     * Creates a new instance.\n     * @param {Iterable<string>} [steps] The steps to use for the path.\n     * @throws {TypeError} When steps is not iterable.\n     */\n    constructor(steps?: Iterable<string>);\n    /**\n     * Adds steps to the end of the path.\n     * @param  {...string} steps The steps to add to the path.\n     * @returns {void}\n     */\n    push(...steps: string[]): void;\n    /**\n     * Removes the last step from the path.\n     * @returns {string} The last step in the path.\n     */\n    pop(): string;\n    /**\n     * Returns an iterator for steps in the path.\n     * @returns {IterableIterator<string>} An iterator for the steps in the path.\n     */\n    steps(): IterableIterator<string>;\n    /**\n     * Sets the name (the last step) of the path.\n     * @type {string}\n     */\n    set name(value: string);\n    /**\n     * Retrieves the name (the last step) of the path.\n     * @type {string}\n     */\n    get name(): string;\n    /**\n     * Retrieves the size of the path.\n     * @type {number}\n     */\n    get size(): number;\n    /**\n     * Returns the path as a string.\n     * @returns {string} The path as a string.\n     */\n    toString(): string;\n    /**\n     * Returns an iterator for the steps in the path.\n     * @returns {IterableIterator<string>} An iterator for the steps in the path.\n     */\n    [Symbol.iterator](): IterableIterator<string>;\n    #private;\n}\nexport type HfsImpl = import(\"@humanfs/types\").HfsImpl;\nexport type HfsDirectoryEntry = import(\"@humanfs/types\").HfsDirectoryEntry;\n"
        }
    ]
}