{
    "sourceFile": "node_modules/@humanfs/core/dist/fsx.d.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891878620,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview The main file for the hfs package.\n * @author Nicholas C. Zakas\n */\n/** @typedef{import(\"@humanfs/types\").HfsImpl} HfsImpl */\n/** @typedef{import(\"@humanfs/types\").HfsDirectoryEntry} HfsDirectoryEntry */\n/**\n * Error to represent when a method is missing on an impl.\n */\nexport class NoSuchMethodError extends Error {\n    /**\n     * Creates a new instance.\n     * @param {string} methodName The name of the method that was missing.\n     */\n    constructor(methodName: string);\n}\n/**\n * Error to represent when an impl is already set.\n */\nexport class ImplAlreadySetError extends Error {\n    /**\n     * Creates a new instance.\n     */\n    constructor();\n}\n/**\n * A class representing a log entry.\n */\nexport class LogEntry {\n    /**\n     * Creates a new instance.\n     * @param {string} type The type of log entry.\n     * @param {any} [data] The data associated with the log entry.\n     */\n    constructor(type: string, data?: any);\n    /**\n     * The time at which the log entry was created.\n     * @type {number}\n     */\n    timestamp: number;\n    methodName: string;\n    data: any;\n    #private;\n}\n/**\n * A class representing a file system utility library.\n * @implements {HfsImpl}\n */\nexport class Hfs implements HfsImpl {\n    /**\n     * Creates a new instance.\n     * @param {object} options The options for the instance.\n     * @param {HfsImpl} options.impl The implementation to use.\n     */\n    constructor({ impl }: {\n        impl: HfsImpl;\n    });\n    /**\n     * Starts a new log with the given name.\n     * @param {string} name The name of the log to start;\n     * @returns {void}\n     * @throws {Error} When the log already exists.\n     * @throws {TypeError} When the name is not a non-empty string.\n     */\n    logStart(name: string): void;\n    /**\n     * Ends a log with the given name and returns the entries.\n     * @param {string} name The name of the log to end.\n     * @returns {Array<LogEntry>} The entries in the log.\n     * @throws {Error} When the log does not exist.\n     */\n    logEnd(name: string): Array<LogEntry>;\n    /**\n     * Determines if the current implementation is the base implementation.\n     * @returns {boolean} True if the current implementation is the base implementation.\n     */\n    isBaseImpl(): boolean;\n    /**\n     * Sets the implementation for this instance.\n     * @param {object} impl The implementation to use.\n     * @returns {void}\n     */\n    setImpl(impl: object): void;\n    /**\n     * Resets the implementation for this instance back to its original.\n     * @returns {void}\n     */\n    resetImpl(): void;\n    /**\n     * Reads the given file and returns the contents as text. Assumes UTF-8 encoding.\n     * @param {string} filePath The file to read.\n     * @returns {Promise<string|undefined>} The contents of the file.\n     * @throws {NoSuchMethodError} When the method does not exist on the current implementation.\n     * @throws {TypeError} When the file path is not a non-empty string.\n     */\n    text(filePath: string): Promise<string | undefined>;\n    /**\n     * Reads the given file and returns the contents as JSON. Assumes UTF-8 encoding.\n     * @param {string} filePath The file to read.\n     * @returns {Promise<any|undefined>} The contents of the file as JSON.\n     * @throws {NoSuchMethodError} When the method does not exist on the current implementation.\n     * @throws {SyntaxError} When the file contents are not valid JSON.\n     * @throws {TypeError} When the file path is not a non-empty string.\n     */\n    json(filePath: string): Promise<any | undefined>;\n    /**\n     * Reads the given file and returns the contents as an ArrayBuffer.\n     * @param {string} filePath The file to read.\n     * @returns {Promise<ArrayBuffer|undefined>} The contents of the file as an ArrayBuffer.\n     * @throws {NoSuchMethodError} When the method does not exist on the current implementation.\n     * @throws {TypeError} When the file path is not a non-empty string.\n     * @deprecated Use bytes() instead.\n     */\n    arrayBuffer(filePath: string): Promise<ArrayBuffer | undefined>;\n    /**\n     * Reads the given file and returns the contents as an Uint8Array.\n     * @param {string} filePath The file to read.\n     * @returns {Promise<Uint8Array|undefined>} The contents of the file as an Uint8Array.\n     * @throws {NoSuchMethodError} When the method does not exist on the current implementation.\n     * @throws {TypeError} When the file path is not a non-empty string.\n     */\n    bytes(filePath: string): Promise<Uint8Array | undefined>;\n    /**\n     * Writes the given data to the given file. Creates any necessary directories along the way.\n     * If the data is a string, UTF-8 encoding is used.\n     * @param {string} filePath The file to write.\n     * @param {any} contents The data to write.\n     * @returns {Promise<void>} A promise that resolves when the file is written.\n     * @throws {NoSuchMethodError} When the method does not exist on the current implementation.\n     * @throws {TypeError} When the file path is not a non-empty string.\n     */\n    write(filePath: string, contents: any): Promise<void>;\n    /**\n     * Determines if the given file exists.\n     * @param {string} filePath The file to check.\n     * @returns {Promise<boolean>} True if the file exists.\n     * @throws {NoSuchMethodError} When the method does not exist on the current implementation.\n     * @throws {TypeError} When the file path is not a non-empty string.\n     */\n    isFile(filePath: string): Promise<boolean>;\n    /**\n     * Determines if the given directory exists.\n     * @param {string} dirPath The directory to check.\n     * @returns {Promise<boolean>} True if the directory exists.\n     * @throws {NoSuchMethodError} When the method does not exist on the current implementation.\n     * @throws {TypeError} When the directory path is not a non-empty string.\n     */\n    isDirectory(dirPath: string): Promise<boolean>;\n    /**\n     * Creates the given directory.\n     * @param {string} dirPath The directory to create.\n     * @returns {Promise<void>} A promise that resolves when the directory is created.\n     * @throws {NoSuchMethodError} When the method does not exist on the current implementation.\n     * @throws {TypeError} When the directory path is not a non-empty string.\n     */\n    createDirectory(dirPath: string): Promise<void>;\n    /**\n     * Deletes the given file.\n     * @param {string} filePath The file to delete.\n     * @returns {Promise<void>} A promise that resolves when the file is deleted.\n     * @throws {NoSuchMethodError} When the method does not exist on the current implementation.\n     * @throws {TypeError} When the file path is not a non-empty string.\n     */\n    delete(filePath: string): Promise<void>;\n    /**\n     * Deletes the given directory.\n     * @param {string} dirPath The directory to delete.\n     * @returns {Promise<void>} A promise that resolves when the directory is deleted.\n     * @throws {NoSuchMethodError} When the method does not exist on the current implementation.\n     * @throws {TypeError} When the directory path is not a non-empty string.\n     */\n    deleteAll(dirPath: string): Promise<void>;\n    /**\n     * Returns a list of directory entries for the given path.\n     * @param {string} dirPath The path to the directory to read.\n     * @returns {AsyncIterable<HfsDirectoryEntry>} A promise that resolves with the\n     *   directory entries.\n     * @throws {TypeError} If the directory path is not a string.\n     * @throws {Error} If the directory cannot be read.\n     */\n    list(dirPath: string): AsyncIterable<HfsDirectoryEntry>;\n    /**\n     * Returns the size of the given file.\n     * @param {string} filePath The path to the file to read.\n     * @returns {Promise<number>} A promise that resolves with the size of the file.\n     * @throws {TypeError} If the file path is not a string.\n     * @throws {Error} If the file cannot be read.\n     */\n    size(filePath: string): Promise<number>;\n    #private;\n}\nexport type HfsImpl = import(\"@humanfs/types\").HfsImpl;\nexport type HfsDirectoryEntry = import(\"@humanfs/types\").HfsDirectoryEntry;\n"
        }
    ]
}