{
    "sourceFile": "node_modules/@humanfs/core/src/path.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891878841,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview The Path class.\n * @author Nicholas C. Zakas\n */\n\n/* globals URL */\n\n//-----------------------------------------------------------------------------\n// Types\n//-----------------------------------------------------------------------------\n\n/** @typedef{import(\"@humanfs/types\").HfsImpl} HfsImpl */\n/** @typedef{import(\"@humanfs/types\").HfsDirectoryEntry} HfsDirectoryEntry */\n\n//-----------------------------------------------------------------------------\n// Helpers\n//-----------------------------------------------------------------------------\n\n/**\n * Normalizes a path to use forward slashes.\n * @param {string} filePath The path to normalize.\n * @returns {string} The normalized path.\n */\nfunction normalizePath(filePath) {\n\tlet startIndex = 0;\n\tlet endIndex = filePath.length;\n\n\tif (/[a-z]:\\//i.test(filePath)) {\n\t\tstartIndex = 3;\n\t}\n\n\tif (filePath.startsWith(\"./\")) {\n\t\tstartIndex = 2;\n\t}\n\n\tif (filePath.startsWith(\"/\")) {\n\t\tstartIndex = 1;\n\t}\n\n\tif (filePath.endsWith(\"/\")) {\n\t\tendIndex = filePath.length - 1;\n\t}\n\n\treturn filePath.slice(startIndex, endIndex).replace(/\\\\/g, \"/\");\n}\n\n/**\n * Asserts that the given name is a non-empty string, no equal to \".\" or \"..\",\n * and does not contain a forward slash or backslash.\n * @param {string} name The name to check.\n * @returns {void}\n * @throws {TypeError} When name is not valid.\n */\nfunction assertValidName(name) {\n\tif (typeof name !== \"string\") {\n\t\tthrow new TypeError(\"name must be a string\");\n\t}\n\n\tif (!name) {\n\t\tthrow new TypeError(\"name cannot be empty\");\n\t}\n\n\tif (name === \".\") {\n\t\tthrow new TypeError(`name cannot be \".\"`);\n\t}\n\n\tif (name === \"..\") {\n\t\tthrow new TypeError(`name cannot be \"..\"`);\n\t}\n\n\tif (name.includes(\"/\") || name.includes(\"\\\\\")) {\n\t\tthrow new TypeError(\n\t\t\t`name cannot contain a slash or backslash: \"${name}\"`,\n\t\t);\n\t}\n}\n\n//-----------------------------------------------------------------------------\n// Exports\n//-----------------------------------------------------------------------------\n\nexport class Path {\n\t/**\n\t * The steps in the path.\n\t * @type {Array<string>}\n\t */\n\t#steps;\n\n\t/**\n\t * Creates a new instance.\n\t * @param {Iterable<string>} [steps] The steps to use for the path.\n\t * @throws {TypeError} When steps is not iterable.\n\t */\n\tconstructor(steps = []) {\n\t\tif (typeof steps[Symbol.iterator] !== \"function\") {\n\t\t\tthrow new TypeError(\"steps must be iterable\");\n\t\t}\n\n\t\tthis.#steps = [...steps];\n\t\tthis.#steps.forEach(assertValidName);\n\t}\n\n\t/**\n\t * Adds steps to the end of the path.\n\t * @param  {...string} steps The steps to add to the path.\n\t * @returns {void}\n\t */\n\tpush(...steps) {\n\t\tsteps.forEach(assertValidName);\n\t\tthis.#steps.push(...steps);\n\t}\n\n\t/**\n\t * Removes the last step from the path.\n\t * @returns {string} The last step in the path.\n\t */\n\tpop() {\n\t\treturn this.#steps.pop();\n\t}\n\n\t/**\n\t * Returns an iterator for steps in the path.\n\t * @returns {IterableIterator<string>} An iterator for the steps in the path.\n\t */\n\tsteps() {\n\t\treturn this.#steps.values();\n\t}\n\n\t/**\n\t * Returns an iterator for the steps in the path.\n\t * @returns {IterableIterator<string>} An iterator for the steps in the path.\n\t */\n\t[Symbol.iterator]() {\n\t\treturn this.steps();\n\t}\n\n\t/**\n\t * Retrieves the name (the last step) of the path.\n\t * @type {string}\n\t */\n\tget name() {\n\t\treturn this.#steps[this.#steps.length - 1];\n\t}\n\n\t/**\n\t * Sets the name (the last step) of the path.\n\t * @type {string}\n\t */\n\tset name(value) {\n\t\tassertValidName(value);\n\t\tthis.#steps[this.#steps.length - 1] = value;\n\t}\n\n\t/**\n\t * Retrieves the size of the path.\n\t * @type {number}\n\t */\n\tget size() {\n\t\treturn this.#steps.length;\n\t}\n\n\t/**\n\t * Returns the path as a string.\n\t * @returns {string} The path as a string.\n\t */\n\ttoString() {\n\t\treturn this.#steps.join(\"/\");\n\t}\n\n\t/**\n\t * Creates a new path based on the argument type. If the argument is a string,\n\t * it is assumed to be a file or directory path and is converted to a Path\n\t * instance. If the argument is a URL, it is assumed to be a file URL and is\n\t * converted to a Path instance. If the argument is a Path instance, it is\n\t * copied into a new Path instance. If the argument is an array, it is assumed\n\t * to be the steps of a path and is used to create a new Path instance.\n\t * @param {string|URL|Path|Array<string>} pathish The value to convert to a Path instance.\n\t * @returns {Path} A new Path instance.\n\t * @throws {TypeError} When pathish is not a string, URL, Path, or Array.\n\t * @throws {TypeError} When pathish is a string and is empty.\n\t */\n\tstatic from(pathish) {\n\t\tif (typeof pathish === \"string\") {\n\t\t\tif (!pathish) {\n\t\t\t\tthrow new TypeError(\"argument cannot be empty\");\n\t\t\t}\n\n\t\t\treturn Path.fromString(pathish);\n\t\t}\n\n\t\tif (pathish instanceof URL) {\n\t\t\treturn Path.fromURL(pathish);\n\t\t}\n\n\t\tif (pathish instanceof Path || Array.isArray(pathish)) {\n\t\t\treturn new Path(pathish);\n\t\t}\n\n\t\tthrow new TypeError(\"argument must be a string, URL, Path, or Array\");\n\t}\n\n\t/**\n\t * Creates a new Path instance from a string.\n\t * @param {string} fileOrDirPath The file or directory path to convert.\n\t * @returns {Path} A new Path instance.\n\t * @deprecated Use Path.from() instead.\n\t */\n\tstatic fromString(fileOrDirPath) {\n\t\treturn new Path(normalizePath(fileOrDirPath).split(\"/\"));\n\t}\n\n\t/**\n\t * Creates a new Path instance from a URL.\n\t * @param {URL} url The URL to convert.\n\t * @returns {Path} A new Path instance.\n\t * @throws {TypeError} When url is not a URL instance.\n\t * @throws {TypeError} When url.pathname is empty.\n\t * @throws {TypeError} When url.protocol is not \"file:\".\n\t * @deprecated Use Path.from() instead.\n\t */\n\tstatic fromURL(url) {\n\t\tif (!(url instanceof URL)) {\n\t\t\tthrow new TypeError(\"url must be a URL instance\");\n\t\t}\n\n\t\tif (!url.pathname || url.pathname === \"/\") {\n\t\t\tthrow new TypeError(\"url.pathname cannot be empty\");\n\t\t}\n\n\t\tif (url.protocol !== \"file:\") {\n\t\t\tthrow new TypeError(`url.protocol must be \"file:\"`);\n\t\t}\n\n\t\t// Remove leading slash in pathname\n\t\treturn new Path(normalizePath(url.pathname.slice(1)).split(\"/\"));\n\t}\n}\n"
        }
    ]
}