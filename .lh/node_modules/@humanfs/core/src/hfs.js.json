{
    "sourceFile": "node_modules/@humanfs/core/src/hfs.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891878799,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview The main file for the humanfs package.\n * @author Nicholas C. Zakas\n */\n\n/* global URL, TextDecoder, TextEncoder */\n\n//-----------------------------------------------------------------------------\n// Types\n//-----------------------------------------------------------------------------\n\n/** @typedef {import(\"@humanfs/types\").HfsImpl} HfsImpl */\n/** @typedef {import(\"@humanfs/types\").HfsDirectoryEntry} HfsDirectoryEntry */\n/** @typedef {import(\"@humanfs/types\").HfsWalkEntry} HfsWalkEntry */\n\n//-----------------------------------------------------------------------------\n// Helpers\n//-----------------------------------------------------------------------------\n\nconst decoder = new TextDecoder();\nconst encoder = new TextEncoder();\n\n/**\n * Error to represent when a method is missing on an impl.\n */\nexport class NoSuchMethodError extends Error {\n\t/**\n\t * Creates a new instance.\n\t * @param {string} methodName The name of the method that was missing.\n\t */\n\tconstructor(methodName) {\n\t\tsuper(`Method \"${methodName}\" does not exist on impl.`);\n\t}\n}\n\n/**\n * Error to represent when a method is not supported on an impl. This happens\n * when a method on `Hfs` is called with one name and the corresponding method\n * on the impl has a different name. (Example: `text()` and `bytes()`.)\n */\nexport class MethodNotSupportedError extends Error {\n\t/**\n\t * Creates a new instance.\n\t * @param {string} methodName The name of the method that was missing.\n\t */\n\tconstructor(methodName) {\n\t\tsuper(`Method \"${methodName}\" is not supported on this impl.`);\n\t}\n}\n\n/**\n * Error to represent when an impl is already set.\n */\nexport class ImplAlreadySetError extends Error {\n\t/**\n\t * Creates a new instance.\n\t */\n\tconstructor() {\n\t\tsuper(`Implementation already set.`);\n\t}\n}\n\n/**\n * Asserts that the given path is a valid file path.\n * @param {any} fileOrDirPath The path to check.\n * @returns {void}\n * @throws {TypeError} When the path is not a non-empty string.\n */\nfunction assertValidFileOrDirPath(fileOrDirPath) {\n\tif (\n\t\t!fileOrDirPath ||\n\t\t(!(fileOrDirPath instanceof URL) && typeof fileOrDirPath !== \"string\")\n\t) {\n\t\tthrow new TypeError(\"Path must be a non-empty string or URL.\");\n\t}\n}\n\n/**\n * Asserts that the given file contents are valid.\n * @param {any} contents The contents to check.\n * @returns {void}\n * @throws {TypeError} When the contents are not a string or ArrayBuffer.\n */\nfunction assertValidFileContents(contents) {\n\tif (\n\t\ttypeof contents !== \"string\" &&\n\t\t!(contents instanceof ArrayBuffer) &&\n\t\t!ArrayBuffer.isView(contents)\n\t) {\n\t\tthrow new TypeError(\n\t\t\t\"File contents must be a string, ArrayBuffer, or ArrayBuffer view.\",\n\t\t);\n\t}\n}\n\n/**\n * Converts the given contents to Uint8Array.\n * @param {any} contents The data to convert.\n * @returns {Uint8Array} The converted Uint8Array.\n * @throws {TypeError} When the contents are not a string or ArrayBuffer.\n */\nfunction toUint8Array(contents) {\n\tif (contents instanceof Uint8Array) {\n\t\treturn contents;\n\t}\n\n\tif (typeof contents === \"string\") {\n\t\treturn encoder.encode(contents);\n\t}\n\n\tif (contents instanceof ArrayBuffer) {\n\t\treturn new Uint8Array(contents);\n\t}\n\n\tif (ArrayBuffer.isView(contents)) {\n\t\tconst bytes = contents.buffer.slice(\n\t\t\tcontents.byteOffset,\n\t\t\tcontents.byteOffset + contents.byteLength,\n\t\t);\n\t\treturn new Uint8Array(bytes);\n\t}\n\tthrow new TypeError(\n\t\t\"Invalid contents type. Expected string or ArrayBuffer.\",\n\t);\n}\n\n//-----------------------------------------------------------------------------\n// Exports\n//-----------------------------------------------------------------------------\n\n/**\n * A class representing a log entry.\n */\nexport class LogEntry {\n\t/**\n\t * The type of log entry.\n\t * @type {string}\n\t */\n\ttype;\n\n\t/**\n\t * The data associated with the log entry.\n\t * @type {any}\n\t */\n\tdata;\n\n\t/**\n\t * The time at which the log entry was created.\n\t * @type {number}\n\t */\n\ttimestamp = Date.now();\n\n\t/**\n\t * Creates a new instance.\n\t * @param {string} type The type of log entry.\n\t * @param {any} [data] The data associated with the log entry.\n\t */\n\tconstructor(type, data) {\n\t\tthis.type = type;\n\t\tthis.data = data;\n\t}\n}\n\n/**\n * A class representing a file system utility library.\n * @implements {HfsImpl}\n */\nexport class Hfs {\n\t/**\n\t * The base implementation for this instance.\n\t * @type {HfsImpl}\n\t */\n\t#baseImpl;\n\n\t/**\n\t * The current implementation for this instance.\n\t * @type {HfsImpl}\n\t */\n\t#impl;\n\n\t/**\n\t * A map of log names to their corresponding entries.\n\t * @type {Map<string,Array<LogEntry>>}\n\t */\n\t#logs = new Map();\n\n\t/**\n\t * Creates a new instance.\n\t * @param {object} options The options for the instance.\n\t * @param {HfsImpl} options.impl The implementation to use.\n\t */\n\tconstructor({ impl }) {\n\t\tthis.#baseImpl = impl;\n\t\tthis.#impl = impl;\n\t}\n\n\t/**\n\t * Logs an entry onto all currently open logs.\n\t * @param {string} methodName The name of the method being called.\n\t * @param {...*} args The arguments to the method.\n\t * @returns {void}\n\t */\n\t#log(methodName, ...args) {\n\t\tfor (const logs of this.#logs.values()) {\n\t\t\tlogs.push(new LogEntry(\"call\", { methodName, args }));\n\t\t}\n\t}\n\n\t/**\n\t * Starts a new log with the given name.\n\t * @param {string} name The name of the log to start;\n\t * @returns {void}\n\t * @throws {Error} When the log already exists.\n\t * @throws {TypeError} When the name is not a non-empty string.\n\t */\n\tlogStart(name) {\n\t\tif (!name || typeof name !== \"string\") {\n\t\t\tthrow new TypeError(\"Log name must be a non-empty string.\");\n\t\t}\n\n\t\tif (this.#logs.has(name)) {\n\t\t\tthrow new Error(`Log \"${name}\" already exists.`);\n\t\t}\n\n\t\tthis.#logs.set(name, []);\n\t}\n\n\t/**\n\t * Ends a log with the given name and returns the entries.\n\t * @param {string} name The name of the log to end.\n\t * @returns {Array<LogEntry>} The entries in the log.\n\t * @throws {Error} When the log does not exist.\n\t */\n\tlogEnd(name) {\n\t\tif (this.#logs.has(name)) {\n\t\t\tconst logs = this.#logs.get(name);\n\t\t\tthis.#logs.delete(name);\n\t\t\treturn logs;\n\t\t}\n\n\t\tthrow new Error(`Log \"${name}\" does not exist.`);\n\t}\n\n\t/**\n\t * Determines if the current implementation is the base implementation.\n\t * @returns {boolean} True if the current implementation is the base implementation.\n\t */\n\tisBaseImpl() {\n\t\treturn this.#impl === this.#baseImpl;\n\t}\n\n\t/**\n\t * Sets the implementation for this instance.\n\t * @param {object} impl The implementation to use.\n\t * @returns {void}\n\t */\n\tsetImpl(impl) {\n\t\tthis.#log(\"implSet\", impl);\n\n\t\tif (this.#impl !== this.#baseImpl) {\n\t\t\tthrow new ImplAlreadySetError();\n\t\t}\n\n\t\tthis.#impl = impl;\n\t}\n\n\t/**\n\t * Resets the implementation for this instance back to its original.\n\t * @returns {void}\n\t */\n\tresetImpl() {\n\t\tthis.#log(\"implReset\");\n\t\tthis.#impl = this.#baseImpl;\n\t}\n\n\t/**\n\t * Asserts that the given method exists on the current implementation.\n\t * @param {string} methodName The name of the method to check.\n\t * @returns {void}\n\t * @throws {NoSuchMethodError} When the method does not exist on the current implementation.\n\t */\n\t#assertImplMethod(methodName) {\n\t\tif (typeof this.#impl[methodName] !== \"function\") {\n\t\t\tthrow new NoSuchMethodError(methodName);\n\t\t}\n\t}\n\n\t/**\n\t * Asserts that the given method exists on the current implementation, and if not,\n\t * throws an error with a different method name.\n\t * @param {string} methodName The name of the method to check.\n\t * @param {string} targetMethodName The name of the method that should be reported\n\t *  as an error when methodName does not exist.\n\t * @returns {void}\n\t * @throws {NoSuchMethodError} When the method does not exist on the current implementation.\n\t */\n\t#assertImplMethodAlt(methodName, targetMethodName) {\n\t\tif (typeof this.#impl[methodName] !== \"function\") {\n\t\t\tthrow new MethodNotSupportedError(targetMethodName);\n\t\t}\n\t}\n\n\t/**\n\t * Calls the given method on the current implementation.\n\t * @param {string} methodName The name of the method to call.\n\t * @param {...any} args The arguments to the method.\n\t * @returns {any} The return value from the method.\n\t * @throws {NoSuchMethodError} When the method does not exist on the current implementation.\n\t */\n\t#callImplMethod(methodName, ...args) {\n\t\tthis.#log(methodName, ...args);\n\t\tthis.#assertImplMethod(methodName);\n\t\treturn this.#impl[methodName](...args);\n\t}\n\n\t/**\n\t * Calls the given method on the current implementation and doesn't log the call.\n\t * @param {string} methodName The name of the method to call.\n\t * @param {...any} args The arguments to the method.\n\t * @returns {any} The return value from the method.\n\t * @throws {NoSuchMethodError} When the method does not exist on the current implementation.\n\t */\n\t#callImplMethodWithoutLog(methodName, ...args) {\n\t\tthis.#assertImplMethod(methodName);\n\t\treturn this.#impl[methodName](...args);\n\t}\n\n\t/**\n\t * Calls the given method on the current implementation but logs a different method name.\n\t * @param {string} methodName The name of the method to call.\n\t * @param {string} targetMethodName The name of the method to log.\n\t * @param {...any} args The arguments to the method.\n\t * @returns {any} The return value from the method.\n\t * @throws {NoSuchMethodError} When the method does not exist on the current implementation.\n\t */\n\t#callImplMethodAlt(methodName, targetMethodName, ...args) {\n\t\tthis.#log(targetMethodName, ...args);\n\t\tthis.#assertImplMethodAlt(methodName, targetMethodName);\n\t\treturn this.#impl[methodName](...args);\n\t}\n\n\t/**\n\t * Reads the given file and returns the contents as text. Assumes UTF-8 encoding.\n\t * @param {string|URL} filePath The file to read.\n\t * @returns {Promise<string|undefined>} The contents of the file.\n\t * @throws {NoSuchMethodError} When the method does not exist on the current implementation.\n\t * @throws {TypeError} When the file path is not a non-empty string.\n\t */\n\tasync text(filePath) {\n\t\tassertValidFileOrDirPath(filePath);\n\n\t\tconst result = await this.#callImplMethodAlt(\"bytes\", \"text\", filePath);\n\t\treturn result ? decoder.decode(result) : undefined;\n\t}\n\n\t/**\n\t * Reads the given file and returns the contents as JSON. Assumes UTF-8 encoding.\n\t * @param {string|URL} filePath The file to read.\n\t * @returns {Promise<any|undefined>} The contents of the file as JSON.\n\t * @throws {NoSuchMethodError} When the method does not exist on the current implementation.\n\t * @throws {SyntaxError} When the file contents are not valid JSON.\n\t * @throws {TypeError} When the file path is not a non-empty string.\n\t */\n\tasync json(filePath) {\n\t\tassertValidFileOrDirPath(filePath);\n\n\t\tconst result = await this.#callImplMethodAlt(\"bytes\", \"json\", filePath);\n\t\treturn result ? JSON.parse(decoder.decode(result)) : undefined;\n\t}\n\n\t/**\n\t * Reads the given file and returns the contents as an ArrayBuffer.\n\t * @param {string|URL} filePath The file to read.\n\t * @returns {Promise<ArrayBuffer|undefined>} The contents of the file as an ArrayBuffer.\n\t * @throws {NoSuchMethodError} When the method does not exist on the current implementation.\n\t * @throws {TypeError} When the file path is not a non-empty string.\n\t * @deprecated Use bytes() instead.\n\t */\n\tasync arrayBuffer(filePath) {\n\t\tassertValidFileOrDirPath(filePath);\n\n\t\tconst result = await this.#callImplMethodAlt(\n\t\t\t\"bytes\",\n\t\t\t\"arrayBuffer\",\n\t\t\tfilePath,\n\t\t);\n\t\treturn result?.buffer;\n\t}\n\n\t/**\n\t * Reads the given file and returns the contents as an Uint8Array.\n\t * @param {string|URL} filePath The file to read.\n\t * @returns {Promise<Uint8Array|undefined>} The contents of the file as an Uint8Array.\n\t * @throws {NoSuchMethodError} When the method does not exist on the current implementation.\n\t * @throws {TypeError} When the file path is not a non-empty string.\n\t */\n\tasync bytes(filePath) {\n\t\tassertValidFileOrDirPath(filePath);\n\t\treturn this.#callImplMethod(\"bytes\", filePath);\n\t}\n\n\t/**\n\t * Writes the given data to the given file. Creates any necessary directories along the way.\n\t * If the data is a string, UTF-8 encoding is used.\n\t * @param {string|URL} filePath The file to write.\n\t * @param {string|ArrayBuffer|ArrayBufferView} contents The data to write.\n\t * @returns {Promise<void>} A promise that resolves when the file is written.\n\t * @throws {NoSuchMethodError} When the method does not exist on the current implementation.\n\t * @throws {TypeError} When the file path is not a non-empty string.\n\t */\n\tasync write(filePath, contents) {\n\t\tassertValidFileOrDirPath(filePath);\n\t\tassertValidFileContents(contents);\n\t\tthis.#log(\"write\", filePath, contents);\n\n\t\tlet value = toUint8Array(contents);\n\t\treturn this.#callImplMethodWithoutLog(\"write\", filePath, value);\n\t}\n\n\t/**\n\t * Appends the given data to the given file. Creates any necessary directories along the way.\n\t * If the data is a string, UTF-8 encoding is used.\n\t * @param {string|URL} filePath The file to append to.\n\t * @param {string|ArrayBuffer|ArrayBufferView} contents The data to append.\n\t * @returns {Promise<void>} A promise that resolves when the file is appended to.\n\t * @throws {NoSuchMethodError} When the method does not exist on the current implementation.\n\t * @throws {TypeError} When the file path is not a non-empty string.\n\t * @throws {TypeError} When the file contents are not a string or ArrayBuffer.\n\t * @throws {Error} When the file cannot be appended to.\n\t */\n\tasync append(filePath, contents) {\n\t\tassertValidFileOrDirPath(filePath);\n\t\tassertValidFileContents(contents);\n\t\tthis.#log(\"append\", filePath, contents);\n\n\t\tlet value = toUint8Array(contents);\n\t\treturn this.#callImplMethodWithoutLog(\"append\", filePath, value);\n\t}\n\n\t/**\n\t * Determines if the given file exists.\n\t * @param {string|URL} filePath The file to check.\n\t * @returns {Promise<boolean>} True if the file exists.\n\t * @throws {NoSuchMethodError} When the method does not exist on the current implementation.\n\t * @throws {TypeError} When the file path is not a non-empty string.\n\t */\n\tasync isFile(filePath) {\n\t\tassertValidFileOrDirPath(filePath);\n\t\treturn this.#callImplMethod(\"isFile\", filePath);\n\t}\n\n\t/**\n\t * Determines if the given directory exists.\n\t * @param {string|URL} dirPath The directory to check.\n\t * @returns {Promise<boolean>} True if the directory exists.\n\t * @throws {NoSuchMethodError} When the method does not exist on the current implementation.\n\t * @throws {TypeError} When the directory path is not a non-empty string.\n\t */\n\tasync isDirectory(dirPath) {\n\t\tassertValidFileOrDirPath(dirPath);\n\t\treturn this.#callImplMethod(\"isDirectory\", dirPath);\n\t}\n\n\t/**\n\t * Creates the given directory.\n\t * @param {string|URL} dirPath The directory to create.\n\t * @returns {Promise<void>} A promise that resolves when the directory is created.\n\t * @throws {NoSuchMethodError} When the method does not exist on the current implementation.\n\t * @throws {TypeError} When the directory path is not a non-empty string.\n\t */\n\tasync createDirectory(dirPath) {\n\t\tassertValidFileOrDirPath(dirPath);\n\t\treturn this.#callImplMethod(\"createDirectory\", dirPath);\n\t}\n\n\t/**\n\t * Deletes the given file or empty directory.\n\t * @param {string|URL} filePath The file to delete.\n\t * @returns {Promise<boolean>} A promise that resolves when the file or\n\t *   directory is deleted, true if the file or directory is deleted, false\n\t *   if the file or directory does not exist.\n\t * @throws {NoSuchMethodError} When the method does not exist on the current implementation.\n\t * @throws {TypeError} When the file path is not a non-empty string.\n\t */\n\tasync delete(filePath) {\n\t\tassertValidFileOrDirPath(filePath);\n\t\treturn this.#callImplMethod(\"delete\", filePath);\n\t}\n\n\t/**\n\t * Deletes the given file or directory recursively.\n\t * @param {string|URL} dirPath The directory to delete.\n\t * @returns {Promise<boolean>} A promise that resolves when the file or\n\t *   directory is deleted, true if the file or directory is deleted, false\n\t *   if the file or directory does not exist.\n\t * @throws {NoSuchMethodError} When the method does not exist on the current implementation.\n\t * @throws {TypeError} When the directory path is not a non-empty string.\n\t */\n\tasync deleteAll(dirPath) {\n\t\tassertValidFileOrDirPath(dirPath);\n\t\treturn this.#callImplMethod(\"deleteAll\", dirPath);\n\t}\n\n\t/**\n\t * Returns a list of directory entries for the given path.\n\t * @param {string|URL} dirPath The path to the directory to read.\n\t * @returns {AsyncIterable<HfsDirectoryEntry>} A promise that resolves with the\n\t *   directory entries.\n\t * @throws {TypeError} If the directory path is not a string or URL.\n\t * @throws {Error} If the directory cannot be read.\n\t */\n\tasync *list(dirPath) {\n\t\tassertValidFileOrDirPath(dirPath);\n\t\tyield* await this.#callImplMethod(\"list\", dirPath);\n\t}\n\n\t/**\n\t * Walks a directory using a depth-first traversal and returns the entries\n\t * from the traversal.\n\t * @param {string|URL} dirPath The path to the directory to walk.\n\t * @param {Object} [options] The options for the walk.\n\t * @param {(entry:HfsWalkEntry) => Promise<boolean>|boolean} [options.directoryFilter] A filter function to determine\n\t * \tif a directory's entries should be included in the walk.\n\t * @param {(entry:HfsWalkEntry) => Promise<boolean>|boolean} [options.entryFilter] A filter function to determine if\n\t * \tan entry should be included in the walk.\n\t * @returns {AsyncIterable<HfsWalkEntry>} A promise that resolves with the\n\t * \tdirectory entries.\n\t * @throws {TypeError} If the directory path is not a string or URL.\n\t * @throws {Error} If the directory cannot be read.\n\t */\n\tasync *walk(\n\t\tdirPath,\n\t\t{ directoryFilter = () => true, entryFilter = () => true } = {},\n\t) {\n\t\tassertValidFileOrDirPath(dirPath);\n\t\tthis.#log(\"walk\", dirPath, { directoryFilter, entryFilter });\n\n\t\t// inner function for recursion without additional logging\n\t\tconst walk = async function* (\n\t\t\tdirPath,\n\t\t\t{ directoryFilter, entryFilter, parentPath = \"\", depth = 1 },\n\t\t) {\n\t\t\tlet dirEntries;\n\n\t\t\ttry {\n\t\t\t\tdirEntries = await this.#callImplMethodWithoutLog(\n\t\t\t\t\t\"list\",\n\t\t\t\t\tdirPath,\n\t\t\t\t);\n\t\t\t} catch (error) {\n\t\t\t\t// if the directory does not exist then return an empty array\n\t\t\t\tif (error.code === \"ENOENT\") {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// otherwise, rethrow the error\n\t\t\t\tthrow error;\n\t\t\t}\n\n\t\t\tfor await (const listEntry of dirEntries) {\n\t\t\t\tconst walkEntry = {\n\t\t\t\t\tpath: listEntry.name,\n\t\t\t\t\tdepth,\n\t\t\t\t\t...listEntry,\n\t\t\t\t};\n\n\t\t\t\tif (parentPath) {\n\t\t\t\t\twalkEntry.path = `${parentPath}/${walkEntry.path}`;\n\t\t\t\t}\n\n\t\t\t\t// first emit the entry but only if the entry filter returns true\n\t\t\t\tlet shouldEmitEntry = entryFilter(walkEntry);\n\t\t\t\tif (shouldEmitEntry.then) {\n\t\t\t\t\tshouldEmitEntry = await shouldEmitEntry;\n\t\t\t\t}\n\n\t\t\t\tif (shouldEmitEntry) {\n\t\t\t\t\tyield walkEntry;\n\t\t\t\t}\n\n\t\t\t\t// if it's a directory then yield the entry and walk the directory\n\t\t\t\tif (listEntry.isDirectory) {\n\t\t\t\t\t// if the directory filter returns false, skip the directory\n\t\t\t\t\tlet shouldWalkDirectory = directoryFilter(walkEntry);\n\t\t\t\t\tif (shouldWalkDirectory.then) {\n\t\t\t\t\t\tshouldWalkDirectory = await shouldWalkDirectory;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!shouldWalkDirectory) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t// make sure there's a trailing slash on the directory path before appending\n\t\t\t\t\tconst directoryPath =\n\t\t\t\t\t\tdirPath instanceof URL\n\t\t\t\t\t\t\t? new URL(\n\t\t\t\t\t\t\t\t\tlistEntry.name,\n\t\t\t\t\t\t\t\t\tdirPath.href.endsWith(\"/\")\n\t\t\t\t\t\t\t\t\t\t? dirPath.href\n\t\t\t\t\t\t\t\t\t\t: `${dirPath.href}/`,\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t: `${dirPath.endsWith(\"/\") ? dirPath : `${dirPath}/`}${listEntry.name}`;\n\n\t\t\t\t\tyield* walk(directoryPath, {\n\t\t\t\t\t\tdirectoryFilter,\n\t\t\t\t\t\tentryFilter,\n\t\t\t\t\t\tparentPath: walkEntry.path,\n\t\t\t\t\t\tdepth: depth + 1,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}.bind(this);\n\n\t\tyield* walk(dirPath, { directoryFilter, entryFilter });\n\t}\n\n\t/**\n\t * Returns the size of the given file.\n\t * @param {string|URL} filePath The path to the file to read.\n\t * @returns {Promise<number>} A promise that resolves with the size of the file.\n\t * @throws {TypeError} If the file path is not a string or URL.\n\t * @throws {Error} If the file cannot be read.\n\t */\n\tasync size(filePath) {\n\t\tassertValidFileOrDirPath(filePath);\n\t\treturn this.#callImplMethod(\"size\", filePath);\n\t}\n\n\t/**\n\t * Returns the last modified timestamp of the given file or directory.\n\t * @param {string|URL} fileOrDirPath The path to the file or directory.\n\t * @returns {Promise<Date|undefined>} A promise that resolves with the last modified date\n\t *  or undefined if the file or directory does not exist.\n\t * @throws {TypeError} If the path is not a string or URL.\n\t */\n\tasync lastModified(fileOrDirPath) {\n\t\tassertValidFileOrDirPath(fileOrDirPath);\n\t\treturn this.#callImplMethod(\"lastModified\", fileOrDirPath);\n\t}\n\n\t/**\n\t * Copys a file from one location to another.\n\t * @param {string|URL} source The path to the file to copy.\n\t * @param {string|URL} destination The path to the new file.\n\t * @returns {Promise<void>} A promise that resolves when the file is copied.\n\t * @throws {TypeError} If the file path is not a string or URL.\n\t * @throws {Error} If the file cannot be copied.\n\t */\n\tasync copy(source, destination) {\n\t\tassertValidFileOrDirPath(source);\n\t\tassertValidFileOrDirPath(destination);\n\t\treturn this.#callImplMethod(\"copy\", source, destination);\n\t}\n\n\t/**\n\t * Copies a file or directory from one location to another.\n\t * @param {string|URL} source The path to the file or directory to copy.\n\t * @param {string|URL} destination The path to copy the file or directory to.\n\t * @returns {Promise<void>} A promise that resolves when the file or directory is\n\t * copied.\n\t * @throws {TypeError} If the directory path is not a string or URL.\n\t * @throws {Error} If the directory cannot be copied.\n\t */\n\tasync copyAll(source, destination) {\n\t\tassertValidFileOrDirPath(source);\n\t\tassertValidFileOrDirPath(destination);\n\t\treturn this.#callImplMethod(\"copyAll\", source, destination);\n\t}\n\n\t/**\n\t * Moves a file from the source path to the destination path.\n\t * @param {string|URL} source The location of the file to move.\n\t * @param {string|URL} destination The destination of the file to move.\n\t * @returns {Promise<void>} A promise that resolves when the move is complete.\n\t * @throws {TypeError} If the file or directory paths are not strings.\n\t * @throws {Error} If the file or directory cannot be moved.\n\t */\n\tasync move(source, destination) {\n\t\tassertValidFileOrDirPath(source);\n\t\tassertValidFileOrDirPath(destination);\n\t\treturn this.#callImplMethod(\"move\", source, destination);\n\t}\n\n\t/**\n\t * Moves a file or directory from one location to another.\n\t * @param {string|URL} source The path to the file or directory to move.\n\t * @param {string|URL} destination The path to move the file or directory to.\n\t * @returns {Promise<void>} A promise that resolves when the file or directory is\n\t * moved.\n\t * @throws {TypeError} If the source is not a string or URL.\n\t * @throws {TypeError} If the destination is not a string or URL.\n\t * @throws {Error} If the file or directory cannot be moved.\n\t */\n\tasync moveAll(source, destination) {\n\t\tassertValidFileOrDirPath(source);\n\t\tassertValidFileOrDirPath(destination);\n\t\treturn this.#callImplMethod(\"moveAll\", source, destination);\n\t}\n}\n"
        }
    ]
}