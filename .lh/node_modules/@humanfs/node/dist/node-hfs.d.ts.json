{
    "sourceFile": "node_modules/@humanfs/node/dist/node-hfs.d.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891878915,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/// <reference types=\"node\" resolution-mode=\"require\"/>\n/**\n * A class representing the Node.js implementation of Hfs.\n * @implements {HfsImpl}\n */\nexport class NodeHfsImpl implements HfsImpl {\n    /**\n     * Creates a new instance.\n     * @param {object} [options] The options for the instance.\n     * @param {Fsp} [options.fsp] The file system module to use.\n     */\n    constructor({ fsp }?: {\n        fsp?: Fsp;\n    });\n    /**\n     * Reads a file and returns the contents as an Uint8Array.\n     * @param {string|URL} filePath The path to the file to read.\n     * @returns {Promise<Uint8Array|undefined>} A promise that resolves with the contents\n     *    of the file or undefined if the file doesn't exist.\n     * @throws {Error} If the file cannot be read.\n     * @throws {TypeError} If the file path is not a string.\n     */\n    bytes(filePath: string | URL): Promise<Uint8Array | undefined>;\n    /**\n     * Writes a value to a file. If the value is a string, UTF-8 encoding is used.\n     * @param {string|URL} filePath The path to the file to write.\n     * @param {Uint8Array} contents The contents to write to the\n     *   file.\n     * @returns {Promise<void>} A promise that resolves when the file is\n     *  written.\n     * @throws {TypeError} If the file path is not a string.\n     * @throws {Error} If the file cannot be written.\n     */\n    write(filePath: string | URL, contents: Uint8Array): Promise<void>;\n    /**\n     * Appends a value to a file. If the value is a string, UTF-8 encoding is used.\n     * @param {string|URL} filePath The path to the file to append to.\n     * @param {Uint8Array} contents The contents to append to the\n     *  file.\n     * @returns {Promise<void>} A promise that resolves when the file is\n     * written.\n     * @throws {TypeError} If the file path is not a string.\n     * @throws {Error} If the file cannot be appended to.\n     */\n    append(filePath: string | URL, contents: Uint8Array): Promise<void>;\n    /**\n     * Checks if a file exists.\n     * @param {string|URL} filePath The path to the file to check.\n     * @returns {Promise<boolean>} A promise that resolves with true if the\n     *    file exists or false if it does not.\n     * @throws {Error} If the operation fails with a code other than ENOENT.\n     */\n    isFile(filePath: string | URL): Promise<boolean>;\n    /**\n     * Checks if a directory exists.\n     * @param {string|URL} dirPath The path to the directory to check.\n     * @returns {Promise<boolean>} A promise that resolves with true if the\n     *    directory exists or false if it does not.\n     * @throws {Error} If the operation fails with a code other than ENOENT.\n     */\n    isDirectory(dirPath: string | URL): Promise<boolean>;\n    /**\n     * Creates a directory recursively.\n     * @param {string|URL} dirPath The path to the directory to create.\n     * @returns {Promise<void>} A promise that resolves when the directory is\n     *   created.\n     */\n    createDirectory(dirPath: string | URL): Promise<void>;\n    /**\n     * Deletes a file or empty directory.\n     * @param {string|URL} fileOrDirPath The path to the file or directory to\n     *   delete.\n     * @returns {Promise<boolean>} A promise that resolves when the file or\n     *   directory is deleted, true if the file or directory is deleted, false\n     *   if the file or directory does not exist.\n     * @throws {TypeError} If the file or directory path is not a string.\n     * @throws {Error} If the file or directory cannot be deleted.\n     */\n    delete(fileOrDirPath: string | URL): Promise<boolean>;\n    /**\n     * Deletes a file or directory recursively.\n     * @param {string|URL} fileOrDirPath The path to the file or directory to\n     *   delete.\n     * @returns {Promise<boolean>} A promise that resolves when the file or\n     *   directory is deleted, true if the file or directory is deleted, false\n     *   if the file or directory does not exist.\n     * @throws {TypeError} If the file or directory path is not a string.\n     * @throws {Error} If the file or directory cannot be deleted.\n     */\n    deleteAll(fileOrDirPath: string | URL): Promise<boolean>;\n    /**\n     * Returns a list of directory entries for the given path.\n     * @param {string|URL} dirPath The path to the directory to read.\n     * @returns {AsyncIterable<HfsDirectoryEntry>} A promise that resolves with the\n     *   directory entries.\n     * @throws {TypeError} If the directory path is not a string.\n     * @throws {Error} If the directory cannot be read.\n     */\n    list(dirPath: string | URL): AsyncIterable<HfsDirectoryEntry>;\n    /**\n     * Returns the size of a file. This method handles ENOENT errors\n     * and returns undefined in that case.\n     * @param {string|URL} filePath The path to the file to read.\n     * @returns {Promise<number|undefined>} A promise that resolves with the size of the\n     *  file in bytes or undefined if the file doesn't exist.\n     */\n    size(filePath: string | URL): Promise<number | undefined>;\n    /**\n     * Returns the last modified date of a file or directory. This method handles ENOENT errors\n     * and returns undefined in that case.\n     * @param {string|URL} fileOrDirPath The path to the file to read.\n     * @returns {Promise<Date|undefined>} A promise that resolves with the last modified\n     * date of the file or directory, or undefined if the file doesn't exist.\n     */\n    lastModified(fileOrDirPath: string | URL): Promise<Date | undefined>;\n    /**\n     * Copies a file from one location to another.\n     * @param {string|URL} source The path to the file to copy.\n     * @param {string|URL} destination The path to copy the file to.\n     * @returns {Promise<void>} A promise that resolves when the file is copied.\n     * @throws {Error} If the source file does not exist.\n     * @throws {Error} If the source file is a directory.\n     * @throws {Error} If the destination file is a directory.\n     */\n    copy(source: string | URL, destination: string | URL): Promise<void>;\n    /**\n     * Copies a file or directory from one location to another.\n     * @param {string|URL} source The path to the file or directory to copy.\n     * @param {string|URL} destination The path to copy the file or directory to.\n     * @returns {Promise<void>} A promise that resolves when the file or directory is\n     * copied.\n     * @throws {Error} If the source file or directory does not exist.\n     * @throws {Error} If the destination file or directory is a directory.\n     */\n    copyAll(source: string | URL, destination: string | URL): Promise<void>;\n    /**\n     * Moves a file from the source path to the destination path.\n     * @param {string|URL} source The location of the file to move.\n     * @param {string|URL} destination The destination of the file to move.\n     * @returns {Promise<void>} A promise that resolves when the move is complete.\n     * @throws {TypeError} If the file paths are not strings.\n     * @throws {Error} If the file cannot be moved.\n     */\n    move(source: string | URL, destination: string | URL): Promise<void>;\n    /**\n     * Moves a file or directory from the source path to the destination path.\n     * @param {string|URL} source The location of the file or directory to move.\n     * @param {string|URL} destination The destination of the file or directory to move.\n     * @returns {Promise<void>} A promise that resolves when the move is complete.\n     * @throws {TypeError} If the file paths are not strings.\n     * @throws {Error} If the file or directory cannot be moved.\n     */\n    moveAll(source: string | URL, destination: string | URL): Promise<void>;\n    #private;\n}\n/**\n * A class representing a file system utility library.\n * @implements {HfsImpl}\n */\nexport class NodeHfs extends Hfs implements HfsImpl {\n    /**\n     * Creates a new instance.\n     * @param {object} [options] The options for the instance.\n     * @param {Fsp} [options.fsp] The file system module to use.\n     */\n    constructor({ fsp }?: {\n        fsp?: Fsp;\n    });\n}\nexport const hfs: NodeHfs;\nexport type HfsImpl = import(\"@humanfs/types\").HfsImpl;\nexport type HfsDirectoryEntry = import(\"@humanfs/types\").HfsDirectoryEntry;\nexport type Fsp = typeof nativeFsp;\nexport type Dirent = import(\"fs\").Dirent;\nimport { Hfs } from \"@humanfs/core\";\nimport nativeFsp from \"node:fs/promises\";\n"
        }
    ]
}