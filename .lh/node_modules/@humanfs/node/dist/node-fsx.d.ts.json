{
    "sourceFile": "node_modules/@humanfs/node/dist/node-fsx.d.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891878892,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/// <reference types=\"node\" resolution-mode=\"require\"/>\n/**\n * A class representing the Node.js implementation of Hfs.\n * @implements {HfsImpl}\n */\nexport class NodeHfsImpl implements HfsImpl {\n    /**\n     * Creates a new instance.\n     * @param {object} [options] The options for the instance.\n     * @param {Fsp} [options.fsp] The file system module to use.\n     */\n    constructor({ fsp }?: {\n        fsp?: Fsp;\n    });\n    /**\n     * Reads a file and returns the contents as a string. Assumes UTF-8 encoding.\n     * @param {string} filePath The path to the file to read.\n     * @returns {Promise<string|undefined>} A promise that resolves with the contents of\n     *     the file or undefined if the file doesn't exist.\n     * @throws {TypeError} If the file path is not a string.\n     * @throws {RangeError} If the file path is empty.\n     * @throws {RangeError} If the file path is not absolute.\n     * @throws {RangeError} If the file path is not a file.\n     * @throws {RangeError} If the file path is not readable.\n     */\n    text(filePath: string): Promise<string | undefined>;\n    /**\n     * Reads a file and returns the contents as a JSON object. Assumes UTF-8 encoding.\n     * @param {string} filePath The path to the file to read.\n     * @returns {Promise<object|undefined>} A promise that resolves with the contents of\n     *    the file or undefined if the file doesn't exist.\n     * @throws {SyntaxError} If the file contents are not valid JSON.\n     * @throws {Error} If the file cannot be read.\n     * @throws {TypeError} If the file path is not a string.\n     */\n    json(filePath: string): Promise<object | undefined>;\n    /**\n     * Reads a file and returns the contents as an ArrayBuffer.\n     * @param {string} filePath The path to the file to read.\n     * @returns {Promise<ArrayBuffer|undefined>} A promise that resolves with the contents\n     *    of the file or undefined if the file doesn't exist.\n     * @throws {Error} If the file cannot be read.\n     * @throws {TypeError} If the file path is not a string.\n     * @deprecated Use bytes() instead.\n     */\n    arrayBuffer(filePath: string): Promise<ArrayBuffer | undefined>;\n    /**\n     * Reads a file and returns the contents as an Uint8Array.\n     * @param {string} filePath The path to the file to read.\n     * @returns {Promise<Uint8Array|undefined>} A promise that resolves with the contents\n     *    of the file or undefined if the file doesn't exist.\n     * @throws {Error} If the file cannot be read.\n     * @throws {TypeError} If the file path is not a string.\n     */\n    bytes(filePath: string): Promise<Uint8Array | undefined>;\n    /**\n     * Writes a value to a file. If the value is a string, UTF-8 encoding is used.\n     * @param {string} filePath The path to the file to write.\n     * @param {string|ArrayBuffer|ArrayBufferView} contents The contents to write to the\n     *   file.\n     * @returns {Promise<void>} A promise that resolves when the file is\n     *  written.\n     * @throws {TypeError} If the file path is not a string.\n     * @throws {Error} If the file cannot be written.\n     */\n    write(filePath: string, contents: string | ArrayBuffer | ArrayBufferView): Promise<void>;\n    /**\n     * Checks if a file exists.\n     * @param {string} filePath The path to the file to check.\n     * @returns {Promise<boolean>} A promise that resolves with true if the\n     *    file exists or false if it does not.\n     * @throws {Error} If the operation fails with a code other than ENOENT.\n     */\n    isFile(filePath: string): Promise<boolean>;\n    /**\n     * Checks if a directory exists.\n     * @param {string} dirPath The path to the directory to check.\n     * @returns {Promise<boolean>} A promise that resolves with true if the\n     *    directory exists or false if it does not.\n     * @throws {Error} If the operation fails with a code other than ENOENT.\n     */\n    isDirectory(dirPath: string): Promise<boolean>;\n    /**\n     * Creates a directory recursively.\n     * @param {string} dirPath The path to the directory to create.\n     * @returns {Promise<void>} A promise that resolves when the directory is\n     *   created.\n     */\n    createDirectory(dirPath: string): Promise<void>;\n    /**\n     * Deletes a file or empty directory.\n     * @param {string} fileOrDirPath The path to the file or directory to\n     *   delete.\n     * @returns {Promise<void>} A promise that resolves when the file or\n     *   directory is deleted.\n     * @throws {TypeError} If the file or directory path is not a string.\n     * @throws {Error} If the file or directory cannot be deleted.\n     * @throws {Error} If the file or directory is not found.\n     */\n    delete(fileOrDirPath: string): Promise<void>;\n    /**\n     * Deletes a file or directory recursively.\n     * @param {string} fileOrDirPath The path to the file or directory to\n     *   delete.\n     * @returns {Promise<void>} A promise that resolves when the file or\n     *   directory is deleted.\n     * @throws {TypeError} If the file or directory path is not a string.\n     * @throws {Error} If the file or directory cannot be deleted.\n     * @throws {Error} If the file or directory is not found.\n     */\n    deleteAll(fileOrDirPath: string): Promise<void>;\n    /**\n     * Returns a list of directory entries for the given path.\n     * @param {string} dirPath The path to the directory to read.\n     * @returns {AsyncIterable<HfsDirectoryEntry>} A promise that resolves with the\n     *   directory entries.\n     * @throws {TypeError} If the directory path is not a string.\n     * @throws {Error} If the directory cannot be read.\n     */\n    list(dirPath: string): AsyncIterable<HfsDirectoryEntry>;\n    /**\n     * Returns the size of a file.\n     * @param {string} filePath The path to the file to read.\n     * @returns {Promise<number|undefined>} A promise that resolves with the size of the\n     *  file in bytes or undefined if the file doesn't exist.\n     */\n    size(filePath: string): Promise<number | undefined>;\n    #private;\n}\n/**\n * A class representing a file system utility library.\n * @implements {HfsImpl}\n */\nexport class NodeHfs extends Hfs implements HfsImpl {\n    /**\n     * Creates a new instance.\n     * @param {object} [options] The options for the instance.\n     * @param {Fsp} [options.fsp] The file system module to use.\n     */\n    constructor({ fsp }?: {\n        fsp?: Fsp;\n    });\n}\nexport const hfs: NodeHfs;\nexport type HfsImpl = import(\"@humanfs/types\").HfsImpl;\nexport type HfsDirectoryEntry = import(\"@humanfs/types\").HfsDirectoryEntry;\nexport type Fsp = typeof nativeFsp;\nexport type Dirent = import(\"fs\").Dirent;\nimport { Hfs } from \"@humanfs/core\";\nimport nativeFsp from \"node:fs/promises\";\n"
        }
    ]
}