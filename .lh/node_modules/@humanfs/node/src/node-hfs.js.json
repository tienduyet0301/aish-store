{
    "sourceFile": "node_modules/@humanfs/node/src/node-hfs.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891879260,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview The main file for the hfs package.\n * @author Nicholas C. Zakas\n */\n/* global Buffer:readonly, URL */\n\n//-----------------------------------------------------------------------------\n// Types\n//-----------------------------------------------------------------------------\n\n/** @typedef {import(\"@humanfs/types\").HfsImpl} HfsImpl */\n/** @typedef {import(\"@humanfs/types\").HfsDirectoryEntry} HfsDirectoryEntry */\n/** @typedef {import(\"node:fs/promises\")} Fsp */\n/** @typedef {import(\"fs\").Dirent} Dirent */\n\n//-----------------------------------------------------------------------------\n// Imports\n//-----------------------------------------------------------------------------\n\nimport { Hfs } from \"@humanfs/core\";\nimport path from \"node:path\";\nimport { Retrier } from \"@humanwhocodes/retry\";\nimport nativeFsp from \"node:fs/promises\";\nimport { fileURLToPath } from \"node:url\";\n\n//-----------------------------------------------------------------------------\n// Constants\n//-----------------------------------------------------------------------------\n\nconst RETRY_ERROR_CODES = new Set([\"ENFILE\", \"EMFILE\"]);\n\n//-----------------------------------------------------------------------------\n// Helpers\n//-----------------------------------------------------------------------------\n\n/**\n * A class representing a directory entry.\n * @implements {HfsDirectoryEntry}\n */\nclass NodeHfsDirectoryEntry {\n\t/**\n\t * The name of the directory entry.\n\t * @type {string}\n\t */\n\tname;\n\n\t/**\n\t * True if the entry is a file.\n\t * @type {boolean}\n\t */\n\tisFile;\n\n\t/**\n\t * True if the entry is a directory.\n\t * @type {boolean}\n\t */\n\tisDirectory;\n\n\t/**\n\t * True if the entry is a symbolic link.\n\t * @type {boolean}\n\t */\n\tisSymlink;\n\n\t/**\n\t * Creates a new instance.\n\t * @param {Dirent} dirent The directory entry to wrap.\n\t */\n\tconstructor(dirent) {\n\t\tthis.name = dirent.name;\n\t\tthis.isFile = dirent.isFile();\n\t\tthis.isDirectory = dirent.isDirectory();\n\t\tthis.isSymlink = dirent.isSymbolicLink();\n\t}\n}\n\n//-----------------------------------------------------------------------------\n// Exports\n//-----------------------------------------------------------------------------\n\n/**\n * A class representing the Node.js implementation of Hfs.\n * @implements {HfsImpl}\n */\nexport class NodeHfsImpl {\n\t/**\n\t * The file system module to use.\n\t * @type {Fsp}\n\t */\n\t#fsp;\n\n\t/**\n\t * The retryer object used for retrying operations.\n\t * @type {Retrier}\n\t */\n\t#retrier;\n\n\t/**\n\t * Creates a new instance.\n\t * @param {object} [options] The options for the instance.\n\t * @param {Fsp} [options.fsp] The file system module to use.\n\t */\n\tconstructor({ fsp = nativeFsp } = {}) {\n\t\tthis.#fsp = fsp;\n\t\tthis.#retrier = new Retrier(error => RETRY_ERROR_CODES.has(error.code));\n\t}\n\n\t/**\n\t * Reads a file and returns the contents as an Uint8Array.\n\t * @param {string|URL} filePath The path to the file to read.\n\t * @returns {Promise<Uint8Array|undefined>} A promise that resolves with the contents\n\t *    of the file or undefined if the file doesn't exist.\n\t * @throws {Error} If the file cannot be read.\n\t * @throws {TypeError} If the file path is not a string.\n\t */\n\tbytes(filePath) {\n\t\treturn this.#retrier\n\t\t\t.retry(() => this.#fsp.readFile(filePath))\n\t\t\t.then(buffer => new Uint8Array(buffer.buffer))\n\t\t\t.catch(error => {\n\t\t\t\tif (error.code === \"ENOENT\") {\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\n\t\t\t\tthrow error;\n\t\t\t});\n\t}\n\n\t/**\n\t * Writes a value to a file. If the value is a string, UTF-8 encoding is used.\n\t * @param {string|URL} filePath The path to the file to write.\n\t * @param {Uint8Array} contents The contents to write to the\n\t *   file.\n\t * @returns {Promise<void>} A promise that resolves when the file is\n\t *  written.\n\t * @throws {TypeError} If the file path is not a string.\n\t * @throws {Error} If the file cannot be written.\n\t */\n\tasync write(filePath, contents) {\n\t\tconst value = Buffer.from(contents);\n\n\t\treturn this.#retrier\n\t\t\t.retry(() => this.#fsp.writeFile(filePath, value))\n\t\t\t.catch(error => {\n\t\t\t\t// the directory may not exist, so create it\n\t\t\t\tif (error.code === \"ENOENT\") {\n\t\t\t\t\tconst dirPath = path.dirname(\n\t\t\t\t\t\tfilePath instanceof URL\n\t\t\t\t\t\t\t? fileURLToPath(filePath)\n\t\t\t\t\t\t\t: filePath,\n\t\t\t\t\t);\n\n\t\t\t\t\treturn this.#fsp\n\t\t\t\t\t\t.mkdir(dirPath, { recursive: true })\n\t\t\t\t\t\t.then(() => this.#fsp.writeFile(filePath, value));\n\t\t\t\t}\n\n\t\t\t\tthrow error;\n\t\t\t});\n\t}\n\n\t/**\n\t * Appends a value to a file. If the value is a string, UTF-8 encoding is used.\n\t * @param {string|URL} filePath The path to the file to append to.\n\t * @param {Uint8Array} contents The contents to append to the\n\t *  file.\n\t * @returns {Promise<void>} A promise that resolves when the file is\n\t * written.\n\t * @throws {TypeError} If the file path is not a string.\n\t * @throws {Error} If the file cannot be appended to.\n\t */\n\tasync append(filePath, contents) {\n\t\tconst value = Buffer.from(contents);\n\n\t\treturn this.#retrier\n\t\t\t.retry(() => this.#fsp.appendFile(filePath, value))\n\t\t\t.catch(error => {\n\t\t\t\t// the directory may not exist, so create it\n\t\t\t\tif (error.code === \"ENOENT\") {\n\t\t\t\t\tconst dirPath = path.dirname(\n\t\t\t\t\t\tfilePath instanceof URL\n\t\t\t\t\t\t\t? fileURLToPath(filePath)\n\t\t\t\t\t\t\t: filePath,\n\t\t\t\t\t);\n\n\t\t\t\t\treturn this.#fsp\n\t\t\t\t\t\t.mkdir(dirPath, { recursive: true })\n\t\t\t\t\t\t.then(() => this.#fsp.appendFile(filePath, value));\n\t\t\t\t}\n\n\t\t\t\tthrow error;\n\t\t\t});\n\t}\n\n\t/**\n\t * Checks if a file exists.\n\t * @param {string|URL} filePath The path to the file to check.\n\t * @returns {Promise<boolean>} A promise that resolves with true if the\n\t *    file exists or false if it does not.\n\t * @throws {Error} If the operation fails with a code other than ENOENT.\n\t */\n\tisFile(filePath) {\n\t\treturn this.#fsp\n\t\t\t.stat(filePath)\n\t\t\t.then(stat => stat.isFile())\n\t\t\t.catch(error => {\n\t\t\t\tif (error.code === \"ENOENT\") {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tthrow error;\n\t\t\t});\n\t}\n\n\t/**\n\t * Checks if a directory exists.\n\t * @param {string|URL} dirPath The path to the directory to check.\n\t * @returns {Promise<boolean>} A promise that resolves with true if the\n\t *    directory exists or false if it does not.\n\t * @throws {Error} If the operation fails with a code other than ENOENT.\n\t */\n\tisDirectory(dirPath) {\n\t\treturn this.#fsp\n\t\t\t.stat(dirPath)\n\t\t\t.then(stat => stat.isDirectory())\n\t\t\t.catch(error => {\n\t\t\t\tif (error.code === \"ENOENT\") {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tthrow error;\n\t\t\t});\n\t}\n\n\t/**\n\t * Creates a directory recursively.\n\t * @param {string|URL} dirPath The path to the directory to create.\n\t * @returns {Promise<void>} A promise that resolves when the directory is\n\t *   created.\n\t */\n\tasync createDirectory(dirPath) {\n\t\tawait this.#fsp.mkdir(dirPath, { recursive: true });\n\t}\n\n\t/**\n\t * Deletes a file or empty directory.\n\t * @param {string|URL} fileOrDirPath The path to the file or directory to\n\t *   delete.\n\t * @returns {Promise<boolean>} A promise that resolves when the file or\n\t *   directory is deleted, true if the file or directory is deleted, false\n\t *   if the file or directory does not exist.\n\t * @throws {TypeError} If the file or directory path is not a string.\n\t * @throws {Error} If the file or directory cannot be deleted.\n\t */\n\tdelete(fileOrDirPath) {\n\t\treturn this.#fsp\n\t\t\t.rm(fileOrDirPath)\n\t\t\t.then(() => true)\n\t\t\t.catch(error => {\n\t\t\t\tif (error.code === \"ERR_FS_EISDIR\") {\n\t\t\t\t\treturn this.#fsp.rmdir(fileOrDirPath).then(() => true);\n\t\t\t\t}\n\n\t\t\t\tif (error.code === \"ENOENT\") {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tthrow error;\n\t\t\t});\n\t}\n\n\t/**\n\t * Deletes a file or directory recursively.\n\t * @param {string|URL} fileOrDirPath The path to the file or directory to\n\t *   delete.\n\t * @returns {Promise<boolean>} A promise that resolves when the file or\n\t *   directory is deleted, true if the file or directory is deleted, false\n\t *   if the file or directory does not exist.\n\t * @throws {TypeError} If the file or directory path is not a string.\n\t * @throws {Error} If the file or directory cannot be deleted.\n\t */\n\tdeleteAll(fileOrDirPath) {\n\t\treturn this.#fsp\n\t\t\t.rm(fileOrDirPath, { recursive: true })\n\t\t\t.then(() => true)\n\t\t\t.catch(error => {\n\t\t\t\tif (error.code === \"ENOENT\") {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tthrow error;\n\t\t\t});\n\t}\n\n\t/**\n\t * Returns a list of directory entries for the given path.\n\t * @param {string|URL} dirPath The path to the directory to read.\n\t * @returns {AsyncIterable<HfsDirectoryEntry>} A promise that resolves with the\n\t *   directory entries.\n\t * @throws {TypeError} If the directory path is not a string.\n\t * @throws {Error} If the directory cannot be read.\n\t */\n\tasync *list(dirPath) {\n\t\tconst entries = await this.#fsp.readdir(dirPath, {\n\t\t\twithFileTypes: true,\n\t\t});\n\n\t\tfor (const entry of entries) {\n\t\t\tyield new NodeHfsDirectoryEntry(entry);\n\t\t}\n\t}\n\n\t/**\n\t * Returns the size of a file. This method handles ENOENT errors\n\t * and returns undefined in that case.\n\t * @param {string|URL} filePath The path to the file to read.\n\t * @returns {Promise<number|undefined>} A promise that resolves with the size of the\n\t *  file in bytes or undefined if the file doesn't exist.\n\t */\n\tsize(filePath) {\n\t\treturn this.#fsp\n\t\t\t.stat(filePath)\n\t\t\t.then(stat => stat.size)\n\t\t\t.catch(error => {\n\t\t\t\tif (error.code === \"ENOENT\") {\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\n\t\t\t\tthrow error;\n\t\t\t});\n\t}\n\n\t/**\n\t * Returns the last modified date of a file or directory. This method handles ENOENT errors\n\t * and returns undefined in that case.\n\t * @param {string|URL} fileOrDirPath The path to the file to read.\n\t * @returns {Promise<Date|undefined>} A promise that resolves with the last modified\n\t * date of the file or directory, or undefined if the file doesn't exist.\n\t */\n\tlastModified(fileOrDirPath) {\n\t\treturn this.#fsp\n\t\t\t.stat(fileOrDirPath)\n\t\t\t.then(stat => stat.mtime)\n\t\t\t.catch(error => {\n\t\t\t\tif (error.code === \"ENOENT\") {\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\n\t\t\t\tthrow error;\n\t\t\t});\n\t}\n\n\t/**\n\t * Copies a file from one location to another.\n\t * @param {string|URL} source The path to the file to copy.\n\t * @param {string|URL} destination The path to copy the file to.\n\t * @returns {Promise<void>} A promise that resolves when the file is copied.\n\t * @throws {Error} If the source file does not exist.\n\t * @throws {Error} If the source file is a directory.\n\t * @throws {Error} If the destination file is a directory.\n\t */\n\tcopy(source, destination) {\n\t\treturn this.#fsp.copyFile(source, destination);\n\t}\n\n\t/**\n\t * Copies a file or directory from one location to another.\n\t * @param {string|URL} source The path to the file or directory to copy.\n\t * @param {string|URL} destination The path to copy the file or directory to.\n\t * @returns {Promise<void>} A promise that resolves when the file or directory is\n\t * copied.\n\t * @throws {Error} If the source file or directory does not exist.\n\t * @throws {Error} If the destination file or directory is a directory.\n\t */\n\tasync copyAll(source, destination) {\n\t\t// for files use copy() and exit\n\t\tif (await this.isFile(source)) {\n\t\t\treturn this.copy(source, destination);\n\t\t}\n\n\t\tconst sourceStr =\n\t\t\tsource instanceof URL ? fileURLToPath(source) : source;\n\n\t\tconst destinationStr =\n\t\t\tdestination instanceof URL\n\t\t\t\t? fileURLToPath(destination)\n\t\t\t\t: destination;\n\n\t\t// for directories, create the destination directory and copy each entry\n\t\tawait this.createDirectory(destination);\n\n\t\tfor await (const entry of this.list(source)) {\n\t\t\tconst fromEntryPath = path.join(sourceStr, entry.name);\n\t\t\tconst toEntryPath = path.join(destinationStr, entry.name);\n\n\t\t\tif (entry.isDirectory) {\n\t\t\t\tawait this.copyAll(fromEntryPath, toEntryPath);\n\t\t\t} else {\n\t\t\t\tawait this.copy(fromEntryPath, toEntryPath);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Moves a file from the source path to the destination path.\n\t * @param {string|URL} source The location of the file to move.\n\t * @param {string|URL} destination The destination of the file to move.\n\t * @returns {Promise<void>} A promise that resolves when the move is complete.\n\t * @throws {TypeError} If the file paths are not strings.\n\t * @throws {Error} If the file cannot be moved.\n\t */\n\tmove(source, destination) {\n\t\treturn this.#fsp.stat(source).then(stat => {\n\t\t\tif (stat.isDirectory()) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`EISDIR: illegal operation on a directory, move '${source}' -> '${destination}'`,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\treturn this.#fsp.rename(source, destination);\n\t\t});\n\t}\n\n\t/**\n\t * Moves a file or directory from the source path to the destination path.\n\t * @param {string|URL} source The location of the file or directory to move.\n\t * @param {string|URL} destination The destination of the file or directory to move.\n\t * @returns {Promise<void>} A promise that resolves when the move is complete.\n\t * @throws {TypeError} If the file paths are not strings.\n\t * @throws {Error} If the file or directory cannot be moved.\n\t */\n\tasync moveAll(source, destination) {\n\t\treturn this.#fsp.rename(source, destination);\n\t}\n}\n\n/**\n * A class representing a file system utility library.\n * @implements {HfsImpl}\n */\nexport class NodeHfs extends Hfs {\n\t/**\n\t * Creates a new instance.\n\t * @param {object} [options] The options for the instance.\n\t * @param {Fsp} [options.fsp] The file system module to use.\n\t */\n\tconstructor({ fsp } = {}) {\n\t\tsuper({ impl: new NodeHfsImpl({ fsp }) });\n\t}\n}\n\nexport const hfs = new NodeHfs();\n"
        }
    ]
}