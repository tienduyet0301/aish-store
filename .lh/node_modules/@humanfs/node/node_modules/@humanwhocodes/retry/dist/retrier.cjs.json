{
    "sourceFile": "node_modules/@humanfs/node/node_modules/@humanwhocodes/retry/dist/retrier.cjs",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891878979,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "'use strict';\n\n/**\n * @fileoverview A utility for retrying failed async method calls.\n */\n\n/* global setTimeout, clearTimeout */\n\n//-----------------------------------------------------------------------------\n// Constants\n//-----------------------------------------------------------------------------\n\nconst MAX_TASK_TIMEOUT = 60000;\nconst MAX_TASK_DELAY = 100;\n\n//-----------------------------------------------------------------------------\n// Helpers\n//-----------------------------------------------------------------------------\n\n/*\n * The following logic has been extracted from graceful-fs.\n *\n * The ISC License\n *\n * Copyright (c) 2011-2023 Isaac Z. Schlueter, Ben Noordhuis, and Contributors\n *\n * Permission to use, copy, modify, and/or distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR\n * IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n/**\n * Checks if it is time to retry a task based on the timestamp and last attempt time.\n * @param {RetryTask} task The task to check.\n * @param {number} maxDelay The maximum delay for the queue.\n * @returns {boolean} true if it is time to retry, false otherwise.\n */\nfunction isTimeToRetry(task, maxDelay) {\n    const timeSinceLastAttempt = Date.now() - task.lastAttempt;\n    const timeSinceStart = Math.max(task.lastAttempt - task.timestamp, 1);\n    const desiredDelay = Math.min(timeSinceStart * 1.2, maxDelay);\n\n    return timeSinceLastAttempt >= desiredDelay;\n}\n\n/**\n * Checks if it is time to bail out based on the given timestamp.\n * @param {RetryTask} task The task to check.\n * @param {number} timeout The timeout for the queue.\n * @returns {boolean} true if it is time to bail, false otherwise.\n */\nfunction isTimeToBail(task, timeout) {\n    return task.age > timeout;\n}\n\n\n/**\n * A class to represent a task in the retry queue.\n */\nclass RetryTask {\n\n    /**\n     * The unique ID for the task.\n     * @type {string}\n     */\n    id = Math.random().toString(36).slice(2);\n\n    /**\n     * The function to call.\n     * @type {Function}\n     */\n    fn;\n\n    /**\n     * The error that was thrown.\n     * @type {Error}\n     */\n    error;\n    \n    /**\n     * The timestamp of the task.\n     * @type {number}\n     */\n    timestamp = Date.now();\n\n    /**\n     * The timestamp of the last attempt.\n     * @type {number}\n     */\n    lastAttempt = this.timestamp;\n\n    /**\n     * The resolve function for the promise.\n     * @type {Function}\n     */\n    resolve;\n\n    /**\n     * The reject function for the promise.\n     * @type {Function}\n     */\n    reject;\n\n    /**\n     * The AbortSignal to monitor for cancellation.\n     * @type {AbortSignal|undefined}\n     */\n    signal;\n\n    /**\n     * Creates a new instance.\n     * @param {Function} fn The function to call.\n     * @param {Error} error The error that was thrown.\n     * @param {Function} resolve The resolve function for the promise.\n     * @param {Function} reject The reject function for the promise.\n     * @param {AbortSignal|undefined} signal The AbortSignal to monitor for cancellation.\n     */\n    constructor(fn, error, resolve, reject, signal) {\n        this.fn = fn;\n        this.error = error;\n        this.timestamp = Date.now();\n        this.lastAttempt = Date.now();\n        this.resolve = resolve;\n        this.reject = reject;\n        this.signal = signal;\n    }\n    \n    /**\n     * Gets the age of the task.\n     * @returns {number} The age of the task in milliseconds.\n     * @readonly\n     */\n    get age() {\n        return Date.now() - this.timestamp;\n    }\n}\n\n//-----------------------------------------------------------------------------\n// Exports\n//-----------------------------------------------------------------------------\n\n/**\n * A class that manages a queue of retry jobs.\n */\nclass Retrier {\n\n    /**\n     * Represents the queue for processing tasks.\n     * @type {Array<RetryTask>}\n     */\n    #queue = [];\n\n    /**\n     * The timeout for the queue.\n     * @type {number}\n     */\n    #timeout;\n\n    /**\n     * The maximum delay for the queue.\n     * @type {number}\n     */\n    #maxDelay;\n\n    /**\n     * The setTimeout() timer ID.\n     * @type {NodeJS.Timeout|undefined}\n     */\n    #timerId;\n\n    /**\n     * The function to call.\n     * @type {Function}\n     */\n    #check;\n\n    /**\n     * Creates a new instance.\n     * @param {Function} check The function to call.\n     * @param {object} [options] The options for the instance.\n     * @param {number} [options.timeout] The timeout for the queue.\n     * @param {number} [options.maxDelay] The maximum delay for the queue.\n     */\n    constructor(check, { timeout = MAX_TASK_TIMEOUT, maxDelay = MAX_TASK_DELAY } = {}) {\n\n        if (typeof check !== \"function\") {\n            throw new Error(\"Missing function to check errors\");\n        }\n\n        this.#check = check;\n        this.#timeout = timeout;\n        this.#maxDelay = maxDelay;\n    }\n\n    /**\n     * Adds a new retry job to the queue.\n     * @param {Function} fn The function to call.\n     * @param {object} [options] The options for the job.\n     * @param {AbortSignal} [options.signal] The AbortSignal to monitor for cancellation.\n     * @returns {Promise<any>} A promise that resolves when the queue is\n     *  processed.\n     */\n    retry(fn, { signal } = {}) {\n\n        signal?.throwIfAborted();\n\n        let result;\n\n        try {\n            result = fn();\n        } catch (/** @type {any} */ error) {\n            return Promise.reject(new Error(`Synchronous error: ${error.message}`, { cause: error }));\n        }\n\n        // if the result is not a promise then reject an error\n        if (!result || typeof result.then !== \"function\") {\n            return Promise.reject(new Error(\"Result is not a promise.\"));\n        }\n\n        // call the original function and catch any ENFILE or EMFILE errors\n        // @ts-ignore because we know it's any\n        return Promise.resolve(result).catch(error => {\n            if (!this.#check(error)) {\n                throw error;\n            }\n\n            return new Promise((resolve, reject) => {\n                this.#queue.push(new RetryTask(fn, error, resolve, reject, signal));\n\n                signal?.addEventListener(\"abort\", () => {\n                    reject(signal.reason);\n                });\n\n                this.#processQueue();\n            });\n        });\n    }\n\n    /**\n     * Processes the queue.\n     * @returns {void}\n     */\n    #processQueue() {\n        // clear any timer because we're going to check right now\n        clearTimeout(this.#timerId);\n        this.#timerId = undefined;\n\n        // if there's nothing in the queue, we're done\n        const task = this.#queue.shift();\n        if (!task) {\n            return;\n        }\n        const processAgain = () => {\n            this.#timerId = setTimeout(() => this.#processQueue(), 0);\n        };\n\n        // if it's time to bail, then bail\n        if (isTimeToBail(task, this.#timeout)) {\n            task.reject(task.error);\n            processAgain();\n            return;\n        }\n\n        // if it's not time to retry, then wait and try again\n        if (!isTimeToRetry(task, this.#maxDelay)) {\n            this.#queue.push(task);\n            processAgain();\n            return;\n        }\n\n        // otherwise, try again\n        task.lastAttempt = Date.now();\n        \n        // Promise.resolve needed in case it's a thenable but not a Promise\n        Promise.resolve(task.fn())\n            // @ts-ignore because we know it's any\n            .then(result => task.resolve(result))\n\n            // @ts-ignore because we know it's any\n            .catch(error => {\n                if (!this.#check(error)) {\n                    task.reject(error);\n                    return;\n                }\n\n                // update the task timestamp and push to back of queue to try again\n                task.lastAttempt = Date.now();\n                this.#queue.push(task);\n\n            })\n            .finally(() => this.#processQueue());\n    }\n}\n\nexports.Retrier = Retrier;\n"
        }
    ]
}