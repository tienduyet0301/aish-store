{
    "sourceFile": "node_modules/next/dist/client/components/router-reducer/refetch-inactive-parallel-segments.d.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892692282,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import type { FlightRouterState } from '../../../server/app-render/types';\nimport type { CacheNode } from '../../../shared/lib/app-router-context.shared-runtime';\nimport type { AppRouterState } from './router-reducer-types';\ninterface RefreshInactiveParallelSegments {\n    navigatedAt: number;\n    state: AppRouterState;\n    updatedTree: FlightRouterState;\n    updatedCache: CacheNode;\n    includeNextUrl: boolean;\n    canonicalUrl: string;\n}\n/**\n * Refreshes inactive segments that are still in the current FlightRouterState.\n * A segment is considered \"inactive\" when the server response indicates it didn't match to a page component.\n * This happens during a soft-navigation, where the server will want to patch in the segment\n * with the \"default\" component, but we explicitly ignore the server in this case\n * and keep the existing state for that segment. New data for inactive segments are inherently\n * not part of the server response when we patch the tree, because they were associated with a response\n * from an earlier navigation/request. For each segment, once it becomes \"active\", we encode the URL that provided\n * the data for it. This function traverses parallel routes looking for these markers so that it can re-fetch\n * and patch the new data into the tree.\n */\nexport declare function refreshInactiveParallelSegments(options: RefreshInactiveParallelSegments): Promise<void>;\n/**\n * Walks the current parallel segments to determine if they are \"active\".\n * An active parallel route will have a `__PAGE__` segment in the FlightRouterState.\n * As opposed to a `__DEFAULT__` segment, which means there was no match for that parallel route.\n * We add a special marker here so that we know how to refresh its data when the router is revalidated.\n */\nexport declare function addRefreshMarkerToActiveParallelSegments(tree: FlightRouterState, path: string): void;\nexport {};\n"
        }
    ]
}