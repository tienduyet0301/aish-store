{
    "sourceFile": "node_modules/next/dist/client/components/router-reducer/reducers/navigate-reducer.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892691840,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    handleExternalUrl: null,\n    navigateReducer: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    handleExternalUrl: function() {\n        return handleExternalUrl;\n    },\n    navigateReducer: function() {\n        return navigateReducer;\n    }\n});\nconst _fetchserverresponse = require(\"../fetch-server-response\");\nconst _createhreffromurl = require(\"../create-href-from-url\");\nconst _invalidatecachebelowflightsegmentpath = require(\"../invalidate-cache-below-flight-segmentpath\");\nconst _applyrouterstatepatchtotree = require(\"../apply-router-state-patch-to-tree\");\nconst _shouldhardnavigate = require(\"../should-hard-navigate\");\nconst _isnavigatingtonewrootlayout = require(\"../is-navigating-to-new-root-layout\");\nconst _routerreducertypes = require(\"../router-reducer-types\");\nconst _handlemutable = require(\"../handle-mutable\");\nconst _applyflightdata = require(\"../apply-flight-data\");\nconst _prefetchreducer = require(\"./prefetch-reducer\");\nconst _approuter = require(\"../../app-router\");\nconst _segment = require(\"../../../../shared/lib/segment\");\nconst _pprnavigations = require(\"../ppr-navigations\");\nconst _prefetchcacheutils = require(\"../prefetch-cache-utils\");\nconst _clearcachenodedataforsegmentpath = require(\"../clear-cache-node-data-for-segment-path\");\nconst _aliasedprefetchnavigations = require(\"../aliased-prefetch-navigations\");\nconst _segmentcache = require(\"../../segment-cache\");\nfunction handleExternalUrl(state, mutable, url, pendingPush) {\n    mutable.mpaNavigation = true;\n    mutable.canonicalUrl = url;\n    mutable.pendingPush = pendingPush;\n    mutable.scrollableSegments = undefined;\n    return (0, _handlemutable.handleMutable)(state, mutable);\n}\nfunction generateSegmentsFromPatch(flightRouterPatch) {\n    const segments = [];\n    const [segment, parallelRoutes] = flightRouterPatch;\n    if (Object.keys(parallelRoutes).length === 0) {\n        return [\n            [\n                segment\n            ]\n        ];\n    }\n    for (const [parallelRouteKey, parallelRoute] of Object.entries(parallelRoutes)){\n        for (const childSegment of generateSegmentsFromPatch(parallelRoute)){\n            // If the segment is empty, it means we are at the root of the tree\n            if (segment === '') {\n                segments.push([\n                    parallelRouteKey,\n                    ...childSegment\n                ]);\n            } else {\n                segments.push([\n                    segment,\n                    parallelRouteKey,\n                    ...childSegment\n                ]);\n            }\n        }\n    }\n    return segments;\n}\nfunction triggerLazyFetchForLeafSegments(newCache, currentCache, flightSegmentPath, treePatch) {\n    let appliedPatch = false;\n    newCache.rsc = currentCache.rsc;\n    newCache.prefetchRsc = currentCache.prefetchRsc;\n    newCache.loading = currentCache.loading;\n    newCache.parallelRoutes = new Map(currentCache.parallelRoutes);\n    const segmentPathsToFill = generateSegmentsFromPatch(treePatch).map((segment)=>[\n            ...flightSegmentPath,\n            ...segment\n        ]);\n    for (const segmentPaths of segmentPathsToFill){\n        (0, _clearcachenodedataforsegmentpath.clearCacheNodeDataForSegmentPath)(newCache, currentCache, segmentPaths);\n        appliedPatch = true;\n    }\n    return appliedPatch;\n}\nfunction handleNavigationResult(url, state, mutable, pendingPush, result) {\n    switch(result.tag){\n        case _segmentcache.NavigationResultTag.MPA:\n            {\n                // Perform an MPA navigation.\n                const newUrl = result.data;\n                return handleExternalUrl(state, mutable, newUrl, pendingPush);\n            }\n        case _segmentcache.NavigationResultTag.NoOp:\n            {\n                // The server responded with no change to the current page. However, if\n                // the URL changed, we still need to update that.\n                const newCanonicalUrl = result.data.canonicalUrl;\n                mutable.canonicalUrl = newCanonicalUrl;\n                // Check if the only thing that changed was the hash fragment.\n                const oldUrl = new URL(state.canonicalUrl, url);\n                const onlyHashChange = // We don't need to compare the origins, because client-driven\n                // navigations are always same-origin.\n                url.pathname === oldUrl.pathname && url.search === oldUrl.search && url.hash !== oldUrl.hash;\n                if (onlyHashChange) {\n                    // The only updated part of the URL is the hash.\n                    mutable.onlyHashChange = true;\n                    mutable.shouldScroll = result.data.shouldScroll;\n                    mutable.hashFragment = url.hash;\n                    // Setting this to an empty array triggers a scroll for all new and\n                    // updated segments. See `ScrollAndFocusHandler` for more details.\n                    mutable.scrollableSegments = [];\n                }\n                return (0, _handlemutable.handleMutable)(state, mutable);\n            }\n        case _segmentcache.NavigationResultTag.Success:\n            {\n                // Received a new result.\n                mutable.cache = result.data.cacheNode;\n                mutable.patchedTree = result.data.flightRouterState;\n                mutable.canonicalUrl = result.data.canonicalUrl;\n                mutable.scrollableSegments = result.data.scrollableSegments;\n                mutable.shouldScroll = result.data.shouldScroll;\n                mutable.hashFragment = result.data.hash;\n                return (0, _handlemutable.handleMutable)(state, mutable);\n            }\n        case _segmentcache.NavigationResultTag.Async:\n            {\n                return result.data.then((asyncResult)=>handleNavigationResult(url, state, mutable, pendingPush, asyncResult), // If the navigation failed, return the current state.\n                // TODO: This matches the current behavior but we need to do something\n                // better here if the network fails.\n                ()=>{\n                    return state;\n                });\n            }\n        default:\n            {\n                result;\n                return state;\n            }\n    }\n}\nfunction navigateReducer(state, action) {\n    const { url, isExternalUrl, navigateType, shouldScroll, allowAliasing } = action;\n    const mutable = {};\n    const { hash } = url;\n    const href = (0, _createhreffromurl.createHrefFromUrl)(url);\n    const pendingPush = navigateType === 'push';\n    // we want to prune the prefetch cache on every navigation to avoid it growing too large\n    (0, _prefetchcacheutils.prunePrefetchCache)(state.prefetchCache);\n    mutable.preserveCustomHistoryState = false;\n    mutable.pendingPush = pendingPush;\n    if (isExternalUrl) {\n        return handleExternalUrl(state, mutable, url.toString(), pendingPush);\n    }\n    // Handles case where `<meta http-equiv=\"refresh\">` tag is present,\n    // which will trigger an MPA navigation.\n    if (document.getElementById('__next-page-redirect')) {\n        return handleExternalUrl(state, mutable, href, pendingPush);\n    }\n    if (process.env.__NEXT_CLIENT_SEGMENT_CACHE) {\n        // (Very Early Experimental Feature) Segment Cache\n        //\n        // Bypass the normal prefetch cache and use the new per-segment cache\n        // implementation instead. This is only supported if PPR is enabled, too.\n        //\n        // Temporary glue code between the router reducer and the new navigation\n        // implementation. Eventually we'll rewrite the router reducer to a\n        // state machine.\n        const result = (0, _segmentcache.navigate)(url, state.cache, state.tree, state.nextUrl, shouldScroll);\n        return handleNavigationResult(url, state, mutable, pendingPush, result);\n    }\n    const prefetchValues = (0, _prefetchcacheutils.getOrCreatePrefetchCacheEntry)({\n        url,\n        nextUrl: state.nextUrl,\n        tree: state.tree,\n        prefetchCache: state.prefetchCache,\n        allowAliasing\n    });\n    const { treeAtTimeOfPrefetch, data } = prefetchValues;\n    _prefetchreducer.prefetchQueue.bump(data);\n    return data.then((param)=>{\n        let { flightData, canonicalUrl: canonicalUrlOverride, postponed } = param;\n        const navigatedAt = Date.now();\n        let isFirstRead = false;\n        // we only want to mark this once\n        if (!prefetchValues.lastUsedTime) {\n            // important: we should only mark the cache node as dirty after we unsuspend from the call above\n            prefetchValues.lastUsedTime = navigatedAt;\n            isFirstRead = true;\n        }\n        if (prefetchValues.aliased) {\n            const result = (0, _aliasedprefetchnavigations.handleAliasedPrefetchEntry)(navigatedAt, state, flightData, url, mutable);\n            // We didn't return new router state because we didn't apply the aliased entry for some reason.\n            // We'll re-invoke the navigation handler but ensure that we don't attempt to use the aliased entry. This\n            // will create an on-demand prefetch entry.\n            if (result === false) {\n                return navigateReducer(state, {\n                    ...action,\n                    allowAliasing: false\n                });\n            }\n            return result;\n        }\n        // Handle case when navigating to page in `pages` from `app`\n        if (typeof flightData === 'string') {\n            return handleExternalUrl(state, mutable, flightData, pendingPush);\n        }\n        const updatedCanonicalUrl = canonicalUrlOverride ? (0, _createhreffromurl.createHrefFromUrl)(canonicalUrlOverride) : href;\n        const onlyHashChange = !!hash && state.canonicalUrl.split('#', 1)[0] === updatedCanonicalUrl.split('#', 1)[0];\n        // If only the hash has changed, the server hasn't sent us any new data. We can just update\n        // the mutable properties responsible for URL and scroll handling and return early.\n        if (onlyHashChange) {\n            mutable.onlyHashChange = true;\n            mutable.canonicalUrl = updatedCanonicalUrl;\n            mutable.shouldScroll = shouldScroll;\n            mutable.hashFragment = hash;\n            mutable.scrollableSegments = [];\n            return (0, _handlemutable.handleMutable)(state, mutable);\n        }\n        let currentTree = state.tree;\n        let currentCache = state.cache;\n        let scrollableSegments = [];\n        for (const normalizedFlightData of flightData){\n            const { pathToSegment: flightSegmentPath, seedData, head, isHeadPartial, isRootRender } = normalizedFlightData;\n            let treePatch = normalizedFlightData.tree;\n            // TODO-APP: remove ''\n            const flightSegmentPathWithLeadingEmpty = [\n                '',\n                ...flightSegmentPath\n            ];\n            // Create new tree based on the flightSegmentPath and router state patch\n            let newTree = (0, _applyrouterstatepatchtotree.applyRouterStatePatchToTree)(// TODO-APP: remove ''\n            flightSegmentPathWithLeadingEmpty, currentTree, treePatch, href);\n            // If the tree patch can't be applied to the current tree then we use the tree at time of prefetch\n            // TODO-APP: This should instead fill in the missing pieces in `currentTree` with the data from `treeAtTimeOfPrefetch`, then apply the patch.\n            if (newTree === null) {\n                newTree = (0, _applyrouterstatepatchtotree.applyRouterStatePatchToTree)(// TODO-APP: remove ''\n                flightSegmentPathWithLeadingEmpty, treeAtTimeOfPrefetch, treePatch, href);\n            }\n            if (newTree !== null) {\n                if (// This is just a paranoid check. When a route is PPRed, the server\n                // will send back a static response that's rendered from\n                // the root. If for some reason it doesn't, we fall back to the\n                // non-PPR implementation.\n                // TODO: We should get rid of the else branch and do all navigations\n                // via startPPRNavigation. The current structure is just\n                // an incremental step.\n                seedData && isRootRender && postponed) {\n                    const task = (0, _pprnavigations.startPPRNavigation)(navigatedAt, currentCache, currentTree, treePatch, seedData, head, isHeadPartial, false, scrollableSegments);\n                    if (task !== null) {\n                        if (task.route === null) {\n                            // Detected a change to the root layout. Perform an full-\n                            // page navigation.\n                            return handleExternalUrl(state, mutable, href, pendingPush);\n                        }\n                        // Use the tree computed by startPPRNavigation instead\n                        // of the one computed by applyRouterStatePatchToTree.\n                        // TODO: We should remove applyRouterStatePatchToTree\n                        // from the PPR path entirely.\n                        const patchedRouterState = task.route;\n                        newTree = patchedRouterState;\n                        const newCache = task.node;\n                        if (newCache !== null) {\n                            // We've created a new Cache Node tree that contains a prefetched\n                            // version of the next page. This can be rendered instantly.\n                            mutable.cache = newCache;\n                        }\n                        const dynamicRequestTree = task.dynamicRequestTree;\n                        if (dynamicRequestTree !== null) {\n                            // The prefetched tree has dynamic holes in it. We initiate a\n                            // dynamic request to fill them in.\n                            //\n                            // Do not block on the result. We'll immediately render the Cache\n                            // Node tree and suspend on the dynamic parts. When the request\n                            // comes in, we'll fill in missing data and ping React to\n                            // re-render. Unlike the lazy fetching model in the non-PPR\n                            // implementation, this is modeled as a single React update +\n                            // streaming, rather than multiple top-level updates. (However,\n                            // even in the new model, we'll still need to sometimes update the\n                            // root multiple times per navigation, like if the server sends us\n                            // a different response than we expected. For now, we revert back\n                            // to the lazy fetching mechanism in that case.)\n                            const dynamicRequest = (0, _fetchserverresponse.fetchServerResponse)(url, {\n                                flightRouterState: dynamicRequestTree,\n                                nextUrl: state.nextUrl\n                            });\n                            (0, _pprnavigations.listenForDynamicRequest)(task, dynamicRequest);\n                        // We store the dynamic request on the `lazyData` property of the CacheNode\n                        // because we're not going to await the dynamic request here. Since we're not blocking\n                        // on the dynamic request, `layout-router` will\n                        // task.node.lazyData = dynamicRequest\n                        } else {\n                        // The prefetched tree does not contain dynamic holes â€” it's\n                        // fully static. We can skip the dynamic request.\n                        }\n                    } else {\n                        // Nothing changed, so reuse the old cache.\n                        // TODO: What if the head changed but not any of the segment data?\n                        // Is that possible? If so, we should clone the whole tree and\n                        // update the head.\n                        newTree = treePatch;\n                    }\n                } else {\n                    // The static response does not include any dynamic holes, so\n                    // there's no need to do a second request.\n                    // TODO: As an incremental step this just reverts back to the\n                    // non-PPR implementation. We can simplify this branch further,\n                    // given that PPR prefetches are always static and return the whole\n                    // tree. Or in the meantime we could factor it out into a\n                    // separate function.\n                    if ((0, _isnavigatingtonewrootlayout.isNavigatingToNewRootLayout)(currentTree, newTree)) {\n                        return handleExternalUrl(state, mutable, href, pendingPush);\n                    }\n                    const cache = (0, _approuter.createEmptyCacheNode)();\n                    let applied = false;\n                    if (prefetchValues.status === _routerreducertypes.PrefetchCacheEntryStatus.stale && !isFirstRead) {\n                        // When we have a stale prefetch entry, we only want to re-use the loading state of the route we're navigating to, to support instant loading navigations\n                        // this will trigger a lazy fetch for the actual page data by nulling the `rsc` and `prefetchRsc` values for page data,\n                        // while copying over the `loading` for the segment that contains the page data.\n                        // We only do this on subsequent reads, as otherwise there'd be no loading data to re-use.\n                        // We skip this branch if only the hash fragment has changed, as we don't want to trigger a lazy fetch in that case\n                        applied = triggerLazyFetchForLeafSegments(cache, currentCache, flightSegmentPath, treePatch);\n                        // since we re-used the stale cache's loading state & refreshed the data,\n                        // update the `lastUsedTime` so that it can continue to be re-used for the next 30s\n                        prefetchValues.lastUsedTime = navigatedAt;\n                    } else {\n                        applied = (0, _applyflightdata.applyFlightData)(navigatedAt, currentCache, cache, normalizedFlightData, prefetchValues);\n                    }\n                    const hardNavigate = (0, _shouldhardnavigate.shouldHardNavigate)(// TODO-APP: remove ''\n                    flightSegmentPathWithLeadingEmpty, currentTree);\n                    if (hardNavigate) {\n                        // Copy rsc for the root node of the cache.\n                        cache.rsc = currentCache.rsc;\n                        cache.prefetchRsc = currentCache.prefetchRsc;\n                        (0, _invalidatecachebelowflightsegmentpath.invalidateCacheBelowFlightSegmentPath)(cache, currentCache, flightSegmentPath);\n                        // Ensure the existing cache value is used when the cache was not invalidated.\n                        mutable.cache = cache;\n                    } else if (applied) {\n                        mutable.cache = cache;\n                        // If we applied the cache, we update the \"current cache\" value so any other\n                        // segments in the FlightDataPath will be able to reference the updated cache.\n                        currentCache = cache;\n                    }\n                    for (const subSegment of generateSegmentsFromPatch(treePatch)){\n                        const scrollableSegmentPath = [\n                            ...flightSegmentPath,\n                            ...subSegment\n                        ];\n                        // Filter out the __DEFAULT__ paths as they shouldn't be scrolled to in this case.\n                        if (scrollableSegmentPath[scrollableSegmentPath.length - 1] !== _segment.DEFAULT_SEGMENT_KEY) {\n                            scrollableSegments.push(scrollableSegmentPath);\n                        }\n                    }\n                }\n                currentTree = newTree;\n            }\n        }\n        mutable.patchedTree = currentTree;\n        mutable.canonicalUrl = updatedCanonicalUrl;\n        mutable.scrollableSegments = scrollableSegments;\n        mutable.hashFragment = hash;\n        mutable.shouldScroll = shouldScroll;\n        return (0, _handlemutable.handleMutable)(state, mutable);\n    }, ()=>state);\n}\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=navigate-reducer.js.map"
        }
    ]
}