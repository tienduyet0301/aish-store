{
    "sourceFile": "node_modules/next/dist/client/components/segment-cache.d.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892693229,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * Entry point to the Segment Cache implementation.\n *\n * All code related to the Segment Cache lives `segment-cache-impl` directory.\n * Callers access it through this indirection.\n *\n * This is to ensure the code is dead code eliminated from the bundle if the\n * flag is disabled.\n *\n * TODO: This is super tedious. Since experimental flags are an essential part\n * of our workflow, we should establish a better pattern for dead code\n * elimination. Ideally it would be done at the bundler level, like how React's\n * build process works. In the React repo, you don't even need to add any extra\n * configuration per experiment â€” if the code is not reachable, it gets stripped\n * from the build automatically by Rollup. Or, shorter term, we could stub out\n * experimental modules at build time by updating the build config, i.e. a more\n * automated version of what I'm doing manually in this file.\n */\nexport type { NavigationResult } from './segment-cache-impl/navigation';\nexport type { PrefetchTask } from './segment-cache-impl/scheduler';\nexport declare const prefetch: typeof import('./segment-cache-impl/prefetch').prefetch;\nexport declare const navigate: typeof import('./segment-cache-impl/navigation').navigate;\nexport declare const revalidateEntireCache: typeof import('./segment-cache-impl/cache').revalidateEntireCache;\nexport declare const getCurrentCacheVersion: typeof import('./segment-cache-impl/cache').getCurrentCacheVersion;\nexport declare const schedulePrefetchTask: typeof import('./segment-cache-impl/scheduler').schedulePrefetchTask;\nexport declare const cancelPrefetchTask: typeof import('./segment-cache-impl/scheduler').cancelPrefetchTask;\nexport declare const reschedulePrefetchTask: typeof import('./segment-cache-impl/scheduler').reschedulePrefetchTask;\nexport declare const createCacheKey: typeof import('./segment-cache-impl/cache-key').createCacheKey;\n/**\n * Below are public constants. They're small enough that we don't need to\n * DCE them.\n */\nexport declare const enum NavigationResultTag {\n    MPA = 0,\n    Success = 1,\n    NoOp = 2,\n    Async = 3\n}\n/**\n * The priority of the prefetch task. Higher numbers are higher priority.\n */\nexport declare const enum PrefetchPriority {\n    /**\n     * Assigned to any visible link that was hovered/touched at some point. This\n     * is not removed on mouse exit, because a link that was momentarily\n     * hovered is more likely to to be interacted with than one that was not.\n     */\n    Intent = 2,\n    /**\n     * The default priority for prefetch tasks.\n     */\n    Default = 1,\n    /**\n     * Assigned to tasks when they spawn non-blocking background work, like\n     * revalidating a partially cached entry to see if more data is available.\n     */\n    Background = 0\n}\n"
        }
    ]
}