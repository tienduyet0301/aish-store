{
    "sourceFile": "node_modules/next/dist/client/components/segment-cache-impl/lru.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892692865,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"createLRU\", {\n    enumerable: true,\n    get: function() {\n        return createLRU;\n    }\n});\nfunction createLRU(// From the LRU's perspective, the size unit is arbitrary, but for our\n// purposes this is the byte size.\nmaxLruSize, onEviction) {\n    let head = null;\n    let didScheduleCleanup = false;\n    let lruSize = 0;\n    function put(node) {\n        if (head === node) {\n            // Already at the head\n            return;\n        }\n        const prev = node.prev;\n        const next = node.next;\n        if (next === null || prev === null) {\n            // This is an insertion\n            lruSize += node.size;\n            // Whenever we add an entry, we need to check if we've exceeded the\n            // max size. We don't evict entries immediately; they're evicted later in\n            // an asynchronous task.\n            ensureCleanupIsScheduled();\n        } else {\n            // This is a move. Remove from its current position.\n            prev.next = next;\n            next.prev = prev;\n        }\n        // Move to the front of the list\n        if (head === null) {\n            // This is the first entry\n            node.prev = node;\n            node.next = node;\n        } else {\n            // Add to the front of the list\n            const tail = head.prev;\n            node.prev = tail;\n            tail.next = node;\n            node.next = head;\n            head.prev = node;\n        }\n        head = node;\n    }\n    function updateSize(node, newNodeSize) {\n        // This is a separate function from `put` so that we can resize the entry\n        // regardless of whether it's currently being tracked by the LRU.\n        const prevNodeSize = node.size;\n        node.size = newNodeSize;\n        if (node.next === null) {\n            // This entry is not currently being tracked by the LRU.\n            return;\n        }\n        // Update the total LRU size\n        lruSize = lruSize - prevNodeSize + newNodeSize;\n        ensureCleanupIsScheduled();\n    }\n    function deleteNode(deleted) {\n        const next = deleted.next;\n        const prev = deleted.prev;\n        if (next !== null && prev !== null) {\n            lruSize -= deleted.size;\n            deleted.next = null;\n            deleted.prev = null;\n            // Remove from the list\n            if (head === deleted) {\n                // Update the head\n                if (next === head) {\n                    // This was the last entry\n                    head = null;\n                } else {\n                    head = next;\n                }\n            } else {\n                prev.next = next;\n                next.prev = prev;\n            }\n        } else {\n        // Already deleted\n        }\n    }\n    function ensureCleanupIsScheduled() {\n        if (didScheduleCleanup || lruSize <= maxLruSize) {\n            return;\n        }\n        didScheduleCleanup = true;\n        requestCleanupCallback(cleanup);\n    }\n    function cleanup() {\n        didScheduleCleanup = false;\n        // Evict entries until we're at 90% capacity. We can assume this won't\n        // infinite loop because even if `maxLruSize` were 0, eventually\n        // `deleteNode` sets `head` to `null` when we run out entries.\n        const ninetyPercentMax = maxLruSize * 0.9;\n        while(lruSize > ninetyPercentMax && head !== null){\n            const tail = head.prev;\n            deleteNode(tail);\n            onEviction(tail);\n        }\n    }\n    return {\n        put,\n        delete: deleteNode,\n        updateSize\n    };\n}\nconst requestCleanupCallback = typeof requestIdleCallback === 'function' ? requestIdleCallback : (cb)=>setTimeout(cb, 0);\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=lru.js.map"
        }
    ]
}