{
    "sourceFile": "node_modules/next/dist/client/components/segment-cache-impl/navigation.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892692946,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"navigate\", {\n    enumerable: true,\n    get: function() {\n        return navigate;\n    }\n});\nconst _fetchserverresponse = require(\"../router-reducer/fetch-server-response\");\nconst _pprnavigations = require(\"../router-reducer/ppr-navigations\");\nconst _createhreffromurl = require(\"../router-reducer/create-href-from-url\");\nconst _cache = require(\"./cache\");\nconst _cachekey = require(\"./cache-key\");\nconst _segment = require(\"../../../shared/lib/segment\");\nconst _segmentcache = require(\"../segment-cache\");\nfunction navigate(url, currentCacheNode, currentFlightRouterState, nextUrl, shouldScroll) {\n    const now = Date.now();\n    const href = url.href;\n    // We special case navigations to the exact same URL as the current location.\n    // It's a common UI pattern for apps to refresh when you click a link to the\n    // current page. So when this happens, we refresh the dynamic data in the page\n    // segments.\n    //\n    // Note that this does not apply if the any part of the hash or search query\n    // has changed. This might feel a bit weird but it makes more sense when you\n    // consider that the way to trigger this behavior is to click the same link\n    // multiple times.\n    //\n    // TODO: We should probably refresh the *entire* route when this case occurs,\n    // not just the page segments. Essentially treating it the same as a refresh()\n    // triggered by an action, which is the more explicit way of modeling the UI\n    // pattern described above.\n    //\n    // Also note that this only refreshes the dynamic data, not static/ cached\n    // data. If the page segment is fully static and prefetched, the request is\n    // skipped. (This is also how refresh() works.)\n    const isSamePageNavigation = // TODO: This is not the only place we read from the location, but we should\n    // consider storing the current URL in the router state instead of reading\n    // from the location object. In practice I don't think this matters much\n    // since we keep them in sync anyway, but having two sources of truth can\n    // lead to subtle bugs and race conditions.\n    href === window.location.href;\n    const cacheKey = (0, _cachekey.createCacheKey)(href, nextUrl);\n    const route = (0, _cache.readRouteCacheEntry)(now, cacheKey);\n    if (route !== null && route.status === _cache.EntryStatus.Fulfilled) {\n        // We have a matching prefetch.\n        const snapshot = readRenderSnapshotFromCache(now, cacheKey, route.tree);\n        const prefetchFlightRouterState = snapshot.flightRouterState;\n        const prefetchSeedData = snapshot.seedData;\n        const prefetchHead = route.head;\n        const isPrefetchHeadPartial = route.isHeadPartial;\n        const newCanonicalUrl = route.canonicalUrl;\n        return navigateUsingPrefetchedRouteTree(now, url, nextUrl, isSamePageNavigation, currentCacheNode, currentFlightRouterState, prefetchFlightRouterState, prefetchSeedData, prefetchHead, isPrefetchHeadPartial, newCanonicalUrl, shouldScroll, url.hash);\n    }\n    // There's no matching prefetch for this route in the cache.\n    return {\n        tag: _segmentcache.NavigationResultTag.Async,\n        data: navigateDynamicallyWithNoPrefetch(now, url, nextUrl, isSamePageNavigation, currentCacheNode, currentFlightRouterState, shouldScroll, url.hash)\n    };\n}\nfunction navigateUsingPrefetchedRouteTree(now, url, nextUrl, isSamePageNavigation, currentCacheNode, currentFlightRouterState, prefetchFlightRouterState, prefetchSeedData, prefetchHead, isPrefetchHeadPartial, canonicalUrl, shouldScroll, hash) {\n    // Recursively construct a prefetch tree by reading from the Segment Cache. To\n    // maintain compatibility, we output the same data structures as the old\n    // prefetching implementation: FlightRouterState and CacheNodeSeedData.\n    // TODO: Eventually updateCacheNodeOnNavigation (or the equivalent) should\n    // read from the Segment Cache directly. It's only structured this way for now\n    // so we can share code with the old prefetching implementation.\n    const scrollableSegments = [];\n    const task = (0, _pprnavigations.startPPRNavigation)(now, currentCacheNode, currentFlightRouterState, prefetchFlightRouterState, prefetchSeedData, prefetchHead, isPrefetchHeadPartial, isSamePageNavigation, scrollableSegments);\n    if (task !== null) {\n        const dynamicRequestTree = task.dynamicRequestTree;\n        if (dynamicRequestTree !== null) {\n            const promiseForDynamicServerResponse = (0, _fetchserverresponse.fetchServerResponse)(url, {\n                flightRouterState: dynamicRequestTree,\n                nextUrl\n            });\n            (0, _pprnavigations.listenForDynamicRequest)(task, promiseForDynamicServerResponse);\n        } else {\n        // The prefetched tree does not contain dynamic holes — it's\n        // fully static. We can skip the dynamic request.\n        }\n        return navigationTaskToResult(task, currentCacheNode, canonicalUrl, scrollableSegments, shouldScroll, hash);\n    }\n    // The server sent back an empty tree patch. There's nothing to update, except\n    // possibly the URL.\n    return {\n        tag: _segmentcache.NavigationResultTag.NoOp,\n        data: {\n            canonicalUrl,\n            shouldScroll\n        }\n    };\n}\nfunction navigationTaskToResult(task, currentCacheNode, canonicalUrl, scrollableSegments, shouldScroll, hash) {\n    const flightRouterState = task.route;\n    if (flightRouterState === null) {\n        // When no router state is provided, it signals that we should perform an\n        // MPA navigation.\n        return {\n            tag: _segmentcache.NavigationResultTag.MPA,\n            data: canonicalUrl\n        };\n    }\n    const newCacheNode = task.node;\n    return {\n        tag: _segmentcache.NavigationResultTag.Success,\n        data: {\n            flightRouterState,\n            cacheNode: newCacheNode !== null ? newCacheNode : currentCacheNode,\n            canonicalUrl,\n            scrollableSegments,\n            shouldScroll,\n            hash\n        }\n    };\n}\nfunction readRenderSnapshotFromCache(now, routeCacheKey, tree) {\n    let childRouterStates = {};\n    let childSeedDatas = {};\n    const slots = tree.slots;\n    if (slots !== null) {\n        for(const parallelRouteKey in slots){\n            const childTree = slots[parallelRouteKey];\n            const childResult = readRenderSnapshotFromCache(now, routeCacheKey, childTree);\n            childRouterStates[parallelRouteKey] = childResult.flightRouterState;\n            childSeedDatas[parallelRouteKey] = childResult.seedData;\n        }\n    }\n    let rsc = null;\n    let loading = null;\n    let isPartial = true;\n    const segmentEntry = (0, _cache.readSegmentCacheEntry)(now, routeCacheKey, tree.key);\n    if (segmentEntry !== null) {\n        switch(segmentEntry.status){\n            case _cache.EntryStatus.Fulfilled:\n                {\n                    // Happy path: a cache hit\n                    rsc = segmentEntry.rsc;\n                    loading = segmentEntry.loading;\n                    isPartial = segmentEntry.isPartial;\n                    break;\n                }\n            case _cache.EntryStatus.Pending:\n                {\n                    // We haven't received data for this segment yet, but there's already\n                    // an in-progress request. Since it's extremely likely to arrive\n                    // before the dynamic data response, we might as well use it.\n                    const promiseForFulfilledEntry = (0, _cache.waitForSegmentCacheEntry)(segmentEntry);\n                    rsc = promiseForFulfilledEntry.then((entry)=>entry !== null ? entry.rsc : null);\n                    loading = promiseForFulfilledEntry.then((entry)=>entry !== null ? entry.loading : null);\n                    // Since we don't know yet whether the segment is partial or fully\n                    // static, we must assume it's partial; we can't skip the\n                    // dynamic request.\n                    isPartial = true;\n                    break;\n                }\n            case _cache.EntryStatus.Empty:\n            case _cache.EntryStatus.Rejected:\n                break;\n            default:\n                segmentEntry;\n        }\n    }\n    const segment = tree.segment === _segment.PAGE_SEGMENT_KEY && routeCacheKey.search ? // included in the segment. However, the Segment Cache tracks search\n    // params separately from the rest of the segment key. So we need to\n    // add them back here.\n    //\n    // See corresponding comment in convertFlightRouterStateToTree.\n    //\n    // TODO: What we should do instead is update the navigation diffing\n    // logic to compare search params explicitly. This is a temporary\n    // solution until more of the Segment Cache implementation has settled.\n    (0, _segment.addSearchParamsIfPageSegment)(tree.segment, Object.fromEntries(new URLSearchParams(routeCacheKey.search))) : tree.segment;\n    return {\n        flightRouterState: [\n            segment,\n            childRouterStates,\n            null,\n            null,\n            tree.isRootLayout\n        ],\n        seedData: [\n            segment,\n            rsc,\n            childSeedDatas,\n            loading,\n            isPartial\n        ]\n    };\n}\nasync function navigateDynamicallyWithNoPrefetch(now, url, nextUrl, isSamePageNavigation, currentCacheNode, currentFlightRouterState, shouldScroll, hash) {\n    // Runs when a navigation happens but there's no cached prefetch we can use.\n    // Don't bother to wait for a prefetch response; go straight to a full\n    // navigation that contains both static and dynamic data in a single stream.\n    // (This is unlike the old navigation implementation, which instead blocks\n    // the dynamic request until a prefetch request is received.)\n    //\n    // To avoid duplication of logic, we're going to pretend that the tree\n    // returned by the dynamic request is, in fact, a prefetch tree. Then we can\n    // use the same server response to write the actual data into the CacheNode\n    // tree. So it's the same flow as the \"happy path\" (prefetch, then\n    // navigation), except we use a single server response for both stages.\n    const promiseForDynamicServerResponse = (0, _fetchserverresponse.fetchServerResponse)(url, {\n        flightRouterState: currentFlightRouterState,\n        nextUrl\n    });\n    const { flightData, canonicalUrl: canonicalUrlOverride } = await promiseForDynamicServerResponse;\n    if (typeof flightData === 'string') {\n        // This is an MPA navigation.\n        const newUrl = flightData;\n        return {\n            tag: _segmentcache.NavigationResultTag.MPA,\n            data: newUrl\n        };\n    }\n    // Since the response format of dynamic requests and prefetches is slightly\n    // different, we'll need to massage the data a bit. Create FlightRouterState\n    // tree that simulates what we'd receive as the result of a prefetch.\n    const prefetchFlightRouterState = simulatePrefetchTreeUsingDynamicTreePatch(currentFlightRouterState, flightData);\n    // In our simulated prefetch payload, we pretend that there's no seed data\n    // nor a prefetch head.\n    const prefetchSeedData = null;\n    const prefetchHead = null;\n    const isPrefetchHeadPartial = true;\n    const canonicalUrl = (0, _createhreffromurl.createHrefFromUrl)(canonicalUrlOverride ? canonicalUrlOverride : url);\n    // Now we proceed exactly as we would for normal navigation.\n    const scrollableSegments = [];\n    const task = (0, _pprnavigations.startPPRNavigation)(now, currentCacheNode, currentFlightRouterState, prefetchFlightRouterState, prefetchSeedData, prefetchHead, isPrefetchHeadPartial, isSamePageNavigation, scrollableSegments);\n    if (task !== null) {\n        // In this case, we've already sent the dynamic request, so we don't\n        // actually use the request tree created by `startPPRNavigation`,\n        // except to check if it contains dynamic holes.\n        //\n        // This is almost always true, but it could be false if all the segment data\n        // was present in the cache, but the route tree was not. E.g. navigating\n        // to a URL that was not prefetched but rewrites to a different URL\n        // that was.\n        const hasDynamicHoles = task.dynamicRequestTree !== null;\n        if (hasDynamicHoles) {\n            (0, _pprnavigations.listenForDynamicRequest)(task, promiseForDynamicServerResponse);\n        } else {\n        // The prefetched tree does not contain dynamic holes — it's\n        // fully static. We don't need to process the server response further.\n        }\n        return navigationTaskToResult(task, currentCacheNode, canonicalUrl, scrollableSegments, shouldScroll, hash);\n    }\n    // The server sent back an empty tree patch. There's nothing to update, except\n    // possibly the URL.\n    return {\n        tag: _segmentcache.NavigationResultTag.NoOp,\n        data: {\n            canonicalUrl,\n            shouldScroll\n        }\n    };\n}\nfunction simulatePrefetchTreeUsingDynamicTreePatch(currentTree, flightData) {\n    // Takes the current FlightRouterState and applies the router state patch\n    // received from the server, to create a full FlightRouterState tree that we\n    // can pretend was returned by a prefetch.\n    //\n    // (It sounds similar to what applyRouterStatePatch does, but it doesn't need\n    // to handle stuff like interception routes or diffing since that will be\n    // handled later.)\n    let baseTree = currentTree;\n    for (const { segmentPath, tree: treePatch } of flightData){\n        // If the server sends us multiple tree patches, we only need to clone the\n        // base tree when applying the first patch. After the first patch, we can\n        // apply the remaining patches in place without copying.\n        const canMutateInPlace = baseTree !== currentTree;\n        baseTree = simulatePrefetchTreeUsingDynamicTreePatchImpl(baseTree, treePatch, segmentPath, canMutateInPlace, 0);\n    }\n    return baseTree;\n}\nfunction simulatePrefetchTreeUsingDynamicTreePatchImpl(baseRouterState, patch, segmentPath, canMutateInPlace, index) {\n    if (index === segmentPath.length) {\n        // We reached the part of the tree that we need to patch.\n        return patch;\n    }\n    // segmentPath represents the parent path of subtree. It's a repeating\n    // pattern of parallel route key and segment:\n    //\n    //   [string, Segment, string, Segment, string, Segment, ...]\n    //\n    // This path tells us which part of the base tree to apply the tree patch.\n    //\n    // NOTE: In the case of a fully dynamic request with no prefetch, we receive\n    // the FlightRouterState patch in the same request as the dynamic data.\n    // Therefore we don't need to worry about diffing the segment values; we can\n    // assume the server sent us a correct result.\n    const updatedParallelRouteKey = segmentPath[index];\n    // const segment: Segment = segmentPath[index + 1] <-- Not used, see note above\n    const baseChildren = baseRouterState[1];\n    const newChildren = {};\n    for(const parallelRouteKey in baseChildren){\n        if (parallelRouteKey === updatedParallelRouteKey) {\n            const childBaseRouterState = baseChildren[parallelRouteKey];\n            newChildren[parallelRouteKey] = simulatePrefetchTreeUsingDynamicTreePatchImpl(childBaseRouterState, patch, segmentPath, canMutateInPlace, // Advance the index by two and keep cloning until we reach\n            // the end of the segment path.\n            index + 2);\n        } else {\n            // This child is not being patched. Copy it over as-is.\n            newChildren[parallelRouteKey] = baseChildren[parallelRouteKey];\n        }\n    }\n    if (canMutateInPlace) {\n        // We can mutate the base tree in place, because the base tree is already\n        // a clone.\n        baseRouterState[1] = newChildren;\n        return baseRouterState;\n    }\n    // Clone all the fields except the children.\n    //\n    // Based on equivalent logic in apply-router-state-patch-to-tree, but should\n    // confirm whether we need to copy all of these fields. Not sure the server\n    // ever sends, e.g. the refetch marker.\n    const clone = [\n        baseRouterState[0],\n        newChildren\n    ];\n    if (2 in baseRouterState) {\n        clone[2] = baseRouterState[2];\n    }\n    if (3 in baseRouterState) {\n        clone[3] = baseRouterState[3];\n    }\n    if (4 in baseRouterState) {\n        clone[4] = baseRouterState[4];\n    }\n    return clone;\n}\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=navigation.js.map"
        }
    ]
}