{
    "sourceFile": "node_modules/next/dist/client/components/segment-cache-impl/scheduler.d.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892693059,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import type { FlightRouterState } from '../../../server/app-render/types';\nimport type { RouteCacheKey } from './cache-key';\nimport { PrefetchPriority } from '../segment-cache';\nexport type PrefetchTask = {\n    key: RouteCacheKey;\n    /**\n     * The FlightRouterState at the time the task was initiated. This is needed\n     * when falling back to the non-PPR behavior, which only prefetches up to\n     * the first loading boundary.\n     */\n    treeAtTimeOfPrefetch: FlightRouterState;\n    /**\n     * Whether to prefetch dynamic data, in addition to static data. This is\n     * used by <Link prefetch={true}>.\n     */\n    includeDynamicData: boolean;\n    /**\n     * sortId is an incrementing counter\n     *\n     * Newer prefetches are prioritized over older ones, so that as new links\n     * enter the viewport, they are not starved by older links that are no\n     * longer relevant. In the future, we can add additional prioritization\n     * heuristics, like removing prefetches once a link leaves the viewport.\n     *\n     * The sortId is assigned when the prefetch is initiated, and reassigned if\n     * the same task is prefetched again (effectively bumping it to the top of\n     * the queue).\n     *\n     * TODO: We can add additional fields here to indicate what kind of prefetch\n     * it is. For example, was it initiated by a link? Or was it an imperative\n     * call? If it was initiated by a link, we can remove it from the queue when\n     * the link leaves the viewport, but if it was an imperative call, then we\n     * should keep it in the queue until it's fulfilled.\n     *\n     * We can also add priority levels. For example, hovering over a link could\n     * increase the priority of its prefetch.\n     */\n    sortId: number;\n    /**\n     * The priority of the task. Like sortId, this affects the task's position in\n     * the queue, so it must never be updated without resifting the heap.\n     */\n    priority: PrefetchPriority;\n    /**\n     * The phase of the task. Tasks are split into multiple phases so that their\n     * priority can be adjusted based on what kind of work they're doing.\n     * Concretely, prefetching the route tree is higher priority than prefetching\n     * segment data.\n     */\n    phase: PrefetchPhase;\n    /**\n     * Temporary state for tracking the currently running task. This is currently\n     * used to track whether a task deferred some work to run background at\n     * priority, but we might need it for additional state in the future.\n     */\n    hasBackgroundWork: boolean;\n    /**\n     * True if the prefetch was cancelled.\n     */\n    isCanceled: boolean;\n    /**\n     * The index of the task in the heap's backing array. Used to efficiently\n     * change the priority of a task by re-sifting it, which requires knowing\n     * where it is in the array. This is only used internally by the heap\n     * algorithm. The naive alternative is indexOf every time a task is queued,\n     * which has O(n) complexity.\n     *\n     * We also use this field to check whether a task is currently in the queue.\n     */\n    _heapIndex: number;\n};\n/**\n * Prefetch tasks are processed in two phases: first the route tree is fetched,\n * then the segments. We use this to priortize tasks that have not yet fetched\n * the route tree.\n */\ndeclare const enum PrefetchPhase {\n    RouteTree = 1,\n    Segments = 0\n}\nexport type PrefetchSubtaskResult<T> = {\n    /**\n     * A promise that resolves when the network connection is closed.\n     */\n    closed: Promise<void>;\n    value: T;\n};\n/**\n * Initiates a prefetch task for the given URL. If a prefetch for the same URL\n * is already in progress, this will bump it to the top of the queue.\n *\n * This is not a user-facing function. By the time this is called, the href is\n * expected to be validated and normalized.\n *\n * @param key The RouteCacheKey to prefetch.\n * @param treeAtTimeOfPrefetch The app's current FlightRouterState\n * @param includeDynamicData Whether to prefetch dynamic data, in addition to\n * static data. This is used by <Link prefetch={true}>.\n */\nexport declare function schedulePrefetchTask(key: RouteCacheKey, treeAtTimeOfPrefetch: FlightRouterState, includeDynamicData: boolean, priority: PrefetchPriority): PrefetchTask;\nexport declare function cancelPrefetchTask(task: PrefetchTask): void;\nexport declare function reschedulePrefetchTask(task: PrefetchTask, treeAtTimeOfPrefetch: FlightRouterState, includeDynamicData: boolean, priority: PrefetchPriority): void;\n/**\n * Notify the scheduler that we've received new data for an in-progress\n * prefetch. The corresponding task will be added back to the queue (unless the\n * task has been canceled in the meantime).\n */\nexport declare function pingPrefetchTask(task: PrefetchTask): void;\nexport {};\n"
        }
    ]
}