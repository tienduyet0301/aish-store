{
    "sourceFile": "node_modules/next/dist/client/components/segment-cache-impl/cache.d.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892692744,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import type { HeadData, LoadingModuleData } from '../../../shared/lib/app-router-context.shared-runtime';\nimport type { Segment as FlightRouterStateSegment } from '../../../server/app-render/types';\nimport { type PrefetchTask, type PrefetchSubtaskResult } from './scheduler';\nimport type { NormalizedHref, NormalizedNextUrl, NormalizedSearch, RouteCacheKey } from './cache-key';\nimport { type Prefix } from './tuple-map';\nimport type { FlightRouterState } from '../../../server/app-render/types';\nexport type RouteTree = {\n    key: string;\n    segment: FlightRouterStateSegment;\n    slots: null | {\n        [parallelRouteKey: string]: RouteTree;\n    };\n    isRootLayout: boolean;\n};\ntype RouteCacheEntryShared = {\n    staleAt: number;\n    couldBeIntercepted: boolean;\n    keypath: null | Prefix<RouteCacheKeypath>;\n    next: null | RouteCacheEntry;\n    prev: null | RouteCacheEntry;\n    size: number;\n};\n/**\n * Tracks the status of a cache entry as it progresses from no data (Empty),\n * waiting for server data (Pending), and finished (either Fulfilled or\n * Rejected depending on the response from the server.\n */\nexport declare const enum EntryStatus {\n    Empty = 0,\n    Pending = 1,\n    Fulfilled = 2,\n    Rejected = 3\n}\ntype PendingRouteCacheEntry = RouteCacheEntryShared & {\n    status: EntryStatus.Empty | EntryStatus.Pending;\n    blockedTasks: Set<PrefetchTask> | null;\n    canonicalUrl: null;\n    tree: null;\n    head: HeadData | null;\n    isHeadPartial: true;\n    isPPREnabled: false;\n};\ntype RejectedRouteCacheEntry = RouteCacheEntryShared & {\n    status: EntryStatus.Rejected;\n    blockedTasks: Set<PrefetchTask> | null;\n    canonicalUrl: null;\n    tree: null;\n    head: null;\n    isHeadPartial: true;\n    isPPREnabled: boolean;\n};\nexport type FulfilledRouteCacheEntry = RouteCacheEntryShared & {\n    status: EntryStatus.Fulfilled;\n    blockedTasks: null;\n    canonicalUrl: string;\n    tree: RouteTree;\n    head: HeadData;\n    isHeadPartial: boolean;\n    isPPREnabled: boolean;\n};\nexport type RouteCacheEntry = PendingRouteCacheEntry | FulfilledRouteCacheEntry | RejectedRouteCacheEntry;\nexport declare const enum FetchStrategy {\n    PPR = 0,\n    Full = 1,\n    LoadingBoundary = 2\n}\ntype SegmentCacheEntryShared = {\n    staleAt: number;\n    fetchStrategy: FetchStrategy;\n    revalidating: SegmentCacheEntry | null;\n    keypath: null | Prefix<SegmentCacheKeypath>;\n    next: null | SegmentCacheEntry;\n    prev: null | SegmentCacheEntry;\n    size: number;\n};\nexport type EmptySegmentCacheEntry = SegmentCacheEntryShared & {\n    status: EntryStatus.Empty;\n    rsc: null;\n    loading: null;\n    isPartial: true;\n    promise: null;\n};\nexport type PendingSegmentCacheEntry = SegmentCacheEntryShared & {\n    status: EntryStatus.Pending;\n    rsc: null;\n    loading: null;\n    isPartial: true;\n    promise: null | PromiseWithResolvers<FulfilledSegmentCacheEntry | null>;\n};\ntype RejectedSegmentCacheEntry = SegmentCacheEntryShared & {\n    status: EntryStatus.Rejected;\n    rsc: null;\n    loading: null;\n    isPartial: true;\n    promise: null;\n};\nexport type FulfilledSegmentCacheEntry = SegmentCacheEntryShared & {\n    status: EntryStatus.Fulfilled;\n    rsc: React.ReactNode | null;\n    loading: LoadingModuleData | Promise<LoadingModuleData>;\n    isPartial: boolean;\n    promise: null;\n};\nexport type SegmentCacheEntry = EmptySegmentCacheEntry | PendingSegmentCacheEntry | RejectedSegmentCacheEntry | FulfilledSegmentCacheEntry;\nexport type NonEmptySegmentCacheEntry = Exclude<SegmentCacheEntry, EmptySegmentCacheEntry>;\ntype RouteCacheKeypath = [NormalizedHref, NormalizedNextUrl];\ntype SegmentCacheKeypath = [string, NormalizedSearch];\nexport declare function getCurrentCacheVersion(): number;\n/**\n * Used to clear the client prefetch cache when a server action calls\n * revalidatePath or revalidateTag. Eventually we will support only clearing the\n * segments that were actually affected, but there's more work to be done on the\n * server before the client is able to do this correctly.\n */\nexport declare function revalidateEntireCache(nextUrl: string | null, tree: FlightRouterState): void;\nexport declare function readExactRouteCacheEntry(now: number, href: NormalizedHref, nextUrl: NormalizedNextUrl | null): RouteCacheEntry | null;\nexport declare function readRouteCacheEntry(now: number, key: RouteCacheKey): RouteCacheEntry | null;\nexport declare function getSegmentKeypathForTask(task: PrefetchTask, route: FulfilledRouteCacheEntry, path: string): Prefix<SegmentCacheKeypath>;\nexport declare function readSegmentCacheEntry(now: number, routeCacheKey: RouteCacheKey, path: string): SegmentCacheEntry | null;\nexport declare function waitForSegmentCacheEntry(pendingEntry: PendingSegmentCacheEntry): Promise<FulfilledSegmentCacheEntry | null>;\n/**\n * Checks if an entry for a route exists in the cache. If so, it returns the\n * entry, If not, it adds an empty entry to the cache and returns it.\n */\nexport declare function readOrCreateRouteCacheEntry(now: number, task: PrefetchTask): RouteCacheEntry;\n/**\n * Checks if an entry for a segment exists in the cache. If so, it returns the\n * entry, If not, it adds an empty entry to the cache and returns it.\n */\nexport declare function readOrCreateSegmentCacheEntry(now: number, task: PrefetchTask, route: FulfilledRouteCacheEntry, path: string): SegmentCacheEntry;\nexport declare function readOrCreateRevalidatingSegmentEntry(now: number, prevEntry: SegmentCacheEntry): SegmentCacheEntry;\nexport declare function upsertSegmentEntry(now: number, keypath: Prefix<SegmentCacheKeypath>, candidateEntry: SegmentCacheEntry): SegmentCacheEntry | null;\nexport declare function createDetachedSegmentCacheEntry(staleAt: number): EmptySegmentCacheEntry;\nexport declare function upgradeToPendingSegment(emptyEntry: EmptySegmentCacheEntry, fetchStrategy: FetchStrategy): PendingSegmentCacheEntry;\nexport declare function resetRevalidatingSegmentEntry(owner: SegmentCacheEntry): EmptySegmentCacheEntry;\nexport declare function convertRouteTreeToFlightRouterState(routeTree: RouteTree): FlightRouterState;\nexport declare function fetchRouteOnCacheMiss(entry: PendingRouteCacheEntry, task: PrefetchTask): Promise<PrefetchSubtaskResult<null> | null>;\nexport declare function fetchSegmentOnCacheMiss(route: FulfilledRouteCacheEntry, segmentCacheEntry: PendingSegmentCacheEntry, routeKey: RouteCacheKey, segmentPath: string): Promise<PrefetchSubtaskResult<FulfilledSegmentCacheEntry> | null>;\nexport declare function fetchSegmentPrefetchesUsingDynamicRequest(task: PrefetchTask, route: FulfilledRouteCacheEntry, fetchStrategy: FetchStrategy, dynamicRequestTree: FlightRouterState, spawnedEntries: Map<string, PendingSegmentCacheEntry>): Promise<PrefetchSubtaskResult<null> | null>;\nexport {};\n"
        }
    ]
}