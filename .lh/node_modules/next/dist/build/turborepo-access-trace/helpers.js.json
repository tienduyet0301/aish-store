{
    "sourceFile": "node_modules/next/dist/build/turborepo-access-trace/helpers.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892663013,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    turborepoTraceAccess: null,\n    writeTurborepoAccessTraceResult: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    turborepoTraceAccess: function() {\n        return turborepoTraceAccess;\n    },\n    writeTurborepoAccessTraceResult: function() {\n        return writeTurborepoAccessTraceResult;\n    }\n});\nconst _promises = /*#__PURE__*/ _interop_require_default(require(\"fs/promises\"));\nconst _path = /*#__PURE__*/ _interop_require_default(require(\"path\"));\nconst _env = require(\"./env\");\nconst _tcp = require(\"./tcp\");\nconst _result = require(\"./result\");\nfunction _interop_require_default(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nfunction turborepoTraceAccess(f, parent) {\n    // If the trace file is not set, don't trace and instead just call the\n    // function.\n    if (!process.env.TURBOREPO_TRACE_FILE) return f();\n    // Otherwise, trace the function and merge the results into the parent. Using\n    // `then` instead of `await` here to avoid creating a new async context when\n    // tracing is disabled.\n    return withTurborepoTraceAccess(f).then(([result, proxy])=>{\n        parent.merge(proxy);\n        // Return the result of the function.\n        return result;\n    });\n}\nasync function writeTurborepoAccessTraceResult({ distDir, traces }) {\n    const configTraceFile = process.env.TURBOREPO_TRACE_FILE;\n    if (!configTraceFile || traces.length === 0) return;\n    // merge traces\n    const [accessTrace, ...otherTraces] = traces;\n    for (const trace of otherTraces){\n        accessTrace.merge(trace);\n    }\n    try {\n        // make sure the directory exists\n        await _promises.default.mkdir(_path.default.dirname(configTraceFile), {\n            recursive: true\n        });\n        await _promises.default.writeFile(configTraceFile, JSON.stringify({\n            outputs: [\n                `${distDir}/**`,\n                `!${distDir}/cache/**`\n            ],\n            accessed: accessTrace.toPublicTrace()\n        }));\n    } catch (err) {\n        // if we can't write this file, we should bail out here to avoid\n        // the possibility of incorrect turborepo cache hits.\n        throw Object.defineProperty(new Error(`Failed to write turborepo access trace file`, {\n            cause: err\n        }), \"__NEXT_ERROR_CODE\", {\n            value: \"E342\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n}\nasync function withTurborepoTraceAccess(f) {\n    const envVars = new Set([]);\n    // addresses is an array of objects, so a set is useless\n    const addresses = [];\n    // TODO: watch fsPaths (removed from this implementation for now)\n    const fsPaths = new Set();\n    // setup proxies\n    const restoreTCP = (0, _tcp.tcpProxy)(addresses);\n    const restoreEnv = (0, _env.envProxy)(envVars);\n    let functionResult;\n    // NOTE: we intentionally don't catch errors here so the calling function can handle them\n    try {\n        // call the wrapped function\n        functionResult = await f();\n    } finally{\n        // remove proxies\n        restoreTCP();\n        restoreEnv();\n    }\n    const traceResult = new _result.TurborepoAccessTraceResult(envVars, addresses, fsPaths);\n    return [\n        functionResult,\n        traceResult\n    ];\n}\n\n//# sourceMappingURL=helpers.js.map"
        }
    ]
}