{
    "sourceFile": "node_modules/next/dist/build/index.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892655926,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    createStaticWorker: null,\n    default: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    createStaticWorker: function() {\n        return createStaticWorker;\n    },\n    default: function() {\n        return build;\n    }\n});\nrequire(\"../lib/setup-exception-listeners\");\nconst _env = require(\"@next/env\");\nconst _picocolors = require(\"../lib/picocolors\");\nconst _crypto = /*#__PURE__*/ _interop_require_default(require(\"crypto\"));\nconst _picomatch = require(\"next/dist/compiled/picomatch\");\nconst _fs = require(\"fs\");\nconst _os = /*#__PURE__*/ _interop_require_default(require(\"os\"));\nconst _worker = require(\"../lib/worker\");\nconst _configshared = require(\"../server/config-shared\");\nconst _devalue = /*#__PURE__*/ _interop_require_default(require(\"next/dist/compiled/devalue\"));\nconst _findup = /*#__PURE__*/ _interop_require_default(require(\"next/dist/compiled/find-up\"));\nconst _indexcjs = require(\"next/dist/compiled/nanoid/index.cjs\");\nconst _path = /*#__PURE__*/ _interop_require_default(require(\"path\"));\nconst _constants = require(\"../lib/constants\");\nconst _fileexists = require(\"../lib/file-exists\");\nconst _findpagesdir = require(\"../lib/find-pages-dir\");\nconst _loadcustomroutes = /*#__PURE__*/ _interop_require_wildcard(require(\"../lib/load-custom-routes\"));\nconst _nonnullable = require(\"../lib/non-nullable\");\nconst _recursivedelete = require(\"../lib/recursive-delete\");\nconst _verifypartytownsetup = require(\"../lib/verify-partytown-setup\");\nconst _constants1 = require(\"../shared/lib/constants\");\nconst _utils = require(\"../shared/lib/router/utils\");\nconst _config = /*#__PURE__*/ _interop_require_default(require(\"../server/config\"));\nconst _normalizepagepath = require(\"../shared/lib/page-path/normalize-page-path\");\nconst _require = require(\"../server/require\");\nconst _ciinfo = /*#__PURE__*/ _interop_require_wildcard(require(\"../server/ci-info\"));\nconst _turborepoaccesstrace = require(\"./turborepo-access-trace\");\nconst _events = require(\"../telemetry/events\");\nconst _storage = require(\"../telemetry/storage\");\nconst _getpagestaticinfo = require(\"./analysis/get-page-static-info\");\nconst _entries = require(\"./entries\");\nconst _pagetypes = require(\"../lib/page-types\");\nconst _generatebuildid = require(\"./generate-build-id\");\nconst _iswriteable = require(\"./is-writeable\");\nconst _log = /*#__PURE__*/ _interop_require_wildcard(require(\"./output/log\"));\nconst _spinner = /*#__PURE__*/ _interop_require_default(require(\"./spinner\"));\nconst _trace = require(\"../trace\");\nconst _utils1 = require(\"./utils\");\nconst _writebuildid = require(\"./write-build-id\");\nconst _normalizelocalepath = require(\"../shared/lib/i18n/normalize-locale-path\");\nconst _iserror = /*#__PURE__*/ _interop_require_default(require(\"../lib/is-error\"));\nconst _isedgeruntime = require(\"../lib/is-edge-runtime\");\nconst _recursivecopy = require(\"../lib/recursive-copy\");\nconst _recursivereaddir = require(\"../lib/recursive-readdir\");\nconst _swc = require(\"./swc\");\nconst _routeregex = require(\"../shared/lib/router/utils/route-regex\");\nconst _getfilesindir = require(\"../lib/get-files-in-dir\");\nconst _swcplugins = require(\"../telemetry/events/swc-plugins\");\nconst _apppaths = require(\"../shared/lib/router/utils/app-paths\");\nconst _approuterheaders = require(\"../client/components/app-router-headers\");\nconst _webpackbuild = require(\"./webpack-build\");\nconst _buildcontext = require(\"./build-context\");\nconst _normalizepathsep = require(\"../shared/lib/page-path/normalize-path-sep\");\nconst _isapprouteroute = require(\"../lib/is-app-route-route\");\nconst _createclientrouterfilter = require(\"../lib/create-client-router-filter\");\nconst _findpagefile = require(\"../server/lib/find-page-file\");\nconst _typecheck = require(\"./type-check\");\nconst _generateinterceptionroutesrewrites = require(\"../lib/generate-interception-routes-rewrites\");\nconst _builddataroute = require(\"../server/lib/router-utils/build-data-route\");\nconst _collectbuildtraces = require(\"./collect-build-traces\");\nconst _formatmanifest = require(\"./manifests/formatter/format-manifest\");\nconst _builddiagnostics = require(\"../diagnostics/build-diagnostics\");\nconst _appinfolog = require(\"../server/lib/app-info-log\");\nconst _utils2 = require(\"../export/utils\");\nconst _buildcustomroute = require(\"../lib/build-custom-route\");\nconst _trace1 = require(\"../lib/memory/trace\");\nconst _encryptionutilsserver = require(\"../server/app-render/encryption-utils-server\");\nconst _uploadtrace = /*#__PURE__*/ _interop_require_default(require(\"../trace/upload-trace\"));\nconst _ppr = require(\"../server/lib/experimental/ppr\");\nconst _fallback = require(\"../lib/fallback\");\nconst _renderingmode = require(\"./rendering-mode\");\nconst _fallbackparams = require(\"../server/request/fallback-params\");\nconst _utils3 = require(\"../server/lib/utils\");\nconst _invarianterror = require(\"../shared/lib/invariant-error\");\nconst _isbot = require(\"../shared/lib/router/utils/is-bot\");\nconst _buildprefetchsegmentdataroute = require(\"../server/lib/router-utils/build-prefetch-segment-data-route\");\nconst _turbopackbuild = require(\"./turbopack-build\");\nconst _utils4 = require(\"../shared/lib/turbopack/utils\");\nconst _inlinestaticenv = require(\"../lib/inline-static-env\");\nconst _staticenv = require(\"../lib/static-env\");\nconst _durationtostring = require(\"./duration-to-string\");\nconst _shared = require(\"../trace/shared\");\nconst _errortelemetryutils = require(\"../lib/error-telemetry-utils\");\nfunction _interop_require_default(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nfunction _getRequireWildcardCache(nodeInterop) {\n    if (typeof WeakMap !== \"function\") return null;\n    var cacheBabelInterop = new WeakMap();\n    var cacheNodeInterop = new WeakMap();\n    return (_getRequireWildcardCache = function(nodeInterop) {\n        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n    })(nodeInterop);\n}\nfunction _interop_require_wildcard(obj, nodeInterop) {\n    if (!nodeInterop && obj && obj.__esModule) {\n        return obj;\n    }\n    if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n        return {\n            default: obj\n        };\n    }\n    var cache = _getRequireWildcardCache(nodeInterop);\n    if (cache && cache.has(obj)) {\n        return cache.get(obj);\n    }\n    var newObj = {\n        __proto__: null\n    };\n    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n    for(var key in obj){\n        if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n            if (desc && (desc.get || desc.set)) {\n                Object.defineProperty(newObj, key, desc);\n            } else {\n                newObj[key] = obj[key];\n            }\n        }\n    }\n    newObj.default = obj;\n    if (cache) {\n        cache.set(obj, newObj);\n    }\n    return newObj;\n}\n/**\n * The headers that are allowed to be used when revalidating routes. Currently\n * this includes both headers used by the pages and app routers.\n */ const ALLOWED_HEADERS = [\n    'host',\n    _constants.MATCHED_PATH_HEADER,\n    _constants.PRERENDER_REVALIDATE_HEADER,\n    _constants.PRERENDER_REVALIDATE_ONLY_GENERATED_HEADER,\n    _constants.NEXT_CACHE_REVALIDATED_TAGS_HEADER,\n    _constants.NEXT_CACHE_REVALIDATE_TAG_TOKEN_HEADER\n];\nfunction pageToRoute(page) {\n    const routeRegex = (0, _routeregex.getNamedRouteRegex)(page, {\n        prefixRouteKeys: true\n    });\n    return {\n        page,\n        regex: (0, _loadcustomroutes.normalizeRouteRegex)(routeRegex.re.source),\n        routeKeys: routeRegex.routeKeys,\n        namedRegex: routeRegex.namedRegex\n    };\n}\nfunction getCacheDir(distDir) {\n    const cacheDir = _path.default.join(distDir, 'cache');\n    if (_ciinfo.isCI && !_ciinfo.hasNextSupport) {\n        const hasCache = (0, _fs.existsSync)(cacheDir);\n        if (!hasCache) {\n            // Intentionally not piping to stderr which is what `Log.warn` does in case people fail in CI when\n            // stderr is detected.\n            console.log(`${_log.prefixes.warn} No build cache found. Please configure build caching for faster rebuilds. Read more: https://nextjs.org/docs/messages/no-cache`);\n        }\n    }\n    return cacheDir;\n}\nasync function writeFileUtf8(filePath, content) {\n    await _fs.promises.writeFile(filePath, content, 'utf-8');\n}\nfunction readFileUtf8(filePath) {\n    return _fs.promises.readFile(filePath, 'utf8');\n}\nasync function writeManifest(filePath, manifest) {\n    await writeFileUtf8(filePath, (0, _formatmanifest.formatManifest)(manifest));\n}\nasync function readManifest(filePath) {\n    return JSON.parse(await readFileUtf8(filePath));\n}\nasync function writePrerenderManifest(distDir, manifest) {\n    await writeManifest(_path.default.join(distDir, _constants1.PRERENDER_MANIFEST), manifest);\n}\nasync function writeClientSsgManifest(prerenderManifest, { buildId, distDir, locales }) {\n    const ssgPages = new Set([\n        ...Object.entries(prerenderManifest.routes)// Filter out dynamic routes\n        .filter(([, { srcRoute }])=>srcRoute == null).map(([route])=>(0, _normalizelocalepath.normalizeLocalePath)(route, locales).pathname),\n        ...Object.keys(prerenderManifest.dynamicRoutes)\n    ].sort());\n    const clientSsgManifestContent = `self.__SSG_MANIFEST=${(0, _devalue.default)(ssgPages)};self.__SSG_MANIFEST_CB&&self.__SSG_MANIFEST_CB()`;\n    await writeFileUtf8(_path.default.join(distDir, _constants1.CLIENT_STATIC_FILES_PATH, buildId, '_ssgManifest.js'), clientSsgManifestContent);\n}\nasync function writeFunctionsConfigManifest(distDir, manifest) {\n    await writeManifest(_path.default.join(distDir, _constants1.SERVER_DIRECTORY, _constants1.FUNCTIONS_CONFIG_MANIFEST), manifest);\n}\nasync function writeRequiredServerFilesManifest(distDir, requiredServerFiles) {\n    await writeManifest(_path.default.join(distDir, _constants1.SERVER_FILES_MANIFEST), requiredServerFiles);\n}\nasync function writeImagesManifest(distDir, config) {\n    var _config_images, _config_images1;\n    const images = {\n        ...config.images\n    };\n    const { deviceSizes, imageSizes } = images;\n    images.sizes = [\n        ...deviceSizes,\n        ...imageSizes\n    ];\n    // By default, remotePatterns will allow no remote images ([])\n    images.remotePatterns = ((config == null ? void 0 : (_config_images = config.images) == null ? void 0 : _config_images.remotePatterns) || []).map((p)=>{\n        var _p_protocol;\n        return {\n            // Modifying the manifest should also modify matchRemotePattern()\n            protocol: (_p_protocol = p.protocol) == null ? void 0 : _p_protocol.replace(/:$/, ''),\n            hostname: (0, _picomatch.makeRe)(p.hostname).source,\n            port: p.port,\n            pathname: (0, _picomatch.makeRe)(p.pathname ?? '**', {\n                dot: true\n            }).source,\n            search: p.search\n        };\n    });\n    // By default, localPatterns will allow all local images (undefined)\n    if (config == null ? void 0 : (_config_images1 = config.images) == null ? void 0 : _config_images1.localPatterns) {\n        images.localPatterns = config.images.localPatterns.map((p)=>({\n                // Modifying the manifest should also modify matchLocalPattern()\n                pathname: (0, _picomatch.makeRe)(p.pathname ?? '**', {\n                    dot: true\n                }).source,\n                search: p.search\n            }));\n    }\n    await writeManifest(_path.default.join(distDir, _constants1.IMAGES_MANIFEST), {\n        version: 1,\n        images\n    });\n}\nconst STANDALONE_DIRECTORY = 'standalone';\nasync function writeStandaloneDirectory(nextBuildSpan, distDir, pageKeys, denormalizedAppPages, outputFileTracingRoot, requiredServerFiles, middlewareManifest, hasNodeMiddleware, hasInstrumentationHook, staticPages, loadedEnvFiles, appDir) {\n    await nextBuildSpan.traceChild('write-standalone-directory').traceAsyncFn(async ()=>{\n        await (0, _utils1.copyTracedFiles)(// requiredServerFiles.appDir Refers to the application directory, not App Router.\n        requiredServerFiles.appDir, distDir, pageKeys.pages, denormalizedAppPages, outputFileTracingRoot, requiredServerFiles.config, middlewareManifest, hasNodeMiddleware, hasInstrumentationHook, staticPages);\n        for (const file of [\n            ...requiredServerFiles.files,\n            _path.default.join(requiredServerFiles.config.distDir, _constants1.SERVER_FILES_MANIFEST),\n            ...loadedEnvFiles.reduce((acc, envFile)=>{\n                if ([\n                    '.env',\n                    '.env.production'\n                ].includes(envFile.path)) {\n                    acc.push(envFile.path);\n                }\n                return acc;\n            }, [])\n        ]){\n            // requiredServerFiles.appDir Refers to the application directory, not App Router.\n            const filePath = _path.default.join(requiredServerFiles.appDir, file);\n            const outputPath = _path.default.join(distDir, STANDALONE_DIRECTORY, _path.default.relative(outputFileTracingRoot, filePath));\n            await _fs.promises.mkdir(_path.default.dirname(outputPath), {\n                recursive: true\n            });\n            await _fs.promises.copyFile(filePath, outputPath);\n        }\n        if (hasNodeMiddleware) {\n            const middlewareOutput = _path.default.join(distDir, STANDALONE_DIRECTORY, _path.default.relative(outputFileTracingRoot, distDir), _constants1.SERVER_DIRECTORY, 'middleware.js');\n            await _fs.promises.mkdir(_path.default.dirname(middlewareOutput), {\n                recursive: true\n            });\n            await _fs.promises.copyFile(_path.default.join(distDir, _constants1.SERVER_DIRECTORY, 'middleware.js'), middlewareOutput);\n        }\n        await (0, _recursivecopy.recursiveCopy)(_path.default.join(distDir, _constants1.SERVER_DIRECTORY, 'pages'), _path.default.join(distDir, STANDALONE_DIRECTORY, _path.default.relative(outputFileTracingRoot, distDir), _constants1.SERVER_DIRECTORY, 'pages'), {\n            overwrite: true\n        });\n        if (appDir) {\n            const originalServerApp = _path.default.join(distDir, _constants1.SERVER_DIRECTORY, 'app');\n            if ((0, _fs.existsSync)(originalServerApp)) {\n                await (0, _recursivecopy.recursiveCopy)(originalServerApp, _path.default.join(distDir, STANDALONE_DIRECTORY, _path.default.relative(outputFileTracingRoot, distDir), _constants1.SERVER_DIRECTORY, 'app'), {\n                    overwrite: true\n                });\n            }\n        }\n    });\n}\nfunction getNumberOfWorkers(config) {\n    if (config.experimental.cpus && config.experimental.cpus !== _configshared.defaultConfig.experimental.cpus) {\n        return config.experimental.cpus;\n    }\n    if (config.experimental.memoryBasedWorkersCount) {\n        return Math.max(Math.min(config.experimental.cpus || 1, Math.floor(_os.default.freemem() / 1e9)), // enforce a minimum of 4 workers\n        4);\n    }\n    if (config.experimental.cpus) {\n        return config.experimental.cpus;\n    }\n    // Fall back to 4 workers if a count is not specified\n    return 4;\n}\nconst staticWorkerPath = require.resolve('./worker');\nconst staticWorkerExposedMethods = [\n    'hasCustomGetInitialProps',\n    'isPageStatic',\n    'getDefinedNamedExports',\n    'exportPages'\n];\nfunction createStaticWorker(config, progress) {\n    // Get the node options without inspect and also remove the\n    // --max-old-space-size flag as it can cause memory issues.\n    const nodeOptions = (0, _utils3.getParsedNodeOptionsWithoutInspect)();\n    delete nodeOptions['max-old-space-size'];\n    delete nodeOptions['max_old_space_size'];\n    return new _worker.Worker(staticWorkerPath, {\n        logger: _log,\n        numWorkers: getNumberOfWorkers(config),\n        onActivity: ()=>{\n            progress == null ? void 0 : progress.run();\n        },\n        onActivityAbort: ()=>{\n            progress == null ? void 0 : progress.clear();\n        },\n        forkOptions: {\n            env: {\n                ...process.env,\n                NODE_OPTIONS: (0, _utils3.formatNodeOptions)(nodeOptions)\n            }\n        },\n        enableWorkerThreads: config.experimental.workerThreads,\n        exposedMethods: staticWorkerExposedMethods\n    });\n}\nasync function writeFullyStaticExport(config, dir, enabledDirectories, configOutDir, nextBuildSpan) {\n    const exportApp = require('../export').default;\n    const pagesWorker = createStaticWorker(config);\n    const appWorker = createStaticWorker(config);\n    await exportApp(dir, {\n        buildExport: false,\n        nextConfig: config,\n        enabledDirectories,\n        silent: true,\n        outdir: _path.default.join(dir, configOutDir),\n        numWorkers: getNumberOfWorkers(config)\n    }, nextBuildSpan);\n    pagesWorker.end();\n    appWorker.end();\n}\nasync function getBuildId(isGenerateMode, distDir, nextBuildSpan, config) {\n    if (isGenerateMode) {\n        return await _fs.promises.readFile(_path.default.join(distDir, 'BUILD_ID'), 'utf8');\n    }\n    return await nextBuildSpan.traceChild('generate-buildid').traceAsyncFn(()=>(0, _generatebuildid.generateBuildId)(config.generateBuildId, _indexcjs.nanoid));\n}\nasync function build(dir, reactProductionProfiling = false, debugOutput = false, runLint = true, noMangling = false, appDirOnly = false, isTurbopack = false, experimentalBuildMode, traceUploadUrl) {\n    const isCompileMode = experimentalBuildMode === 'compile';\n    const isGenerateMode = experimentalBuildMode === 'generate';\n    _buildcontext.NextBuildContext.isCompileMode = isCompileMode;\n    const buildStartTime = Date.now();\n    let loadedConfig;\n    try {\n        const nextBuildSpan = (0, _trace.trace)('next-build', undefined, {\n            buildMode: experimentalBuildMode,\n            isTurboBuild: String(isTurbopack),\n            version: \"15.3.1\"\n        });\n        _buildcontext.NextBuildContext.nextBuildSpan = nextBuildSpan;\n        _buildcontext.NextBuildContext.dir = dir;\n        _buildcontext.NextBuildContext.appDirOnly = appDirOnly;\n        _buildcontext.NextBuildContext.reactProductionProfiling = reactProductionProfiling;\n        _buildcontext.NextBuildContext.noMangling = noMangling;\n        await nextBuildSpan.traceAsyncFn(async ()=>{\n            var _mappedPages_404;\n            // attempt to load global env values so they are available in next.config.js\n            const { loadedEnvFiles } = nextBuildSpan.traceChild('load-dotenv').traceFn(()=>(0, _env.loadEnvConfig)(dir, false, _log));\n            _buildcontext.NextBuildContext.loadedEnvFiles = loadedEnvFiles;\n            const turborepoAccessTraceResult = new _turborepoaccesstrace.TurborepoAccessTraceResult();\n            const config = await nextBuildSpan.traceChild('load-next-config').traceAsyncFn(()=>(0, _turborepoaccesstrace.turborepoTraceAccess)(()=>(0, _config.default)(_constants1.PHASE_PRODUCTION_BUILD, dir, {\n                        // Log for next.config loading process\n                        silent: false,\n                        reactProductionProfiling\n                    }), turborepoAccessTraceResult));\n            loadedConfig = config;\n            process.env.NEXT_DEPLOYMENT_ID = config.deploymentId || '';\n            _buildcontext.NextBuildContext.config = config;\n            let configOutDir = 'out';\n            if ((0, _utils2.hasCustomExportOutput)(config)) {\n                configOutDir = config.distDir;\n                config.distDir = '.next';\n            }\n            const distDir = _path.default.join(dir, config.distDir);\n            _buildcontext.NextBuildContext.distDir = distDir;\n            (0, _trace.setGlobal)('phase', _constants1.PHASE_PRODUCTION_BUILD);\n            (0, _trace.setGlobal)('distDir', distDir);\n            const buildId = await getBuildId(isGenerateMode, distDir, nextBuildSpan, config);\n            _buildcontext.NextBuildContext.buildId = buildId;\n            if (experimentalBuildMode === 'generate-env') {\n                if (isTurbopack) {\n                    _log.warn('generate-env is not needed with turbopack');\n                    process.exit(0);\n                }\n                _log.info('Inlining static env ...');\n                await nextBuildSpan.traceChild('inline-static-env').traceAsyncFn(async ()=>{\n                    await (0, _inlinestaticenv.inlineStaticEnv)({\n                        distDir,\n                        config\n                    });\n                });\n                _log.info('Complete');\n                await (0, _trace.flushAllTraces)();\n                (0, _swc.teardownTraceSubscriber)();\n                process.exit(0);\n            }\n            // when using compile mode static env isn't inlined so we\n            // need to populate in normal runtime env\n            if (isCompileMode || isGenerateMode) {\n                (0, _staticenv.populateStaticEnv)(config);\n            }\n            const customRoutes = await nextBuildSpan.traceChild('load-custom-routes').traceAsyncFn(()=>(0, _loadcustomroutes.default)(config));\n            const { headers, rewrites, redirects } = customRoutes;\n            const combinedRewrites = [\n                ...rewrites.beforeFiles,\n                ...rewrites.afterFiles,\n                ...rewrites.fallback\n            ];\n            const hasRewrites = combinedRewrites.length > 0;\n            _buildcontext.NextBuildContext.hasRewrites = hasRewrites;\n            _buildcontext.NextBuildContext.originalRewrites = config._originalRewrites;\n            _buildcontext.NextBuildContext.originalRedirects = config._originalRedirects;\n            const cacheDir = getCacheDir(distDir);\n            const telemetry = new _storage.Telemetry({\n                distDir\n            });\n            (0, _trace.setGlobal)('telemetry', telemetry);\n            const publicDir = _path.default.join(dir, 'public');\n            const { pagesDir, appDir } = (0, _findpagesdir.findPagesDir)(dir);\n            _buildcontext.NextBuildContext.pagesDir = pagesDir;\n            _buildcontext.NextBuildContext.appDir = appDir;\n            const enabledDirectories = {\n                app: typeof appDir === 'string',\n                pages: typeof pagesDir === 'string'\n            };\n            // Generate a random encryption key for this build.\n            // This key is used to encrypt cross boundary values and can be used to generate hashes.\n            const encryptionKey = await (0, _encryptionutilsserver.generateEncryptionKeyBase64)({\n                isBuild: true,\n                distDir\n            });\n            _buildcontext.NextBuildContext.encryptionKey = encryptionKey;\n            const isSrcDir = _path.default.relative(dir, pagesDir || appDir || '').startsWith('src');\n            const hasPublicDir = (0, _fs.existsSync)(publicDir);\n            telemetry.record((0, _events.eventCliSession)(dir, config, {\n                webpackVersion: 5,\n                cliCommand: 'build',\n                isSrcDir,\n                hasNowJson: !!await (0, _findup.default)('now.json', {\n                    cwd: dir\n                }),\n                isCustomServer: null,\n                turboFlag: false,\n                pagesDir: !!pagesDir,\n                appDir: !!appDir\n            }));\n            (0, _events.eventNextPlugins)(_path.default.resolve(dir)).then((events)=>telemetry.record(events));\n            (0, _swcplugins.eventSwcPlugins)(_path.default.resolve(dir), config).then((events)=>telemetry.record(events));\n            // Always log next version first then start rest jobs\n            const { envInfo, experimentalFeatures } = await (0, _appinfolog.getStartServerInfo)(dir, false);\n            (0, _appinfolog.logStartInfo)({\n                networkUrl: null,\n                appUrl: null,\n                envInfo,\n                experimentalFeatures\n            });\n            const ignoreESLint = Boolean(config.eslint.ignoreDuringBuilds);\n            const shouldLint = !ignoreESLint && runLint;\n            const typeCheckingOptions = {\n                dir,\n                appDir,\n                pagesDir,\n                runLint,\n                shouldLint,\n                ignoreESLint,\n                telemetry,\n                nextBuildSpan,\n                config,\n                cacheDir\n            };\n            const distDirCreated = await nextBuildSpan.traceChild('create-dist-dir').traceAsyncFn(async ()=>{\n                try {\n                    await _fs.promises.mkdir(distDir, {\n                        recursive: true\n                    });\n                    return true;\n                } catch (err) {\n                    if ((0, _iserror.default)(err) && err.code === 'EPERM') {\n                        return false;\n                    }\n                    throw err;\n                }\n            });\n            if (!distDirCreated || !await (0, _iswriteable.isWriteable)(distDir)) {\n                throw Object.defineProperty(new Error('> Build directory is not writeable. https://nextjs.org/docs/messages/build-dir-not-writeable'), \"__NEXT_ERROR_CODE\", {\n                    value: \"E202\",\n                    enumerable: false,\n                    configurable: true\n                });\n            }\n            if (config.cleanDistDir && !isGenerateMode) {\n                await (0, _recursivedelete.recursiveDelete)(distDir, /^cache/);\n            }\n            // For app directory, we run type checking after build. That's because\n            // we dynamically generate types for each layout and page in the app\n            // directory.\n            if (!appDir && !isCompileMode) await (0, _typecheck.startTypeChecking)(typeCheckingOptions);\n            if (appDir && 'exportPathMap' in config) {\n                _log.error('The \"exportPathMap\" configuration cannot be used with the \"app\" directory. Please use generateStaticParams() instead.');\n                await telemetry.flush();\n                process.exit(1);\n            }\n            const buildLintEvent = {\n                featureName: 'build-lint',\n                invocationCount: shouldLint ? 1 : 0\n            };\n            telemetry.record({\n                eventName: _events.EVENT_BUILD_FEATURE_USAGE,\n                payload: buildLintEvent\n            });\n            const validFileMatcher = (0, _findpagefile.createValidFileMatcher)(config.pageExtensions, appDir);\n            const providedPagePaths = JSON.parse(process.env.NEXT_PRIVATE_PAGE_PATHS || '[]');\n            let pagesPaths = Boolean(process.env.NEXT_PRIVATE_PAGE_PATHS) ? providedPagePaths : !appDirOnly && pagesDir ? await nextBuildSpan.traceChild('collect-pages').traceAsyncFn(()=>(0, _recursivereaddir.recursiveReadDir)(pagesDir, {\n                    pathnameFilter: validFileMatcher.isPageFile\n                })) : [];\n            const middlewareDetectionRegExp = new RegExp(`^${_constants.MIDDLEWARE_FILENAME}\\\\.(?:${config.pageExtensions.join('|')})$`);\n            const instrumentationHookDetectionRegExp = new RegExp(`^${_constants.INSTRUMENTATION_HOOK_FILENAME}\\\\.(?:${config.pageExtensions.join('|')})$`);\n            const rootDir = _path.default.join(pagesDir || appDir, '..');\n            const includes = [\n                middlewareDetectionRegExp,\n                instrumentationHookDetectionRegExp\n            ];\n            const rootPaths = Array.from(await (0, _getfilesindir.getFilesInDir)(rootDir)).filter((file)=>includes.some((include)=>include.test(file))).sort((0, _entries.sortByPageExts)(config.pageExtensions)).map((file)=>_path.default.join(rootDir, file).replace(dir, ''));\n            const hasInstrumentationHook = rootPaths.some((p)=>p.includes(_constants.INSTRUMENTATION_HOOK_FILENAME));\n            const hasMiddlewareFile = rootPaths.some((p)=>p.includes(_constants.MIDDLEWARE_FILENAME));\n            _buildcontext.NextBuildContext.hasInstrumentationHook = hasInstrumentationHook;\n            const previewProps = {\n                previewModeId: _crypto.default.randomBytes(16).toString('hex'),\n                previewModeSigningKey: _crypto.default.randomBytes(32).toString('hex'),\n                previewModeEncryptionKey: _crypto.default.randomBytes(32).toString('hex')\n            };\n            _buildcontext.NextBuildContext.previewProps = previewProps;\n            const mappedPages = await nextBuildSpan.traceChild('create-pages-mapping').traceAsyncFn(()=>(0, _entries.createPagesMapping)({\n                    isDev: false,\n                    pageExtensions: config.pageExtensions,\n                    pagesType: _pagetypes.PAGE_TYPES.PAGES,\n                    pagePaths: pagesPaths,\n                    pagesDir,\n                    appDir\n                }));\n            _buildcontext.NextBuildContext.mappedPages = mappedPages;\n            let mappedAppPages;\n            let denormalizedAppPages;\n            if (appDir) {\n                const providedAppPaths = JSON.parse(process.env.NEXT_PRIVATE_APP_PATHS || '[]');\n                let appPaths = Boolean(process.env.NEXT_PRIVATE_APP_PATHS) ? providedAppPaths : await nextBuildSpan.traceChild('collect-app-paths').traceAsyncFn(()=>(0, _recursivereaddir.recursiveReadDir)(appDir, {\n                        pathnameFilter: (absolutePath)=>validFileMatcher.isAppRouterPage(absolutePath) || // For now we only collect the root /not-found page in the app\n                            // directory as the 404 fallback\n                            validFileMatcher.isRootNotFound(absolutePath),\n                        ignorePartFilter: (part)=>part.startsWith('_')\n                    }));\n                mappedAppPages = await nextBuildSpan.traceChild('create-app-mapping').traceAsyncFn(()=>(0, _entries.createPagesMapping)({\n                        pagePaths: appPaths,\n                        isDev: false,\n                        pagesType: _pagetypes.PAGE_TYPES.APP,\n                        pageExtensions: config.pageExtensions,\n                        pagesDir,\n                        appDir\n                    }));\n                _buildcontext.NextBuildContext.mappedAppPages = mappedAppPages;\n            }\n            const mappedRootPaths = await (0, _entries.createPagesMapping)({\n                isDev: false,\n                pageExtensions: config.pageExtensions,\n                pagePaths: rootPaths,\n                pagesType: _pagetypes.PAGE_TYPES.ROOT,\n                pagesDir: pagesDir,\n                appDir\n            });\n            _buildcontext.NextBuildContext.mappedRootPaths = mappedRootPaths;\n            const pagesPageKeys = Object.keys(mappedPages);\n            const conflictingAppPagePaths = [];\n            const appPageKeys = new Set();\n            if (mappedAppPages) {\n                denormalizedAppPages = Object.keys(mappedAppPages);\n                for (const appKey of denormalizedAppPages){\n                    const normalizedAppPageKey = (0, _apppaths.normalizeAppPath)(appKey);\n                    const pagePath = mappedPages[normalizedAppPageKey];\n                    if (pagePath) {\n                        const appPath = mappedAppPages[appKey];\n                        conflictingAppPagePaths.push([\n                            pagePath.replace(/^private-next-pages/, 'pages'),\n                            appPath.replace(/^private-next-app-dir/, 'app')\n                        ]);\n                    }\n                    appPageKeys.add(normalizedAppPageKey);\n                }\n            }\n            const appPaths = Array.from(appPageKeys);\n            // Interception routes are modelled as beforeFiles rewrites\n            rewrites.beforeFiles.push(...(0, _generateinterceptionroutesrewrites.generateInterceptionRoutesRewrites)(appPaths, config.basePath));\n            _buildcontext.NextBuildContext.rewrites = rewrites;\n            const totalAppPagesCount = appPaths.length;\n            const pageKeys = {\n                pages: pagesPageKeys,\n                app: appPaths.length > 0 ? appPaths : undefined\n            };\n            // Turbopack already handles conflicting app and page routes.\n            if (!isTurbopack) {\n                const numConflictingAppPaths = conflictingAppPagePaths.length;\n                if (mappedAppPages && numConflictingAppPaths > 0) {\n                    _log.error(`Conflicting app and page file${numConflictingAppPaths === 1 ? ' was' : 's were'} found, please remove the conflicting files to continue:`);\n                    for (const [pagePath, appPath] of conflictingAppPagePaths){\n                        _log.error(`  \"${pagePath}\" - \"${appPath}\"`);\n                    }\n                    await telemetry.flush();\n                    process.exit(1);\n                }\n            }\n            const conflictingPublicFiles = [];\n            const hasPages404 = (_mappedPages_404 = mappedPages['/404']) == null ? void 0 : _mappedPages_404.startsWith(_constants.PAGES_DIR_ALIAS);\n            const hasApp404 = !!(mappedAppPages == null ? void 0 : mappedAppPages[_constants1.UNDERSCORE_NOT_FOUND_ROUTE_ENTRY]);\n            const hasCustomErrorPage = mappedPages['/_error'].startsWith(_constants.PAGES_DIR_ALIAS);\n            if (hasPublicDir) {\n                const hasPublicUnderScoreNextDir = (0, _fs.existsSync)(_path.default.join(publicDir, '_next'));\n                if (hasPublicUnderScoreNextDir) {\n                    throw Object.defineProperty(new Error(_constants.PUBLIC_DIR_MIDDLEWARE_CONFLICT), \"__NEXT_ERROR_CODE\", {\n                        value: \"E394\",\n                        enumerable: false,\n                        configurable: true\n                    });\n                }\n            }\n            await nextBuildSpan.traceChild('public-dir-conflict-check').traceAsyncFn(async ()=>{\n                // Check if pages conflict with files in `public`\n                // Only a page of public file can be served, not both.\n                for(const page in mappedPages){\n                    const hasPublicPageFile = await (0, _fileexists.fileExists)(_path.default.join(publicDir, page === '/' ? '/index' : page), _fileexists.FileType.File);\n                    if (hasPublicPageFile) {\n                        conflictingPublicFiles.push(page);\n                    }\n                }\n                const numConflicting = conflictingPublicFiles.length;\n                if (numConflicting) {\n                    throw Object.defineProperty(new Error(`Conflicting public and page file${numConflicting === 1 ? ' was' : 's were'} found. https://nextjs.org/docs/messages/conflicting-public-file-page\\n${conflictingPublicFiles.join('\\n')}`), \"__NEXT_ERROR_CODE\", {\n                        value: \"E270\",\n                        enumerable: false,\n                        configurable: true\n                    });\n                }\n            });\n            const nestedReservedPages = pageKeys.pages.filter((page)=>{\n                return page.match(/\\/(_app|_document|_error)$/) && _path.default.dirname(page) !== '/';\n            });\n            if (nestedReservedPages.length) {\n                _log.warn(`The following reserved Next.js pages were detected not directly under the pages directory:\\n` + nestedReservedPages.join('\\n') + `\\nSee more info here: https://nextjs.org/docs/messages/nested-reserved-page\\n`);\n            }\n            const restrictedRedirectPaths = [\n                '/_next'\n            ].map((p)=>config.basePath ? `${config.basePath}${p}` : p);\n            const isAppDynamicIOEnabled = Boolean(config.experimental.dynamicIO);\n            const isAuthInterruptsEnabled = Boolean(config.experimental.authInterrupts);\n            const isAppPPREnabled = (0, _ppr.checkIsAppPPREnabled)(config.experimental.ppr);\n            const routesManifestPath = _path.default.join(distDir, _constants1.ROUTES_MANIFEST);\n            const routesManifest = nextBuildSpan.traceChild('generate-routes-manifest').traceFn(()=>{\n                const sortedRoutes = (0, _utils.getSortedRoutes)([\n                    ...pageKeys.pages,\n                    ...pageKeys.app ?? []\n                ]);\n                const dynamicRoutes = [];\n                const staticRoutes = [];\n                for (const route of sortedRoutes){\n                    if ((0, _utils.isDynamicRoute)(route)) {\n                        dynamicRoutes.push(pageToRoute(route));\n                    } else if (!(0, _utils1.isReservedPage)(route)) {\n                        staticRoutes.push(pageToRoute(route));\n                    }\n                }\n                return {\n                    version: 3,\n                    pages404: true,\n                    caseSensitive: !!config.experimental.caseSensitiveRoutes,\n                    basePath: config.basePath,\n                    redirects: redirects.map((r)=>(0, _buildcustomroute.buildCustomRoute)('redirect', r, restrictedRedirectPaths)),\n                    headers: headers.map((r)=>(0, _buildcustomroute.buildCustomRoute)('header', r)),\n                    dynamicRoutes,\n                    staticRoutes,\n                    dataRoutes: [],\n                    i18n: config.i18n || undefined,\n                    rsc: {\n                        header: _approuterheaders.RSC_HEADER,\n                        // This vary header is used as a default. It is technically re-assigned in `base-server`,\n                        // and may include an additional Vary option for `Next-URL`.\n                        varyHeader: `${_approuterheaders.RSC_HEADER}, ${_approuterheaders.NEXT_ROUTER_STATE_TREE_HEADER}, ${_approuterheaders.NEXT_ROUTER_PREFETCH_HEADER}, ${_approuterheaders.NEXT_ROUTER_SEGMENT_PREFETCH_HEADER}`,\n                        prefetchHeader: _approuterheaders.NEXT_ROUTER_PREFETCH_HEADER,\n                        didPostponeHeader: _approuterheaders.NEXT_DID_POSTPONE_HEADER,\n                        contentTypeHeader: _approuterheaders.RSC_CONTENT_TYPE_HEADER,\n                        suffix: _constants.RSC_SUFFIX,\n                        prefetchSuffix: _constants.RSC_PREFETCH_SUFFIX,\n                        prefetchSegmentHeader: _approuterheaders.NEXT_ROUTER_SEGMENT_PREFETCH_HEADER,\n                        prefetchSegmentSuffix: _constants.RSC_SEGMENT_SUFFIX,\n                        prefetchSegmentDirSuffix: _constants.RSC_SEGMENTS_DIR_SUFFIX\n                    },\n                    rewriteHeaders: {\n                        pathHeader: _approuterheaders.NEXT_REWRITTEN_PATH_HEADER,\n                        queryHeader: _approuterheaders.NEXT_REWRITTEN_QUERY_HEADER\n                    },\n                    skipMiddlewareUrlNormalize: config.skipMiddlewareUrlNormalize,\n                    ppr: isAppPPREnabled ? {\n                        chain: {\n                            headers: {\n                                [_constants.NEXT_RESUME_HEADER]: '1'\n                            }\n                        }\n                    } : undefined\n                };\n            });\n            if (rewrites.beforeFiles.length === 0 && rewrites.fallback.length === 0) {\n                routesManifest.rewrites = rewrites.afterFiles.map((r)=>(0, _buildcustomroute.buildCustomRoute)('rewrite', r));\n            } else {\n                routesManifest.rewrites = {\n                    beforeFiles: rewrites.beforeFiles.map((r)=>(0, _buildcustomroute.buildCustomRoute)('rewrite', r)),\n                    afterFiles: rewrites.afterFiles.map((r)=>(0, _buildcustomroute.buildCustomRoute)('rewrite', r)),\n                    fallback: rewrites.fallback.map((r)=>(0, _buildcustomroute.buildCustomRoute)('rewrite', r))\n                };\n            }\n            let clientRouterFilters;\n            if (config.experimental.clientRouterFilter) {\n                const nonInternalRedirects = (config._originalRedirects || []).filter((r)=>!r.internal);\n                clientRouterFilters = (0, _createclientrouterfilter.createClientRouterFilter)([\n                    ...appPaths\n                ], config.experimental.clientRouterFilterRedirects ? nonInternalRedirects : [], config.experimental.clientRouterFilterAllowedRate);\n                _buildcontext.NextBuildContext.clientRouterFilters = clientRouterFilters;\n            }\n            // Ensure commonjs handling is used for files in the distDir (generally .next)\n            // Files outside of the distDir can be \"type\": \"module\"\n            await writeFileUtf8(_path.default.join(distDir, 'package.json'), '{\"type\": \"commonjs\"}');\n            // These are written to distDir, so they need to come after creating and cleaning distDr.\n            await (0, _builddiagnostics.recordFrameworkVersion)(\"15.3.1\");\n            await (0, _builddiagnostics.updateBuildDiagnostics)({\n                buildStage: 'start'\n            });\n            const outputFileTracingRoot = config.outputFileTracingRoot || dir;\n            const pagesManifestPath = _path.default.join(distDir, _constants1.SERVER_DIRECTORY, _constants1.PAGES_MANIFEST);\n            let buildTraceContext;\n            let buildTracesPromise = undefined;\n            // If there's has a custom webpack config and disable the build worker.\n            // Otherwise respect the option if it's set.\n            const useBuildWorker = config.experimental.webpackBuildWorker || config.experimental.webpackBuildWorker === undefined && !config.webpack;\n            const runServerAndEdgeInParallel = config.experimental.parallelServerCompiles;\n            const collectServerBuildTracesInParallel = config.experimental.parallelServerBuildTraces || config.experimental.parallelServerBuildTraces === undefined && isCompileMode;\n            nextBuildSpan.setAttribute('has-custom-webpack-config', String(!!config.webpack));\n            nextBuildSpan.setAttribute('use-build-worker', String(useBuildWorker));\n            if (!useBuildWorker && (runServerAndEdgeInParallel || collectServerBuildTracesInParallel)) {\n                throw Object.defineProperty(new Error('The \"parallelServerBuildTraces\" and \"parallelServerCompiles\" options may only be used when build workers can be used. Read more: https://nextjs.org/docs/messages/parallel-build-without-worker'), \"__NEXT_ERROR_CODE\", {\n                    value: \"E101\",\n                    enumerable: false,\n                    configurable: true\n                });\n            }\n            _log.info('Creating an optimized production build ...');\n            (0, _trace1.traceMemoryUsage)('Starting build', nextBuildSpan);\n            await (0, _builddiagnostics.updateBuildDiagnostics)({\n                buildStage: 'compile',\n                buildOptions: {\n                    useBuildWorker: String(useBuildWorker)\n                }\n            });\n            let shutdownPromise = Promise.resolve();\n            if (!isGenerateMode) {\n                if (isTurbopack) {\n                    const { duration: compilerDuration, shutdownPromise: p, ...rest } = await (0, _turbopackbuild.turbopackBuild)(process.env.NEXT_TURBOPACK_USE_WORKER === undefined || process.env.NEXT_TURBOPACK_USE_WORKER !== '0');\n                    shutdownPromise = p;\n                    (0, _trace1.traceMemoryUsage)('Finished build', nextBuildSpan);\n                    buildTraceContext = rest.buildTraceContext;\n                    const durationString = (0, _durationtostring.durationToString)(compilerDuration);\n                    _log.event(`Compiled successfully in ${durationString}`);\n                    telemetry.record((0, _events.eventBuildCompleted)(pagesPaths, {\n                        bundler: 'turbopack',\n                        durationInSeconds: Math.round(compilerDuration),\n                        totalAppPagesCount\n                    }));\n                } else {\n                    if (runServerAndEdgeInParallel || collectServerBuildTracesInParallel) {\n                        let durationInSeconds = 0;\n                        await (0, _builddiagnostics.updateBuildDiagnostics)({\n                            buildStage: 'compile-server'\n                        });\n                        const serverBuildPromise = (0, _webpackbuild.webpackBuild)(useBuildWorker, [\n                            'server'\n                        ]).then((res)=>{\n                            (0, _trace1.traceMemoryUsage)('Finished server compilation', nextBuildSpan);\n                            buildTraceContext = res.buildTraceContext;\n                            durationInSeconds += res.duration;\n                            if (collectServerBuildTracesInParallel) {\n                                const buildTraceWorker = new _worker.Worker(require.resolve('./collect-build-traces'), {\n                                    numWorkers: 1,\n                                    exposedMethods: [\n                                        'collectBuildTraces'\n                                    ]\n                                });\n                                buildTracesPromise = buildTraceWorker.collectBuildTraces({\n                                    dir,\n                                    config,\n                                    distDir,\n                                    // Serialize Map as this is sent to the worker.\n                                    edgeRuntimeRoutes: (0, _utils1.collectRoutesUsingEdgeRuntime)(new Map()),\n                                    staticPages: [],\n                                    hasSsrAmpPages: false,\n                                    buildTraceContext,\n                                    outputFileTracingRoot\n                                }).catch((err)=>{\n                                    console.error(err);\n                                    process.exit(1);\n                                });\n                            }\n                        });\n                        if (!runServerAndEdgeInParallel) {\n                            await serverBuildPromise;\n                            await (0, _builddiagnostics.updateBuildDiagnostics)({\n                                buildStage: 'webpack-compile-edge-server'\n                            });\n                        }\n                        const edgeBuildPromise = (0, _webpackbuild.webpackBuild)(useBuildWorker, [\n                            'edge-server'\n                        ]).then((res)=>{\n                            durationInSeconds += res.duration;\n                            (0, _trace1.traceMemoryUsage)('Finished edge-server compilation', nextBuildSpan);\n                        });\n                        if (runServerAndEdgeInParallel) {\n                            await serverBuildPromise;\n                            await (0, _builddiagnostics.updateBuildDiagnostics)({\n                                buildStage: 'webpack-compile-edge-server'\n                            });\n                        }\n                        await edgeBuildPromise;\n                        await (0, _builddiagnostics.updateBuildDiagnostics)({\n                            buildStage: 'webpack-compile-client'\n                        });\n                        await (0, _webpackbuild.webpackBuild)(useBuildWorker, [\n                            'client'\n                        ]).then((res)=>{\n                            durationInSeconds += res.duration;\n                            (0, _trace1.traceMemoryUsage)('Finished client compilation', nextBuildSpan);\n                        });\n                        const durationString = (0, _durationtostring.durationToString)(durationInSeconds);\n                        _log.event(`Compiled successfully in ${durationString}`);\n                        telemetry.record((0, _events.eventBuildCompleted)(pagesPaths, {\n                            bundler: getBundlerForTelemetry(isTurbopack),\n                            durationInSeconds,\n                            totalAppPagesCount\n                        }));\n                    } else {\n                        const { duration: compilerDuration, ...rest } = await (0, _webpackbuild.webpackBuild)(useBuildWorker, null);\n                        (0, _trace1.traceMemoryUsage)('Finished build', nextBuildSpan);\n                        buildTraceContext = rest.buildTraceContext;\n                        telemetry.record((0, _events.eventBuildCompleted)(pagesPaths, {\n                            bundler: getBundlerForTelemetry(isTurbopack),\n                            durationInSeconds: compilerDuration,\n                            totalAppPagesCount\n                        }));\n                    }\n                }\n            }\n            // For app directory, we run type checking after build.\n            if (appDir && !isCompileMode && !isGenerateMode) {\n                await (0, _builddiagnostics.updateBuildDiagnostics)({\n                    buildStage: 'type-checking'\n                });\n                await (0, _typecheck.startTypeChecking)(typeCheckingOptions);\n                (0, _trace1.traceMemoryUsage)('Finished type checking', nextBuildSpan);\n            }\n            const postCompileSpinner = (0, _spinner.default)('Collecting page data');\n            const buildManifestPath = _path.default.join(distDir, _constants1.BUILD_MANIFEST);\n            const appBuildManifestPath = _path.default.join(distDir, _constants1.APP_BUILD_MANIFEST);\n            let staticAppPagesCount = 0;\n            let serverAppPagesCount = 0;\n            let edgeRuntimeAppCount = 0;\n            let edgeRuntimePagesCount = 0;\n            const ssgPages = new Set();\n            const ssgStaticFallbackPages = new Set();\n            const ssgBlockingFallbackPages = new Set();\n            const staticPages = new Set();\n            const invalidPages = new Set();\n            const hybridAmpPages = new Set();\n            const serverPropsPages = new Set();\n            const additionalPaths = new Map();\n            const staticPaths = new Map();\n            const prospectiveRenders = new Map();\n            const appNormalizedPaths = new Map();\n            const fallbackModes = new Map();\n            const appDefaultConfigs = new Map();\n            const pageInfos = new Map();\n            let pagesManifest = await readManifest(pagesManifestPath);\n            const buildManifest = await readManifest(buildManifestPath);\n            const appBuildManifest = appDir ? await readManifest(appBuildManifestPath) : undefined;\n            const appPathRoutes = {};\n            if (appDir) {\n                const appPathsManifest = await readManifest(_path.default.join(distDir, _constants1.SERVER_DIRECTORY, _constants1.APP_PATHS_MANIFEST));\n                for(const key in appPathsManifest){\n                    appPathRoutes[key] = (0, _apppaths.normalizeAppPath)(key);\n                }\n                await writeManifest(_path.default.join(distDir, _constants1.APP_PATH_ROUTES_MANIFEST), appPathRoutes);\n            }\n            process.env.NEXT_PHASE = _constants1.PHASE_PRODUCTION_BUILD;\n            const worker = createStaticWorker(config);\n            const analysisBegin = process.hrtime();\n            const staticCheckSpan = nextBuildSpan.traceChild('static-check');\n            const functionsConfigManifest = {\n                version: 1,\n                functions: {}\n            };\n            const { customAppGetInitialProps, namedExports, isNextImageImported, hasSsrAmpPages, hasNonStaticErrorPage } = await staticCheckSpan.traceAsyncFn(async ()=>{\n                var _config_experimental_sri;\n                if (isCompileMode) {\n                    return {\n                        customAppGetInitialProps: false,\n                        namedExports: [],\n                        isNextImageImported: true,\n                        hasSsrAmpPages: !!pagesDir,\n                        hasNonStaticErrorPage: true\n                    };\n                }\n                const { configFileName, publicRuntimeConfig, serverRuntimeConfig } = config;\n                const runtimeEnvConfig = {\n                    publicRuntimeConfig,\n                    serverRuntimeConfig\n                };\n                const sriEnabled = Boolean((_config_experimental_sri = config.experimental.sri) == null ? void 0 : _config_experimental_sri.algorithm);\n                const nonStaticErrorPageSpan = staticCheckSpan.traceChild('check-static-error-page');\n                const errorPageHasCustomGetInitialProps = nonStaticErrorPageSpan.traceAsyncFn(async ()=>hasCustomErrorPage && await worker.hasCustomGetInitialProps({\n                        page: '/_error',\n                        distDir,\n                        runtimeEnvConfig,\n                        checkingApp: false,\n                        sriEnabled\n                    }));\n                const errorPageStaticResult = nonStaticErrorPageSpan.traceAsyncFn(async ()=>{\n                    var _config_i18n, _config_i18n1;\n                    return hasCustomErrorPage && worker.isPageStatic({\n                        dir,\n                        page: '/_error',\n                        distDir,\n                        configFileName,\n                        runtimeEnvConfig,\n                        dynamicIO: isAppDynamicIOEnabled,\n                        authInterrupts: isAuthInterruptsEnabled,\n                        httpAgentOptions: config.httpAgentOptions,\n                        locales: (_config_i18n = config.i18n) == null ? void 0 : _config_i18n.locales,\n                        defaultLocale: (_config_i18n1 = config.i18n) == null ? void 0 : _config_i18n1.defaultLocale,\n                        nextConfigOutput: config.output,\n                        pprConfig: config.experimental.ppr,\n                        cacheLifeProfiles: config.experimental.cacheLife,\n                        buildId,\n                        sriEnabled\n                    });\n                });\n                const appPageToCheck = '/_app';\n                const customAppGetInitialPropsPromise = worker.hasCustomGetInitialProps({\n                    page: appPageToCheck,\n                    distDir,\n                    runtimeEnvConfig,\n                    checkingApp: true,\n                    sriEnabled\n                });\n                const namedExportsPromise = worker.getDefinedNamedExports({\n                    page: appPageToCheck,\n                    distDir,\n                    runtimeEnvConfig,\n                    sriEnabled\n                });\n                // eslint-disable-next-line @typescript-eslint/no-shadow\n                let isNextImageImported;\n                // eslint-disable-next-line @typescript-eslint/no-shadow\n                let hasSsrAmpPages = false;\n                const computedManifestData = await (0, _utils1.computeFromManifest)({\n                    build: buildManifest,\n                    app: appBuildManifest\n                }, distDir, config.experimental.gzipSize);\n                const middlewareManifest = require(_path.default.join(distDir, _constants1.SERVER_DIRECTORY, _constants1.MIDDLEWARE_MANIFEST));\n                const actionManifest = appDir ? require(_path.default.join(distDir, _constants1.SERVER_DIRECTORY, _constants1.SERVER_REFERENCE_MANIFEST + '.json')) : null;\n                const entriesWithAction = actionManifest ? new Set() : null;\n                if (actionManifest && entriesWithAction) {\n                    for(const id in actionManifest.node){\n                        for(const entry in actionManifest.node[id].workers){\n                            entriesWithAction.add(entry);\n                        }\n                    }\n                    for(const id in actionManifest.edge){\n                        for(const entry in actionManifest.edge[id].workers){\n                            entriesWithAction.add(entry);\n                        }\n                    }\n                }\n                for (const key of Object.keys(middlewareManifest == null ? void 0 : middlewareManifest.functions)){\n                    if (key.startsWith('/api')) {\n                        edgeRuntimePagesCount++;\n                    }\n                }\n                await Promise.all(Object.entries(pageKeys).reduce((acc, [key, files])=>{\n                    if (!files) {\n                        return acc;\n                    }\n                    const pageType = key;\n                    for (const page of files){\n                        acc.push({\n                            pageType,\n                            page\n                        });\n                    }\n                    return acc;\n                }, []).map(({ pageType, page })=>{\n                    const checkPageSpan = staticCheckSpan.traceChild('check-page', {\n                        page\n                    });\n                    return checkPageSpan.traceAsyncFn(async ()=>{\n                        const actualPage = (0, _normalizepagepath.normalizePagePath)(page);\n                        const [size, totalSize] = await (0, _utils1.getJsPageSizeInKb)(pageType, actualPage, distDir, buildManifest, appBuildManifest, config.experimental.gzipSize, computedManifestData);\n                        let isRoutePPREnabled = false;\n                        let isSSG = false;\n                        let isStatic = false;\n                        let isServerComponent = false;\n                        let isHybridAmp = false;\n                        let ssgPageRoutes = null;\n                        let pagePath = '';\n                        if (pageType === 'pages') {\n                            pagePath = pagesPaths.find((p)=>{\n                                p = (0, _normalizepathsep.normalizePathSep)(p);\n                                return p.startsWith(actualPage + '.') || p.startsWith(actualPage + '/index.');\n                            }) || '';\n                        }\n                        let originalAppPath;\n                        if (pageType === 'app' && mappedAppPages) {\n                            for (const [originalPath, normalizedPath] of Object.entries(appPathRoutes)){\n                                if (normalizedPath === page) {\n                                    pagePath = mappedAppPages[originalPath].replace(/^private-next-app-dir/, '');\n                                    originalAppPath = originalPath;\n                                    break;\n                                }\n                            }\n                        }\n                        const pageFilePath = (0, _utils1.isAppBuiltinNotFoundPage)(pagePath) ? require.resolve('next/dist/client/components/not-found-error') : _path.default.join((pageType === 'pages' ? pagesDir : appDir) || '', pagePath);\n                        const isInsideAppDir = pageType === 'app';\n                        const staticInfo = pagePath ? await (0, _entries.getStaticInfoIncludingLayouts)({\n                            isInsideAppDir,\n                            pageFilePath,\n                            pageExtensions: config.pageExtensions,\n                            appDir,\n                            config,\n                            isDev: false,\n                            // If this route is an App Router page route, inherit the\n                            // route segment configs (e.g. `runtime`) from the layout by\n                            // passing the `originalAppPath`, which should end with `/page`.\n                            page: isInsideAppDir ? originalAppPath : page\n                        }) : undefined;\n                        // If there's any thing that would contribute to the functions\n                        // configuration, we need to add it to the manifest.\n                        if (typeof (staticInfo == null ? void 0 : staticInfo.runtime) !== 'undefined' || typeof (staticInfo == null ? void 0 : staticInfo.maxDuration) !== 'undefined') {\n                            functionsConfigManifest.functions[page] = {\n                                maxDuration: staticInfo == null ? void 0 : staticInfo.maxDuration\n                            };\n                        }\n                        const pageRuntime = middlewareManifest.functions[originalAppPath || page] ? 'edge' : staticInfo == null ? void 0 : staticInfo.runtime;\n                        if (!isCompileMode) {\n                            isServerComponent = pageType === 'app' && (staticInfo == null ? void 0 : staticInfo.rsc) !== _constants1.RSC_MODULE_TYPES.client;\n                            if (pageType === 'app' || !(0, _utils1.isReservedPage)(page)) {\n                                try {\n                                    let edgeInfo;\n                                    if ((0, _isedgeruntime.isEdgeRuntime)(pageRuntime)) {\n                                        if (pageType === 'app') {\n                                            edgeRuntimeAppCount++;\n                                        } else {\n                                            edgeRuntimePagesCount++;\n                                        }\n                                        const manifestKey = pageType === 'pages' ? page : originalAppPath || '';\n                                        edgeInfo = middlewareManifest.functions[manifestKey];\n                                    }\n                                    let isPageStaticSpan = checkPageSpan.traceChild('is-page-static');\n                                    let workerResult = await isPageStaticSpan.traceAsyncFn(()=>{\n                                        var _config_i18n, _config_i18n1;\n                                        return worker.isPageStatic({\n                                            dir,\n                                            page,\n                                            originalAppPath,\n                                            distDir,\n                                            configFileName,\n                                            runtimeEnvConfig,\n                                            httpAgentOptions: config.httpAgentOptions,\n                                            locales: (_config_i18n = config.i18n) == null ? void 0 : _config_i18n.locales,\n                                            defaultLocale: (_config_i18n1 = config.i18n) == null ? void 0 : _config_i18n1.defaultLocale,\n                                            parentId: isPageStaticSpan.getId(),\n                                            pageRuntime,\n                                            edgeInfo,\n                                            pageType,\n                                            dynamicIO: isAppDynamicIOEnabled,\n                                            authInterrupts: isAuthInterruptsEnabled,\n                                            cacheHandler: config.cacheHandler,\n                                            cacheHandlers: config.experimental.cacheHandlers,\n                                            isrFlushToDisk: _ciinfo.hasNextSupport ? false : config.experimental.isrFlushToDisk,\n                                            maxMemoryCacheSize: config.cacheMaxMemorySize,\n                                            nextConfigOutput: config.output,\n                                            pprConfig: config.experimental.ppr,\n                                            cacheLifeProfiles: config.experimental.cacheLife,\n                                            buildId,\n                                            sriEnabled\n                                        });\n                                    });\n                                    if (pageType === 'app' && originalAppPath) {\n                                        appNormalizedPaths.set(originalAppPath, page);\n                                        // TODO-APP: handle prerendering with edge\n                                        if ((0, _isedgeruntime.isEdgeRuntime)(pageRuntime)) {\n                                            isStatic = false;\n                                            isSSG = false;\n                                            _log.warnOnce(`Using edge runtime on a page currently disables static generation for that page`);\n                                        } else {\n                                            const isDynamic = (0, _utils.isDynamicRoute)(page);\n                                            if (typeof workerResult.isRoutePPREnabled === 'boolean') {\n                                                isRoutePPREnabled = workerResult.isRoutePPREnabled;\n                                            }\n                                            // If this route can be partially pre-rendered, then\n                                            // mark it as such and mark that it can be\n                                            // generated server-side.\n                                            if (workerResult.isRoutePPREnabled) {\n                                                isSSG = true;\n                                                isStatic = true;\n                                                staticPaths.set(originalAppPath, []);\n                                            } else if (config.experimental.dynamicIO && isDynamic) {\n                                                prospectiveRenders.set(originalAppPath, {\n                                                    page,\n                                                    originalAppPath\n                                                });\n                                            }\n                                            if (workerResult.prerenderedRoutes) {\n                                                staticPaths.set(originalAppPath, workerResult.prerenderedRoutes);\n                                                ssgPageRoutes = workerResult.prerenderedRoutes.map((route)=>route.pathname);\n                                                isSSG = true;\n                                            }\n                                            const appConfig = workerResult.appConfig || {};\n                                            if (appConfig.revalidate !== 0) {\n                                                const hasGenerateStaticParams = workerResult.prerenderedRoutes && workerResult.prerenderedRoutes.length > 0;\n                                                if (config.output === 'export' && isDynamic && !hasGenerateStaticParams) {\n                                                    throw Object.defineProperty(new Error(`Page \"${page}\" is missing \"generateStaticParams()\" so it cannot be used with \"output: export\" config.`), \"__NEXT_ERROR_CODE\", {\n                                                        value: \"E87\",\n                                                        enumerable: false,\n                                                        configurable: true\n                                                    });\n                                                }\n                                                // Mark the app as static if:\n                                                // - It has no dynamic param\n                                                // - It doesn't have generateStaticParams but `dynamic` is set to\n                                                //   `error` or `force-static`\n                                                if (!isDynamic) {\n                                                    staticPaths.set(originalAppPath, [\n                                                        {\n                                                            pathname: page,\n                                                            encodedPathname: page,\n                                                            fallbackRouteParams: undefined,\n                                                            fallbackMode: workerResult.prerenderFallbackMode,\n                                                            fallbackRootParams: undefined\n                                                        }\n                                                    ]);\n                                                    isStatic = true;\n                                                } else if (!hasGenerateStaticParams && (appConfig.dynamic === 'error' || appConfig.dynamic === 'force-static')) {\n                                                    staticPaths.set(originalAppPath, []);\n                                                    isStatic = true;\n                                                    isRoutePPREnabled = false;\n                                                }\n                                            }\n                                            if (workerResult.prerenderFallbackMode) {\n                                                fallbackModes.set(originalAppPath, workerResult.prerenderFallbackMode);\n                                            }\n                                            appDefaultConfigs.set(originalAppPath, appConfig);\n                                        }\n                                    } else {\n                                        if ((0, _isedgeruntime.isEdgeRuntime)(pageRuntime)) {\n                                            if (workerResult.hasStaticProps) {\n                                                console.warn(`\"getStaticProps\" is not yet supported fully with \"experimental-edge\", detected on ${page}`);\n                                            }\n                                            // TODO: add handling for statically rendering edge\n                                            // pages and allow edge with Prerender outputs\n                                            workerResult.isStatic = false;\n                                            workerResult.hasStaticProps = false;\n                                        }\n                                        if (workerResult.isStatic === false && (workerResult.isHybridAmp || workerResult.isAmpOnly)) {\n                                            hasSsrAmpPages = true;\n                                        }\n                                        if (workerResult.isHybridAmp) {\n                                            isHybridAmp = true;\n                                            hybridAmpPages.add(page);\n                                        }\n                                        if (workerResult.isNextImageImported) {\n                                            isNextImageImported = true;\n                                        }\n                                        if (workerResult.hasStaticProps) {\n                                            ssgPages.add(page);\n                                            isSSG = true;\n                                            if (workerResult.prerenderedRoutes && workerResult.prerenderedRoutes.length > 0) {\n                                                additionalPaths.set(page, workerResult.prerenderedRoutes);\n                                                ssgPageRoutes = workerResult.prerenderedRoutes.map((route)=>route.pathname);\n                                            }\n                                            if (workerResult.prerenderFallbackMode === _fallback.FallbackMode.BLOCKING_STATIC_RENDER) {\n                                                ssgBlockingFallbackPages.add(page);\n                                            } else if (workerResult.prerenderFallbackMode === _fallback.FallbackMode.PRERENDER) {\n                                                ssgStaticFallbackPages.add(page);\n                                            }\n                                        } else if (workerResult.hasServerProps) {\n                                            serverPropsPages.add(page);\n                                        } else if (workerResult.isStatic && !isServerComponent && await customAppGetInitialPropsPromise === false) {\n                                            staticPages.add(page);\n                                            isStatic = true;\n                                        } else if (isServerComponent) {\n                                            // This is a static server component page that doesn't have\n                                            // gSP or gSSP. We still treat it as a SSG page.\n                                            ssgPages.add(page);\n                                            isSSG = true;\n                                        }\n                                        if (hasPages404 && page === '/404') {\n                                            if (!workerResult.isStatic && !workerResult.hasStaticProps) {\n                                                throw Object.defineProperty(new Error(`\\`pages/404\\` ${_constants.STATIC_STATUS_PAGE_GET_INITIAL_PROPS_ERROR}`), \"__NEXT_ERROR_CODE\", {\n                                                    value: \"E134\",\n                                                    enumerable: false,\n                                                    configurable: true\n                                                });\n                                            }\n                                            // we need to ensure the 404 lambda is present since we use\n                                            // it when _app has getInitialProps\n                                            if (await customAppGetInitialPropsPromise && !workerResult.hasStaticProps) {\n                                                staticPages.delete(page);\n                                            }\n                                        }\n                                        if (_constants1.STATIC_STATUS_PAGES.includes(page) && !workerResult.isStatic && !workerResult.hasStaticProps) {\n                                            throw Object.defineProperty(new Error(`\\`pages${page}\\` ${_constants.STATIC_STATUS_PAGE_GET_INITIAL_PROPS_ERROR}`), \"__NEXT_ERROR_CODE\", {\n                                                value: \"E125\",\n                                                enumerable: false,\n                                                configurable: true\n                                            });\n                                        }\n                                    }\n                                } catch (err) {\n                                    if (!(0, _iserror.default)(err) || err.message !== 'INVALID_DEFAULT_EXPORT') throw err;\n                                    invalidPages.add(page);\n                                }\n                            }\n                            if (pageType === 'app') {\n                                if (isSSG || isStatic) {\n                                    staticAppPagesCount++;\n                                } else {\n                                    serverAppPagesCount++;\n                                }\n                            }\n                        }\n                        pageInfos.set(page, {\n                            size,\n                            totalSize,\n                            isStatic,\n                            isSSG,\n                            isRoutePPREnabled,\n                            isHybridAmp,\n                            ssgPageRoutes,\n                            initialCacheControl: undefined,\n                            runtime: pageRuntime,\n                            pageDuration: undefined,\n                            ssgPageDurations: undefined,\n                            hasEmptyPrelude: undefined\n                        });\n                    });\n                }));\n                if (_getpagestaticinfo.hadUnsupportedValue) {\n                    _log.error(`Invalid config value exports detected, these can cause unexpected behavior from the configs not being applied. Please fix them to continue`);\n                    process.exit(1);\n                }\n                const errorPageResult = await errorPageStaticResult;\n                const nonStaticErrorPage = await errorPageHasCustomGetInitialProps || errorPageResult && errorPageResult.hasServerProps;\n                const returnValue = {\n                    customAppGetInitialProps: await customAppGetInitialPropsPromise,\n                    namedExports: await namedExportsPromise,\n                    isNextImageImported,\n                    hasSsrAmpPages,\n                    hasNonStaticErrorPage: nonStaticErrorPage\n                };\n                return returnValue;\n            });\n            if (postCompileSpinner) postCompileSpinner.stopAndPersist();\n            (0, _trace1.traceMemoryUsage)('Finished collecting page data', nextBuildSpan);\n            if (customAppGetInitialProps) {\n                console.warn((0, _picocolors.bold)((0, _picocolors.yellow)(`Warning: `)) + (0, _picocolors.yellow)(`You have opted-out of Automatic Static Optimization due to \\`getInitialProps\\` in \\`pages/_app\\`. This does not opt-out pages with \\`getStaticProps\\``));\n                console.warn('Read more: https://nextjs.org/docs/messages/opt-out-auto-static-optimization\\n');\n            }\n            const { cacheHandler } = config;\n            const instrumentationHookEntryFiles = [];\n            if (hasInstrumentationHook) {\n                instrumentationHookEntryFiles.push(_path.default.join(_constants1.SERVER_DIRECTORY, `${_constants.INSTRUMENTATION_HOOK_FILENAME}.js`));\n                // If there's edge routes, append the edge instrumentation hook\n                // Turbopack generates this chunk with a hashed name and references it in middleware-manifest.\n                if (!isTurbopack && (edgeRuntimeAppCount || edgeRuntimePagesCount)) {\n                    instrumentationHookEntryFiles.push(_path.default.join(_constants1.SERVER_DIRECTORY, `edge-${_constants.INSTRUMENTATION_HOOK_FILENAME}.js`));\n                }\n            }\n            const requiredServerFilesManifest = nextBuildSpan.traceChild('generate-required-server-files').traceFn(()=>{\n                const normalizedCacheHandlers = {};\n                for (const [key, value] of Object.entries(config.experimental.cacheHandlers || {})){\n                    if (key && value) {\n                        normalizedCacheHandlers[key] = _path.default.relative(distDir, value);\n                    }\n                }\n                const serverFilesManifest = {\n                    version: 1,\n                    config: {\n                        ...config,\n                        configFile: undefined,\n                        ..._ciinfo.hasNextSupport ? {\n                            compress: false\n                        } : {},\n                        cacheHandler: cacheHandler ? _path.default.relative(distDir, cacheHandler) : config.cacheHandler,\n                        experimental: {\n                            ...config.experimental,\n                            cacheHandlers: normalizedCacheHandlers,\n                            trustHostHeader: _ciinfo.hasNextSupport,\n                            // @ts-expect-error internal field TODO: fix this, should use a separate mechanism to pass the info.\n                            isExperimentalCompile: isCompileMode\n                        }\n                    },\n                    appDir: dir,\n                    relativeAppDir: _path.default.relative(outputFileTracingRoot, dir),\n                    files: [\n                        _constants1.ROUTES_MANIFEST,\n                        _path.default.relative(distDir, pagesManifestPath),\n                        _constants1.BUILD_MANIFEST,\n                        _constants1.PRERENDER_MANIFEST,\n                        _path.default.join(_constants1.SERVER_DIRECTORY, _constants1.FUNCTIONS_CONFIG_MANIFEST),\n                        _path.default.join(_constants1.SERVER_DIRECTORY, _constants1.MIDDLEWARE_MANIFEST),\n                        _path.default.join(_constants1.SERVER_DIRECTORY, _constants1.MIDDLEWARE_BUILD_MANIFEST + '.js'),\n                        ...!isTurbopack ? [\n                            _path.default.join(_constants1.SERVER_DIRECTORY, _constants1.MIDDLEWARE_REACT_LOADABLE_MANIFEST + '.js'),\n                            _constants1.REACT_LOADABLE_MANIFEST\n                        ] : [],\n                        ...appDir ? [\n                            ...config.experimental.sri ? [\n                                _path.default.join(_constants1.SERVER_DIRECTORY, _constants1.SUBRESOURCE_INTEGRITY_MANIFEST + '.js'),\n                                _path.default.join(_constants1.SERVER_DIRECTORY, _constants1.SUBRESOURCE_INTEGRITY_MANIFEST + '.json')\n                            ] : [],\n                            _path.default.join(_constants1.SERVER_DIRECTORY, _constants1.APP_PATHS_MANIFEST),\n                            _path.default.join(_constants1.APP_PATH_ROUTES_MANIFEST),\n                            _constants1.APP_BUILD_MANIFEST,\n                            _path.default.join(_constants1.SERVER_DIRECTORY, _constants1.SERVER_REFERENCE_MANIFEST + '.js'),\n                            _path.default.join(_constants1.SERVER_DIRECTORY, _constants1.SERVER_REFERENCE_MANIFEST + '.json')\n                        ] : [],\n                        ...pagesDir && !isTurbopack ? [\n                            _constants1.DYNAMIC_CSS_MANIFEST + '.json',\n                            _path.default.join(_constants1.SERVER_DIRECTORY, _constants1.DYNAMIC_CSS_MANIFEST + '.js')\n                        ] : [],\n                        _constants1.BUILD_ID_FILE,\n                        _path.default.join(_constants1.SERVER_DIRECTORY, _constants1.NEXT_FONT_MANIFEST + '.js'),\n                        _path.default.join(_constants1.SERVER_DIRECTORY, _constants1.NEXT_FONT_MANIFEST + '.json'),\n                        ...instrumentationHookEntryFiles\n                    ].filter(_nonnullable.nonNullable).map((file)=>_path.default.join(config.distDir, file)),\n                    ignore: []\n                };\n                return serverFilesManifest;\n            });\n            if (!hasSsrAmpPages) {\n                requiredServerFilesManifest.ignore.push(_path.default.relative(dir, _path.default.join(_path.default.dirname(require.resolve('next/dist/compiled/@ampproject/toolbox-optimizer')), '**/*')));\n            }\n            const middlewareFile = rootPaths.find((p)=>p.includes(_constants.MIDDLEWARE_FILENAME));\n            let hasNodeMiddleware = false;\n            if (middlewareFile) {\n                const staticInfo = await (0, _entries.getStaticInfoIncludingLayouts)({\n                    isInsideAppDir: false,\n                    pageFilePath: _path.default.join(dir, middlewareFile),\n                    config,\n                    appDir,\n                    pageExtensions: config.pageExtensions,\n                    isDev: false,\n                    page: 'middleware'\n                });\n                if (staticInfo.runtime === 'nodejs') {\n                    var _staticInfo_middleware;\n                    hasNodeMiddleware = true;\n                    functionsConfigManifest.functions['/_middleware'] = {\n                        runtime: staticInfo.runtime,\n                        matchers: ((_staticInfo_middleware = staticInfo.middleware) == null ? void 0 : _staticInfo_middleware.matchers) ?? [\n                            {\n                                regexp: '^.*$',\n                                originalSource: '/:path*'\n                            }\n                        ]\n                    };\n                    if (isTurbopack) {\n                        await writeManifest(_path.default.join(distDir, 'static', buildId, _constants1.TURBOPACK_CLIENT_MIDDLEWARE_MANIFEST), functionsConfigManifest.functions['/_middleware'].matchers || []);\n                    }\n                }\n            }\n            await writeFunctionsConfigManifest(distDir, functionsConfigManifest);\n            if (!isGenerateMode && !buildTracesPromise) {\n                buildTracesPromise = (0, _collectbuildtraces.collectBuildTraces)({\n                    dir,\n                    config,\n                    distDir,\n                    edgeRuntimeRoutes: (0, _utils1.collectRoutesUsingEdgeRuntime)(pageInfos),\n                    staticPages: [\n                        ...staticPages\n                    ],\n                    nextBuildSpan,\n                    hasSsrAmpPages,\n                    buildTraceContext,\n                    outputFileTracingRoot\n                }).catch((err)=>{\n                    console.error(err);\n                    process.exit(1);\n                });\n            }\n            if (serverPropsPages.size > 0 || ssgPages.size > 0) {\n                // We update the routes manifest after the build with the\n                // data routes since we can't determine these until after build\n                routesManifest.dataRoutes = (0, _utils.getSortedRoutes)([\n                    ...serverPropsPages,\n                    ...ssgPages\n                ]).map((page)=>{\n                    return (0, _builddataroute.buildDataRoute)(page, buildId);\n                });\n            }\n            // We need to write the manifest with rewrites before build\n            await nextBuildSpan.traceChild('write-routes-manifest').traceAsyncFn(()=>writeManifest(routesManifestPath, routesManifest));\n            // Since custom _app.js can wrap the 404 page we have to opt-out of static optimization if it has getInitialProps\n            // Only export the static 404 when there is no /_error present\n            const useStaticPages404 = !customAppGetInitialProps && (!hasNonStaticErrorPage || hasPages404);\n            if (invalidPages.size > 0) {\n                const err = Object.defineProperty(new Error(`Build optimization failed: found page${invalidPages.size === 1 ? '' : 's'} without a React Component as default export in \\n${[\n                    ...invalidPages\n                ].map((pg)=>`pages${pg}`).join('\\n')}\\n\\nSee https://nextjs.org/docs/messages/page-without-valid-component for more info.\\n`), \"__NEXT_ERROR_CODE\", {\n                    value: \"E474\",\n                    enumerable: false,\n                    configurable: true\n                });\n                err.code = 'BUILD_OPTIMIZATION_FAILED';\n                throw err;\n            }\n            await (0, _writebuildid.writeBuildId)(distDir, buildId);\n            if (config.experimental.optimizeCss) {\n                const globOrig = require('next/dist/compiled/glob');\n                const cssFilePaths = await new Promise((resolve, reject)=>{\n                    globOrig('**/*.css', {\n                        cwd: _path.default.join(distDir, 'static')\n                    }, (err, files)=>{\n                        if (err) {\n                            return reject(err);\n                        }\n                        resolve(files);\n                    });\n                });\n                requiredServerFilesManifest.files.push(...cssFilePaths.map((filePath)=>_path.default.join(config.distDir, 'static', filePath)));\n            }\n            const features = [\n                {\n                    featureName: 'experimental/dynamicIO',\n                    invocationCount: config.experimental.dynamicIO ? 1 : 0\n                },\n                {\n                    featureName: 'experimental/optimizeCss',\n                    invocationCount: config.experimental.optimizeCss ? 1 : 0\n                },\n                {\n                    featureName: 'experimental/nextScriptWorkers',\n                    invocationCount: config.experimental.nextScriptWorkers ? 1 : 0\n                },\n                {\n                    featureName: 'experimental/ppr',\n                    invocationCount: config.experimental.ppr ? 1 : 0\n                },\n                {\n                    featureName: 'turbopackPersistentCaching',\n                    invocationCount: (0, _utils4.isPersistentCachingEnabled)(config) ? 1 : 0\n                }\n            ];\n            telemetry.record(features.map((feature)=>{\n                return {\n                    eventName: _events.EVENT_BUILD_FEATURE_USAGE,\n                    payload: feature\n                };\n            }));\n            await writeRequiredServerFilesManifest(distDir, requiredServerFilesManifest);\n            // we don't need to inline for turbopack build as\n            // it will handle it's own caching separate of compile\n            if (isGenerateMode && !isTurbopack) {\n                _log.info('Inlining static env ...');\n                await nextBuildSpan.traceChild('inline-static-env').traceAsyncFn(async ()=>{\n                    await (0, _inlinestaticenv.inlineStaticEnv)({\n                        distDir,\n                        config\n                    });\n                });\n            }\n            const middlewareManifest = await readManifest(_path.default.join(distDir, _constants1.SERVER_DIRECTORY, _constants1.MIDDLEWARE_MANIFEST));\n            const prerenderManifest = {\n                version: 4,\n                routes: {},\n                dynamicRoutes: {},\n                notFoundRoutes: [],\n                preview: previewProps\n            };\n            const tbdPrerenderRoutes = [];\n            const { i18n } = config;\n            const usedStaticStatusPages = _constants1.STATIC_STATUS_PAGES.filter((page)=>mappedPages[page] && mappedPages[page].startsWith('private-next-pages'));\n            usedStaticStatusPages.forEach((page)=>{\n                if (!ssgPages.has(page) && !customAppGetInitialProps) {\n                    staticPages.add(page);\n                }\n            });\n            const hasPages500 = usedStaticStatusPages.includes('/500');\n            const useDefaultStatic500 = !hasPages500 && !hasNonStaticErrorPage && !customAppGetInitialProps;\n            const combinedPages = [\n                ...staticPages,\n                ...ssgPages\n            ];\n            const isApp404Static = staticPaths.has(_constants1.UNDERSCORE_NOT_FOUND_ROUTE_ENTRY);\n            const hasStaticApp404 = hasApp404 && isApp404Static;\n            await (0, _builddiagnostics.updateBuildDiagnostics)({\n                buildStage: 'static-generation'\n            });\n            // we need to trigger automatic exporting when we have\n            // - static 404/500\n            // - getStaticProps paths\n            // - experimental app is enabled\n            if (!isCompileMode && (combinedPages.length > 0 || useStaticPages404 || useDefaultStatic500 || appDir)) {\n                const staticGenerationSpan = nextBuildSpan.traceChild('static-generation');\n                await staticGenerationSpan.traceAsyncFn(async ()=>{\n                    (0, _utils1.detectConflictingPaths)([\n                        ...combinedPages,\n                        ...pageKeys.pages.filter((page)=>!combinedPages.includes(page))\n                    ], ssgPages, new Map(Array.from(additionalPaths.entries()).map(([page, routes])=>{\n                        return [\n                            page,\n                            routes.map((route)=>route.pathname)\n                        ];\n                    })));\n                    const exportApp = require('../export').default;\n                    const exportConfig = {\n                        ...config,\n                        // Default map will be the collection of automatic statically exported\n                        // pages and incremental pages.\n                        // n.b. we cannot handle this above in combinedPages because the dynamic\n                        // page must be in the `pages` array, but not in the mapping.\n                        exportPathMap: (defaultMap)=>{\n                            // Dynamically routed pages should be prerendered to be used as\n                            // a client-side skeleton (fallback) while data is being fetched.\n                            // This ensures the end-user never sees a 500 or slow response from the\n                            // server.\n                            //\n                            // Note: prerendering disables automatic static optimization.\n                            ssgPages.forEach((page)=>{\n                                if ((0, _utils.isDynamicRoute)(page)) {\n                                    tbdPrerenderRoutes.push(page);\n                                    if (ssgStaticFallbackPages.has(page)) {\n                                        // Override the rendering for the dynamic page to be treated as a\n                                        // fallback render.\n                                        if (i18n) {\n                                            defaultMap[`/${i18n.defaultLocale}${page}`] = {\n                                                page,\n                                                _pagesFallback: true\n                                            };\n                                        } else {\n                                            defaultMap[page] = {\n                                                page,\n                                                _pagesFallback: true\n                                            };\n                                        }\n                                    } else {\n                                        // Remove dynamically routed pages from the default path map when\n                                        // fallback behavior is disabled.\n                                        delete defaultMap[page];\n                                    }\n                                }\n                            });\n                            // Append the \"well-known\" routes we should prerender for, e.g. blog\n                            // post slugs.\n                            additionalPaths.forEach((routes, page)=>{\n                                routes.forEach((route)=>{\n                                    defaultMap[route.pathname] = {\n                                        page,\n                                        _ssgPath: route.encodedPathname\n                                    };\n                                });\n                            });\n                            if (useStaticPages404) {\n                                defaultMap['/404'] = {\n                                    page: hasPages404 ? '/404' : '/_error'\n                                };\n                            }\n                            if (useDefaultStatic500) {\n                                defaultMap['/500'] = {\n                                    page: '/_error'\n                                };\n                            }\n                            // TODO: output manifest specific to app paths and their\n                            // revalidate periods and dynamicParams settings\n                            staticPaths.forEach((routes, originalAppPath)=>{\n                                const appConfig = appDefaultConfigs.get(originalAppPath);\n                                const isDynamicError = (appConfig == null ? void 0 : appConfig.dynamic) === 'error';\n                                const isRoutePPREnabled = appConfig ? (0, _ppr.checkIsRoutePPREnabled)(config.experimental.ppr, appConfig) : undefined;\n                                routes.forEach((route)=>{\n                                    // If the route has any dynamic root segments, we need to skip\n                                    // rendering the route. This is because we don't support\n                                    // revalidating the shells without the parameters present.\n                                    if (route.fallbackRootParams && route.fallbackRootParams.length > 0) {\n                                        return;\n                                    }\n                                    defaultMap[route.pathname] = {\n                                        page: originalAppPath,\n                                        _ssgPath: route.encodedPathname,\n                                        _fallbackRouteParams: route.fallbackRouteParams,\n                                        _isDynamicError: isDynamicError,\n                                        _isAppDir: true,\n                                        _isRoutePPREnabled: isRoutePPREnabled\n                                    };\n                                });\n                            });\n                            // If the app does have dynamic IO enabled but does not have PPR\n                            // enabled, then we need to perform a prospective render for all\n                            // the dynamic pages to ensure that they won't error during\n                            // rendering (due to a missing prelude).\n                            for (const { page, originalAppPath } of prospectiveRenders.values()){\n                                defaultMap[page] = {\n                                    page: originalAppPath,\n                                    _ssgPath: page,\n                                    _fallbackRouteParams: (0, _fallbackparams.getParamKeys)(page),\n                                    // Prospective renders are only enabled for app pages.\n                                    _isAppDir: true,\n                                    // Prospective renders are only enabled when PPR is disabled.\n                                    _isRoutePPREnabled: false,\n                                    _isProspectiveRender: true,\n                                    // Dynamic IO does not currently support `dynamic === 'error'`.\n                                    _isDynamicError: false\n                                };\n                            }\n                            if (i18n) {\n                                for (const page of [\n                                    ...staticPages,\n                                    ...ssgPages,\n                                    ...useStaticPages404 ? [\n                                        '/404'\n                                    ] : [],\n                                    ...useDefaultStatic500 ? [\n                                        '/500'\n                                    ] : []\n                                ]){\n                                    const isSsg = ssgPages.has(page);\n                                    const isDynamic = (0, _utils.isDynamicRoute)(page);\n                                    const isFallback = isSsg && ssgStaticFallbackPages.has(page);\n                                    for (const locale of i18n.locales){\n                                        var _defaultMap_page;\n                                        // skip fallback generation for SSG pages without fallback mode\n                                        if (isSsg && isDynamic && !isFallback) continue;\n                                        const outputPath = `/${locale}${page === '/' ? '' : page}`;\n                                        defaultMap[outputPath] = {\n                                            page: ((_defaultMap_page = defaultMap[page]) == null ? void 0 : _defaultMap_page.page) || page,\n                                            _locale: locale,\n                                            _pagesFallback: isFallback\n                                        };\n                                    }\n                                    if (isSsg) {\n                                        // remove non-locale prefixed variant from defaultMap\n                                        delete defaultMap[page];\n                                    }\n                                }\n                            }\n                            return defaultMap;\n                        }\n                    };\n                    const outdir = _path.default.join(distDir, 'export');\n                    const exportResult = await exportApp(dir, {\n                        nextConfig: exportConfig,\n                        enabledDirectories,\n                        silent: true,\n                        buildExport: true,\n                        debugOutput,\n                        pages: combinedPages,\n                        outdir,\n                        statusMessage: 'Generating static pages',\n                        numWorkers: getNumberOfWorkers(exportConfig)\n                    }, nextBuildSpan);\n                    // If there was no result, there's nothing more to do.\n                    if (!exportResult) return;\n                    const getCacheControl = (exportPath, defaultRevalidate = false)=>{\n                        var _exportResult_byPath_get;\n                        const cacheControl = (_exportResult_byPath_get = exportResult.byPath.get(exportPath)) == null ? void 0 : _exportResult_byPath_get.cacheControl;\n                        if (!cacheControl) {\n                            return {\n                                revalidate: defaultRevalidate,\n                                expire: undefined\n                            };\n                        }\n                        if (cacheControl.revalidate !== false && cacheControl.revalidate > 0 && cacheControl.expire === undefined) {\n                            return {\n                                revalidate: cacheControl.revalidate,\n                                expire: config.expireTime\n                            };\n                        }\n                        return cacheControl;\n                    };\n                    if (debugOutput || process.env.NEXT_SSG_FETCH_METRICS === '1') {\n                        (0, _builddiagnostics.recordFetchMetrics)(exportResult);\n                    }\n                    (0, _turborepoaccesstrace.writeTurborepoAccessTraceResult)({\n                        distDir: config.distDir,\n                        traces: [\n                            turborepoAccessTraceResult,\n                            ...exportResult.turborepoAccessTraceResults.values()\n                        ]\n                    });\n                    prerenderManifest.notFoundRoutes = Array.from(exportResult.ssgNotFoundPaths);\n                    // remove server bundles that were exported\n                    for (const page of staticPages){\n                        const serverBundle = (0, _require.getPagePath)(page, distDir, undefined, false);\n                        await _fs.promises.unlink(serverBundle);\n                    }\n                    staticPaths.forEach((prerenderedRoutes, originalAppPath)=>{\n                        var _pageInfos_get;\n                        const page = appNormalizedPaths.get(originalAppPath);\n                        if (!page) throw Object.defineProperty(new _invarianterror.InvariantError('Page not found'), \"__NEXT_ERROR_CODE\", {\n                            value: \"E619\",\n                            enumerable: false,\n                            configurable: true\n                        });\n                        const appConfig = appDefaultConfigs.get(originalAppPath);\n                        if (!appConfig) throw Object.defineProperty(new _invarianterror.InvariantError('App config not found'), \"__NEXT_ERROR_CODE\", {\n                            value: \"E616\",\n                            enumerable: false,\n                            configurable: true\n                        });\n                        let hasRevalidateZero = appConfig.revalidate === 0 || getCacheControl(page).revalidate === 0;\n                        if (hasRevalidateZero && ((_pageInfos_get = pageInfos.get(page)) == null ? void 0 : _pageInfos_get.isStatic)) {\n                            // if the page was marked as being static, but it contains dynamic data\n                            // (ie, in the case of a static generation bailout), then it should be marked dynamic\n                            pageInfos.set(page, {\n                                ...pageInfos.get(page),\n                                isStatic: false,\n                                isSSG: false\n                            });\n                        }\n                        const isAppRouteHandler = (0, _isapprouteroute.isAppRouteRoute)(originalAppPath);\n                        // When this is an app page and PPR is enabled, the route supports\n                        // partial pre-rendering.\n                        const isRoutePPREnabled = !isAppRouteHandler && (0, _ppr.checkIsRoutePPREnabled)(config.experimental.ppr, appConfig) ? true : undefined;\n                        const htmlBotsRegexString = // The htmlLimitedBots has been converted to a string during loadConfig\n                        config.htmlLimitedBots || _isbot.HTML_LIMITED_BOT_UA_RE_STRING;\n                        // this flag is used to selectively bypass the static cache and invoke the lambda directly\n                        // to enable server actions on static routes\n                        const bypassFor = [\n                            {\n                                type: 'header',\n                                key: _approuterheaders.ACTION_HEADER\n                            },\n                            {\n                                type: 'header',\n                                key: 'content-type',\n                                value: 'multipart/form-data;.*'\n                            },\n                            // If it's PPR rendered non-static page, bypass the PPR cache when streaming metadata is enabled.\n                            // This will skip the postpone data for those bots requests and instead produce a dynamic render.\n                            ...isRoutePPREnabled ? [\n                                {\n                                    type: 'header',\n                                    key: 'user-agent',\n                                    value: htmlBotsRegexString\n                                }\n                            ] : []\n                        ];\n                        // We should collect all the dynamic routes into a single array for\n                        // this page. Including the full fallback route (the original\n                        // route), any routes that were generated with unknown route params\n                        // should be collected and included in the dynamic routes part\n                        // of the manifest instead.\n                        const routes = [];\n                        const dynamicRoutes = [];\n                        // Sort the outputted routes to ensure consistent output. Any route\n                        // though that has unknown route params will be pulled and sorted\n                        // independently. This is because the routes with unknown route\n                        // params will contain the dynamic path parameters, some of which\n                        // may conflict with the actual prerendered routes.\n                        let unknownPrerenderRoutes = [];\n                        let knownPrerenderRoutes = [];\n                        for (const prerenderedRoute of prerenderedRoutes){\n                            if (prerenderedRoute.fallbackRouteParams && prerenderedRoute.fallbackRouteParams.length > 0) {\n                                unknownPrerenderRoutes.push(prerenderedRoute);\n                            } else {\n                                knownPrerenderRoutes.push(prerenderedRoute);\n                            }\n                        }\n                        unknownPrerenderRoutes = (0, _utils.getSortedRouteObjects)(unknownPrerenderRoutes, (prerenderedRoute)=>prerenderedRoute.pathname);\n                        knownPrerenderRoutes = (0, _utils.getSortedRouteObjects)(knownPrerenderRoutes, (prerenderedRoute)=>prerenderedRoute.pathname);\n                        prerenderedRoutes = [\n                            ...knownPrerenderRoutes,\n                            ...unknownPrerenderRoutes\n                        ];\n                        for (const prerenderedRoute of prerenderedRoutes){\n                            // TODO: check if still needed?\n                            // Exclude the /_not-found route.\n                            if (prerenderedRoute.pathname === _constants1.UNDERSCORE_NOT_FOUND_ROUTE) {\n                                continue;\n                            }\n                            if (isRoutePPREnabled && prerenderedRoute.fallbackRouteParams && prerenderedRoute.fallbackRouteParams.length > 0) {\n                                // If the route has unknown params, then we need to add it to\n                                // the list of dynamic routes.\n                                dynamicRoutes.push(prerenderedRoute);\n                            } else {\n                                // If the route doesn't have unknown params, then we need to\n                                // add it to the list of routes.\n                                routes.push(prerenderedRoute);\n                            }\n                        }\n                        // Handle all the static routes.\n                        for (const route of routes){\n                            if ((0, _utils.isDynamicRoute)(page) && route.pathname === page) continue;\n                            if (route.pathname === _constants1.UNDERSCORE_NOT_FOUND_ROUTE) continue;\n                            const { metadata = {}, hasEmptyPrelude, hasPostponed } = exportResult.byPath.get(route.pathname) ?? {};\n                            const cacheControl = getCacheControl(route.pathname, appConfig.revalidate);\n                            pageInfos.set(route.pathname, {\n                                ...pageInfos.get(route.pathname),\n                                hasPostponed,\n                                hasEmptyPrelude,\n                                initialCacheControl: cacheControl\n                            });\n                            // update the page (eg /blog/[slug]) to also have the postpone metadata\n                            pageInfos.set(page, {\n                                ...pageInfos.get(page),\n                                hasPostponed,\n                                hasEmptyPrelude,\n                                initialCacheControl: cacheControl\n                            });\n                            if (cacheControl.revalidate !== 0) {\n                                const normalizedRoute = (0, _normalizepagepath.normalizePagePath)(route.pathname);\n                                let dataRoute;\n                                if (isAppRouteHandler) {\n                                    dataRoute = null;\n                                } else {\n                                    dataRoute = _path.default.posix.join(`${normalizedRoute}${_constants.RSC_SUFFIX}`);\n                                }\n                                let prefetchDataRoute;\n                                // While we may only write the `.rsc` when the route does not\n                                // have PPR enabled, we still want to generate the route when\n                                // deployed so it doesn't 404. If the app has PPR enabled, we\n                                // should add this key.\n                                if (!isAppRouteHandler && isAppPPREnabled) {\n                                    prefetchDataRoute = _path.default.posix.join(`${normalizedRoute}${_constants.RSC_PREFETCH_SUFFIX}`);\n                                }\n                                const meta = (0, _utils1.collectMeta)(metadata);\n                                prerenderManifest.routes[route.pathname] = {\n                                    initialStatus: meta.status,\n                                    initialHeaders: meta.headers,\n                                    renderingMode: isAppPPREnabled ? isRoutePPREnabled ? _renderingmode.RenderingMode.PARTIALLY_STATIC : _renderingmode.RenderingMode.STATIC : undefined,\n                                    experimentalPPR: isRoutePPREnabled,\n                                    experimentalBypassFor: bypassFor,\n                                    initialRevalidateSeconds: cacheControl.revalidate,\n                                    initialExpireSeconds: cacheControl.expire,\n                                    srcRoute: page,\n                                    dataRoute,\n                                    prefetchDataRoute,\n                                    allowHeader: ALLOWED_HEADERS\n                                };\n                            } else {\n                                hasRevalidateZero = true;\n                                // we might have determined during prerendering that this page\n                                // used dynamic data\n                                pageInfos.set(route.pathname, {\n                                    ...pageInfos.get(route.pathname),\n                                    isSSG: false,\n                                    isStatic: false\n                                });\n                            }\n                        }\n                        if (!hasRevalidateZero && (0, _utils.isDynamicRoute)(page)) {\n                            // When PPR fallbacks aren't used, we need to include it here. If\n                            // they are enabled, then it'll already be included in the\n                            // prerendered routes.\n                            if (!isRoutePPREnabled) {\n                                dynamicRoutes.push({\n                                    pathname: page,\n                                    encodedPathname: page,\n                                    fallbackRouteParams: undefined,\n                                    fallbackMode: fallbackModes.get(originalAppPath) ?? _fallback.FallbackMode.NOT_FOUND,\n                                    fallbackRootParams: undefined\n                                });\n                            }\n                            for (const route of dynamicRoutes){\n                                var _exportResult_byPath_get, _route_fallbackRouteParams;\n                                const normalizedRoute = (0, _normalizepagepath.normalizePagePath)(route.pathname);\n                                const metadata = (_exportResult_byPath_get = exportResult.byPath.get(route.pathname)) == null ? void 0 : _exportResult_byPath_get.metadata;\n                                const cacheControl = getCacheControl(route.pathname);\n                                let dataRoute = null;\n                                if (!isAppRouteHandler) {\n                                    dataRoute = _path.default.posix.join(`${normalizedRoute}${_constants.RSC_SUFFIX}`);\n                                }\n                                let prefetchDataRoute;\n                                if (!isAppRouteHandler && isAppPPREnabled) {\n                                    prefetchDataRoute = _path.default.posix.join(`${normalizedRoute}${_constants.RSC_PREFETCH_SUFFIX}`);\n                                }\n                                if (!isAppRouteHandler && (metadata == null ? void 0 : metadata.segmentPaths)) {\n                                    const dynamicRoute = routesManifest.dynamicRoutes.find((r)=>r.page === page);\n                                    if (!dynamicRoute) {\n                                        throw Object.defineProperty(new Error('Dynamic route not found'), \"__NEXT_ERROR_CODE\", {\n                                            value: \"E633\",\n                                            enumerable: false,\n                                            configurable: true\n                                        });\n                                    }\n                                    dynamicRoute.prefetchSegmentDataRoutes ??= [];\n                                    for (const segmentPath of metadata.segmentPaths){\n                                        const result = (0, _buildprefetchsegmentdataroute.buildPrefetchSegmentDataRoute)(route.pathname, segmentPath);\n                                        dynamicRoute.prefetchSegmentDataRoutes.push(result);\n                                    }\n                                }\n                                pageInfos.set(route.pathname, {\n                                    ...pageInfos.get(route.pathname),\n                                    isDynamicAppRoute: true,\n                                    // if PPR is turned on and the route contains a dynamic segment,\n                                    // we assume it'll be partially prerendered\n                                    hasPostponed: isRoutePPREnabled\n                                });\n                                const fallbackMode = route.fallbackMode ?? _fallback.FallbackMode.NOT_FOUND;\n                                // When the route is configured to serve a prerender, we should\n                                // use the cache control from the export result. If it can't be\n                                // found, mark that we should keep the shell forever\n                                // (revalidate: `false` via `getCacheControl()`).\n                                const fallbackCacheControl = isRoutePPREnabled && fallbackMode === _fallback.FallbackMode.PRERENDER ? cacheControl : undefined;\n                                const fallback = (0, _fallback.fallbackModeToFallbackField)(fallbackMode, route.pathname);\n                                const meta = metadata && isRoutePPREnabled && fallbackMode === _fallback.FallbackMode.PRERENDER ? (0, _utils1.collectMeta)(metadata) : {};\n                                prerenderManifest.dynamicRoutes[route.pathname] = {\n                                    experimentalPPR: isRoutePPREnabled,\n                                    renderingMode: isAppPPREnabled ? isRoutePPREnabled ? _renderingmode.RenderingMode.PARTIALLY_STATIC : _renderingmode.RenderingMode.STATIC : undefined,\n                                    experimentalBypassFor: bypassFor,\n                                    routeRegex: (0, _loadcustomroutes.normalizeRouteRegex)((0, _routeregex.getNamedRouteRegex)(route.pathname, {\n                                        prefixRouteKeys: false\n                                    }).re.source),\n                                    dataRoute,\n                                    fallback,\n                                    fallbackRevalidate: fallbackCacheControl == null ? void 0 : fallbackCacheControl.revalidate,\n                                    fallbackExpire: fallbackCacheControl == null ? void 0 : fallbackCacheControl.expire,\n                                    fallbackStatus: meta.status,\n                                    fallbackHeaders: meta.headers,\n                                    fallbackRootParams: route.fallbackRootParams,\n                                    fallbackSourceRoute: ((_route_fallbackRouteParams = route.fallbackRouteParams) == null ? void 0 : _route_fallbackRouteParams.length) ? page : undefined,\n                                    dataRouteRegex: !dataRoute ? null : (0, _loadcustomroutes.normalizeRouteRegex)((0, _routeregex.getNamedRouteRegex)(dataRoute, {\n                                        prefixRouteKeys: false,\n                                        includeSuffix: true,\n                                        excludeOptionalTrailingSlash: true\n                                    }).re.source),\n                                    prefetchDataRoute,\n                                    prefetchDataRouteRegex: !prefetchDataRoute ? undefined : (0, _loadcustomroutes.normalizeRouteRegex)((0, _routeregex.getNamedRouteRegex)(prefetchDataRoute, {\n                                        prefixRouteKeys: false,\n                                        includeSuffix: true,\n                                        excludeOptionalTrailingSlash: true\n                                    }).re.source),\n                                    allowHeader: ALLOWED_HEADERS\n                                };\n                            }\n                        }\n                    });\n                    const moveExportedPage = async (originPage, page, file, isSsg, ext, additionalSsgFile = false)=>{\n                        return staticGenerationSpan.traceChild('move-exported-page').traceAsyncFn(async ()=>{\n                            file = `${file}.${ext}`;\n                            const orig = _path.default.join(outdir, file);\n                            const pagePath = (0, _require.getPagePath)(originPage, distDir, undefined, false);\n                            const relativeDest = _path.default.relative(_path.default.join(distDir, _constants1.SERVER_DIRECTORY), _path.default.join(_path.default.join(pagePath, // strip leading / and then recurse number of nested dirs\n                            // to place from base folder\n                            originPage.slice(1).split('/').map(()=>'..').join('/')), file)).replace(/\\\\/g, '/');\n                            if (!isSsg && !// don't add static status page to manifest if it's\n                            // the default generated version e.g. no pages/500\n                            (_constants1.STATIC_STATUS_PAGES.includes(page) && !usedStaticStatusPages.includes(page))) {\n                                pagesManifest[page] = relativeDest;\n                            }\n                            const dest = _path.default.join(distDir, _constants1.SERVER_DIRECTORY, relativeDest);\n                            const isNotFound = prerenderManifest.notFoundRoutes.includes(page);\n                            // for SSG files with i18n the non-prerendered variants are\n                            // output with the locale prefixed so don't attempt moving\n                            // without the prefix\n                            if ((!i18n || additionalSsgFile) && !isNotFound) {\n                                await _fs.promises.mkdir(_path.default.dirname(dest), {\n                                    recursive: true\n                                });\n                                await _fs.promises.rename(orig, dest);\n                            } else if (i18n && !isSsg) {\n                                // this will be updated with the locale prefixed variant\n                                // since all files are output with the locale prefix\n                                delete pagesManifest[page];\n                            }\n                            if (i18n) {\n                                if (additionalSsgFile) return;\n                                const localeExt = page === '/' ? _path.default.extname(file) : '';\n                                const relativeDestNoPages = relativeDest.slice('pages/'.length);\n                                for (const locale of i18n.locales){\n                                    const curPath = `/${locale}${page === '/' ? '' : page}`;\n                                    if (isSsg && prerenderManifest.notFoundRoutes.includes(curPath)) {\n                                        continue;\n                                    }\n                                    const updatedRelativeDest = _path.default.join('pages', locale + localeExt, // if it's the top-most index page we want it to be locale.EXT\n                                    // instead of locale/index.html\n                                    page === '/' ? '' : relativeDestNoPages).replace(/\\\\/g, '/');\n                                    const updatedOrig = _path.default.join(outdir, locale + localeExt, page === '/' ? '' : file);\n                                    const updatedDest = _path.default.join(distDir, _constants1.SERVER_DIRECTORY, updatedRelativeDest);\n                                    if (!isSsg) {\n                                        pagesManifest[curPath] = updatedRelativeDest;\n                                    }\n                                    await _fs.promises.mkdir(_path.default.dirname(updatedDest), {\n                                        recursive: true\n                                    });\n                                    await _fs.promises.rename(updatedOrig, updatedDest);\n                                }\n                            }\n                        });\n                    };\n                    async function moveExportedAppNotFoundTo404() {\n                        return staticGenerationSpan.traceChild('move-exported-app-not-found-').traceAsyncFn(async ()=>{\n                            const orig = _path.default.join(distDir, 'server', 'app', '_not-found.html');\n                            const updatedRelativeDest = _path.default.join('pages', '404.html').replace(/\\\\/g, '/');\n                            if ((0, _fs.existsSync)(orig)) {\n                                await _fs.promises.copyFile(orig, _path.default.join(distDir, 'server', updatedRelativeDest));\n                                pagesManifest['/404'] = updatedRelativeDest;\n                            }\n                        });\n                    }\n                    // If there's /not-found inside app, we prefer it over the pages 404\n                    if (hasStaticApp404) {\n                        await moveExportedAppNotFoundTo404();\n                    } else {\n                        // Only move /404 to /404 when there is no custom 404 as in that case we don't know about the 404 page\n                        if (!hasPages404 && !hasApp404 && useStaticPages404) {\n                            await moveExportedPage('/_error', '/404', '/404', false, 'html');\n                        }\n                    }\n                    if (useDefaultStatic500) {\n                        await moveExportedPage('/_error', '/500', '/500', false, 'html');\n                    }\n                    for (const page of combinedPages){\n                        const isSsg = ssgPages.has(page);\n                        const isStaticSsgFallback = ssgStaticFallbackPages.has(page);\n                        const isDynamic = (0, _utils.isDynamicRoute)(page);\n                        const hasAmp = hybridAmpPages.has(page);\n                        const file = (0, _normalizepagepath.normalizePagePath)(page);\n                        const pageInfo = pageInfos.get(page);\n                        const durationInfo = exportResult.byPage.get(page);\n                        if (pageInfo && durationInfo) {\n                            // Set Build Duration\n                            if (pageInfo.ssgPageRoutes) {\n                                pageInfo.ssgPageDurations = pageInfo.ssgPageRoutes.map((pagePath)=>{\n                                    const duration = durationInfo.durationsByPath.get(pagePath);\n                                    if (typeof duration === 'undefined') {\n                                        throw Object.defineProperty(new Error(\"Invariant: page wasn't built\"), \"__NEXT_ERROR_CODE\", {\n                                            value: \"E239\",\n                                            enumerable: false,\n                                            configurable: true\n                                        });\n                                    }\n                                    return duration;\n                                });\n                            }\n                            pageInfo.pageDuration = durationInfo.durationsByPath.get(page);\n                        }\n                        // The dynamic version of SSG pages are only prerendered if the\n                        // fallback is enabled. Below, we handle the specific prerenders\n                        // of these.\n                        const hasHtmlOutput = !(isSsg && isDynamic && !isStaticSsgFallback);\n                        if (hasHtmlOutput) {\n                            await moveExportedPage(page, page, file, isSsg, 'html');\n                        }\n                        if (hasAmp && (!isSsg || isSsg && !isDynamic)) {\n                            const ampPage = `${file}.amp`;\n                            await moveExportedPage(page, ampPage, ampPage, isSsg, 'html');\n                            if (isSsg) {\n                                await moveExportedPage(page, ampPage, ampPage, isSsg, 'json');\n                            }\n                        }\n                        if (isSsg) {\n                            // For a non-dynamic SSG page, we must copy its data file\n                            // from export, we already moved the HTML file above\n                            if (!isDynamic) {\n                                await moveExportedPage(page, page, file, isSsg, 'json');\n                                if (i18n) {\n                                    // TODO: do we want to show all locale variants in build output\n                                    for (const locale of i18n.locales){\n                                        const localePage = `/${locale}${page === '/' ? '' : page}`;\n                                        const cacheControl = getCacheControl(localePage);\n                                        prerenderManifest.routes[localePage] = {\n                                            initialRevalidateSeconds: cacheControl.revalidate,\n                                            initialExpireSeconds: cacheControl.expire,\n                                            experimentalPPR: undefined,\n                                            renderingMode: undefined,\n                                            srcRoute: null,\n                                            dataRoute: _path.default.posix.join('/_next/data', buildId, `${file}.json`),\n                                            prefetchDataRoute: undefined,\n                                            allowHeader: ALLOWED_HEADERS\n                                        };\n                                    }\n                                } else {\n                                    const cacheControl = getCacheControl(page);\n                                    prerenderManifest.routes[page] = {\n                                        initialRevalidateSeconds: cacheControl.revalidate,\n                                        initialExpireSeconds: cacheControl.expire,\n                                        experimentalPPR: undefined,\n                                        renderingMode: undefined,\n                                        srcRoute: null,\n                                        dataRoute: _path.default.posix.join('/_next/data', buildId, `${file}.json`),\n                                        // Pages does not have a prefetch data route.\n                                        prefetchDataRoute: undefined,\n                                        allowHeader: ALLOWED_HEADERS\n                                    };\n                                }\n                                if (pageInfo) {\n                                    pageInfo.initialCacheControl = getCacheControl(page);\n                                }\n                            } else {\n                                // For a dynamic SSG page, we did not copy its data exports and only\n                                // copy the fallback HTML file (if present).\n                                // We must also copy specific versions of this page as defined by\n                                // `getStaticPaths` (additionalSsgPaths).\n                                for (const route of additionalPaths.get(page) ?? []){\n                                    const pageFile = (0, _normalizepagepath.normalizePagePath)(route.pathname);\n                                    await moveExportedPage(page, route.pathname, pageFile, isSsg, 'html', true);\n                                    await moveExportedPage(page, route.pathname, pageFile, isSsg, 'json', true);\n                                    if (hasAmp) {\n                                        const ampPage = `${pageFile}.amp`;\n                                        await moveExportedPage(page, ampPage, ampPage, isSsg, 'html', true);\n                                        await moveExportedPage(page, ampPage, ampPage, isSsg, 'json', true);\n                                    }\n                                    const cacheControl = getCacheControl(route.pathname);\n                                    prerenderManifest.routes[route.pathname] = {\n                                        initialRevalidateSeconds: cacheControl.revalidate,\n                                        initialExpireSeconds: cacheControl.expire,\n                                        experimentalPPR: undefined,\n                                        renderingMode: undefined,\n                                        srcRoute: page,\n                                        dataRoute: _path.default.posix.join('/_next/data', buildId, `${(0, _normalizepagepath.normalizePagePath)(route.pathname)}.json`),\n                                        // Pages does not have a prefetch data route.\n                                        prefetchDataRoute: undefined,\n                                        allowHeader: ALLOWED_HEADERS\n                                    };\n                                    if (pageInfo) {\n                                        pageInfo.initialCacheControl = cacheControl;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    // remove temporary export folder\n                    await _fs.promises.rm(outdir, {\n                        recursive: true,\n                        force: true\n                    });\n                    await writeManifest(pagesManifestPath, pagesManifest);\n                });\n                // We need to write the manifest with rewrites after build as it might\n                // have been modified.\n                await nextBuildSpan.traceChild('write-routes-manifest').traceAsyncFn(()=>writeManifest(routesManifestPath, routesManifest));\n            }\n            const postBuildSpinner = (0, _spinner.default)('Finalizing page optimization');\n            let buildTracesSpinner = (0, _spinner.default)(`Collecting build traces`);\n            // ensure the worker is not left hanging\n            worker.end();\n            const analysisEnd = process.hrtime(analysisBegin);\n            telemetry.record((0, _events.eventBuildOptimize)(pagesPaths, {\n                durationInSeconds: analysisEnd[0],\n                staticPageCount: staticPages.size,\n                staticPropsPageCount: ssgPages.size,\n                serverPropsPageCount: serverPropsPages.size,\n                ssrPageCount: pagesPaths.length - (staticPages.size + ssgPages.size + serverPropsPages.size),\n                hasStatic404: useStaticPages404,\n                hasReportWebVitals: (namedExports == null ? void 0 : namedExports.includes('reportWebVitals')) ?? false,\n                rewritesCount: combinedRewrites.length,\n                headersCount: headers.length,\n                redirectsCount: redirects.length - 1,\n                headersWithHasCount: headers.filter((r)=>!!r.has).length,\n                rewritesWithHasCount: combinedRewrites.filter((r)=>!!r.has).length,\n                redirectsWithHasCount: redirects.filter((r)=>!!r.has).length,\n                middlewareCount: hasMiddlewareFile ? 1 : 0,\n                totalAppPagesCount,\n                staticAppPagesCount,\n                serverAppPagesCount,\n                edgeRuntimeAppCount,\n                edgeRuntimePagesCount\n            }));\n            if (_buildcontext.NextBuildContext.telemetryState) {\n                const events = (0, _events.eventBuildFeatureUsage)(_buildcontext.NextBuildContext.telemetryState.usages);\n                telemetry.record(events);\n                telemetry.record((0, _events.eventPackageUsedInGetServerSideProps)(_buildcontext.NextBuildContext.telemetryState.packagesUsedInServerSideProps));\n                const useCacheTracker = _buildcontext.NextBuildContext.telemetryState.useCacheTracker;\n                for (const [key, value] of Object.entries(useCacheTracker)){\n                    telemetry.record((0, _events.eventBuildFeatureUsage)([\n                        {\n                            featureName: key,\n                            invocationCount: value\n                        }\n                    ]));\n                }\n            }\n            if (ssgPages.size > 0 || appDir) {\n                var _config_i18n;\n                tbdPrerenderRoutes.forEach((tbdRoute)=>{\n                    const normalizedRoute = (0, _normalizepagepath.normalizePagePath)(tbdRoute);\n                    const dataRoute = _path.default.posix.join('/_next/data', buildId, `${normalizedRoute}.json`);\n                    prerenderManifest.dynamicRoutes[tbdRoute] = {\n                        routeRegex: (0, _loadcustomroutes.normalizeRouteRegex)((0, _routeregex.getNamedRouteRegex)(tbdRoute, {\n                            prefixRouteKeys: false\n                        }).re.source),\n                        experimentalPPR: undefined,\n                        renderingMode: undefined,\n                        dataRoute,\n                        fallback: ssgBlockingFallbackPages.has(tbdRoute) ? null : ssgStaticFallbackPages.has(tbdRoute) ? `${normalizedRoute}.html` : false,\n                        fallbackRevalidate: undefined,\n                        fallbackExpire: undefined,\n                        fallbackSourceRoute: undefined,\n                        fallbackRootParams: undefined,\n                        dataRouteRegex: (0, _loadcustomroutes.normalizeRouteRegex)((0, _routeregex.getNamedRouteRegex)(dataRoute, {\n                            prefixRouteKeys: true,\n                            includeSuffix: true,\n                            excludeOptionalTrailingSlash: true\n                        }).re.source),\n                        // Pages does not have a prefetch data route.\n                        prefetchDataRoute: undefined,\n                        prefetchDataRouteRegex: undefined,\n                        allowHeader: ALLOWED_HEADERS\n                    };\n                });\n                _buildcontext.NextBuildContext.previewModeId = previewProps.previewModeId;\n                _buildcontext.NextBuildContext.fetchCacheKeyPrefix = config.experimental.fetchCacheKeyPrefix;\n                _buildcontext.NextBuildContext.allowedRevalidateHeaderKeys = config.experimental.allowedRevalidateHeaderKeys;\n                await writePrerenderManifest(distDir, prerenderManifest);\n                await writeClientSsgManifest(prerenderManifest, {\n                    distDir,\n                    buildId,\n                    locales: (_config_i18n = config.i18n) == null ? void 0 : _config_i18n.locales\n                });\n            } else {\n                await writePrerenderManifest(distDir, {\n                    version: 4,\n                    routes: {},\n                    dynamicRoutes: {},\n                    preview: previewProps,\n                    notFoundRoutes: []\n                });\n            }\n            await writeImagesManifest(distDir, config);\n            await writeManifest(_path.default.join(distDir, _constants1.EXPORT_MARKER), {\n                version: 1,\n                hasExportPathMap: typeof config.exportPathMap === 'function',\n                exportTrailingSlash: config.trailingSlash === true,\n                isNextImageImported: isNextImageImported === true\n            });\n            await _fs.promises.unlink(_path.default.join(distDir, _constants1.EXPORT_DETAIL)).catch((err)=>{\n                if (err.code === 'ENOENT') {\n                    return Promise.resolve();\n                }\n                return Promise.reject(err);\n            });\n            if (Boolean(config.experimental.nextScriptWorkers)) {\n                await nextBuildSpan.traceChild('verify-partytown-setup').traceAsyncFn(async ()=>{\n                    await (0, _verifypartytownsetup.verifyPartytownSetup)(dir, _path.default.join(distDir, _constants1.CLIENT_STATIC_FILES_PATH));\n                });\n            }\n            await buildTracesPromise;\n            if (buildTracesSpinner) {\n                buildTracesSpinner.stopAndPersist();\n                buildTracesSpinner = undefined;\n            }\n            if (isCompileMode) {\n                _log.info(`Build ran with \"compile\" mode, to finalize the build run either \"generate\" or \"generate-env\" mode as well`);\n            }\n            if (config.output === 'export') {\n                await writeFullyStaticExport(config, dir, enabledDirectories, configOutDir, nextBuildSpan);\n            }\n            if (config.output === 'standalone') {\n                await writeStandaloneDirectory(nextBuildSpan, distDir, pageKeys, denormalizedAppPages, outputFileTracingRoot, requiredServerFilesManifest, middlewareManifest, hasNodeMiddleware, hasInstrumentationHook, staticPages, loadedEnvFiles, appDir);\n            }\n            if (postBuildSpinner) postBuildSpinner.stopAndPersist();\n            console.log();\n            if (debugOutput) {\n                nextBuildSpan.traceChild('print-custom-routes').traceFn(()=>(0, _utils1.printCustomRoutes)({\n                        redirects,\n                        rewrites,\n                        headers\n                    }));\n            }\n            await nextBuildSpan.traceChild('print-tree-view').traceAsyncFn(()=>(0, _utils1.printTreeView)(pageKeys, pageInfos, {\n                    distPath: distDir,\n                    buildId: buildId,\n                    pagesDir,\n                    useStaticPages404,\n                    pageExtensions: config.pageExtensions,\n                    appBuildManifest,\n                    buildManifest,\n                    middlewareManifest,\n                    gzipSize: config.experimental.gzipSize\n                }));\n            await nextBuildSpan.traceChild('telemetry-flush').traceAsyncFn(()=>telemetry.flush());\n            await shutdownPromise;\n        });\n    } catch (e) {\n        const telemetry = _shared.traceGlobals.get('telemetry');\n        if (telemetry) {\n            telemetry.record((0, _events.eventBuildFailed)({\n                bundler: getBundlerForTelemetry(isTurbopack),\n                errorCode: getErrorCodeForTelemetry(e),\n                durationInSeconds: Math.floor((Date.now() - buildStartTime) / 1000)\n            }));\n        }\n        throw e;\n    } finally{\n        // Ensure we wait for lockfile patching if present\n        await _swc.lockfilePatchPromise.cur;\n        if (isTurbopack && !process.env.__NEXT_TEST_MODE) {\n            warnAboutTurbopackBuilds(loadedConfig);\n        }\n        // Ensure all traces are flushed before finishing the command\n        await (0, _trace.flushAllTraces)();\n        (0, _swc.teardownTraceSubscriber)();\n        if (traceUploadUrl && loadedConfig) {\n            (0, _uploadtrace.default)({\n                traceUploadUrl,\n                mode: 'build',\n                projectDir: dir,\n                distDir: loadedConfig.distDir,\n                isTurboSession: isTurbopack,\n                sync: true\n            });\n        }\n    }\n}\nfunction warnAboutTurbopackBuilds(config) {\n    let warningStr = `Support for Turbopack builds is experimental. ` + (0, _picocolors.bold)(`We don't recommend deploying mission-critical applications to production.`);\n    warningStr += '\\n\\n- ' + (0, _picocolors.bold)('Turbopack currently always builds production sourcemaps for the browser. This will include project sourcecode if deployed to production.');\n    warningStr += '\\n- It is expected that your bundle size might be different from `next build` with webpack. This will be improved as we work towards stability.';\n    if (!(config == null ? void 0 : config.experimental.turbopackPersistentCaching)) {\n        warningStr += '\\n- This build is without disk caching; subsequent builds will become faster when disk caching becomes available.';\n    }\n    warningStr += '\\n- When comparing output to webpack builds, make sure to first clear the Next.js cache by deleting the `.next` directory.';\n    warningStr += '\\n\\nProvide feedback for Turbopack builds at https://github.com/vercel/next.js/discussions/77721';\n    _log.warn(warningStr);\n}\nfunction getBundlerForTelemetry(isTurbopack) {\n    if (isTurbopack) {\n        return 'turbopack';\n    }\n    if (process.env.NEXT_RSPACK) {\n        return 'rspack';\n    }\n    return 'webpack';\n}\nfunction getErrorCodeForTelemetry(err) {\n    const code = (0, _errortelemetryutils.extractNextErrorCode)(err);\n    if (code != null) {\n        return code;\n    }\n    if (err instanceof Error && 'code' in err && typeof err.code === 'string') {\n        return err.code;\n    }\n    if (err instanceof Error) {\n        return err.name;\n    }\n    return 'Unknown';\n}\n\n//# sourceMappingURL=index.js.map"
        }
    ]
}