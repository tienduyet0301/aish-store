{
    "sourceFile": "node_modules/next/dist/build/segment-config/app/app-segments.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892659582,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"collectSegments\", {\n    enumerable: true,\n    get: function() {\n        return collectSegments;\n    }\n});\nconst _appsegmentconfig = require(\"./app-segment-config\");\nconst _invarianterror = require(\"../../../shared/lib/invariant-error\");\nconst _checks = require(\"../../../server/route-modules/checks\");\nconst _clientandserverreferences = require(\"../../../lib/client-and-server-references\");\nconst _getsegmentparam = require(\"../../../server/app-render/get-segment-param\");\nconst _appdirmodule = require(\"../../../server/lib/app-dir-module\");\nconst _segment = require(\"../../../shared/lib/segment\");\n/**\n * Parses the app config and attaches it to the segment.\n */ function attach(segment, userland, route) {\n    // If the userland is not an object, then we can't do anything with it.\n    if (typeof userland !== 'object' || userland === null) {\n        return;\n    }\n    // Try to parse the application configuration.\n    const config = (0, _appsegmentconfig.parseAppSegmentConfig)(userland, route);\n    // If there was any keys on the config, then attach it to the segment.\n    if (Object.keys(config).length > 0) {\n        segment.config = config;\n    }\n    if ('generateStaticParams' in userland && typeof userland.generateStaticParams === 'function') {\n        var _segment_config;\n        segment.generateStaticParams = userland.generateStaticParams;\n        // Validate that `generateStaticParams` makes sense in this context.\n        if (((_segment_config = segment.config) == null ? void 0 : _segment_config.runtime) === 'edge') {\n            throw Object.defineProperty(new Error('Edge runtime is not supported with `generateStaticParams`.'), \"__NEXT_ERROR_CODE\", {\n                value: \"E502\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n    }\n}\n/**\n * Walks the loader tree and collects the generate parameters for each segment.\n *\n * @param routeModule the app page route module\n * @returns the segments for the app page route module\n */ async function collectAppPageSegments(routeModule) {\n    // We keep track of unique segments, since with parallel routes, it's possible\n    // to see the same segment multiple times.\n    const uniqueSegments = new Map();\n    const queue = [\n        [\n            routeModule.userland.loaderTree,\n            []\n        ]\n    ];\n    while(queue.length > 0){\n        var _getSegmentParam;\n        const [loaderTree, currentSegments] = queue.shift();\n        const [name, parallelRoutes] = loaderTree;\n        // Process current node\n        const { mod: userland, filePath } = await (0, _appdirmodule.getLayoutOrPageModule)(loaderTree);\n        const isClientComponent = userland && (0, _clientandserverreferences.isClientReference)(userland);\n        const param = (_getSegmentParam = (0, _getsegmentparam.getSegmentParam)(name)) == null ? void 0 : _getSegmentParam.param;\n        const segment = {\n            name,\n            param,\n            filePath,\n            config: undefined,\n            isDynamicSegment: !!param,\n            generateStaticParams: undefined\n        };\n        // Only server components can have app segment configurations\n        if (!isClientComponent) {\n            attach(segment, userland, routeModule.definition.pathname);\n        }\n        // Create a unique key for the segment\n        const segmentKey = getSegmentKey(segment);\n        if (!uniqueSegments.has(segmentKey)) {\n            uniqueSegments.set(segmentKey, segment);\n        }\n        const updatedSegments = [\n            ...currentSegments,\n            segment\n        ];\n        // If this is a page segment, we've reached a leaf node\n        if (name === _segment.PAGE_SEGMENT_KEY) {\n            // Add all segments in the current path\n            updatedSegments.forEach((seg)=>{\n                const key = getSegmentKey(seg);\n                uniqueSegments.set(key, seg);\n            });\n        }\n        // Add all parallel routes to the queue\n        for(const parallelRouteKey in parallelRoutes){\n            const parallelRoute = parallelRoutes[parallelRouteKey];\n            queue.push([\n                parallelRoute,\n                updatedSegments\n            ]);\n        }\n    }\n    return Array.from(uniqueSegments.values());\n}\nfunction getSegmentKey(segment) {\n    return `${segment.name}-${segment.filePath ?? ''}-${segment.param ?? ''}`;\n}\n/**\n * Collects the segments for a given app route module.\n *\n * @param routeModule the app route module\n * @returns the segments for the app route module\n */ function collectAppRouteSegments(routeModule) {\n    // Get the pathname parts, slice off the first element (which is empty).\n    const parts = routeModule.definition.pathname.split('/').slice(1);\n    if (parts.length === 0) {\n        throw Object.defineProperty(new _invarianterror.InvariantError('Expected at least one segment'), \"__NEXT_ERROR_CODE\", {\n            value: \"E580\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    // Generate all the segments.\n    const segments = parts.map((name)=>{\n        var _getSegmentParam;\n        const param = (_getSegmentParam = (0, _getsegmentparam.getSegmentParam)(name)) == null ? void 0 : _getSegmentParam.param;\n        return {\n            name,\n            param,\n            filePath: undefined,\n            isDynamicSegment: !!param,\n            config: undefined,\n            generateStaticParams: undefined\n        };\n    });\n    // We know we have at least one, we verified this above. We should get the\n    // last segment which represents the root route module.\n    const segment = segments[segments.length - 1];\n    segment.filePath = routeModule.definition.filename;\n    // Extract the segment config from the userland module.\n    attach(segment, routeModule.userland, routeModule.definition.pathname);\n    return segments;\n}\nfunction collectSegments({ routeModule }) {\n    if ((0, _checks.isAppRouteRouteModule)(routeModule)) {\n        return collectAppRouteSegments(routeModule);\n    }\n    if ((0, _checks.isAppPageRouteModule)(routeModule)) {\n        return collectAppPageSegments(routeModule);\n    }\n    throw Object.defineProperty(new _invarianterror.InvariantError('Expected a route module to be one of app route or page'), \"__NEXT_ERROR_CODE\", {\n        value: \"E568\",\n        enumerable: false,\n        configurable: true\n    });\n}\n\n//# sourceMappingURL=app-segments.js.map"
        }
    ]
}