{
    "sourceFile": "node_modules/next/dist/build/utils.d.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892663478,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import type { NextConfigComplete } from '../server/config-shared';\nimport type { ExperimentalPPRConfig } from '../server/lib/experimental/ppr';\nimport type { AppBuildManifest } from './webpack/plugins/app-build-manifest-plugin';\nimport type { ServerRuntime } from '../types';\nimport type { BuildManifest } from '../server/get-page-files';\nimport type { CustomRoutes } from '../lib/load-custom-routes';\nimport type { MiddlewareManifest } from './webpack/plugins/middleware-plugin';\nimport type { WebpackLayerName } from '../lib/constants';\nimport '../server/require-hook';\nimport '../server/node-polyfill-crypto';\nimport '../server/node-environment';\nimport type { PageExtensions } from './page-extensions-type';\nimport type { FallbackMode } from '../lib/fallback';\nimport type { OutgoingHttpHeaders } from 'http';\nimport type { AppSegmentConfig } from './segment-config/app/app-segment-config';\nimport type { AppSegment } from './segment-config/app/app-segments';\nimport type { PrerenderedRoute } from './static-paths/types';\nimport type { CacheControl } from '../server/lib/cache-control';\nexport type ROUTER_TYPE = 'pages' | 'app';\nexport declare function unique<T>(main: ReadonlyArray<T>, sub: ReadonlyArray<T>): T[];\nexport declare function difference<T>(main: ReadonlyArray<T> | ReadonlySet<T>, sub: ReadonlyArray<T> | ReadonlySet<T>): T[];\ntype ComputeFilesGroup = {\n    files: ReadonlyArray<string>;\n    size: {\n        total: number;\n    };\n};\ntype ComputeFilesManifest = {\n    unique: ComputeFilesGroup;\n    common: ComputeFilesGroup;\n};\ntype ComputeFilesManifestResult = {\n    router: {\n        pages: ComputeFilesManifest;\n        app?: ComputeFilesManifest;\n    };\n    sizes: Map<string, number>;\n};\nexport declare function computeFromManifest(manifests: {\n    build: BuildManifest;\n    app?: AppBuildManifest;\n}, distPath: string, gzipSize?: boolean, pageInfos?: Map<string, PageInfo>): Promise<ComputeFilesManifestResult>;\nexport declare function isMiddlewareFilename(file?: string | null): file is \"middleware\" | \"src/middleware\";\nexport declare function isInstrumentationHookFilename(file?: string | null): file is \"instrumentation\" | \"src/instrumentation\";\nexport interface PageInfo {\n    isHybridAmp?: boolean;\n    size: number;\n    totalSize: number;\n    isStatic: boolean;\n    isSSG: boolean;\n    /**\n     * If true, it means that the route has partial prerendering enabled.\n     */\n    isRoutePPREnabled: boolean;\n    ssgPageRoutes: string[] | null;\n    initialCacheControl: CacheControl | undefined;\n    pageDuration: number | undefined;\n    ssgPageDurations: number[] | undefined;\n    runtime: ServerRuntime;\n    hasEmptyPrelude?: boolean;\n    hasPostponed?: boolean;\n    isDynamicAppRoute?: boolean;\n}\nexport type PageInfos = Map<string, PageInfo>;\nexport interface RoutesUsingEdgeRuntime {\n    [route: string]: 0;\n}\nexport declare function collectRoutesUsingEdgeRuntime(input: PageInfos): RoutesUsingEdgeRuntime;\nexport declare function printTreeView(lists: {\n    pages: ReadonlyArray<string>;\n    app: ReadonlyArray<string> | undefined;\n}, pageInfos: Map<string, PageInfo>, { distPath, buildId, pagesDir, pageExtensions, buildManifest, appBuildManifest, middlewareManifest, useStaticPages404, gzipSize, }: {\n    distPath: string;\n    buildId: string;\n    pagesDir?: string;\n    pageExtensions: PageExtensions;\n    buildManifest: BuildManifest;\n    appBuildManifest?: AppBuildManifest;\n    middlewareManifest: MiddlewareManifest;\n    useStaticPages404: boolean;\n    gzipSize?: boolean;\n}): Promise<void>;\nexport declare function printCustomRoutes({ redirects, rewrites, headers, }: CustomRoutes): void;\nexport declare function getJsPageSizeInKb(routerType: ROUTER_TYPE, page: string, distPath: string, buildManifest: BuildManifest, appBuildManifest?: AppBuildManifest, gzipSize?: boolean, cachedStats?: ComputeFilesManifestResult): Promise<[number, number]>;\ntype PageIsStaticResult = {\n    isRoutePPREnabled?: boolean;\n    isStatic?: boolean;\n    isAmpOnly?: boolean;\n    isHybridAmp?: boolean;\n    hasServerProps?: boolean;\n    hasStaticProps?: boolean;\n    prerenderedRoutes: PrerenderedRoute[] | undefined;\n    prerenderFallbackMode: FallbackMode | undefined;\n    rootParamKeys: readonly string[] | undefined;\n    isNextImageImported?: boolean;\n    traceIncludes?: string[];\n    traceExcludes?: string[];\n    appConfig?: AppSegmentConfig;\n};\nexport declare function isPageStatic({ dir, page, distDir, configFileName, runtimeEnvConfig, httpAgentOptions, locales, defaultLocale, parentId, pageRuntime, edgeInfo, pageType, dynamicIO, authInterrupts, originalAppPath, isrFlushToDisk, maxMemoryCacheSize, nextConfigOutput, cacheHandler, cacheHandlers, cacheLifeProfiles, pprConfig, buildId, sriEnabled, }: {\n    dir: string;\n    page: string;\n    distDir: string;\n    dynamicIO: boolean;\n    authInterrupts: boolean;\n    configFileName: string;\n    runtimeEnvConfig: any;\n    httpAgentOptions: NextConfigComplete['httpAgentOptions'];\n    locales?: readonly string[];\n    defaultLocale?: string;\n    parentId?: any;\n    edgeInfo?: any;\n    pageType?: 'pages' | 'app';\n    pageRuntime?: ServerRuntime;\n    originalAppPath?: string;\n    isrFlushToDisk?: boolean;\n    maxMemoryCacheSize?: number;\n    cacheHandler?: string;\n    cacheHandlers?: Record<string, string | undefined>;\n    cacheLifeProfiles?: {\n        [profile: string]: import('../server/use-cache/cache-life').CacheLife;\n    };\n    nextConfigOutput: 'standalone' | 'export' | undefined;\n    pprConfig: ExperimentalPPRConfig | undefined;\n    buildId: string;\n    sriEnabled: boolean;\n}): Promise<PageIsStaticResult>;\ntype ReducedAppConfig = Pick<AppSegmentConfig, 'revalidate' | 'dynamic' | 'fetchCache' | 'preferredRegion' | 'experimental_ppr' | 'runtime' | 'maxDuration'>;\n/**\n * Collect the app config from the generate param segments. This only gets a\n * subset of the config options.\n *\n * @param segments the generate param segments\n * @returns the reduced app config\n */\nexport declare function reduceAppConfig(segments: Pick<AppSegment, 'config'>[]): ReducedAppConfig;\nexport declare function hasCustomGetInitialProps({ page, distDir, runtimeEnvConfig, checkingApp, sriEnabled, }: {\n    page: string;\n    distDir: string;\n    runtimeEnvConfig: any;\n    checkingApp: boolean;\n    sriEnabled: boolean;\n}): Promise<boolean>;\nexport declare function getDefinedNamedExports({ page, distDir, runtimeEnvConfig, sriEnabled, }: {\n    page: string;\n    distDir: string;\n    runtimeEnvConfig: any;\n    sriEnabled: boolean;\n}): Promise<ReadonlyArray<string>>;\nexport declare function detectConflictingPaths(combinedPages: string[], ssgPages: Set<string>, additionalGeneratedSSGPaths: Map<string, string[]>): void;\nexport declare function copyTracedFiles(dir: string, distDir: string, pageKeys: readonly string[], appPageKeys: readonly string[] | undefined, tracingRoot: string, serverConfig: NextConfigComplete, middlewareManifest: MiddlewareManifest, hasNodeMiddleware: boolean, hasInstrumentationHook: boolean, staticPages: Set<string>): Promise<void>;\nexport declare function isReservedPage(page: string): boolean;\nexport declare function isAppBuiltinNotFoundPage(page: string): boolean;\nexport declare function isCustomErrorPage(page: string): page is \"/500\" | \"/404\";\nexport declare function isMiddlewareFile(file: string): file is \"/middleware\" | \"/src/middleware\";\nexport declare function isInstrumentationHookFile(file: string): file is \"/instrumentation\" | \"/src/instrumentation\";\nexport declare function getPossibleInstrumentationHookFilenames(folder: string, extensions: string[]): string[];\nexport declare function getPossibleMiddlewareFilenames(folder: string, extensions: string[]): string[];\nexport declare class NestedMiddlewareError extends Error {\n    constructor(nestedFileNames: string[], mainDir: string, pagesOrAppDir: string);\n}\nexport declare function getSupportedBrowsers(dir: string, isDevelopment: boolean): string[];\nexport declare function isWebpackServerOnlyLayer(layer: WebpackLayerName | null | undefined): boolean;\nexport declare function isWebpackClientOnlyLayer(layer: WebpackLayerName | null | undefined): boolean;\nexport declare function isWebpackDefaultLayer(layer: WebpackLayerName | null | undefined): boolean;\nexport declare function isWebpackBundledLayer(layer: WebpackLayerName | null | undefined): boolean;\nexport declare function isWebpackAppPagesLayer(layer: WebpackLayerName | null | undefined): boolean;\nexport declare function collectMeta({ status, headers, }: {\n    status?: number;\n    headers?: OutgoingHttpHeaders;\n}): {\n    status?: number;\n    headers?: Record<string, string>;\n};\nexport {};\n"
        }
    ]
}