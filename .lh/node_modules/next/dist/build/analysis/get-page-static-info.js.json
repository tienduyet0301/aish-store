{
    "sourceFile": "node_modules/next/dist/build/analysis/get-page-static-info.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892652273,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    getAppPageStaticInfo: null,\n    getMiddlewareMatchers: null,\n    getPageStaticInfo: null,\n    getPagesPageStaticInfo: null,\n    getRSCModuleInformation: null,\n    hadUnsupportedValue: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    getAppPageStaticInfo: function() {\n        return getAppPageStaticInfo;\n    },\n    getMiddlewareMatchers: function() {\n        return getMiddlewareMatchers;\n    },\n    getPageStaticInfo: function() {\n        return getPageStaticInfo;\n    },\n    getPagesPageStaticInfo: function() {\n        return getPagesPageStaticInfo;\n    },\n    getRSCModuleInformation: function() {\n        return getRSCModuleInformation;\n    },\n    hadUnsupportedValue: function() {\n        return hadUnsupportedValue;\n    }\n});\nconst _fs = require(\"fs\");\nconst _lrucache = require(\"../../server/lib/lru-cache\");\nconst _extractconstvalue = require(\"./extract-const-value\");\nconst _parsemodule = require(\"./parse-module\");\nconst _log = /*#__PURE__*/ _interop_require_wildcard(require(\"../output/log\"));\nconst _constants = require(\"../../lib/constants\");\nconst _trytoparsepath = require(\"../../lib/try-to-parse-path\");\nconst _isapiroute = require(\"../../lib/is-api-route\");\nconst _isedgeruntime = require(\"../../lib/is-edge-runtime\");\nconst _constants1 = require(\"../../shared/lib/constants\");\nconst _pagetypes = require(\"../../lib/page-types\");\nconst _appsegmentconfig = require(\"../segment-config/app/app-segment-config\");\nconst _zod = require(\"../../shared/lib/zod\");\nconst _pagessegmentconfig = require(\"../segment-config/pages/pages-segment-config\");\nconst _middlewareconfig = require(\"../segment-config/middleware/middleware-config\");\nconst _apppaths = require(\"../../shared/lib/router/utils/app-paths\");\nconst _normalizepagepath = require(\"../../shared/lib/page-path/normalize-page-path\");\nfunction _getRequireWildcardCache(nodeInterop) {\n    if (typeof WeakMap !== \"function\") return null;\n    var cacheBabelInterop = new WeakMap();\n    var cacheNodeInterop = new WeakMap();\n    return (_getRequireWildcardCache = function(nodeInterop) {\n        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n    })(nodeInterop);\n}\nfunction _interop_require_wildcard(obj, nodeInterop) {\n    if (!nodeInterop && obj && obj.__esModule) {\n        return obj;\n    }\n    if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n        return {\n            default: obj\n        };\n    }\n    var cache = _getRequireWildcardCache(nodeInterop);\n    if (cache && cache.has(obj)) {\n        return cache.get(obj);\n    }\n    var newObj = {\n        __proto__: null\n    };\n    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n    for(var key in obj){\n        if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n            if (desc && (desc.get || desc.set)) {\n                Object.defineProperty(newObj, key, desc);\n            } else {\n                newObj[key] = obj[key];\n            }\n        }\n    }\n    newObj.default = obj;\n    if (cache) {\n        cache.set(obj, newObj);\n    }\n    return newObj;\n}\nconst PARSE_PATTERN = /(?<!(_jsx|jsx-))runtime|preferredRegion|getStaticProps|getServerSideProps|generateStaticParams|export const|generateImageMetadata|generateSitemaps/;\nconst CLIENT_MODULE_LABEL = /\\/\\* __next_internal_client_entry_do_not_use__ ([^ ]*) (cjs|auto) \\*\\//;\nconst ACTION_MODULE_LABEL = /\\/\\* __next_internal_action_entry_do_not_use__ (\\{[^}]+\\}) \\*\\//;\nconst CLIENT_DIRECTIVE = 'use client';\nconst SERVER_ACTION_DIRECTIVE = 'use server';\nfunction getRSCModuleInformation(source, isReactServerLayer) {\n    const actionsJson = source.match(ACTION_MODULE_LABEL);\n    const parsedActionsMeta = actionsJson ? JSON.parse(actionsJson[1]) : undefined;\n    const clientInfoMatch = source.match(CLIENT_MODULE_LABEL);\n    const isClientRef = !!clientInfoMatch;\n    if (!isReactServerLayer) {\n        return {\n            type: _constants1.RSC_MODULE_TYPES.client,\n            actionIds: parsedActionsMeta,\n            isClientRef\n        };\n    }\n    const clientRefsString = clientInfoMatch == null ? void 0 : clientInfoMatch[1];\n    const clientRefs = clientRefsString ? clientRefsString.split(',') : [];\n    const clientEntryType = clientInfoMatch == null ? void 0 : clientInfoMatch[2];\n    const type = clientInfoMatch ? _constants1.RSC_MODULE_TYPES.client : _constants1.RSC_MODULE_TYPES.server;\n    return {\n        type,\n        actionIds: parsedActionsMeta,\n        clientRefs,\n        clientEntryType,\n        isClientRef\n    };\n}\n/**\n * Receives a parsed AST from SWC and checks if it belongs to a module that\n * requires a runtime to be specified. Those are:\n *   - Modules with `export function getStaticProps | getServerSideProps`\n *   - Modules with `export { getStaticProps | getServerSideProps } <from ...>`\n *   - Modules with `export const runtime = ...`\n */ function checkExports(ast, expectedExports, page) {\n    const exportsSet = new Set([\n        'getStaticProps',\n        'getServerSideProps',\n        'generateImageMetadata',\n        'generateSitemaps',\n        'generateStaticParams'\n    ]);\n    if (!Array.isArray(ast == null ? void 0 : ast.body)) {\n        return {};\n    }\n    try {\n        let getStaticProps = false;\n        let getServerSideProps = false;\n        let generateImageMetadata = false;\n        let generateSitemaps = false;\n        let generateStaticParams = false;\n        let exports1 = new Set();\n        let directives = new Set();\n        let hasLeadingNonDirectiveNode = false;\n        for (const node of ast.body){\n            var _node_declaration, _node_declaration1, _node_declaration_identifier, _node_declaration2;\n            // There should be no non-string literals nodes before directives\n            if (node.type === 'ExpressionStatement' && node.expression.type === 'StringLiteral') {\n                if (!hasLeadingNonDirectiveNode) {\n                    const directive = node.expression.value;\n                    if (CLIENT_DIRECTIVE === directive) {\n                        directives.add('client');\n                    }\n                    if (SERVER_ACTION_DIRECTIVE === directive) {\n                        directives.add('server');\n                    }\n                }\n            } else {\n                hasLeadingNonDirectiveNode = true;\n            }\n            if (node.type === 'ExportDeclaration' && ((_node_declaration = node.declaration) == null ? void 0 : _node_declaration.type) === 'VariableDeclaration') {\n                var _node_declaration3;\n                for (const declaration of (_node_declaration3 = node.declaration) == null ? void 0 : _node_declaration3.declarations){\n                    if (expectedExports.includes(declaration.id.value)) {\n                        exports1.add(declaration.id.value);\n                    }\n                }\n            }\n            if (node.type === 'ExportDeclaration' && ((_node_declaration1 = node.declaration) == null ? void 0 : _node_declaration1.type) === 'FunctionDeclaration' && exportsSet.has((_node_declaration_identifier = node.declaration.identifier) == null ? void 0 : _node_declaration_identifier.value)) {\n                const id = node.declaration.identifier.value;\n                getServerSideProps = id === 'getServerSideProps';\n                getStaticProps = id === 'getStaticProps';\n                generateImageMetadata = id === 'generateImageMetadata';\n                generateSitemaps = id === 'generateSitemaps';\n                generateStaticParams = id === 'generateStaticParams';\n            }\n            if (node.type === 'ExportDeclaration' && ((_node_declaration2 = node.declaration) == null ? void 0 : _node_declaration2.type) === 'VariableDeclaration') {\n                var _node_declaration_declarations_, _node_declaration4;\n                const id = (_node_declaration4 = node.declaration) == null ? void 0 : (_node_declaration_declarations_ = _node_declaration4.declarations[0]) == null ? void 0 : _node_declaration_declarations_.id.value;\n                if (exportsSet.has(id)) {\n                    getServerSideProps = id === 'getServerSideProps';\n                    getStaticProps = id === 'getStaticProps';\n                    generateImageMetadata = id === 'generateImageMetadata';\n                    generateSitemaps = id === 'generateSitemaps';\n                    generateStaticParams = id === 'generateStaticParams';\n                }\n            }\n            if (node.type === 'ExportNamedDeclaration') {\n                for (const specifier of node.specifiers){\n                    var _specifier_orig;\n                    if (specifier.type === 'ExportSpecifier' && ((_specifier_orig = specifier.orig) == null ? void 0 : _specifier_orig.type) === 'Identifier') {\n                        const value = specifier.orig.value;\n                        if (!getServerSideProps && value === 'getServerSideProps') {\n                            getServerSideProps = true;\n                        }\n                        if (!getStaticProps && value === 'getStaticProps') {\n                            getStaticProps = true;\n                        }\n                        if (!generateImageMetadata && value === 'generateImageMetadata') {\n                            generateImageMetadata = true;\n                        }\n                        if (!generateSitemaps && value === 'generateSitemaps') {\n                            generateSitemaps = true;\n                        }\n                        if (!generateStaticParams && value === 'generateStaticParams') {\n                            generateStaticParams = true;\n                        }\n                        if (expectedExports.includes(value) && !exports1.has(value)) {\n                            // An export was found that was actually a re-export, and not a\n                            // literal value. We should warn here.\n                            _log.warn(`Next.js can't recognize the exported \\`${value}\\` field in \"${page}\", it may be re-exported from another file. The default config will be used instead.`);\n                        }\n                    }\n                }\n            }\n        }\n        return {\n            getStaticProps,\n            getServerSideProps,\n            generateImageMetadata,\n            generateSitemaps,\n            generateStaticParams,\n            directives,\n            exports: exports1\n        };\n    } catch  {}\n    return {};\n}\nasync function tryToReadFile(filePath, shouldThrow) {\n    try {\n        return await _fs.promises.readFile(filePath, {\n            encoding: 'utf8'\n        });\n    } catch (error) {\n        if (shouldThrow) {\n            error.message = `Next.js ERROR: Failed to read file ${filePath}:\\n${error.message}`;\n            throw error;\n        }\n    }\n}\nfunction getMiddlewareMatchers(matcherOrMatchers, nextConfig) {\n    const matchers = Array.isArray(matcherOrMatchers) ? matcherOrMatchers : [\n        matcherOrMatchers\n    ];\n    const { i18n } = nextConfig;\n    return matchers.map((matcher)=>{\n        matcher = typeof matcher === 'string' ? {\n            source: matcher\n        } : matcher;\n        const originalSource = matcher.source;\n        let { source, ...rest } = matcher;\n        const isRoot = source === '/';\n        if ((i18n == null ? void 0 : i18n.locales) && matcher.locale !== false) {\n            source = `/:nextInternalLocale((?!_next/)[^/.]{1,})${isRoot ? '' : source}`;\n        }\n        source = `/:nextData(_next/data/[^/]{1,})?${source}${isRoot ? `(${nextConfig.i18n ? '|\\\\.json|' : ''}/?index|/?index\\\\.json)?` : '{(\\\\.json)}?'}`;\n        if (nextConfig.basePath) {\n            source = `${nextConfig.basePath}${source}`;\n        }\n        // Validate that the source is still.\n        const result = _middlewareconfig.SourceSchema.safeParse(source);\n        if (!result.success) {\n            (0, _zod.reportZodError)('Failed to parse middleware source', result.error);\n            // We need to exit here because middleware being built occurs before we\n            // finish setting up the server. Exiting here is the only way to ensure\n            // that we don't hang.\n            process.exit(1);\n        }\n        return {\n            ...rest,\n            // We know that parsed.regexStr is not undefined because we already\n            // checked that the source is valid.\n            regexp: (0, _trytoparsepath.tryToParsePath)(result.data).regexStr,\n            originalSource: originalSource || source\n        };\n    });\n}\nfunction parseMiddlewareConfig(page, rawConfig, nextConfig) {\n    // If there's no config to parse, then return nothing.\n    if (typeof rawConfig !== 'object' || !rawConfig) return {};\n    const input = _middlewareconfig.MiddlewareConfigInputSchema.safeParse(rawConfig);\n    if (!input.success) {\n        (0, _zod.reportZodError)(`${page} contains invalid middleware config`, input.error);\n        // We need to exit here because middleware being built occurs before we\n        // finish setting up the server. Exiting here is the only way to ensure\n        // that we don't hang.\n        process.exit(1);\n    }\n    const config = {};\n    if (input.data.matcher) {\n        config.matchers = getMiddlewareMatchers(input.data.matcher, nextConfig);\n    }\n    if (input.data.unstable_allowDynamic) {\n        config.unstable_allowDynamic = Array.isArray(input.data.unstable_allowDynamic) ? input.data.unstable_allowDynamic : [\n            input.data.unstable_allowDynamic\n        ];\n    }\n    if (input.data.regions) {\n        config.regions = input.data.regions;\n    }\n    return config;\n}\nconst apiRouteWarnings = new _lrucache.LRUCache(250);\nfunction warnAboutExperimentalEdge(apiRoute) {\n    if (process.env.NODE_ENV === 'production' && process.env.NEXT_PRIVATE_BUILD_WORKER === '1') {\n        return;\n    }\n    if (apiRouteWarnings.has(apiRoute)) {\n        return;\n    }\n    _log.warn(apiRoute ? `${apiRoute} provided runtime 'experimental-edge'. It can be updated to 'edge' instead.` : `You are using an experimental edge runtime, the API might change.`);\n    apiRouteWarnings.set(apiRoute, 1);\n}\nlet hadUnsupportedValue = false;\nconst warnedUnsupportedValueMap = new _lrucache.LRUCache(250, ()=>1);\nfunction warnAboutUnsupportedValue(pageFilePath, page, error) {\n    hadUnsupportedValue = true;\n    const isProductionBuild = process.env.NODE_ENV === 'production';\n    if (// we only log for the server compilation so it's not\n    // duplicated due to webpack build worker having fresh\n    // module scope for each compiler\n    process.env.NEXT_COMPILER_NAME !== 'server' || isProductionBuild && warnedUnsupportedValueMap.has(pageFilePath)) {\n        return;\n    }\n    warnedUnsupportedValueMap.set(pageFilePath, true);\n    const message = `Next.js can't recognize the exported \\`config\\` field in ` + (page ? `route \"${page}\"` : `\"${pageFilePath}\"`) + ':\\n' + error.message + (error.path ? ` at \"${error.path}\"` : '') + '.\\n' + 'Read More - https://nextjs.org/docs/messages/invalid-page-config';\n    // for a build we use `Log.error` instead of throwing\n    // so that all errors can be logged before exiting the process\n    if (isProductionBuild) {\n        _log.error(message);\n    } else {\n        throw Object.defineProperty(new Error(message), \"__NEXT_ERROR_CODE\", {\n            value: \"E394\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n}\nasync function getAppPageStaticInfo({ pageFilePath, nextConfig, isDev, page }) {\n    const content = await tryToReadFile(pageFilePath, !isDev);\n    if (!content || !PARSE_PATTERN.test(content)) {\n        return {\n            type: _pagetypes.PAGE_TYPES.APP,\n            config: undefined,\n            runtime: undefined,\n            preferredRegion: undefined,\n            maxDuration: undefined\n        };\n    }\n    const ast = await (0, _parsemodule.parseModule)(pageFilePath, content);\n    const { generateStaticParams, generateImageMetadata, generateSitemaps, exports: exports1, directives } = checkExports(ast, _appsegmentconfig.AppSegmentConfigSchemaKeys, page);\n    const { type: rsc } = getRSCModuleInformation(content, true);\n    const exportedConfig = {};\n    if (exports1) {\n        for (const property of exports1){\n            try {\n                exportedConfig[property] = (0, _extractconstvalue.extractExportedConstValue)(ast, property);\n            } catch (e) {\n                if (e instanceof _extractconstvalue.UnsupportedValueError) {\n                    warnAboutUnsupportedValue(pageFilePath, page, e);\n                }\n            }\n        }\n    }\n    try {\n        exportedConfig.config = (0, _extractconstvalue.extractExportedConstValue)(ast, 'config');\n    } catch (e) {\n        if (e instanceof _extractconstvalue.UnsupportedValueError) {\n            warnAboutUnsupportedValue(pageFilePath, page, e);\n        }\n    // `export config` doesn't exist, or other unknown error thrown by swc, silence them\n    }\n    const route = (0, _apppaths.normalizeAppPath)(page);\n    const config = (0, _appsegmentconfig.parseAppSegmentConfig)(exportedConfig, route);\n    // Prevent edge runtime and generateStaticParams in the same file.\n    if ((0, _isedgeruntime.isEdgeRuntime)(config.runtime) && generateStaticParams) {\n        throw Object.defineProperty(new Error(`Page \"${page}\" cannot use both \\`export const runtime = 'edge'\\` and export \\`generateStaticParams\\`.`), \"__NEXT_ERROR_CODE\", {\n            value: \"E42\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    // Prevent use client and generateStaticParams in the same file.\n    if ((directives == null ? void 0 : directives.has('client')) && generateStaticParams) {\n        throw Object.defineProperty(new Error(`Page \"${page}\" cannot use both \"use client\" and export function \"generateStaticParams()\".`), \"__NEXT_ERROR_CODE\", {\n            value: \"E475\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    return {\n        type: _pagetypes.PAGE_TYPES.APP,\n        rsc,\n        generateImageMetadata,\n        generateSitemaps,\n        generateStaticParams,\n        config,\n        middleware: parseMiddlewareConfig(page, exportedConfig.config, nextConfig),\n        runtime: config.runtime,\n        preferredRegion: config.preferredRegion,\n        maxDuration: config.maxDuration\n    };\n}\nasync function getPagesPageStaticInfo({ pageFilePath, nextConfig, isDev, page }) {\n    var _config_config, _config_config1, _config_config2;\n    const content = await tryToReadFile(pageFilePath, !isDev);\n    if (!content || !PARSE_PATTERN.test(content)) {\n        return {\n            type: _pagetypes.PAGE_TYPES.PAGES,\n            config: undefined,\n            runtime: undefined,\n            preferredRegion: undefined,\n            maxDuration: undefined\n        };\n    }\n    const ast = await (0, _parsemodule.parseModule)(pageFilePath, content);\n    const { getServerSideProps, getStaticProps, exports: exports1 } = checkExports(ast, _pagessegmentconfig.PagesSegmentConfigSchemaKeys, page);\n    const { type: rsc } = getRSCModuleInformation(content, true);\n    const exportedConfig = {};\n    if (exports1) {\n        for (const property of exports1){\n            try {\n                exportedConfig[property] = (0, _extractconstvalue.extractExportedConstValue)(ast, property);\n            } catch (e) {\n                if (e instanceof _extractconstvalue.UnsupportedValueError) {\n                    warnAboutUnsupportedValue(pageFilePath, page, e);\n                }\n            }\n        }\n    }\n    try {\n        exportedConfig.config = (0, _extractconstvalue.extractExportedConstValue)(ast, 'config');\n    } catch (e) {\n        if (e instanceof _extractconstvalue.UnsupportedValueError) {\n            warnAboutUnsupportedValue(pageFilePath, page, e);\n        }\n    // `export config` doesn't exist, or other unknown error thrown by swc, silence them\n    }\n    // Validate the config.\n    const route = (0, _normalizepagepath.normalizePagePath)(page);\n    const config = (0, _pagessegmentconfig.parsePagesSegmentConfig)(exportedConfig, route);\n    const isAnAPIRoute = (0, _isapiroute.isAPIRoute)(route);\n    const resolvedRuntime = config.runtime ?? ((_config_config = config.config) == null ? void 0 : _config_config.runtime);\n    if (resolvedRuntime === _constants.SERVER_RUNTIME.experimentalEdge) {\n        warnAboutExperimentalEdge(isAnAPIRoute ? page : null);\n    }\n    if (resolvedRuntime === _constants.SERVER_RUNTIME.edge && page && !isAnAPIRoute) {\n        const message = `Page ${page} provided runtime 'edge', the edge runtime for rendering is currently experimental. Use runtime 'experimental-edge' instead.`;\n        if (isDev) {\n            _log.error(message);\n        } else {\n            throw Object.defineProperty(new Error(message), \"__NEXT_ERROR_CODE\", {\n                value: \"E394\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n    }\n    return {\n        type: _pagetypes.PAGE_TYPES.PAGES,\n        getStaticProps,\n        getServerSideProps,\n        rsc,\n        config,\n        middleware: parseMiddlewareConfig(page, exportedConfig.config, nextConfig),\n        runtime: resolvedRuntime,\n        preferredRegion: (_config_config1 = config.config) == null ? void 0 : _config_config1.regions,\n        maxDuration: config.maxDuration ?? ((_config_config2 = config.config) == null ? void 0 : _config_config2.maxDuration)\n    };\n}\nasync function getPageStaticInfo(params) {\n    if (params.pageType === _pagetypes.PAGE_TYPES.APP) {\n        return getAppPageStaticInfo(params);\n    }\n    return getPagesPageStaticInfo(params);\n}\n\n//# sourceMappingURL=get-page-static-info.js.map"
        }
    ]
}