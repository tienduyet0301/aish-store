{
    "sourceFile": "node_modules/next/dist/build/analysis/extract-const-value.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892652100,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    NoSuchDeclarationError: null,\n    UnsupportedValueError: null,\n    extractExportedConstValue: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    NoSuchDeclarationError: function() {\n        return NoSuchDeclarationError;\n    },\n    UnsupportedValueError: function() {\n        return UnsupportedValueError;\n    },\n    extractExportedConstValue: function() {\n        return extractExportedConstValue;\n    }\n});\nclass NoSuchDeclarationError extends Error {\n}\nfunction isExportDeclaration(node) {\n    return node.type === 'ExportDeclaration';\n}\nfunction isVariableDeclaration(node) {\n    return node.type === 'VariableDeclaration';\n}\nfunction isIdentifier(node) {\n    return node.type === 'Identifier';\n}\nfunction isBooleanLiteral(node) {\n    return node.type === 'BooleanLiteral';\n}\nfunction isNullLiteral(node) {\n    return node.type === 'NullLiteral';\n}\nfunction isStringLiteral(node) {\n    return node.type === 'StringLiteral';\n}\nfunction isNumericLiteral(node) {\n    return node.type === 'NumericLiteral';\n}\nfunction isArrayExpression(node) {\n    return node.type === 'ArrayExpression';\n}\nfunction isObjectExpression(node) {\n    return node.type === 'ObjectExpression';\n}\nfunction isKeyValueProperty(node) {\n    return node.type === 'KeyValueProperty';\n}\nfunction isRegExpLiteral(node) {\n    return node.type === 'RegExpLiteral';\n}\nfunction isTemplateLiteral(node) {\n    return node.type === 'TemplateLiteral';\n}\nfunction isTsSatisfiesExpression(node) {\n    return node.type === 'TsSatisfiesExpression';\n}\nclass UnsupportedValueError extends Error {\n    constructor(message, paths){\n        super(message);\n        // Generating \"path\" that looks like \"config.runtime[0].value\"\n        let codePath;\n        if (paths) {\n            codePath = '';\n            for (const path of paths){\n                if (path[0] === '[') {\n                    // \"array\" + \"[0]\"\n                    codePath += path;\n                } else {\n                    if (codePath === '') {\n                        codePath = path;\n                    } else {\n                        // \"object\" + \".key\"\n                        codePath += `.${path}`;\n                    }\n                }\n            }\n        }\n        this.path = codePath;\n    }\n}\nfunction extractValue(node, path) {\n    if (isNullLiteral(node)) {\n        return null;\n    } else if (isBooleanLiteral(node)) {\n        // e.g. true / false\n        return node.value;\n    } else if (isStringLiteral(node)) {\n        // e.g. \"abc\"\n        return node.value;\n    } else if (isNumericLiteral(node)) {\n        // e.g. 123\n        return node.value;\n    } else if (isRegExpLiteral(node)) {\n        // e.g. /abc/i\n        return new RegExp(node.pattern, node.flags);\n    } else if (isIdentifier(node)) {\n        switch(node.value){\n            case 'undefined':\n                return undefined;\n            default:\n                throw new UnsupportedValueError(`Unknown identifier \"${node.value}\"`, path);\n        }\n    } else if (isArrayExpression(node)) {\n        // e.g. [1, 2, 3]\n        const arr = [];\n        for(let i = 0, len = node.elements.length; i < len; i++){\n            const elem = node.elements[i];\n            if (elem) {\n                if (elem.spread) {\n                    // e.g. [ ...a ]\n                    throw new UnsupportedValueError('Unsupported spread operator in the Array Expression', path);\n                }\n                arr.push(extractValue(elem.expression, path && [\n                    ...path,\n                    `[${i}]`\n                ]));\n            } else {\n                // e.g. [1, , 2]\n                //         ^^\n                arr.push(undefined);\n            }\n        }\n        return arr;\n    } else if (isObjectExpression(node)) {\n        // e.g. { a: 1, b: 2 }\n        const obj = {};\n        for (const prop of node.properties){\n            if (!isKeyValueProperty(prop)) {\n                // e.g. { ...a }\n                throw new UnsupportedValueError('Unsupported spread operator in the Object Expression', path);\n            }\n            let key;\n            if (isIdentifier(prop.key)) {\n                // e.g. { a: 1, b: 2 }\n                key = prop.key.value;\n            } else if (isStringLiteral(prop.key)) {\n                // e.g. { \"a\": 1, \"b\": 2 }\n                key = prop.key.value;\n            } else {\n                throw new UnsupportedValueError(`Unsupported key type \"${prop.key.type}\" in the Object Expression`, path);\n            }\n            obj[key] = extractValue(prop.value, path && [\n                ...path,\n                key\n            ]);\n        }\n        return obj;\n    } else if (isTemplateLiteral(node)) {\n        // e.g. `abc`\n        if (node.expressions.length !== 0) {\n            // TODO: should we add support for `${'e'}d${'g'}'e'`?\n            throw new UnsupportedValueError('Unsupported template literal with expressions', path);\n        }\n        // When TemplateLiteral has 0 expressions, the length of quasis is always 1.\n        // Because when parsing TemplateLiteral, the parser yields the first quasi,\n        // then the first expression, then the next quasi, then the next expression, etc.,\n        // until the last quasi.\n        // Thus if there is no expression, the parser ends at the frst and also last quasis\n        //\n        // A \"cooked\" interpretation where backslashes have special meaning, while a\n        // \"raw\" interpretation where backslashes do not have special meaning\n        // https://exploringjs.com/impatient-js/ch_template-literals.html#template-strings-cooked-vs-raw\n        const [{ cooked, raw }] = node.quasis;\n        return cooked ?? raw;\n    } else if (isTsSatisfiesExpression(node)) {\n        return extractValue(node.expression);\n    } else {\n        throw new UnsupportedValueError(`Unsupported node type \"${node.type}\"`, path);\n    }\n}\nfunction extractExportedConstValue(module1, exportedName) {\n    for (const moduleItem of module1.body){\n        if (!isExportDeclaration(moduleItem)) {\n            continue;\n        }\n        const declaration = moduleItem.declaration;\n        if (!isVariableDeclaration(declaration)) {\n            continue;\n        }\n        if (declaration.kind !== 'const') {\n            continue;\n        }\n        for (const decl of declaration.declarations){\n            if (isIdentifier(decl.id) && decl.id.value === exportedName && decl.init) {\n                return extractValue(decl.init, [\n                    exportedName\n                ]);\n            }\n        }\n    }\n    throw new NoSuchDeclarationError();\n}\n\n//# sourceMappingURL=extract-const-value.js.map"
        }
    ]
}