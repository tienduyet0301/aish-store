{
    "sourceFile": "node_modules/next/dist/build/static-paths/app.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892660696,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"buildAppStaticPaths\", {\n    enumerable: true,\n    get: function() {\n        return buildAppStaticPaths;\n    }\n});\nconst _path = /*#__PURE__*/ _interop_require_default(require(\"path\"));\nconst _runwithafter = require(\"../../server/after/run-with-after\");\nconst _workstore = require(\"../../server/async-storage/work-store\");\nconst _fallback = require(\"../../lib/fallback\");\nconst _routematcher = require(\"../../shared/lib/router/utils/route-matcher\");\nconst _routeregex = require(\"../../shared/lib/router/utils/route-regex\");\nconst _utils = require(\"./utils\");\nconst _escapepathdelimiters = /*#__PURE__*/ _interop_require_default(require(\"../../shared/lib/router/utils/escape-path-delimiters\"));\nconst _createincrementalcache = require(\"../../export/helpers/create-incremental-cache\");\nfunction _interop_require_default(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\n/**\n * Compares two parameters to see if they're equal.\n *\n * @param a - The first parameter.\n * @param b - The second parameter.\n * @returns Whether the parameters are equal.\n */ function areParamValuesEqual(a, b) {\n    // If they're equal, then we can return true.\n    if (a === b) {\n        return true;\n    }\n    // If they're both arrays, then we can return true if they have the same\n    // length and all the items are the same.\n    if (Array.isArray(a) && Array.isArray(b)) {\n        if (a.length !== b.length) {\n            return false;\n        }\n        return a.every((item, index)=>item === b[index]);\n    }\n    // Otherwise, they're not equal.\n    return false;\n}\n/**\n * Filters out duplicate parameters from a list of parameters.\n *\n * @param routeParamKeys - The keys of the parameters.\n * @param routeParams - The list of parameters to filter.\n * @returns The list of unique parameters.\n */ function filterUniqueParams(routeParamKeys, routeParams) {\n    const unique = [];\n    for (const params of routeParams){\n        let i = 0;\n        for(; i < unique.length; i++){\n            const item = unique[i];\n            let j = 0;\n            for(; j < routeParamKeys.length; j++){\n                const key = routeParamKeys[j];\n                // If the param is not the same, then we need to break out of the loop.\n                if (!areParamValuesEqual(item[key], params[key])) {\n                    break;\n                }\n            }\n            // If we got to the end of the paramKeys array, then it means that we\n            // found a duplicate. Skip it.\n            if (j === routeParamKeys.length) {\n                break;\n            }\n        }\n        // If we didn't get to the end of the unique array, then it means that we\n        // found a duplicate. Skip it.\n        if (i < unique.length) {\n            continue;\n        }\n        unique.push(params);\n    }\n    return unique;\n}\n/**\n * Filters out all combinations of root params from a list of parameters.\n *\n * Given the following root param ('lang'), and the following routeParams:\n *\n * ```\n * [\n *   { lang: 'en', region: 'US', slug: ['home'] },\n *   { lang: 'en', region: 'US', slug: ['about'] },\n *   { lang: 'fr', region: 'CA', slug: ['about'] },\n * ]\n * ```\n *\n * The result will be:\n *\n * ```\n * [\n *   { lang: 'en', region: 'US' },\n *   { lang: 'fr', region: 'CA' },\n * ]\n * ```\n *\n * @param rootParamKeys - The keys of the root params.\n * @param routeParams - The list of parameters to filter.\n * @returns The list of combinations of root params.\n */ function filterRootParamsCombinations(rootParamKeys, routeParams) {\n    const combinations = [];\n    for (const params of routeParams){\n        const combination = {};\n        // Collect all root params. As soon as we don't find a root param, break.\n        let i = 0;\n        for(; i < rootParamKeys.length; i++){\n            const key = rootParamKeys[i];\n            if (params[key]) {\n                combination[key] = params[key];\n            } else {\n                break;\n            }\n        }\n        // If we didn't find all root params, skip this combination. We only want to\n        // generate combinations that have all root params.\n        if (i < rootParamKeys.length) {\n            continue;\n        }\n        combinations.push(combination);\n    }\n    return combinations;\n}\n/**\n * Validates the parameters to ensure they're accessible and have the correct\n * types.\n *\n * @param page - The page to validate.\n * @param regex - The route regex.\n * @param isRoutePPREnabled - Whether the route has partial prerendering enabled.\n * @param routeParamKeys - The keys of the parameters.\n * @param rootParamKeys - The keys of the root params.\n * @param routeParams - The list of parameters to validate.\n * @returns The list of validated parameters.\n */ function validateParams(page, regex, isRoutePPREnabled, routeParamKeys, rootParamKeys, routeParams) {\n    const valid = [];\n    // Validate that if there are any root params, that the user has provided at\n    // least one value for them only if we're using partial prerendering.\n    if (isRoutePPREnabled && rootParamKeys.length > 0) {\n        if (routeParams.length === 0 || rootParamKeys.some((key)=>routeParams.some((params)=>!(key in params)))) {\n            if (rootParamKeys.length === 1) {\n                throw Object.defineProperty(new Error(`A required root parameter (${rootParamKeys[0]}) was not provided in generateStaticParams for ${page}, please provide at least one value.`), \"__NEXT_ERROR_CODE\", {\n                    value: \"E622\",\n                    enumerable: false,\n                    configurable: true\n                });\n            }\n            throw Object.defineProperty(new Error(`Required root params (${rootParamKeys.join(', ')}) were not provided in generateStaticParams for ${page}, please provide at least one value for each.`), \"__NEXT_ERROR_CODE\", {\n                value: \"E621\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n    }\n    for (const params of routeParams){\n        const item = {};\n        for (const key of routeParamKeys){\n            const { repeat, optional } = regex.groups[key];\n            let paramValue = params[key];\n            if (optional && params.hasOwnProperty(key) && (paramValue === null || paramValue === undefined || paramValue === false)) {\n                paramValue = [];\n            }\n            // A parameter is missing, so the rest of the params are not accessible.\n            // We only support this when the route has partial prerendering enabled.\n            // This will make it so that the remaining params are marked as missing so\n            // we can generate a fallback route for them.\n            if (!paramValue && isRoutePPREnabled) {\n                break;\n            }\n            // Perform validation for the parameter based on whether it's a repeat\n            // parameter or not.\n            if (repeat) {\n                if (!Array.isArray(paramValue)) {\n                    throw Object.defineProperty(new Error(`A required parameter (${key}) was not provided as an array received ${typeof paramValue} in generateStaticParams for ${page}`), \"__NEXT_ERROR_CODE\", {\n                        value: \"E618\",\n                        enumerable: false,\n                        configurable: true\n                    });\n                }\n            } else {\n                if (typeof paramValue !== 'string') {\n                    throw Object.defineProperty(new Error(`A required parameter (${key}) was not provided as a string received ${typeof paramValue} in generateStaticParams for ${page}`), \"__NEXT_ERROR_CODE\", {\n                        value: \"E617\",\n                        enumerable: false,\n                        configurable: true\n                    });\n                }\n            }\n            item[key] = paramValue;\n        }\n        valid.push(item);\n    }\n    return valid;\n}\nasync function buildAppStaticPaths({ dir, page, distDir, dynamicIO, authInterrupts, segments, isrFlushToDisk, cacheHandler, cacheLifeProfiles, requestHeaders, cacheHandlers, maxMemoryCacheSize, fetchCacheKeyPrefix, nextConfigOutput, ComponentMod, isRoutePPREnabled = false, buildId, rootParamKeys }) {\n    if (segments.some((generate)=>{\n        var _generate_config;\n        return ((_generate_config = generate.config) == null ? void 0 : _generate_config.dynamicParams) === true;\n    }) && nextConfigOutput === 'export') {\n        throw Object.defineProperty(new Error('\"dynamicParams: true\" cannot be used with \"output: export\". See more info here: https://nextjs.org/docs/app/building-your-application/deploying/static-exports'), \"__NEXT_ERROR_CODE\", {\n            value: \"E393\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    ComponentMod.patchFetch();\n    const incrementalCache = await (0, _createincrementalcache.createIncrementalCache)({\n        dir,\n        distDir,\n        cacheHandler,\n        cacheHandlers,\n        requestHeaders,\n        fetchCacheKeyPrefix,\n        flushToDisk: isrFlushToDisk,\n        cacheMaxMemorySize: maxMemoryCacheSize\n    });\n    const regex = (0, _routeregex.getRouteRegex)(page);\n    const routeParamKeys = Object.keys((0, _routematcher.getRouteMatcher)(regex)(page) || {});\n    const afterRunner = new _runwithafter.AfterRunner();\n    const store = (0, _workstore.createWorkStore)({\n        page,\n        // We're discovering the parameters here, so we don't have any unknown\n        // ones.\n        fallbackRouteParams: null,\n        renderOpts: {\n            incrementalCache,\n            cacheLifeProfiles,\n            supportsDynamicResponse: true,\n            isRevalidate: false,\n            experimental: {\n                dynamicIO,\n                authInterrupts\n            },\n            waitUntil: afterRunner.context.waitUntil,\n            onClose: afterRunner.context.onClose,\n            onAfterTaskError: afterRunner.context.onTaskError\n        },\n        buildId,\n        previouslyRevalidatedTags: []\n    });\n    const routeParams = await ComponentMod.workAsyncStorage.run(store, async ()=>{\n        async function builtRouteParams(parentsParams = [], idx = 0) {\n            // If we don't have any more to process, then we're done.\n            if (idx === segments.length) return parentsParams;\n            const current = segments[idx];\n            if (typeof current.generateStaticParams !== 'function' && idx < segments.length) {\n                return builtRouteParams(parentsParams, idx + 1);\n            }\n            const params = [];\n            if (current.generateStaticParams) {\n                var _current_config;\n                // fetchCache can be used to inform the fetch() defaults used inside\n                // of generateStaticParams. revalidate and dynamic options don't come into\n                // play within generateStaticParams.\n                if (typeof ((_current_config = current.config) == null ? void 0 : _current_config.fetchCache) !== 'undefined') {\n                    store.fetchCache = current.config.fetchCache;\n                }\n                if (parentsParams.length > 0) {\n                    for (const parentParams of parentsParams){\n                        const result = await current.generateStaticParams({\n                            params: parentParams\n                        });\n                        for (const item of result){\n                            params.push({\n                                ...parentParams,\n                                ...item\n                            });\n                        }\n                    }\n                } else {\n                    const result = await current.generateStaticParams({\n                        params: {}\n                    });\n                    params.push(...result);\n                }\n            }\n            if (idx < segments.length) {\n                return builtRouteParams(params, idx + 1);\n            }\n            return params;\n        }\n        return builtRouteParams();\n    });\n    let lastDynamicSegmentHadGenerateStaticParams = false;\n    for (const segment of segments){\n        var _segment_config;\n        // Check to see if there are any missing params for segments that have\n        // dynamicParams set to false.\n        if (segment.param && segment.isDynamicSegment && ((_segment_config = segment.config) == null ? void 0 : _segment_config.dynamicParams) === false) {\n            for (const params of routeParams){\n                if (segment.param in params) continue;\n                const relative = segment.filePath ? _path.default.relative(dir, segment.filePath) : undefined;\n                throw Object.defineProperty(new Error(`Segment \"${relative}\" exports \"dynamicParams: false\" but the param \"${segment.param}\" is missing from the generated route params.`), \"__NEXT_ERROR_CODE\", {\n                    value: \"E280\",\n                    enumerable: false,\n                    configurable: true\n                });\n            }\n        }\n        if (segment.isDynamicSegment && typeof segment.generateStaticParams !== 'function') {\n            lastDynamicSegmentHadGenerateStaticParams = false;\n        } else if (typeof segment.generateStaticParams === 'function') {\n            lastDynamicSegmentHadGenerateStaticParams = true;\n        }\n    }\n    // Determine if all the segments have had their parameters provided.\n    const hadAllParamsGenerated = routeParamKeys.length === 0 || routeParams.length > 0 && routeParams.every((params)=>{\n        for (const key of routeParamKeys){\n            if (key in params) continue;\n            return false;\n        }\n        return true;\n    });\n    // TODO: dynamic params should be allowed to be granular per segment but\n    // we need additional information stored/leveraged in the prerender\n    // manifest to allow this behavior.\n    const dynamicParams = segments.every((segment)=>{\n        var _segment_config;\n        return ((_segment_config = segment.config) == null ? void 0 : _segment_config.dynamicParams) !== false;\n    });\n    const supportsRoutePreGeneration = hadAllParamsGenerated || process.env.NODE_ENV === 'production';\n    const fallbackMode = dynamicParams ? supportsRoutePreGeneration ? isRoutePPREnabled ? _fallback.FallbackMode.PRERENDER : _fallback.FallbackMode.BLOCKING_STATIC_RENDER : undefined : _fallback.FallbackMode.NOT_FOUND;\n    const result = {\n        fallbackMode,\n        prerenderedRoutes: lastDynamicSegmentHadGenerateStaticParams ? [] : undefined\n    };\n    if (hadAllParamsGenerated || isRoutePPREnabled) {\n        if (isRoutePPREnabled) {\n            // Discover all unique combinations of the rootParams so we can generate\n            // shells for each of them if they're available.\n            routeParams.unshift(...filterRootParamsCombinations(rootParamKeys, routeParams));\n            result.prerenderedRoutes ??= [];\n            result.prerenderedRoutes.push({\n                pathname: page,\n                encodedPathname: page,\n                fallbackRouteParams: routeParamKeys,\n                fallbackMode: dynamicParams ? // perform a blocking static render.\n                rootParamKeys.length > 0 ? _fallback.FallbackMode.BLOCKING_STATIC_RENDER : fallbackMode : _fallback.FallbackMode.NOT_FOUND,\n                fallbackRootParams: rootParamKeys\n            });\n        }\n        filterUniqueParams(routeParamKeys, validateParams(page, regex, isRoutePPREnabled, routeParamKeys, rootParamKeys, routeParams)).forEach((params)=>{\n            let pathname = page;\n            let encodedPathname = page;\n            const fallbackRouteParams = [];\n            for (const key of routeParamKeys){\n                if (fallbackRouteParams.length > 0) {\n                    // This is a partial route, so we should add the value to the\n                    // fallbackRouteParams.\n                    fallbackRouteParams.push(key);\n                    continue;\n                }\n                let paramValue = params[key];\n                if (!paramValue) {\n                    if (isRoutePPREnabled) {\n                        // This is a partial route, so we should add the value to the\n                        // fallbackRouteParams.\n                        fallbackRouteParams.push(key);\n                        continue;\n                    } else {\n                        // This route is not complete, and we aren't performing a partial\n                        // prerender, so we should return, skipping this route.\n                        return;\n                    }\n                }\n                const { repeat, optional } = regex.groups[key];\n                let replaced = `[${repeat ? '...' : ''}${key}]`;\n                if (optional) {\n                    replaced = `[${replaced}]`;\n                }\n                pathname = pathname.replace(replaced, (0, _utils.encodeParam)(paramValue, (value)=>(0, _escapepathdelimiters.default)(value, true)));\n                encodedPathname = encodedPathname.replace(replaced, (0, _utils.encodeParam)(paramValue, encodeURIComponent));\n            }\n            const fallbackRootParams = rootParamKeys.filter((param)=>fallbackRouteParams.includes(param));\n            result.prerenderedRoutes ??= [];\n            result.prerenderedRoutes.push({\n                pathname: (0, _utils.normalizePathname)(pathname),\n                encodedPathname: (0, _utils.normalizePathname)(encodedPathname),\n                fallbackRouteParams,\n                fallbackMode: dynamicParams ? // perform a blocking static render.\n                fallbackRootParams.length > 0 ? _fallback.FallbackMode.BLOCKING_STATIC_RENDER : fallbackMode : _fallback.FallbackMode.NOT_FOUND,\n                fallbackRootParams\n            });\n        });\n    }\n    await afterRunner.executeAfter();\n    return result;\n}\n\n//# sourceMappingURL=app.js.map"
        }
    ]
}