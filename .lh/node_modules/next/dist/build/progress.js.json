{
    "sourceFile": "node_modules/next/dist/build/progress.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892659266,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"createProgress\", {\n    enumerable: true,\n    get: function() {\n        return createProgress;\n    }\n});\nconst _log = /*#__PURE__*/ _interop_require_wildcard(require(\"../build/output/log\"));\nconst _spinner = /*#__PURE__*/ _interop_require_default(require(\"./spinner\"));\nfunction _interop_require_default(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nfunction _getRequireWildcardCache(nodeInterop) {\n    if (typeof WeakMap !== \"function\") return null;\n    var cacheBabelInterop = new WeakMap();\n    var cacheNodeInterop = new WeakMap();\n    return (_getRequireWildcardCache = function(nodeInterop) {\n        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n    })(nodeInterop);\n}\nfunction _interop_require_wildcard(obj, nodeInterop) {\n    if (!nodeInterop && obj && obj.__esModule) {\n        return obj;\n    }\n    if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n        return {\n            default: obj\n        };\n    }\n    var cache = _getRequireWildcardCache(nodeInterop);\n    if (cache && cache.has(obj)) {\n        return cache.get(obj);\n    }\n    var newObj = {\n        __proto__: null\n    };\n    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n    for(var key in obj){\n        if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n            if (desc && (desc.get || desc.set)) {\n                Object.defineProperty(newObj, key, desc);\n            } else {\n                newObj[key] = obj[key];\n            }\n        }\n    }\n    newObj.default = obj;\n    if (cache) {\n        cache.set(obj, newObj);\n    }\n    return newObj;\n}\nfunction divideSegments(number, segments) {\n    const result = [];\n    while(number > 0 && segments > 0){\n        const dividedNumber = number < segments ? number : Math.floor(number / segments);\n        number -= dividedNumber;\n        segments--;\n        result.push(dividedNumber);\n    }\n    return result;\n}\nconst createProgress = (total, label)=>{\n    const segments = divideSegments(total, 4);\n    if (total === 0) {\n        throw Object.defineProperty(new Error('invariant: progress total can not be zero'), \"__NEXT_ERROR_CODE\", {\n            value: \"E49\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    let currentSegmentTotal = segments.shift();\n    let currentSegmentCount = 0;\n    let lastProgressOutput = Date.now();\n    let curProgress = 0;\n    let progressSpinner = (0, _spinner.default)(`${label} (${curProgress}/${total})`, {\n        spinner: {\n            frames: [\n                '[    ]',\n                '[=   ]',\n                '[==  ]',\n                '[=== ]',\n                '[ ===]',\n                '[  ==]',\n                '[   =]',\n                '[    ]',\n                '[   =]',\n                '[  ==]',\n                '[ ===]',\n                '[====]',\n                '[=== ]',\n                '[==  ]',\n                '[=   ]'\n            ],\n            interval: 200\n        }\n    });\n    const run = ()=>{\n        curProgress++;\n        // Make sure we only log once\n        // - per fully generated segment, or\n        // - per minute\n        // when not showing the spinner\n        if (!progressSpinner) {\n            currentSegmentCount++;\n            if (currentSegmentCount === currentSegmentTotal) {\n                currentSegmentTotal = segments.shift();\n                currentSegmentCount = 0;\n            } else if (lastProgressOutput + 60000 > Date.now()) {\n                return;\n            }\n            lastProgressOutput = Date.now();\n        }\n        const isFinished = curProgress === total;\n        const message = `${label} (${curProgress}/${total})`;\n        if (progressSpinner && !isFinished) {\n            progressSpinner.setText(message);\n        } else {\n            progressSpinner == null ? void 0 : progressSpinner.stop();\n            if (isFinished) {\n                _log.event(message);\n            } else {\n                _log.info(`${message} ${process.stdout.isTTY ? '\\n' : '\\r'}`);\n            }\n        }\n    };\n    const clear = ()=>{\n        if (progressSpinner && // Ensure only reset and clear once to avoid set operation overflow in ora\n        progressSpinner.isSpinning) {\n            progressSpinner.prefixText = '\\r';\n            progressSpinner.text = '\\r';\n            progressSpinner.clear();\n            progressSpinner.stop();\n        }\n    };\n    return {\n        run,\n        clear\n    };\n};\n\n//# sourceMappingURL=progress.js.map"
        }
    ]
}