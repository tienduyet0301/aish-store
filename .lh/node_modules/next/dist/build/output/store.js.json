{
    "sourceFile": "node_modules/next/dist/build/output/store.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892657797,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    formatTrigger: null,\n    store: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    formatTrigger: function() {\n        return formatTrigger;\n    },\n    store: function() {\n        return store;\n    }\n});\nconst _unistore = /*#__PURE__*/ _interop_require_default(require(\"next/dist/compiled/unistore\"));\nconst _stripansi = /*#__PURE__*/ _interop_require_default(require(\"next/dist/compiled/strip-ansi\"));\nconst _trace = require(\"../../trace\");\nconst _swc = require(\"../swc\");\nconst _log = /*#__PURE__*/ _interop_require_wildcard(require(\"./log\"));\nfunction _interop_require_default(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nfunction _getRequireWildcardCache(nodeInterop) {\n    if (typeof WeakMap !== \"function\") return null;\n    var cacheBabelInterop = new WeakMap();\n    var cacheNodeInterop = new WeakMap();\n    return (_getRequireWildcardCache = function(nodeInterop) {\n        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n    })(nodeInterop);\n}\nfunction _interop_require_wildcard(obj, nodeInterop) {\n    if (!nodeInterop && obj && obj.__esModule) {\n        return obj;\n    }\n    if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n        return {\n            default: obj\n        };\n    }\n    var cache = _getRequireWildcardCache(nodeInterop);\n    if (cache && cache.has(obj)) {\n        return cache.get(obj);\n    }\n    var newObj = {\n        __proto__: null\n    };\n    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n    for(var key in obj){\n        if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n            if (desc && (desc.get || desc.set)) {\n                Object.defineProperty(newObj, key, desc);\n            } else {\n                newObj[key] = obj[key];\n            }\n        }\n    }\n    newObj.default = obj;\n    if (cache) {\n        cache.set(obj, newObj);\n    }\n    return newObj;\n}\nconst MAX_LOG_SKIP_DURATION = 500 // 500ms\n;\nfunction formatTrigger(trigger) {\n    // Format dynamic sitemap routes to simpler file path\n    // e.g., /sitemap.xml[] -> /sitemap.xml\n    if (trigger.includes('[__metadata_id__]')) {\n        trigger = trigger.replace('/[__metadata_id__]', '/[id]');\n    }\n    if (trigger.length > 1 && trigger.endsWith('/')) {\n        trigger = trigger.slice(0, -1);\n    }\n    return trigger;\n}\nconst store = (0, _unistore.default)({\n    appUrl: null,\n    bindAddr: null,\n    bootstrap: true,\n    logging: true\n});\nlet lastStore = {\n    appUrl: null,\n    bindAddr: null,\n    bootstrap: true,\n    logging: true\n};\nfunction hasStoreChanged(nextStore) {\n    if ([\n        ...new Set([\n            ...Object.keys(lastStore),\n            ...Object.keys(nextStore)\n        ])\n    ].every((key)=>Object.is(lastStore[key], nextStore[key]))) {\n        return false;\n    }\n    lastStore = nextStore;\n    return true;\n}\nlet startTime = 0;\nlet trigger = '' // default, use empty string for trigger\n;\nlet triggerUrl = undefined;\nlet loadingLogTimer = null;\nlet traceSpan = null;\nlet logging = true;\nstore.subscribe((state)=>{\n    // Update persisted logging state\n    if ('logging' in state) {\n        logging = state.logging;\n    }\n    // If logging is disabled, do not log\n    if (!logging) {\n        return;\n    }\n    if (!hasStoreChanged(state)) {\n        return;\n    }\n    if (state.bootstrap) {\n        return;\n    }\n    if (state.loading) {\n        if (state.trigger) {\n            trigger = formatTrigger(state.trigger);\n            triggerUrl = state.url;\n            if (trigger !== 'initial') {\n                traceSpan = (0, _trace.trace)('compile-path', undefined, {\n                    trigger: trigger\n                });\n                if (!loadingLogTimer) {\n                    // Only log compiling if compiled is not finished in 3 seconds\n                    loadingLogTimer = setTimeout(()=>{\n                        if (triggerUrl && triggerUrl !== trigger && process.env.NEXT_TRIGGER_URL) {\n                            _log.wait(`Compiling ${trigger} (${triggerUrl}) ...`);\n                        } else {\n                            _log.wait(`Compiling ${trigger} ...`);\n                        }\n                    }, MAX_LOG_SKIP_DURATION);\n                }\n            }\n        }\n        if (startTime === 0) {\n            startTime = Date.now();\n        }\n        return;\n    }\n    if (state.errors) {\n        // Log compilation errors\n        _log.error(state.errors[0]);\n        const cleanError = (0, _stripansi.default)(state.errors[0]);\n        if (cleanError.indexOf('SyntaxError') > -1) {\n            const matches = cleanError.match(/\\[.*\\]=/);\n            if (matches) {\n                for (const match of matches){\n                    const prop = (match.split(']').shift() || '').slice(1);\n                    console.log(`AMP bind syntax [${prop}]='' is not supported in JSX, use 'data-amp-bind-${prop}' instead. https://nextjs.org/docs/messages/amp-bind-jsx-alt`);\n                }\n                return;\n            }\n        }\n        startTime = 0;\n        // Ensure traces are flushed after each compile in development mode\n        (0, _trace.flushAllTraces)();\n        (0, _swc.teardownTraceSubscriber)();\n        return;\n    }\n    let timeMessage = '';\n    if (startTime) {\n        const time = Date.now() - startTime;\n        startTime = 0;\n        timeMessage = ' ' + (time > 2000 ? `in ${Math.round(time / 100) / 10}s` : `in ${time}ms`);\n    }\n    let modulesMessage = '';\n    if (state.totalModulesCount) {\n        modulesMessage = ` (${state.totalModulesCount} modules)`;\n    }\n    if (state.warnings) {\n        _log.warn(state.warnings.join('\\n\\n'));\n        // Ensure traces are flushed after each compile in development mode\n        (0, _trace.flushAllTraces)();\n        (0, _swc.teardownTraceSubscriber)();\n        return;\n    }\n    if (state.typeChecking) {\n        _log.info(`bundled ${trigger}${timeMessage}${modulesMessage}, type checking...`);\n        return;\n    }\n    if (trigger === 'initial') {\n        trigger = '';\n    } else {\n        if (loadingLogTimer) {\n            clearTimeout(loadingLogTimer);\n            loadingLogTimer = null;\n        }\n        if (traceSpan) {\n            traceSpan.stop();\n            traceSpan = null;\n        }\n        _log.event(`Compiled${trigger ? ' ' + trigger : ''}${timeMessage}${modulesMessage}`);\n        trigger = '';\n    }\n    // Ensure traces are flushed after each compile in development mode\n    (0, _trace.flushAllTraces)();\n    (0, _swc.teardownTraceSubscriber)();\n});\n\n//# sourceMappingURL=store.js.map"
        }
    ]
}