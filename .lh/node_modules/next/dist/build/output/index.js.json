{
    "sourceFile": "node_modules/next/dist/build/output/index.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892657596,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    ampValidation: null,\n    formatAmpMessages: null,\n    reportTrigger: null,\n    watchCompilers: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    ampValidation: function() {\n        return ampValidation;\n    },\n    formatAmpMessages: function() {\n        return formatAmpMessages;\n    },\n    reportTrigger: function() {\n        return reportTrigger;\n    },\n    watchCompilers: function() {\n        return watchCompilers;\n    }\n});\nconst _picocolors = require(\"../../lib/picocolors\");\nconst _stripansi = /*#__PURE__*/ _interop_require_default(require(\"next/dist/compiled/strip-ansi\"));\nconst _texttable = /*#__PURE__*/ _interop_require_default(require(\"next/dist/compiled/text-table\"));\nconst _unistore = /*#__PURE__*/ _interop_require_default(require(\"next/dist/compiled/unistore\"));\nconst _formatwebpackmessages = /*#__PURE__*/ _interop_require_default(require(\"../../client/components/react-dev-overlay/utils/format-webpack-messages\"));\nconst _store = require(\"./store\");\nconst _constants = require(\"../../shared/lib/constants\");\nfunction _interop_require_default(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nfunction formatAmpMessages(amp) {\n    let output = (0, _picocolors.bold)('Amp Validation') + '\\n\\n';\n    let messages = [];\n    const chalkError = (0, _picocolors.red)('error');\n    function ampError(page, error) {\n        messages.push([\n            page,\n            chalkError,\n            error.message,\n            error.specUrl || ''\n        ]);\n    }\n    const chalkWarn = (0, _picocolors.yellow)('warn');\n    function ampWarn(page, warn) {\n        messages.push([\n            page,\n            chalkWarn,\n            warn.message,\n            warn.specUrl || ''\n        ]);\n    }\n    for(const page in amp){\n        let { errors, warnings } = amp[page];\n        const devOnlyFilter = (err)=>err.code !== 'DEV_MODE_ONLY';\n        errors = errors.filter(devOnlyFilter);\n        warnings = warnings.filter(devOnlyFilter);\n        if (!(errors.length || warnings.length)) {\n            continue;\n        }\n        if (errors.length) {\n            ampError(page, errors[0]);\n            for(let index = 1; index < errors.length; ++index){\n                ampError('', errors[index]);\n            }\n        }\n        if (warnings.length) {\n            ampWarn(errors.length ? '' : page, warnings[0]);\n            for(let index = 1; index < warnings.length; ++index){\n                ampWarn('', warnings[index]);\n            }\n        }\n        messages.push([\n            '',\n            '',\n            '',\n            ''\n        ]);\n    }\n    if (!messages.length) {\n        return '';\n    }\n    output += (0, _texttable.default)(messages, {\n        align: [\n            'l',\n            'l',\n            'l',\n            'l'\n        ],\n        stringLength (str) {\n            return (0, _stripansi.default)(str).length;\n        }\n    });\n    return output;\n}\nconst buildStore = (0, _unistore.default)({\n    // @ts-expect-error initial value\n    client: {},\n    // @ts-expect-error initial value\n    server: {},\n    // @ts-expect-error initial value\n    edgeServer: {}\n});\nlet buildWasDone = false;\nlet clientWasLoading = true;\nlet serverWasLoading = true;\nlet edgeServerWasLoading = false;\nbuildStore.subscribe((state)=>{\n    const { amp, client, server, edgeServer, trigger, url } = state;\n    const { appUrl } = _store.store.getState();\n    if (client.loading || server.loading || (edgeServer == null ? void 0 : edgeServer.loading)) {\n        _store.store.setState({\n            bootstrap: false,\n            appUrl: appUrl,\n            // If it takes more than 3 seconds to compile, mark it as loading status\n            loading: true,\n            trigger,\n            url\n        }, true);\n        clientWasLoading = !buildWasDone && clientWasLoading || client.loading;\n        serverWasLoading = !buildWasDone && serverWasLoading || server.loading;\n        edgeServerWasLoading = !buildWasDone && edgeServerWasLoading || edgeServer.loading;\n        buildWasDone = false;\n        return;\n    }\n    buildWasDone = true;\n    let partialState = {\n        bootstrap: false,\n        appUrl: appUrl,\n        loading: false,\n        typeChecking: false,\n        totalModulesCount: (clientWasLoading ? client.totalModulesCount : 0) + (serverWasLoading ? server.totalModulesCount : 0) + (edgeServerWasLoading ? (edgeServer == null ? void 0 : edgeServer.totalModulesCount) || 0 : 0),\n        hasEdgeServer: !!edgeServer\n    };\n    if (client.errors && clientWasLoading) {\n        // Show only client errors\n        _store.store.setState({\n            ...partialState,\n            errors: client.errors,\n            warnings: null\n        }, true);\n    } else if (server.errors && serverWasLoading) {\n        _store.store.setState({\n            ...partialState,\n            errors: server.errors,\n            warnings: null\n        }, true);\n    } else if (edgeServer.errors && edgeServerWasLoading) {\n        _store.store.setState({\n            ...partialState,\n            errors: edgeServer.errors,\n            warnings: null\n        }, true);\n    } else {\n        // Show warnings from all of them\n        const warnings = [\n            ...client.warnings || [],\n            ...server.warnings || [],\n            ...edgeServer.warnings || []\n        ].concat(formatAmpMessages(amp) || []);\n        _store.store.setState({\n            ...partialState,\n            errors: null,\n            warnings: warnings.length === 0 ? null : warnings\n        }, true);\n    }\n});\nfunction ampValidation(page, errors, warnings) {\n    const { amp } = buildStore.getState();\n    if (!(errors.length || warnings.length)) {\n        buildStore.setState({\n            amp: Object.keys(amp).filter((k)=>k !== page).sort()// eslint-disable-next-line no-sequences\n            .reduce((a, c)=>(a[c] = amp[c], a), {})\n        });\n        return;\n    }\n    const newAmp = {\n        ...amp,\n        [page]: {\n            errors,\n            warnings\n        }\n    };\n    buildStore.setState({\n        amp: Object.keys(newAmp).sort()// eslint-disable-next-line no-sequences\n        .reduce((a, c)=>(a[c] = newAmp[c], a), {})\n    });\n}\nfunction watchCompilers(client, server, edgeServer) {\n    buildStore.setState({\n        client: {\n            loading: true\n        },\n        server: {\n            loading: true\n        },\n        edgeServer: {\n            loading: true\n        },\n        trigger: 'initial',\n        url: undefined\n    });\n    function tapCompiler(key, compiler, onEvent) {\n        compiler.hooks.invalid.tap(`NextJsInvalid-${key}`, ()=>{\n            onEvent({\n                loading: true\n            });\n        });\n        compiler.hooks.done.tap(`NextJsDone-${key}`, (stats)=>{\n            buildStore.setState({\n                amp: {}\n            });\n            const { errors, warnings } = (0, _formatwebpackmessages.default)(stats.toJson({\n                preset: 'errors-warnings',\n                moduleTrace: true\n            }));\n            const hasErrors = !!(errors == null ? void 0 : errors.length);\n            const hasWarnings = !!(warnings == null ? void 0 : warnings.length);\n            onEvent({\n                loading: false,\n                totalModulesCount: stats.compilation.modules.size,\n                errors: hasErrors ? errors : null,\n                warnings: hasWarnings ? warnings : null\n            });\n        });\n    }\n    tapCompiler(_constants.COMPILER_NAMES.client, client, (status)=>{\n        if (!status.loading && !buildStore.getState().server.loading && !buildStore.getState().edgeServer.loading && status.totalModulesCount > 0) {\n            buildStore.setState({\n                client: status,\n                trigger: undefined,\n                url: undefined\n            });\n        } else {\n            buildStore.setState({\n                client: status\n            });\n        }\n    });\n    tapCompiler(_constants.COMPILER_NAMES.server, server, (status)=>{\n        if (!status.loading && !buildStore.getState().client.loading && !buildStore.getState().edgeServer.loading && status.totalModulesCount > 0) {\n            buildStore.setState({\n                server: status,\n                trigger: undefined,\n                url: undefined\n            });\n        } else {\n            buildStore.setState({\n                server: status\n            });\n        }\n    });\n    tapCompiler(_constants.COMPILER_NAMES.edgeServer, edgeServer, (status)=>{\n        if (!status.loading && !buildStore.getState().client.loading && !buildStore.getState().server.loading && status.totalModulesCount > 0) {\n            buildStore.setState({\n                edgeServer: status,\n                trigger: undefined,\n                url: undefined\n            });\n        } else {\n            buildStore.setState({\n                edgeServer: status\n            });\n        }\n    });\n}\nfunction reportTrigger(trigger, url) {\n    buildStore.setState({\n        trigger,\n        url\n    });\n}\n\n//# sourceMappingURL=index.js.map"
        }
    ]
}