{
    "sourceFile": "node_modules/next/dist/build/entries.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892655326,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    createEntrypoints: null,\n    createPagesMapping: null,\n    finalizeEntrypoint: null,\n    getAppEntry: null,\n    getAppLoader: null,\n    getClientEntry: null,\n    getEdgeServerEntry: null,\n    getInstrumentationEntry: null,\n    getPageFilePath: null,\n    getPageFromPath: null,\n    getStaticInfoIncludingLayouts: null,\n    runDependingOnPageType: null,\n    sortByPageExts: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    createEntrypoints: function() {\n        return createEntrypoints;\n    },\n    createPagesMapping: function() {\n        return createPagesMapping;\n    },\n    finalizeEntrypoint: function() {\n        return finalizeEntrypoint;\n    },\n    getAppEntry: function() {\n        return getAppEntry;\n    },\n    getAppLoader: function() {\n        return getAppLoader;\n    },\n    getClientEntry: function() {\n        return getClientEntry;\n    },\n    getEdgeServerEntry: function() {\n        return getEdgeServerEntry;\n    },\n    getInstrumentationEntry: function() {\n        return getInstrumentationEntry;\n    },\n    getPageFilePath: function() {\n        return getPageFilePath;\n    },\n    getPageFromPath: function() {\n        return getPageFromPath;\n    },\n    getStaticInfoIncludingLayouts: function() {\n        return getStaticInfoIncludingLayouts;\n    },\n    runDependingOnPageType: function() {\n        return runDependingOnPageType;\n    },\n    sortByPageExts: function() {\n        return sortByPageExts;\n    }\n});\nconst _log = /*#__PURE__*/ _interop_require_wildcard(require(\"./output/log\"));\nconst _path = require(\"path\");\nconst _querystring = require(\"querystring\");\nconst _fs = /*#__PURE__*/ _interop_require_default(require(\"fs\"));\nconst _constants = require(\"../lib/constants\");\nconst _isapiroute = require(\"../lib/is-api-route\");\nconst _isedgeruntime = require(\"../lib/is-edge-runtime\");\nconst _constants1 = require(\"../shared/lib/constants\");\nconst _utils = require(\"./utils\");\nconst _getpagestaticinfo = require(\"./analysis/get-page-static-info\");\nconst _normalizepathsep = require(\"../shared/lib/page-path/normalize-path-sep\");\nconst _normalizepagepath = require(\"../shared/lib/page-path/normalize-page-path\");\nconst _apppaths = require(\"../shared/lib/router/utils/app-paths\");\nconst _nextmiddlewareloader = require(\"./webpack/loaders/next-middleware-loader\");\nconst _isapprouteroute = require(\"../lib/is-app-route-route\");\nconst _getmetadataroute = require(\"../lib/metadata/get-metadata-route\");\nconst _nextrouteloader = require(\"./webpack/loaders/next-route-loader\");\nconst _isinternalcomponent = require(\"../lib/is-internal-component\");\nconst _ismetadataroute = require(\"../lib/metadata/is-metadata-route\");\nconst _routekind = require(\"../server/route-kind\");\nconst _utils1 = require(\"./webpack/loaders/utils\");\nconst _normalizecatchallroutes = require(\"./normalize-catchall-routes\");\nconst _pagetypes = require(\"../lib/page-types\");\nconst _isapppageroute = require(\"../lib/is-app-page-route\");\nfunction _interop_require_default(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nfunction _getRequireWildcardCache(nodeInterop) {\n    if (typeof WeakMap !== \"function\") return null;\n    var cacheBabelInterop = new WeakMap();\n    var cacheNodeInterop = new WeakMap();\n    return (_getRequireWildcardCache = function(nodeInterop) {\n        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n    })(nodeInterop);\n}\nfunction _interop_require_wildcard(obj, nodeInterop) {\n    if (!nodeInterop && obj && obj.__esModule) {\n        return obj;\n    }\n    if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n        return {\n            default: obj\n        };\n    }\n    var cache = _getRequireWildcardCache(nodeInterop);\n    if (cache && cache.has(obj)) {\n        return cache.get(obj);\n    }\n    var newObj = {\n        __proto__: null\n    };\n    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n    for(var key in obj){\n        if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n            if (desc && (desc.get || desc.set)) {\n                Object.defineProperty(newObj, key, desc);\n            } else {\n                newObj[key] = obj[key];\n            }\n        }\n    }\n    newObj.default = obj;\n    if (cache) {\n        cache.set(obj, newObj);\n    }\n    return newObj;\n}\nfunction sortByPageExts(pageExtensions) {\n    return (a, b)=>{\n        // prioritize entries according to pageExtensions order\n        // for consistency as fs order can differ across systems\n        // NOTE: this is reversed so preferred comes last and\n        // overrides prior\n        const aExt = (0, _path.extname)(a);\n        const bExt = (0, _path.extname)(b);\n        const aNoExt = a.substring(0, a.length - aExt.length);\n        const bNoExt = a.substring(0, b.length - bExt.length);\n        if (aNoExt !== bNoExt) return 0;\n        // find extension index (skip '.' as pageExtensions doesn't have it)\n        const aExtIndex = pageExtensions.indexOf(aExt.substring(1));\n        const bExtIndex = pageExtensions.indexOf(bExt.substring(1));\n        return bExtIndex - aExtIndex;\n    };\n}\nasync function getStaticInfoIncludingLayouts({ isInsideAppDir, pageExtensions, pageFilePath, appDir, config: nextConfig, isDev, page }) {\n    // TODO: sync types for pages: PAGE_TYPES, ROUTER_TYPE, 'app' | 'pages', etc.\n    const pageType = isInsideAppDir ? _pagetypes.PAGE_TYPES.APP : _pagetypes.PAGE_TYPES.PAGES;\n    const pageStaticInfo = await (0, _getpagestaticinfo.getPageStaticInfo)({\n        nextConfig,\n        pageFilePath,\n        isDev,\n        page,\n        pageType\n    });\n    if (pageStaticInfo.type === _pagetypes.PAGE_TYPES.PAGES || !appDir) {\n        return pageStaticInfo;\n    }\n    const segments = [\n        pageStaticInfo\n    ];\n    // inherit from layout files only if it's a page route\n    if ((0, _isapppageroute.isAppPageRoute)(page)) {\n        const layoutFiles = [];\n        const potentialLayoutFiles = pageExtensions.map((ext)=>'layout.' + ext);\n        let dir = (0, _path.dirname)(pageFilePath);\n        // Uses startsWith to not include directories further up.\n        while(dir.startsWith(appDir)){\n            for (const potentialLayoutFile of potentialLayoutFiles){\n                const layoutFile = (0, _path.join)(dir, potentialLayoutFile);\n                if (!_fs.default.existsSync(layoutFile)) {\n                    continue;\n                }\n                layoutFiles.push(layoutFile);\n            }\n            // Walk up the directory tree\n            dir = (0, _path.join)(dir, '..');\n        }\n        for (const layoutFile of layoutFiles){\n            const layoutStaticInfo = await (0, _getpagestaticinfo.getAppPageStaticInfo)({\n                nextConfig,\n                pageFilePath: layoutFile,\n                isDev,\n                page,\n                pageType: isInsideAppDir ? _pagetypes.PAGE_TYPES.APP : _pagetypes.PAGE_TYPES.PAGES\n            });\n            segments.unshift(layoutStaticInfo);\n        }\n    }\n    const config = (0, _utils.reduceAppConfig)(segments);\n    return {\n        ...pageStaticInfo,\n        config,\n        runtime: config.runtime,\n        preferredRegion: config.preferredRegion,\n        maxDuration: config.maxDuration\n    };\n}\nfunction getPageFromPath(pagePath, pageExtensions) {\n    let page = (0, _normalizepathsep.normalizePathSep)(pagePath.replace(new RegExp(`\\\\.+(${pageExtensions.join('|')})$`), ''));\n    page = page.replace(/\\/index$/, '');\n    return page === '' ? '/' : page;\n}\nfunction getPageFilePath({ absolutePagePath, pagesDir, appDir, rootDir }) {\n    if (absolutePagePath.startsWith(_constants.PAGES_DIR_ALIAS) && pagesDir) {\n        return absolutePagePath.replace(_constants.PAGES_DIR_ALIAS, pagesDir);\n    }\n    if (absolutePagePath.startsWith(_constants.APP_DIR_ALIAS) && appDir) {\n        return absolutePagePath.replace(_constants.APP_DIR_ALIAS, appDir);\n    }\n    if (absolutePagePath.startsWith(_constants.ROOT_DIR_ALIAS)) {\n        return absolutePagePath.replace(_constants.ROOT_DIR_ALIAS, rootDir);\n    }\n    return require.resolve(absolutePagePath);\n}\nasync function createPagesMapping({ isDev, pageExtensions, pagePaths, pagesType, pagesDir, appDir }) {\n    const isAppRoute = pagesType === 'app';\n    const pages = {};\n    const promises = pagePaths.map(async (pagePath)=>{\n        // Do not process .d.ts files as routes\n        if (pagePath.endsWith('.d.ts') && pageExtensions.includes('ts')) {\n            return;\n        }\n        let pageKey = getPageFromPath(pagePath, pageExtensions);\n        if (isAppRoute) {\n            pageKey = pageKey.replace(/%5F/g, '_');\n            if (pageKey === '/not-found') {\n                pageKey = _constants1.UNDERSCORE_NOT_FOUND_ROUTE_ENTRY;\n            }\n        }\n        const normalizedPath = (0, _normalizepathsep.normalizePathSep)((0, _path.join)(pagesType === 'pages' ? _constants.PAGES_DIR_ALIAS : pagesType === 'app' ? _constants.APP_DIR_ALIAS : _constants.ROOT_DIR_ALIAS, pagePath));\n        let route = pagesType === 'app' ? (0, _getmetadataroute.normalizeMetadataRoute)(pageKey) : pageKey;\n        if (pagesType === 'app' && (0, _ismetadataroute.isMetadataRouteFile)(pagePath, pageExtensions, true)) {\n            const filePath = (0, _path.join)(appDir, pagePath);\n            const staticInfo = await (0, _getpagestaticinfo.getPageStaticInfo)({\n                nextConfig: {},\n                pageFilePath: filePath,\n                isDev,\n                page: pageKey,\n                pageType: pagesType\n            });\n            route = (0, _getmetadataroute.normalizeMetadataPageToRoute)(route, !!(staticInfo.generateImageMetadata || staticInfo.generateSitemaps));\n        }\n        pages[route] = normalizedPath;\n    });\n    await Promise.all(promises);\n    switch(pagesType){\n        case _pagetypes.PAGE_TYPES.ROOT:\n            {\n                return pages;\n            }\n        case _pagetypes.PAGE_TYPES.APP:\n            {\n                const hasAppPages = Object.keys(pages).some((page)=>page.endsWith('/page'));\n                return {\n                    // If there's any app pages existed, add a default not-found page.\n                    // If there's any custom not-found page existed, it will override the default one.\n                    ...hasAppPages && {\n                        [_constants1.UNDERSCORE_NOT_FOUND_ROUTE_ENTRY]: 'next/dist/client/components/not-found-error'\n                    },\n                    ...pages\n                };\n            }\n        case _pagetypes.PAGE_TYPES.PAGES:\n            {\n                if (isDev) {\n                    delete pages['/_app'];\n                    delete pages['/_error'];\n                    delete pages['/_document'];\n                }\n                // In development we always alias these to allow Webpack to fallback to\n                // the correct source file so that HMR can work properly when a file is\n                // added or removed.\n                const root = isDev && pagesDir ? _constants.PAGES_DIR_ALIAS : 'next/dist/pages';\n                return {\n                    '/_app': `${root}/_app`,\n                    '/_error': `${root}/_error`,\n                    '/_document': `${root}/_document`,\n                    ...pages\n                };\n            }\n        default:\n            {\n                return {};\n            }\n    }\n}\nfunction getEdgeServerEntry(opts) {\n    var _opts_config_experimental_sri;\n    if (opts.pagesType === 'app' && (0, _isapprouteroute.isAppRouteRoute)(opts.page) && opts.appDirLoader) {\n        const loaderParams = {\n            absolutePagePath: opts.absolutePagePath,\n            page: opts.page,\n            appDirLoader: Buffer.from(opts.appDirLoader || '').toString('base64'),\n            nextConfig: Buffer.from(JSON.stringify(opts.config)).toString('base64'),\n            preferredRegion: opts.preferredRegion,\n            middlewareConfig: Buffer.from(JSON.stringify(opts.middlewareConfig || {})).toString('base64'),\n            cacheHandlers: JSON.stringify(opts.config.experimental.cacheHandlers || {})\n        };\n        return {\n            import: `next-edge-app-route-loader?${(0, _querystring.stringify)(loaderParams)}!`,\n            layer: _constants.WEBPACK_LAYERS.reactServerComponents\n        };\n    }\n    if ((0, _utils.isMiddlewareFile)(opts.page)) {\n        var _opts_middleware;\n        const loaderParams = {\n            absolutePagePath: opts.absolutePagePath,\n            page: opts.page,\n            rootDir: opts.rootDir,\n            matchers: ((_opts_middleware = opts.middleware) == null ? void 0 : _opts_middleware.matchers) ? (0, _nextmiddlewareloader.encodeMatchers)(opts.middleware.matchers) : '',\n            preferredRegion: opts.preferredRegion,\n            middlewareConfig: Buffer.from(JSON.stringify(opts.middlewareConfig || {})).toString('base64')\n        };\n        return {\n            import: `next-middleware-loader?${(0, _querystring.stringify)(loaderParams)}!`,\n            layer: _constants.WEBPACK_LAYERS.middleware\n        };\n    }\n    if ((0, _isapiroute.isAPIRoute)(opts.page)) {\n        const loaderParams = {\n            absolutePagePath: opts.absolutePagePath,\n            page: opts.page,\n            rootDir: opts.rootDir,\n            preferredRegion: opts.preferredRegion,\n            middlewareConfig: Buffer.from(JSON.stringify(opts.middlewareConfig || {})).toString('base64')\n        };\n        return {\n            import: `next-edge-function-loader?${(0, _querystring.stringify)(loaderParams)}!`,\n            layer: _constants.WEBPACK_LAYERS.apiEdge\n        };\n    }\n    const loaderParams = {\n        absolute500Path: opts.pages['/500'] || '',\n        absoluteAppPath: opts.pages['/_app'],\n        absoluteDocumentPath: opts.pages['/_document'],\n        absoluteErrorPath: opts.pages['/_error'],\n        absolutePagePath: opts.absolutePagePath,\n        dev: opts.isDev,\n        isServerComponent: opts.isServerComponent,\n        page: opts.page,\n        stringifiedConfig: Buffer.from(JSON.stringify(opts.config)).toString('base64'),\n        pagesType: opts.pagesType,\n        appDirLoader: Buffer.from(opts.appDirLoader || '').toString('base64'),\n        sriEnabled: !opts.isDev && !!((_opts_config_experimental_sri = opts.config.experimental.sri) == null ? void 0 : _opts_config_experimental_sri.algorithm),\n        cacheHandler: opts.config.cacheHandler,\n        preferredRegion: opts.preferredRegion,\n        middlewareConfig: Buffer.from(JSON.stringify(opts.middlewareConfig || {})).toString('base64'),\n        serverActions: opts.config.experimental.serverActions,\n        cacheHandlers: JSON.stringify(opts.config.experimental.cacheHandlers || {})\n    };\n    return {\n        import: `next-edge-ssr-loader?${JSON.stringify(loaderParams)}!`,\n        // The Edge bundle includes the server in its entrypoint, so it has to\n        // be in the SSR layer — we later convert the page request to the RSC layer\n        // via a webpack rule.\n        layer: opts.appDirLoader ? _constants.WEBPACK_LAYERS.serverSideRendering : undefined\n    };\n}\nfunction getInstrumentationEntry(opts) {\n    // the '../' is needed to make sure the file is not chunked\n    const filename = `${opts.isEdgeServer ? 'edge-' : opts.isDev ? '' : '../'}${_constants.INSTRUMENTATION_HOOK_FILENAME}.js`;\n    return {\n        import: opts.absolutePagePath,\n        filename,\n        layer: _constants.WEBPACK_LAYERS.instrument\n    };\n}\nfunction getAppLoader() {\n    return process.env.BUILTIN_APP_LOADER ? `builtin:next-app-loader` : 'next-app-loader';\n}\nfunction getAppEntry(opts) {\n    if (process.env.NEXT_RSPACK && process.env.BUILTIN_APP_LOADER) {\n        ;\n        opts.projectRoot = (0, _path.normalize)((0, _path.join)(__dirname, '../../..'));\n    }\n    return {\n        import: `${getAppLoader()}?${(0, _querystring.stringify)(opts)}!`,\n        layer: _constants.WEBPACK_LAYERS.reactServerComponents\n    };\n}\nfunction getClientEntry(opts) {\n    const loaderOptions = {\n        absolutePagePath: opts.absolutePagePath,\n        page: opts.page\n    };\n    const pageLoader = `next-client-pages-loader?${(0, _querystring.stringify)(loaderOptions)}!`;\n    // Make sure next/router is a dependency of _app or else chunk splitting\n    // might cause the router to not be able to load causing hydration\n    // to fail\n    return opts.page === '/_app' ? [\n        pageLoader,\n        require.resolve('../client/router')\n    ] : pageLoader;\n}\nfunction runDependingOnPageType(params) {\n    if (params.pageType === _pagetypes.PAGE_TYPES.ROOT && (0, _utils.isInstrumentationHookFile)(params.page)) {\n        params.onServer();\n        params.onEdgeServer();\n        return;\n    }\n    if ((0, _utils.isMiddlewareFile)(params.page)) {\n        if (params.pageRuntime === 'nodejs') {\n            params.onServer();\n            return;\n        } else {\n            params.onEdgeServer();\n            return;\n        }\n    }\n    if ((0, _isapiroute.isAPIRoute)(params.page)) {\n        if ((0, _isedgeruntime.isEdgeRuntime)(params.pageRuntime)) {\n            params.onEdgeServer();\n            return;\n        }\n        params.onServer();\n        return;\n    }\n    if (params.page === '/_document') {\n        params.onServer();\n        return;\n    }\n    if (params.page === '/_app' || params.page === '/_error' || params.page === '/404' || params.page === '/500') {\n        params.onClient();\n        params.onServer();\n        return;\n    }\n    if ((0, _isedgeruntime.isEdgeRuntime)(params.pageRuntime)) {\n        params.onClient();\n        params.onEdgeServer();\n        return;\n    }\n    params.onClient();\n    params.onServer();\n    return;\n}\nasync function createEntrypoints(params) {\n    const { config, pages, pagesDir, isDev, rootDir, rootPaths, appDir, appPaths, pageExtensions } = params;\n    const edgeServer = {};\n    const server = {};\n    const client = {};\n    let middlewareMatchers = undefined;\n    let appPathsPerRoute = {};\n    if (appDir && appPaths) {\n        for(const pathname in appPaths){\n            const normalizedPath = (0, _apppaths.normalizeAppPath)(pathname);\n            const actualPath = appPaths[pathname];\n            if (!appPathsPerRoute[normalizedPath]) {\n                appPathsPerRoute[normalizedPath] = [];\n            }\n            appPathsPerRoute[normalizedPath].push(// TODO-APP: refactor to pass the page path from createPagesMapping instead.\n            getPageFromPath(actualPath, pageExtensions).replace(_constants.APP_DIR_ALIAS, ''));\n        }\n        // TODO: find a better place to do this\n        (0, _normalizecatchallroutes.normalizeCatchAllRoutes)(appPathsPerRoute);\n        // Make sure to sort parallel routes to make the result deterministic.\n        appPathsPerRoute = Object.fromEntries(Object.entries(appPathsPerRoute).map(([k, v])=>[\n                k,\n                v.sort()\n            ]));\n    }\n    const getEntryHandler = (mappings, pagesType)=>async (page)=>{\n            const bundleFile = (0, _normalizepagepath.normalizePagePath)(page);\n            const clientBundlePath = _path.posix.join(pagesType, bundleFile);\n            const serverBundlePath = pagesType === _pagetypes.PAGE_TYPES.PAGES ? _path.posix.join('pages', bundleFile) : pagesType === _pagetypes.PAGE_TYPES.APP ? _path.posix.join('app', bundleFile) : bundleFile.slice(1);\n            const absolutePagePath = mappings[page];\n            // Handle paths that have aliases\n            const pageFilePath = getPageFilePath({\n                absolutePagePath,\n                pagesDir,\n                appDir,\n                rootDir\n            });\n            const isInsideAppDir = !!appDir && (absolutePagePath.startsWith(_constants.APP_DIR_ALIAS) || absolutePagePath.startsWith(appDir));\n            const staticInfo = await getStaticInfoIncludingLayouts({\n                isInsideAppDir,\n                pageExtensions,\n                pageFilePath,\n                appDir,\n                config,\n                isDev,\n                page\n            });\n            // TODO(timneutkens): remove this\n            const isServerComponent = isInsideAppDir && staticInfo.rsc !== _constants1.RSC_MODULE_TYPES.client;\n            if ((0, _utils.isMiddlewareFile)(page)) {\n                var _staticInfo_middleware;\n                middlewareMatchers = ((_staticInfo_middleware = staticInfo.middleware) == null ? void 0 : _staticInfo_middleware.matchers) ?? [\n                    {\n                        regexp: '.*',\n                        originalSource: '/:path*'\n                    }\n                ];\n            }\n            const isInstrumentation = (0, _utils.isInstrumentationHookFile)(page) && pagesType === _pagetypes.PAGE_TYPES.ROOT;\n            let pageRuntime = staticInfo == null ? void 0 : staticInfo.runtime;\n            if ((0, _utils.isMiddlewareFile)(page) && !config.experimental.nodeMiddleware && pageRuntime === 'nodejs') {\n                _log.warn('nodejs runtime support for middleware requires experimental.nodeMiddleware be enabled in your next.config');\n                pageRuntime = 'edge';\n            }\n            runDependingOnPageType({\n                page,\n                pageRuntime: staticInfo.runtime,\n                pageType: pagesType,\n                onClient: ()=>{\n                    if (isServerComponent || isInsideAppDir) {\n                    // We skip the initial entries for server component pages and let the\n                    // server compiler inject them instead.\n                    } else {\n                        client[clientBundlePath] = getClientEntry({\n                            absolutePagePath,\n                            page\n                        });\n                    }\n                },\n                onServer: ()=>{\n                    if (pagesType === 'app' && appDir) {\n                        const matchedAppPaths = appPathsPerRoute[(0, _apppaths.normalizeAppPath)(page)];\n                        server[serverBundlePath] = getAppEntry({\n                            page,\n                            name: serverBundlePath,\n                            pagePath: absolutePagePath,\n                            appDir,\n                            appPaths: matchedAppPaths,\n                            pageExtensions,\n                            basePath: config.basePath,\n                            assetPrefix: config.assetPrefix,\n                            nextConfigOutput: config.output,\n                            nextConfigExperimentalUseEarlyImport: config.experimental.useEarlyImport ? true : undefined,\n                            preferredRegion: staticInfo.preferredRegion,\n                            middlewareConfig: (0, _utils1.encodeToBase64)(staticInfo.middleware || {})\n                        });\n                    } else if (isInstrumentation) {\n                        server[serverBundlePath.replace('src/', '')] = getInstrumentationEntry({\n                            absolutePagePath,\n                            isEdgeServer: false,\n                            isDev: false\n                        });\n                    } else if ((0, _utils.isMiddlewareFile)(page)) {\n                        server[serverBundlePath.replace('src/', '')] = getEdgeServerEntry({\n                            ...params,\n                            rootDir,\n                            absolutePagePath: absolutePagePath,\n                            bundlePath: clientBundlePath,\n                            isDev: false,\n                            isServerComponent,\n                            page,\n                            middleware: staticInfo == null ? void 0 : staticInfo.middleware,\n                            pagesType,\n                            preferredRegion: staticInfo.preferredRegion,\n                            middlewareConfig: staticInfo.middleware\n                        });\n                    } else if ((0, _isapiroute.isAPIRoute)(page)) {\n                        server[serverBundlePath] = [\n                            (0, _nextrouteloader.getRouteLoaderEntry)({\n                                kind: _routekind.RouteKind.PAGES_API,\n                                page,\n                                absolutePagePath,\n                                preferredRegion: staticInfo.preferredRegion,\n                                middlewareConfig: staticInfo.middleware || {}\n                            })\n                        ];\n                    } else if (!(0, _utils.isMiddlewareFile)(page) && !(0, _isinternalcomponent.isInternalComponent)(absolutePagePath) && !(0, _isinternalcomponent.isNonRoutePagesPage)(page)) {\n                        server[serverBundlePath] = [\n                            (0, _nextrouteloader.getRouteLoaderEntry)({\n                                kind: _routekind.RouteKind.PAGES,\n                                page,\n                                pages,\n                                absolutePagePath,\n                                preferredRegion: staticInfo.preferredRegion,\n                                middlewareConfig: staticInfo.middleware ?? {}\n                            })\n                        ];\n                    } else {\n                        server[serverBundlePath] = [\n                            absolutePagePath\n                        ];\n                    }\n                },\n                onEdgeServer: ()=>{\n                    let appDirLoader = '';\n                    if (isInstrumentation) {\n                        edgeServer[serverBundlePath.replace('src/', '')] = getInstrumentationEntry({\n                            absolutePagePath,\n                            isEdgeServer: true,\n                            isDev: false\n                        });\n                    } else {\n                        if (pagesType === 'app') {\n                            const matchedAppPaths = appPathsPerRoute[(0, _apppaths.normalizeAppPath)(page)];\n                            appDirLoader = getAppEntry({\n                                name: serverBundlePath,\n                                page,\n                                pagePath: absolutePagePath,\n                                appDir: appDir,\n                                appPaths: matchedAppPaths,\n                                pageExtensions,\n                                basePath: config.basePath,\n                                assetPrefix: config.assetPrefix,\n                                nextConfigOutput: config.output,\n                                // This isn't used with edge as it needs to be set on the entry module, which will be the `edgeServerEntry` instead.\n                                // Still passing it here for consistency.\n                                preferredRegion: staticInfo.preferredRegion,\n                                middlewareConfig: Buffer.from(JSON.stringify(staticInfo.middleware || {})).toString('base64')\n                            }).import;\n                        }\n                        edgeServer[serverBundlePath] = getEdgeServerEntry({\n                            ...params,\n                            rootDir,\n                            absolutePagePath: absolutePagePath,\n                            bundlePath: clientBundlePath,\n                            isDev: false,\n                            isServerComponent,\n                            page,\n                            middleware: staticInfo == null ? void 0 : staticInfo.middleware,\n                            pagesType,\n                            appDirLoader,\n                            preferredRegion: staticInfo.preferredRegion,\n                            middlewareConfig: staticInfo.middleware\n                        });\n                    }\n                }\n            });\n        };\n    const promises = [];\n    if (appPaths) {\n        const entryHandler = getEntryHandler(appPaths, _pagetypes.PAGE_TYPES.APP);\n        promises.push(Promise.all(Object.keys(appPaths).map(entryHandler)));\n    }\n    if (rootPaths) {\n        promises.push(Promise.all(Object.keys(rootPaths).map(getEntryHandler(rootPaths, _pagetypes.PAGE_TYPES.ROOT))));\n    }\n    promises.push(Promise.all(Object.keys(pages).map(getEntryHandler(pages, _pagetypes.PAGE_TYPES.PAGES))));\n    await Promise.all(promises);\n    // Optimization: If there's only one instrumentation hook in edge compiler, which means there's no edge server entry.\n    // We remove the edge instrumentation entry from edge compiler as it can be pure server side.\n    if (edgeServer.instrumentation && Object.keys(edgeServer).length === 1) {\n        delete edgeServer.instrumentation;\n    }\n    return {\n        client,\n        server,\n        edgeServer,\n        middlewareMatchers\n    };\n}\nfunction finalizeEntrypoint({ name, compilerType, value, isServerComponent, hasAppDir }) {\n    const entry = typeof value !== 'object' || Array.isArray(value) ? {\n        import: value\n    } : value;\n    const isApi = name.startsWith('pages/api/');\n    const isInstrumentation = (0, _utils.isInstrumentationHookFilename)(name);\n    switch(compilerType){\n        case _constants1.COMPILER_NAMES.server:\n            {\n                const layer = isApi ? _constants.WEBPACK_LAYERS.apiNode : isInstrumentation ? _constants.WEBPACK_LAYERS.instrument : isServerComponent ? _constants.WEBPACK_LAYERS.reactServerComponents : name.startsWith('pages/') ? _constants.WEBPACK_LAYERS.pagesDirNode : undefined;\n                return {\n                    publicPath: isApi ? '' : undefined,\n                    runtime: isApi ? 'webpack-api-runtime' : 'webpack-runtime',\n                    layer,\n                    ...entry\n                };\n            }\n        case _constants1.COMPILER_NAMES.edgeServer:\n            {\n                return {\n                    layer: isApi ? _constants.WEBPACK_LAYERS.apiEdge : (0, _utils.isMiddlewareFilename)(name) || isInstrumentation ? _constants.WEBPACK_LAYERS.middleware : name.startsWith('pages/') ? _constants.WEBPACK_LAYERS.pagesDirEdge : undefined,\n                    library: {\n                        name: [\n                            '_ENTRIES',\n                            `middleware_[name]`\n                        ],\n                        type: 'assign'\n                    },\n                    runtime: _constants1.EDGE_RUNTIME_WEBPACK,\n                    asyncChunks: false,\n                    ...entry\n                };\n            }\n        case _constants1.COMPILER_NAMES.client:\n            {\n                const isAppLayer = hasAppDir && (name === _constants1.CLIENT_STATIC_FILES_RUNTIME_MAIN_APP || name === _constants1.APP_CLIENT_INTERNALS || name.startsWith('app/'));\n                if (// Client special cases\n                name !== _constants1.CLIENT_STATIC_FILES_RUNTIME_POLYFILLS && name !== _constants1.CLIENT_STATIC_FILES_RUNTIME_MAIN && name !== _constants1.CLIENT_STATIC_FILES_RUNTIME_MAIN_APP && name !== _constants1.CLIENT_STATIC_FILES_RUNTIME_AMP && name !== _constants1.CLIENT_STATIC_FILES_RUNTIME_REACT_REFRESH) {\n                    if (isAppLayer) {\n                        return {\n                            dependOn: _constants1.CLIENT_STATIC_FILES_RUNTIME_MAIN_APP,\n                            layer: _constants.WEBPACK_LAYERS.appPagesBrowser,\n                            ...entry\n                        };\n                    }\n                    return {\n                        dependOn: name.startsWith('pages/') && name !== 'pages/_app' ? 'pages/_app' : _constants1.CLIENT_STATIC_FILES_RUNTIME_MAIN,\n                        layer: _constants.WEBPACK_LAYERS.pagesDirBrowser,\n                        ...entry\n                    };\n                }\n                if (isAppLayer) {\n                    return {\n                        layer: _constants.WEBPACK_LAYERS.appPagesBrowser,\n                        ...entry\n                    };\n                }\n                return {\n                    layer: _constants.WEBPACK_LAYERS.pagesDirBrowser,\n                    ...entry\n                };\n            }\n        default:\n            {\n                // Should never happen.\n                throw Object.defineProperty(new Error('Invalid compiler type'), \"__NEXT_ERROR_CODE\", {\n                    value: \"E498\",\n                    enumerable: false,\n                    configurable: true\n                });\n            }\n    }\n}\n\n//# sourceMappingURL=entries.js.map"
        }
    ]
}