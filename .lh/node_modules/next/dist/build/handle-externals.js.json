{
    "sourceFile": "node_modules/next/dist/build/handle-externals.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892655765,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    isResourceInPackages: null,\n    makeExternalHandler: null,\n    resolveExternal: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    isResourceInPackages: function() {\n        return isResourceInPackages;\n    },\n    makeExternalHandler: function() {\n        return makeExternalHandler;\n    },\n    resolveExternal: function() {\n        return resolveExternal;\n    }\n});\nconst _requirehook = require(\"../server/require-hook\");\nconst _constants = require(\"../shared/lib/constants\");\nconst _path = /*#__PURE__*/ _interop_require_default(require(\"../shared/lib/isomorphic/path\"));\nconst _webpackconfig = require(\"./webpack-config\");\nconst _utils = require(\"./utils\");\nconst _normalizepathsep = require(\"../shared/lib/page-path/normalize-path-sep\");\nfunction _interop_require_default(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nconst reactPackagesRegex = /^(react|react-dom|react-server-dom-webpack)($|\\/)/;\nconst pathSeparators = '[/\\\\\\\\]';\nconst optionalEsmPart = `((${pathSeparators}esm)?${pathSeparators})`;\nconst externalFileEnd = '(\\\\.external(\\\\.js)?)$';\nconst nextDist = `next${pathSeparators}dist`;\nconst externalPattern = new RegExp(`${nextDist}${optionalEsmPart}.*${externalFileEnd}`);\nconst nodeModulesRegex = /node_modules[/\\\\].*\\.[mc]?js$/;\nfunction isResourceInPackages(resource, packageNames, packageDirMapping) {\n    if (!packageNames) return false;\n    return packageNames.some((p)=>packageDirMapping && packageDirMapping.has(p) ? resource.startsWith(packageDirMapping.get(p) + _path.default.sep) : resource.includes(_path.default.sep + _path.default.join('node_modules', p.replace(/\\//g, _path.default.sep)) + _path.default.sep));\n}\nasync function resolveExternal(dir, esmExternalsConfig, context, request, isEsmRequested, getResolve, isLocalCallback, baseResolveCheck = true, esmResolveOptions = _webpackconfig.NODE_ESM_RESOLVE_OPTIONS, nodeResolveOptions = _webpackconfig.NODE_RESOLVE_OPTIONS, baseEsmResolveOptions = _webpackconfig.NODE_BASE_ESM_RESOLVE_OPTIONS, baseResolveOptions = _webpackconfig.NODE_BASE_RESOLVE_OPTIONS) {\n    const esmExternals = !!esmExternalsConfig;\n    const looseEsmExternals = esmExternalsConfig === 'loose';\n    let res = null;\n    let isEsm = false;\n    const preferEsmOptions = esmExternals && isEsmRequested ? [\n        true,\n        false\n    ] : [\n        false\n    ];\n    for (const preferEsm of preferEsmOptions){\n        const resolveOptions = preferEsm ? esmResolveOptions : nodeResolveOptions;\n        const resolve = getResolve(resolveOptions);\n        // Resolve the import with the webpack provided context, this\n        // ensures we're resolving the correct version when multiple\n        // exist.\n        try {\n            ;\n            [res, isEsm] = await resolve(context, request);\n        } catch (err) {\n            res = null;\n        }\n        if (!res) {\n            continue;\n        }\n        // ESM externals can only be imported (and not required).\n        // Make an exception in loose mode.\n        if (!isEsmRequested && isEsm && !looseEsmExternals) {\n            continue;\n        }\n        if (isLocalCallback) {\n            return {\n                localRes: isLocalCallback(res)\n            };\n        }\n        // Bundled Node.js code is relocated without its node_modules tree.\n        // This means we need to make sure its request resolves to the same\n        // package that'll be available at runtime. If it's not identical,\n        // we need to bundle the code (even if it _should_ be external).\n        if (baseResolveCheck) {\n            let baseRes;\n            let baseIsEsm;\n            try {\n                const baseResolve = getResolve(isEsm ? baseEsmResolveOptions : baseResolveOptions);\n                [baseRes, baseIsEsm] = await baseResolve(dir, request);\n            } catch (err) {\n                baseRes = null;\n                baseIsEsm = false;\n            }\n            // Same as above: if the package, when required from the root,\n            // would be different from what the real resolution would use, we\n            // cannot externalize it.\n            // if request is pointing to a symlink it could point to the same file,\n            // the resolver will resolve symlinks so this is handled\n            if (baseRes !== res || isEsm !== baseIsEsm) {\n                res = null;\n                continue;\n            }\n        }\n        break;\n    }\n    return {\n        res,\n        isEsm\n    };\n}\nfunction makeExternalHandler({ config, optOutBundlingPackageRegex, transpiledPackages, dir }) {\n    var _config_experimental;\n    let resolvedExternalPackageDirs;\n    const looseEsmExternals = ((_config_experimental = config.experimental) == null ? void 0 : _config_experimental.esmExternals) === 'loose';\n    return async function handleExternals(context, request, dependencyType, layer, getResolve) {\n        // We need to externalize internal requests for files intended to\n        // not be bundled.\n        const isLocal = request.startsWith('.') || // Always check for unix-style path, as webpack sometimes\n        // normalizes as posix.\n        _path.default.posix.isAbsolute(request) || // When on Windows, we also want to check for Windows-specific\n        // absolute paths.\n        process.platform === 'win32' && _path.default.win32.isAbsolute(request);\n        // make sure import \"next\" shows a warning when imported\n        // in pages/components\n        if (request === 'next') {\n            return `commonjs next/dist/lib/import-next-warning`;\n        }\n        const isAppLayer = (0, _utils.isWebpackBundledLayer)(layer);\n        // Relative requires don't need custom resolution, because they\n        // are relative to requests we've already resolved here.\n        // Absolute requires (require('/foo')) are extremely uncommon, but\n        // also have no need for customization as they're already resolved.\n        if (!isLocal) {\n            if (/^next$/.test(request)) {\n                return `commonjs ${request}`;\n            }\n            if (reactPackagesRegex.test(request) && !isAppLayer) {\n                return `commonjs ${request}`;\n            }\n            const notExternalModules = /^(?:private-next-pages\\/|next\\/(?:dist\\/pages\\/|(?:app|cache|document|link|form|head|image|legacy\\/image|constants|dynamic|script|navigation|headers|router|compat\\/router|server)$)|string-hash|private-next-rsc-action-validate|private-next-rsc-action-client-wrapper|private-next-rsc-server-reference|private-next-rsc-cache-wrapper$)/;\n            if (notExternalModules.test(request)) {\n                return;\n            }\n        }\n        // @swc/helpers should not be external as it would\n        // require hoisting the package which we can't rely on\n        if (request.includes('@swc/helpers')) {\n            return;\n        }\n        // BARREL_OPTIMIZATION_PREFIX is a special marker that tells Next.js to\n        // optimize the import by removing unused exports. This has to be compiled.\n        if (request.startsWith(_constants.BARREL_OPTIMIZATION_PREFIX)) {\n            return;\n        }\n        // When in esm externals mode, and using import, we resolve with\n        // ESM resolving options.\n        // Also disable esm request when appDir is enabled\n        const isEsmRequested = dependencyType === 'esm';\n        // Don't bundle @vercel/og nodejs bundle for nodejs runtime.\n        // TODO-APP: bundle route.js with different layer that externals common node_module deps.\n        // Make sure @vercel/og is loaded as ESM for Node.js runtime\n        if ((0, _utils.isWebpackServerOnlyLayer)(layer) && request === 'next/dist/compiled/@vercel/og/index.node.js') {\n            return `module ${request}`;\n        }\n        // Specific Next.js imports that should remain external\n        // TODO-APP: Investigate if we can remove this.\n        if (request.startsWith('next/dist/')) {\n            // Non external that needs to be transpiled\n            // Image loader needs to be transpiled\n            if (/^next[\\\\/]dist[\\\\/]shared[\\\\/]lib[\\\\/]image-loader/.test(request)) {\n                return;\n            }\n            if (/^next[\\\\/]dist[\\\\/]compiled[\\\\/]next-server/.test(request)) {\n                return `commonjs ${request}`;\n            }\n            if (/^next[\\\\/]dist[\\\\/]shared[\\\\/](?!lib[\\\\/]router[\\\\/]router)/.test(request) || /^next[\\\\/]dist[\\\\/]compiled[\\\\/].*\\.c?js$/.test(request)) {\n                return `commonjs ${request}`;\n            }\n            if (/^next[\\\\/]dist[\\\\/]esm[\\\\/]shared[\\\\/](?!lib[\\\\/]router[\\\\/]router)/.test(request) || /^next[\\\\/]dist[\\\\/]compiled[\\\\/].*\\.mjs$/.test(request)) {\n                return `module ${request}`;\n            }\n            return resolveNextExternal(request);\n        }\n        // TODO-APP: Let's avoid this resolve call as much as possible, and eventually get rid of it.\n        const resolveResult = await resolveExternal(dir, config.experimental.esmExternals, context, request, isEsmRequested, getResolve, isLocal ? resolveNextExternal : undefined);\n        if ('localRes' in resolveResult) {\n            return resolveResult.localRes;\n        }\n        // Forcedly resolve the styled-jsx installed by next.js,\n        // since `resolveExternal` cannot find the styled-jsx dep with pnpm\n        if (request === 'styled-jsx/style') {\n            resolveResult.res = _requirehook.defaultOverrides['styled-jsx/style'];\n        }\n        const { res, isEsm } = resolveResult;\n        // If the request cannot be resolved we need to have\n        // webpack \"bundle\" it so it surfaces the not found error.\n        if (!res) {\n            return;\n        }\n        const isOptOutBundling = optOutBundlingPackageRegex.test(res);\n        // Apply bundling rules to all app layers.\n        // Since handleExternals only handle the server layers, we don't need to exclude client here\n        if (!isOptOutBundling && isAppLayer) {\n            return;\n        }\n        // ESM externals can only be imported (and not required).\n        // Make an exception in loose mode.\n        if (!isEsmRequested && isEsm && !looseEsmExternals && !isLocal) {\n            throw Object.defineProperty(new Error(`ESM packages (${request}) need to be imported. Use 'import' to reference the package instead. https://nextjs.org/docs/messages/import-esm-externals`), \"__NEXT_ERROR_CODE\", {\n                value: \"E310\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n        const externalType = isEsm ? 'module' : 'commonjs';\n        // Default pages have to be transpiled\n        if (// This is the @babel/plugin-transform-runtime \"helpers: true\" option\n        /node_modules[/\\\\]@babel[/\\\\]runtime[/\\\\]/.test(res)) {\n            return;\n        }\n        // Webpack itself has to be compiled because it doesn't always use module relative paths\n        if (/node_modules[/\\\\]webpack/.test(res) || /node_modules[/\\\\]css-loader/.test(res)) {\n            return;\n        }\n        // If a package should be transpiled by Next.js, we skip making it external.\n        // It doesn't matter what the extension is, as we'll transpile it anyway.\n        if (transpiledPackages && !resolvedExternalPackageDirs) {\n            resolvedExternalPackageDirs = new Map();\n            // We need to resolve all the external package dirs initially.\n            for (const pkg of transpiledPackages){\n                const pkgRes = await resolveExternal(dir, config.experimental.esmExternals, context, pkg + '/package.json', isEsmRequested, getResolve, isLocal ? resolveNextExternal : undefined);\n                if (pkgRes.res) {\n                    resolvedExternalPackageDirs.set(pkg, _path.default.dirname(pkgRes.res));\n                }\n            }\n        }\n        const resolvedBundlingOptOutRes = resolveBundlingOptOutPackages({\n            resolvedRes: res,\n            config,\n            resolvedExternalPackageDirs,\n            isAppLayer,\n            externalType,\n            isOptOutBundling,\n            request,\n            transpiledPackages\n        });\n        if (resolvedBundlingOptOutRes) {\n            return resolvedBundlingOptOutRes;\n        }\n        // if here, we default to bundling the file\n        return;\n    };\n}\nfunction resolveBundlingOptOutPackages({ resolvedRes, config, resolvedExternalPackageDirs, isAppLayer, externalType, isOptOutBundling, request, transpiledPackages }) {\n    if (nodeModulesRegex.test(resolvedRes)) {\n        const shouldBundlePages = !isAppLayer && config.bundlePagesRouterDependencies && !isOptOutBundling;\n        const shouldBeBundled = shouldBundlePages || isResourceInPackages(resolvedRes, transpiledPackages, resolvedExternalPackageDirs);\n        if (!shouldBeBundled) {\n            return `${externalType} ${request}` // Externalize if not bundled or opted out\n            ;\n        }\n    }\n}\n/**\n * @param localRes the full path to the file\n * @returns the externalized path\n * @description returns an externalized path if the file is a Next.js file and ends with either `.shared-runtime.js` or `.external.js`\n * This is used to ensure that files used across the rendering runtime(s) and the user code are one and the same. The logic in this function\n * will rewrite the require to the correct bundle location depending on the layer at which the file is being used.\n */ function resolveNextExternal(localRes) {\n    const isExternal = externalPattern.test(localRes);\n    // if the file ends with .external, we need to make it a commonjs require in all cases\n    // this is used mainly to share the async local storage across the routing, rendering and user layers.\n    if (isExternal) {\n        // it's important we return the path that starts with `next/dist/` here instead of the absolute path\n        // otherwise NFT will get tripped up\n        return `commonjs ${(0, _normalizepathsep.normalizePathSep)(localRes.replace(/.*?next[/\\\\]dist/, 'next/dist'))}`;\n    }\n}\n\n//# sourceMappingURL=handle-externals.js.map"
        }
    ]
}