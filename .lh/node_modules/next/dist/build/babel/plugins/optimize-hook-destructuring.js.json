{
    "sourceFile": "node_modules/next/dist/build/babel/plugins/optimize-hook-destructuring.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892654429,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"default\", {\n    enumerable: true,\n    get: function() {\n        return _default;\n    }\n});\n// matches any hook-like (the default)\nconst isHook = /^use[A-Z]/;\n// matches only built-in hooks provided by React et al\nconst isBuiltInHook = /^use(Callback|Context|DebugValue|Effect|ImperativeHandle|LayoutEffect|Memo|Reducer|Ref|State)$/;\nfunction _default({ types: t }) {\n    const visitor = {\n        CallExpression (path, state) {\n            const onlyBuiltIns = state.opts.onlyBuiltIns;\n            // if specified, options.lib is a list of libraries that provide hook functions\n            const libs = state.opts.lib && (state.opts.lib === true ? [\n                'react',\n                'preact/hooks'\n            ] : [].concat(state.opts.lib));\n            // skip function calls that are not the init of a variable declaration:\n            if (!t.isVariableDeclarator(path.parent)) return;\n            // skip function calls where the return value is not Array-destructured:\n            if (!t.isArrayPattern(path.parent.id)) return;\n            // name of the (hook) function being called:\n            const hookName = path.node.callee.name;\n            if (libs) {\n                const binding = path.scope.getBinding(hookName);\n                // not an import\n                if (!binding || binding.kind !== 'module') return;\n                const specifier = binding.path.parent.source.value;\n                // not a match\n                if (!libs.some((lib)=>lib === specifier)) return;\n            }\n            // only match function calls with names that look like a hook\n            if (!(onlyBuiltIns ? isBuiltInHook : isHook).test(hookName)) return;\n            path.parent.id = t.objectPattern(path.parent.id.elements.reduce((patterns, element, i)=>{\n                if (element === null) {\n                    return patterns;\n                }\n                return patterns.concat(t.objectProperty(t.numericLiteral(i), // TODO: fix this\n                element));\n            }, []));\n        }\n    };\n    return {\n        name: 'optimize-hook-destructuring',\n        visitor: {\n            // this is a workaround to run before preset-env destroys destructured assignments\n            Program (path, state) {\n                path.traverse(visitor, state);\n            }\n        }\n    };\n}\n\n//# sourceMappingURL=optimize-hook-destructuring.js.map"
        }
    ]
}