{
    "sourceFile": "node_modules/next/dist/build/turbopack-build/index.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892662830,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"turbopackBuild\", {\n    enumerable: true,\n    get: function() {\n        return turbopackBuild;\n    }\n});\nconst _path = /*#__PURE__*/ _interop_require_default(require(\"path\"));\nconst _utils = require(\"../../server/lib/utils\");\nconst _worker = require(\"../../lib/worker\");\nconst _buildcontext = require(\"../build-context\");\nfunction _interop_require_default(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nasync function turbopackBuildWithWorker() {\n    const nodeOptions = (0, _utils.getParsedNodeOptionsWithoutInspect)();\n    try {\n        const worker = new _worker.Worker(_path.default.join(__dirname, 'impl.js'), {\n            exposedMethods: [\n                'workerMain',\n                'waitForShutdown'\n            ],\n            numWorkers: 1,\n            maxRetries: 0,\n            forkOptions: {\n                env: {\n                    ...process.env,\n                    NEXT_PRIVATE_BUILD_WORKER: '1',\n                    NODE_OPTIONS: (0, _utils.formatNodeOptions)(nodeOptions)\n                }\n            }\n        });\n        const { nextBuildSpan, ...prunedBuildContext } = _buildcontext.NextBuildContext;\n        const result = await worker.workerMain({\n            buildContext: prunedBuildContext\n        });\n        // destroy worker when Turbopack has shutdown so it's not sticking around using memory\n        // We need to wait for shutdown to make sure persistent cache is flushed\n        result.shutdownPromise = worker.waitForShutdown().then(()=>{\n            worker.end();\n        });\n        return result;\n    } catch (err) {\n        // When the error is a serialized `Error` object we need to recreate the `Error` instance\n        // in order to keep the consistent error reporting behavior.\n        if (err.type === 'Error') {\n            const error = Object.defineProperty(new Error(err.message), \"__NEXT_ERROR_CODE\", {\n                value: \"E394\",\n                enumerable: false,\n                configurable: true\n            });\n            if (err.name) {\n                error.name = err.name;\n            }\n            if (err.cause) {\n                error.cause = err.cause;\n            }\n            error.message = err.message;\n            error.stack = err.stack;\n            throw error;\n        }\n        throw err;\n    }\n}\nfunction turbopackBuild(withWorker) {\n    if (withWorker) {\n        return turbopackBuildWithWorker();\n    } else {\n        const build = require('./impl').turbopackBuild;\n        return build();\n    }\n}\n\n//# sourceMappingURL=index.js.map"
        }
    ]
}