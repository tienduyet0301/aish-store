{
    "sourceFile": "node_modules/next/dist/build/turbopack-build/impl.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892662754,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    turbopackBuild: null,\n    waitForShutdown: null,\n    workerMain: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    turbopackBuild: function() {\n        return turbopackBuild;\n    },\n    waitForShutdown: function() {\n        return waitForShutdown;\n    },\n    workerMain: function() {\n        return workerMain;\n    }\n});\nconst _path = /*#__PURE__*/ _interop_require_default(require(\"path\"));\nconst _turbopackwarning = require(\"../../lib/turbopack-warning\");\nconst _utils = require(\"../../shared/lib/turbopack/utils\");\nconst _buildcontext = require(\"../build-context\");\nconst _swc = require(\"../swc\");\nconst _handleentrypoints = require(\"../handle-entrypoints\");\nconst _manifestloader = require(\"../../shared/lib/turbopack/manifest-loader\");\nconst _fs = require(\"fs\");\nconst _constants = require(\"../../shared/lib/constants\");\nconst _config = /*#__PURE__*/ _interop_require_default(require(\"../../server/config\"));\nconst _utils1 = require(\"../../export/utils\");\nconst _storage = require(\"../../telemetry/storage\");\nconst _trace = require(\"../../trace\");\nfunction _interop_require_default(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nasync function turbopackBuild() {\n    var _config_experimental, _config_turbopack, _config_experimental1;\n    await (0, _turbopackwarning.validateTurboNextConfig)({\n        dir: _buildcontext.NextBuildContext.dir,\n        isDev: false\n    });\n    const config = _buildcontext.NextBuildContext.config;\n    const dir = _buildcontext.NextBuildContext.dir;\n    const distDir = _buildcontext.NextBuildContext.distDir;\n    const buildId = _buildcontext.NextBuildContext.buildId;\n    const encryptionKey = _buildcontext.NextBuildContext.encryptionKey;\n    const previewProps = _buildcontext.NextBuildContext.previewProps;\n    const hasRewrites = _buildcontext.NextBuildContext.hasRewrites;\n    const rewrites = _buildcontext.NextBuildContext.rewrites;\n    const appDirOnly = _buildcontext.NextBuildContext.appDirOnly;\n    const noMangling = _buildcontext.NextBuildContext.noMangling;\n    const startTime = process.hrtime();\n    const bindings = await (0, _swc.loadBindings)(config == null ? void 0 : (_config_experimental = config.experimental) == null ? void 0 : _config_experimental.useWasmBinary);\n    const dev = false;\n    // const supportedBrowsers = await getSupportedBrowsers(dir, dev)\n    const supportedBrowsers = [\n        'last 1 Chrome versions, last 1 Firefox versions, last 1 Safari versions, last 1 Edge versions'\n    ];\n    const persistentCaching = (0, _utils.isPersistentCachingEnabled)(config);\n    const project = await bindings.turbo.createProject({\n        projectPath: dir,\n        rootPath: ((_config_turbopack = config.turbopack) == null ? void 0 : _config_turbopack.root) || config.outputFileTracingRoot || dir,\n        distDir,\n        nextConfig: config,\n        jsConfig: await (0, _utils.getTurbopackJsConfig)(dir, config),\n        watch: {\n            enable: false\n        },\n        dev,\n        env: process.env,\n        defineEnv: (0, _swc.createDefineEnv)({\n            isTurbopack: true,\n            clientRouterFilters: _buildcontext.NextBuildContext.clientRouterFilters,\n            config,\n            dev,\n            distDir,\n            fetchCacheKeyPrefix: config.experimental.fetchCacheKeyPrefix,\n            hasRewrites,\n            // Implemented separately in Turbopack, doesn't have to be passed here.\n            middlewareMatchers: undefined\n        }),\n        buildId,\n        encryptionKey,\n        previewProps,\n        browserslistQuery: supportedBrowsers.join(', '),\n        noMangling\n    }, {\n        persistentCaching,\n        memoryLimit: (_config_experimental1 = config.experimental) == null ? void 0 : _config_experimental1.turbopackMemoryLimit,\n        dependencyTracking: persistentCaching\n    });\n    try {\n        // Write an empty file in a known location to signal this was built with Turbopack\n        await _fs.promises.writeFile(_path.default.join(distDir, 'turbopack'), '');\n        await _fs.promises.mkdir(_path.default.join(distDir, 'server'), {\n            recursive: true\n        });\n        await _fs.promises.mkdir(_path.default.join(distDir, 'static', buildId), {\n            recursive: true\n        });\n        await _fs.promises.writeFile(_path.default.join(distDir, 'package.json'), JSON.stringify({\n            type: 'commonjs'\n        }, null, 2));\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        const entrypoints = await project.writeAllEntrypointsToDisk(appDirOnly);\n        const manifestLoader = new _manifestloader.TurbopackManifestLoader({\n            buildId,\n            distDir,\n            encryptionKey\n        });\n        const topLevelErrors = [];\n        const topLevelWarnings = [];\n        for (const issue of entrypoints.issues){\n            if (issue.severity === 'error' || issue.severity === 'fatal') {\n                topLevelErrors.push((0, _utils.formatIssue)(issue));\n            } else if ((0, _utils.isRelevantWarning)(issue)) {\n                topLevelWarnings.push((0, _utils.formatIssue)(issue));\n            }\n        }\n        if (topLevelWarnings.length > 0) {\n            console.warn(`Turbopack build encountered ${topLevelWarnings.length} warnings:\\n${topLevelWarnings.join('\\n')}`);\n        }\n        if (topLevelErrors.length > 0) {\n            throw Object.defineProperty(new Error(`Turbopack build failed with ${topLevelErrors.length} errors:\\n${topLevelErrors.join('\\n')}`), \"__NEXT_ERROR_CODE\", {\n                value: \"E425\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n        const currentEntrypoints = await (0, _handleentrypoints.rawEntrypointsToEntrypoints)(entrypoints);\n        const promises = [];\n        if (!appDirOnly) {\n            for (const [page, route] of currentEntrypoints.page){\n                promises.push((0, _handleentrypoints.handleRouteType)({\n                    page,\n                    route,\n                    manifestLoader\n                }));\n            }\n        }\n        for (const [page, route] of currentEntrypoints.app){\n            promises.push((0, _handleentrypoints.handleRouteType)({\n                page,\n                route,\n                manifestLoader\n            }));\n        }\n        await Promise.all(promises);\n        await Promise.all([\n            manifestLoader.loadBuildManifest('_app'),\n            manifestLoader.loadPagesManifest('_app'),\n            manifestLoader.loadFontManifest('_app'),\n            manifestLoader.loadPagesManifest('_document'),\n            manifestLoader.loadBuildManifest('_error'),\n            manifestLoader.loadPagesManifest('_error'),\n            manifestLoader.loadFontManifest('_error'),\n            entrypoints.instrumentation && manifestLoader.loadMiddlewareManifest('instrumentation', 'instrumentation'),\n            entrypoints.middleware && await manifestLoader.loadMiddlewareManifest('middleware', 'middleware')\n        ]);\n        await manifestLoader.writeManifests({\n            devRewrites: undefined,\n            productionRewrites: rewrites,\n            entrypoints: currentEntrypoints\n        });\n        const shutdownPromise = project.shutdown();\n        const time = process.hrtime(startTime);\n        return {\n            duration: time[0] + time[1] / 1e9,\n            buildTraceContext: undefined,\n            shutdownPromise\n        };\n    } catch (err) {\n        await project.shutdown();\n        throw err;\n    }\n}\nlet shutdownPromise;\nasync function workerMain(workerData) {\n    // setup new build context from the serialized data passed from the parent\n    Object.assign(_buildcontext.NextBuildContext, workerData.buildContext);\n    /// load the config because it's not serializable\n    _buildcontext.NextBuildContext.config = await (0, _config.default)(_constants.PHASE_PRODUCTION_BUILD, _buildcontext.NextBuildContext.dir);\n    // Matches handling in build/index.ts\n    // https://github.com/vercel/next.js/blob/84f347fc86f4efc4ec9f13615c215e4b9fb6f8f0/packages/next/src/build/index.ts#L815-L818\n    // Ensures the `config.distDir` option is matched.\n    if ((0, _utils1.hasCustomExportOutput)(_buildcontext.NextBuildContext.config)) {\n        _buildcontext.NextBuildContext.config.distDir = '.next';\n    }\n    // Clone the telemetry for worker\n    const telemetry = new _storage.Telemetry({\n        distDir: _buildcontext.NextBuildContext.config.distDir\n    });\n    (0, _trace.setGlobal)('telemetry', telemetry);\n    const result = await turbopackBuild();\n    shutdownPromise = result.shutdownPromise;\n    return result;\n}\nasync function waitForShutdown() {\n    if (shutdownPromise) {\n        await shutdownPromise;\n    }\n}\n\n//# sourceMappingURL=impl.js.map"
        }
    ]
}