{
    "sourceFile": "node_modules/next/dist/build/index.d.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892655857,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import type { NextConfigComplete } from '../server/config-shared';\nimport type { Revalidate } from '../server/lib/cache-control';\nimport '../lib/setup-exception-listeners';\nimport { Worker } from '../lib/worker';\nimport { RSC_PREFETCH_SUFFIX, RSC_SUFFIX, RSC_SEGMENTS_DIR_SUFFIX, RSC_SEGMENT_SUFFIX } from '../lib/constants';\nimport type { Header, Redirect, Rewrite, RouteHas } from '../lib/load-custom-routes';\nimport type { __ApiPreviewProps } from '../server/api-utils';\nimport { NEXT_ROUTER_PREFETCH_HEADER, RSC_HEADER, RSC_CONTENT_TYPE_HEADER, NEXT_DID_POSTPONE_HEADER, NEXT_ROUTER_SEGMENT_PREFETCH_HEADER, NEXT_REWRITTEN_PATH_HEADER, NEXT_REWRITTEN_QUERY_HEADER } from '../client/components/app-router-headers';\nimport { RenderingMode } from './rendering-mode';\nimport { type PrefetchSegmentDataRoute } from '../server/lib/router-utils/build-prefetch-segment-data-route';\ntype Fallback = null | boolean | string;\nexport interface PrerenderManifestRoute {\n    dataRoute: string | null;\n    experimentalBypassFor?: RouteHas[];\n    /**\n     * The headers that should be served along side this prerendered route.\n     */\n    initialHeaders?: Record<string, string>;\n    /**\n     * The status code that should be served along side this prerendered route.\n     */\n    initialStatus?: number;\n    /**\n     * The revalidate value for this route. This might be inferred from:\n     * - route segment configs\n     * - fetch calls\n     * - unstable_cache\n     * - \"use cache\"\n     */\n    initialRevalidateSeconds: Revalidate;\n    /**\n     * The expire value for this route, which is inferred from the \"use cache\"\n     * functions that are used by the route, or the expireTime config.\n     */\n    initialExpireSeconds: number | undefined;\n    /**\n     * The prefetch data route associated with this page. If not defined, this\n     * page does not support prefetching.\n     */\n    prefetchDataRoute: string | null | undefined;\n    /**\n     * The dynamic route that this statically prerendered route is based on. If\n     * this is null, then the route was not based on a dynamic route.\n     */\n    srcRoute: string | null;\n    /**\n     * @deprecated use `renderingMode` instead\n     */\n    experimentalPPR: boolean | undefined;\n    /**\n     * The rendering mode for this route. Only `undefined` when not an app router\n     * route.\n     */\n    renderingMode: RenderingMode | undefined;\n    /**\n     * The headers that are allowed to be used when revalidating this route. These\n     * are used internally by Next.js to revalidate routes.\n     */\n    allowHeader: string[];\n}\nexport interface DynamicPrerenderManifestRoute {\n    dataRoute: string | null;\n    dataRouteRegex: string | null;\n    experimentalBypassFor?: RouteHas[];\n    fallback: Fallback;\n    /**\n     * When defined, it describes the revalidation configuration for the fallback\n     * route.\n     */\n    fallbackRevalidate: Revalidate | undefined;\n    /**\n     * When defined, it describes the expire configuration for the fallback route.\n     */\n    fallbackExpire: number | undefined;\n    /**\n     * The headers that should used when serving the fallback.\n     */\n    fallbackHeaders?: Record<string, string>;\n    /**\n     * The status code that should be used when serving the fallback.\n     */\n    fallbackStatus?: number;\n    /**\n     * The root params that are unknown for this fallback route.\n     */\n    fallbackRootParams: readonly string[] | undefined;\n    /**\n     * The source route that this fallback route is based on. This is a reference\n     * so that we can associate this dynamic route with the correct source.\n     */\n    fallbackSourceRoute: string | undefined;\n    prefetchDataRoute: string | null | undefined;\n    prefetchDataRouteRegex: string | null | undefined;\n    routeRegex: string;\n    /**\n     * @deprecated use `renderingMode` instead\n     */\n    experimentalPPR: boolean | undefined;\n    /**\n     * The rendering mode for this route. Only `undefined` when not an app router\n     * route.\n     */\n    renderingMode: RenderingMode | undefined;\n    /**\n     * The headers that are allowed to be used when revalidating this route. These\n     * are used internally by Next.js to revalidate routes.\n     */\n    allowHeader: string[];\n}\nexport type PrerenderManifest = {\n    version: 4;\n    routes: {\n        [route: string]: PrerenderManifestRoute;\n    };\n    dynamicRoutes: {\n        [route: string]: DynamicPrerenderManifestRoute;\n    };\n    notFoundRoutes: string[];\n    preview: __ApiPreviewProps;\n};\ntype ManifestBuiltRoute = {\n    /**\n     * The route pattern used to match requests for this route.\n     */\n    regex: string;\n};\nexport type ManifestRewriteRoute = ManifestBuiltRoute & Rewrite;\nexport type ManifestRedirectRoute = ManifestBuiltRoute & Redirect;\nexport type ManifestHeaderRoute = ManifestBuiltRoute & Header;\nexport type ManifestRoute = ManifestBuiltRoute & {\n    page: string;\n    namedRegex?: string;\n    routeKeys?: {\n        [key: string]: string;\n    };\n    prefetchSegmentDataRoutes?: PrefetchSegmentDataRoute[];\n};\ntype ManifestDataRoute = {\n    page: string;\n    routeKeys?: {\n        [key: string]: string;\n    };\n    dataRouteRegex: string;\n    namedDataRouteRegex?: string;\n};\nexport type RoutesManifest = {\n    version: number;\n    pages404: boolean;\n    basePath: string;\n    redirects: Array<Redirect>;\n    rewrites?: Array<ManifestRewriteRoute> | {\n        beforeFiles: Array<ManifestRewriteRoute>;\n        afterFiles: Array<ManifestRewriteRoute>;\n        fallback: Array<ManifestRewriteRoute>;\n    };\n    headers: Array<ManifestHeaderRoute>;\n    staticRoutes: Array<ManifestRoute>;\n    dynamicRoutes: Array<ManifestRoute>;\n    dataRoutes: Array<ManifestDataRoute>;\n    i18n?: {\n        domains?: ReadonlyArray<{\n            http?: true;\n            domain: string;\n            locales?: readonly string[];\n            defaultLocale: string;\n        }>;\n        locales: readonly string[];\n        defaultLocale: string;\n        localeDetection?: false;\n    };\n    rsc: {\n        header: typeof RSC_HEADER;\n        didPostponeHeader: typeof NEXT_DID_POSTPONE_HEADER;\n        contentTypeHeader: typeof RSC_CONTENT_TYPE_HEADER;\n        varyHeader: string;\n        prefetchHeader: typeof NEXT_ROUTER_PREFETCH_HEADER;\n        suffix: typeof RSC_SUFFIX;\n        prefetchSuffix: typeof RSC_PREFETCH_SUFFIX;\n        prefetchSegmentHeader: typeof NEXT_ROUTER_SEGMENT_PREFETCH_HEADER;\n        prefetchSegmentDirSuffix: typeof RSC_SEGMENTS_DIR_SUFFIX;\n        prefetchSegmentSuffix: typeof RSC_SEGMENT_SUFFIX;\n    };\n    rewriteHeaders: {\n        pathHeader: typeof NEXT_REWRITTEN_PATH_HEADER;\n        queryHeader: typeof NEXT_REWRITTEN_QUERY_HEADER;\n    };\n    skipMiddlewareUrlNormalize?: boolean;\n    caseSensitive?: boolean;\n    /**\n     * Configuration related to Partial Prerendering.\n     */\n    ppr?: {\n        /**\n         * The chained response for the PPR resume.\n         */\n        chain: {\n            /**\n             * The headers that will indicate to Next.js that the request is for a PPR\n             * resume.\n             */\n            headers: Record<string, string>;\n        };\n    };\n};\nexport interface FunctionsConfigManifest {\n    version: number;\n    functions: Record<string, {\n        maxDuration?: number | undefined;\n        runtime?: 'nodejs';\n        matchers?: Array<{\n            regexp: string;\n            originalSource: string;\n            has?: Rewrite['has'];\n            missing?: Rewrite['has'];\n        }>;\n    }>;\n}\ntype StaticWorker = typeof import('./worker') & Worker;\nexport declare function createStaticWorker(config: NextConfigComplete, progress?: {\n    run: () => void;\n    clear: () => void;\n}): StaticWorker;\nexport default function build(dir: string, reactProductionProfiling: boolean | undefined, debugOutput: boolean | undefined, runLint: boolean | undefined, noMangling: boolean | undefined, appDirOnly: boolean | undefined, isTurbopack: boolean | undefined, experimentalBuildMode: 'default' | 'compile' | 'generate' | 'generate-env', traceUploadUrl: string | undefined): Promise<void>;\nexport {};\n"
        }
    ]
}