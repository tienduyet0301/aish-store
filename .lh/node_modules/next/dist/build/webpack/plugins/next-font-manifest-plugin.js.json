{
    "sourceFile": "node_modules/next/dist/build/webpack/plugins/next-font-manifest-plugin.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892671748,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"NextFontManifestPlugin\", {\n    enumerable: true,\n    get: function() {\n        return NextFontManifestPlugin;\n    }\n});\nconst _webpack = require(\"next/dist/compiled/webpack/webpack\");\nconst _getroutefromentrypoint = /*#__PURE__*/ _interop_require_default(require(\"../../../server/get-route-from-entrypoint\"));\nconst _constants = require(\"../../../shared/lib/constants\");\nconst _utils = require(\"../utils\");\nconst _path = /*#__PURE__*/ _interop_require_default(require(\"path\"));\nfunction _interop_require_default(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nconst PLUGIN_NAME = 'NextFontManifestPlugin';\n/**\n * When calling font functions with next/font, you can specify if you'd like the font to be preloaded (true by default).\n * e.g.: const inter = Inter({ subsets: ['latin'], preload: true })\n *\n * In that case, next-font-loader will emit the font file as [name].p.[ext] instead of [name].[ext]\n * This function returns those files from an array that can include both preloaded and non-preloaded files.\n */ function getPreloadedFontFiles(fontFiles) {\n    return fontFiles.filter((file)=>/\\.p\\.(woff|woff2|eot|ttf|otf)$/.test(file));\n}\n/**\n * Similarly to getPreloadedFontFiles, but returns true if some of the files includes -s in the name.\n * This means that a font is using size adjust in its fallback font.\n * This was added to enable adding data-size-adjust=\"true\" to the dom, used by the Google Aurora team to collect statistics.\n */ function getPageIsUsingSizeAdjust(fontFiles) {\n    return fontFiles.some((file)=>file.includes('-s'));\n}\nclass NextFontManifestPlugin {\n    constructor(options){\n        this.appDir = options.appDir;\n    }\n    apply(compiler) {\n        compiler.hooks.make.tap(PLUGIN_NAME, (compilation)=>{\n            // In this stage the font files are emitted and we can collect all files emitted by each chunkGroup (entry).\n            compilation.hooks.processAssets.tap({\n                name: PLUGIN_NAME,\n                stage: _webpack.webpack.Compilation.PROCESS_ASSETS_STAGE_ADDITIONS\n            }, ()=>{\n                const nextFontManifest = {\n                    pages: {},\n                    app: {},\n                    appUsingSizeAdjust: false,\n                    pagesUsingSizeAdjust: false\n                };\n                if (this.appDir) {\n                    const appDirBase = _path.default.dirname(this.appDir) + _path.default.sep;\n                    // After all modules are created, we collect the modules that was created by next-font-loader.\n                    (0, _utils.traverseModules)(compilation, (mod, _chunk, chunkGroup)=>{\n                        var _mod_request;\n                        if (mod == null ? void 0 : (_mod_request = mod.request) == null ? void 0 : _mod_request.includes('/next-font-loader/index.js?')) {\n                            var _mod_buildInfo;\n                            if (!((_mod_buildInfo = mod.buildInfo) == null ? void 0 : _mod_buildInfo.assets)) return;\n                            const chunkEntryName = (appDirBase + chunkGroup.name).replace(/[\\\\/]/g, _path.default.sep);\n                            const modAssets = Object.keys(mod.buildInfo.assets);\n                            const fontFiles = modAssets.filter((file)=>/\\.(woff|woff2|eot|ttf|otf)$/.test(file));\n                            // Look if size-adjust fallback font is being used\n                            if (!nextFontManifest.appUsingSizeAdjust) {\n                                nextFontManifest.appUsingSizeAdjust = getPageIsUsingSizeAdjust(fontFiles);\n                            }\n                            const preloadedFontFiles = getPreloadedFontFiles(fontFiles);\n                            // Add an entry of the module's font files in the manifest.\n                            // We'll add an entry even if no files should preload.\n                            // When an entry is present but empty, instead of preloading the font files, a preconnect tag is added.\n                            if (fontFiles.length > 0) {\n                                if (!nextFontManifest.app[chunkEntryName]) {\n                                    nextFontManifest.app[chunkEntryName] = [];\n                                }\n                                nextFontManifest.app[chunkEntryName].push(...preloadedFontFiles);\n                            }\n                        }\n                    }, (chunkGroup)=>{\n                        var _chunkGroup_name;\n                        // Only loop through entrypoints that are under app/.\n                        return !!((_chunkGroup_name = chunkGroup.name) == null ? void 0 : _chunkGroup_name.startsWith('app/'));\n                    });\n                }\n                // Look at all the entrypoints created for pages/.\n                for (const entrypoint of compilation.entrypoints.values()){\n                    const pagePath = (0, _getroutefromentrypoint.default)(entrypoint.name);\n                    if (!pagePath) {\n                        continue;\n                    }\n                    // Get font files from the chunks included in the entrypoint.\n                    const fontFiles = entrypoint.chunks.flatMap((chunk)=>[\n                            ...chunk.auxiliaryFiles\n                        ]).filter((file)=>/\\.(woff|woff2|eot|ttf|otf)$/.test(file));\n                    // Look if size-adjust fallback font is being used\n                    if (!nextFontManifest.pagesUsingSizeAdjust) {\n                        nextFontManifest.pagesUsingSizeAdjust = getPageIsUsingSizeAdjust(fontFiles);\n                    }\n                    const preloadedFontFiles = getPreloadedFontFiles(fontFiles);\n                    // Add an entry of the route's font files in the manifest.\n                    // We'll add an entry even if no files should preload.\n                    // When an entry is present but empty, instead of preloading the font files, a preconnect tag is added.\n                    if (fontFiles.length > 0) {\n                        nextFontManifest.pages[pagePath] = preloadedFontFiles;\n                    }\n                }\n                const manifest = JSON.stringify(nextFontManifest, null);\n                // Create manifest for edge\n                compilation.emitAsset(`server/${_constants.NEXT_FONT_MANIFEST}.js`, new _webpack.sources.RawSource(`self.__NEXT_FONT_MANIFEST=${JSON.stringify(manifest)}`));\n                // Create manifest for server\n                compilation.emitAsset(`server/${_constants.NEXT_FONT_MANIFEST}.json`, new _webpack.sources.RawSource(manifest));\n            });\n        });\n        return;\n    }\n}\n\n//# sourceMappingURL=next-font-manifest-plugin.js.map"
        }
    ]
}