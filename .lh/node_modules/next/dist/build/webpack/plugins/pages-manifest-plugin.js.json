{
    "sourceFile": "node_modules/next/dist/build/webpack/plugins/pages-manifest-plugin.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892672253,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    default: null,\n    edgeServerAppPaths: null,\n    edgeServerPages: null,\n    nodeServerAppPaths: null,\n    nodeServerPages: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    // This plugin creates a pages-manifest.json from page entrypoints.\n    // This is used for mapping paths like `/` to `.next/server/static/<buildid>/pages/index.js` when doing SSR\n    // It's also used by next export to provide defaultPathMap\n    default: function() {\n        return PagesManifestPlugin;\n    },\n    edgeServerAppPaths: function() {\n        return edgeServerAppPaths;\n    },\n    edgeServerPages: function() {\n        return edgeServerPages;\n    },\n    nodeServerAppPaths: function() {\n        return nodeServerAppPaths;\n    },\n    nodeServerPages: function() {\n        return nodeServerPages;\n    }\n});\nconst _path = /*#__PURE__*/ _interop_require_default(require(\"path\"));\nconst _promises = /*#__PURE__*/ _interop_require_default(require(\"fs/promises\"));\nconst _webpack = require(\"next/dist/compiled/webpack/webpack\");\nconst _constants = require(\"../../../shared/lib/constants\");\nconst _getroutefromentrypoint = /*#__PURE__*/ _interop_require_default(require(\"../../../server/get-route-from-entrypoint\"));\nconst _normalizepathsep = require(\"../../../shared/lib/page-path/normalize-path-sep\");\nfunction _interop_require_default(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nlet edgeServerPages = {};\nlet nodeServerPages = {};\nlet edgeServerAppPaths = {};\nlet nodeServerAppPaths = {};\nclass PagesManifestPlugin {\n    constructor({ dev, distDir, isEdgeRuntime, appDirEnabled }){\n        this.dev = dev;\n        this.distDir = distDir;\n        this.isEdgeRuntime = isEdgeRuntime;\n        this.appDirEnabled = appDirEnabled;\n    }\n    async createAssets(compilation) {\n        const entrypoints = compilation.entrypoints;\n        const pages = {};\n        const appPaths = {};\n        for (const entrypoint of entrypoints.values()){\n            const pagePath = (0, _getroutefromentrypoint.default)(entrypoint.name, this.appDirEnabled);\n            if (!pagePath) {\n                continue;\n            }\n            const files = entrypoint.getFiles().filter((file)=>!file.includes('webpack-runtime') && !file.includes('webpack-api-runtime') && file.endsWith('.js'));\n            // Skip entries which are empty\n            if (!files.length) {\n                continue;\n            }\n            // Write filename, replace any backslashes in path (on windows) with forwardslashes for cross-platform consistency.\n            let file = files[files.length - 1];\n            if (!this.dev) {\n                if (!this.isEdgeRuntime) {\n                    file = file.slice(3);\n                }\n            }\n            file = (0, _normalizepathsep.normalizePathSep)(file);\n            if (entrypoint.name.startsWith('app/')) {\n                appPaths[pagePath] = file;\n            } else {\n                pages[pagePath] = file;\n            }\n        }\n        // This plugin is used by both the Node server and Edge server compilers,\n        // we need to merge both pages to generate the full manifest.\n        if (this.isEdgeRuntime) {\n            edgeServerPages = pages;\n            edgeServerAppPaths = appPaths;\n        } else {\n            nodeServerPages = pages;\n            nodeServerAppPaths = appPaths;\n        }\n        // handle parallel compilers writing to the same\n        // manifest path by merging existing manifest with new\n        const writeMergedManifest = async (manifestPath, entries)=>{\n            await _promises.default.mkdir(_path.default.dirname(manifestPath), {\n                recursive: true\n            });\n            await _promises.default.writeFile(manifestPath, JSON.stringify({\n                ...await _promises.default.readFile(manifestPath, 'utf8').then((res)=>JSON.parse(res)).catch(()=>({})),\n                ...entries\n            }, null, 2));\n        };\n        if (this.distDir) {\n            const pagesManifestPath = _path.default.join(this.distDir, 'server', _constants.PAGES_MANIFEST);\n            await writeMergedManifest(pagesManifestPath, {\n                ...edgeServerPages,\n                ...nodeServerPages\n            });\n        } else {\n            const pagesManifestPath = (!this.dev && !this.isEdgeRuntime ? '../' : '') + _constants.PAGES_MANIFEST;\n            compilation.emitAsset(pagesManifestPath, new _webpack.sources.RawSource(JSON.stringify({\n                ...edgeServerPages,\n                ...nodeServerPages\n            }, null, 2)));\n        }\n        if (this.appDirEnabled) {\n            if (this.distDir) {\n                const appPathsManifestPath = _path.default.join(this.distDir, 'server', _constants.APP_PATHS_MANIFEST);\n                await writeMergedManifest(appPathsManifestPath, {\n                    ...edgeServerAppPaths,\n                    ...nodeServerAppPaths\n                });\n            } else {\n                compilation.emitAsset((!this.dev && !this.isEdgeRuntime ? '../' : '') + _constants.APP_PATHS_MANIFEST, new _webpack.sources.RawSource(JSON.stringify({\n                    ...edgeServerAppPaths,\n                    ...nodeServerAppPaths\n                }, null, 2)));\n            }\n        }\n    }\n    apply(compiler) {\n        compiler.hooks.make.tap('NextJsPagesManifest', (compilation)=>{\n            compilation.hooks.processAssets.tapPromise({\n                name: 'NextJsPagesManifest',\n                stage: _webpack.webpack.Compilation.PROCESS_ASSETS_STAGE_ADDITIONS\n            }, ()=>this.createAssets(compilation));\n        });\n    }\n}\n\n//# sourceMappingURL=pages-manifest-plugin.js.map"
        }
    ]
}