{
    "sourceFile": "node_modules/next/dist/build/webpack/plugins/css-chunking-plugin.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892670740,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"CssChunkingPlugin\", {\n    enumerable: true,\n    get: function() {\n        return CssChunkingPlugin;\n    }\n});\nconst PLUGIN_NAME = 'CssChunkingPlugin';\n/**\n * Merge chunks until they are bigger than the target size.\n */ const MIN_CSS_CHUNK_SIZE = 30 * 1024;\n/**\n * Avoid merging chunks when they would be bigger than this size.\n */ const MAX_CSS_CHUNK_SIZE = 100 * 1024;\nfunction isGlobalCss(module) {\n    return !/\\.module\\.(css|scss|sass)$/.test(module.nameForCondition() || '');\n}\nclass CssChunkingPlugin {\n    constructor(strict){\n        this.strict = strict;\n    }\n    apply(compiler) {\n        const strict = this.strict;\n        const summary = !!process.env.CSS_CHUNKING_SUMMARY;\n        compiler.hooks.thisCompilation.tap(PLUGIN_NAME, (compilation)=>{\n            let once = false;\n            compilation.hooks.optimizeChunks.tap({\n                name: PLUGIN_NAME,\n                stage: 5\n            }, ()=>{\n                if (once) {\n                    return;\n                }\n                once = true;\n                const chunkGraph = compilation.chunkGraph;\n                let changed = undefined;\n                const chunkStates = new Map();\n                const chunkStatesByModule = new Map();\n                // Collect all css modules in chunks and the execpted order of them\n                for (const chunk of compilation.chunks){\n                    var _chunk_name;\n                    if ((_chunk_name = chunk.name) == null ? void 0 : _chunk_name.startsWith('pages/')) continue;\n                    const modules = [];\n                    for (const module of chunkGraph.getChunkModulesIterable(chunk)){\n                        var _module_type;\n                        if (!((_module_type = module.type) == null ? void 0 : _module_type.startsWith('css'))) continue;\n                        modules.push(module);\n                    }\n                    if (!modules.length) continue;\n                    const chunkState = {\n                        chunk,\n                        modules,\n                        order: 0,\n                        requests: modules.length\n                    };\n                    chunkStates.set(chunk, chunkState);\n                    for(let i = 0; i < modules.length; i++){\n                        const module = modules[i];\n                        let moduleChunkStates = chunkStatesByModule.get(module);\n                        if (!moduleChunkStates) {\n                            moduleChunkStates = new Map();\n                            chunkStatesByModule.set(module, moduleChunkStates);\n                        }\n                        moduleChunkStates.set(chunkState, i);\n                        chunkStatesByModule.set(module, moduleChunkStates);\n                    }\n                }\n                // Sort modules by their index sum\n                const orderedModules = [];\n                for (const [module, moduleChunkStates] of chunkStatesByModule){\n                    let sum = 0;\n                    for (const i of moduleChunkStates.values()){\n                        sum += i;\n                    }\n                    orderedModules.push({\n                        module,\n                        sum\n                    });\n                }\n                orderedModules.sort((a, b)=>a.sum - b.sum);\n                // A queue of modules that still need to be processed\n                const remainingModules = new Set(orderedModules.map(({ module })=>module));\n                // In loose mode we guess the dependents of modules from the order\n                // assuming that when a module is a dependency of another module\n                // it will always appear before it in every chunk.\n                const allDependents = new Map();\n                if (!this.strict) {\n                    for (const b of remainingModules){\n                        const dependent = new Set();\n                        loop: for (const a of remainingModules){\n                            if (a === b) continue;\n                            // check if a depends on b\n                            for (const [chunkState, ia] of chunkStatesByModule.get(a)){\n                                const bChunkStates = chunkStatesByModule.get(b);\n                                const ib = bChunkStates.get(chunkState);\n                                if (ib === undefined) {\n                                    continue loop;\n                                }\n                                if (ib > ia) {\n                                    continue loop;\n                                }\n                            }\n                            dependent.add(a);\n                        }\n                        if (dependent.size > 0) allDependents.set(b, dependent);\n                    }\n                }\n                // Stores the new chunk for every module\n                const newChunksByModule = new Map();\n                // Process through all modules\n                for (const startModule of remainingModules){\n                    let globalCssMode = isGlobalCss(startModule);\n                    // The current position of processing in all selected chunks\n                    let allChunkStates = new Map(chunkStatesByModule.get(startModule));\n                    // The list of modules that goes into the new chunk\n                    const newChunkModules = new Set([\n                        startModule\n                    ]);\n                    // The current size of the new chunk\n                    let currentSize = startModule.size();\n                    // A pool of potential modules where the next module is selected from.\n                    // It's filled from the next module of the selected modules in every chunk.\n                    // It also keeps some metadata to improve performance [size, chunkStates].\n                    const potentialNextModules = new Map();\n                    for (const [chunkState, i] of allChunkStates){\n                        const nextModule = chunkState.modules[i + 1];\n                        if (nextModule && remainingModules.has(nextModule)) {\n                            potentialNextModules.set(nextModule, [\n                                nextModule.size(),\n                                chunkStatesByModule.get(nextModule)\n                            ]);\n                        }\n                    }\n                    // Try to add modules to the chunk until a break condition is met\n                    let cont;\n                    do {\n                        cont = false;\n                        // We try to select a module that reduces request count and\n                        // has the highest number of requests\n                        const orderedPotentialNextModules = [];\n                        for (const [nextModule, [size, nextChunkStates]] of potentialNextModules){\n                            let maxRequests = 0;\n                            for (const chunkState of nextChunkStates.keys()){\n                                // There is always some overlap\n                                if (allChunkStates.has(chunkState)) {\n                                    maxRequests = Math.max(maxRequests, chunkState.requests);\n                                }\n                            }\n                            orderedPotentialNextModules.push([\n                                nextModule,\n                                size,\n                                nextChunkStates,\n                                maxRequests\n                            ]);\n                        }\n                        orderedPotentialNextModules.sort((a, b)=>b[3] - a[3] || (a[0].identifier() < b[0].identifier() ? -1 : 1));\n                        // Try every potential module\n                        loop: for (const [nextModule, size, nextChunkStates] of orderedPotentialNextModules){\n                            if (currentSize + size > MAX_CSS_CHUNK_SIZE) {\n                                continue;\n                            }\n                            if (!strict) {\n                                // In loose mode we only check if the dependencies are not violated\n                                const dependent = allDependents.get(nextModule);\n                                if (dependent) {\n                                    for (const dep of dependent){\n                                        if (newChunkModules.has(dep)) {\n                                            continue loop;\n                                        }\n                                    }\n                                }\n                            } else {\n                                // In strict mode we check that none of the order in any chunk is changed by adding the module\n                                for (const [chunkState, i] of nextChunkStates){\n                                    const prevState = allChunkStates.get(chunkState);\n                                    if (prevState === undefined) {\n                                        // New chunk group, can add it, but should we?\n                                        // We only add that if below min size\n                                        if (currentSize < MIN_CSS_CHUNK_SIZE) {\n                                            continue;\n                                        } else {\n                                            continue loop;\n                                        }\n                                    } else if (prevState + 1 === i) {\n                                        continue;\n                                    } else {\n                                        continue loop;\n                                    }\n                                }\n                            }\n                            // Global CSS must not leak into unrelated chunks\n                            const nextIsGlobalCss = isGlobalCss(nextModule);\n                            if (nextIsGlobalCss && globalCssMode) {\n                                if (allChunkStates.size !== nextChunkStates.size) {\n                                    continue;\n                                }\n                            }\n                            if (globalCssMode) {\n                                for (const chunkState of nextChunkStates.keys()){\n                                    if (!allChunkStates.has(chunkState)) {\n                                        continue loop;\n                                    }\n                                }\n                            }\n                            if (nextIsGlobalCss) {\n                                for (const chunkState of allChunkStates.keys()){\n                                    if (!nextChunkStates.has(chunkState)) {\n                                        continue loop;\n                                    }\n                                }\n                            }\n                            potentialNextModules.delete(nextModule);\n                            currentSize += size;\n                            if (nextIsGlobalCss) {\n                                globalCssMode = true;\n                            }\n                            for (const [chunkState, i] of nextChunkStates){\n                                if (allChunkStates.has(chunkState)) {\n                                    // This reduces the request count of the chunk group\n                                    chunkState.requests--;\n                                }\n                                allChunkStates.set(chunkState, i);\n                                const newNextModule = chunkState.modules[i + 1];\n                                if (newNextModule && remainingModules.has(newNextModule) && !newChunkModules.has(newNextModule)) {\n                                    potentialNextModules.set(newNextModule, [\n                                        newNextModule.size(),\n                                        chunkStatesByModule.get(newNextModule)\n                                    ]);\n                                }\n                            }\n                            newChunkModules.add(nextModule);\n                            cont = true;\n                            break;\n                        }\n                    }while (cont);\n                    const newChunk = compilation.addChunk();\n                    newChunk.preventIntegration = true;\n                    newChunk.idNameHints.add('css');\n                    for (const module of newChunkModules){\n                        remainingModules.delete(module);\n                        chunkGraph.connectChunkAndModule(newChunk, module);\n                        newChunksByModule.set(module, newChunk);\n                    }\n                    changed = true;\n                }\n                for (const { chunk, modules } of chunkStates.values()){\n                    const chunks = new Set();\n                    for (const module of modules){\n                        const newChunk = newChunksByModule.get(module);\n                        if (newChunk) {\n                            chunkGraph.disconnectChunkAndModule(chunk, module);\n                            if (chunks.has(newChunk)) continue;\n                            chunks.add(newChunk);\n                            chunk.split(newChunk);\n                        }\n                    }\n                }\n                if (summary) {\n                    console.log('Top 20 chunks by request count:');\n                    const orderedChunkStates = [\n                        ...chunkStates.values()\n                    ];\n                    orderedChunkStates.sort((a, b)=>b.requests - a.requests);\n                    for (const { chunk, modules, requests } of orderedChunkStates.slice(0, 20)){\n                        console.log(`- ${requests} requests for ${chunk.name} (has ${modules.length} modules)`);\n                    }\n                }\n                return changed;\n            });\n        });\n    }\n}\n\n//# sourceMappingURL=css-chunking-plugin.js.map"
        }
    ]
}