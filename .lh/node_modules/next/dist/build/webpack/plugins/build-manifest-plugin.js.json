{
    "sourceFile": "node_modules/next/dist/build/webpack/plugins/build-manifest-plugin.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892670585,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    createEdgeRuntimeManifest: null,\n    default: null,\n    generateClientManifest: null,\n    getEntrypointFiles: null,\n    normalizeRewritesForBuildManifest: null,\n    processRoute: null,\n    srcEmptySsgManifest: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    createEdgeRuntimeManifest: function() {\n        return createEdgeRuntimeManifest;\n    },\n    // This plugin creates a build-manifest.json for all assets that are being output\n    // It has a mapping of \"entry\" filename to real filename. Because the real filename can be hashed in production\n    default: function() {\n        return BuildManifestPlugin;\n    },\n    generateClientManifest: function() {\n        return generateClientManifest;\n    },\n    getEntrypointFiles: function() {\n        return getEntrypointFiles;\n    },\n    normalizeRewritesForBuildManifest: function() {\n        return normalizeRewritesForBuildManifest;\n    },\n    processRoute: function() {\n        return processRoute;\n    },\n    srcEmptySsgManifest: function() {\n        return srcEmptySsgManifest;\n    }\n});\nconst _devalue = /*#__PURE__*/ _interop_require_default(require(\"next/dist/compiled/devalue\"));\nconst _webpack = require(\"next/dist/compiled/webpack/webpack\");\nconst _constants = require(\"../../../shared/lib/constants\");\nconst _getroutefromentrypoint = /*#__PURE__*/ _interop_require_default(require(\"../../../server/get-route-from-entrypoint\"));\nconst _nextdropclientpageplugin = require(\"./next-drop-client-page-plugin\");\nconst _utils = require(\"../../../shared/lib/router/utils\");\nconst _trace = require(\"../../../trace\");\nconst _utils1 = require(\"../utils\");\nfunction _interop_require_default(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nconst srcEmptySsgManifest = `self.__SSG_MANIFEST=new Set;self.__SSG_MANIFEST_CB&&self.__SSG_MANIFEST_CB()`;\n// nodejs: '/static/<build id>/low-priority.js'\nfunction buildNodejsLowPriorityPath(filename, buildId) {\n    return `${_constants.CLIENT_STATIC_FILES_PATH}/${buildId}/${filename}`;\n}\nfunction createEdgeRuntimeManifest(originAssetMap) {\n    const manifestFilenames = [\n        '_buildManifest.js',\n        '_ssgManifest.js'\n    ];\n    const assetMap = {\n        ...originAssetMap,\n        lowPriorityFiles: []\n    };\n    // we use globalThis here because middleware can be node\n    // which doesn't have \"self\"\n    const manifestDefCode = `globalThis.__BUILD_MANIFEST = ${JSON.stringify(assetMap, null, 2)};\\n`;\n    // edge lowPriorityFiles item: '\"/static/\" + process.env.__NEXT_BUILD_ID + \"/low-priority.js\"'.\n    // Since lowPriorityFiles is not fixed and relying on `process.env.__NEXT_BUILD_ID`, we'll produce code creating it dynamically.\n    const lowPriorityFilesCode = `globalThis.__BUILD_MANIFEST.lowPriorityFiles = [\\n` + manifestFilenames.map((filename)=>{\n        return `\"/static/\" + process.env.__NEXT_BUILD_ID + \"/${filename}\",\\n`;\n    }).join(',') + `\\n];`;\n    return manifestDefCode + lowPriorityFilesCode;\n}\nfunction normalizeRewrite(item) {\n    return {\n        has: item.has,\n        source: item.source,\n        destination: item.destination\n    };\n}\nfunction normalizeRewritesForBuildManifest(rewrites) {\n    var _rewrites_afterFiles_map, _rewrites_afterFiles, _rewrites_beforeFiles_map, _rewrites_beforeFiles, _rewrites_fallback_map, _rewrites_fallback;\n    return {\n        afterFiles: (_rewrites_afterFiles = rewrites.afterFiles) == null ? void 0 : (_rewrites_afterFiles_map = _rewrites_afterFiles.map(processRoute)) == null ? void 0 : _rewrites_afterFiles_map.map((item)=>normalizeRewrite(item)),\n        beforeFiles: (_rewrites_beforeFiles = rewrites.beforeFiles) == null ? void 0 : (_rewrites_beforeFiles_map = _rewrites_beforeFiles.map(processRoute)) == null ? void 0 : _rewrites_beforeFiles_map.map((item)=>normalizeRewrite(item)),\n        fallback: (_rewrites_fallback = rewrites.fallback) == null ? void 0 : (_rewrites_fallback_map = _rewrites_fallback.map(processRoute)) == null ? void 0 : _rewrites_fallback_map.map((item)=>normalizeRewrite(item))\n    };\n}\nfunction generateClientManifest(assetMap, rewrites, clientRouterFilters, compiler, compilation) {\n    const compilationSpan = compilation ? (0, _utils1.getCompilationSpan)(compilation) : compiler ? (0, _utils1.getCompilationSpan)(compiler) : new _trace.Span({\n        name: 'client-manifest'\n    });\n    const genClientManifestSpan = compilationSpan == null ? void 0 : compilationSpan.traceChild('NextJsBuildManifest-generateClientManifest');\n    return genClientManifestSpan == null ? void 0 : genClientManifestSpan.traceFn(()=>{\n        const clientManifest = {\n            __rewrites: normalizeRewritesForBuildManifest(rewrites),\n            __routerFilterStatic: clientRouterFilters == null ? void 0 : clientRouterFilters.staticFilter,\n            __routerFilterDynamic: clientRouterFilters == null ? void 0 : clientRouterFilters.dynamicFilter\n        };\n        const appDependencies = new Set(assetMap.pages['/_app']);\n        const sortedPageKeys = (0, _utils.getSortedRoutes)(Object.keys(assetMap.pages));\n        sortedPageKeys.forEach((page)=>{\n            const dependencies = assetMap.pages[page];\n            if (page === '/_app') return;\n            // Filter out dependencies in the _app entry, because those will have already\n            // been loaded by the client prior to a navigation event\n            const filteredDeps = dependencies.filter((dep)=>!appDependencies.has(dep));\n            // The manifest can omit the page if it has no requirements\n            if (filteredDeps.length) {\n                clientManifest[page] = filteredDeps;\n            }\n        });\n        // provide the sorted pages as an array so we don't rely on the object's keys\n        // being in order and we don't slow down look-up time for page assets\n        clientManifest.sortedPages = sortedPageKeys;\n        return (0, _devalue.default)(clientManifest);\n    });\n}\nfunction getEntrypointFiles(entrypoint) {\n    return (entrypoint == null ? void 0 : entrypoint.getFiles().filter((file)=>{\n        // We don't want to include `.hot-update.js` files into the initial page\n        return /(?<!\\.hot-update)\\.(js|css)($|\\?)/.test(file);\n    }).map((file)=>file.replace(/\\\\/g, '/'))) ?? [];\n}\nconst processRoute = (r)=>{\n    var _rewrite_destination;\n    const rewrite = {\n        ...r\n    };\n    // omit external rewrite destinations since these aren't\n    // handled client-side\n    if (!(rewrite == null ? void 0 : (_rewrite_destination = rewrite.destination) == null ? void 0 : _rewrite_destination.startsWith('/'))) {\n        delete rewrite.destination;\n    }\n    return rewrite;\n};\nclass BuildManifestPlugin {\n    constructor(options){\n        this.buildId = options.buildId;\n        this.isDevFallback = !!options.isDevFallback;\n        this.rewrites = {\n            beforeFiles: [],\n            afterFiles: [],\n            fallback: []\n        };\n        this.appDirEnabled = options.appDirEnabled;\n        this.clientRouterFilters = options.clientRouterFilters;\n        this.rewrites.beforeFiles = options.rewrites.beforeFiles.map(processRoute);\n        this.rewrites.afterFiles = options.rewrites.afterFiles.map(processRoute);\n        this.rewrites.fallback = options.rewrites.fallback.map(processRoute);\n    }\n    createAssets(compiler, compilation) {\n        const compilationSpan = (0, _utils1.getCompilationSpan)(compilation) ?? (0, _utils1.getCompilationSpan)(compiler);\n        if (!compilationSpan) {\n            throw Object.defineProperty(new Error('No span found for compilation'), \"__NEXT_ERROR_CODE\", {\n                value: \"E646\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n        const createAssetsSpan = compilationSpan.traceChild('NextJsBuildManifest-createassets');\n        return createAssetsSpan.traceFn(()=>{\n            const entrypoints = compilation.entrypoints;\n            const assetMap = {\n                polyfillFiles: [],\n                devFiles: [],\n                ampDevFiles: [],\n                lowPriorityFiles: [],\n                rootMainFiles: [],\n                rootMainFilesTree: {},\n                pages: {\n                    '/_app': []\n                },\n                ampFirstPages: []\n            };\n            const ampFirstEntryNames = _nextdropclientpageplugin.ampFirstEntryNamesMap.get(compilation);\n            if (ampFirstEntryNames) {\n                for (const entryName of ampFirstEntryNames){\n                    const pagePath = (0, _getroutefromentrypoint.default)(entryName);\n                    if (!pagePath) {\n                        continue;\n                    }\n                    assetMap.ampFirstPages.push(pagePath);\n                }\n            }\n            const mainFiles = new Set(getEntrypointFiles(entrypoints.get(_constants.CLIENT_STATIC_FILES_RUNTIME_MAIN)));\n            if (this.appDirEnabled) {\n                assetMap.rootMainFiles = [\n                    ...new Set(getEntrypointFiles(entrypoints.get(_constants.CLIENT_STATIC_FILES_RUNTIME_MAIN_APP)))\n                ];\n            }\n            const compilationAssets = compilation.getAssets();\n            assetMap.polyfillFiles = compilationAssets.filter((p)=>{\n                // Ensure only .js files are passed through\n                if (!p.name.endsWith('.js')) {\n                    return false;\n                }\n                return p.info && _constants.CLIENT_STATIC_FILES_RUNTIME_POLYFILLS_SYMBOL in p.info;\n            }).map((v)=>v.name);\n            assetMap.devFiles = getEntrypointFiles(entrypoints.get(_constants.CLIENT_STATIC_FILES_RUNTIME_REACT_REFRESH)).filter((file)=>!mainFiles.has(file));\n            assetMap.ampDevFiles = getEntrypointFiles(entrypoints.get(_constants.CLIENT_STATIC_FILES_RUNTIME_AMP));\n            for (const entrypoint of compilation.entrypoints.values()){\n                if (_constants.SYSTEM_ENTRYPOINTS.has(entrypoint.name)) continue;\n                const pagePath = (0, _getroutefromentrypoint.default)(entrypoint.name);\n                if (!pagePath) {\n                    continue;\n                }\n                const filesForPage = getEntrypointFiles(entrypoint);\n                assetMap.pages[pagePath] = [\n                    ...new Set([\n                        ...mainFiles,\n                        ...filesForPage\n                    ])\n                ];\n            }\n            if (!this.isDevFallback) {\n                // Add the runtime build manifest file (generated later in this file)\n                // as a dependency for the app. If the flag is false, the file won't be\n                // downloaded by the client.\n                const buildManifestPath = buildNodejsLowPriorityPath('_buildManifest.js', this.buildId);\n                const ssgManifestPath = buildNodejsLowPriorityPath('_ssgManifest.js', this.buildId);\n                assetMap.lowPriorityFiles.push(buildManifestPath, ssgManifestPath);\n                compilation.emitAsset(ssgManifestPath, new _webpack.sources.RawSource(srcEmptySsgManifest));\n            }\n            assetMap.pages = Object.keys(assetMap.pages).sort().reduce(// eslint-disable-next-line\n            (a, c)=>(a[c] = assetMap.pages[c], a), {});\n            let buildManifestName = _constants.BUILD_MANIFEST;\n            if (this.isDevFallback) {\n                buildManifestName = `fallback-${_constants.BUILD_MANIFEST}`;\n            }\n            compilation.emitAsset(buildManifestName, new _webpack.sources.RawSource(JSON.stringify(assetMap, null, 2)));\n            compilation.emitAsset(`server/${_constants.MIDDLEWARE_BUILD_MANIFEST}.js`, new _webpack.sources.RawSource(`${createEdgeRuntimeManifest(assetMap)}`));\n            if (!this.isDevFallback) {\n                compilation.emitAsset(`${_constants.CLIENT_STATIC_FILES_PATH}/${this.buildId}/_buildManifest.js`, new _webpack.sources.RawSource(`self.__BUILD_MANIFEST = ${generateClientManifest(assetMap, this.rewrites, this.clientRouterFilters, compiler, compilation)};self.__BUILD_MANIFEST_CB && self.__BUILD_MANIFEST_CB()`));\n            }\n        });\n    }\n    apply(compiler) {\n        compiler.hooks.make.tap('NextJsBuildManifest', (compilation)=>{\n            compilation.hooks.processAssets.tap({\n                name: 'NextJsBuildManifest',\n                stage: _webpack.webpack.Compilation.PROCESS_ASSETS_STAGE_ADDITIONS\n            }, ()=>{\n                this.createAssets(compiler, compilation);\n            });\n        });\n        return;\n    }\n}\n\n//# sourceMappingURL=build-manifest-plugin.js.map"
        }
    ]
}