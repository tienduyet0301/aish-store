{
    "sourceFile": "node_modules/next/dist/build/webpack/plugins/minify-webpack-plugin/src/index.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892671605,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"MinifyPlugin\", {\n    enumerable: true,\n    get: function() {\n        return MinifyPlugin;\n    }\n});\nconst _webpack = require(\"next/dist/compiled/webpack/webpack\");\nconst _plimit = /*#__PURE__*/ _interop_require_default(require(\"next/dist/compiled/p-limit\"));\nconst _utils = require(\"../../../utils\");\nfunction _interop_require_default(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nfunction buildError(error, file) {\n    if (error.line) {\n        return new _webpack.WebpackError(`${file} from Minifier\\n${error.message} [${file}:${error.line},${error.col}]${error.stack ? `\\n${error.stack.split('\\n').slice(1).join('\\n')}` : ''}`);\n    }\n    if (error.stack) {\n        return new _webpack.WebpackError(`${file} from Minifier\\n${error.message}\\n${error.stack}`);\n    }\n    return new _webpack.WebpackError(`${file} from Minifier\\n${error.message}`);\n}\nconst debugMinify = process.env.NEXT_DEBUG_MINIFY;\nclass MinifyPlugin {\n    constructor(options){\n        this.options = options;\n    }\n    async optimize(compiler, compilation, assets, cache, { SourceMapSource, RawSource }) {\n        const mangle = !this.options.noMangling;\n        const compilationSpan = (0, _utils.getCompilationSpan)(compilation) || (0, _utils.getCompilationSpan)(compiler);\n        const MinifierSpan = compilationSpan.traceChild('minify-webpack-plugin-optimize');\n        if (compilation.name) {\n            MinifierSpan.setAttribute('compilationName', compilation.name);\n        }\n        MinifierSpan.setAttribute('mangle', String(mangle));\n        return MinifierSpan.traceAsyncFn(async ()=>{\n            const assetsList = Object.keys(assets);\n            const assetsForMinify = await Promise.all(assetsList.filter((name)=>{\n                if (!_webpack.ModuleFilenameHelpers.matchObject.bind(// eslint-disable-next-line no-undefined\n                undefined, {\n                    test: /\\.[cm]?js(\\?.*)?$/i\n                })(name)) {\n                    return false;\n                }\n                const res = compilation.getAsset(name);\n                if (!res) {\n                    console.log(name);\n                    return false;\n                }\n                const { info } = res;\n                // Skip double minimize assets from child compilation\n                if (info.minimized) {\n                    return false;\n                }\n                return true;\n            }).map(async (name)=>{\n                const { info, source } = compilation.getAsset(name);\n                const eTag = cache.mergeEtags(cache.getLazyHashedEtag(source), JSON.stringify(this.options));\n                const output = await cache.getPromise(name, eTag);\n                if (debugMinify && debugMinify === '1') {\n                    console.log(JSON.stringify({\n                        name,\n                        source: source.source().toString()\n                    }), {\n                        breakLength: Infinity,\n                        maxStringLength: Infinity\n                    });\n                }\n                return {\n                    name,\n                    info,\n                    inputSource: source,\n                    output,\n                    eTag\n                };\n            }));\n            let initializedWorker;\n            // eslint-disable-next-line consistent-return\n            const getWorker = ()=>{\n                return {\n                    minify: async (options)=>{\n                        const result = await require('../../../../swc').minify(options.input, {\n                            ...options.inputSourceMap ? {\n                                sourceMap: {\n                                    content: JSON.stringify(options.inputSourceMap)\n                                }\n                            } : {},\n                            // Compress options are defined in crates/napi/src/minify.rs.\n                            compress: false,\n                            // Mangle options may be amended in crates/napi/src/minify.rs.\n                            mangle,\n                            module: 'unknown',\n                            output: {\n                                comments: false\n                            }\n                        });\n                        return result;\n                    }\n                };\n            };\n            // The limit in the SWC minifier will be handled by Node.js\n            const limit = (0, _plimit.default)(Infinity);\n            const scheduledTasks = [];\n            for (const asset of assetsForMinify){\n                scheduledTasks.push(limit(async ()=>{\n                    const { name, inputSource, eTag } = asset;\n                    let { output } = asset;\n                    const minifySpan = MinifierSpan.traceChild('minify-js');\n                    minifySpan.setAttribute('name', name);\n                    minifySpan.setAttribute('cache', typeof output === 'undefined' ? 'MISS' : 'HIT');\n                    return minifySpan.traceAsyncFn(async ()=>{\n                        if (!output) {\n                            const { source: sourceFromInputSource, map: inputSourceMap } = inputSource.sourceAndMap();\n                            const input = Buffer.isBuffer(sourceFromInputSource) ? sourceFromInputSource.toString() : sourceFromInputSource;\n                            let minifiedOutput;\n                            try {\n                                minifiedOutput = await getWorker().minify({\n                                    input,\n                                    inputSourceMap\n                                });\n                            } catch (error) {\n                                compilation.errors.push(buildError(error, name));\n                                return;\n                            }\n                            const source = minifiedOutput.map ? new SourceMapSource(minifiedOutput.code, name, minifiedOutput.map, input, inputSourceMap, true) : new RawSource(minifiedOutput.code);\n                            await cache.storePromise(name, eTag, {\n                                source\n                            });\n                            output = {\n                                source\n                            };\n                        }\n                        const newInfo = {\n                            minimized: true\n                        };\n                        compilation.updateAsset(name, output.source, newInfo);\n                    });\n                }));\n            }\n            await Promise.all(scheduledTasks);\n            if (initializedWorker) {\n                await initializedWorker.end();\n            }\n        });\n    }\n    apply(compiler) {\n        var _compiler_webpack;\n        const { SourceMapSource, RawSource } = (compiler == null ? void 0 : (_compiler_webpack = compiler.webpack) == null ? void 0 : _compiler_webpack.sources) || _webpack.sources;\n        const pluginName = this.constructor.name;\n        compiler.hooks.thisCompilation.tap(pluginName, (compilation)=>{\n            const cache = compilation.getCache('MinifierWebpackPlugin');\n            const handleHashForChunk = (hash, _chunk)=>{\n                // increment 'c' to invalidate cache\n                hash.update('c');\n            };\n            const JSModulesHooks = _webpack.webpack.javascript.JavascriptModulesPlugin.getCompilationHooks(compilation);\n            JSModulesHooks.chunkHash.tap(pluginName, (chunk, hash)=>{\n                if (!chunk.hasRuntime()) return;\n                return handleHashForChunk(hash, chunk);\n            });\n            compilation.hooks.processAssets.tapPromise({\n                name: pluginName,\n                stage: _webpack.webpack.Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE_SIZE\n            }, (assets)=>this.optimize(compiler, compilation, assets, cache, {\n                    SourceMapSource,\n                    RawSource\n                }));\n            compilation.hooks.statsPrinter.tap(pluginName, (stats)=>{\n                stats.hooks.print.for('asset.info.minimized').tap('minify-webpack-plugin', (minimized, { green, formatFlag })=>// eslint-disable-next-line no-undefined\n                    minimized ? green(formatFlag('minimized')) : undefined);\n            });\n        });\n    }\n}\n\n//# sourceMappingURL=index.js.map"
        }
    ]
}