{
    "sourceFile": "node_modules/next/dist/build/webpack/plugins/flight-client-entry-plugin.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892671109,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"FlightClientEntryPlugin\", {\n    enumerable: true,\n    get: function() {\n        return FlightClientEntryPlugin;\n    }\n});\nconst _webpack = require(\"next/dist/compiled/webpack/webpack\");\nconst _querystring = require(\"querystring\");\nconst _path = /*#__PURE__*/ _interop_require_default(require(\"path\"));\nconst _ondemandentryhandler = require(\"../../../server/dev/on-demand-entry-handler\");\nconst _constants = require(\"../../../lib/constants\");\nconst _constants1 = require(\"../../../shared/lib/constants\");\nconst _utils = require(\"../loaders/utils\");\nconst _utils1 = require(\"../utils\");\nconst _normalizepathsep = require(\"../../../shared/lib/page-path/normalize-path-sep\");\nconst _buildcontext = require(\"../../build-context\");\nconst _pagetypes = require(\"../../../lib/page-types\");\nconst _getmodulebuildinfo = require(\"../loaders/get-module-build-info\");\nconst _nextflightloader = require(\"../loaders/next-flight-loader\");\nconst _isapprouteroute = require(\"../../../lib/is-app-route-route\");\nconst _ismetadataroute = require(\"../../../lib/metadata/is-metadata-route\");\nconst _getwebpackbundler = /*#__PURE__*/ _interop_require_default(require(\"../../../shared/lib/get-webpack-bundler\"));\nfunction _interop_require_default(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nconst PLUGIN_NAME = 'FlightClientEntryPlugin';\nconst pluginState = (0, _buildcontext.getProxiedPluginState)({\n    // A map to track \"action\" -> \"list of bundles\".\n    serverActions: {},\n    edgeServerActions: {},\n    serverActionModules: {},\n    edgeServerActionModules: {},\n    ssrModules: {},\n    edgeSsrModules: {},\n    rscModules: {},\n    edgeRscModules: {},\n    injectedClientEntries: {}\n});\nfunction deduplicateCSSImportsForEntry(mergedCSSimports) {\n    // If multiple entry module connections are having the same CSS import,\n    // we only need to have one module to keep track of that CSS import.\n    // It is based on the fact that if a page or a layout is rendered in the\n    // given entry, all its parent layouts are always rendered too.\n    // This can avoid duplicate CSS imports in the generated CSS manifest,\n    // for example, if a page and its parent layout are both using the same\n    // CSS import, we only need to have the layout to keep track of that CSS\n    // import.\n    // To achieve this, we need to first collect all the CSS imports from\n    // every connection, and deduplicate them in the order of layers from\n    // top to bottom. The implementation can be generally described as:\n    // - Sort by number of `/` in the request path (the more `/`, the deeper)\n    // - When in the same depth, sort by the filename (template < layout < page and others)\n    // Sort the connections as described above.\n    const sortedCSSImports = Object.entries(mergedCSSimports).sort((a, b)=>{\n        const [aPath] = a;\n        const [bPath] = b;\n        const aDepth = aPath.split('/').length;\n        const bDepth = bPath.split('/').length;\n        if (aDepth !== bDepth) {\n            return aDepth - bDepth;\n        }\n        const aName = _path.default.parse(aPath).name;\n        const bName = _path.default.parse(bPath).name;\n        const indexA = [\n            'template',\n            'layout'\n        ].indexOf(aName);\n        const indexB = [\n            'template',\n            'layout'\n        ].indexOf(bName);\n        if (indexA === -1) return 1;\n        if (indexB === -1) return -1;\n        return indexA - indexB;\n    });\n    const dedupedCSSImports = {};\n    const trackedCSSImports = new Set();\n    for (const [entryName, cssImports] of sortedCSSImports){\n        for (const cssImport of cssImports){\n            if (trackedCSSImports.has(cssImport)) continue;\n            // Only track CSS imports that are in files that can inherit CSS.\n            const filename = _path.default.parse(entryName).name;\n            if ([\n                'template',\n                'layout'\n            ].includes(filename)) {\n                trackedCSSImports.add(cssImport);\n            }\n            if (!dedupedCSSImports[entryName]) {\n                dedupedCSSImports[entryName] = [];\n            }\n            dedupedCSSImports[entryName].push(cssImport);\n        }\n    }\n    return dedupedCSSImports;\n}\nclass FlightClientEntryPlugin {\n    constructor(options){\n        this.dev = options.dev;\n        this.appDir = options.appDir;\n        this.isEdgeServer = options.isEdgeServer;\n        this.assetPrefix = !this.dev && !this.isEdgeServer ? '../' : '';\n        this.encryptionKey = options.encryptionKey;\n        this.webpackRuntime = this.isEdgeServer ? _constants1.EDGE_RUNTIME_WEBPACK : _constants1.DEFAULT_RUNTIME_WEBPACK;\n    }\n    apply(compiler) {\n        compiler.hooks.finishMake.tapPromise(PLUGIN_NAME, (compilation)=>this.createClientEntries(compiler, compilation));\n        compiler.hooks.afterCompile.tap(PLUGIN_NAME, (compilation)=>{\n            const recordModule = (modId, mod)=>{\n                var _mod_resourceResolveData, _mod_resourceResolveData1;\n                // Match Resource is undefined unless an import is using the inline match resource syntax\n                // https://webpack.js.org/api/loaders/#inline-matchresource\n                const modPath = mod.matchResource || ((_mod_resourceResolveData = mod.resourceResolveData) == null ? void 0 : _mod_resourceResolveData.path);\n                const modQuery = ((_mod_resourceResolveData1 = mod.resourceResolveData) == null ? void 0 : _mod_resourceResolveData1.query) || '';\n                // query is already part of mod.resource\n                // so it's only necessary to add it for matchResource or mod.resourceResolveData\n                const modResource = modPath ? modPath.startsWith(_constants1.BARREL_OPTIMIZATION_PREFIX) ? (0, _utils1.formatBarrelOptimizedResource)(mod.resource, modPath) : modPath + modQuery : mod.resource;\n                if (typeof modId !== 'undefined' && modResource) {\n                    if (mod.layer === _constants.WEBPACK_LAYERS.reactServerComponents) {\n                        const key = _path.default.relative(compiler.context, modResource).replace(/\\/next\\/dist\\/esm\\//, '/next/dist/');\n                        const moduleInfo = {\n                            moduleId: modId,\n                            async: compilation.moduleGraph.isAsync(mod)\n                        };\n                        if (this.isEdgeServer) {\n                            pluginState.edgeRscModules[key] = moduleInfo;\n                        } else {\n                            pluginState.rscModules[key] = moduleInfo;\n                        }\n                    }\n                }\n                if (mod.layer !== _constants.WEBPACK_LAYERS.serverSideRendering) {\n                    return;\n                }\n                // Check mod resource to exclude the empty resource module like virtual module created by next-flight-client-entry-loader\n                if (typeof modId !== 'undefined' && modResource) {\n                    // Note that this isn't that reliable as webpack is still possible to assign\n                    // additional queries to make sure there's no conflict even using the `named`\n                    // module ID strategy.\n                    let ssrNamedModuleId = _path.default.relative(compiler.context, modResource);\n                    if (!ssrNamedModuleId.startsWith('.')) {\n                        // TODO use getModuleId instead\n                        ssrNamedModuleId = `./${(0, _normalizepathsep.normalizePathSep)(ssrNamedModuleId)}`;\n                    }\n                    const moduleInfo = {\n                        moduleId: modId,\n                        async: compilation.moduleGraph.isAsync(mod)\n                    };\n                    if (this.isEdgeServer) {\n                        pluginState.edgeSsrModules[ssrNamedModuleId.replace(/\\/next\\/dist\\/esm\\//, '/next/dist/')] = moduleInfo;\n                    } else {\n                        pluginState.ssrModules[ssrNamedModuleId] = moduleInfo;\n                    }\n                }\n            };\n            (0, _utils1.traverseModules)(compilation, (mod, _chunk, _chunkGroup, modId)=>{\n                if (modId) recordModule(modId, mod);\n            });\n        });\n        compiler.hooks.make.tap(PLUGIN_NAME, (compilation)=>{\n            compilation.hooks.processAssets.tapPromise({\n                name: PLUGIN_NAME,\n                stage: _webpack.webpack.Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE_HASH\n            }, ()=>this.createActionAssets(compilation));\n        });\n    }\n    async createClientEntries(compiler, compilation) {\n        const addClientEntryAndSSRModulesList = [];\n        const createdSSRDependenciesForEntry = {};\n        const addActionEntryList = [];\n        const actionMapsPerEntry = {};\n        const createdActionIds = new Set();\n        // For each SC server compilation entry, we need to create its corresponding\n        // client component entry.\n        (0, _utils1.forEachEntryModule)(compilation, ({ name, entryModule })=>{\n            const internalClientComponentEntryImports = {};\n            const actionEntryImports = new Map();\n            const clientEntriesToInject = [];\n            const mergedCSSimports = {};\n            for (const connection of (0, _utils1.getModuleReferencesInOrder)(entryModule, compilation.moduleGraph)){\n                // Entry can be any user defined entry files such as layout, page, error, loading, etc.\n                let entryRequest = connection.dependency.request;\n                if (entryRequest.endsWith(_constants.WEBPACK_RESOURCE_QUERIES.metadataRoute)) {\n                    const { filePath, isDynamicRouteExtension } = getMetadataRouteResource(entryRequest);\n                    if (isDynamicRouteExtension === '1') {\n                        entryRequest = filePath;\n                    }\n                }\n                const { clientComponentImports, actionImports, cssImports } = this.collectComponentInfoFromServerEntryDependency({\n                    entryRequest,\n                    compilation,\n                    resolvedModule: connection.resolvedModule\n                });\n                actionImports.forEach(([dep, actions])=>actionEntryImports.set(dep, actions));\n                const isAbsoluteRequest = _path.default.isAbsolute(entryRequest);\n                // Next.js internals are put into a separate entry.\n                if (!isAbsoluteRequest) {\n                    Object.keys(clientComponentImports).forEach((value)=>internalClientComponentEntryImports[value] = new Set());\n                    continue;\n                }\n                // TODO-APP: Enable these lines. This ensures no entrypoint is created for layout/page when there are no client components.\n                // Currently disabled because it causes test failures in CI.\n                // if (clientImports.length === 0 && actionImports.length === 0) {\n                //   continue\n                // }\n                const relativeRequest = isAbsoluteRequest ? _path.default.relative(compilation.options.context, entryRequest) : entryRequest;\n                // Replace file suffix as `.js` will be added.\n                // bundlePath will have app/ prefix but not src/.\n                // e.g. src/app/foo/page.js -> app/foo/page\n                let bundlePath = (0, _normalizepathsep.normalizePathSep)(relativeRequest.replace(/\\.[^.\\\\/]+$/, '').replace(/^src[\\\\/]/, ''));\n                // For metadata routes, the entry name can be used as the bundle path,\n                // as it has been normalized already.\n                // e.g.\n                // When `relativeRequest` is 'src/app/sitemap.js',\n                // `appDirRelativeRequest` will be '/sitemap.js'\n                // then `isMetadataEntryFile` will be `true`\n                const appDirRelativeRequest = relativeRequest.replace(/^src[\\\\/]/, '').replace(/^app[\\\\/]/, '/');\n                const isMetadataEntryFile = (0, _ismetadataroute.isMetadataRouteFile)(appDirRelativeRequest, _ismetadataroute.DEFAULT_METADATA_ROUTE_EXTENSIONS, true);\n                if (isMetadataEntryFile) {\n                    bundlePath = name;\n                }\n                Object.assign(mergedCSSimports, cssImports);\n                clientEntriesToInject.push({\n                    compiler,\n                    compilation,\n                    entryName: name,\n                    clientComponentImports,\n                    bundlePath,\n                    absolutePagePath: entryRequest\n                });\n                // The webpack implementation of writing the client reference manifest relies on all entrypoints writing a page.js even when there is no client components in the page.\n                // It needs the file in order to write the reference manifest for the path in the `.next/server` folder.\n                // TODO-APP: This could be better handled, however Turbopack does not have the same problem as we resolve client components in a single graph.\n                if (name === `app${_constants1.UNDERSCORE_NOT_FOUND_ROUTE_ENTRY}` && bundlePath === 'app/not-found') {\n                    clientEntriesToInject.push({\n                        compiler,\n                        compilation,\n                        entryName: name,\n                        clientComponentImports: {},\n                        bundlePath: `app${_constants1.UNDERSCORE_NOT_FOUND_ROUTE_ENTRY}`,\n                        absolutePagePath: entryRequest\n                    });\n                }\n            }\n            // Make sure CSS imports are deduplicated before injecting the client entry\n            // and SSR modules.\n            const dedupedCSSImports = deduplicateCSSImportsForEntry(mergedCSSimports);\n            for (const clientEntryToInject of clientEntriesToInject){\n                const injected = this.injectClientEntryAndSSRModules({\n                    ...clientEntryToInject,\n                    clientImports: {\n                        ...clientEntryToInject.clientComponentImports,\n                        ...(dedupedCSSImports[clientEntryToInject.absolutePagePath] || []).reduce((res, curr)=>{\n                            res[curr] = new Set();\n                            return res;\n                        }, {})\n                    }\n                });\n                // Track all created SSR dependencies for each entry from the server layer.\n                if (!createdSSRDependenciesForEntry[clientEntryToInject.entryName]) {\n                    createdSSRDependenciesForEntry[clientEntryToInject.entryName] = [];\n                }\n                createdSSRDependenciesForEntry[clientEntryToInject.entryName].push(injected[3]);\n                addClientEntryAndSSRModulesList.push(injected);\n            }\n            if (!(0, _isapprouteroute.isAppRouteRoute)(name)) {\n                // Create internal app\n                addClientEntryAndSSRModulesList.push(this.injectClientEntryAndSSRModules({\n                    compiler,\n                    compilation,\n                    entryName: name,\n                    clientImports: {\n                        ...internalClientComponentEntryImports\n                    },\n                    bundlePath: _constants1.APP_CLIENT_INTERNALS\n                }));\n            }\n            if (actionEntryImports.size > 0) {\n                if (!actionMapsPerEntry[name]) {\n                    actionMapsPerEntry[name] = new Map();\n                }\n                actionMapsPerEntry[name] = new Map([\n                    ...actionMapsPerEntry[name],\n                    ...actionEntryImports\n                ]);\n            }\n        });\n        for (const [name, actionEntryImports] of Object.entries(actionMapsPerEntry)){\n            addActionEntryList.push(this.injectActionEntry({\n                compiler,\n                compilation,\n                actions: actionEntryImports,\n                entryName: name,\n                bundlePath: name,\n                createdActionIds\n            }));\n        }\n        // Invalidate in development to trigger recompilation\n        const invalidator = (0, _ondemandentryhandler.getInvalidator)(compiler.outputPath);\n        // Check if any of the entry injections need an invalidation\n        if (invalidator && addClientEntryAndSSRModulesList.some(([shouldInvalidate])=>shouldInvalidate === true)) {\n            invalidator.invalidate([\n                _constants1.COMPILER_NAMES.client\n            ]);\n        }\n        // Client compiler is invalidated before awaiting the compilation of the SSR\n        // and RSC client component entries so that the client compiler is running\n        // in parallel to the server compiler.\n        await Promise.all(addClientEntryAndSSRModulesList.flatMap((addClientEntryAndSSRModules)=>[\n                addClientEntryAndSSRModules[1],\n                addClientEntryAndSSRModules[2]\n            ]));\n        // Wait for action entries to be added.\n        await Promise.all(addActionEntryList);\n        const addedClientActionEntryList = [];\n        const actionMapsPerClientEntry = {};\n        // We need to create extra action entries that are created from the\n        // client layer.\n        // Start from each entry's created SSR dependency from our previous step.\n        for (const [name, ssrEntryDependencies] of Object.entries(createdSSRDependenciesForEntry)){\n            // Collect from all entries, e.g. layout.js, page.js, loading.js, ...\n            // add aggregate them.\n            const actionEntryImports = this.collectClientActionsFromDependencies({\n                compilation,\n                dependencies: ssrEntryDependencies\n            });\n            if (actionEntryImports.size > 0) {\n                if (!actionMapsPerClientEntry[name]) {\n                    actionMapsPerClientEntry[name] = new Map();\n                }\n                actionMapsPerClientEntry[name] = new Map([\n                    ...actionMapsPerClientEntry[name],\n                    ...actionEntryImports\n                ]);\n            }\n        }\n        for (const [entryName, actionEntryImports] of Object.entries(actionMapsPerClientEntry)){\n            // If an action method is already created in the server layer, we don't\n            // need to create it again in the action layer.\n            // This is to avoid duplicate action instances and make sure the module\n            // state is shared.\n            let remainingClientImportedActions = false;\n            const remainingActionEntryImports = new Map();\n            for (const [dep, actions] of actionEntryImports){\n                const remainingActionNames = [];\n                for (const action of actions){\n                    if (!createdActionIds.has(entryName + '@' + action.id)) {\n                        remainingActionNames.push(action);\n                    }\n                }\n                if (remainingActionNames.length > 0) {\n                    remainingActionEntryImports.set(dep, remainingActionNames);\n                    remainingClientImportedActions = true;\n                }\n            }\n            if (remainingClientImportedActions) {\n                addedClientActionEntryList.push(this.injectActionEntry({\n                    compiler,\n                    compilation,\n                    actions: remainingActionEntryImports,\n                    entryName,\n                    bundlePath: entryName,\n                    fromClient: true,\n                    createdActionIds\n                }));\n            }\n        }\n        await Promise.all(addedClientActionEntryList);\n    }\n    collectClientActionsFromDependencies({ compilation, dependencies }) {\n        // action file path -> action names\n        const collectedActions = new Map();\n        // Keep track of checked modules to avoid infinite loops with recursive imports.\n        const visitedModule = new Set();\n        const visitedEntry = new Set();\n        const collectActions = ({ entryRequest, resolvedModule })=>{\n            const collectActionsInDep = (mod)=>{\n                var _getModuleBuildInfo_rsc;\n                if (!mod) return;\n                const modResource = getModuleResource(mod);\n                if (!modResource) return;\n                if (visitedModule.has(modResource)) return;\n                visitedModule.add(modResource);\n                const actionIds = (_getModuleBuildInfo_rsc = (0, _getmodulebuildinfo.getModuleBuildInfo)(mod).rsc) == null ? void 0 : _getModuleBuildInfo_rsc.actionIds;\n                if (actionIds) {\n                    collectedActions.set(modResource, Object.entries(actionIds).map(([id, exportedName])=>({\n                            id,\n                            exportedName\n                        })));\n                }\n                // Collect used exported actions transversely.\n                (0, _utils1.getModuleReferencesInOrder)(mod, compilation.moduleGraph).forEach((connection)=>{\n                    collectActionsInDep(connection.resolvedModule);\n                });\n            };\n            // Don't traverse the module graph anymore once hitting the action layer.\n            if (entryRequest && !entryRequest.includes('next-flight-action-entry-loader')) {\n                // Traverse the module graph to find all client components.\n                collectActionsInDep(resolvedModule);\n            }\n        };\n        for (const entryDependency of dependencies){\n            const ssrEntryModule = compilation.moduleGraph.getResolvedModule(entryDependency);\n            for (const connection of (0, _utils1.getModuleReferencesInOrder)(ssrEntryModule, compilation.moduleGraph)){\n                const depModule = connection.dependency;\n                const request = depModule.request;\n                // It is possible that the same entry is added multiple times in the\n                // connection graph. We can just skip these to speed up the process.\n                if (visitedEntry.has(request)) continue;\n                visitedEntry.add(request);\n                collectActions({\n                    entryRequest: request,\n                    resolvedModule: connection.resolvedModule\n                });\n            }\n        }\n        return collectedActions;\n    }\n    collectComponentInfoFromServerEntryDependency({ entryRequest, compilation, resolvedModule }) {\n        // Keep track of checked modules to avoid infinite loops with recursive imports.\n        const visitedOfClientComponentsTraverse = new Set();\n        // Info to collect.\n        const clientComponentImports = {};\n        const actionImports = [];\n        const CSSImports = new Set();\n        const filterClientComponents = (mod, importedIdentifiers)=>{\n            var _getModuleBuildInfo_rsc;\n            if (!mod) return;\n            const modResource = getModuleResource(mod);\n            if (!modResource) return;\n            if (visitedOfClientComponentsTraverse.has(modResource)) {\n                if (clientComponentImports[modResource]) {\n                    addClientImport(mod, modResource, clientComponentImports, importedIdentifiers, false);\n                }\n                return;\n            }\n            visitedOfClientComponentsTraverse.add(modResource);\n            const actionIds = (_getModuleBuildInfo_rsc = (0, _getmodulebuildinfo.getModuleBuildInfo)(mod).rsc) == null ? void 0 : _getModuleBuildInfo_rsc.actionIds;\n            if (actionIds) {\n                actionImports.push([\n                    modResource,\n                    Object.entries(actionIds).map(([id, exportedName])=>({\n                            id,\n                            exportedName\n                        }))\n                ]);\n            }\n            if ((0, _utils.isCSSMod)(mod)) {\n                const sideEffectFree = mod.factoryMeta && mod.factoryMeta.sideEffectFree;\n                if (sideEffectFree) {\n                    const unused = !compilation.moduleGraph.getExportsInfo(mod).isModuleUsed(this.webpackRuntime);\n                    if (unused) return;\n                }\n                CSSImports.add(modResource);\n            } else if ((0, _utils.isClientComponentEntryModule)(mod)) {\n                if (!clientComponentImports[modResource]) {\n                    clientComponentImports[modResource] = new Set();\n                }\n                addClientImport(mod, modResource, clientComponentImports, importedIdentifiers, true);\n                return;\n            }\n            (0, _utils1.getModuleReferencesInOrder)(mod, compilation.moduleGraph).forEach((connection)=>{\n                var _connection_dependency;\n                let dependencyIds = [];\n                // `ids` are the identifiers that are imported from the dependency,\n                // if it's present, it's an array of strings.\n                if ((_connection_dependency = connection.dependency) == null ? void 0 : _connection_dependency.ids) {\n                    dependencyIds.push(...connection.dependency.ids);\n                } else {\n                    dependencyIds = [\n                        '*'\n                    ];\n                }\n                filterClientComponents(connection.resolvedModule, dependencyIds);\n            });\n        };\n        // Traverse the module graph to find all client components.\n        filterClientComponents(resolvedModule, []);\n        return {\n            clientComponentImports,\n            cssImports: CSSImports.size ? {\n                [entryRequest]: Array.from(CSSImports)\n            } : {},\n            actionImports\n        };\n    }\n    injectClientEntryAndSSRModules({ compiler, compilation, entryName, clientImports, bundlePath, absolutePagePath }) {\n        const bundler = (0, _getwebpackbundler.default)();\n        let shouldInvalidate = false;\n        const modules = Object.keys(clientImports).sort((a, b)=>_utils.regexCSS.test(b) ? 1 : a.localeCompare(b)).map((clientImportPath)=>({\n                request: clientImportPath,\n                ids: [\n                    ...clientImports[clientImportPath]\n                ]\n            }));\n        // For the client entry, we always use the CJS build of Next.js. If the\n        // server is using the ESM build (when using the Edge runtime), we need to\n        // replace them.\n        const clientBrowserLoader = `next-flight-client-entry-loader?${(0, _querystring.stringify)({\n            modules: (this.isEdgeServer ? modules.map(({ request, ids })=>({\n                    request: request.replace(/[\\\\/]next[\\\\/]dist[\\\\/]esm[\\\\/]/, '/next/dist/'.replace(/\\//g, _path.default.sep)),\n                    ids\n                })) : modules).map((x)=>JSON.stringify(x)),\n            server: false\n        })}!`;\n        const clientServerLoader = `next-flight-client-entry-loader?${(0, _querystring.stringify)({\n            modules: modules.map((x)=>JSON.stringify(x)),\n            server: true\n        })}!`;\n        // Add for the client compilation\n        // Inject the entry to the client compiler.\n        if (this.dev) {\n            const entries = (0, _ondemandentryhandler.getEntries)(compiler.outputPath);\n            const pageKey = (0, _ondemandentryhandler.getEntryKey)(_constants1.COMPILER_NAMES.client, _pagetypes.PAGE_TYPES.APP, bundlePath);\n            if (!entries[pageKey]) {\n                entries[pageKey] = {\n                    type: _ondemandentryhandler.EntryTypes.CHILD_ENTRY,\n                    parentEntries: new Set([\n                        entryName\n                    ]),\n                    absoluteEntryFilePath: absolutePagePath,\n                    bundlePath,\n                    request: clientBrowserLoader,\n                    dispose: false,\n                    lastActiveTime: Date.now()\n                };\n                shouldInvalidate = true;\n            } else {\n                const entryData = entries[pageKey];\n                // New version of the client loader\n                if (entryData.request !== clientBrowserLoader) {\n                    entryData.request = clientBrowserLoader;\n                    shouldInvalidate = true;\n                }\n                if (entryData.type === _ondemandentryhandler.EntryTypes.CHILD_ENTRY) {\n                    entryData.parentEntries.add(entryName);\n                }\n                entryData.dispose = false;\n                entryData.lastActiveTime = Date.now();\n            }\n        } else {\n            pluginState.injectedClientEntries[bundlePath] = clientBrowserLoader;\n        }\n        const clientComponentSSREntryDep = bundler.EntryPlugin.createDependency(clientServerLoader, {\n            name: bundlePath\n        });\n        const clientComponentRSCEntryDep = bundler.EntryPlugin.createDependency(clientServerLoader, {\n            name: bundlePath\n        });\n        return [\n            shouldInvalidate,\n            // Add the entries to the server compiler for the SSR and RSC layers. The\n            // promises are awaited later using `Promise.all` in order to parallelize\n            // adding the entries.\n            this.addEntry(compilation, compiler.context, clientComponentSSREntryDep, {\n                name: entryName,\n                layer: _constants.WEBPACK_LAYERS.serverSideRendering\n            }),\n            this.addEntry(compilation, compiler.context, clientComponentRSCEntryDep, {\n                name: entryName,\n                layer: _constants.WEBPACK_LAYERS.reactServerComponents\n            }),\n            clientComponentSSREntryDep\n        ];\n    }\n    injectActionEntry({ compiler, compilation, actions, entryName, bundlePath, fromClient, createdActionIds }) {\n        const bundler = (0, _getwebpackbundler.default)();\n        const actionsArray = Array.from(actions.entries());\n        for (const [, actionsFromModule] of actions){\n            for (const { id } of actionsFromModule){\n                createdActionIds.add(entryName + '@' + id);\n            }\n        }\n        if (actionsArray.length === 0) {\n            return Promise.resolve();\n        }\n        const actionLoader = `next-flight-action-entry-loader?${(0, _querystring.stringify)({\n            actions: JSON.stringify(actionsArray),\n            __client_imported__: fromClient\n        })}!`;\n        const currentCompilerServerActions = this.isEdgeServer ? pluginState.edgeServerActions : pluginState.serverActions;\n        for (const [, actionsFromModule] of actionsArray){\n            for (const { id } of actionsFromModule){\n                if (typeof currentCompilerServerActions[id] === 'undefined') {\n                    currentCompilerServerActions[id] = {\n                        workers: {},\n                        layer: {}\n                    };\n                }\n                currentCompilerServerActions[id].workers[bundlePath] = {\n                    moduleId: '',\n                    async: false\n                };\n                currentCompilerServerActions[id].layer[bundlePath] = fromClient ? _constants.WEBPACK_LAYERS.actionBrowser : _constants.WEBPACK_LAYERS.reactServerComponents;\n            }\n        }\n        // Inject the entry to the server compiler\n        const actionEntryDep = bundler.EntryPlugin.createDependency(actionLoader, {\n            name: bundlePath\n        });\n        return this.addEntry(compilation, // Reuse compilation context.\n        compiler.context, actionEntryDep, {\n            name: entryName,\n            layer: fromClient ? _constants.WEBPACK_LAYERS.actionBrowser : _constants.WEBPACK_LAYERS.reactServerComponents\n        });\n    }\n    addEntry(compilation, context, dependency, options) /* Promise<module> */ {\n        return new Promise((resolve, reject)=>{\n            if ('rspack' in compilation.compiler) {\n                compilation.addInclude(context, dependency, options, (err, module)=>{\n                    if (err) {\n                        return reject(err);\n                    }\n                    compilation.moduleGraph.getExportsInfo(module).setUsedInUnknownWay(this.isEdgeServer ? _constants1.EDGE_RUNTIME_WEBPACK : _constants1.DEFAULT_RUNTIME_WEBPACK);\n                    return resolve(module);\n                });\n            } else {\n                const entry = compilation.entries.get(options.name);\n                entry.includeDependencies.push(dependency);\n                compilation.hooks.addEntry.call(entry, options);\n                compilation.addModuleTree({\n                    context,\n                    dependency,\n                    contextInfo: {\n                        issuerLayer: options.layer\n                    }\n                }, (err, module)=>{\n                    if (err) {\n                        compilation.hooks.failedEntry.call(dependency, options, err);\n                        return reject(err);\n                    }\n                    compilation.hooks.succeedEntry.call(dependency, options, module);\n                    compilation.moduleGraph.getExportsInfo(module).setUsedInUnknownWay(this.isEdgeServer ? _constants1.EDGE_RUNTIME_WEBPACK : _constants1.DEFAULT_RUNTIME_WEBPACK);\n                    return resolve(module);\n                });\n            }\n        });\n    }\n    async createActionAssets(compilation) {\n        const serverActions = {};\n        const edgeServerActions = {};\n        (0, _utils1.traverseModules)(compilation, (mod, _chunk, chunkGroup, modId)=>{\n            // Go through all action entries and record the module ID for each entry.\n            if (chunkGroup.name && mod.request && modId && /next-flight-action-entry-loader/.test(mod.request)) {\n                const fromClient = /&__client_imported__=true/.test(mod.request);\n                const mapping = this.isEdgeServer ? pluginState.edgeServerActionModules : pluginState.serverActionModules;\n                if (!mapping[chunkGroup.name]) {\n                    mapping[chunkGroup.name] = {};\n                }\n                mapping[chunkGroup.name][fromClient ? 'client' : 'server'] = {\n                    moduleId: modId,\n                    async: compilation.moduleGraph.isAsync(mod)\n                };\n            }\n        });\n        for(let id in pluginState.serverActions){\n            const action = pluginState.serverActions[id];\n            for(let name in action.workers){\n                const modId = pluginState.serverActionModules[name][action.layer[name] === _constants.WEBPACK_LAYERS.actionBrowser ? 'client' : 'server'];\n                action.workers[name] = modId;\n            }\n            serverActions[id] = action;\n        }\n        for(let id in pluginState.edgeServerActions){\n            const action = pluginState.edgeServerActions[id];\n            for(let name in action.workers){\n                const modId = pluginState.edgeServerActionModules[name][action.layer[name] === _constants.WEBPACK_LAYERS.actionBrowser ? 'client' : 'server'];\n                action.workers[name] = modId;\n            }\n            edgeServerActions[id] = action;\n        }\n        const serverManifest = {\n            node: serverActions,\n            edge: edgeServerActions,\n            encryptionKey: this.encryptionKey\n        };\n        const edgeServerManifest = {\n            ...serverManifest,\n            encryptionKey: 'process.env.NEXT_SERVER_ACTIONS_ENCRYPTION_KEY'\n        };\n        const json = JSON.stringify(serverManifest, null, this.dev ? 2 : undefined);\n        const edgeJson = JSON.stringify(edgeServerManifest, null, this.dev ? 2 : undefined);\n        compilation.emitAsset(`${this.assetPrefix}${_constants1.SERVER_REFERENCE_MANIFEST}.js`, new _webpack.sources.RawSource(`self.__RSC_SERVER_MANIFEST=${JSON.stringify(edgeJson)}`));\n        compilation.emitAsset(`${this.assetPrefix}${_constants1.SERVER_REFERENCE_MANIFEST}.json`, new _webpack.sources.RawSource(json));\n    }\n}\nfunction addClientImport(mod, modRequest, clientComponentImports, importedIdentifiers, isFirstVisitModule) {\n    var _getModuleBuildInfo_rsc;\n    const clientEntryType = (_getModuleBuildInfo_rsc = (0, _getmodulebuildinfo.getModuleBuildInfo)(mod).rsc) == null ? void 0 : _getModuleBuildInfo_rsc.clientEntryType;\n    const isCjsModule = clientEntryType === 'cjs';\n    const assumedSourceType = (0, _nextflightloader.getAssumedSourceType)(mod, isCjsModule ? 'commonjs' : 'auto');\n    const clientImportsSet = clientComponentImports[modRequest];\n    if (importedIdentifiers[0] === '*') {\n        // If there's collected import path with named import identifiers,\n        // or there's nothing in collected imports are empty.\n        // we should include the whole module.\n        if (!isFirstVisitModule && [\n            ...clientImportsSet\n        ][0] !== '*') {\n            clientComponentImports[modRequest] = new Set([\n                '*'\n            ]);\n        }\n    } else {\n        const isAutoModuleSourceType = assumedSourceType === 'auto';\n        if (isAutoModuleSourceType) {\n            clientComponentImports[modRequest] = new Set([\n                '*'\n            ]);\n        } else {\n            // If it's not analyzed as named ESM exports, e.g. if it's mixing `export *` with named exports,\n            // We'll include all modules since it's not able to do tree-shaking.\n            for (const name of importedIdentifiers){\n                // For cjs module default import, we include the whole module since\n                const isCjsDefaultImport = isCjsModule && name === 'default';\n                // Always include __esModule along with cjs module default export,\n                // to make sure it work with client module proxy from React.\n                if (isCjsDefaultImport) {\n                    clientComponentImports[modRequest].add('__esModule');\n                }\n                clientComponentImports[modRequest].add(name);\n            }\n        }\n    }\n}\nfunction getModuleResource(mod) {\n    var _mod_resourceResolveData, _mod_resourceResolveData1, _mod_matchResource;\n    const modPath = ((_mod_resourceResolveData = mod.resourceResolveData) == null ? void 0 : _mod_resourceResolveData.path) || '';\n    const modQuery = ((_mod_resourceResolveData1 = mod.resourceResolveData) == null ? void 0 : _mod_resourceResolveData1.query) || '';\n    // We have to always use the resolved request here to make sure the\n    // server and client are using the same module path (required by RSC), as\n    // the server compiler and client compiler have different resolve configs.\n    let modResource = modPath + modQuery;\n    // Context modules don't have a resource path, we use the identifier instead.\n    if (mod.constructor.name === 'ContextModule') {\n        modResource = mod.identifier();\n    }\n    // For the barrel optimization, we need to use the match resource instead\n    // because there will be 2 modules for the same file (same resource path)\n    // but they're different modules and can't be deduped via `visitedModule`.\n    // The first module is a virtual re-export module created by the loader.\n    if ((_mod_matchResource = mod.matchResource) == null ? void 0 : _mod_matchResource.startsWith(_constants1.BARREL_OPTIMIZATION_PREFIX)) {\n        modResource = mod.matchResource + ':' + modResource;\n    }\n    if (mod.resource === `?${_constants.WEBPACK_RESOURCE_QUERIES.metadataRoute}`) {\n        return getMetadataRouteResource(mod.rawRequest).filePath;\n    }\n    return modResource;\n}\nfunction getMetadataRouteResource(request) {\n    // e.g. next-metadata-route-loader?filePath=<some-url-encoded-path>&isDynamicRouteExtension=1!?__next_metadata_route__\n    const query = request.split('!')[0].split('next-metadata-route-loader?')[1];\n    return (0, _querystring.parse)(query);\n}\n\n//# sourceMappingURL=flight-client-entry-plugin.js.map"
        }
    ]
}