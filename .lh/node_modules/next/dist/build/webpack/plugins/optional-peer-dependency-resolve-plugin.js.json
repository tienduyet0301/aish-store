{
    "sourceFile": "node_modules/next/dist/build/webpack/plugins/optional-peer-dependency-resolve-plugin.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892672169,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"OptionalPeerDependencyResolverPlugin\", {\n    enumerable: true,\n    get: function() {\n        return OptionalPeerDependencyResolverPlugin;\n    }\n});\nconst pluginSymbol = Symbol('OptionalPeerDependencyResolverPlugin');\nclass OptionalPeerDependencyResolverPlugin {\n    apply(resolver) {\n        const target = resolver.ensureHook('raw-module');\n        target.tapAsync('OptionalPeerDependencyResolverPlugin', (request, resolveContext, callback)=>{\n            var // popping the stack to prevent the recursion check\n            _resolveContext_stack;\n            // if we've already recursed into this plugin, we want to skip it\n            if (request[pluginSymbol]) {\n                return callback();\n            }\n            (_resolveContext_stack = resolveContext.stack) == null ? void 0 : _resolveContext_stack.delete(Array.from(resolveContext.stack).pop());\n            resolver.doResolve(target, // when we call doResolve again, we need to make sure we don't\n            // recurse into this plugin again\n            {\n                ...request,\n                [pluginSymbol]: true\n            }, null, resolveContext, (err, result)=>{\n                var _request_descriptionFileData;\n                if (!result && (request == null ? void 0 : (_request_descriptionFileData = request.descriptionFileData) == null ? void 0 : _request_descriptionFileData.peerDependenciesMeta) && request.request) {\n                    const peerDependenciesMeta = request.descriptionFileData.peerDependenciesMeta;\n                    const isOptional = peerDependenciesMeta && peerDependenciesMeta[request.request] && peerDependenciesMeta[request.request].optional;\n                    if (isOptional) {\n                        return callback(null, {\n                            path: false\n                        });\n                    }\n                }\n                return callback(err, result);\n            });\n        });\n    }\n}\n\n//# sourceMappingURL=optional-peer-dependency-resolve-plugin.js.map"
        }
    ]
}