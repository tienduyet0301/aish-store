{
    "sourceFile": "node_modules/next/dist/build/webpack/plugins/next-trace-entrypoints-plugin.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892671835,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    TRACE_IGNORES: null,\n    TraceEntryPointsPlugin: null,\n    getFilesMapFromReasons: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    TRACE_IGNORES: function() {\n        return TRACE_IGNORES;\n    },\n    TraceEntryPointsPlugin: function() {\n        return TraceEntryPointsPlugin;\n    },\n    getFilesMapFromReasons: function() {\n        return getFilesMapFromReasons;\n    }\n});\nconst _path = /*#__PURE__*/ _interop_require_default(require(\"path\"));\nconst _iserror = /*#__PURE__*/ _interop_require_default(require(\"../../../lib/is-error\"));\nconst _nft = require(\"next/dist/compiled/@vercel/nft\");\nconst _constants = require(\"../../../shared/lib/constants\");\nconst _webpack = require(\"next/dist/compiled/webpack/webpack\");\nconst _webpackconfig = require(\"../../webpack-config\");\nconst _picomatch = /*#__PURE__*/ _interop_require_default(require(\"next/dist/compiled/picomatch\"));\nconst _getmodulebuildinfo = require(\"../loaders/get-module-build-info\");\nconst _entries = require(\"../../entries\");\nconst _handleexternals = require(\"../../handle-externals\");\nconst _ismetadataroute = require(\"../../../lib/metadata/is-metadata-route\");\nconst _utils = require(\"../utils\");\nfunction _interop_require_default(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nconst PLUGIN_NAME = 'TraceEntryPointsPlugin';\nconst TRACE_IGNORES = [\n    '**/*/next/dist/server/next.js',\n    '**/*/next/dist/bin/next'\n];\nconst NOT_TRACEABLE = [\n    '.wasm',\n    '.png',\n    '.jpg',\n    '.jpeg',\n    '.gif',\n    '.webp',\n    '.avif',\n    '.ico',\n    '.bmp',\n    '.svg'\n];\nfunction getModuleFromDependency(compilation, dep) {\n    return compilation.moduleGraph.getModule(dep);\n}\nfunction getFilesMapFromReasons(fileList, reasons, ignoreFn) {\n    // this uses the reasons tree to collect files specific to a\n    // certain parent allowing us to not have to trace each parent\n    // separately\n    const parentFilesMap = new Map();\n    function propagateToParents(parents, file, seen = new Set()) {\n        for (const parent of parents || []){\n            if (!seen.has(parent)) {\n                seen.add(parent);\n                let parentFiles = parentFilesMap.get(parent);\n                if (!parentFiles) {\n                    parentFiles = new Map();\n                    parentFilesMap.set(parent, parentFiles);\n                }\n                const ignored = Boolean(ignoreFn == null ? void 0 : ignoreFn(file, parent));\n                parentFiles.set(file, {\n                    ignored\n                });\n                const parentReason = reasons.get(parent);\n                if (parentReason == null ? void 0 : parentReason.parents) {\n                    propagateToParents(parentReason.parents, file, seen);\n                }\n            }\n        }\n    }\n    for (const file of fileList){\n        const reason = reasons.get(file);\n        const isInitial = (reason == null ? void 0 : reason.type.length) === 1 && reason.type.includes('initial');\n        if (!reason || !reason.parents || isInitial && reason.parents.size === 0) {\n            continue;\n        }\n        propagateToParents(reason.parents, file);\n    }\n    return parentFilesMap;\n}\nclass TraceEntryPointsPlugin {\n    constructor({ rootDir, appDir, pagesDir, compilerType, appDirEnabled, traceIgnores, esmExternals, outputFileTracingRoot }){\n        this.buildTraceContext = {};\n        this.rootDir = rootDir;\n        this.appDir = appDir;\n        this.pagesDir = pagesDir;\n        this.entryTraces = new Map();\n        this.esmExternals = esmExternals;\n        this.appDirEnabled = appDirEnabled;\n        this.traceIgnores = traceIgnores || [];\n        this.tracingRoot = outputFileTracingRoot || rootDir;\n        this.compilerType = compilerType;\n    }\n    // Here we output all traced assets and webpack chunks to a\n    // ${page}.js.nft.json file\n    async createTraceAssets(compilation, span) {\n        const outputPath = compilation.outputOptions.path || '';\n        await span.traceChild('create-trace-assets').traceAsyncFn(async ()=>{\n            const entryFilesMap = new Map();\n            const chunksToTrace = new Set();\n            const entryNameFilesMap = new Map();\n            const isTraceable = (file)=>!NOT_TRACEABLE.some((suffix)=>{\n                    return file.endsWith(suffix);\n                });\n            for (const entrypoint of compilation.entrypoints.values()){\n                const entryFiles = new Set();\n                for (const chunk of entrypoint.getEntrypointChunk().getAllReferencedChunks()){\n                    for (const file of chunk.files){\n                        if (isTraceable(file)) {\n                            const filePath = _path.default.join(outputPath, file);\n                            chunksToTrace.add(filePath);\n                            entryFiles.add(filePath);\n                        }\n                    }\n                    for (const file of chunk.auxiliaryFiles){\n                        if (isTraceable(file)) {\n                            const filePath = _path.default.join(outputPath, file);\n                            chunksToTrace.add(filePath);\n                            entryFiles.add(filePath);\n                        }\n                    }\n                }\n                entryFilesMap.set(entrypoint, entryFiles);\n                entryNameFilesMap.set(entrypoint.name || '', [\n                    ...entryFiles\n                ]);\n            }\n            // startTrace existed and callable\n            this.buildTraceContext.chunksTrace = {\n                action: {\n                    action: 'annotate',\n                    input: [\n                        ...chunksToTrace\n                    ],\n                    contextDirectory: this.tracingRoot,\n                    processCwd: this.rootDir\n                },\n                outputPath,\n                entryNameFilesMap: Object.fromEntries(entryNameFilesMap)\n            };\n            // server compiler outputs to `server/chunks` so we traverse up\n            // one, but edge-server does not so don't for that one\n            const outputPrefix = this.compilerType === 'server' ? '../' : '';\n            for (const [entrypoint, entryFiles] of entryFilesMap){\n                var _this_entryTraces_get;\n                const traceOutputName = `${outputPrefix}${entrypoint.name}.js.nft.json`;\n                const traceOutputPath = _path.default.dirname(_path.default.join(outputPath, traceOutputName));\n                // don't include the entry itself in the trace\n                entryFiles.delete(_path.default.join(outputPath, `${outputPrefix}${entrypoint.name}.js`));\n                if (entrypoint.name.startsWith('app/') && this.appDir) {\n                    var _this_buildTraceContext_entriesTrace_absolutePathByEntryName_entrypoint_name, _this_buildTraceContext_entriesTrace;\n                    const appDirRelativeEntryPath = (_this_buildTraceContext_entriesTrace = this.buildTraceContext.entriesTrace) == null ? void 0 : (_this_buildTraceContext_entriesTrace_absolutePathByEntryName_entrypoint_name = _this_buildTraceContext_entriesTrace.absolutePathByEntryName[entrypoint.name]) == null ? void 0 : _this_buildTraceContext_entriesTrace_absolutePathByEntryName_entrypoint_name.replace(this.appDir, '');\n                    const entryIsStaticMetadataRoute = appDirRelativeEntryPath && (0, _ismetadataroute.isMetadataRouteFile)(appDirRelativeEntryPath, [], true);\n                    // Include the client reference manifest in the trace, but not for\n                    // static metadata routes, for which we don't generate those.\n                    if (!entryIsStaticMetadataRoute) {\n                        entryFiles.add(_path.default.join(outputPath, outputPrefix, entrypoint.name.replace(/%5F/g, '_') + '_' + _constants.CLIENT_REFERENCE_MANIFEST + '.js'));\n                    }\n                }\n                const finalFiles = [];\n                await Promise.all([\n                    ...new Set([\n                        ...entryFiles,\n                        ...((_this_entryTraces_get = this.entryTraces.get(entrypoint.name)) == null ? void 0 : _this_entryTraces_get.keys()) || []\n                    ])\n                ].map(async (file)=>{\n                    var _this_entryTraces_get;\n                    const fileInfo = (_this_entryTraces_get = this.entryTraces.get(entrypoint.name)) == null ? void 0 : _this_entryTraces_get.get(file);\n                    const relativeFile = _path.default.relative(traceOutputPath, file).replace(/\\\\/g, '/');\n                    if (file) {\n                        if (!(fileInfo == null ? void 0 : fileInfo.bundled)) {\n                            finalFiles.push(relativeFile);\n                        }\n                    }\n                }));\n                compilation.emitAsset(traceOutputName, new _webpack.sources.RawSource(JSON.stringify({\n                    version: _constants.TRACE_OUTPUT_VERSION,\n                    files: finalFiles\n                })));\n            }\n        });\n    }\n    tapfinishModules(compilation, traceEntrypointsPluginSpan, doResolve, readlink, stat) {\n        compilation.hooks.finishModules.tapAsync(PLUGIN_NAME, async (_stats, callback)=>{\n            const finishModulesSpan = traceEntrypointsPluginSpan.traceChild('finish-modules');\n            await finishModulesSpan.traceAsyncFn(async ()=>{\n                // we create entry -> module maps so that we can\n                // look them up faster instead of having to iterate\n                // over the compilation modules list\n                const entryNameMap = new Map();\n                const entryModMap = new Map();\n                const additionalEntries = new Map();\n                const absolutePathByEntryName = new Map();\n                const depModMap = new Map();\n                await finishModulesSpan.traceChild('get-entries').traceAsyncFn(async ()=>{\n                    for (const [name, entry] of compilation.entries.entries()){\n                        const normalizedName = name == null ? void 0 : name.replace(/\\\\/g, '/');\n                        const isPage = normalizedName.startsWith('pages/');\n                        const isApp = this.appDirEnabled && normalizedName.startsWith('app/');\n                        if (isApp || isPage) {\n                            for (const dep of entry.dependencies){\n                                if (!dep) continue;\n                                const entryMod = getModuleFromDependency(compilation, dep);\n                                // Handle case where entry is a loader coming from Next.js.\n                                // For example edge-loader or app-loader.\n                                if (entryMod && entryMod.resource === '') {\n                                    const moduleBuildInfo = (0, _getmodulebuildinfo.getModuleBuildInfo)(entryMod);\n                                    // All loaders that are used to create entries have a `route` property on the buildInfo.\n                                    if (moduleBuildInfo.route) {\n                                        const absolutePath = (0, _entries.getPageFilePath)({\n                                            absolutePagePath: moduleBuildInfo.route.absolutePagePath,\n                                            rootDir: this.rootDir,\n                                            appDir: this.appDir,\n                                            pagesDir: this.pagesDir\n                                        });\n                                        // Ensures we don't handle non-pages.\n                                        if (this.pagesDir && absolutePath.startsWith(this.pagesDir) || this.appDir && absolutePath.startsWith(this.appDir)) {\n                                            entryModMap.set(absolutePath, entryMod);\n                                            entryNameMap.set(absolutePath, name);\n                                            absolutePathByEntryName.set(name, absolutePath);\n                                        }\n                                    }\n                                    // If there was no `route` property, we can assume that it was something custom instead.\n                                    // In order to trace these we add them to the additionalEntries map.\n                                    if (entryMod.request) {\n                                        let curMap = additionalEntries.get(name);\n                                        if (!curMap) {\n                                            curMap = new Map();\n                                            additionalEntries.set(name, curMap);\n                                        }\n                                        depModMap.set(entryMod.request, entryMod);\n                                        curMap.set(entryMod.resource, entryMod);\n                                    }\n                                }\n                                if (entryMod && entryMod.resource) {\n                                    entryNameMap.set(entryMod.resource, name);\n                                    entryModMap.set(entryMod.resource, entryMod);\n                                    let curMap = additionalEntries.get(name);\n                                    if (!curMap) {\n                                        curMap = new Map();\n                                        additionalEntries.set(name, curMap);\n                                    }\n                                    depModMap.set(entryMod.resource, entryMod);\n                                    curMap.set(entryMod.resource, entryMod);\n                                }\n                            }\n                        }\n                    }\n                });\n                const readFile = async (path)=>{\n                    var _mod_originalSource, _mod_originalSource1;\n                    const mod = depModMap.get(path) || entryModMap.get(path);\n                    // map the transpiled source when available to avoid\n                    // parse errors in node-file-trace\n                    let source = mod == null ? void 0 : (_mod_originalSource1 = mod.originalSource) == null ? void 0 : (_mod_originalSource = _mod_originalSource1.call(mod)) == null ? void 0 : _mod_originalSource.buffer();\n                    return source || '';\n                };\n                const entryPaths = Array.from(entryModMap.keys());\n                const collectDependencies = async (mod, parent)=>{\n                    if (!mod || !mod.dependencies) return;\n                    for (const dep of mod.dependencies){\n                        const depMod = getModuleFromDependency(compilation, dep);\n                        if ((depMod == null ? void 0 : depMod.resource) && !depModMap.get(depMod.resource)) {\n                            depModMap.set(depMod.resource, depMod);\n                            await collectDependencies(depMod, parent);\n                        }\n                    }\n                };\n                const entriesToTrace = [\n                    ...entryPaths\n                ];\n                for (const entry of entryPaths){\n                    await collectDependencies(entryModMap.get(entry), entry);\n                    const entryName = entryNameMap.get(entry);\n                    const curExtraEntries = additionalEntries.get(entryName);\n                    if (curExtraEntries) {\n                        entriesToTrace.push(...curExtraEntries.keys());\n                    }\n                }\n                const contextDirectory = this.tracingRoot;\n                const chunks = [\n                    ...entriesToTrace\n                ];\n                this.buildTraceContext.entriesTrace = {\n                    action: {\n                        action: 'print',\n                        input: chunks,\n                        contextDirectory,\n                        processCwd: this.rootDir\n                    },\n                    appDir: this.rootDir,\n                    depModArray: Array.from(depModMap.keys()),\n                    entryNameMap: Object.fromEntries(entryNameMap),\n                    absolutePathByEntryName: Object.fromEntries(absolutePathByEntryName),\n                    outputPath: compilation.outputOptions.path\n                };\n                let fileList;\n                let reasons;\n                const ignores = [\n                    ...TRACE_IGNORES,\n                    ...this.traceIgnores,\n                    '**/node_modules/**'\n                ];\n                // pre-compile the ignore matcher to avoid repeating on every ignoreFn call\n                const isIgnoreMatcher = (0, _picomatch.default)(ignores, {\n                    contains: true,\n                    dot: true\n                });\n                const ignoreFn = (path)=>{\n                    return isIgnoreMatcher(path);\n                };\n                await finishModulesSpan.traceChild('node-file-trace-plugin', {\n                    traceEntryCount: entriesToTrace.length + ''\n                }).traceAsyncFn(async ()=>{\n                    const result = await (0, _nft.nodeFileTrace)(entriesToTrace, {\n                        base: this.tracingRoot,\n                        processCwd: this.rootDir,\n                        readFile,\n                        readlink,\n                        stat,\n                        resolve: doResolve ? async (id, parent, job, isCjs)=>{\n                            return doResolve(id, parent, job, !isCjs);\n                        } : undefined,\n                        ignore: ignoreFn,\n                        mixedModules: true\n                    });\n                    // @ts-ignore\n                    fileList = result.fileList;\n                    result.esmFileList.forEach((file)=>fileList.add(file));\n                    reasons = result.reasons;\n                });\n                await finishModulesSpan.traceChild('collect-traced-files').traceAsyncFn(()=>{\n                    const parentFilesMap = getFilesMapFromReasons(fileList, reasons, (file)=>{\n                        var _reasons_get;\n                        // if a file was imported and a loader handled it\n                        // we don't include it in the trace e.g.\n                        // static image imports, CSS imports\n                        file = _path.default.join(this.tracingRoot, file);\n                        const depMod = depModMap.get(file);\n                        const isAsset = (_reasons_get = reasons.get(_path.default.relative(this.tracingRoot, file))) == null ? void 0 : _reasons_get.type.includes('asset');\n                        return !isAsset && Array.isArray(depMod == null ? void 0 : depMod.loaders) && depMod.loaders.length > 0;\n                    });\n                    for (const entry of entryPaths){\n                        var _parentFilesMap_get;\n                        const entryName = entryNameMap.get(entry);\n                        const normalizedEntry = _path.default.relative(this.tracingRoot, entry);\n                        const curExtraEntries = additionalEntries.get(entryName);\n                        const finalDeps = new Map();\n                        // ensure we include entry source file as well for\n                        // hash comparison\n                        finalDeps.set(entry, {\n                            bundled: true\n                        });\n                        for (const [dep, info] of ((_parentFilesMap_get = parentFilesMap.get(normalizedEntry)) == null ? void 0 : _parentFilesMap_get.entries()) || []){\n                            finalDeps.set(_path.default.join(this.tracingRoot, dep), {\n                                bundled: info.ignored\n                            });\n                        }\n                        if (curExtraEntries) {\n                            for (const extraEntry of curExtraEntries.keys()){\n                                var _parentFilesMap_get1;\n                                const normalizedExtraEntry = _path.default.relative(this.tracingRoot, extraEntry);\n                                finalDeps.set(extraEntry, {\n                                    bundled: false\n                                });\n                                for (const [dep, info] of ((_parentFilesMap_get1 = parentFilesMap.get(normalizedExtraEntry)) == null ? void 0 : _parentFilesMap_get1.entries()) || []){\n                                    finalDeps.set(_path.default.join(this.tracingRoot, dep), {\n                                        bundled: info.ignored\n                                    });\n                                }\n                            }\n                        }\n                        this.entryTraces.set(entryName, finalDeps);\n                    }\n                });\n            }).then(()=>callback(), (err)=>callback(err));\n        });\n    }\n    apply(compiler) {\n        compiler.hooks.compilation.tap(PLUGIN_NAME, (compilation)=>{\n            const compilationSpan = (0, _utils.getCompilationSpan)(compilation) || (0, _utils.getCompilationSpan)(compiler);\n            const traceEntrypointsPluginSpan = compilationSpan.traceChild('next-trace-entrypoint-plugin');\n            const readlink = async (path)=>{\n                try {\n                    return await new Promise((resolve, reject)=>{\n                        ;\n                        compilation.inputFileSystem.readlink(path, (err, link)=>{\n                            if (err) return reject(err);\n                            resolve(link);\n                        });\n                    });\n                } catch (e) {\n                    if ((0, _iserror.default)(e) && (e.code === 'EINVAL' || e.code === 'ENOENT' || e.code === 'UNKNOWN')) {\n                        return null;\n                    }\n                    throw e;\n                }\n            };\n            const stat = async (path)=>{\n                try {\n                    return await new Promise((resolve, reject)=>{\n                        ;\n                        compilation.inputFileSystem.stat(path, (err, stats)=>{\n                            if (err) return reject(err);\n                            resolve(stats);\n                        });\n                    });\n                } catch (e) {\n                    if ((0, _iserror.default)(e) && (e.code === 'ENOENT' || e.code === 'ENOTDIR')) {\n                        return null;\n                    }\n                    throw e;\n                }\n            };\n            traceEntrypointsPluginSpan.traceFn(()=>{\n                compilation.hooks.processAssets.tapAsync({\n                    name: PLUGIN_NAME,\n                    stage: _webpack.webpack.Compilation.PROCESS_ASSETS_STAGE_SUMMARIZE\n                }, (_, callback)=>{\n                    this.createTraceAssets(compilation, traceEntrypointsPluginSpan).then(()=>callback()).catch((err)=>callback(err));\n                });\n                let resolver = compilation.resolverFactory.get('normal');\n                function getPkgName(name) {\n                    const segments = name.split('/');\n                    if (name[0] === '@' && segments.length > 1) return segments.length > 1 ? segments.slice(0, 2).join('/') : null;\n                    return segments.length ? segments[0] : null;\n                }\n                const getResolve = (options)=>{\n                    const curResolver = resolver.withOptions(options);\n                    return (parent, request, job)=>new Promise((resolve, reject)=>{\n                            const context = _path.default.dirname(parent);\n                            curResolver.resolve({}, context, request, {\n                                fileDependencies: compilation.fileDependencies,\n                                missingDependencies: compilation.missingDependencies,\n                                contextDependencies: compilation.contextDependencies\n                            }, async (err, result, resContext)=>{\n                                if (err) return reject(err);\n                                if (!result) {\n                                    return reject(Object.defineProperty(new Error('module not found'), \"__NEXT_ERROR_CODE\", {\n                                        value: \"E512\",\n                                        enumerable: false,\n                                        configurable: true\n                                    }));\n                                }\n                                // webpack resolver doesn't strip loader query info\n                                // from the result so use path instead\n                                if (result.includes('?') || result.includes('!')) {\n                                    result = (resContext == null ? void 0 : resContext.path) || result;\n                                }\n                                try {\n                                    // we need to collect all parent package.json's used\n                                    // as webpack's resolve doesn't expose this and parent\n                                    // package.json could be needed for resolving e.g. stylis\n                                    // stylis/package.json -> stylis/dist/umd/package.json\n                                    if (result.includes('node_modules')) {\n                                        let requestPath = result.replace(/\\\\/g, '/').replace(/\\0/g, '');\n                                        if (!_path.default.isAbsolute(request) && request.includes('/') && (resContext == null ? void 0 : resContext.descriptionFileRoot)) {\n                                            var _getPkgName;\n                                            requestPath = (resContext.descriptionFileRoot + request.slice(((_getPkgName = getPkgName(request)) == null ? void 0 : _getPkgName.length) || 0) + _path.default.sep + 'package.json').replace(/\\\\/g, '/').replace(/\\0/g, '');\n                                        }\n                                        const rootSeparatorIndex = requestPath.indexOf('/');\n                                        let separatorIndex;\n                                        while((separatorIndex = requestPath.lastIndexOf('/')) > rootSeparatorIndex){\n                                            requestPath = requestPath.slice(0, separatorIndex);\n                                            const curPackageJsonPath = `${requestPath}/package.json`;\n                                            if (await job.isFile(curPackageJsonPath)) {\n                                                await job.emitFile(await job.realpath(curPackageJsonPath), 'resolve', parent);\n                                            }\n                                        }\n                                    }\n                                } catch (_err) {\n                                // we failed to resolve the package.json boundary,\n                                // we don't block emitting the initial asset from this\n                                }\n                                resolve([\n                                    result,\n                                    options.dependencyType === 'esm'\n                                ]);\n                            });\n                        });\n                };\n                const CJS_RESOLVE_OPTIONS = {\n                    ..._webpackconfig.NODE_RESOLVE_OPTIONS,\n                    fullySpecified: undefined,\n                    modules: undefined,\n                    extensions: undefined\n                };\n                const BASE_CJS_RESOLVE_OPTIONS = {\n                    ...CJS_RESOLVE_OPTIONS,\n                    alias: false\n                };\n                const ESM_RESOLVE_OPTIONS = {\n                    ..._webpackconfig.NODE_ESM_RESOLVE_OPTIONS,\n                    fullySpecified: undefined,\n                    modules: undefined,\n                    extensions: undefined\n                };\n                const BASE_ESM_RESOLVE_OPTIONS = {\n                    ...ESM_RESOLVE_OPTIONS,\n                    alias: false\n                };\n                const doResolve = async (request, parent, job, isEsmRequested)=>{\n                    const context = _path.default.dirname(parent);\n                    // When in esm externals mode, and using import, we resolve with\n                    // ESM resolving options.\n                    const { res } = await (0, _handleexternals.resolveExternal)(this.rootDir, this.esmExternals, context, request, isEsmRequested, (options)=>(_, resRequest)=>{\n                            return getResolve(options)(parent, resRequest, job);\n                        }, undefined, undefined, ESM_RESOLVE_OPTIONS, CJS_RESOLVE_OPTIONS, BASE_ESM_RESOLVE_OPTIONS, BASE_CJS_RESOLVE_OPTIONS);\n                    if (!res) {\n                        throw Object.defineProperty(new Error(`failed to resolve ${request} from ${parent}`), \"__NEXT_ERROR_CODE\", {\n                            value: \"E361\",\n                            enumerable: false,\n                            configurable: true\n                        });\n                    }\n                    return res.replace(/\\0/g, '');\n                };\n                this.tapfinishModules(compilation, traceEntrypointsPluginSpan, doResolve, readlink, stat);\n            });\n        });\n    }\n}\n\n//# sourceMappingURL=next-trace-entrypoints-plugin.js.map"
        }
    ]
}