{
    "sourceFile": "node_modules/next/dist/build/webpack/plugins/middleware-plugin.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892671444,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    SUPPORTED_NATIVE_MODULES: null,\n    default: null,\n    getEdgePolyfilledModules: null,\n    handleWebpackExternalForEdgeRuntime: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    SUPPORTED_NATIVE_MODULES: function() {\n        return SUPPORTED_NATIVE_MODULES;\n    },\n    default: function() {\n        return MiddlewarePlugin;\n    },\n    getEdgePolyfilledModules: function() {\n        return getEdgePolyfilledModules;\n    },\n    handleWebpackExternalForEdgeRuntime: function() {\n        return handleWebpackExternalForEdgeRuntime;\n    }\n});\nconst _routeregex = require(\"../../../shared/lib/router/utils/route-regex\");\nconst _getmodulebuildinfo = require(\"../loaders/get-module-build-info\");\nconst _utils = require(\"../../../shared/lib/router/utils\");\nconst _webpack = require(\"next/dist/compiled/webpack/webpack\");\nconst _picomatch = /*#__PURE__*/ _interop_require_default(require(\"next/dist/compiled/picomatch\"));\nconst _path = /*#__PURE__*/ _interop_require_default(require(\"path\"));\nconst _constants = require(\"../../../shared/lib/constants\");\nconst _shared = require(\"../../../trace/shared\");\nconst _events = require(\"../../../telemetry/events\");\nconst _apppaths = require(\"../../../shared/lib/router/utils/app-paths\");\nconst _constants1 = require(\"../../../lib/constants\");\nconst _generateinterceptionroutesrewrites = require(\"../../../lib/generate-interception-routes-rewrites\");\nconst _parsedynamiccodeevaluationerror = require(\"./wellknown-errors-plugin/parse-dynamic-code-evaluation-error\");\nconst _utils1 = require(\"../utils\");\nfunction _interop_require_default(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nconst KNOWN_SAFE_DYNAMIC_PACKAGES = require('../../../lib/known-edge-safe-packages.json');\nconst NAME = 'MiddlewarePlugin';\nconst MANIFEST_VERSION = 3;\n/**\n * Checks the value of usingIndirectEval and when it is a set of modules it\n * check if any of the modules is actually being used. If the value is\n * simply truthy it will return true.\n */ function isUsingIndirectEvalAndUsedByExports(args) {\n    const { moduleGraph, runtime, module: module1, usingIndirectEval, wp } = args;\n    if (typeof usingIndirectEval === 'boolean') {\n        return usingIndirectEval;\n    }\n    const exportsInfo = moduleGraph.getExportsInfo(module1);\n    for (const exportName of usingIndirectEval){\n        if (exportsInfo.getUsed(exportName, runtime) !== wp.UsageState.Unused) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction getEntryFiles(entryFiles, meta, hasInstrumentationHook, opts) {\n    const files = [];\n    if (meta.edgeSSR) {\n        if (meta.edgeSSR.isServerComponent) {\n            files.push(`server/${_constants.SERVER_REFERENCE_MANIFEST}.js`);\n            if (opts.sriEnabled) {\n                files.push(`server/${_constants.SUBRESOURCE_INTEGRITY_MANIFEST}.js`);\n            }\n            files.push(...entryFiles.filter((file)=>file.startsWith('app/') && !file.endsWith('.hot-update.js')).map((file)=>'server/' + file.replace(/\\.js$/, '_' + _constants.CLIENT_REFERENCE_MANIFEST + '.js')));\n        }\n        if (!opts.dev && !meta.edgeSSR.isAppDir) {\n            files.push(`server/${_constants.DYNAMIC_CSS_MANIFEST}.js`);\n        }\n        files.push(`server/${_constants.MIDDLEWARE_BUILD_MANIFEST}.js`, `server/${_constants.MIDDLEWARE_REACT_LOADABLE_MANIFEST}.js`, `server/${_constants.NEXT_FONT_MANIFEST}.js`, `server/${_constants.INTERCEPTION_ROUTE_REWRITE_MANIFEST}.js`);\n    }\n    if (hasInstrumentationHook) {\n        files.push(`server/edge-${_constants1.INSTRUMENTATION_HOOK_FILENAME}.js`);\n    }\n    files.push(...entryFiles.filter((file)=>!file.endsWith('.hot-update.js')).map((file)=>'server/' + file));\n    return files;\n}\nfunction getCreateAssets(params) {\n    const { compilation, metadataByEntry, opts } = params;\n    return ()=>{\n        const middlewareManifest = {\n            version: MANIFEST_VERSION,\n            middleware: {},\n            functions: {},\n            sortedMiddleware: []\n        };\n        const hasInstrumentationHook = compilation.entrypoints.has(_constants1.INSTRUMENTATION_HOOK_FILENAME);\n        // we only emit this entry for the edge runtime since it doesn't have access to a routes manifest\n        // and we don't need to provide the entire route manifest, just the interception routes.\n        const interceptionRewrites = JSON.stringify(opts.rewrites.beforeFiles.filter(_generateinterceptionroutesrewrites.isInterceptionRouteRewrite));\n        compilation.emitAsset(`${_constants.INTERCEPTION_ROUTE_REWRITE_MANIFEST}.js`, new _webpack.sources.RawSource(`self.__INTERCEPTION_ROUTE_REWRITE_MANIFEST=${JSON.stringify(interceptionRewrites)}`));\n        for (const entrypoint of compilation.entrypoints.values()){\n            var _metadata_edgeMiddleware, _metadata_edgeSSR, _metadata_edgeApiFunction, _metadata_edgeSSR1, _metadata_edgeMiddleware1;\n            if (!entrypoint.name) {\n                continue;\n            }\n            // There should always be metadata for the entrypoint.\n            const metadata = metadataByEntry.get(entrypoint.name);\n            const page = (metadata == null ? void 0 : (_metadata_edgeMiddleware = metadata.edgeMiddleware) == null ? void 0 : _metadata_edgeMiddleware.page) || (metadata == null ? void 0 : (_metadata_edgeSSR = metadata.edgeSSR) == null ? void 0 : _metadata_edgeSSR.page) || (metadata == null ? void 0 : (_metadata_edgeApiFunction = metadata.edgeApiFunction) == null ? void 0 : _metadata_edgeApiFunction.page);\n            if (!page) {\n                continue;\n            }\n            const matcherSource = ((_metadata_edgeSSR1 = metadata.edgeSSR) == null ? void 0 : _metadata_edgeSSR1.isAppDir) ? (0, _apppaths.normalizeAppPath)(page) : page;\n            const catchAll = !metadata.edgeSSR && !metadata.edgeApiFunction;\n            const { namedRegex } = (0, _routeregex.getNamedMiddlewareRegex)(matcherSource, {\n                catchAll\n            });\n            const matchers = (metadata == null ? void 0 : (_metadata_edgeMiddleware1 = metadata.edgeMiddleware) == null ? void 0 : _metadata_edgeMiddleware1.matchers) ?? [\n                {\n                    regexp: namedRegex,\n                    originalSource: page === '/' && catchAll ? '/:path*' : matcherSource\n                }\n            ];\n            const isEdgeFunction = !!(metadata.edgeApiFunction || metadata.edgeSSR);\n            const edgeFunctionDefinition = {\n                files: getEntryFiles(entrypoint.getFiles(), metadata, hasInstrumentationHook, opts),\n                name: entrypoint.name,\n                page: page,\n                matchers,\n                wasm: Array.from(metadata.wasmBindings, ([name, filePath])=>({\n                        name,\n                        filePath\n                    })),\n                assets: Array.from(metadata.assetBindings, ([name, filePath])=>({\n                        name,\n                        filePath\n                    })),\n                env: opts.edgeEnvironments,\n                ...metadata.regions && {\n                    regions: metadata.regions\n                }\n            };\n            if (isEdgeFunction) {\n                middlewareManifest.functions[page] = edgeFunctionDefinition;\n            } else {\n                middlewareManifest.middleware[page] = edgeFunctionDefinition;\n            }\n        }\n        middlewareManifest.sortedMiddleware = (0, _utils.getSortedRoutes)(Object.keys(middlewareManifest.middleware));\n        compilation.emitAsset(_constants.MIDDLEWARE_MANIFEST, new _webpack.sources.RawSource(JSON.stringify(middlewareManifest, null, 2)));\n    };\n}\nfunction buildWebpackError({ message, loc, compilation, entryModule, parser }) {\n    const error = new compilation.compiler.webpack.WebpackError(message);\n    error.name = NAME;\n    const module1 = entryModule ?? (parser == null ? void 0 : parser.state.current);\n    if (module1) {\n        error.module = module1;\n    }\n    error.loc = loc;\n    return error;\n}\nfunction isInMiddlewareLayer(parser) {\n    var _parser_state_module;\n    const layer = (_parser_state_module = parser.state.module) == null ? void 0 : _parser_state_module.layer;\n    return layer === _constants1.WEBPACK_LAYERS.middleware || layer === _constants1.WEBPACK_LAYERS.apiEdge;\n}\nfunction isNodeJsModule(moduleName) {\n    return require('module').builtinModules.includes(moduleName);\n}\nfunction isDynamicCodeEvaluationAllowed(fileName, middlewareConfig, rootDir) {\n    // Some packages are known to use `eval` but are safe to use in the Edge\n    // Runtime because the dynamic code will never be executed.\n    if (KNOWN_SAFE_DYNAMIC_PACKAGES.some((pkg)=>fileName.includes(`/node_modules/${pkg}/`.replace(/\\//g, _path.default.sep)))) {\n        return true;\n    }\n    const name = fileName.replace(rootDir ?? '', '');\n    return (0, _picomatch.default)((middlewareConfig == null ? void 0 : middlewareConfig.unstable_allowDynamic) ?? [], {\n        dot: true\n    })(name);\n}\nfunction buildUnsupportedApiError({ apiName, loc, ...rest }) {\n    return buildWebpackError({\n        message: `A Node.js API is used (${apiName} at line: ${loc.start.line}) which is not supported in the Edge Runtime.\nLearn more: https://nextjs.org/docs/api-reference/edge-runtime`,\n        loc,\n        ...rest\n    });\n}\nfunction registerUnsupportedApiHooks(parser, compilation) {\n    for (const expression of _constants.EDGE_UNSUPPORTED_NODE_APIS){\n        const warnForUnsupportedApi = (node)=>{\n            if (!isInMiddlewareLayer(parser)) {\n                return;\n            }\n            compilation.warnings.push(buildUnsupportedApiError({\n                compilation,\n                parser,\n                apiName: expression,\n                ...node\n            }));\n            return true;\n        };\n        parser.hooks.call.for(expression).tap(NAME, warnForUnsupportedApi);\n        parser.hooks.expression.for(expression).tap(NAME, warnForUnsupportedApi);\n        parser.hooks.callMemberChain.for(expression).tap(NAME, warnForUnsupportedApi);\n        parser.hooks.expressionMemberChain.for(expression).tap(NAME, warnForUnsupportedApi);\n    }\n    const warnForUnsupportedProcessApi = (node, [callee])=>{\n        if (!isInMiddlewareLayer(parser) || callee === 'env') {\n            return;\n        }\n        compilation.warnings.push(buildUnsupportedApiError({\n            compilation,\n            parser,\n            apiName: `process.${callee}`,\n            ...node\n        }));\n        return true;\n    };\n    parser.hooks.callMemberChain.for('process').tap(NAME, warnForUnsupportedProcessApi);\n    parser.hooks.expressionMemberChain.for('process').tap(NAME, warnForUnsupportedProcessApi);\n}\nfunction getCodeAnalyzer(params) {\n    return (parser)=>{\n        const { dev, compiler: { webpack: wp }, compilation } = params;\n        const { hooks } = parser;\n        /**\n     * For an expression this will check the graph to ensure it is being used\n     * by exports. Then it will store in the module buildInfo a boolean to\n     * express that it contains dynamic code and, if it is available, the\n     * module path that is using it.\n     */ const handleExpression = ()=>{\n            if (!isInMiddlewareLayer(parser)) {\n                return;\n            }\n            wp.optimize.InnerGraph.onUsage(parser.state, (used = true)=>{\n                const buildInfo = (0, _getmodulebuildinfo.getModuleBuildInfo)(parser.state.module);\n                if (buildInfo.usingIndirectEval === true || used === false) {\n                    return;\n                }\n                if (!buildInfo.usingIndirectEval || used === true) {\n                    buildInfo.usingIndirectEval = used;\n                    return;\n                }\n                buildInfo.usingIndirectEval = new Set([\n                    ...Array.from(buildInfo.usingIndirectEval),\n                    ...Array.from(used)\n                ]);\n            });\n        };\n        /**\n     * This expression handler allows to wrap a dynamic code expression with a\n     * function call where we can warn about dynamic code not being allowed\n     * but actually execute the expression.\n     */ const handleWrapExpression = (expr)=>{\n            if (!isInMiddlewareLayer(parser)) {\n                return;\n            }\n            const { ConstDependency } = wp.dependencies;\n            const dep1 = new ConstDependency('__next_eval__(function() { return ', expr.range[0]);\n            dep1.loc = expr.loc;\n            parser.state.module.addPresentationalDependency(dep1);\n            const dep2 = new ConstDependency('})', expr.range[1]);\n            dep2.loc = expr.loc;\n            parser.state.module.addPresentationalDependency(dep2);\n            handleExpression();\n            return true;\n        };\n        /**\n     * This expression handler allows to wrap a WebAssembly.compile invocation with a\n     * function call where we can warn about WASM code generation not being allowed\n     * but actually execute the expression.\n     */ const handleWrapWasmCompileExpression = (expr)=>{\n            if (!isInMiddlewareLayer(parser)) {\n                return;\n            }\n            const { ConstDependency } = wp.dependencies;\n            const dep1 = new ConstDependency('__next_webassembly_compile__(function() { return ', expr.range[0]);\n            dep1.loc = expr.loc;\n            parser.state.module.addPresentationalDependency(dep1);\n            const dep2 = new ConstDependency('})', expr.range[1]);\n            dep2.loc = expr.loc;\n            parser.state.module.addPresentationalDependency(dep2);\n            handleExpression();\n        };\n        /**\n     * This expression handler allows to wrap a WebAssembly.instatiate invocation with a\n     * function call where we can warn about WASM code generation not being allowed\n     * but actually execute the expression.\n     *\n     * Note that we don't update `usingIndirectEval`, i.e. we don't abort a production build\n     * since we can't determine statically if the first parameter is a module (legit use) or\n     * a buffer (dynamic code generation).\n     */ const handleWrapWasmInstantiateExpression = (expr)=>{\n            if (!isInMiddlewareLayer(parser)) {\n                return;\n            }\n            if (dev) {\n                const { ConstDependency } = wp.dependencies;\n                const dep1 = new ConstDependency('__next_webassembly_instantiate__(function() { return ', expr.range[0]);\n                dep1.loc = expr.loc;\n                parser.state.module.addPresentationalDependency(dep1);\n                const dep2 = new ConstDependency('})', expr.range[1]);\n                dep2.loc = expr.loc;\n                parser.state.module.addPresentationalDependency(dep2);\n            }\n        };\n        /**\n     * Handler to store original source location of static and dynamic imports into module's buildInfo.\n     */ const handleImport = (node)=>{\n            var _node_source;\n            if (isInMiddlewareLayer(parser) && ((_node_source = node.source) == null ? void 0 : _node_source.value) && (node == null ? void 0 : node.loc)) {\n                var _node_source_value;\n                const { module: module1, source } = parser.state;\n                const buildInfo = (0, _getmodulebuildinfo.getModuleBuildInfo)(module1);\n                if (!buildInfo.importLocByPath) {\n                    buildInfo.importLocByPath = new Map();\n                }\n                const importedModule = (_node_source_value = node.source.value) == null ? void 0 : _node_source_value.toString();\n                buildInfo.importLocByPath.set(importedModule, {\n                    sourcePosition: {\n                        ...node.loc.start,\n                        source: module1.identifier()\n                    },\n                    sourceContent: source.toString()\n                });\n                if (!dev && isNodeJsModule(importedModule) && !SUPPORTED_NATIVE_MODULES.includes(importedModule)) {\n                    compilation.warnings.push(buildWebpackError({\n                        message: `A Node.js module is loaded ('${importedModule}' at line ${node.loc.start.line}) which is not supported in the Edge Runtime.\nLearn More: https://nextjs.org/docs/messages/node-module-in-edge-runtime`,\n                        compilation,\n                        parser,\n                        ...node\n                    }));\n                }\n            }\n        };\n        /**\n     * A noop handler to skip analyzing some cases.\n     * Order matters: for it to work, it must be registered first\n     */ const skip = ()=>isInMiddlewareLayer(parser) ? true : undefined;\n        for (const prefix of [\n            '',\n            'global.'\n        ]){\n            hooks.expression.for(`${prefix}Function.prototype`).tap(NAME, skip);\n            hooks.expression.for(`${prefix}Function.bind`).tap(NAME, skip);\n            hooks.call.for(`${prefix}eval`).tap(NAME, handleWrapExpression);\n            hooks.call.for(`${prefix}Function`).tap(NAME, handleWrapExpression);\n            hooks.new.for(`${prefix}Function`).tap(NAME, handleWrapExpression);\n            hooks.call.for(`${prefix}WebAssembly.compile`).tap(NAME, handleWrapWasmCompileExpression);\n            hooks.call.for(`${prefix}WebAssembly.instantiate`).tap(NAME, handleWrapWasmInstantiateExpression);\n        }\n        hooks.importCall.tap(NAME, handleImport);\n        hooks.import.tap(NAME, handleImport);\n        if (!dev) {\n            // do not issue compilation warning on dev: invoking code will provide details\n            registerUnsupportedApiHooks(parser, compilation);\n        }\n    };\n}\nfunction getExtractMetadata(params) {\n    const { dev, compilation, metadataByEntry, compiler } = params;\n    const { webpack: wp } = compiler;\n    return async ()=>{\n        metadataByEntry.clear();\n        const telemetry = _shared.traceGlobals.get('telemetry');\n        for (const [entryName, entry] of compilation.entries){\n            var _entry_dependencies, _route_middlewareConfig;\n            if (entry.options.runtime !== _constants.EDGE_RUNTIME_WEBPACK) {\n                continue;\n            }\n            const entryDependency = (_entry_dependencies = entry.dependencies) == null ? void 0 : _entry_dependencies[0];\n            const resolvedModule = compilation.moduleGraph.getResolvedModule(entryDependency);\n            if (!resolvedModule) {\n                continue;\n            }\n            const { rootDir, route } = (0, _getmodulebuildinfo.getModuleBuildInfo)(resolvedModule);\n            const { moduleGraph } = compilation;\n            const modules = new Set();\n            const addEntriesFromDependency = (dependency)=>{\n                const module1 = moduleGraph.getModule(dependency);\n                if (module1) {\n                    modules.add(module1);\n                }\n            };\n            entry.dependencies.forEach(addEntriesFromDependency);\n            entry.includeDependencies.forEach(addEntriesFromDependency);\n            const entryMetadata = {\n                wasmBindings: new Map(),\n                assetBindings: new Map()\n            };\n            if (route == null ? void 0 : (_route_middlewareConfig = route.middlewareConfig) == null ? void 0 : _route_middlewareConfig.regions) {\n                entryMetadata.regions = route.middlewareConfig.regions;\n            }\n            if (route == null ? void 0 : route.preferredRegion) {\n                const preferredRegion = route.preferredRegion;\n                entryMetadata.regions = // Ensures preferredRegion is always an array in the manifest.\n                typeof preferredRegion === 'string' ? [\n                    preferredRegion\n                ] : preferredRegion;\n            }\n            let ogImageGenerationCount = 0;\n            for (const module1 of modules){\n                const buildInfo = (0, _getmodulebuildinfo.getModuleBuildInfo)(module1);\n                /**\n         * Check if it uses the image generation feature.\n         */ if (!dev) {\n                    const resource = module1.resource;\n                    const hasOGImageGeneration = resource && /[\\\\/]node_modules[\\\\/]@vercel[\\\\/]og[\\\\/]dist[\\\\/]index\\.(edge|node)\\.js$|[\\\\/]next[\\\\/]dist[\\\\/](esm[\\\\/])?server[\\\\/]og[\\\\/]image-response\\.js$/.test(resource);\n                    if (hasOGImageGeneration) {\n                        ogImageGenerationCount++;\n                    }\n                }\n                /**\n         * When building for production checks if the module is using `eval`\n         * and in such case produces a compilation error. The module has to\n         * be in use.\n         */ if (!dev && buildInfo.usingIndirectEval && isUsingIndirectEvalAndUsedByExports({\n                    module: module1,\n                    moduleGraph,\n                    runtime: wp.util.runtime.getEntryRuntime(compilation, entryName),\n                    usingIndirectEval: buildInfo.usingIndirectEval,\n                    wp\n                })) {\n                    var _route_middlewareConfig1;\n                    const id = module1.identifier();\n                    if (/node_modules[\\\\/]regenerator-runtime[\\\\/]runtime\\.js/.test(id)) {\n                        continue;\n                    }\n                    if (route == null ? void 0 : (_route_middlewareConfig1 = route.middlewareConfig) == null ? void 0 : _route_middlewareConfig1.unstable_allowDynamic) {\n                        telemetry == null ? void 0 : telemetry.record({\n                            eventName: 'NEXT_EDGE_ALLOW_DYNAMIC_USED',\n                            payload: {\n                                file: route == null ? void 0 : route.absolutePagePath.replace(rootDir ?? '', ''),\n                                config: route == null ? void 0 : route.middlewareConfig,\n                                fileWithDynamicCode: module1.userRequest.replace(rootDir ?? '', '')\n                            }\n                        });\n                    }\n                    if (!isDynamicCodeEvaluationAllowed(module1.userRequest, route == null ? void 0 : route.middlewareConfig, rootDir)) {\n                        const message = `Dynamic Code Evaluation (e. g. 'eval', 'new Function', 'WebAssembly.compile') not allowed in Edge Runtime ${typeof buildInfo.usingIndirectEval !== 'boolean' ? `\\nUsed by ${Array.from(buildInfo.usingIndirectEval).join(', ')}` : ''}\\nLearn More: https://nextjs.org/docs/messages/edge-dynamic-code-evaluation`;\n                        compilation.errors.push((0, _parsedynamiccodeevaluationerror.getDynamicCodeEvaluationError)(message, module1, compilation, compiler));\n                    }\n                }\n                /**\n         * The entry module has to be either a page or a middleware and hold\n         * the corresponding metadata.\n         */ if (buildInfo == null ? void 0 : buildInfo.nextEdgeSSR) {\n                    entryMetadata.edgeSSR = buildInfo.nextEdgeSSR;\n                } else if (buildInfo == null ? void 0 : buildInfo.nextEdgeMiddleware) {\n                    entryMetadata.edgeMiddleware = buildInfo.nextEdgeMiddleware;\n                } else if (buildInfo == null ? void 0 : buildInfo.nextEdgeApiFunction) {\n                    entryMetadata.edgeApiFunction = buildInfo.nextEdgeApiFunction;\n                }\n                /**\n         * If the module is a WASM module we read the binding information and\n         * append it to the entry wasm bindings.\n         */ if (buildInfo == null ? void 0 : buildInfo.nextWasmMiddlewareBinding) {\n                    entryMetadata.wasmBindings.set(buildInfo.nextWasmMiddlewareBinding.name, buildInfo.nextWasmMiddlewareBinding.filePath);\n                }\n                if (buildInfo == null ? void 0 : buildInfo.nextAssetMiddlewareBinding) {\n                    entryMetadata.assetBindings.set(buildInfo.nextAssetMiddlewareBinding.name, buildInfo.nextAssetMiddlewareBinding.filePath);\n                }\n                /**\n         * Append to the list of modules to process outgoingConnections from\n         * the module that is being processed.\n         */ for (const conn of (0, _utils1.getModuleReferencesInOrder)(module1, moduleGraph)){\n                    if (conn.module) {\n                        modules.add(conn.module);\n                    }\n                }\n            }\n            telemetry == null ? void 0 : telemetry.record({\n                eventName: _events.EVENT_BUILD_FEATURE_USAGE,\n                payload: {\n                    featureName: 'vercelImageGeneration',\n                    invocationCount: ogImageGenerationCount\n                }\n            });\n            metadataByEntry.set(entryName, entryMetadata);\n        }\n    };\n}\nclass MiddlewarePlugin {\n    constructor({ dev, sriEnabled, rewrites, edgeEnvironments }){\n        this.dev = dev;\n        this.sriEnabled = sriEnabled;\n        this.rewrites = rewrites;\n        this.edgeEnvironments = edgeEnvironments;\n    }\n    apply(compiler) {\n        compiler.hooks.compilation.tap(NAME, (compilation, params)=>{\n            const { hooks } = params.normalModuleFactory;\n            /**\n       * This is the static code analysis phase.\n       */ const codeAnalyzer = getCodeAnalyzer({\n                dev: this.dev,\n                compiler,\n                compilation\n            });\n            // parser hooks aren't available in rspack\n            if (!process.env.NEXT_RSPACK) {\n                hooks.parser.for('javascript/auto').tap(NAME, codeAnalyzer);\n                hooks.parser.for('javascript/dynamic').tap(NAME, codeAnalyzer);\n                hooks.parser.for('javascript/esm').tap(NAME, codeAnalyzer);\n            }\n            /**\n       * Extract all metadata for the entry points in a Map object.\n       */ const metadataByEntry = new Map();\n            compilation.hooks.finishModules.tapPromise(NAME, getExtractMetadata({\n                compilation,\n                compiler,\n                dev: this.dev,\n                metadataByEntry\n            }));\n            /**\n       * Emit the middleware manifest.\n       */ compilation.hooks.processAssets.tap({\n                name: 'NextJsMiddlewareManifest',\n                stage: _webpack.webpack.Compilation.PROCESS_ASSETS_STAGE_ADDITIONS\n            }, getCreateAssets({\n                compilation,\n                metadataByEntry,\n                opts: {\n                    sriEnabled: this.sriEnabled,\n                    rewrites: this.rewrites,\n                    edgeEnvironments: this.edgeEnvironments,\n                    dev: this.dev\n                }\n            }));\n        });\n    }\n}\nconst SUPPORTED_NATIVE_MODULES = [\n    'buffer',\n    'events',\n    'assert',\n    'util',\n    'async_hooks'\n];\nconst supportedEdgePolyfills = new Set(SUPPORTED_NATIVE_MODULES);\nfunction getEdgePolyfilledModules() {\n    const records = {};\n    for (const mod of SUPPORTED_NATIVE_MODULES){\n        records[mod] = `commonjs node:${mod}`;\n        records[`node:${mod}`] = `commonjs node:${mod}`;\n    }\n    return records;\n}\nasync function handleWebpackExternalForEdgeRuntime({ request, context, contextInfo, getResolve }) {\n    if ((contextInfo.issuerLayer === _constants1.WEBPACK_LAYERS.middleware || contextInfo.issuerLayer === _constants1.WEBPACK_LAYERS.apiEdge) && isNodeJsModule(request) && !supportedEdgePolyfills.has(request)) {\n        // allows user to provide and use their polyfills, as we do with buffer.\n        try {\n            await getResolve()(context, request);\n        } catch  {\n            return `root globalThis.__import_unsupported('${request}')`;\n        }\n    }\n}\n\n//# sourceMappingURL=middleware-plugin.js.map"
        }
    ]
}