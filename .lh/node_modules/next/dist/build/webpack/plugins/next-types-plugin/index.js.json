{
    "sourceFile": "node_modules/next/dist/build/webpack/plugins/next-types-plugin/index.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892671938,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"NextTypesPlugin\", {\n    enumerable: true,\n    get: function() {\n        return NextTypesPlugin;\n    }\n});\nconst _promises = /*#__PURE__*/ _interop_require_default(require(\"fs/promises\"));\nconst _webpack = require(\"next/dist/compiled/webpack/webpack\");\nconst _pathtoregexp = require(\"next/dist/compiled/path-to-regexp\");\nconst _path = /*#__PURE__*/ _interop_require_default(require(\"path\"));\nconst _constants = require(\"../../../../lib/constants\");\nconst _denormalizepagepath = require(\"../../../../shared/lib/page-path/denormalize-page-path\");\nconst _ensureleadingslash = require(\"../../../../shared/lib/page-path/ensure-leading-slash\");\nconst _normalizepathsep = require(\"../../../../shared/lib/page-path/normalize-path-sep\");\nconst _http = require(\"../../../../server/web/http\");\nconst _utils = require(\"../../../../shared/lib/router/utils\");\nconst _apppaths = require(\"../../../../shared/lib/router/utils/app-paths\");\nconst _entries = require(\"../../../entries\");\nconst _shared = require(\"./shared\");\nconst _buildcontext = require(\"../../../build-context\");\nfunction _interop_require_default(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nconst PLUGIN_NAME = 'NextTypesPlugin';\nfunction createTypeGuardFile(fullPath, relativePath, options) {\n    return `// File: ${fullPath}\nimport * as entry from '${relativePath}.js'\n${options.type === 'route' ? `import type { NextRequest } from 'next/server.js'` : `import type { ResolvingMetadata, ResolvingViewport } from 'next/dist/lib/metadata/types/metadata-interface.js'`}\n\ntype TEntry = typeof import('${relativePath}.js')\n\ntype SegmentParams<T extends Object = any> = T extends Record<string, any>\n  ? { [K in keyof T]: T[K] extends string ? string | string[] | undefined : never }\n  : T\n\n// Check that the entry is a valid entry\ncheckFields<Diff<{\n  ${options.type === 'route' ? _http.HTTP_METHODS.map((method)=>`${method}?: Function`).join('\\n  ') : 'default: Function'}\n  config?: {}\n  generateStaticParams?: Function\n  revalidate?: RevalidateRange<TEntry> | false\n  dynamic?: 'auto' | 'force-dynamic' | 'error' | 'force-static'\n  dynamicParams?: boolean\n  fetchCache?: 'auto' | 'force-no-store' | 'only-no-store' | 'default-no-store' | 'default-cache' | 'only-cache' | 'force-cache'\n  preferredRegion?: 'auto' | 'global' | 'home' | string | string[]\n  runtime?: 'nodejs' | 'experimental-edge' | 'edge'\n  maxDuration?: number\n  ${options.type === 'route' ? '' : `\n  metadata?: any\n  generateMetadata?: Function\n  viewport?: any\n  generateViewport?: Function\n  experimental_ppr?: boolean\n  `}\n}, TEntry, ''>>()\n\n${options.type === 'route' ? `type RouteContext = { params: Promise<SegmentParams> }` : ''}\n${options.type === 'route' ? _http.HTTP_METHODS.map((method)=>`// Check the prop type of the entry function\nif ('${method}' in entry) {\n  checkFields<\n    Diff<\n      ParamCheck<Request | NextRequest>,\n      {\n        __tag__: '${method}'\n        __param_position__: 'first'\n        __param_type__: FirstArg<MaybeField<TEntry, '${method}'>>\n      },\n      '${method}'\n    >\n  >()\n  checkFields<\n    Diff<\n      ParamCheck<RouteContext>,\n      {\n        __tag__: '${method}'\n        __param_position__: 'second'\n        __param_type__: SecondArg<MaybeField<TEntry, '${method}'>>\n      },\n      '${method}'\n    >\n  >()\n  ${''}\n  checkFields<\n    Diff<\n      {\n        __tag__: '${method}',\n        __return_type__: Response | void | never | Promise<Response | void | never>\n      },\n      {\n        __tag__: '${method}',\n        __return_type__: ReturnType<MaybeField<TEntry, '${method}'>>\n      },\n      '${method}'\n    >\n  >()\n}\n`).join('') : `// Check the prop type of the entry function\ncheckFields<Diff<${options.type === 'page' ? 'PageProps' : 'LayoutProps'}, FirstArg<TEntry['default']>, 'default'>>()\n\n// Check the arguments and return type of the generateMetadata function\nif ('generateMetadata' in entry) {\n  checkFields<Diff<${options.type === 'page' ? 'PageProps' : 'LayoutProps'}, FirstArg<MaybeField<TEntry, 'generateMetadata'>>, 'generateMetadata'>>()\n  checkFields<Diff<ResolvingMetadata, SecondArg<MaybeField<TEntry, 'generateMetadata'>>, 'generateMetadata'>>()\n}\n\n// Check the arguments and return type of the generateViewport function\nif ('generateViewport' in entry) {\n  checkFields<Diff<${options.type === 'page' ? 'PageProps' : 'LayoutProps'}, FirstArg<MaybeField<TEntry, 'generateViewport'>>, 'generateViewport'>>()\n  checkFields<Diff<ResolvingViewport, SecondArg<MaybeField<TEntry, 'generateViewport'>>, 'generateViewport'>>()\n}\n`}\n// Check the arguments and return type of the generateStaticParams function\nif ('generateStaticParams' in entry) {\n  checkFields<Diff<{ params: SegmentParams }, FirstArg<MaybeField<TEntry, 'generateStaticParams'>>, 'generateStaticParams'>>()\n  checkFields<Diff<{ __tag__: 'generateStaticParams', __return_type__: any[] | Promise<any[]> }, { __tag__: 'generateStaticParams', __return_type__: ReturnType<MaybeField<TEntry, 'generateStaticParams'>> }>>()\n}\n\nexport interface PageProps {\n  params?: Promise<SegmentParams>\n  searchParams?: Promise<any>\n}\nexport interface LayoutProps {\n  children?: React.ReactNode\n${options.slots ? options.slots.map((slot)=>`  ${slot}: React.ReactNode`).join('\\n') : ''}\n  params?: Promise<SegmentParams>\n}\n\n// =============\n// Utility types\ntype RevalidateRange<T> = T extends { revalidate: any } ? NonNegative<T['revalidate']> : never\n\n// If T is unknown or any, it will be an empty {} type. Otherwise, it will be the same as Omit<T, keyof Base>.\ntype OmitWithTag<T, K extends keyof any, _M> = Omit<T, K>\ntype Diff<Base, T extends Base, Message extends string = ''> = 0 extends (1 & T) ? {} : OmitWithTag<T, keyof Base, Message>\n\ntype FirstArg<T extends Function> = T extends (...args: [infer T, any]) => any ? unknown extends T ? any : T : never\ntype SecondArg<T extends Function> = T extends (...args: [any, infer T]) => any ? unknown extends T ? any : T : never\ntype MaybeField<T, K extends string> = T extends { [k in K]: infer G } ? G extends Function ? G : never : never\n\n${options.type === 'route' ? `type ParamCheck<T> = {\n  __tag__: string\n  __param_position__: string\n  __param_type__: T\n}` : ''}\n\nfunction checkFields<_ extends { [k in keyof any]: never }>() {}\n\n// https://github.com/sindresorhus/type-fest\ntype Numeric = number | bigint\ntype Zero = 0 | 0n\ntype Negative<T extends Numeric> = T extends Zero ? never : \\`\\${T}\\` extends \\`-\\${string}\\` ? T : never\ntype NonNegative<T extends Numeric> = T extends Zero ? T : Negative<T> extends never ? T : '__invalid_negative_number__'\n`;\n}\nasync function collectNamedSlots(layoutPath) {\n    const layoutDir = _path.default.dirname(layoutPath);\n    const items = await _promises.default.readdir(layoutDir, {\n        withFileTypes: true\n    });\n    const slots = [];\n    for (const item of items){\n        if (item.isDirectory() && item.name.startsWith('@') && // `@children slots are matched to the children prop, and should not be handled separately for type-checking\n        item.name !== '@children') {\n            slots.push(item.name.slice(1));\n        }\n    }\n    return slots;\n}\n// By exposing the static route types separately as string literals,\n// editors can provide autocompletion for them. However it's currently not\n// possible to provide the same experience for dynamic routes.\nconst pluginState = (0, _buildcontext.getProxiedPluginState)({\n    collectedRootParams: {},\n    routeTypes: {\n        edge: {\n            static: '',\n            dynamic: ''\n        },\n        node: {\n            static: '',\n            dynamic: ''\n        },\n        extra: {\n            static: '',\n            dynamic: ''\n        }\n    }\n});\nfunction formatRouteToRouteType(route) {\n    const isDynamic = (0, _utils.isDynamicRoute)(route);\n    if (isDynamic) {\n        route = route.split('/').map((part)=>{\n            if (part.startsWith('[') && part.endsWith(']')) {\n                if (part.startsWith('[...')) {\n                    // /[...slug]\n                    return `\\${CatchAllSlug<T>}`;\n                } else if (part.startsWith('[[...') && part.endsWith(']]')) {\n                    // /[[...slug]]\n                    return `\\${OptionalCatchAllSlug<T>}`;\n                }\n                // /[slug]\n                return `\\${SafeSlug<T>}`;\n            }\n            return part;\n        }).join('/');\n    }\n    return {\n        isDynamic,\n        routeType: `\\n    | \\`${route}\\``\n    };\n}\n// Whether redirects and rewrites have been converted into routeTypes or not.\nlet redirectsRewritesTypesProcessed = false;\n// Convert redirects and rewrites into routeTypes.\nfunction addRedirectsRewritesRouteTypes(rewrites, redirects) {\n    function addExtraRoute(source) {\n        let tokens;\n        try {\n            tokens = (0, _pathtoregexp.parse)(source);\n        } catch  {\n        // Ignore invalid routes - they will be handled by other checks.\n        }\n        if (Array.isArray(tokens)) {\n            const possibleNormalizedRoutes = [\n                ''\n            ];\n            let slugCnt = 1;\n            function append(suffix) {\n                for(let i = 0; i < possibleNormalizedRoutes.length; i++){\n                    possibleNormalizedRoutes[i] += suffix;\n                }\n            }\n            function fork(suffix) {\n                const currentLength = possibleNormalizedRoutes.length;\n                for(let i = 0; i < currentLength; i++){\n                    possibleNormalizedRoutes.push(possibleNormalizedRoutes[i] + suffix);\n                }\n            }\n            for (const token of tokens){\n                if (typeof token === 'object') {\n                    // Make sure the slug is always named.\n                    const slug = token.name || (slugCnt++ === 1 ? 'slug' : `slug${slugCnt}`);\n                    if (token.modifier === '*') {\n                        append(`${token.prefix}[[...${slug}]]`);\n                    } else if (token.modifier === '+') {\n                        append(`${token.prefix}[...${slug}]`);\n                    } else if (token.modifier === '') {\n                        if (token.pattern === '[^\\\\/#\\\\?]+?') {\n                            // A safe slug\n                            append(`${token.prefix}[${slug}]`);\n                        } else if (token.pattern === '.*') {\n                            // An optional catch-all slug\n                            append(`${token.prefix}[[...${slug}]]`);\n                        } else if (token.pattern === '.+') {\n                            // A catch-all slug\n                            append(`${token.prefix}[...${slug}]`);\n                        } else {\n                            // Other regex patterns are not supported. Skip this route.\n                            return;\n                        }\n                    } else if (token.modifier === '?') {\n                        if (/^[a-zA-Z0-9_/]*$/.test(token.pattern)) {\n                            // An optional slug with plain text only, fork the route.\n                            append(token.prefix);\n                            fork(token.pattern);\n                        } else {\n                            // Optional modifier `?` and regex patterns are not supported.\n                            return;\n                        }\n                    }\n                } else if (typeof token === 'string') {\n                    append(token);\n                }\n            }\n            for (const normalizedRoute of possibleNormalizedRoutes){\n                const { isDynamic, routeType } = formatRouteToRouteType(normalizedRoute);\n                pluginState.routeTypes.extra[isDynamic ? 'dynamic' : 'static'] += routeType;\n            }\n        }\n    }\n    if (rewrites) {\n        for (const rewrite of rewrites.beforeFiles){\n            addExtraRoute(rewrite.source);\n        }\n        for (const rewrite of rewrites.afterFiles){\n            addExtraRoute(rewrite.source);\n        }\n        for (const rewrite of rewrites.fallback){\n            addExtraRoute(rewrite.source);\n        }\n    }\n    if (redirects) {\n        for (const redirect of redirects){\n            // Skip internal redirects\n            // https://github.com/vercel/next.js/blob/8ff3d7ff57836c24088474175d595b4d50b3f857/packages/next/src/lib/load-custom-routes.ts#L704-L710\n            if (!('internal' in redirect)) {\n                addExtraRoute(redirect.source);\n            }\n        }\n    }\n}\nfunction createRouteDefinitions() {\n    let staticRouteTypes = '';\n    let dynamicRouteTypes = '';\n    for (const type of [\n        'edge',\n        'node',\n        'extra'\n    ]){\n        staticRouteTypes += pluginState.routeTypes[type].static;\n        dynamicRouteTypes += pluginState.routeTypes[type].dynamic;\n    }\n    // If both StaticRoutes and DynamicRoutes are empty, fallback to type 'string & {}'.\n    const routeTypesFallback = !staticRouteTypes && !dynamicRouteTypes ? 'string & {}' : '';\n    return `// Type definitions for Next.js routes\n\n/**\n * Internal types used by the Next.js router and Link component.\n * These types are not meant to be used directly.\n * @internal\n */\ndeclare namespace __next_route_internal_types__ {\n  type SearchOrHash = \\`?\\${string}\\` | \\`#\\${string}\\`\n  type WithProtocol = \\`\\${string}:\\${string}\\`\n\n  type Suffix = '' | SearchOrHash\n\n  type SafeSlug<S extends string> = S extends \\`\\${string}/\\${string}\\`\n    ? never\n    : S extends \\`\\${string}\\${SearchOrHash}\\`\n    ? never\n    : S extends ''\n    ? never\n    : S\n\n  type CatchAllSlug<S extends string> = S extends \\`\\${string}\\${SearchOrHash}\\`\n    ? never\n    : S extends ''\n    ? never\n    : S\n\n  type OptionalCatchAllSlug<S extends string> =\n    S extends \\`\\${string}\\${SearchOrHash}\\` ? never : S\n\n  type StaticRoutes = ${staticRouteTypes || 'never'}\n  type DynamicRoutes<T extends string = string> = ${dynamicRouteTypes || 'never'}\n\n  type RouteImpl<T> = ${routeTypesFallback || `\n    ${// This keeps autocompletion working for static routes.\n    '| StaticRoutes'}\n    | SearchOrHash\n    | WithProtocol\n    | \\`\\${StaticRoutes}\\${SearchOrHash}\\`\n    | (T extends \\`\\${DynamicRoutes<infer _>}\\${Suffix}\\` ? T : never)\n    `}\n}\n\ndeclare module 'next' {\n  export { default } from 'next/types.js'\n  export * from 'next/types.js'\n\n  export type Route<T extends string = string> =\n    __next_route_internal_types__.RouteImpl<T>\n}\n\ndeclare module 'next/link' {\n  import type { LinkProps as OriginalLinkProps } from 'next/dist/client/link.js'\n  import type { AnchorHTMLAttributes, DetailedHTMLProps } from 'react'\n  import type { UrlObject } from 'url'\n\n  type LinkRestProps = Omit<\n    Omit<\n      DetailedHTMLProps<\n        AnchorHTMLAttributes<HTMLAnchorElement>,\n        HTMLAnchorElement\n      >,\n      keyof OriginalLinkProps\n    > &\n      OriginalLinkProps,\n    'href'\n  >\n\n  export type LinkProps<RouteInferType> = LinkRestProps & {\n    /**\n     * The path or URL to navigate to. This is the only required prop. It can also be an object.\n     * @see https://nextjs.org/docs/api-reference/next/link\n     */\n    href: __next_route_internal_types__.RouteImpl<RouteInferType> | UrlObject\n  }\n\n  export default function Link<RouteType>(props: LinkProps<RouteType>): JSX.Element\n}\n\ndeclare module 'next/navigation' {\n  export * from 'next/dist/client/components/navigation.js'\n\n  import type { NavigateOptions, AppRouterInstance as OriginalAppRouterInstance } from 'next/dist/shared/lib/app-router-context.shared-runtime.js'\n  interface AppRouterInstance extends OriginalAppRouterInstance {\n    /**\n     * Navigate to the provided href.\n     * Pushes a new history entry.\n     */\n    push<RouteType>(href: __next_route_internal_types__.RouteImpl<RouteType>, options?: NavigateOptions): void\n    /**\n     * Navigate to the provided href.\n     * Replaces the current history entry.\n     */\n    replace<RouteType>(href: __next_route_internal_types__.RouteImpl<RouteType>, options?: NavigateOptions): void\n    /**\n     * Prefetch the provided href.\n     */\n    prefetch<RouteType>(href: __next_route_internal_types__.RouteImpl<RouteType>): void\n  }\n\n  export function useRouter(): AppRouterInstance;\n}\n\ndeclare module 'next/form' {\n  import type { FormProps as OriginalFormProps } from 'next/dist/client/form.js'\n\n  type FormRestProps = Omit<OriginalFormProps, 'action'>\n\n  export type FormProps<RouteInferType> = {\n    /**\n     * \\`action\\` can be either a \\`string\\` or a function.\n     * - If \\`action\\` is a string, it will be interpreted as a path or URL to navigate to when the form is submitted.\n     *   The path will be prefetched when the form becomes visible.\n     * - If \\`action\\` is a function, it will be called when the form is submitted. See the [React docs](https://react.dev/reference/react-dom/components/form#props) for more.\n     */\n    action: __next_route_internal_types__.RouteImpl<RouteInferType> | ((formData: FormData) => void)\n  } & FormRestProps\n\n  export default function Form<RouteType>(props: FormProps<RouteType>): JSX.Element\n}\n`;\n}\nfunction formatTimespan(seconds) {\n    if (seconds > 0) {\n        if (seconds === 18748800) {\n            return '1 month';\n        }\n        if (seconds === 18144000) {\n            return '1 month';\n        }\n        if (seconds === 604800) {\n            return '1 week';\n        }\n        if (seconds === 86400) {\n            return '1 day';\n        }\n        if (seconds === 3600) {\n            return '1 hour';\n        }\n        if (seconds === 60) {\n            return '1 minute';\n        }\n        if (seconds % 18748800 === 0) {\n            return seconds / 18748800 + ' months';\n        }\n        if (seconds % 18144000 === 0) {\n            return seconds / 18144000 + ' months';\n        }\n        if (seconds % 604800 === 0) {\n            return seconds / 604800 + ' weeks';\n        }\n        if (seconds % 86400 === 0) {\n            return seconds / 86400 + ' days';\n        }\n        if (seconds % 3600 === 0) {\n            return seconds / 3600 + ' hours';\n        }\n        if (seconds % 60 === 0) {\n            return seconds / 60 + ' minutes';\n        }\n    }\n    return seconds + ' seconds';\n}\nfunction formatTimespanWithSeconds(seconds) {\n    if (seconds === undefined) {\n        return 'default';\n    }\n    if (seconds >= 0xfffffffe) {\n        return 'never';\n    }\n    const text = seconds + ' seconds';\n    const descriptive = formatTimespan(seconds);\n    if (descriptive === text) {\n        return text;\n    }\n    return text + ' (' + descriptive + ')';\n}\nfunction getRootParamsFromLayouts(layouts) {\n    // Sort layouts by depth (descending)\n    const sortedLayouts = Object.entries(layouts).sort((a, b)=>b[0].split('/').length - a[0].split('/').length);\n    if (!sortedLayouts.length) {\n        return [];\n    }\n    // we assume the shorted layout path is the root layout\n    let rootLayout = sortedLayouts[sortedLayouts.length - 1][0];\n    let rootParams = new Set();\n    let isMultipleRootLayouts = false;\n    for (const [layoutPath, params] of sortedLayouts){\n        const allSegmentsAreDynamic = layoutPath.split('/').slice(1, -1)// match dynamic params but not catch-all or optional catch-all\n        .every((segment)=>/^\\[[^[.\\]]+\\]$/.test(segment));\n        if (allSegmentsAreDynamic) {\n            if (isSubpath(rootLayout, layoutPath)) {\n                // Current path is a subpath of the root layout, update root\n                rootLayout = layoutPath;\n                rootParams = new Set(params);\n            } else {\n                // Found another potential root layout\n                isMultipleRootLayouts = true;\n                // Add any new params\n                for (const param of params){\n                    rootParams.add(param);\n                }\n            }\n        }\n    }\n    // Create result array\n    const result = Array.from(rootParams).map((param)=>({\n            param,\n            optional: isMultipleRootLayouts\n        }));\n    return result;\n}\nfunction isSubpath(parentLayoutPath, potentialChildLayoutPath) {\n    // we strip off the `layout` part of the path as those will always conflict with being a subpath\n    const parentSegments = parentLayoutPath.split('/').slice(1, -1);\n    const childSegments = potentialChildLayoutPath.split('/').slice(1, -1);\n    // child segments should be shorter or equal to parent segments to be a subpath\n    if (childSegments.length > parentSegments.length || !childSegments.length) return false;\n    // Verify all segment values are equal\n    return childSegments.every((childSegment, index)=>childSegment === parentSegments[index]);\n}\nfunction createServerDefinitions(rootParams) {\n    return `\n  declare module 'next/server' {\n\n    import type { AsyncLocalStorage as NodeAsyncLocalStorage } from 'async_hooks'\n    declare global {\n      var AsyncLocalStorage: typeof NodeAsyncLocalStorage\n    }\n    export { NextFetchEvent } from 'next/dist/server/web/spec-extension/fetch-event'\n    export { NextRequest } from 'next/dist/server/web/spec-extension/request'\n    export { NextResponse } from 'next/dist/server/web/spec-extension/response'\n    export { NextMiddleware, MiddlewareConfig } from 'next/dist/server/web/types'\n    export { userAgentFromString } from 'next/dist/server/web/spec-extension/user-agent'\n    export { userAgent } from 'next/dist/server/web/spec-extension/user-agent'\n    export { URLPattern } from 'next/dist/compiled/@edge-runtime/primitives/url'\n    export { ImageResponse } from 'next/dist/server/web/spec-extension/image-response'\n    export type { ImageResponseOptions } from 'next/dist/compiled/@vercel/og/types'\n    export { after } from 'next/dist/server/after'\n    export { connection } from 'next/dist/server/request/connection'\n    export type { UnsafeUnwrappedSearchParams } from 'next/dist/server/request/search-params'\n    export type { UnsafeUnwrappedParams } from 'next/dist/server/request/params'\n    export function unstable_rootParams(): Promise<{ ${rootParams.map(({ param, optional })=>// ensure params with dashes are valid keys\n        `${param.includes('-') ? `'${param}'` : param}${optional ? '?' : ''}: string`).join(', ')} }>\n  }\n  `;\n}\nfunction createCustomCacheLifeDefinitions(cacheLife) {\n    let overloads = '';\n    const profileNames = Object.keys(cacheLife);\n    for(let i = 0; i < profileNames.length; i++){\n        const profileName = profileNames[i];\n        const profile = cacheLife[profileName];\n        if (typeof profile !== 'object' || profile === null) {\n            continue;\n        }\n        let description = '';\n        if (profile.stale === undefined) {\n            description += `\n     * This cache may be stale on clients for the default stale time of the scope before checking with the server.`;\n        } else if (profile.stale >= 0xfffffffe) {\n            description += `\n     * This cache may be stale on clients indefinitely before checking with the server.`;\n        } else {\n            description += `\n     * This cache may be stale on clients for ${formatTimespan(profile.stale)} before checking with the server.`;\n        }\n        if (profile.revalidate !== undefined && profile.expire !== undefined && profile.revalidate >= profile.expire) {\n            description += `\n     * This cache will expire after ${formatTimespan(profile.expire)}. The next request will recompute it.`;\n        } else {\n            if (profile.revalidate === undefined) {\n                description += `\n     * It will inherit the default revalidate time of its scope since it does not define its own.`;\n            } else if (profile.revalidate >= 0xfffffffe) {\n            // Nothing to mention.\n            } else {\n                description += `\n     * If the server receives a new request after ${formatTimespan(profile.revalidate)}, start revalidating new values in the background.`;\n            }\n            if (profile.expire === undefined) {\n                description += `\n     * It will inherit the default expiration time of its scope since it does not define its own.`;\n            } else if (profile.expire >= 0xfffffffe) {\n                description += `\n     * It lives for the maximum age of the server cache. If this entry has no traffic for a while, it may serve an old value the next request.`;\n            } else {\n                description += `\n     * If this entry has no traffic for ${formatTimespan(profile.expire)} it will expire. The next request will recompute it.`;\n            }\n        }\n        overloads += `\n    /**\n     * Cache this \\`\"use cache\"\\` for a timespan defined by the \\`${JSON.stringify(profileName)}\\` profile.\n     * \\`\\`\\`\n     *   stale:      ${formatTimespanWithSeconds(profile.stale)}\n     *   revalidate: ${formatTimespanWithSeconds(profile.revalidate)}\n     *   expire:     ${formatTimespanWithSeconds(profile.expire)}\n     * \\`\\`\\`\n     * ${description}\n     */\n    export function unstable_cacheLife(profile: ${JSON.stringify(profileName)}): void\n    `;\n    }\n    overloads += `\n    /**\n     * Cache this \\`\"use cache\"\\` using a custom timespan.\n     * \\`\\`\\`\n     *   stale: ... // seconds\n     *   revalidate: ... // seconds\n     *   expire: ... // seconds\n     * \\`\\`\\`\n     *\n     * This is similar to Cache-Control: max-age=\\`stale\\`,s-max-age=\\`revalidate\\`,stale-while-revalidate=\\`expire-revalidate\\`\n     *\n     * If a value is left out, the lowest of other cacheLife() calls or the default, is used instead.\n     */\n    export function unstable_cacheLife(profile: {\n      /**\n       * This cache may be stale on clients for ... seconds before checking with the server.\n       */\n      stale?: number,\n      /**\n       * If the server receives a new request after ... seconds, start revalidating new values in the background.\n       */\n      revalidate?: number,\n      /**\n       * If this entry has no traffic for ... seconds it will expire. The next request will recompute it.\n       */\n      expire?: number\n    }): void\n  `;\n    // Redefine the cacheLife() accepted arguments.\n    return `// Type definitions for Next.js cacheLife configs\n\ndeclare module 'next/cache' {\n  export { unstable_cache } from 'next/dist/server/web/spec-extension/unstable-cache'\n  export {\n    revalidateTag,\n    revalidatePath,\n    unstable_expireTag,\n    unstable_expirePath,\n  } from 'next/dist/server/web/spec-extension/revalidate'\n  export { unstable_noStore } from 'next/dist/server/web/spec-extension/unstable-no-store'\n\n  ${overloads}\n\n  export { cacheTag as unstable_cacheTag } from 'next/dist/server/use-cache/cache-tag'\n}\n`;\n}\nconst appTypesBasePath = _path.default.join('types', 'app');\nclass NextTypesPlugin {\n    constructor(options){\n        this.dir = options.dir;\n        this.distDir = options.distDir;\n        this.appDir = options.appDir;\n        this.dev = options.dev;\n        this.isEdgeServer = options.isEdgeServer;\n        this.pageExtensions = options.pageExtensions;\n        this.pagesDir = _path.default.join(this.appDir, '..', 'pages');\n        this.typedRoutes = options.typedRoutes;\n        this.cacheLifeConfig = options.cacheLifeConfig;\n        this.distDirAbsolutePath = _path.default.join(this.dir, this.distDir);\n        if (this.typedRoutes && !redirectsRewritesTypesProcessed) {\n            redirectsRewritesTypesProcessed = true;\n            addRedirectsRewritesRouteTypes(options.originalRewrites, options.originalRedirects);\n        }\n    }\n    getRelativePathFromAppTypesDir(moduleRelativePathToAppDir) {\n        const moduleAbsolutePath = _path.default.join(this.appDir, moduleRelativePathToAppDir);\n        const moduleInAppTypesAbsolutePath = _path.default.join(this.distDirAbsolutePath, appTypesBasePath, moduleRelativePathToAppDir);\n        return _path.default.relative(moduleInAppTypesAbsolutePath + '/..', moduleAbsolutePath);\n    }\n    collectPage(filePath) {\n        if (!this.typedRoutes) return;\n        const isApp = filePath.startsWith(this.appDir + _path.default.sep);\n        const isPages = !isApp && filePath.startsWith(this.pagesDir + _path.default.sep);\n        if (!isApp && !isPages) {\n            return;\n        }\n        // Filter out non-page and non-route files in app dir\n        if (isApp && !/[/\\\\](?:page|route)\\.[^.]+$/.test(filePath)) {\n            return;\n        }\n        // Filter out non-page files in pages dir\n        if (isPages && /[/\\\\](?:_app|_document|_error|404|500)\\.[^.]+$/.test(filePath)) {\n            return;\n        }\n        let route = (isApp ? _apppaths.normalizeAppPath : _denormalizepagepath.denormalizePagePath)((0, _ensureleadingslash.ensureLeadingSlash)((0, _entries.getPageFromPath)(_path.default.relative(isApp ? this.appDir : this.pagesDir, filePath), this.pageExtensions)));\n        const { isDynamic, routeType } = formatRouteToRouteType(route);\n        pluginState.routeTypes[this.isEdgeServer ? 'edge' : 'node'][isDynamic ? 'dynamic' : 'static'] += routeType;\n    }\n    apply(compiler) {\n        // From asset root to dist root\n        const assetDirRelative = this.dev ? '..' : this.isEdgeServer ? '..' : '../..';\n        const handleModule = async (mod, compilation)=>{\n            if (!mod.resource) return;\n            const pageExtensionsRegex = new RegExp(`\\\\.(${this.pageExtensions.join('|')})$`);\n            if (!pageExtensionsRegex.test(mod.resource)) return;\n            if (!mod.resource.startsWith(this.appDir + _path.default.sep)) {\n                if (!this.dev) {\n                    if (mod.resource.startsWith(this.pagesDir + _path.default.sep)) {\n                        this.collectPage(mod.resource);\n                    }\n                }\n                return;\n            }\n            if (mod.layer !== _constants.WEBPACK_LAYERS.reactServerComponents) return;\n            // skip for /app/_private dir convention\n            // matches <app-dir>/**/_*\n            const IS_PRIVATE = /(?:\\/[^/]+)*\\/_.*$/.test(mod.resource.replace(this.appDir, ''));\n            if (IS_PRIVATE) return;\n            const IS_LAYOUT = /[/\\\\]layout\\.[^./\\\\]+$/.test(mod.resource);\n            const IS_PAGE = !IS_LAYOUT && /[/\\\\]page\\.[^.]+$/.test(mod.resource);\n            const IS_ROUTE = !IS_PAGE && /[/\\\\]route\\.[^.]+$/.test(mod.resource);\n            const IS_IMPORTABLE = /\\.(js|jsx|ts|tsx|mjs|cjs)$/.test(mod.resource);\n            const relativePathToApp = _path.default.relative(this.appDir, mod.resource);\n            if (!this.dev) {\n                if (IS_PAGE || IS_ROUTE) {\n                    this.collectPage(mod.resource);\n                }\n            }\n            const typePath = _path.default.join(appTypesBasePath, relativePathToApp.replace(pageExtensionsRegex, '.ts'));\n            const relativeImportPath = (0, _normalizepathsep.normalizePathSep)(_path.default.join(this.getRelativePathFromAppTypesDir(relativePathToApp)).replace(pageExtensionsRegex, ''));\n            const assetPath = _path.default.join(assetDirRelative, typePath);\n            // Typescript won’t allow relative-importing (for example) a .mdx file using the .js extension\n            // so for now we only generate “type guard files” for files that typescript can transform\n            if (!IS_IMPORTABLE) return;\n            if (IS_LAYOUT) {\n                const rootLayoutPath = (0, _apppaths.normalizeAppPath)((0, _ensureleadingslash.ensureLeadingSlash)((0, _entries.getPageFromPath)(_path.default.relative(this.appDir, mod.resource), this.pageExtensions)));\n                const foundParams = Array.from(rootLayoutPath.matchAll(/\\[(.*?)\\]/g), (match)=>match[1]);\n                pluginState.collectedRootParams[rootLayoutPath] = foundParams;\n                const slots = await collectNamedSlots(mod.resource);\n                compilation.emitAsset(assetPath, new _webpack.sources.RawSource(createTypeGuardFile(mod.resource, relativeImportPath, {\n                    type: 'layout',\n                    slots\n                })));\n            } else if (IS_PAGE) {\n                compilation.emitAsset(assetPath, new _webpack.sources.RawSource(createTypeGuardFile(mod.resource, relativeImportPath, {\n                    type: 'page'\n                })));\n            } else if (IS_ROUTE) {\n                compilation.emitAsset(assetPath, new _webpack.sources.RawSource(createTypeGuardFile(mod.resource, relativeImportPath, {\n                    type: 'route'\n                })));\n            }\n        };\n        compiler.hooks.compilation.tap(PLUGIN_NAME, (compilation)=>{\n            compilation.hooks.processAssets.tapAsync({\n                name: PLUGIN_NAME,\n                stage: _webpack.webpack.Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE_HASH\n            }, async (_, callback)=>{\n                const promises = [];\n                // Clear routes\n                if (this.isEdgeServer) {\n                    pluginState.routeTypes.edge.dynamic = '';\n                    pluginState.routeTypes.edge.static = '';\n                } else {\n                    pluginState.routeTypes.node.dynamic = '';\n                    pluginState.routeTypes.node.static = '';\n                }\n                compilation.chunkGroups.forEach((chunkGroup)=>{\n                    chunkGroup.chunks.forEach((chunk)=>{\n                        if (!chunk.name) return;\n                        // Here we only track page and route chunks.\n                        if (!chunk.name.startsWith('pages/') && !(chunk.name.startsWith('app/') && (chunk.name.endsWith('/page') || chunk.name.endsWith('/route')))) {\n                            return;\n                        }\n                        const chunkModules = compilation.chunkGraph.getChunkModulesIterable(chunk);\n                        for (const mod of chunkModules){\n                            promises.push(handleModule(mod, compilation));\n                            // If this is a concatenation, register each child to the parent ID.\n                            const anyModule = mod;\n                            if (anyModule.modules) {\n                                anyModule.modules.forEach((concatenatedMod)=>{\n                                    promises.push(handleModule(concatenatedMod, compilation));\n                                });\n                            }\n                        }\n                    });\n                });\n                await Promise.all(promises);\n                const rootParams = getRootParamsFromLayouts(pluginState.collectedRootParams);\n                // If we discovered rootParams, we'll override the `next/server` types\n                // since we're able to determine the root params at build time.\n                if (rootParams.length > 0) {\n                    const serverTypesPath = _path.default.join(assetDirRelative, 'types/server.d.ts');\n                    compilation.emitAsset(serverTypesPath, new _webpack.sources.RawSource(createServerDefinitions(rootParams)));\n                }\n                // Support `\"moduleResolution\": \"Node16\" | \"NodeNext\"` with `\"type\": \"module\"`\n                const packageJsonAssetPath = _path.default.join(assetDirRelative, 'types/package.json');\n                compilation.emitAsset(packageJsonAssetPath, new _webpack.sources.RawSource('{\"type\": \"module\"}'));\n                if (this.typedRoutes) {\n                    if (this.dev && !this.isEdgeServer) {\n                        _shared.devPageFiles.forEach((file)=>{\n                            this.collectPage(file);\n                        });\n                    }\n                    const linkAssetPath = _path.default.join(assetDirRelative, 'types/link.d.ts');\n                    compilation.emitAsset(linkAssetPath, new _webpack.sources.RawSource(createRouteDefinitions()));\n                }\n                if (this.cacheLifeConfig) {\n                    const cacheLifeAssetPath = _path.default.join(assetDirRelative, 'types/cache-life.d.ts');\n                    compilation.emitAsset(cacheLifeAssetPath, new _webpack.sources.RawSource(createCustomCacheLifeDefinitions(this.cacheLifeConfig)));\n                }\n                callback();\n            });\n        });\n    }\n}\n\n//# sourceMappingURL=index.js.map"
        }
    ]
}