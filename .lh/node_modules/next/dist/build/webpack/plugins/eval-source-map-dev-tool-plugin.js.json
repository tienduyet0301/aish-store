{
    "sourceFile": "node_modules/next/dist/build/webpack/plugins/eval-source-map-dev-tool-plugin.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892671021,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n\n  Forked to add support for `ignoreList`.\n  Keep in sync with packages/next/webpack-plugins/eval-source-map-dev-tool-plugin.js\n*/ \"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, // Fork of webpack's EvalSourceMapDevToolPlugin with support for adding `ignoreList`.\n// https://github.com/webpack/webpack/blob/e237b580e2bda705c5ab39973f786f7c5a7026bc/lib/EvalSourceMapDevToolPlugin.js#L37\n\"default\", {\n    enumerable: true,\n    get: function() {\n        return EvalSourceMapDevToolPlugin;\n    }\n});\nconst _webpack = require(\"next/dist/compiled/webpack/webpack\");\nconst cache = new WeakMap();\nconst devtoolWarningMessage = `/*\n * ATTENTION: An \"eval-source-map\" devtool has been used.\n * This devtool is neither made for production nor for readable output files.\n * It uses \"eval()\" calls to create a separate source file with attached SourceMaps in the browser devtools.\n * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)\n * or disable the default devtool with \"devtool: false\".\n * If you are looking for production-ready output files, see mode: \"production\" (https://webpack.js.org/configuration/mode/).\n */\n`;\nclass EvalSourceMapDevToolPlugin {\n    /**\n   * @param {SourceMapDevToolPluginOptions|string} inputOptions Options object\n   */ constructor(inputOptions){\n        let options;\n        if (typeof inputOptions === 'string') {\n            options = {\n                append: inputOptions\n            };\n        } else {\n            options = inputOptions;\n        }\n        this.sourceMapComment = options.append && typeof options.append !== 'function' ? options.append : '//# sourceURL=[module]\\n//# sourceMappingURL=[url]';\n        this.moduleFilenameTemplate = options.moduleFilenameTemplate || 'webpack://[namespace]/[resource-path]?[hash]';\n        this.namespace = options.namespace || '';\n        this.options = options;\n        // fork\n        this.shouldIgnorePath = options.shouldIgnorePath ?? (()=>false);\n    }\n    /**\n   * Apply the plugin\n   * @param compiler the compiler instance\n   */ apply(compiler) {\n        const options = this.options;\n        compiler.hooks.compilation.tap('NextJSEvalSourceMapDevToolPlugin', (compilation)=>{\n            const { JavascriptModulesPlugin } = compiler.webpack.javascript;\n            const { RawSource, ConcatSource } = compiler.webpack.sources;\n            const devtoolWarning = new RawSource(devtoolWarningMessage);\n            const hooks = JavascriptModulesPlugin.getCompilationHooks(compilation);\n            new _webpack.SourceMapDevToolModuleOptionsPlugin(options).apply(compilation);\n            const matchModule = _webpack.ModuleFilenameHelpers.matchObject.bind(_webpack.ModuleFilenameHelpers, options);\n            hooks.renderModuleContent.tap('NextJSEvalSourceMapDevToolPlugin', (source, m, { chunk, runtimeTemplate, chunkGraph })=>{\n                const cachedSource = cache.get(source);\n                if (cachedSource !== undefined) {\n                    return cachedSource;\n                }\n                const result = (r)=>{\n                    cache.set(source, r);\n                    return r;\n                };\n                if (m instanceof _webpack.NormalModule) {\n                    const module = m;\n                    if (!matchModule(module.resource)) {\n                        return result(source);\n                    }\n                } else if (m instanceof _webpack.ConcatenatedModule) {\n                    const concatModule = m;\n                    if (concatModule.rootModule instanceof _webpack.NormalModule) {\n                        const module = concatModule.rootModule;\n                        if (!matchModule(module.resource)) {\n                            return result(source);\n                        }\n                    } else {\n                        return result(source);\n                    }\n                } else {\n                    return result(source);\n                }\n                const namespace = compilation.getPath(this.namespace, {\n                    chunk\n                });\n                let sourceMap;\n                let content;\n                if (source.sourceAndMap) {\n                    const sourceAndMap = source.sourceAndMap(options);\n                    sourceMap = sourceAndMap.map;\n                    content = sourceAndMap.source;\n                } else {\n                    sourceMap = source.map(options);\n                    content = source.source();\n                }\n                if (!sourceMap) {\n                    return result(source);\n                }\n                // Clone (flat) the sourcemap to ensure that the mutations below do not persist.\n                sourceMap = {\n                    ...sourceMap\n                };\n                const context = compiler.options.context;\n                const root = compiler.root;\n                const modules = sourceMap.sources.map((sourceMapSource)=>{\n                    if (!sourceMapSource.startsWith('webpack://')) return sourceMapSource;\n                    sourceMapSource = (0, _webpack.makePathsAbsolute)(context, sourceMapSource.slice(10), root);\n                    const module = compilation.findModule(sourceMapSource);\n                    return module || sourceMapSource;\n                });\n                let moduleFilenames = modules.map((module)=>_webpack.ModuleFilenameHelpers.createFilename(module, {\n                        moduleFilenameTemplate: this.moduleFilenameTemplate,\n                        namespace\n                    }, {\n                        requestShortener: runtimeTemplate.requestShortener,\n                        chunkGraph,\n                        hashFunction: compilation.outputOptions.hashFunction\n                    }));\n                moduleFilenames = _webpack.ModuleFilenameHelpers.replaceDuplicates(moduleFilenames, (filename, _i, n)=>{\n                    for(let j = 0; j < n; j++)filename += '*';\n                    return filename;\n                });\n                sourceMap.sources = moduleFilenames;\n                sourceMap.ignoreList = [];\n                for(let index = 0; index < moduleFilenames.length; index++){\n                    if (this.shouldIgnorePath(moduleFilenames[index])) {\n                        sourceMap.ignoreList.push(index);\n                    }\n                }\n                if (options.noSources) {\n                    sourceMap.sourcesContent = undefined;\n                }\n                sourceMap.sourceRoot = options.sourceRoot || '';\n                const moduleId = /** @type {ModuleId} */ chunkGraph.getModuleId(m);\n                if (moduleId) {\n                    sourceMap.file = typeof moduleId === 'number' ? `${moduleId}.js` : moduleId;\n                }\n                const footer = `${this.sourceMapComment.replace(/\\[url\\]/g, `data:application/json;charset=utf-8;base64,${Buffer.from(JSON.stringify(sourceMap), 'utf8').toString('base64')}`)}\\n//# sourceURL=webpack-internal:///${moduleId}\\n` // workaround for chrome bug\n                ;\n                return result(new RawSource(`eval(${compilation.outputOptions.trustedTypes ? `${_webpack.RuntimeGlobals.createScript}(${JSON.stringify(content + footer)})` : JSON.stringify(content + footer)});`));\n            });\n            hooks.inlineInRuntimeBailout.tap('EvalDevToolModulePlugin', ()=>'the eval-source-map devtool is used.');\n            hooks.render.tap('EvalSourceMapDevToolPlugin', (source)=>new ConcatSource(devtoolWarning, source));\n            hooks.chunkHash.tap('EvalSourceMapDevToolPlugin', (_chunk, hash)=>{\n                hash.update('EvalSourceMapDevToolPlugin');\n                hash.update('2');\n            });\n            if (compilation.outputOptions.trustedTypes) {\n                compilation.hooks.additionalModuleRuntimeRequirements.tap('EvalSourceMapDevToolPlugin', (_module, set, _context)=>{\n                    set.add(_webpack.RuntimeGlobals.createScript);\n                });\n            }\n        });\n    }\n}\n\n//# sourceMappingURL=eval-source-map-dev-tool-plugin.js.map"
        }
    ]
}