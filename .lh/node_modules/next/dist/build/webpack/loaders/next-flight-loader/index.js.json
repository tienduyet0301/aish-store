{
    "sourceFile": "node_modules/next/dist/build/webpack/loaders/next-flight-loader/index.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892668286,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    default: null,\n    getAssumedSourceType: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    default: function() {\n        return transformSource;\n    },\n    getAssumedSourceType: function() {\n        return getAssumedSourceType;\n    }\n});\nconst _constants = require(\"../../../../lib/constants\");\nconst _constants1 = require(\"../../../../shared/lib/constants\");\nconst _warnonce = require(\"../../../../shared/lib/utils/warn-once\");\nconst _getpagestaticinfo = require(\"../../../analysis/get-page-static-info\");\nconst _utils = require(\"../../utils\");\nconst _getmodulebuildinfo = require(\"../get-module-build-info\");\nconst noopHeadPath = require.resolve('next/dist/client/components/noop-head');\n// For edge runtime it will be aliased to esm version by webpack\nconst MODULE_PROXY_PATH = 'next/dist/build/webpack/loaders/next-flight-loader/module-proxy';\nfunction getAssumedSourceType(mod, sourceType) {\n    var _buildInfo_rsc, _buildInfo_rsc1;\n    const buildInfo = (0, _getmodulebuildinfo.getModuleBuildInfo)(mod);\n    const detectedClientEntryType = buildInfo == null ? void 0 : (_buildInfo_rsc = buildInfo.rsc) == null ? void 0 : _buildInfo_rsc.clientEntryType;\n    const clientRefs = (buildInfo == null ? void 0 : (_buildInfo_rsc1 = buildInfo.rsc) == null ? void 0 : _buildInfo_rsc1.clientRefs) || [];\n    // It's tricky to detect the type of a client boundary, but we should always\n    // use the `module` type when we can, to support `export *` and `export from`\n    // syntax in other modules that import this client boundary.\n    if (sourceType === 'auto') {\n        if (detectedClientEntryType === 'auto') {\n            if (clientRefs.length === 0) {\n                // If there's zero export detected in the client boundary, and it's the\n                // `auto` type, we can safely assume it's a CJS module because it doesn't\n                // have ESM exports.\n                return 'commonjs';\n            } else if (!clientRefs.includes('*')) {\n                // Otherwise, we assume it's an ESM module.\n                return 'module';\n            }\n        } else if (detectedClientEntryType === 'cjs') {\n            return 'commonjs';\n        }\n    }\n    return sourceType;\n}\nfunction transformSource(source, sourceMap) {\n    var _module_matchResource, _buildInfo_rsc, _buildInfo_rsc1;\n    // Avoid buffer to be consumed\n    if (typeof source !== 'string') {\n        throw Object.defineProperty(new Error('Expected source to have been transformed to a string.'), \"__NEXT_ERROR_CODE\", {\n            value: \"E429\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    const module1 = this._module;\n    // Assign the RSC meta information to buildInfo.\n    // Exclude next internal files which are not marked as client files\n    const buildInfo = (0, _getmodulebuildinfo.getModuleBuildInfo)(module1);\n    buildInfo.rsc = (0, _getpagestaticinfo.getRSCModuleInformation)(source, true);\n    let prefix = '';\n    if (process.env.BUILTIN_FLIGHT_CLIENT_ENTRY_PLUGIN) {\n        const rscModuleInformationJson = JSON.stringify(buildInfo.rsc);\n        prefix = `/* __rspack_internal_rsc_module_information_do_not_use__ ${rscModuleInformationJson} */\\n`;\n        source = prefix + source;\n    }\n    // Resource key is the unique identifier for the resource. When RSC renders\n    // a client module, that key is used to identify that module across all compiler\n    // layers.\n    //\n    // Usually it's the module's file path + the export name (e.g. `foo.js#bar`).\n    // But with Barrel Optimizations, one file can be splitted into multiple modules,\n    // so when you import `foo.js#bar` and `foo.js#baz`, they are actually different\n    // \"foo.js\" being created by the Barrel Loader (one only exports `bar`, the other\n    // only exports `baz`).\n    //\n    // Because of that, we must add another query param to the resource key to\n    // differentiate them.\n    let resourceKey = this.resourcePath;\n    if ((_module_matchResource = module1.matchResource) == null ? void 0 : _module_matchResource.startsWith(_constants1.BARREL_OPTIMIZATION_PREFIX)) {\n        resourceKey = (0, _utils.formatBarrelOptimizedResource)(resourceKey, module1.matchResource);\n    }\n    // A client boundary.\n    if (((_buildInfo_rsc = buildInfo.rsc) == null ? void 0 : _buildInfo_rsc.type) === _constants1.RSC_MODULE_TYPES.client) {\n        const assumedSourceType = getAssumedSourceType(module1, sourceTypeFromModule(module1));\n        const clientRefs = buildInfo.rsc.clientRefs;\n        const stringifiedResourceKey = JSON.stringify(resourceKey);\n        if (assumedSourceType === 'module') {\n            if (clientRefs.length === 0) {\n                return this.callback(null, 'export {}');\n            }\n            if (clientRefs.includes('*')) {\n                this.callback(Object.defineProperty(new Error(`It's currently unsupported to use \"export *\" in a client boundary. Please use named exports instead.`), \"__NEXT_ERROR_CODE\", {\n                    value: \"E46\",\n                    enumerable: false,\n                    configurable: true\n                }));\n                return;\n            }\n            let esmSource = prefix + `\\\nimport { registerClientReference } from \"react-server-dom-webpack/server.edge\";\n`;\n            for (const ref of clientRefs){\n                if (ref === 'default') {\n                    esmSource += `export default registerClientReference(\nfunction() { throw new Error(${JSON.stringify(`Attempted to call the default \\\nexport of ${stringifiedResourceKey} from the server, but it's on the client. \\\nIt's not possible to invoke a client function from the server, it can only be \\\nrendered as a Component or passed to props of a Client Component.`)}); },\n${stringifiedResourceKey},\n\"default\",\n);\\n`;\n                } else {\n                    esmSource += `export const ${ref} = registerClientReference(\nfunction() { throw new Error(${JSON.stringify(`Attempted to call ${ref}() from \\\nthe server but ${ref} is on the client. It's not possible to invoke a client \\\nfunction from the server, it can only be rendered as a Component or passed to \\\nprops of a Client Component.`)}); },\n${stringifiedResourceKey},\n${JSON.stringify(ref)},\n);`;\n                }\n            }\n            return this.callback(null, esmSource, sourceMap);\n        } else if (assumedSourceType === 'commonjs') {\n            let cjsSource = prefix + `\\\nconst { createProxy } = require(\"${MODULE_PROXY_PATH}\")\n\nmodule.exports = createProxy(${stringifiedResourceKey})\n`;\n            return this.callback(null, cjsSource, sourceMap);\n        }\n    }\n    if (((_buildInfo_rsc1 = buildInfo.rsc) == null ? void 0 : _buildInfo_rsc1.type) !== _constants1.RSC_MODULE_TYPES.client) {\n        if (noopHeadPath === this.resourcePath) {\n            (0, _warnonce.warnOnce)(`Warning: You're using \\`next/head\\` inside the \\`app\\` directory, please migrate to the Metadata API. See https://nextjs.org/docs/app/building-your-application/upgrading/app-router-migration#step-3-migrating-nexthead for more details.`);\n        }\n    }\n    const replacedSource = source.replace(_constants.RSC_MOD_REF_PROXY_ALIAS, MODULE_PROXY_PATH);\n    this.callback(null, replacedSource, sourceMap);\n}\nfunction sourceTypeFromModule(module1) {\n    const moduleType = module1.type;\n    switch(moduleType){\n        case 'javascript/auto':\n            return 'auto';\n        case 'javascript/dynamic':\n            return 'script';\n        case 'javascript/esm':\n            return 'module';\n        default:\n            throw Object.defineProperty(new Error('Unexpected module type ' + moduleType), \"__NEXT_ERROR_CODE\", {\n                value: \"E651\",\n                enumerable: false,\n                configurable: true\n            });\n    }\n}\n\n//# sourceMappingURL=index.js.map"
        }
    ]
}