{
    "sourceFile": "node_modules/next/dist/build/webpack/loaders/next-app-loader/index.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892667004,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"default\", {\n    enumerable: true,\n    get: function() {\n        return _default;\n    }\n});\nconst _constants = require(\"../../../../shared/lib/constants\");\nconst _path = /*#__PURE__*/ _interop_require_default(require(\"path\"));\nconst _picocolors = require(\"../../../../lib/picocolors\");\nconst _getmodulebuildinfo = require(\"../get-module-build-info\");\nconst _verifyrootlayout = require(\"../../../../lib/verify-root-layout\");\nconst _log = /*#__PURE__*/ _interop_require_wildcard(require(\"../../../output/log\"));\nconst _constants1 = require(\"../../../../lib/constants\");\nconst _discover = require(\"../metadata/discover\");\nconst _fs = require(\"fs\");\nconst _isapprouteroute = require(\"../../../../lib/is-app-route-route\");\nconst _apppathnamenormalizer = require(\"../../../../server/normalizers/built/app/app-pathname-normalizer\");\nconst _utils = require(\"../../../utils\");\nconst _loadentrypoint = require(\"../../../load-entrypoint\");\nconst _segment = require(\"../../../../shared/lib/segment\");\nconst _getfilesindir = require(\"../../../../lib/get-files-in-dir\");\nconst _parallelroutedefault = require(\"../../../../client/components/parallel-route-default\");\nconst _createapproutecode = require(\"./create-app-route-code\");\nfunction _interop_require_default(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nfunction _getRequireWildcardCache(nodeInterop) {\n    if (typeof WeakMap !== \"function\") return null;\n    var cacheBabelInterop = new WeakMap();\n    var cacheNodeInterop = new WeakMap();\n    return (_getRequireWildcardCache = function(nodeInterop) {\n        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n    })(nodeInterop);\n}\nfunction _interop_require_wildcard(obj, nodeInterop) {\n    if (!nodeInterop && obj && obj.__esModule) {\n        return obj;\n    }\n    if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n        return {\n            default: obj\n        };\n    }\n    var cache = _getRequireWildcardCache(nodeInterop);\n    if (cache && cache.has(obj)) {\n        return cache.get(obj);\n    }\n    var newObj = {\n        __proto__: null\n    };\n    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n    for(var key in obj){\n        if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n            if (desc && (desc.get || desc.set)) {\n                Object.defineProperty(newObj, key, desc);\n            } else {\n                newObj[key] = obj[key];\n            }\n        }\n    }\n    newObj.default = obj;\n    if (cache) {\n        cache.set(obj, newObj);\n    }\n    return newObj;\n}\nconst HTTP_ACCESS_FALLBACKS = {\n    'not-found': 'not-found',\n    forbidden: 'forbidden',\n    unauthorized: 'unauthorized'\n};\nconst defaultHTTPAccessFallbackPaths = {\n    'not-found': 'next/dist/client/components/not-found-error',\n    forbidden: 'next/dist/client/components/forbidden-error',\n    unauthorized: 'next/dist/client/components/unauthorized-error'\n};\nconst FILE_TYPES = {\n    layout: 'layout',\n    template: 'template',\n    error: 'error',\n    loading: 'loading',\n    'global-error': 'global-error',\n    ...HTTP_ACCESS_FALLBACKS\n};\nconst GLOBAL_ERROR_FILE_TYPE = 'global-error';\nconst PAGE_SEGMENT = 'page$';\nconst PARALLEL_CHILDREN_SEGMENT = 'children$';\nconst defaultGlobalErrorPath = 'next/dist/client/components/error-boundary';\nconst defaultLayoutPath = 'next/dist/client/components/default-layout';\nconst normalizeParallelKey = (key)=>key.startsWith('@') ? key.slice(1) : key;\nconst isDirectory = async (pathname)=>{\n    try {\n        const stat = await _fs.promises.stat(pathname);\n        return stat.isDirectory();\n    } catch (err) {\n        return false;\n    }\n};\nasync function createTreeCodeFromPath(pagePath, { page, resolveDir, resolver, resolveParallelSegments, metadataResolver, pageExtensions, basePath, collectedDeclarations }) {\n    const splittedPath = pagePath.split(/[\\\\/]/, 1);\n    const isNotFoundRoute = page === _constants.UNDERSCORE_NOT_FOUND_ROUTE_ENTRY;\n    const isDefaultNotFound = (0, _utils.isAppBuiltinNotFoundPage)(pagePath);\n    const appDirPrefix = isDefaultNotFound ? _constants1.APP_DIR_ALIAS : splittedPath[0];\n    const pages = [];\n    let rootLayout;\n    let globalError;\n    async function resolveAdjacentParallelSegments(segmentPath) {\n        const absoluteSegmentPath = await resolveDir(`${appDirPrefix}${segmentPath}`);\n        if (!absoluteSegmentPath) {\n            return [];\n        }\n        const segmentIsDirectory = await isDirectory(absoluteSegmentPath);\n        if (!segmentIsDirectory) {\n            return [];\n        }\n        // We need to resolve all parallel routes in this level.\n        const files = await _fs.promises.opendir(absoluteSegmentPath);\n        const parallelSegments = [\n            'children'\n        ];\n        for await (const dirent of files){\n            // Make sure name starts with \"@\" and is a directory.\n            if (dirent.isDirectory() && dirent.name.charCodeAt(0) === 64) {\n                parallelSegments.push(dirent.name);\n            }\n        }\n        return parallelSegments;\n    }\n    async function createSubtreePropsFromSegmentPath(segments, nestedCollectedDeclarations) {\n        const segmentPath = segments.join('/');\n        // Existing tree are the children of the current segment\n        const props = {};\n        // Root layer could be 1st layer of normal routes\n        const isRootLayer = segments.length === 0;\n        const isRootLayoutOrRootPage = segments.length <= 1;\n        // We need to resolve all parallel routes in this level.\n        const parallelSegments = [];\n        if (isRootLayer) {\n            parallelSegments.push([\n                'children',\n                ''\n            ]);\n        } else {\n            parallelSegments.push(...resolveParallelSegments(segmentPath));\n        }\n        let metadata = null;\n        const routerDirPath = `${appDirPrefix}${segmentPath}`;\n        // For default not-found, don't traverse the directory to find metadata.\n        const resolvedRouteDir = isDefaultNotFound ? '' : await resolveDir(routerDirPath);\n        if (resolvedRouteDir) {\n            metadata = await (0, _discover.createStaticMetadataFromRoute)(resolvedRouteDir, {\n                basePath,\n                segment: segmentPath,\n                metadataResolver,\n                isRootLayoutOrRootPage,\n                pageExtensions\n            });\n        }\n        for (const [parallelKey, parallelSegment] of parallelSegments){\n            // if parallelSegment is the page segment (ie, `page$` and not ['page$']), it gets loaded into the __PAGE__ slot\n            // as it's the page for the current route.\n            if (parallelSegment === PAGE_SEGMENT) {\n                const matchedPagePath = `${appDirPrefix}${segmentPath}${parallelKey === 'children' ? '' : `/${parallelKey}`}/page`;\n                const resolvedPagePath = await resolver(matchedPagePath);\n                if (resolvedPagePath) {\n                    pages.push(resolvedPagePath);\n                    const varName = `page${nestedCollectedDeclarations.length}`;\n                    nestedCollectedDeclarations.push([\n                        varName,\n                        resolvedPagePath\n                    ]);\n                    // Use '' for segment as it's the page. There can't be a segment called '' so this is the safest way to add it.\n                    props[normalizeParallelKey(parallelKey)] = `['${_segment.PAGE_SEGMENT_KEY}', {}, {\n          page: [${varName}, ${JSON.stringify(resolvedPagePath)}],\n          ${(0, _discover.createMetadataExportsCode)(metadata)}\n        }]`;\n                    continue;\n                }\n            }\n            // if the parallelSegment was not matched to the __PAGE__ slot, then it's a parallel route at this level.\n            // the code below recursively traverses the parallel slots directory to match the corresponding __PAGE__ for each parallel slot\n            // while also filling in layout/default/etc files into the loader tree at each segment level.\n            const subSegmentPath = [\n                ...segments\n            ];\n            if (parallelKey !== 'children') {\n                // A `children` parallel key should have already been processed in the above segment\n                // So we exclude it when constructing the subsegment path for the remaining segment levels\n                subSegmentPath.push(parallelKey);\n            }\n            const normalizedParallelSegment = Array.isArray(parallelSegment) ? parallelSegment[0] : parallelSegment;\n            if (normalizedParallelSegment !== PAGE_SEGMENT && normalizedParallelSegment !== PARALLEL_CHILDREN_SEGMENT) {\n                // If we don't have a page segment, nor a special $children marker, it means we need to traverse the next directory\n                // (ie, `normalizedParallelSegment` would correspond with the folder that contains the next level of pages/layout/etc)\n                // we push it to the subSegmentPath so that we can fill in the loader tree for that segment.\n                subSegmentPath.push(normalizedParallelSegment);\n            }\n            const parallelSegmentPath = subSegmentPath.join('/');\n            // Fill in the loader tree for all of the special files types (layout, default, etc) at this level\n            // `page` is not included here as it's added above.\n            const filePaths = await Promise.all(Object.values(FILE_TYPES).map(async (file)=>{\n                return [\n                    file,\n                    await resolver(`${appDirPrefix}${// TODO-APP: parallelSegmentPath sometimes ends in `/` but sometimes it doesn't. This should be consistent.\n                    parallelSegmentPath.endsWith('/') ? parallelSegmentPath : parallelSegmentPath + '/'}${file}`)\n                ];\n            }));\n            const definedFilePaths = filePaths.filter(([, filePath])=>filePath !== undefined);\n            // Add default access fallback as root fallback if not present\n            const existedConventionNames = new Set(definedFilePaths.map(([type])=>type));\n            // If the first layer is a group route, we treat it as root layer\n            const isFirstLayerGroupRoute = segments.length === 1 && subSegmentPath.filter((seg)=>(0, _segment.isGroupSegment)(seg)).length === 1;\n            if (isRootLayer || isFirstLayerGroupRoute) {\n                const accessFallbackTypes = Object.keys(defaultHTTPAccessFallbackPaths);\n                for (const type of accessFallbackTypes){\n                    const hasRootFallbackFile = await resolver(`${appDirPrefix}/${FILE_TYPES[type]}`);\n                    const hasLayerFallbackFile = existedConventionNames.has(type);\n                    // If you already have a root access error fallback, don't insert default access error boundary to group routes root\n                    if (// Is treated as root layout and without boundary\n                    !(hasRootFallbackFile && isFirstLayerGroupRoute) && // Does not have a fallback boundary file\n                    !hasLayerFallbackFile) {\n                        const defaultFallbackPath = defaultHTTPAccessFallbackPaths[type];\n                        definedFilePaths.push([\n                            type,\n                            defaultFallbackPath\n                        ]);\n                    }\n                }\n            }\n            if (!rootLayout) {\n                var _definedFilePaths_find;\n                const layoutPath = (_definedFilePaths_find = definedFilePaths.find(([type])=>type === 'layout')) == null ? void 0 : _definedFilePaths_find[1];\n                rootLayout = layoutPath;\n                if (isDefaultNotFound && !layoutPath && !rootLayout) {\n                    rootLayout = defaultLayoutPath;\n                    definedFilePaths.push([\n                        'layout',\n                        rootLayout\n                    ]);\n                }\n            }\n            if (!globalError) {\n                const resolvedGlobalErrorPath = await resolver(`${appDirPrefix}/${GLOBAL_ERROR_FILE_TYPE}`);\n                if (resolvedGlobalErrorPath) {\n                    globalError = resolvedGlobalErrorPath;\n                }\n            }\n            let parallelSegmentKey = Array.isArray(parallelSegment) ? parallelSegment[0] : parallelSegment;\n            // normalize the parallel segment key to remove any special markers that we inserted in the\n            // earlier logic (such as children$ and page$). These should never appear in the loader tree, and\n            // should instead be the corresponding segment keys (ie `__PAGE__`) or the `children` parallel route.\n            parallelSegmentKey = parallelSegmentKey === PARALLEL_CHILDREN_SEGMENT ? 'children' : parallelSegmentKey === PAGE_SEGMENT ? _segment.PAGE_SEGMENT_KEY : parallelSegmentKey;\n            const normalizedParallelKey = normalizeParallelKey(parallelKey);\n            let subtreeCode;\n            // If it's root not found page, set not-found boundary as children page\n            if (isNotFoundRoute && normalizedParallelKey === 'children') {\n                var _definedFilePaths_find1;\n                const notFoundPath = ((_definedFilePaths_find1 = definedFilePaths.find(([type])=>type === 'not-found')) == null ? void 0 : _definedFilePaths_find1[1]) ?? defaultHTTPAccessFallbackPaths['not-found'];\n                const varName = `notFound${nestedCollectedDeclarations.length}`;\n                nestedCollectedDeclarations.push([\n                    varName,\n                    notFoundPath\n                ]);\n                subtreeCode = `{\n          children: [${JSON.stringify(_constants.UNDERSCORE_NOT_FOUND_ROUTE)}, {\n            children: ['${_segment.PAGE_SEGMENT_KEY}', {}, {\n              page: [\n                ${varName},\n                ${JSON.stringify(notFoundPath)}\n              ]\n            }]\n          }, {}]\n        }`;\n            }\n            const modulesCode = `{\n        ${definedFilePaths.map(([file, filePath])=>{\n                const varName = `module${nestedCollectedDeclarations.length}`;\n                nestedCollectedDeclarations.push([\n                    varName,\n                    filePath\n                ]);\n                return `'${file}': [${varName}, ${JSON.stringify(filePath)}],`;\n            }).join('\\n')}\n        ${(0, _discover.createMetadataExportsCode)(metadata)}\n      }`;\n            if (!subtreeCode) {\n                const { treeCode: pageSubtreeCode } = await createSubtreePropsFromSegmentPath(subSegmentPath, nestedCollectedDeclarations);\n                subtreeCode = pageSubtreeCode;\n            }\n            props[normalizedParallelKey] = `[\n        '${parallelSegmentKey}',\n        ${subtreeCode},\n        ${modulesCode}\n      ]`;\n        }\n        const adjacentParallelSegments = await resolveAdjacentParallelSegments(segmentPath);\n        for (const adjacentParallelSegment of adjacentParallelSegments){\n            if (!props[normalizeParallelKey(adjacentParallelSegment)]) {\n                const actualSegment = adjacentParallelSegment === 'children' ? '' : `/${adjacentParallelSegment}`;\n                // if a default is found, use that. Otherwise use the fallback, which will trigger a `notFound()`\n                const defaultPath = await resolver(`${appDirPrefix}${segmentPath}${actualSegment}/default`) ?? _parallelroutedefault.PARALLEL_ROUTE_DEFAULT_PATH;\n                const varName = `default${nestedCollectedDeclarations.length}`;\n                nestedCollectedDeclarations.push([\n                    varName,\n                    defaultPath\n                ]);\n                props[normalizeParallelKey(adjacentParallelSegment)] = `[\n          '${_segment.DEFAULT_SEGMENT_KEY}',\n          {},\n          {\n            defaultPage: [${varName}, ${JSON.stringify(defaultPath)}],\n          }\n        ]`;\n            }\n        }\n        return {\n            treeCode: `{\n        ${Object.entries(props).map(([key, value])=>`${key}: ${value}`).join(',\\n')}\n      }`\n        };\n    }\n    const { treeCode } = await createSubtreePropsFromSegmentPath([], collectedDeclarations);\n    return {\n        treeCode: `${treeCode}.children;`,\n        pages: `${JSON.stringify(pages)};`,\n        rootLayout,\n        globalError: globalError ?? defaultGlobalErrorPath\n    };\n}\nfunction createAbsolutePath(appDir, pathToTurnAbsolute) {\n    return pathToTurnAbsolute// Replace all POSIX path separators with the current OS path separator\n    .replace(/\\//g, _path.default.sep).replace(/^private-next-app-dir/, appDir);\n}\nconst filesInDirMapMap = new WeakMap();\nconst nextAppLoader = async function nextAppLoader() {\n    const loaderOptions = this.getOptions();\n    const { name, appDir, appPaths, pagePath, pageExtensions, rootDir, tsconfigPath, isDev, nextConfigOutput, preferredRegion, basePath, middlewareConfig: middlewareConfigBase64, nextConfigExperimentalUseEarlyImport } = loaderOptions;\n    const buildInfo = (0, _getmodulebuildinfo.getModuleBuildInfo)(this._module);\n    const collectedDeclarations = [];\n    const page = name.replace(/^app/, '');\n    const middlewareConfig = JSON.parse(Buffer.from(middlewareConfigBase64, 'base64').toString());\n    buildInfo.route = {\n        page,\n        absolutePagePath: createAbsolutePath(appDir, pagePath),\n        preferredRegion,\n        middlewareConfig,\n        relatedModules: []\n    };\n    const extensions = pageExtensions.map((extension)=>`.${extension}`);\n    const normalizedAppPaths = typeof appPaths === 'string' ? [\n        appPaths\n    ] : appPaths || [];\n    const resolveParallelSegments = (pathname)=>{\n        const matched = {};\n        let existingChildrenPath;\n        for (const appPath of normalizedAppPaths){\n            if (appPath.startsWith(pathname + '/')) {\n                const rest = appPath.slice(pathname.length + 1).split('/');\n                // It is the actual page, mark it specially.\n                if (rest.length === 1 && rest[0] === 'page') {\n                    existingChildrenPath = appPath;\n                    matched.children = PAGE_SEGMENT;\n                    continue;\n                }\n                const isParallelRoute = rest[0].startsWith('@');\n                if (isParallelRoute) {\n                    if (rest.length === 2 && rest[1] === 'page') {\n                        // We found a parallel route at this level. We don't want to mark it explicitly as the page segment,\n                        // as that should be matched to the `children` slot. Instead, we use an array, to signal to `createSubtreePropsFromSegmentPath`\n                        // that it needs to recursively fill in the loader tree code for the parallel route at the appropriate levels.\n                        matched[rest[0]] = [\n                            PAGE_SEGMENT\n                        ];\n                        continue;\n                    }\n                    // If it was a parallel route but we weren't able to find the page segment (ie, maybe the page is nested further)\n                    // we first insert a special marker to ensure that we still process layout/default/etc at the slot level prior to continuing\n                    // on to the page segment.\n                    matched[rest[0]] = [\n                        PARALLEL_CHILDREN_SEGMENT,\n                        ...rest.slice(1)\n                    ];\n                    continue;\n                }\n                if (existingChildrenPath && matched.children !== rest[0]) {\n                    // If we get here, it means we already set a `page` segment earlier in the loop,\n                    // meaning we already matched a page to the `children` parallel segment.\n                    const isIncomingParallelPage = appPath.includes('@');\n                    const hasCurrentParallelPage = existingChildrenPath.includes('@');\n                    if (isIncomingParallelPage) {\n                        continue;\n                    } else if (!hasCurrentParallelPage && !isIncomingParallelPage) {\n                        // Both the current `children` and the incoming `children` are regular pages.\n                        throw Object.defineProperty(new Error(`You cannot have two parallel pages that resolve to the same path. Please check ${existingChildrenPath} and ${appPath}. Refer to the route group docs for more information: https://nextjs.org/docs/app/building-your-application/routing/route-groups`), \"__NEXT_ERROR_CODE\", {\n                            value: \"E28\",\n                            enumerable: false,\n                            configurable: true\n                        });\n                    }\n                }\n                existingChildrenPath = appPath;\n                matched.children = rest[0];\n            }\n        }\n        return Object.entries(matched);\n    };\n    const resolveDir = (pathToResolve)=>{\n        return createAbsolutePath(appDir, pathToResolve);\n    };\n    const resolveAppRoute = (pathToResolve)=>{\n        return createAbsolutePath(appDir, pathToResolve);\n    };\n    // Cached checker to see if a file exists in a given directory.\n    // This can be more efficient than checking them with `fs.stat` one by one\n    // because all the thousands of files are likely in a few possible directories.\n    // Note that it should only be cached for this compilation, not globally.\n    const fileExistsInDirectory = async (dirname, fileName)=>{\n        // I don't think we should ever hit this code path, but if we do we should handle it gracefully.\n        if (this._compilation === undefined) {\n            try {\n                return (await (0, _getfilesindir.getFilesInDir)(dirname).catch(()=>new Set())).has(fileName);\n            } catch (e) {\n                return false;\n            }\n        }\n        const map = filesInDirMapMap.get(this._compilation) || new Map();\n        if (!filesInDirMapMap.has(this._compilation)) {\n            filesInDirMapMap.set(this._compilation, map);\n        }\n        if (!map.has(dirname)) {\n            map.set(dirname, (0, _getfilesindir.getFilesInDir)(dirname).catch(()=>new Set()));\n        }\n        return (await map.get(dirname) || new Set()).has(fileName);\n    };\n    const resolver = async (pathname)=>{\n        const absolutePath = createAbsolutePath(appDir, pathname);\n        const filenameIndex = absolutePath.lastIndexOf(_path.default.sep);\n        const dirname = absolutePath.slice(0, filenameIndex);\n        const filename = absolutePath.slice(filenameIndex + 1);\n        let result;\n        for (const ext of extensions){\n            const absolutePathWithExtension = `${absolutePath}${ext}`;\n            if (!result && await fileExistsInDirectory(dirname, `${filename}${ext}`)) {\n                result = absolutePathWithExtension;\n            }\n            // Call `addMissingDependency` for all files even if they didn't match,\n            // because they might be added or removed during development.\n            this.addMissingDependency(absolutePathWithExtension);\n        }\n        return result;\n    };\n    const metadataResolver = async (dirname, filename, exts)=>{\n        const absoluteDir = createAbsolutePath(appDir, dirname);\n        let result;\n        for (const ext of exts){\n            // Compared to `resolver` above the exts do not have the `.` included already, so it's added here.\n            const filenameWithExt = `${filename}.${ext}`;\n            const absolutePathWithExtension = `${absoluteDir}${_path.default.sep}${filenameWithExt}`;\n            if (!result && await fileExistsInDirectory(dirname, filenameWithExt)) {\n                result = absolutePathWithExtension;\n            }\n            // Call `addMissingDependency` for all files even if they didn't match,\n            // because they might be added or removed during development.\n            this.addMissingDependency(absolutePathWithExtension);\n        }\n        return result;\n    };\n    if ((0, _isapprouteroute.isAppRouteRoute)(name)) {\n        return (0, _createapproutecode.createAppRouteCode)({\n            appDir,\n            // TODO: investigate if the local `page` is the same as the loaderOptions.page\n            page: loaderOptions.page,\n            name,\n            pagePath,\n            resolveAppRoute,\n            pageExtensions,\n            nextConfigOutput\n        });\n    }\n    let treeCodeResult = await createTreeCodeFromPath(pagePath, {\n        page,\n        resolveDir,\n        resolver,\n        metadataResolver,\n        resolveParallelSegments,\n        loaderContext: this,\n        pageExtensions,\n        basePath,\n        collectedDeclarations\n    });\n    if (!treeCodeResult.rootLayout) {\n        if (!isDev) {\n            // If we're building and missing a root layout, exit the build\n            _log.error(`${(0, _picocolors.bold)(pagePath.replace(`${_constants1.APP_DIR_ALIAS}/`, ''))} doesn't have a root layout. To fix this error, make sure every page has a root layout.`);\n            process.exit(1);\n        } else {\n            var _filesInDirMapMap_get;\n            // In dev we'll try to create a root layout\n            const [createdRootLayout, rootLayoutPath] = await (0, _verifyrootlayout.verifyRootLayout)({\n                appDir: appDir,\n                dir: rootDir,\n                tsconfigPath: tsconfigPath,\n                pagePath,\n                pageExtensions\n            });\n            if (!createdRootLayout) {\n                let message = `${(0, _picocolors.bold)(pagePath.replace(`${_constants1.APP_DIR_ALIAS}/`, ''))} doesn't have a root layout. `;\n                if (rootLayoutPath) {\n                    var _this__compiler;\n                    message += `We tried to create ${(0, _picocolors.bold)(_path.default.relative(((_this__compiler = this._compiler) == null ? void 0 : _this__compiler.context) ?? '', rootLayoutPath))} for you but something went wrong.`;\n                } else {\n                    message += 'To fix this error, make sure every page has a root layout.';\n                }\n                throw Object.defineProperty(new Error(message), \"__NEXT_ERROR_CODE\", {\n                    value: \"E394\",\n                    enumerable: false,\n                    configurable: true\n                });\n            }\n            // Clear fs cache, get the new result with the created root layout.\n            if (this._compilation) (_filesInDirMapMap_get = filesInDirMapMap.get(this._compilation)) == null ? void 0 : _filesInDirMapMap_get.clear();\n            treeCodeResult = await createTreeCodeFromPath(pagePath, {\n                page,\n                resolveDir,\n                resolver,\n                metadataResolver,\n                resolveParallelSegments,\n                loaderContext: this,\n                pageExtensions,\n                basePath,\n                collectedDeclarations\n            });\n        }\n    }\n    const pathname = new _apppathnamenormalizer.AppPathnameNormalizer().normalize(page);\n    // Prefer to modify next/src/server/app-render/entry-base.ts since this is shared with Turbopack.\n    // Any changes to this code should be reflected in Turbopack's app_source.rs and/or app-renderer.tsx as well.\n    const code = await (0, _loadentrypoint.loadEntrypoint)('app-page', {\n        VAR_DEFINITION_PAGE: page,\n        VAR_DEFINITION_PATHNAME: pathname,\n        VAR_MODULE_GLOBAL_ERROR: treeCodeResult.globalError\n    }, {\n        tree: treeCodeResult.treeCode,\n        pages: treeCodeResult.pages,\n        __next_app_require__: '__webpack_require__',\n        // all modules are in the entry chunk, so we never actually need to load chunks in webpack\n        __next_app_load_chunk__: '() => Promise.resolve()'\n    });\n    const header = nextConfigExperimentalUseEarlyImport && process.env.NODE_ENV === 'production' ? collectedDeclarations.map(([varName, modulePath])=>{\n        return `import * as ${varName}_ from ${JSON.stringify(modulePath)};\\nconst ${varName} = () => ${varName}_;\\n`;\n    }).join('') : collectedDeclarations.map(([varName, modulePath])=>{\n        return `const ${varName} = () => import(/* webpackMode: \"eager\" */ ${JSON.stringify(modulePath)});\\n`;\n    }).join('');\n    return header + code;\n};\nconst _default = nextAppLoader;\n\n//# sourceMappingURL=index.js.map"
        }
    ]
}