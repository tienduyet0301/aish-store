{
    "sourceFile": "node_modules/next/dist/build/webpack/loaders/next-edge-ssr-loader/render.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892667613,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"getRender\", {\n    enumerable: true,\n    get: function() {\n        return getRender;\n    }\n});\nconst _webserver = /*#__PURE__*/ _interop_require_default(require(\"../../../../server/web-server\"));\nconst _web = require(\"../../../../server/base-http/web\");\nconst _constants = require(\"../../../../lib/constants\");\nconst _apppaths = require(\"../../../../shared/lib/router/utils/app-paths\");\nconst _internaledgewaituntil = require(\"../../../../server/web/internal-edge-wait-until\");\nfunction _interop_require_default(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nfunction getRender({ dev, page, appMod, pageMod, errorMod, error500Mod, pagesType, Document, buildManifest, reactLoadableManifest, dynamicCssManifest, interceptionRouteRewrites, renderToHTML, clientReferenceManifest, subresourceIntegrityManifest, serverActionsManifest, serverActions, config, buildId, nextFontManifest, incrementalCacheHandler }) {\n    const isAppPath = pagesType === 'app';\n    const baseLoadComponentResult = {\n        dev,\n        buildManifest,\n        reactLoadableManifest,\n        dynamicCssManifest,\n        subresourceIntegrityManifest,\n        Document,\n        App: appMod == null ? void 0 : appMod.default,\n        clientReferenceManifest\n    };\n    const server = new _webserver.default({\n        dev,\n        buildId,\n        conf: config,\n        minimalMode: true,\n        webServerConfig: {\n            page,\n            pathname: isAppPath ? (0, _apppaths.normalizeAppPath)(page) : page,\n            pagesType,\n            interceptionRouteRewrites,\n            extendRenderOpts: {\n                runtime: _constants.SERVER_RUNTIME.experimentalEdge,\n                supportsDynamicResponse: true,\n                disableOptimizedLoading: true,\n                serverActionsManifest,\n                serverActions,\n                nextFontManifest\n            },\n            renderToHTML,\n            incrementalCacheHandler,\n            loadComponent: async (inputPage)=>{\n                if (inputPage === page) {\n                    return {\n                        ...baseLoadComponentResult,\n                        Component: pageMod.default,\n                        pageConfig: pageMod.config || {},\n                        getStaticProps: pageMod.getStaticProps,\n                        getServerSideProps: pageMod.getServerSideProps,\n                        getStaticPaths: pageMod.getStaticPaths,\n                        ComponentMod: pageMod,\n                        isAppPath: !!pageMod.__next_app__,\n                        page: inputPage,\n                        routeModule: pageMod.routeModule\n                    };\n                }\n                // If there is a custom 500 page, we need to handle it separately.\n                if (inputPage === '/500' && error500Mod) {\n                    return {\n                        ...baseLoadComponentResult,\n                        Component: error500Mod.default,\n                        pageConfig: error500Mod.config || {},\n                        getStaticProps: error500Mod.getStaticProps,\n                        getServerSideProps: error500Mod.getServerSideProps,\n                        getStaticPaths: error500Mod.getStaticPaths,\n                        ComponentMod: error500Mod,\n                        page: inputPage,\n                        routeModule: error500Mod.routeModule\n                    };\n                }\n                if (inputPage === '/_error') {\n                    return {\n                        ...baseLoadComponentResult,\n                        Component: errorMod.default,\n                        pageConfig: errorMod.config || {},\n                        getStaticProps: errorMod.getStaticProps,\n                        getServerSideProps: errorMod.getServerSideProps,\n                        getStaticPaths: errorMod.getStaticPaths,\n                        ComponentMod: errorMod,\n                        page: inputPage,\n                        routeModule: errorMod.routeModule\n                    };\n                }\n                return null;\n            }\n        }\n    });\n    const handler = server.getRequestHandler();\n    return async function render(request, event) {\n        const extendedReq = new _web.WebNextRequest(request);\n        const extendedRes = new _web.WebNextResponse(undefined);\n        handler(extendedReq, extendedRes);\n        const result = await extendedRes.toResponse();\n        request.fetchMetrics = extendedReq.fetchMetrics;\n        if (event == null ? void 0 : event.waitUntil) {\n            // TODO(after):\n            // remove `internal_runWithWaitUntil` and the `internal-edge-wait-until` module\n            // when consumers switch to `after`.\n            const waitUntilPromise = (0, _internaledgewaituntil.internal_getCurrentFunctionWaitUntil)();\n            if (waitUntilPromise) {\n                event.waitUntil(waitUntilPromise);\n            }\n        }\n        return result;\n    };\n}\n\n//# sourceMappingURL=render.js.map"
        }
    ]
}