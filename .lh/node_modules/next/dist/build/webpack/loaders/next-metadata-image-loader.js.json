{
    "sourceFile": "node_modules/next/dist/build/webpack/loaders/next-metadata-image-loader.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892668918,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/*\n * This loader is responsible for extracting the metadata image info for rendering in html\n */ \"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    default: null,\n    raw: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    default: function() {\n        return _default;\n    },\n    raw: function() {\n        return raw;\n    }\n});\nconst _fs = require(\"fs\");\nconst _path = /*#__PURE__*/ _interop_require_default(require(\"path\"));\nconst _loaderutils3 = /*#__PURE__*/ _interop_require_default(require(\"next/dist/compiled/loader-utils3\"));\nconst _imageoptimizer = require(\"../../../server/image-optimizer\");\nconst _mimetype = require(\"../../../lib/mime-type\");\nconst _constants = require(\"../../../lib/constants\");\nconst _normalizepathsep = require(\"../../../shared/lib/page-path/normalize-path-sep\");\nconst _utils = require(\"./utils\");\nfunction _interop_require_default(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\n// [NOTE] For turbopack, refer to app_page_loader_tree's write_metadata_item for\n// corresponding features.\nasync function nextMetadataImageLoader(content) {\n    const options = this.getOptions();\n    const { type, segment, pageExtensions, basePath } = options;\n    const { resourcePath, rootContext: context } = this;\n    const { name: fileNameBase, ext } = _path.default.parse(resourcePath);\n    const useNumericSizes = type === 'twitter' || type === 'openGraph';\n    let extension = ext.slice(1);\n    if (extension === 'jpg') {\n        extension = 'jpeg';\n    }\n    const opts = {\n        context,\n        content\n    };\n    // No hash query for favicon.ico\n    const contentHash = type === 'favicon' ? '' : _loaderutils3.default.interpolateName(this, '[contenthash]', opts);\n    const interpolatedName = _loaderutils3.default.interpolateName(this, '[name].[ext]', opts);\n    const isDynamicResource = pageExtensions.includes(extension);\n    const pageSegment = isDynamicResource ? fileNameBase : interpolatedName;\n    const hashQuery = contentHash ? '?' + contentHash : '';\n    const pathnamePrefix = (0, _normalizepathsep.normalizePathSep)(_path.default.join(basePath, segment));\n    if (isDynamicResource) {\n        const exportedFieldsExcludingDefault = (await (0, _utils.getLoaderModuleNamedExports)(resourcePath, this)).filter((name)=>name !== 'default');\n        // re-export and spread as `exportedImageData` to avoid non-exported error\n        return `\\\n    import {\n      ${exportedFieldsExcludingDefault.map((field)=>`${field} as _${field}`).join(',')}\n    } from ${JSON.stringify(// This is an arbitrary resource query to ensure it's a new request, instead\n        // of sharing the same module with next-metadata-route-loader.\n        // Since here we only need export fields such as `size`, `alt` and\n        // `generateImageMetadata`, avoid sharing the same module can make this entry\n        // smaller.\n        resourcePath + '?' + _constants.WEBPACK_RESOURCE_QUERIES.metadataImageMeta)}\n    import { fillMetadataSegment } from 'next/dist/lib/metadata/get-metadata-route'\n\n    const imageModule = {\n      ${exportedFieldsExcludingDefault.map((field)=>`${field}: _${field}`).join(',')}\n    }\n\n    export default async function (props) {\n      const { __metadata_id__: _, ...params } = await props.params\n      const imageUrl = fillMetadataSegment(${JSON.stringify(pathnamePrefix)}, params, ${JSON.stringify(pageSegment)})\n\n      const { generateImageMetadata } = imageModule\n\n      function getImageMetadata(imageMetadata, idParam) {\n        const data = {\n          alt: imageMetadata.alt,\n          type: imageMetadata.contentType || 'image/png',\n          url: imageUrl + (idParam ? ('/' + idParam) : '') + ${JSON.stringify(hashQuery)},\n        }\n        const { size } = imageMetadata\n        if (size) {\n          ${type === 'twitter' || type === 'openGraph' ? 'data.width = size.width; data.height = size.height;' : 'data.sizes = size.width + \"x\" + size.height;'}\n        }\n        return data\n      }\n\n      if (generateImageMetadata) {\n        const imageMetadataArray = await generateImageMetadata({ params })\n        return imageMetadataArray.map((imageMetadata, index) => {\n          const idParam = (imageMetadata.id || index) + ''\n          return getImageMetadata(imageMetadata, idParam)\n        })\n      } else {\n        return [getImageMetadata(imageModule, '')]\n      }\n    }`;\n    }\n    const imageSize = await (0, _imageoptimizer.getImageSize)(content).catch((err)=>err);\n    if (imageSize instanceof Error) {\n        const err = imageSize;\n        err.name = 'InvalidImageFormatError';\n        throw err;\n    }\n    const imageData = {\n        ...extension in _mimetype.imageExtMimeTypeMap && {\n            type: _mimetype.imageExtMimeTypeMap[extension]\n        },\n        ...useNumericSizes && imageSize.width != null && imageSize.height != null ? imageSize : {\n            sizes: // For SVGs, skip sizes and use \"any\" to let it scale automatically based on viewport,\n            // For the images doesn't provide the size properly, use \"any\" as well.\n            // If the size is presented, use the actual size for the image.\n            extension !== 'svg' && imageSize.width != null && imageSize.height != null ? `${imageSize.width}x${imageSize.height}` : 'any'\n        }\n    };\n    if (type === 'openGraph' || type === 'twitter') {\n        const altPath = _path.default.join(_path.default.dirname(resourcePath), fileNameBase + '.alt.txt');\n        if ((0, _fs.existsSync)(altPath)) {\n            imageData.alt = await _fs.promises.readFile(altPath, 'utf8');\n        }\n    }\n    return `\\\n  import { fillMetadataSegment } from 'next/dist/lib/metadata/get-metadata-route'\n\n  export default async (props) => {\n    const imageData = ${JSON.stringify(imageData)}\n    const imageUrl = fillMetadataSegment(${JSON.stringify(pathnamePrefix)}, await props.params, ${JSON.stringify(pageSegment)})\n\n    return [{\n      ...imageData,\n      url: imageUrl + ${JSON.stringify(type === 'favicon' ? '' : hashQuery)},\n    }]\n  }`;\n}\nconst raw = true;\nconst _default = nextMetadataImageLoader;\n\n//# sourceMappingURL=next-metadata-image-loader.js.map"
        }
    ]
}