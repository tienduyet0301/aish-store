{
    "sourceFile": "node_modules/next/dist/build/webpack/loaders/next-barrel-loader.d.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892667054,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * ## Barrel Optimizations\n *\n * This loader is used to optimize the imports of \"barrel\" files that have many\n * re-exports. Currently, both Node.js and Webpack have to enter all of these\n * submodules even if we only need a few of them.\n *\n * For example, say a file `foo.js` with the following contents:\n *\n *   export { a } from './a'\n *   export { b } from './b'\n *   export { c } from './c'\n *   ...\n *\n * If the user imports `a` only, this loader will accept the `names` option to\n * be `['a']`. Then, it request the \"__barrel_transform__\" SWC transform to load\n * `foo.js` and receive the following output:\n *\n *   export const __next_private_export_map__ = '[[\"a\",\"./a\",\"a\"],[\"b\",\"./b\",\"b\"],[\"c\",\"./c\",\"c\"],...]'\n *\n *   format: '[\"<imported identifier>\", \"<import path>\", \"<exported name>\"]'\n *   e.g.: import { a as b } from './module-a' => '[\"b\", \"./module-a\", \"a\"]'\n *\n * The export map, generated by SWC, is a JSON that represents the exports of\n * that module, their original file, and their original name (since you can do\n * `export { a as b }`).\n *\n * Then, this loader can safely remove all the exports that are not needed and\n * re-export the ones from `names`:\n *\n *   export { a } from './a'\n *\n * That's the basic situation and also the happy path.\n *\n *\n *\n * ## Wildcard Exports\n *\n * For wildcard exports (e.g. `export * from './a'`), it becomes a bit more complicated.\n * Say `foo.js` with the following contents:\n *\n *   export * from './a'\n *   export * from './b'\n *   export * from './c'\n *   ...\n *\n * If the user imports `bar` from it, SWC can never know which files are going to be\n * exporting `bar`. So, we have to keep all the wildcard exports and do the same\n * process recursively. This loader will return the following output:\n *\n *   export * from '__barrel_optimize__?names=bar&wildcard!=!./a'\n *   export * from '__barrel_optimize__?names=bar&wildcard!=!./b'\n *   export * from '__barrel_optimize__?names=bar&wildcard!=!./c'\n *   ...\n *\n * The \"!=!\" tells Webpack to use the same loader to process './a', './b', and './c'.\n * After the recursive process, the \"inner loaders\" will either return an empty string\n * or:\n *\n *   export * from './target'\n *\n * Where `target` is the file that exports `bar`.\n *\n *\n *\n * ## Non-Barrel Files\n *\n * If the file is not a barrel, we can't apply any optimizations. That's because\n * we can't easily remove things from the file. For example, say `foo.js` with:\n *\n *   const v = 1\n *   export function b () {\n *     return v\n *   }\n *\n * If the user imports `b` only, we can't remove the `const v = 1` even though\n * the file is side-effect free. In these caes, this loader will simply re-export\n * `foo.js`:\n *\n *   export * from './foo'\n *\n * Besides these cases, this loader also carefully handles the module cache so\n * SWC won't analyze the same file twice, and no instance of the same file will\n * be accidentally created as different instances.\n */\nimport type webpack from 'webpack';\ndeclare const NextBarrelLoader: (this: webpack.LoaderContext<{\n    names: string[];\n    swcCacheDir: string;\n}>) => Promise<void>;\nexport default NextBarrelLoader;\n"
        }
    ]
}