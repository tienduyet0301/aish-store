{
    "sourceFile": "node_modules/next/dist/build/webpack/loaders/lightningcss-loader/src/loader.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892666363,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    LightningCssLoader: null,\n    raw: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    LightningCssLoader: function() {\n        return LightningCssLoader;\n    },\n    raw: function() {\n        return raw;\n    }\n});\nconst _utils = require(\"./utils\");\nconst _codegen = require(\"./codegen\");\nconst _utils1 = require(\"../../css-loader/src/utils\");\nconst _stringifyrequest = require(\"../../../stringify-request\");\nconst _interface = require(\"./interface\");\nconst encoder = new TextEncoder();\nfunction createUrlAndImportVisitor(visitorOptions, apis, imports, replacements, replacedUrls, replacedImportUrls) {\n    const importUrlToNameMap = new Map();\n    let hasUrlImportHelper = false;\n    const urlToNameMap = new Map();\n    const urlToReplacementMap = new Map();\n    let urlIndex = -1;\n    let importUrlIndex = -1;\n    function handleUrl(u) {\n        let url = u.url;\n        const needKeep = visitorOptions.urlFilter(url);\n        if (!needKeep) {\n            return u;\n        }\n        if ((0, _utils1.isDataUrl)(url)) {\n            return u;\n        }\n        urlIndex++;\n        replacedUrls.set(urlIndex, url);\n        url = `__NEXT_LIGHTNINGCSS_LOADER_URL_REPLACE_${urlIndex}__`;\n        const [, query, hashOrQuery] = url.split(/(\\?)?#/, 3);\n        const queryParts = url.split('!');\n        let prefix;\n        if (queryParts.length > 1) {\n            url = queryParts.pop();\n            prefix = queryParts.join('!');\n        }\n        let hash = query ? '?' : '';\n        hash += hashOrQuery ? `#${hashOrQuery}` : '';\n        if (!hasUrlImportHelper) {\n            imports.push({\n                type: 'get_url_import',\n                importName: '___CSS_LOADER_GET_URL_IMPORT___',\n                url: JSON.stringify(require.resolve('../../css-loader/src/runtime/getUrl.js')),\n                index: -1\n            });\n            hasUrlImportHelper = true;\n        }\n        const newUrl = prefix ? `${prefix}!${url}` : url;\n        let importName = urlToNameMap.get(newUrl);\n        if (!importName) {\n            importName = `___CSS_LOADER_URL_IMPORT_${urlToNameMap.size}___`;\n            urlToNameMap.set(newUrl, importName);\n            imports.push({\n                type: 'url',\n                importName,\n                url: JSON.stringify(newUrl),\n                index: urlIndex\n            });\n        }\n        // This should be true for string-urls in image-set\n        const needQuotes = false;\n        const replacementKey = JSON.stringify({\n            newUrl,\n            hash,\n            needQuotes\n        });\n        let replacementName = urlToReplacementMap.get(replacementKey);\n        if (!replacementName) {\n            replacementName = `___CSS_LOADER_URL_REPLACEMENT_${urlToReplacementMap.size}___`;\n            urlToReplacementMap.set(replacementKey, replacementName);\n            replacements.push({\n                replacementName,\n                importName,\n                hash,\n                needQuotes\n            });\n        }\n        return {\n            loc: u.loc,\n            url: replacementName\n        };\n    }\n    return {\n        Rule: {\n            import (node) {\n                if (visitorOptions.importFilter) {\n                    const needKeep = visitorOptions.importFilter(node.value.url, node.value.media);\n                    if (!needKeep) {\n                        return node;\n                    }\n                }\n                let url = node.value.url;\n                importUrlIndex++;\n                replacedImportUrls.set(importUrlIndex, url);\n                url = `__NEXT_LIGHTNINGCSS_LOADER_IMPORT_URL_REPLACE_${importUrlIndex}__`;\n                // TODO: Use identical logic as valueParser.stringify()\n                const media = node.value.media.mediaQueries.length ? JSON.stringify(node.value.media.mediaQueries) : undefined;\n                const isRequestable = (0, _utils1.isUrlRequestable)(url);\n                let prefix;\n                if (isRequestable) {\n                    const queryParts = url.split('!');\n                    if (queryParts.length > 1) {\n                        url = queryParts.pop();\n                        prefix = queryParts.join('!');\n                    }\n                }\n                if (!isRequestable) {\n                    apis.push({\n                        url,\n                        media\n                    });\n                    // Bug of lightningcss\n                    return {\n                        type: 'ignored',\n                        value: ''\n                    };\n                }\n                const newUrl = prefix ? `${prefix}!${url}` : url;\n                let importName = importUrlToNameMap.get(newUrl);\n                if (!importName) {\n                    importName = `___CSS_LOADER_AT_RULE_IMPORT_${importUrlToNameMap.size}___`;\n                    importUrlToNameMap.set(newUrl, importName);\n                    const importUrl = visitorOptions.urlHandler(newUrl);\n                    imports.push({\n                        type: 'rule_import',\n                        importName,\n                        url: importUrl\n                    });\n                }\n                apis.push({\n                    importName,\n                    media\n                });\n                // Bug of lightningcss\n                return {\n                    type: 'ignored',\n                    value: ''\n                };\n            }\n        },\n        Url (node) {\n            return handleUrl(node);\n        }\n    };\n}\nfunction createIcssVisitor({ apis, imports, replacements, replacedUrls, urlHandler }) {\n    let index = -1;\n    let replacementIndex = -1;\n    return {\n        Declaration: {\n            composes (node) {\n                if (node.property === 'unparsed') {\n                    return;\n                }\n                const specifier = node.value.from;\n                if ((specifier == null ? void 0 : specifier.type) !== 'file') {\n                    return;\n                }\n                let url = specifier.value;\n                if (!url) {\n                    return;\n                }\n                index++;\n                replacedUrls.set(index, url);\n                url = `__NEXT_LIGHTNINGCSS_LOADER_ICSS_URL_REPLACE_${index}__`;\n                const importName = `___CSS_LOADER_ICSS_IMPORT_${imports.length}___`;\n                imports.push({\n                    type: 'icss_import',\n                    importName,\n                    icss: true,\n                    url: urlHandler(url),\n                    index\n                });\n                apis.push({\n                    importName,\n                    dedupe: true,\n                    index\n                });\n                const newNames = [];\n                for (const localName of node.value.names){\n                    replacementIndex++;\n                    const replacementName = `___CSS_LOADER_ICSS_IMPORT_${index}_REPLACEMENT_${replacementIndex}___`;\n                    replacements.push({\n                        replacementName,\n                        importName,\n                        localName\n                    });\n                    newNames.push(replacementName);\n                }\n                return {\n                    property: 'composes',\n                    value: {\n                        loc: node.value.loc,\n                        names: newNames,\n                        from: specifier\n                    }\n                };\n            }\n        }\n    };\n}\nconst LOADER_NAME = `lightningcss-loader`;\nasync function LightningCssLoader(source, prevMap) {\n    var _options_modules;\n    const done = this.async();\n    const options = this.getOptions();\n    const { implementation, targets: userTargets, ...opts } = options;\n    options.modules ??= {};\n    if (implementation && typeof implementation.transformCss !== 'function') {\n        done(Object.defineProperty(new TypeError(`[${LOADER_NAME}]: options.implementation.transformCss must be an 'lightningcss' transform function. Received ${typeof implementation.transformCss}`), \"__NEXT_ERROR_CODE\", {\n            value: \"E560\",\n            enumerable: false,\n            configurable: true\n        }));\n        return;\n    }\n    if (options.postcss) {\n        var _postcssWithPlugins_plugins;\n        const { postcssWithPlugins } = await options.postcss();\n        if ((postcssWithPlugins == null ? void 0 : (_postcssWithPlugins_plugins = postcssWithPlugins.plugins) == null ? void 0 : _postcssWithPlugins_plugins.length) > 0) {\n            throw Object.defineProperty(new Error(`[${LOADER_NAME}]: experimental.useLightningcss does not work with postcss plugins. Please remove 'useLightningcss: true' from your configuration.`), \"__NEXT_ERROR_CODE\", {\n                value: \"E519\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n    }\n    const exports1 = [];\n    const imports = [];\n    const icssImports = [];\n    const apis = [];\n    const replacements = [];\n    if (((_options_modules = options.modules) == null ? void 0 : _options_modules.exportOnlyLocals) !== true) {\n        imports.unshift({\n            type: 'api_import',\n            importName: '___CSS_LOADER_API_IMPORT___',\n            url: (0, _stringifyrequest.stringifyRequest)(this, require.resolve('../../css-loader/src/runtime/api'))\n        });\n    }\n    const { loadBindings } = require('next/dist/build/swc');\n    const transform = (implementation == null ? void 0 : implementation.transformCss) ?? (await loadBindings()).css.lightning.transform;\n    const replacedUrls = new Map();\n    const icssReplacedUrls = new Map();\n    const replacedImportUrls = new Map();\n    const urlImportVisitor = createUrlAndImportVisitor({\n        urlHandler: (url)=>(0, _stringifyrequest.stringifyRequest)(this, (0, _utils1.getPreRequester)(this)(options.importLoaders ?? 0) + url),\n        urlFilter: (0, _utils1.getFilter)(options.url, this.resourcePath),\n        importFilter: (0, _utils1.getFilter)(options.import, this.resourcePath),\n        context: this.context\n    }, apis, imports, replacements, replacedUrls, replacedImportUrls);\n    const icssVisitor = createIcssVisitor({\n        apis,\n        imports: icssImports,\n        replacements,\n        replacedUrls: icssReplacedUrls,\n        urlHandler: (url)=>(0, _stringifyrequest.stringifyRequest)(this, (0, _utils1.getPreRequester)(this)(options.importLoaders) + url)\n    });\n    // This works by returned visitors are not conflicting.\n    // naive workaround for composeVisitors, as we do not directly depends on lightningcss's npm pkg\n    // but next-swc provides bindings\n    const visitor = {\n        ...urlImportVisitor,\n        ...icssVisitor\n    };\n    try {\n        const { code, map, exports: moduleExports } = transform({\n            ...opts,\n            visitor,\n            cssModules: options.modules ? {\n                pattern: process.env.__NEXT_TEST_MODE ? '[name]__[local]' : '[name]__[hash]__[local]'\n            } : undefined,\n            filename: this.resourcePath,\n            code: encoder.encode(source),\n            sourceMap: this.sourceMap,\n            targets: (0, _utils.getTargets)({\n                targets: userTargets,\n                key: _interface.ECacheKey.loader\n            }),\n            inputSourceMap: this.sourceMap && prevMap ? JSON.stringify(prevMap) : undefined,\n            include: 1\n        });\n        let cssCodeAsString = code.toString();\n        if (moduleExports) {\n            for(const name in moduleExports){\n                if (Object.prototype.hasOwnProperty.call(moduleExports, name)) {\n                    const v = moduleExports[name];\n                    let value = v.name;\n                    for (const compose of v.composes){\n                        value += ` ${compose.name}`;\n                    }\n                    exports1.push({\n                        name,\n                        value\n                    });\n                }\n            }\n        }\n        if (replacedUrls.size !== 0) {\n            const urlResolver = this.getResolve({\n                conditionNames: [\n                    'asset'\n                ],\n                mainFields: [\n                    'asset'\n                ],\n                mainFiles: [],\n                extensions: []\n            });\n            for (const [index, url] of replacedUrls.entries()){\n                const [pathname] = url.split(/(\\?)?#/, 3);\n                const request = (0, _utils1.requestify)(pathname, this.rootContext);\n                const resolvedUrl = await (0, _utils1.resolveRequests)(urlResolver, this.context, [\n                    ...new Set([\n                        request,\n                        url\n                    ])\n                ]);\n                for (const importItem of imports){\n                    importItem.url = importItem.url.replace(`__NEXT_LIGHTNINGCSS_LOADER_URL_REPLACE_${index}__`, resolvedUrl ?? url);\n                }\n            }\n        }\n        if (replacedImportUrls.size !== 0) {\n            const importResolver = this.getResolve({\n                conditionNames: [\n                    'style'\n                ],\n                extensions: [\n                    '.css'\n                ],\n                mainFields: [\n                    'css',\n                    'style',\n                    'main',\n                    '...'\n                ],\n                mainFiles: [\n                    'index',\n                    '...'\n                ],\n                restrictions: [\n                    /\\.css$/i\n                ]\n            });\n            for (const [index, url] of replacedImportUrls.entries()){\n                const [pathname] = url.split(/(\\?)?#/, 3);\n                const request = (0, _utils1.requestify)(pathname, this.rootContext);\n                const resolvedUrl = await (0, _utils1.resolveRequests)(importResolver, this.context, [\n                    ...new Set([\n                        request,\n                        url\n                    ])\n                ]);\n                for (const importItem of imports){\n                    importItem.url = importItem.url.replace(`__NEXT_LIGHTNINGCSS_LOADER_IMPORT_URL_REPLACE_${index}__`, resolvedUrl ?? url);\n                }\n            }\n        }\n        if (icssReplacedUrls.size !== 0) {\n            const icssResolver = this.getResolve({\n                conditionNames: [\n                    'style'\n                ],\n                extensions: [],\n                mainFields: [\n                    'css',\n                    'style',\n                    'main',\n                    '...'\n                ],\n                mainFiles: [\n                    'index',\n                    '...'\n                ]\n            });\n            for (const [index, url] of icssReplacedUrls.entries()){\n                const [pathname] = url.split(/(\\?)?#/, 3);\n                const request = (0, _utils1.requestify)(pathname, this.rootContext);\n                const resolvedUrl = await (0, _utils1.resolveRequests)(icssResolver, this.context, [\n                    ...new Set([\n                        url,\n                        request\n                    ])\n                ]);\n                for (const importItem of icssImports){\n                    importItem.url = importItem.url.replace(`__NEXT_LIGHTNINGCSS_LOADER_ICSS_URL_REPLACE_${index}__`, resolvedUrl ?? url);\n                }\n            }\n        }\n        imports.push(...icssImports);\n        const importCode = (0, _codegen.getImportCode)(imports, options);\n        const moduleCode = (0, _codegen.getModuleCode)({\n            css: cssCodeAsString,\n            map\n        }, apis, replacements, options, this);\n        const exportCode = (0, _codegen.getExportCode)(exports1, replacements, options);\n        const esCode = `${importCode}${moduleCode}${exportCode}`;\n        done(null, esCode, map && JSON.parse(map.toString()));\n    } catch (error) {\n        console.error('lightningcss-loader error', error);\n        done(error);\n    }\n}\nconst raw = true;\n\n//# sourceMappingURL=loader.js.map"
        }
    ]
}