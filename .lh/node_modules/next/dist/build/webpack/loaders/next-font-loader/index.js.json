{
    "sourceFile": "node_modules/next/dist/build/webpack/loaders/next-font-loader/index.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892668567,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"default\", {\n    enumerable: true,\n    get: function() {\n        return nextFontLoader;\n    }\n});\nconst _path = /*#__PURE__*/ _interop_require_default(require(\"path\"));\nconst _picocolors = require(\"../../../../lib/picocolors\");\nconst _loaderutils3 = /*#__PURE__*/ _interop_require_default(require(\"next/dist/compiled/loader-utils3\"));\nconst _postcssnextfont = /*#__PURE__*/ _interop_require_default(require(\"./postcss-next-font\"));\nconst _util = require(\"util\");\nfunction _interop_require_default(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nasync function nextFontLoader() {\n    const nextFontLoaderSpan = this.currentTraceSpan.traceChild('next-font-loader');\n    return nextFontLoaderSpan.traceAsyncFn(async ()=>{\n        const callback = this.async();\n        /**\n     * The next-swc plugin next-transform-font turns font function calls into CSS imports.\n     * At the end of the import, it adds the call arguments and some additional data as a resourceQuery.\n     * e.g:\n     * const inter = Inter({ subset: ['latin'] })\n     * ->\n     * import inter from 'next/font/google/target.css?{\"import\":\"Inter\",\"subsets\":[\"latin\"]}'\n     *\n     * Here we parse the resourceQuery to get the font function name, call arguments, and the path to the file that called the font function.\n     */ const { path: relativeFilePathFromRoot, import: functionName, arguments: data, variableName } = JSON.parse(this.resourceQuery.slice(1));\n        // Throw error if @next/font is used in _document.js\n        if (/pages[\\\\/]_document\\./.test(relativeFilePathFromRoot)) {\n            const err = Object.defineProperty(new Error(`${(0, _picocolors.bold)('Cannot')} be used within ${(0, _picocolors.cyan)('pages/_document.js')}.`), \"__NEXT_ERROR_CODE\", {\n                value: \"E135\",\n                enumerable: false,\n                configurable: true\n            });\n            err.name = 'NextFontError';\n            callback(err);\n            return;\n        }\n        const { isDev, isServer, assetPrefix, fontLoaderPath, postcss: getPostcss } = this.getOptions();\n        if (assetPrefix && !/^\\/|https?:\\/\\//.test(assetPrefix)) {\n            const err = Object.defineProperty(new Error('assetPrefix must start with a leading slash or be an absolute URL(http:// or https://)'), \"__NEXT_ERROR_CODE\", {\n                value: \"E72\",\n                enumerable: false,\n                configurable: true\n            });\n            err.name = 'NextFontError';\n            callback(err);\n            return;\n        }\n        /**\n     * Emit font files to .next/static/media as [hash].[ext].\n     *\n     * If the font should be preloaded, add .p to the filename: [hash].p.[ext]\n     * NextFontManifestPlugin adds these files to the next/font manifest.\n     *\n     * If the font is using a size-adjust fallback font, add -s to the filename: [hash]-s.[ext]\n     * NextFontManifestPlugin uses this to see if fallback fonts are being used.\n     * This is used to collect stats on fallback fonts usage by the Google Aurora team.\n     */ const emitFontFile = (content, ext, preload, isUsingSizeAdjust)=>{\n            const opts = {\n                context: this.rootContext,\n                content\n            };\n            const interpolatedName = _loaderutils3.default.interpolateName(this, `static/media/[hash]${isUsingSizeAdjust ? '-s' : ''}${preload ? '.p' : ''}.${ext}`, opts);\n            const outputPath = `${assetPrefix}/_next/${interpolatedName}`;\n            // Only the client emits the font file\n            if (!isServer) {\n                this.emitFile(interpolatedName, content, null);\n            }\n            // But both the server and client must get the resulting path\n            return outputPath;\n        };\n        try {\n            // Import the font loader function from either next/font/local or next/font/google\n            // The font loader function emits font files and returns @font-faces and fallback font metrics\n            const fontLoader = require(fontLoaderPath).default;\n            let { css, fallbackFonts, adjustFontFallback, weight, style, variable } = await nextFontLoaderSpan.traceChild('font-loader').traceAsyncFn(()=>fontLoader({\n                    functionName,\n                    variableName,\n                    data,\n                    emitFontFile,\n                    resolve: (src)=>(0, _util.promisify)(this.resolve)(_path.default.dirname(_path.default.join(this.rootContext, relativeFilePathFromRoot)), src.startsWith('.') ? src : `./${src}`),\n                    isDev,\n                    isServer,\n                    loaderContext: this\n                }));\n            const { postcss } = await getPostcss();\n            // Exports will be exported as is from css-loader instead of a CSS module export\n            const exports1 = [];\n            // Generate a hash from the CSS content. Used to generate classnames\n            const fontFamilyHash = _loaderutils3.default.getHashDigest(Buffer.from(css), 'sha1', 'hex', 6);\n            // Add CSS classes, exports and make the font-family locally scoped by turning it unguessable\n            const result = await nextFontLoaderSpan.traceChild('postcss').traceAsyncFn(()=>postcss((0, _postcssnextfont.default)({\n                    exports: exports1,\n                    fallbackFonts,\n                    weight,\n                    style,\n                    adjustFontFallback,\n                    variable\n                })).process(css, {\n                    from: undefined\n                }));\n            const ast = {\n                type: 'postcss',\n                version: result.processor.version,\n                root: result.root\n            };\n            // Return the resulting CSS and send the postcss ast, font exports and the hash to the css-loader in the meta argument.\n            callback(null, result.css, null, {\n                exports: exports1,\n                ast,\n                fontFamilyHash\n            });\n        } catch (err) {\n            callback(err);\n        }\n    });\n}\n\n//# sourceMappingURL=index.js.map"
        }
    ]
}