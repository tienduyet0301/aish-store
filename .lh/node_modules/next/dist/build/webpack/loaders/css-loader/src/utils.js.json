{
    "sourceFile": "node_modules/next/dist/build/webpack/loaders/css-loader/src/utils.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892665823,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/ \"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    dashesCamelCase: null,\n    getExportCode: null,\n    getFilter: null,\n    getImportCode: null,\n    getModuleCode: null,\n    getModulesPlugins: null,\n    getPreRequester: null,\n    isDataUrl: null,\n    isUrlRequestable: null,\n    normalizeSourceMap: null,\n    normalizeSourceMapForRuntime: null,\n    normalizeUrl: null,\n    requestify: null,\n    resolveRequests: null,\n    shouldUseIcssPlugin: null,\n    shouldUseImportPlugin: null,\n    shouldUseModulesPlugins: null,\n    shouldUseURLPlugin: null,\n    sort: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    dashesCamelCase: function() {\n        return dashesCamelCase;\n    },\n    getExportCode: function() {\n        return getExportCode;\n    },\n    getFilter: function() {\n        return getFilter;\n    },\n    getImportCode: function() {\n        return getImportCode;\n    },\n    getModuleCode: function() {\n        return getModuleCode;\n    },\n    getModulesPlugins: function() {\n        return getModulesPlugins;\n    },\n    getPreRequester: function() {\n        return getPreRequester;\n    },\n    isDataUrl: function() {\n        return isDataUrl;\n    },\n    isUrlRequestable: function() {\n        return isUrlRequestable;\n    },\n    normalizeSourceMap: function() {\n        return normalizeSourceMap;\n    },\n    // For lightningcss-loader\n    normalizeSourceMapForRuntime: function() {\n        return normalizeSourceMapForRuntime;\n    },\n    normalizeUrl: function() {\n        return normalizeUrl;\n    },\n    requestify: function() {\n        return requestify;\n    },\n    resolveRequests: function() {\n        return resolveRequests;\n    },\n    shouldUseIcssPlugin: function() {\n        return shouldUseIcssPlugin;\n    },\n    shouldUseImportPlugin: function() {\n        return shouldUseImportPlugin;\n    },\n    shouldUseModulesPlugins: function() {\n        return shouldUseModulesPlugins;\n    },\n    shouldUseURLPlugin: function() {\n        return shouldUseURLPlugin;\n    },\n    sort: function() {\n        return sort;\n    }\n});\nconst _url = require(\"url\");\nconst _path = /*#__PURE__*/ _interop_require_default(require(\"path\"));\nconst _loaderutils3 = require(\"next/dist/compiled/loader-utils3\");\nconst _postcssmodulesvalues = /*#__PURE__*/ _interop_require_default(require(\"next/dist/compiled/postcss-modules-values\"));\nconst _postcssmoduleslocalbydefault = /*#__PURE__*/ _interop_require_default(require(\"next/dist/compiled/postcss-modules-local-by-default\"));\nconst _postcssmodulesextractimports = /*#__PURE__*/ _interop_require_default(require(\"next/dist/compiled/postcss-modules-extract-imports\"));\nconst _postcssmodulesscope = /*#__PURE__*/ _interop_require_default(require(\"next/dist/compiled/postcss-modules-scope\"));\nconst _camelcase = /*#__PURE__*/ _interop_require_default(require(\"./camelcase\"));\nfunction _interop_require_default(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nconst whitespace = '[\\\\x20\\\\t\\\\r\\\\n\\\\f]';\nconst unescapeRegExp = new RegExp(`\\\\\\\\([\\\\da-f]{1,6}${whitespace}?|(${whitespace})|.)`, 'ig');\nconst matchNativeWin32Path = /^[A-Z]:[/\\\\]|^\\\\\\\\/i;\nfunction unescape(str) {\n    return str.replace(unescapeRegExp, (_, escaped, escapedWhitespace)=>{\n        const high = `0x${escaped}` - 0x10000;\n        /* eslint-disable line-comment-position */ // NaN means non-codepoint\n        // Workaround erroneous numeric interpretation of +\"0x\"\n        // eslint-disable-next-line no-self-compare\n        return high !== high || escapedWhitespace ? escaped : high < 0 ? String.fromCharCode(high + 0x10000) : // eslint-disable-next-line no-bitwise\n        String.fromCharCode(high >> 10 | 0xd800, high & 0x3ff | 0xdc00);\n    /* eslint-enable line-comment-position */ });\n}\nfunction normalizePath(file) {\n    return _path.default.sep === '\\\\' ? file.replace(/\\\\/g, '/') : file;\n}\nfunction fixedEncodeURIComponent(str) {\n    return str.replace(/[!'()*]/g, (c)=>`%${c.charCodeAt(0).toString(16)}`);\n}\nfunction normalizeUrl(url, isStringValue) {\n    let normalizedUrl = url;\n    if (isStringValue && /\\\\(\\n|\\r\\n|\\r|\\f)/.test(normalizedUrl)) {\n        normalizedUrl = normalizedUrl.replace(/\\\\(\\n|\\r\\n|\\r|\\f)/g, '');\n    }\n    if (matchNativeWin32Path.test(url)) {\n        try {\n            normalizedUrl = decodeURIComponent(normalizedUrl);\n        } catch (error) {\n        // Ignores invalid and broken URLs and try to resolve them as is\n        }\n        return normalizedUrl;\n    }\n    normalizedUrl = unescape(normalizedUrl);\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    if (isDataUrl(url)) {\n        return fixedEncodeURIComponent(normalizedUrl);\n    }\n    try {\n        normalizedUrl = decodeURI(normalizedUrl);\n    } catch (error) {\n    // Ignores invalid and broken URLs and try to resolve them as is\n    }\n    return normalizedUrl;\n}\nfunction requestify(url, rootContext) {\n    if (/^file:/i.test(url)) {\n        return (0, _url.fileURLToPath)(url);\n    }\n    if (/^[a-z][a-z0-9+.-]*:/i.test(url)) {\n        return url;\n    }\n    return url.charAt(0) === '/' ? (0, _loaderutils3.urlToRequest)(url, rootContext) : (0, _loaderutils3.urlToRequest)(url);\n}\nfunction getFilter(filter, resourcePath) {\n    return (...args)=>{\n        if (typeof filter === 'function') {\n            return filter(...args, resourcePath);\n        }\n        return true;\n    };\n}\nfunction shouldUseImportPlugin(options) {\n    if (options.modules.exportOnlyLocals) {\n        return false;\n    }\n    if (typeof options.import === 'boolean') {\n        return options.import;\n    }\n    return true;\n}\nfunction shouldUseURLPlugin(options) {\n    if (options.modules.exportOnlyLocals) {\n        return false;\n    }\n    if (typeof options.url === 'boolean') {\n        return options.url;\n    }\n    return true;\n}\nfunction shouldUseModulesPlugins(options) {\n    return options.modules.compileType === 'module';\n}\nfunction shouldUseIcssPlugin(options) {\n    return options.icss === true || Boolean(options.modules);\n}\nfunction getModulesPlugins(options, loaderContext, meta) {\n    const { mode, getLocalIdent, localIdentName, localIdentContext, localIdentHashPrefix, localIdentRegExp } = options.modules;\n    let plugins = [];\n    try {\n        plugins = [\n            _postcssmodulesvalues.default,\n            (0, _postcssmoduleslocalbydefault.default)({\n                mode\n            }),\n            (0, _postcssmodulesextractimports.default)(),\n            (0, _postcssmodulesscope.default)({\n                generateScopedName (exportName) {\n                    return getLocalIdent(loaderContext, localIdentName, exportName, {\n                        context: localIdentContext,\n                        hashPrefix: localIdentHashPrefix,\n                        regExp: localIdentRegExp\n                    }, meta);\n                },\n                exportGlobals: options.modules.exportGlobals\n            })\n        ];\n    } catch (error) {\n        loaderContext.emitError(error);\n    }\n    return plugins;\n}\nconst IS_NATIVE_WIN32_PATH = /^[a-z]:[/\\\\]|^\\\\\\\\/i;\nconst ABSOLUTE_SCHEME = /^[a-z0-9+\\-.]+:/i;\nfunction getURLType(source) {\n    if (source[0] === '/') {\n        if (source[1] === '/') {\n            return 'scheme-relative';\n        }\n        return 'path-absolute';\n    }\n    if (IS_NATIVE_WIN32_PATH.test(source)) {\n        return 'path-absolute';\n    }\n    return ABSOLUTE_SCHEME.test(source) ? 'absolute' : 'path-relative';\n}\nfunction normalizeSourceMap(map, resourcePath) {\n    let newMap = map;\n    // Some loader emit source map as string\n    // Strip any JSON XSSI avoidance prefix from the string (as documented in the source maps specification), and then parse the string as JSON.\n    if (typeof newMap === 'string') {\n        newMap = JSON.parse(newMap);\n    }\n    delete newMap.file;\n    const { sourceRoot } = newMap;\n    delete newMap.sourceRoot;\n    if (newMap.sources) {\n        // Source maps should use forward slash because it is URLs (https://github.com/mozilla/source-map/issues/91)\n        // We should normalize path because previous loaders like `sass-loader` using backslash when generate source map\n        newMap.sources = newMap.sources.map((source)=>{\n            // Non-standard syntax from `postcss`\n            if (source.startsWith('<')) {\n                return source;\n            }\n            const sourceType = getURLType(source);\n            // Do no touch `scheme-relative` and `absolute` URLs\n            if (sourceType === 'path-relative' || sourceType === 'path-absolute') {\n                const absoluteSource = sourceType === 'path-relative' && sourceRoot ? _path.default.resolve(sourceRoot, normalizePath(source)) : normalizePath(source);\n                return _path.default.relative(_path.default.dirname(resourcePath), absoluteSource);\n            }\n            return source;\n        });\n    }\n    return newMap;\n}\nfunction getPreRequester({ loaders, loaderIndex }) {\n    const cache = Object.create(null);\n    return (number)=>{\n        if (cache[number]) {\n            return cache[number];\n        }\n        if (number === false) {\n            cache[number] = '';\n        } else {\n            const loadersRequest = loaders.slice(loaderIndex, loaderIndex + 1 + (typeof number !== 'number' ? 0 : number)).map((x)=>x.request).join('!');\n            cache[number] = `-!${loadersRequest}!`;\n        }\n        return cache[number];\n    };\n}\nfunction getImportCode(imports, options) {\n    let code = '';\n    for (const item of imports){\n        const { importName, url, icss } = item;\n        if (options.esModule) {\n            if (icss && options.modules.namedExport) {\n                code += `import ${options.modules.exportOnlyLocals ? '' : `${importName}, `}* as ${importName}_NAMED___ from ${url};\\n`;\n            } else {\n                code += `import ${importName} from ${url};\\n`;\n            }\n        } else {\n            code += `var ${importName} = require(${url});\\n`;\n        }\n    }\n    return code ? `// Imports\\n${code}` : '';\n}\nfunction normalizeSourceMapForRuntime(map, loaderContext) {\n    const resultMap = map ? map.toJSON() : null;\n    if (resultMap) {\n        delete resultMap.file;\n        resultMap.sourceRoot = '';\n        resultMap.sources = resultMap.sources.map((source)=>{\n            // Non-standard syntax from `postcss`\n            if (source.startsWith('<')) {\n                return source;\n            }\n            const sourceType = getURLType(source);\n            if (sourceType !== 'path-relative') {\n                return source;\n            }\n            const resourceDirname = _path.default.dirname(loaderContext.resourcePath);\n            const absoluteSource = _path.default.resolve(resourceDirname, source);\n            const contextifyPath = normalizePath(_path.default.relative(loaderContext.rootContext, absoluteSource));\n            return `webpack://${contextifyPath}`;\n        });\n    }\n    return JSON.stringify(resultMap);\n}\nfunction getModuleCode(result, api, replacements, options, loaderContext) {\n    if (options.modules.exportOnlyLocals === true) {\n        return '';\n    }\n    const sourceMapValue = options.sourceMap ? `,${normalizeSourceMapForRuntime(result.map, loaderContext)}` : '';\n    let code = JSON.stringify(result.css);\n    let beforeCode = `var ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(${options.sourceMap});\\n`;\n    for (const item of api){\n        const { url, media, dedupe } = item;\n        beforeCode += url ? `___CSS_LOADER_EXPORT___.push([module.id, ${JSON.stringify(`@import url(${url});`)}${media ? `, ${JSON.stringify(media)}` : ''}]);\\n` : `___CSS_LOADER_EXPORT___.i(${item.importName}${media ? `, ${JSON.stringify(media)}` : dedupe ? ', \"\"' : ''}${dedupe ? ', true' : ''});\\n`;\n    }\n    for (const item of replacements){\n        const { replacementName, importName, localName } = item;\n        if (localName) {\n            code = code.replace(new RegExp(replacementName, 'g'), ()=>options.modules.namedExport ? `\" + ${importName}_NAMED___[${JSON.stringify((0, _camelcase.default)(localName))}] + \"` : `\" + ${importName}.locals[${JSON.stringify(localName)}] + \"`);\n        } else {\n            const { hash, needQuotes } = item;\n            const getUrlOptions = [\n                ...hash ? [\n                    `hash: ${JSON.stringify(hash)}`\n                ] : [],\n                ...needQuotes ? 'needQuotes: true' : []\n            ];\n            const preparedOptions = getUrlOptions.length > 0 ? `, { ${getUrlOptions.join(', ')} }` : '';\n            beforeCode += `var ${replacementName} = ___CSS_LOADER_GET_URL_IMPORT___(${importName}${preparedOptions});\\n`;\n            code = code.replace(new RegExp(replacementName, 'g'), ()=>`\" + ${replacementName} + \"`);\n        }\n    }\n    return `${beforeCode}// Module\\n___CSS_LOADER_EXPORT___.push([module.id, ${code}, \"\"${sourceMapValue}]);\\n`;\n}\nfunction dashesCamelCase(str) {\n    return str.replace(/-+(\\w)/g, (_match, firstLetter)=>firstLetter.toUpperCase());\n}\nfunction getExportCode(exports1, replacements, options) {\n    let code = '// Exports\\n';\n    let localsCode = '';\n    const addExportToLocalsCode = (name, value)=>{\n        if (options.modules.namedExport) {\n            localsCode += `export const ${(0, _camelcase.default)(name)} = ${JSON.stringify(value)};\\n`;\n        } else {\n            if (localsCode) {\n                localsCode += `,\\n`;\n            }\n            localsCode += `\\t${JSON.stringify(name)}: ${JSON.stringify(value)}`;\n        }\n    };\n    for (const { name, value } of exports1){\n        switch(options.modules.exportLocalsConvention){\n            case 'camelCase':\n                {\n                    addExportToLocalsCode(name, value);\n                    const modifiedName = (0, _camelcase.default)(name);\n                    if (modifiedName !== name) {\n                        addExportToLocalsCode(modifiedName, value);\n                    }\n                    break;\n                }\n            case 'camelCaseOnly':\n                {\n                    addExportToLocalsCode((0, _camelcase.default)(name), value);\n                    break;\n                }\n            case 'dashes':\n                {\n                    addExportToLocalsCode(name, value);\n                    const modifiedName = dashesCamelCase(name);\n                    if (modifiedName !== name) {\n                        addExportToLocalsCode(modifiedName, value);\n                    }\n                    break;\n                }\n            case 'dashesOnly':\n                {\n                    addExportToLocalsCode(dashesCamelCase(name), value);\n                    break;\n                }\n            case 'asIs':\n            default:\n                addExportToLocalsCode(name, value);\n                break;\n        }\n    }\n    for (const item of replacements){\n        const { replacementName, localName } = item;\n        if (localName) {\n            const { importName } = item;\n            localsCode = localsCode.replace(new RegExp(replacementName, 'g'), ()=>{\n                if (options.modules.namedExport) {\n                    return `\" + ${importName}_NAMED___[${JSON.stringify((0, _camelcase.default)(localName))}] + \"`;\n                } else if (options.modules.exportOnlyLocals) {\n                    return `\" + ${importName}[${JSON.stringify(localName)}] + \"`;\n                }\n                return `\" + ${importName}.locals[${JSON.stringify(localName)}] + \"`;\n            });\n        } else {\n            localsCode = localsCode.replace(new RegExp(replacementName, 'g'), ()=>`\" + ${replacementName} + \"`);\n        }\n    }\n    if (options.modules.exportOnlyLocals) {\n        code += options.modules.namedExport ? localsCode : `${options.esModule ? 'export default' : 'module.exports ='} {\\n${localsCode}\\n};\\n`;\n        return code;\n    }\n    if (localsCode) {\n        code += options.modules.namedExport ? localsCode : `___CSS_LOADER_EXPORT___.locals = {\\n${localsCode}\\n};\\n`;\n    }\n    code += `${options.esModule ? 'export default' : 'module.exports ='} ___CSS_LOADER_EXPORT___;\\n`;\n    return code;\n}\nasync function resolveRequests(resolve, context, possibleRequests) {\n    return resolve(context, possibleRequests[0]).then((result)=>{\n        return result;\n    }).catch((error)=>{\n        const [, ...tailPossibleRequests] = possibleRequests;\n        if (tailPossibleRequests.length === 0) {\n            throw error;\n        }\n        return resolveRequests(resolve, context, tailPossibleRequests);\n    });\n}\nfunction isUrlRequestable(url) {\n    // Protocol-relative URLs\n    if (/^\\/\\//.test(url)) {\n        return false;\n    }\n    // `file:` protocol\n    if (/^file:/i.test(url)) {\n        return true;\n    }\n    // Absolute URLs\n    if (/^[a-z][a-z0-9+.-]*:/i.test(url)) {\n        return true;\n    }\n    // `#` URLs\n    if (/^#/.test(url)) {\n        return false;\n    }\n    return true;\n}\nfunction sort(a, b) {\n    return a.index - b.index;\n}\nfunction isDataUrl(url) {\n    if (/^data:/i.test(url)) {\n        return true;\n    }\n    return false;\n}\n\n//# sourceMappingURL=utils.js.map"
        }
    ]
}