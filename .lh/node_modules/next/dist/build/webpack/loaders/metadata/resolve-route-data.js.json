{
    "sourceFile": "node_modules/next/dist/build/webpack/loaders/metadata/resolve-route-data.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892666694,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    resolveManifest: null,\n    resolveRobots: null,\n    resolveRouteData: null,\n    resolveSitemap: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    resolveManifest: function() {\n        return resolveManifest;\n    },\n    resolveRobots: function() {\n        return resolveRobots;\n    },\n    resolveRouteData: function() {\n        return resolveRouteData;\n    },\n    resolveSitemap: function() {\n        return resolveSitemap;\n    }\n});\nconst _utils = require(\"../../../../lib/metadata/generate/utils\");\nfunction resolveRobots(data) {\n    let content = '';\n    const rules = Array.isArray(data.rules) ? data.rules : [\n        data.rules\n    ];\n    for (const rule of rules){\n        const userAgent = (0, _utils.resolveArray)(rule.userAgent || [\n            '*'\n        ]);\n        for (const agent of userAgent){\n            content += `User-Agent: ${agent}\\n`;\n        }\n        if (rule.allow) {\n            const allow = (0, _utils.resolveArray)(rule.allow);\n            for (const item of allow){\n                content += `Allow: ${item}\\n`;\n            }\n        }\n        if (rule.disallow) {\n            const disallow = (0, _utils.resolveArray)(rule.disallow);\n            for (const item of disallow){\n                content += `Disallow: ${item}\\n`;\n            }\n        }\n        if (rule.crawlDelay) {\n            content += `Crawl-delay: ${rule.crawlDelay}\\n`;\n        }\n        content += '\\n';\n    }\n    if (data.host) {\n        content += `Host: ${data.host}\\n`;\n    }\n    if (data.sitemap) {\n        const sitemap = (0, _utils.resolveArray)(data.sitemap);\n        // TODO-METADATA: support injecting sitemap url into robots.txt\n        sitemap.forEach((item)=>{\n            content += `Sitemap: ${item}\\n`;\n        });\n    }\n    return content;\n}\nfunction resolveSitemap(data) {\n    const hasAlternates = data.some((item)=>Object.keys(item.alternates ?? {}).length > 0);\n    const hasImages = data.some((item)=>{\n        var _item_images;\n        return Boolean((_item_images = item.images) == null ? void 0 : _item_images.length);\n    });\n    const hasVideos = data.some((item)=>{\n        var _item_videos;\n        return Boolean((_item_videos = item.videos) == null ? void 0 : _item_videos.length);\n    });\n    let content = '';\n    content += '<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n';\n    content += '<urlset xmlns=\"http://www.sitemaps.org/schemas/sitemap/0.9\"';\n    if (hasImages) {\n        content += ' xmlns:image=\"http://www.google.com/schemas/sitemap-image/1.1\"';\n    }\n    if (hasVideos) {\n        content += ' xmlns:video=\"http://www.google.com/schemas/sitemap-video/1.1\"';\n    }\n    if (hasAlternates) {\n        content += ' xmlns:xhtml=\"http://www.w3.org/1999/xhtml\">\\n';\n    } else {\n        content += '>\\n';\n    }\n    for (const item of data){\n        var _item_alternates, _item_images, _item_videos;\n        content += '<url>\\n';\n        content += `<loc>${item.url}</loc>\\n`;\n        const languages = (_item_alternates = item.alternates) == null ? void 0 : _item_alternates.languages;\n        if (languages && Object.keys(languages).length) {\n            // Since sitemap is separated from the page rendering, there's not metadataBase accessible yet.\n            // we give the default setting that won't effect the languages resolving.\n            for(const language in languages){\n                content += `<xhtml:link rel=\"alternate\" hreflang=\"${language}\" href=\"${languages[language]}\" />\\n`;\n            }\n        }\n        if ((_item_images = item.images) == null ? void 0 : _item_images.length) {\n            for (const image of item.images){\n                content += `<image:image>\\n<image:loc>${image}</image:loc>\\n</image:image>\\n`;\n            }\n        }\n        if ((_item_videos = item.videos) == null ? void 0 : _item_videos.length) {\n            for (const video of item.videos){\n                let videoFields = [\n                    `<video:video>`,\n                    `<video:title>${video.title}</video:title>`,\n                    `<video:thumbnail_loc>${video.thumbnail_loc}</video:thumbnail_loc>`,\n                    `<video:description>${video.description}</video:description>`,\n                    video.content_loc && `<video:content_loc>${video.content_loc}</video:content_loc>`,\n                    video.player_loc && `<video:player_loc>${video.player_loc}</video:player_loc>`,\n                    video.duration && `<video:duration>${video.duration}</video:duration>`,\n                    video.view_count && `<video:view_count>${video.view_count}</video:view_count>`,\n                    video.tag && `<video:tag>${video.tag}</video:tag>`,\n                    video.rating && `<video:rating>${video.rating}</video:rating>`,\n                    video.expiration_date && `<video:expiration_date>${video.expiration_date}</video:expiration_date>`,\n                    video.publication_date && `<video:publication_date>${video.publication_date}</video:publication_date>`,\n                    video.family_friendly && `<video:family_friendly>${video.family_friendly}</video:family_friendly>`,\n                    video.requires_subscription && `<video:requires_subscription>${video.requires_subscription}</video:requires_subscription>`,\n                    video.live && `<video:live>${video.live}</video:live>`,\n                    video.restriction && `<video:restriction relationship=\"${video.restriction.relationship}\">${video.restriction.content}</video:restriction>`,\n                    video.platform && `<video:platform relationship=\"${video.platform.relationship}\">${video.platform.content}</video:platform>`,\n                    video.uploader && `<video:uploader${video.uploader.info && ` info=\"${video.uploader.info}\"`}>${video.uploader.content}</video:uploader>`,\n                    `</video:video>\\n`\n                ].filter(Boolean);\n                content += videoFields.join('\\n');\n            }\n        }\n        if (item.lastModified) {\n            const serializedDate = item.lastModified instanceof Date ? item.lastModified.toISOString() : item.lastModified;\n            content += `<lastmod>${serializedDate}</lastmod>\\n`;\n        }\n        if (item.changeFrequency) {\n            content += `<changefreq>${item.changeFrequency}</changefreq>\\n`;\n        }\n        if (typeof item.priority === 'number') {\n            content += `<priority>${item.priority}</priority>\\n`;\n        }\n        content += '</url>\\n';\n    }\n    content += '</urlset>\\n';\n    return content;\n}\nfunction resolveManifest(data) {\n    return JSON.stringify(data);\n}\nfunction resolveRouteData(data, fileType) {\n    if (fileType === 'robots') {\n        return resolveRobots(data);\n    }\n    if (fileType === 'sitemap') {\n        return resolveSitemap(data);\n    }\n    if (fileType === 'manifest') {\n        return resolveManifest(data);\n    }\n    return '';\n}\n\n//# sourceMappingURL=resolve-route-data.js.map"
        }
    ]
}