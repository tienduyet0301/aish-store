{
    "sourceFile": "node_modules/next/dist/build/webpack/loaders/metadata/discover.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892666593,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    createMetadataExportsCode: null,\n    createStaticMetadataFromRoute: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    createMetadataExportsCode: function() {\n        return createMetadataExportsCode;\n    },\n    createStaticMetadataFromRoute: function() {\n        return createStaticMetadataFromRoute;\n    }\n});\nconst _path = /*#__PURE__*/ _interop_require_default(require(\"path\"));\nconst _querystring = require(\"querystring\");\nconst _ismetadataroute = require(\"../../../../lib/metadata/is-metadata-route\");\nconst _constants = require(\"../../../../lib/constants\");\nfunction _interop_require_default(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nconst METADATA_TYPE = 'metadata';\nconst NUMERIC_SUFFIX_ARRAY = Array(10).fill(0);\n// Produce all compositions with filename (icon, apple-icon, etc.) with extensions (png, jpg, etc.)\nasync function enumMetadataFiles(dir, filename, extensions, { metadataResolver, // When set to true, possible filename without extension could: icon, icon0, ..., icon9\nnumericSuffix }) {\n    const collectedFiles = [];\n    // Collect <filename>.<ext>, <filename>[].<ext>\n    const possibleFileNames = [\n        filename\n    ].concat(numericSuffix ? NUMERIC_SUFFIX_ARRAY.map((_, index)=>filename + index) : []);\n    for (const name of possibleFileNames){\n        const resolved = await metadataResolver(dir, name, extensions);\n        if (resolved) {\n            collectedFiles.push(resolved);\n        }\n    }\n    return collectedFiles;\n}\nasync function createStaticMetadataFromRoute(resolvedDir, { segment, metadataResolver, isRootLayoutOrRootPage, pageExtensions, basePath }) {\n    let hasStaticMetadataFiles = false;\n    const staticImagesMetadata = {\n        icon: [],\n        apple: [],\n        twitter: [],\n        openGraph: [],\n        manifest: undefined\n    };\n    async function collectIconModuleIfExists(type) {\n        if (type === 'manifest') {\n            const staticManifestExtension = [\n                'webmanifest',\n                'json'\n            ];\n            const manifestFile = await enumMetadataFiles(resolvedDir, 'manifest', staticManifestExtension.concat(pageExtensions), {\n                metadataResolver,\n                numericSuffix: false\n            });\n            if (manifestFile.length > 0) {\n                hasStaticMetadataFiles = true;\n                const { name, ext } = _path.default.parse(manifestFile[0]);\n                const extension = staticManifestExtension.includes(ext.slice(1)) ? ext.slice(1) : 'webmanifest';\n                staticImagesMetadata.manifest = JSON.stringify(`${basePath}/${name}.${extension}`);\n            }\n            return;\n        }\n        const isFavicon = type === 'favicon';\n        const resolvedMetadataFiles = await enumMetadataFiles(resolvedDir, _ismetadataroute.STATIC_METADATA_IMAGES[type].filename, [\n            ..._ismetadataroute.STATIC_METADATA_IMAGES[type].extensions,\n            ...isFavicon ? [] : pageExtensions\n        ], {\n            metadataResolver,\n            numericSuffix: !isFavicon\n        });\n        resolvedMetadataFiles.sort((a, b)=>a.localeCompare(b)).forEach((filepath)=>{\n            const imageModuleImportSource = `next-metadata-image-loader?${(0, _querystring.stringify)({\n                type,\n                segment,\n                basePath,\n                pageExtensions\n            })}!${filepath}?${_constants.WEBPACK_RESOURCE_QUERIES.metadata}`;\n            const imageModule = `(async (props) => (await import(/* webpackMode: \"eager\" */ ${JSON.stringify(imageModuleImportSource)})).default(props))`;\n            hasStaticMetadataFiles = true;\n            if (type === 'favicon') {\n                staticImagesMetadata.icon.unshift(imageModule);\n            } else {\n                staticImagesMetadata[type].push(imageModule);\n            }\n        });\n    }\n    // Intentionally make these serial to reuse directory access cache.\n    await collectIconModuleIfExists('icon');\n    await collectIconModuleIfExists('apple');\n    await collectIconModuleIfExists('openGraph');\n    await collectIconModuleIfExists('twitter');\n    if (isRootLayoutOrRootPage) {\n        await collectIconModuleIfExists('favicon');\n        await collectIconModuleIfExists('manifest');\n    }\n    return hasStaticMetadataFiles ? staticImagesMetadata : null;\n}\nfunction createMetadataExportsCode(metadata) {\n    return metadata ? `${METADATA_TYPE}: {\n    icon: [${metadata.icon.join(',')}],\n    apple: [${metadata.apple.join(',')}],\n    openGraph: [${metadata.openGraph.join(',')}],\n    twitter: [${metadata.twitter.join(',')}],\n    manifest: ${metadata.manifest ? metadata.manifest : 'undefined'}\n  }` : '';\n}\n\n//# sourceMappingURL=discover.js.map"
        }
    ]
}