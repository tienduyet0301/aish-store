{
    "sourceFile": "node_modules/next/dist/build/type-check.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892663431,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"startTypeChecking\", {\n    enumerable: true,\n    get: function() {\n        return startTypeChecking;\n    }\n});\nconst _path = /*#__PURE__*/ _interop_require_default(require(\"path\"));\nconst _log = /*#__PURE__*/ _interop_require_wildcard(require(\"./output/log\"));\nconst _worker = require(\"../lib/worker\");\nconst _verifyAndLint = require(\"../lib/verifyAndLint\");\nconst _spinner = /*#__PURE__*/ _interop_require_default(require(\"./spinner\"));\nconst _events = require(\"../telemetry/events\");\nconst _iserror = /*#__PURE__*/ _interop_require_default(require(\"../lib/is-error\"));\nfunction _interop_require_default(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nfunction _getRequireWildcardCache(nodeInterop) {\n    if (typeof WeakMap !== \"function\") return null;\n    var cacheBabelInterop = new WeakMap();\n    var cacheNodeInterop = new WeakMap();\n    return (_getRequireWildcardCache = function(nodeInterop) {\n        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n    })(nodeInterop);\n}\nfunction _interop_require_wildcard(obj, nodeInterop) {\n    if (!nodeInterop && obj && obj.__esModule) {\n        return obj;\n    }\n    if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n        return {\n            default: obj\n        };\n    }\n    var cache = _getRequireWildcardCache(nodeInterop);\n    if (cache && cache.has(obj)) {\n        return cache.get(obj);\n    }\n    var newObj = {\n        __proto__: null\n    };\n    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n    for(var key in obj){\n        if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n            if (desc && (desc.get || desc.set)) {\n                Object.defineProperty(newObj, key, desc);\n            } else {\n                newObj[key] = obj[key];\n            }\n        }\n    }\n    newObj.default = obj;\n    if (cache) {\n        cache.set(obj, newObj);\n    }\n    return newObj;\n}\n/**\n * typescript will be loaded in \"next/lib/verify-typescript-setup\" and\n * then passed to \"next/lib/typescript/runTypeCheck\" as a parameter.\n *\n * Since it is impossible to pass a function from main thread to a worker,\n * instead of running \"next/lib/typescript/runTypeCheck\" in a worker,\n * we will run entire \"next/lib/verify-typescript-setup\" in a worker instead.\n */ function verifyTypeScriptSetup(dir, distDir, intentDirs, typeCheckPreflight, tsconfigPath, disableStaticImages, cacheDir, enableWorkerThreads, hasAppDir, hasPagesDir) {\n    const typeCheckWorker = new _worker.Worker(require.resolve('../lib/verify-typescript-setup'), {\n        exposedMethods: [\n            'verifyTypeScriptSetup'\n        ],\n        numWorkers: 1,\n        enableWorkerThreads,\n        maxRetries: 0\n    });\n    return typeCheckWorker.verifyTypeScriptSetup({\n        dir,\n        distDir,\n        intentDirs,\n        typeCheckPreflight,\n        tsconfigPath,\n        disableStaticImages,\n        cacheDir,\n        hasAppDir,\n        hasPagesDir\n    }).then((result)=>{\n        typeCheckWorker.end();\n        return result;\n    }).catch(()=>{\n        // The error is already logged in the worker, we simply exit the main thread to prevent the\n        // `Jest worker encountered 1 child process exceptions, exceeding retry limit` from showing up\n        process.exit(1);\n    });\n}\nasync function startTypeChecking({ cacheDir, config, dir, ignoreESLint, nextBuildSpan, pagesDir, runLint, shouldLint, telemetry, appDir }) {\n    const ignoreTypeScriptErrors = Boolean(config.typescript.ignoreBuildErrors);\n    const eslintCacheDir = _path.default.join(cacheDir, 'eslint/');\n    if (ignoreTypeScriptErrors) {\n        _log.info('Skipping validation of types');\n    }\n    if (runLint && ignoreESLint) {\n        // only print log when build require lint while ignoreESLint is enabled\n        _log.info('Skipping linting');\n    }\n    let typeCheckingAndLintingSpinnerPrefixText;\n    let typeCheckingAndLintingSpinner;\n    if (!ignoreTypeScriptErrors && shouldLint) {\n        typeCheckingAndLintingSpinnerPrefixText = 'Linting and checking validity of types';\n    } else if (!ignoreTypeScriptErrors) {\n        typeCheckingAndLintingSpinnerPrefixText = 'Checking validity of types';\n    } else if (shouldLint) {\n        typeCheckingAndLintingSpinnerPrefixText = 'Linting';\n    }\n    // we will not create a spinner if both ignoreTypeScriptErrors and ignoreESLint are\n    // enabled, but we will still verifying project's tsconfig and dependencies.\n    if (typeCheckingAndLintingSpinnerPrefixText) {\n        typeCheckingAndLintingSpinner = (0, _spinner.default)(typeCheckingAndLintingSpinnerPrefixText);\n    }\n    const typeCheckStart = process.hrtime();\n    try {\n        const [[verifyResult, typeCheckEnd]] = await Promise.all([\n            nextBuildSpan.traceChild('verify-typescript-setup').traceAsyncFn(()=>verifyTypeScriptSetup(dir, config.distDir, [\n                    pagesDir,\n                    appDir\n                ].filter(Boolean), !ignoreTypeScriptErrors, config.typescript.tsconfigPath, config.images.disableStaticImages, cacheDir, config.experimental.workerThreads, !!appDir, !!pagesDir).then((resolved)=>{\n                    const checkEnd = process.hrtime(typeCheckStart);\n                    return [\n                        resolved,\n                        checkEnd\n                    ];\n                })),\n            shouldLint && nextBuildSpan.traceChild('verify-and-lint').traceAsyncFn(async ()=>{\n                var _config_eslint;\n                await (0, _verifyAndLint.verifyAndLint)(dir, eslintCacheDir, (_config_eslint = config.eslint) == null ? void 0 : _config_eslint.dirs, config.experimental.workerThreads, telemetry);\n            })\n        ]);\n        typeCheckingAndLintingSpinner == null ? void 0 : typeCheckingAndLintingSpinner.stopAndPersist();\n        if (!ignoreTypeScriptErrors && verifyResult) {\n            var _verifyResult_result, _verifyResult_result1, _verifyResult_result2;\n            telemetry.record((0, _events.eventTypeCheckCompleted)({\n                durationInSeconds: typeCheckEnd[0],\n                typescriptVersion: verifyResult.version,\n                inputFilesCount: (_verifyResult_result = verifyResult.result) == null ? void 0 : _verifyResult_result.inputFilesCount,\n                totalFilesCount: (_verifyResult_result1 = verifyResult.result) == null ? void 0 : _verifyResult_result1.totalFilesCount,\n                incremental: (_verifyResult_result2 = verifyResult.result) == null ? void 0 : _verifyResult_result2.incremental\n            }));\n        }\n    } catch (err) {\n        // prevent showing jest-worker internal error as it\n        // isn't helpful for users and clutters output\n        if ((0, _iserror.default)(err) && err.message === 'Call retries were exceeded') {\n            await telemetry.flush();\n            process.exit(1);\n        }\n        throw err;\n    }\n}\n\n//# sourceMappingURL=type-check.js.map"
        }
    ]
}