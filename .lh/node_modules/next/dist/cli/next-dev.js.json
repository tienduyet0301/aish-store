{
    "sourceFile": "node_modules/next/dist/cli/next-dev.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892674604,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "#!/usr/bin/env node\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"nextDev\", {\n    enumerable: true,\n    get: function() {\n        return nextDev;\n    }\n});\nrequire(\"../server/lib/cpu-profile\");\nconst _utils = require(\"../server/lib/utils\");\nconst _log = /*#__PURE__*/ _interop_require_wildcard(require(\"../build/output/log\"));\nconst _getprojectdir = require(\"../lib/get-project-dir\");\nconst _constants = require(\"../shared/lib/constants\");\nconst _path = /*#__PURE__*/ _interop_require_default(require(\"path\"));\nconst _shared = require(\"../trace/shared\");\nconst _storage = require(\"../telemetry/storage\");\nconst _config = /*#__PURE__*/ _interop_require_default(require(\"../server/config\"));\nconst _findpagesdir = require(\"../lib/find-pages-dir\");\nconst _fileexists = require(\"../lib/file-exists\");\nconst _getnpxcommand = require(\"../lib/helpers/get-npx-command\");\nconst _mkcert = require(\"../lib/mkcert\");\nconst _uploadtrace = /*#__PURE__*/ _interop_require_default(require(\"../trace/upload-trace\"));\nconst _env = require(\"@next/env\");\nconst _child_process = require(\"child_process\");\nconst _getreservedport = require(\"../lib/helpers/get-reserved-port\");\nconst _os = /*#__PURE__*/ _interop_require_default(require(\"os\"));\nconst _nodeevents = require(\"node:events\");\nconst _timers = require(\"timers\");\nconst _trace = require(\"../trace\");\nfunction _interop_require_default(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nfunction _getRequireWildcardCache(nodeInterop) {\n    if (typeof WeakMap !== \"function\") return null;\n    var cacheBabelInterop = new WeakMap();\n    var cacheNodeInterop = new WeakMap();\n    return (_getRequireWildcardCache = function(nodeInterop) {\n        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n    })(nodeInterop);\n}\nfunction _interop_require_wildcard(obj, nodeInterop) {\n    if (!nodeInterop && obj && obj.__esModule) {\n        return obj;\n    }\n    if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n        return {\n            default: obj\n        };\n    }\n    var cache = _getRequireWildcardCache(nodeInterop);\n    if (cache && cache.has(obj)) {\n        return cache.get(obj);\n    }\n    var newObj = {\n        __proto__: null\n    };\n    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n    for(var key in obj){\n        if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n            if (desc && (desc.get || desc.set)) {\n                Object.defineProperty(newObj, key, desc);\n            } else {\n                newObj[key] = obj[key];\n            }\n        }\n    }\n    newObj.default = obj;\n    if (cache) {\n        cache.set(obj, newObj);\n    }\n    return newObj;\n}\nlet dir;\nlet child;\nlet config;\nlet isTurboSession = false;\nlet traceUploadUrl;\nlet sessionStopHandled = false;\nlet sessionStarted = Date.now();\nlet sessionSpan = (0, _trace.trace)('next-dev');\n// How long should we wait for the child to cleanly exit after sending\n// SIGINT/SIGTERM to the child process before sending SIGKILL?\nconst CHILD_EXIT_TIMEOUT_MS = parseInt(process.env.NEXT_EXIT_TIMEOUT_MS ?? '100', 10);\nconst handleSessionStop = async (signal)=>{\n    if (signal != null && (child == null ? void 0 : child.pid)) child.kill(signal);\n    if (sessionStopHandled) return;\n    sessionStopHandled = true;\n    if (signal != null && (child == null ? void 0 : child.pid) && child.exitCode === null && child.signalCode === null) {\n        let exitTimeout = setTimeout(()=>{\n            child == null ? void 0 : child.kill('SIGKILL');\n        }, CHILD_EXIT_TIMEOUT_MS);\n        await (0, _nodeevents.once)(child, 'exit').catch(()=>{});\n        (0, _timers.clearTimeout)(exitTimeout);\n    }\n    sessionSpan.stop();\n    await (0, _trace.flushAllTraces)({\n        end: true\n    });\n    try {\n        const { eventCliSessionStopped } = require('../telemetry/events/session-stopped');\n        config = config || await (0, _config.default)(_constants.PHASE_DEVELOPMENT_SERVER, dir);\n        let telemetry = _shared.traceGlobals.get('telemetry') || new _storage.Telemetry({\n            distDir: _path.default.join(dir, config.distDir)\n        });\n        let pagesDir = !!_shared.traceGlobals.get('pagesDir');\n        let appDir = !!_shared.traceGlobals.get('appDir');\n        if (typeof _shared.traceGlobals.get('pagesDir') === 'undefined' || typeof _shared.traceGlobals.get('appDir') === 'undefined') {\n            const pagesResult = (0, _findpagesdir.findPagesDir)(dir);\n            appDir = !!pagesResult.appDir;\n            pagesDir = !!pagesResult.pagesDir;\n        }\n        telemetry.record(eventCliSessionStopped({\n            cliCommand: 'dev',\n            turboFlag: isTurboSession,\n            durationMilliseconds: Date.now() - sessionStarted,\n            pagesDir,\n            appDir\n        }), true);\n        telemetry.flushDetached('dev', dir);\n    } catch (_) {\n    // errors here aren't actionable so don't add\n    // noise to the output\n    }\n    if (traceUploadUrl) {\n        (0, _uploadtrace.default)({\n            traceUploadUrl,\n            mode: 'dev',\n            projectDir: dir,\n            distDir: config.distDir,\n            isTurboSession\n        });\n    }\n    // ensure we re-enable the terminal cursor before exiting\n    // the program, or the cursor could remain hidden\n    process.stdout.write('\\x1B[?25h');\n    process.stdout.write('\\n');\n    process.exit(0);\n};\nprocess.on('SIGINT', ()=>handleSessionStop('SIGINT'));\nprocess.on('SIGTERM', ()=>handleSessionStop('SIGTERM'));\n// exit event must be synchronous\nprocess.on('exit', ()=>child == null ? void 0 : child.kill('SIGKILL'));\nconst nextDev = async (options, portSource, directory)=>{\n    dir = (0, _getprojectdir.getProjectDir)(process.env.NEXT_PRIVATE_DEV_DIR || directory);\n    // Check if pages dir exists and warn if not\n    if (!await (0, _fileexists.fileExists)(dir, _fileexists.FileType.Directory)) {\n        (0, _utils.printAndExit)(`> No such directory exists as the project root: ${dir}`);\n    }\n    async function preflight(skipOnReboot) {\n        const { getPackageVersion, getDependencies } = await Promise.resolve(require('../lib/get-package-version'));\n        const [sassVersion, nodeSassVersion] = await Promise.all([\n            getPackageVersion({\n                cwd: dir,\n                name: 'sass'\n            }),\n            getPackageVersion({\n                cwd: dir,\n                name: 'node-sass'\n            })\n        ]);\n        if (sassVersion && nodeSassVersion) {\n            _log.warn('Your project has both `sass` and `node-sass` installed as dependencies, but should only use one or the other. ' + 'Please remove the `node-sass` dependency from your project. ' + ' Read more: https://nextjs.org/docs/messages/duplicate-sass');\n        }\n        if (!skipOnReboot) {\n            const { dependencies, devDependencies } = await getDependencies({\n                cwd: dir\n            });\n            // Warn if @next/font is installed as a dependency. Ignore `workspace:*` to not warn in the Next.js monorepo.\n            if (dependencies['@next/font'] || devDependencies['@next/font'] && devDependencies['@next/font'] !== 'workspace:*') {\n                const command = (0, _getnpxcommand.getNpxCommand)(dir);\n                _log.warn('Your project has `@next/font` installed as a dependency, please use the built-in `next/font` instead. ' + 'The `@next/font` package will be removed in Next.js 14. ' + `You can migrate by running \\`${command} @next/codemod@latest built-in-next-font .\\`. Read more: https://nextjs.org/docs/messages/built-in-next-font`);\n            }\n        }\n    }\n    let port = options.port;\n    if ((0, _getreservedport.isPortIsReserved)(port)) {\n        (0, _utils.printAndExit)((0, _getreservedport.getReservedPortExplanation)(port), 1);\n    }\n    // If neither --port nor PORT were specified, it's okay to retry new ports.\n    const allowRetry = portSource === 'default';\n    // We do not set a default host value here to prevent breaking\n    // some set-ups that rely on listening on other interfaces\n    const host = options.hostname;\n    config = await (0, _config.default)(_constants.PHASE_DEVELOPMENT_SERVER, dir);\n    if (options.experimentalUploadTrace && !process.env.NEXT_TRACE_UPLOAD_DISABLED) {\n        traceUploadUrl = options.experimentalUploadTrace;\n    }\n    const devServerOptions = {\n        dir,\n        port,\n        allowRetry,\n        isDev: true,\n        hostname: host\n    };\n    const isTurbopack = Boolean(options.turbo || options.turbopack || process.env.IS_TURBOPACK_TEST);\n    if (isTurbopack) {\n        process.env.TURBOPACK = '1';\n    }\n    isTurboSession = isTurbopack;\n    const distDir = _path.default.join(dir, config.distDir ?? '.next');\n    (0, _shared.setGlobal)('phase', _constants.PHASE_DEVELOPMENT_SERVER);\n    (0, _shared.setGlobal)('distDir', distDir);\n    const startServerPath = require.resolve('../server/lib/start-server');\n    async function startServer(startServerOptions) {\n        return new Promise((resolve)=>{\n            let resolved = false;\n            const defaultEnv = _env.initialEnv || process.env;\n            const nodeOptions = (0, _utils.getParsedNodeOptionsWithoutInspect)();\n            const nodeDebugType = (0, _utils.getNodeDebugType)();\n            let maxOldSpaceSize = (0, _utils.getMaxOldSpaceSize)();\n            if (!maxOldSpaceSize && !process.env.NEXT_DISABLE_MEM_OVERRIDE) {\n                const totalMem = _os.default.totalmem();\n                const totalMemInMB = Math.floor(totalMem / 1024 / 1024);\n                maxOldSpaceSize = Math.floor(totalMemInMB * 0.5).toString();\n                nodeOptions['max-old-space-size'] = maxOldSpaceSize;\n                // Ensure the max_old_space_size is not also set.\n                delete nodeOptions['max_old_space_size'];\n            }\n            if (options.disableSourceMaps) {\n                delete nodeOptions['enable-source-maps'];\n            } else {\n                nodeOptions['enable-source-maps'] = true;\n            }\n            if (nodeDebugType) {\n                const address = (0, _utils.getParsedDebugAddress)();\n                address.port = address.port + 1;\n                nodeOptions[nodeDebugType] = (0, _utils.formatDebugAddress)(address);\n            }\n            child = (0, _child_process.fork)(startServerPath, {\n                stdio: 'inherit',\n                env: {\n                    ...defaultEnv,\n                    ...isTurbopack ? {\n                        TURBOPACK: '1'\n                    } : undefined,\n                    NEXT_PRIVATE_WORKER: '1',\n                    NEXT_PRIVATE_TRACE_ID: _shared.traceId,\n                    NODE_EXTRA_CA_CERTS: startServerOptions.selfSignedCertificate ? startServerOptions.selfSignedCertificate.rootCA : defaultEnv.NODE_EXTRA_CA_CERTS,\n                    NODE_OPTIONS: (0, _utils.formatNodeOptions)(nodeOptions),\n                    // There is a node.js bug on MacOS which causes closing file watchers to be really slow.\n                    // This limits the number of watchers to mitigate the issue.\n                    // https://github.com/nodejs/node/issues/29949\n                    WATCHPACK_WATCHER_LIMIT: _os.default.platform() === 'darwin' ? '20' : undefined\n                }\n            });\n            child.on('message', (msg)=>{\n                if (msg && typeof msg === 'object') {\n                    if (msg.nextWorkerReady) {\n                        child == null ? void 0 : child.send({\n                            nextWorkerOptions: startServerOptions\n                        });\n                    } else if (msg.nextServerReady && !resolved) {\n                        if (msg.port) {\n                            // Store the used port in case a random one was selected, so that\n                            // it can be re-used on automatic dev server restarts.\n                            port = parseInt(msg.port, 10);\n                        }\n                        resolved = true;\n                        resolve();\n                    }\n                }\n            });\n            child.on('exit', async (code, signal)=>{\n                if (sessionStopHandled || signal) {\n                    return;\n                }\n                if (code === _utils.RESTART_EXIT_CODE) {\n                    // Starting the dev server will overwrite the `.next/trace` file, so we\n                    // must upload the existing contents before restarting the server to\n                    // preserve the metrics.\n                    if (traceUploadUrl) {\n                        (0, _uploadtrace.default)({\n                            traceUploadUrl,\n                            mode: 'dev',\n                            projectDir: dir,\n                            distDir: config.distDir,\n                            isTurboSession,\n                            sync: true\n                        });\n                    }\n                    return startServer({\n                        ...startServerOptions,\n                        port\n                    });\n                }\n                // Call handler (e.g. upload telemetry). Don't try to send a signal to\n                // the child, as it has already exited.\n                await handleSessionStop(/* signal */ null);\n            });\n        });\n    }\n    const runDevServer = async (reboot)=>{\n        try {\n            if (!!options.experimentalHttps) {\n                _log.warn('Self-signed certificates are currently an experimental feature, use with caution.');\n                let certificate;\n                const key = options.experimentalHttpsKey;\n                const cert = options.experimentalHttpsCert;\n                const rootCA = options.experimentalHttpsCa;\n                if (key && cert) {\n                    certificate = {\n                        key: _path.default.resolve(key),\n                        cert: _path.default.resolve(cert),\n                        rootCA: rootCA ? _path.default.resolve(rootCA) : undefined\n                    };\n                } else {\n                    certificate = await (0, _mkcert.createSelfSignedCertificate)(host);\n                }\n                await startServer({\n                    ...devServerOptions,\n                    selfSignedCertificate: certificate\n                });\n            } else {\n                await startServer(devServerOptions);\n            }\n            await preflight(reboot);\n        } catch (err) {\n            console.error(err);\n            process.exit(1);\n        }\n    };\n    await runDevServer(false);\n};\n\n//# sourceMappingURL=next-dev.js.map"
        }
    ]
}