{
    "sourceFile": "node_modules/next/dist/experimental/testmode/playwright/report.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892854885,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"reportFetch\", {\n    enumerable: true,\n    get: function() {\n        return reportFetch;\n    }\n});\nconst _step = require(\"./step\");\nasync function parseBody(r) {\n    const contentType = r.headers.get('content-type');\n    let error;\n    let text;\n    let json;\n    let formData;\n    let buffer;\n    if (contentType == null ? void 0 : contentType.includes('text')) {\n        try {\n            text = await r.text();\n        } catch (e) {\n            error = 'failed to parse text';\n        }\n    } else if (contentType == null ? void 0 : contentType.includes('json')) {\n        try {\n            json = await r.json();\n        } catch (e) {\n            error = 'failed to parse json';\n        }\n    } else if (contentType == null ? void 0 : contentType.includes('form-data')) {\n        try {\n            formData = await r.formData();\n        } catch (e) {\n            error = 'failed to parse formData';\n        }\n    } else {\n        try {\n            buffer = await r.arrayBuffer();\n        } catch (e) {\n            error = 'failed to parse arrayBuffer';\n        }\n    }\n    return {\n        ...error ? {\n            error\n        } : null,\n        ...text ? {\n            text\n        } : null,\n        ...json ? {\n            json: JSON.stringify(json)\n        } : null,\n        ...formData ? {\n            formData: JSON.stringify(Array.from(formData))\n        } : null,\n        ...buffer && buffer.byteLength > 0 ? {\n            buffer: `base64;${Buffer.from(buffer).toString('base64')}`\n        } : null\n    };\n}\nfunction parseHeaders(headers) {\n    return Object.fromEntries(Array.from(headers).sort(([key1], [key2])=>key1.localeCompare(key2)).map(([key, value])=>{\n        return [\n            `header.${key}`,\n            value\n        ];\n    }));\n}\nasync function reportFetch(testInfo, req, handler) {\n    return (0, _step.step)(testInfo, {\n        title: `next.onFetch: ${req.method} ${req.url}`,\n        category: 'next.onFetch',\n        apiName: 'next.onFetch',\n        params: {\n            method: req.method,\n            url: req.url,\n            ...await parseBody(req.clone()),\n            ...parseHeaders(req.headers)\n        }\n    }, async (complete)=>{\n        const res = await handler(req);\n        if (res === undefined || res == null) {\n            complete({\n                error: {\n                    message: 'unhandled'\n                }\n            });\n        } else if (typeof res === 'string' && res !== 'continue') {\n            complete({\n                error: {\n                    message: res\n                }\n            });\n        } else {\n            let body;\n            if (typeof res === 'string') {\n                body = {\n                    response: res\n                };\n            } else {\n                const { status, statusText } = res;\n                body = {\n                    status,\n                    ...statusText ? {\n                        statusText\n                    } : null,\n                    ...await parseBody(res.clone()),\n                    ...parseHeaders(res.headers)\n                };\n            }\n            await (0, _step.step)(testInfo, {\n                title: `next.onFetch.fulfilled: ${req.method} ${req.url}`,\n                category: 'next.onFetch',\n                apiName: 'next.onFetch.fulfilled',\n                params: {\n                    ...body,\n                    'request.url': req.url,\n                    'request.method': req.method\n                }\n            }, async ()=>undefined).catch(()=>undefined);\n        }\n        return res;\n    });\n}\n\n//# sourceMappingURL=report.js.map"
        }
    ]
}