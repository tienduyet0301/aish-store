{
    "sourceFile": "node_modules/next/dist/experimental/testing/server/config-testing-utils.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892853586,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"unstable_getResponseFromNextConfig\", {\n    enumerable: true,\n    get: function() {\n        return unstable_getResponseFromNextConfig;\n    }\n});\nconst _nodeurl = require(\"node:url\");\nconst _pathtoregexp = require(\"next/dist/compiled/path-to-regexp\");\nconst _preparedestination = require(\"../../../shared/lib/router/utils/prepare-destination\");\nconst _buildcustomroute = require(\"../../../lib/build-custom-route\");\nconst _loadcustomroutes = /*#__PURE__*/ _interop_require_default(require(\"../../../lib/load-custom-routes\"));\nconst _exports = require(\"../../../server/web/exports\");\nconst _redirectstatus = require(\"../../../lib/redirect-status\");\nconst _utils = require(\"./utils\");\nconst _parsedurlquerytoparams = require(\"../../../server/route-modules/app-route/helpers/parsed-url-query-to-params\");\nfunction _interop_require_default(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\n/**\n * Tries to match the current request against the provided route. If there is\n * a match, it returns the params extracted from the path. If not, it returns\n * undefined.\n */ function matchRoute(route, request, parsedUrl) {\n    const pathname = parsedUrl.pathname;\n    if (!pathname) {\n        return;\n    }\n    const regexMatches = pathname == null ? void 0 : pathname.match(route.regex);\n    if (regexMatches) {\n        const pathMatch = (0, _pathtoregexp.match)(route.source)(pathname);\n        if (!pathMatch) {\n            throw Object.defineProperty(new Error('Unexpected error: extracting params from path failed but the regular expression matched'), \"__NEXT_ERROR_CODE\", {\n                value: \"E289\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n        if (route.has || route.missing) {\n            if (!(0, _preparedestination.matchHas)(request, parsedUrl.query, route.has, route.missing)) {\n                return;\n            }\n        }\n        return pathMatch.params;\n    }\n}\nasync function unstable_getResponseFromNextConfig({ url, nextConfig, headers = {}, cookies = {} }) {\n    const parsedUrl = (0, _nodeurl.parse)(url, true);\n    const request = (0, _utils.constructRequest)({\n        url,\n        headers,\n        cookies\n    });\n    const routes = await (0, _loadcustomroutes.default)(nextConfig);\n    const headerRoutes = routes.headers.map((route)=>(0, _buildcustomroute.buildCustomRoute)('header', route));\n    const redirectRoutes = routes.redirects.map((route)=>(0, _buildcustomroute.buildCustomRoute)('redirect', route, [\n            '/_next/'\n        ]));\n    const rewriteRoutes = [\n        ...routes.rewrites.beforeFiles,\n        ...routes.rewrites.afterFiles,\n        ...routes.rewrites.fallback\n    ].map((route)=>(0, _buildcustomroute.buildCustomRoute)('rewrite', route));\n    const respHeaders = {};\n    for (const route of headerRoutes){\n        const matched = matchRoute(route, request, parsedUrl);\n        if (matched) {\n            for (const header of route.headers){\n                respHeaders[header.key] = header.value;\n            }\n        }\n    }\n    function matchRouteAndGetDestination(route) {\n        const params = matchRoute(route, request, parsedUrl);\n        if (!params) {\n            return;\n        }\n        const { newUrl, parsedDestination } = (0, _preparedestination.prepareDestination)({\n            appendParamsToQuery: false,\n            destination: route.destination,\n            params,\n            query: parsedUrl.query\n        });\n        const searchParams = new URLSearchParams((0, _parsedurlquerytoparams.parsedUrlQueryToParams)(parsedDestination.query));\n        return new URL(searchParams.size > 0 ? `${newUrl}?${searchParams.toString()}` : newUrl, parsedDestination.hostname ? `${parsedDestination.protocol}//${parsedDestination.hostname}` : parsedUrl.host ? `${parsedUrl.protocol}//${parsedUrl.host}` : 'https://example.com');\n    }\n    for (const route of redirectRoutes){\n        const redirectUrl = matchRouteAndGetDestination(route);\n        if (!redirectUrl) {\n            continue;\n        }\n        const statusCode = (0, _redirectstatus.getRedirectStatus)(route);\n        return _exports.NextResponse.redirect(redirectUrl, {\n            status: statusCode,\n            headers: respHeaders\n        });\n    }\n    for (const route of rewriteRoutes){\n        const rewriteUrl = matchRouteAndGetDestination(route);\n        if (!rewriteUrl) {\n            continue;\n        }\n        return _exports.NextResponse.rewrite(rewriteUrl, {\n            headers: respHeaders\n        });\n    }\n    return new _exports.NextResponse('', {\n        status: 200,\n        headers: respHeaders\n    });\n}\n\n//# sourceMappingURL=config-testing-utils.js.map"
        }
    ]
}