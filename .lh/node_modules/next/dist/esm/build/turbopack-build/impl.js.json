{
    "sourceFile": "node_modules/next/dist/esm/build/turbopack-build/impl.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892751116,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import path from 'path';\nimport { validateTurboNextConfig } from '../../lib/turbopack-warning';\nimport { formatIssue, getTurbopackJsConfig, isPersistentCachingEnabled, isRelevantWarning } from '../../shared/lib/turbopack/utils';\nimport { NextBuildContext } from '../build-context';\nimport { createDefineEnv, loadBindings } from '../swc';\nimport { rawEntrypointsToEntrypoints, handleRouteType } from '../handle-entrypoints';\nimport { TurbopackManifestLoader } from '../../shared/lib/turbopack/manifest-loader';\nimport { promises as fs } from 'fs';\nimport { PHASE_PRODUCTION_BUILD } from '../../shared/lib/constants';\nimport loadConfig from '../../server/config';\nimport { hasCustomExportOutput } from '../../export/utils';\nimport { Telemetry } from '../../telemetry/storage';\nimport { setGlobal } from '../../trace';\nexport async function turbopackBuild() {\n    var _config_experimental, _config_turbopack, _config_experimental1;\n    await validateTurboNextConfig({\n        dir: NextBuildContext.dir,\n        isDev: false\n    });\n    const config = NextBuildContext.config;\n    const dir = NextBuildContext.dir;\n    const distDir = NextBuildContext.distDir;\n    const buildId = NextBuildContext.buildId;\n    const encryptionKey = NextBuildContext.encryptionKey;\n    const previewProps = NextBuildContext.previewProps;\n    const hasRewrites = NextBuildContext.hasRewrites;\n    const rewrites = NextBuildContext.rewrites;\n    const appDirOnly = NextBuildContext.appDirOnly;\n    const noMangling = NextBuildContext.noMangling;\n    const startTime = process.hrtime();\n    const bindings = await loadBindings(config == null ? void 0 : (_config_experimental = config.experimental) == null ? void 0 : _config_experimental.useWasmBinary);\n    const dev = false;\n    // const supportedBrowsers = await getSupportedBrowsers(dir, dev)\n    const supportedBrowsers = [\n        'last 1 Chrome versions, last 1 Firefox versions, last 1 Safari versions, last 1 Edge versions'\n    ];\n    const persistentCaching = isPersistentCachingEnabled(config);\n    const project = await bindings.turbo.createProject({\n        projectPath: dir,\n        rootPath: ((_config_turbopack = config.turbopack) == null ? void 0 : _config_turbopack.root) || config.outputFileTracingRoot || dir,\n        distDir,\n        nextConfig: config,\n        jsConfig: await getTurbopackJsConfig(dir, config),\n        watch: {\n            enable: false\n        },\n        dev,\n        env: process.env,\n        defineEnv: createDefineEnv({\n            isTurbopack: true,\n            clientRouterFilters: NextBuildContext.clientRouterFilters,\n            config,\n            dev,\n            distDir,\n            fetchCacheKeyPrefix: config.experimental.fetchCacheKeyPrefix,\n            hasRewrites,\n            // Implemented separately in Turbopack, doesn't have to be passed here.\n            middlewareMatchers: undefined\n        }),\n        buildId,\n        encryptionKey,\n        previewProps,\n        browserslistQuery: supportedBrowsers.join(', '),\n        noMangling\n    }, {\n        persistentCaching,\n        memoryLimit: (_config_experimental1 = config.experimental) == null ? void 0 : _config_experimental1.turbopackMemoryLimit,\n        dependencyTracking: persistentCaching\n    });\n    try {\n        // Write an empty file in a known location to signal this was built with Turbopack\n        await fs.writeFile(path.join(distDir, 'turbopack'), '');\n        await fs.mkdir(path.join(distDir, 'server'), {\n            recursive: true\n        });\n        await fs.mkdir(path.join(distDir, 'static', buildId), {\n            recursive: true\n        });\n        await fs.writeFile(path.join(distDir, 'package.json'), JSON.stringify({\n            type: 'commonjs'\n        }, null, 2));\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        const entrypoints = await project.writeAllEntrypointsToDisk(appDirOnly);\n        const manifestLoader = new TurbopackManifestLoader({\n            buildId,\n            distDir,\n            encryptionKey\n        });\n        const topLevelErrors = [];\n        const topLevelWarnings = [];\n        for (const issue of entrypoints.issues){\n            if (issue.severity === 'error' || issue.severity === 'fatal') {\n                topLevelErrors.push(formatIssue(issue));\n            } else if (isRelevantWarning(issue)) {\n                topLevelWarnings.push(formatIssue(issue));\n            }\n        }\n        if (topLevelWarnings.length > 0) {\n            console.warn(`Turbopack build encountered ${topLevelWarnings.length} warnings:\\n${topLevelWarnings.join('\\n')}`);\n        }\n        if (topLevelErrors.length > 0) {\n            throw Object.defineProperty(new Error(`Turbopack build failed with ${topLevelErrors.length} errors:\\n${topLevelErrors.join('\\n')}`), \"__NEXT_ERROR_CODE\", {\n                value: \"E425\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n        const currentEntrypoints = await rawEntrypointsToEntrypoints(entrypoints);\n        const promises = [];\n        if (!appDirOnly) {\n            for (const [page, route] of currentEntrypoints.page){\n                promises.push(handleRouteType({\n                    page,\n                    route,\n                    manifestLoader\n                }));\n            }\n        }\n        for (const [page, route] of currentEntrypoints.app){\n            promises.push(handleRouteType({\n                page,\n                route,\n                manifestLoader\n            }));\n        }\n        await Promise.all(promises);\n        await Promise.all([\n            manifestLoader.loadBuildManifest('_app'),\n            manifestLoader.loadPagesManifest('_app'),\n            manifestLoader.loadFontManifest('_app'),\n            manifestLoader.loadPagesManifest('_document'),\n            manifestLoader.loadBuildManifest('_error'),\n            manifestLoader.loadPagesManifest('_error'),\n            manifestLoader.loadFontManifest('_error'),\n            entrypoints.instrumentation && manifestLoader.loadMiddlewareManifest('instrumentation', 'instrumentation'),\n            entrypoints.middleware && await manifestLoader.loadMiddlewareManifest('middleware', 'middleware')\n        ]);\n        await manifestLoader.writeManifests({\n            devRewrites: undefined,\n            productionRewrites: rewrites,\n            entrypoints: currentEntrypoints\n        });\n        const shutdownPromise = project.shutdown();\n        const time = process.hrtime(startTime);\n        return {\n            duration: time[0] + time[1] / 1e9,\n            buildTraceContext: undefined,\n            shutdownPromise\n        };\n    } catch (err) {\n        await project.shutdown();\n        throw err;\n    }\n}\nlet shutdownPromise;\nexport async function workerMain(workerData) {\n    // setup new build context from the serialized data passed from the parent\n    Object.assign(NextBuildContext, workerData.buildContext);\n    /// load the config because it's not serializable\n    NextBuildContext.config = await loadConfig(PHASE_PRODUCTION_BUILD, NextBuildContext.dir);\n    // Matches handling in build/index.ts\n    // https://github.com/vercel/next.js/blob/84f347fc86f4efc4ec9f13615c215e4b9fb6f8f0/packages/next/src/build/index.ts#L815-L818\n    // Ensures the `config.distDir` option is matched.\n    if (hasCustomExportOutput(NextBuildContext.config)) {\n        NextBuildContext.config.distDir = '.next';\n    }\n    // Clone the telemetry for worker\n    const telemetry = new Telemetry({\n        distDir: NextBuildContext.config.distDir\n    });\n    setGlobal('telemetry', telemetry);\n    const result = await turbopackBuild();\n    shutdownPromise = result.shutdownPromise;\n    return result;\n}\nexport async function waitForShutdown() {\n    if (shutdownPromise) {\n        await shutdownPromise;\n    }\n}\n\n//# sourceMappingURL=impl.js.map"
        }
    ]
}