{
    "sourceFile": "node_modules/next/dist/esm/build/collect-build-traces.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892746132,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import { Span } from '../trace';\nimport { TRACE_IGNORES, getFilesMapFromReasons } from './webpack/plugins/next-trace-entrypoints-plugin';\nimport path from 'path';\nimport fs from 'fs/promises';\nimport { nonNullable } from '../lib/non-nullable';\nimport * as ciEnvironment from '../server/ci-info';\nimport debugOriginal from 'next/dist/compiled/debug';\nimport picomatch from 'next/dist/compiled/picomatch';\nimport { defaultOverrides } from '../server/require-hook';\nimport { nodeFileTrace } from 'next/dist/compiled/@vercel/nft';\nimport { normalizePagePath } from '../shared/lib/page-path/normalize-page-path';\nimport { normalizeAppPath } from '../shared/lib/router/utils/app-paths';\nimport isError from '../lib/is-error';\nconst debug = debugOriginal('next:build:build-traces');\nfunction shouldIgnore(file, serverIgnoreFn, reasons, cachedIgnoreFiles, children = new Set()) {\n    if (cachedIgnoreFiles.has(file)) {\n        return cachedIgnoreFiles.get(file);\n    }\n    if (serverIgnoreFn(file)) {\n        cachedIgnoreFiles.set(file, true);\n        return true;\n    }\n    children.add(file);\n    const reason = reasons.get(file);\n    if (!reason || reason.parents.size === 0 || reason.type.includes('initial')) {\n        cachedIgnoreFiles.set(file, false);\n        return false;\n    }\n    // if all parents are ignored the child file\n    // should be ignored as well\n    let allParentsIgnored = true;\n    for (const parent of reason.parents.values()){\n        if (!children.has(parent)) {\n            children.add(parent);\n            if (!shouldIgnore(parent, serverIgnoreFn, reasons, cachedIgnoreFiles, children)) {\n                allParentsIgnored = false;\n                break;\n            }\n        }\n    }\n    cachedIgnoreFiles.set(file, allParentsIgnored);\n    return allParentsIgnored;\n}\nexport async function collectBuildTraces({ dir, config, distDir, edgeRuntimeRoutes, staticPages, nextBuildSpan = new Span({\n    name: 'build'\n}), hasSsrAmpPages, buildTraceContext, outputFileTracingRoot }) {\n    const startTime = Date.now();\n    debug('starting build traces');\n    const { outputFileTracingIncludes = {}, outputFileTracingExcludes = {} } = config;\n    const excludeGlobKeys = Object.keys(outputFileTracingExcludes);\n    const includeGlobKeys = Object.keys(outputFileTracingIncludes);\n    await nextBuildSpan.traceChild('node-file-trace-build', {\n        isTurbotrace: 'false'\n    }).traceAsyncFn(async ()=>{\n        const nextServerTraceOutput = path.join(distDir, 'next-server.js.nft.json');\n        const nextMinimalTraceOutput = path.join(distDir, 'next-minimal-server.js.nft.json');\n        const root = outputFileTracingRoot;\n        // Under standalone mode, we need to trace the extra IPC server and\n        // worker files.\n        const isStandalone = config.output === 'standalone';\n        const sharedEntriesSet = Object.keys(defaultOverrides).map((value)=>require.resolve(value, {\n                paths: [\n                    require.resolve('next/dist/server/require-hook')\n                ]\n            }));\n        const { cacheHandler } = config;\n        const { cacheHandlers } = config.experimental;\n        // ensure we trace any dependencies needed for custom\n        // incremental cache handler\n        if (cacheHandler) {\n            sharedEntriesSet.push(require.resolve(path.isAbsolute(cacheHandler) ? cacheHandler : path.join(dir, cacheHandler)));\n        }\n        if (cacheHandlers) {\n            for (const handlerPath of Object.values(cacheHandlers)){\n                if (handlerPath) {\n                    sharedEntriesSet.push(require.resolve(path.isAbsolute(handlerPath) ? handlerPath : path.join(dir, handlerPath)));\n                }\n            }\n        }\n        const serverEntries = [\n            ...sharedEntriesSet,\n            ...isStandalone ? [\n                require.resolve('next/dist/server/lib/start-server'),\n                require.resolve('next/dist/server/next'),\n                require.resolve('next/dist/server/require-hook')\n            ] : [],\n            require.resolve('next/dist/server/next-server')\n        ].filter(Boolean);\n        const minimalServerEntries = [\n            ...sharedEntriesSet,\n            require.resolve('next/dist/compiled/next-server/server.runtime.prod')\n        ].filter(Boolean);\n        const additionalIgnores = new Set();\n        for (const glob of excludeGlobKeys){\n            if (picomatch(glob)('next-server')) {\n                outputFileTracingExcludes[glob].forEach((exclude)=>{\n                    additionalIgnores.add(exclude);\n                });\n            }\n        }\n        const makeIgnoreFn = (ignores)=>{\n            // pre compile the ignore globs\n            const isMatch = picomatch(ignores, {\n                contains: true,\n                dot: true\n            });\n            return (pathname)=>{\n                if (path.isAbsolute(pathname) && !pathname.startsWith(root)) {\n                    return true;\n                }\n                return isMatch(pathname);\n            };\n        };\n        const sharedIgnores = [\n            '**/next/dist/compiled/next-server/**/*.dev.js',\n            ...isStandalone ? [] : [\n                '**/next/dist/compiled/jest-worker/**/*'\n            ],\n            '**/next/dist/compiled/webpack/*',\n            '**/node_modules/webpack5/**/*',\n            '**/next/dist/server/lib/route-resolver*',\n            'next/dist/compiled/semver/semver/**/*.js',\n            ...ciEnvironment.hasNextSupport ? [\n                // only ignore image-optimizer code when\n                // this is being handled outside of next-server\n                '**/next/dist/server/image-optimizer.js'\n            ] : [],\n            ...!hasSsrAmpPages ? [\n                '**/next/dist/compiled/@ampproject/toolbox-optimizer/**/*'\n            ] : [],\n            ...isStandalone ? [] : TRACE_IGNORES,\n            ...additionalIgnores\n        ];\n        const sharedIgnoresFn = makeIgnoreFn(sharedIgnores);\n        const serverIgnores = [\n            ...sharedIgnores,\n            '**/node_modules/react{,-dom,-dom-server-turbopack}/**/*.development.js',\n            '**/*.d.ts',\n            '**/*.map',\n            '**/next/dist/pages/**/*',\n            ...ciEnvironment.hasNextSupport ? [\n                '**/node_modules/sharp/**/*',\n                '**/@img/sharp-libvips*/**/*'\n            ] : []\n        ].filter(nonNullable);\n        const serverIgnoreFn = makeIgnoreFn(serverIgnores);\n        const minimalServerIgnores = [\n            ...serverIgnores,\n            '**/next/dist/compiled/edge-runtime/**/*',\n            '**/next/dist/server/web/sandbox/**/*',\n            '**/next/dist/server/post-process.js'\n        ];\n        const minimalServerIgnoreFn = makeIgnoreFn(minimalServerIgnores);\n        const routesIgnores = [\n            ...sharedIgnores,\n            // server chunks are provided via next-trace-entrypoints-plugin plugin\n            // as otherwise all chunks are traced here and included for all pages\n            // whether they are needed or not\n            '**/.next/server/chunks/**',\n            '**/next/dist/server/optimize-amp.js',\n            '**/next/dist/server/post-process.js'\n        ].filter(nonNullable);\n        const routeIgnoreFn = makeIgnoreFn(routesIgnores);\n        const serverTracedFiles = new Set();\n        const minimalServerTracedFiles = new Set();\n        function addToTracedFiles(base, file, dest) {\n            dest.add(path.relative(distDir, path.join(base, file)).replace(/\\\\/g, '/'));\n        }\n        if (isStandalone) {\n            addToTracedFiles('', require.resolve('next/dist/compiled/jest-worker/processChild'), serverTracedFiles);\n            addToTracedFiles('', require.resolve('next/dist/compiled/jest-worker/threadChild'), serverTracedFiles);\n        }\n        {\n            var _buildTraceContext_chunksTrace;\n            const chunksToTrace = [\n                ...(buildTraceContext == null ? void 0 : (_buildTraceContext_chunksTrace = buildTraceContext.chunksTrace) == null ? void 0 : _buildTraceContext_chunksTrace.action.input) || [],\n                ...serverEntries,\n                ...minimalServerEntries\n            ];\n            const result = await nodeFileTrace(chunksToTrace, {\n                base: outputFileTracingRoot,\n                processCwd: dir,\n                mixedModules: true,\n                async readFile (p) {\n                    try {\n                        return await fs.readFile(p, 'utf8');\n                    } catch (e) {\n                        if (isError(e) && (e.code === 'ENOENT' || e.code === 'EISDIR')) {\n                            // since tracing runs in parallel with static generation server\n                            // files might be removed from that step so tolerate ENOENT\n                            // errors gracefully\n                            return '';\n                        }\n                        throw e;\n                    }\n                },\n                async readlink (p) {\n                    try {\n                        return await fs.readlink(p);\n                    } catch (e) {\n                        if (isError(e) && (e.code === 'EINVAL' || e.code === 'ENOENT' || e.code === 'UNKNOWN')) {\n                            return null;\n                        }\n                        throw e;\n                    }\n                },\n                async stat (p) {\n                    try {\n                        return await fs.stat(p);\n                    } catch (e) {\n                        if (isError(e) && (e.code === 'ENOENT' || e.code === 'ENOTDIR')) {\n                            return null;\n                        }\n                        throw e;\n                    }\n                },\n                // handle shared ignores at top-level as it\n                // avoids over-tracing when we don't need to\n                // and speeds up total trace time\n                ignore (p) {\n                    if (sharedIgnoresFn(p)) {\n                        return true;\n                    }\n                    // if a chunk is attempting to be traced that isn't\n                    // in our initial list we need to ignore it to prevent\n                    // over tracing as webpack needs to be the source of\n                    // truth for which chunks should be included for each entry\n                    if (p.includes('.next/server/chunks') && !chunksToTrace.includes(path.join(outputFileTracingRoot, p))) {\n                        return true;\n                    }\n                    return false;\n                }\n            });\n            const reasons = result.reasons;\n            const fileList = result.fileList;\n            for (const file of result.esmFileList){\n                fileList.add(file);\n            }\n            const parentFilesMap = getFilesMapFromReasons(fileList, reasons);\n            const cachedLookupIgnore = new Map();\n            const cachedLookupIgnoreMinimal = new Map();\n            for (const [entries, tracedFiles] of [\n                [\n                    serverEntries,\n                    serverTracedFiles\n                ],\n                [\n                    minimalServerEntries,\n                    minimalServerTracedFiles\n                ]\n            ]){\n                for (const file of entries){\n                    var _parentFilesMap_get;\n                    const curFiles = [\n                        ...((_parentFilesMap_get = parentFilesMap.get(path.relative(outputFileTracingRoot, file))) == null ? void 0 : _parentFilesMap_get.keys()) || []\n                    ];\n                    tracedFiles.add(path.relative(distDir, file).replace(/\\\\/g, '/'));\n                    for (const curFile of curFiles || []){\n                        const filePath = path.join(outputFileTracingRoot, curFile);\n                        if (!shouldIgnore(curFile, tracedFiles === minimalServerTracedFiles ? minimalServerIgnoreFn : serverIgnoreFn, reasons, tracedFiles === minimalServerTracedFiles ? cachedLookupIgnoreMinimal : cachedLookupIgnore)) {\n                            tracedFiles.add(path.relative(distDir, filePath).replace(/\\\\/g, '/'));\n                        }\n                    }\n                }\n            }\n            const { entryNameFilesMap } = (buildTraceContext == null ? void 0 : buildTraceContext.chunksTrace) || {};\n            const cachedLookupIgnoreRoutes = new Map();\n            await Promise.all([\n                ...entryNameFilesMap ? Object.entries(entryNameFilesMap) : new Map()\n            ].map(async ([entryName, entryNameFiles])=>{\n                const isApp = entryName.startsWith('app/');\n                const isPages = entryName.startsWith('pages/');\n                let route = entryName;\n                if (isApp) {\n                    route = normalizeAppPath(route.substring('app'.length));\n                }\n                if (isPages) {\n                    route = normalizePagePath(route.substring('pages'.length));\n                }\n                // we don't need to trace for automatically statically optimized\n                // pages as they don't have server bundles, note there is\n                // the caveat with flying shuttle mode as it needs this for\n                // detecting changed entries\n                if (staticPages.includes(route)) {\n                    return;\n                }\n                const entryOutputPath = path.join(distDir, 'server', `${entryName}.js`);\n                const traceOutputPath = `${entryOutputPath}.nft.json`;\n                const existingTrace = JSON.parse(await fs.readFile(traceOutputPath, 'utf8'));\n                const traceOutputDir = path.dirname(traceOutputPath);\n                const curTracedFiles = new Set();\n                for (const file of [\n                    ...entryNameFiles,\n                    entryOutputPath\n                ]){\n                    var _parentFilesMap_get;\n                    const curFiles = [\n                        ...((_parentFilesMap_get = parentFilesMap.get(path.relative(outputFileTracingRoot, file))) == null ? void 0 : _parentFilesMap_get.keys()) || []\n                    ];\n                    for (const curFile of curFiles || []){\n                        if (!shouldIgnore(curFile, routeIgnoreFn, reasons, cachedLookupIgnoreRoutes)) {\n                            const filePath = path.join(outputFileTracingRoot, curFile);\n                            const outputFile = path.relative(traceOutputDir, filePath).replace(/\\\\/g, '/');\n                            curTracedFiles.add(outputFile);\n                        }\n                    }\n                }\n                for (const file of existingTrace.files || []){\n                    curTracedFiles.add(file);\n                }\n                await fs.writeFile(traceOutputPath, JSON.stringify({\n                    ...existingTrace,\n                    files: [\n                        ...curTracedFiles\n                    ].sort()\n                }));\n            }));\n        }\n        const moduleTypes = [\n            'app-page',\n            'pages'\n        ];\n        for (const type of moduleTypes){\n            const modulePath = require.resolve(`next/dist/server/route-modules/${type}/module.compiled`);\n            const relativeModulePath = path.relative(root, modulePath);\n            const contextDir = path.join(path.dirname(modulePath), 'vendored', 'contexts');\n            for (const item of (await fs.readdir(contextDir))){\n                const itemPath = path.relative(root, path.join(contextDir, item));\n                if (!serverIgnoreFn(itemPath)) {\n                    addToTracedFiles(root, itemPath, serverTracedFiles);\n                    addToTracedFiles(root, itemPath, minimalServerTracedFiles);\n                }\n            }\n            addToTracedFiles(root, relativeModulePath, serverTracedFiles);\n            addToTracedFiles(root, relativeModulePath, minimalServerTracedFiles);\n        }\n        await Promise.all([\n            fs.writeFile(nextServerTraceOutput, JSON.stringify({\n                version: 1,\n                files: Array.from(serverTracedFiles)\n            })),\n            fs.writeFile(nextMinimalTraceOutput, JSON.stringify({\n                version: 1,\n                files: Array.from(minimalServerTracedFiles)\n            }))\n        ]);\n    });\n    // apply outputFileTracingIncludes/outputFileTracingExcludes after runTurbotrace\n    const includeExcludeSpan = nextBuildSpan.traceChild('apply-include-excludes');\n    await includeExcludeSpan.traceAsyncFn(async ()=>{\n        const globOrig = require('next/dist/compiled/glob');\n        const glob = (pattern)=>{\n            return new Promise((resolve, reject)=>{\n                globOrig(pattern, {\n                    cwd: dir,\n                    nodir: true,\n                    dot: true\n                }, (err, files)=>{\n                    if (err) {\n                        return reject(err);\n                    }\n                    resolve(files);\n                });\n            });\n        };\n        const { entryNameFilesMap } = (buildTraceContext == null ? void 0 : buildTraceContext.chunksTrace) || {};\n        await Promise.all([\n            ...entryNameFilesMap ? Object.entries(entryNameFilesMap) : new Map()\n        ].map(async ([entryName])=>{\n            const isApp = entryName.startsWith('app/');\n            const isPages = entryName.startsWith('pages/');\n            let route = entryName;\n            if (isApp) {\n                route = normalizeAppPath(entryName);\n            }\n            if (isPages) {\n                route = normalizePagePath(entryName);\n            }\n            if (staticPages.includes(route)) {\n                return;\n            }\n            // edge routes have no trace files\n            if (edgeRuntimeRoutes.hasOwnProperty(route)) {\n                return;\n            }\n            const combinedIncludes = new Set();\n            const combinedExcludes = new Set();\n            for (const curGlob of includeGlobKeys){\n                const isMatch = picomatch(curGlob, {\n                    dot: true,\n                    contains: true\n                });\n                if (isMatch(route)) {\n                    for (const include of outputFileTracingIncludes[curGlob]){\n                        combinedIncludes.add(include.replace(/\\\\/g, '/'));\n                    }\n                }\n            }\n            for (const curGlob of excludeGlobKeys){\n                const isMatch = picomatch(curGlob, {\n                    dot: true,\n                    contains: true\n                });\n                if (isMatch(route)) {\n                    for (const exclude of outputFileTracingExcludes[curGlob]){\n                        combinedExcludes.add(exclude);\n                    }\n                }\n            }\n            if (!(combinedIncludes == null ? void 0 : combinedIncludes.size) && !(combinedExcludes == null ? void 0 : combinedExcludes.size)) {\n                return;\n            }\n            const traceFile = path.join(distDir, `server`, `${entryName}.js.nft.json`);\n            const pageDir = path.dirname(traceFile);\n            const traceContent = JSON.parse(await fs.readFile(traceFile, 'utf8'));\n            const includes = [];\n            const resolvedTraceIncludes = new Map();\n            if (combinedIncludes == null ? void 0 : combinedIncludes.size) {\n                await Promise.all([\n                    ...combinedIncludes\n                ].map(async (includeGlob)=>{\n                    const results = await glob(includeGlob);\n                    const resolvedInclude = resolvedTraceIncludes.get(includeGlob) || [\n                        ...results.map((file)=>{\n                            return path.relative(pageDir, path.join(dir, file));\n                        })\n                    ];\n                    includes.push(...resolvedInclude);\n                    resolvedTraceIncludes.set(includeGlob, resolvedInclude);\n                }));\n            }\n            const combined = new Set([\n                ...traceContent.files,\n                ...includes\n            ]);\n            if (combinedExcludes == null ? void 0 : combinedExcludes.size) {\n                const resolvedGlobs = [\n                    ...combinedExcludes\n                ].map((exclude)=>path.join(dir, exclude));\n                // pre compile before forEach\n                const isMatch = picomatch(resolvedGlobs, {\n                    dot: true,\n                    contains: true\n                });\n                combined.forEach((file)=>{\n                    if (isMatch(path.join(pageDir, file))) {\n                        combined.delete(file);\n                    }\n                });\n            }\n            // overwrite trace file with custom includes/excludes\n            await fs.writeFile(traceFile, JSON.stringify({\n                version: traceContent.version,\n                files: [\n                    ...combined\n                ]\n            }));\n        }));\n    });\n    debug(`finished build tracing ${Date.now() - startTime}ms`);\n}\n\n//# sourceMappingURL=collect-build-traces.js.map"
        }
    ]
}