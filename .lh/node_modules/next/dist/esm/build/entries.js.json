{
    "sourceFile": "node_modules/next/dist/esm/build/entries.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892746459,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import * as Log from './output/log';\nimport { posix, join, dirname, extname, normalize } from 'path';\nimport { stringify } from 'querystring';\nimport fs from 'fs';\nimport { PAGES_DIR_ALIAS, ROOT_DIR_ALIAS, APP_DIR_ALIAS, WEBPACK_LAYERS, INSTRUMENTATION_HOOK_FILENAME } from '../lib/constants';\nimport { isAPIRoute } from '../lib/is-api-route';\nimport { isEdgeRuntime } from '../lib/is-edge-runtime';\nimport { APP_CLIENT_INTERNALS, RSC_MODULE_TYPES, UNDERSCORE_NOT_FOUND_ROUTE_ENTRY } from '../shared/lib/constants';\nimport { CLIENT_STATIC_FILES_RUNTIME_AMP, CLIENT_STATIC_FILES_RUNTIME_MAIN, CLIENT_STATIC_FILES_RUNTIME_MAIN_APP, CLIENT_STATIC_FILES_RUNTIME_POLYFILLS, CLIENT_STATIC_FILES_RUNTIME_REACT_REFRESH, COMPILER_NAMES, EDGE_RUNTIME_WEBPACK } from '../shared/lib/constants';\nimport { isMiddlewareFile, isMiddlewareFilename, isInstrumentationHookFile, isInstrumentationHookFilename, reduceAppConfig } from './utils';\nimport { getAppPageStaticInfo, getPageStaticInfo } from './analysis/get-page-static-info';\nimport { normalizePathSep } from '../shared/lib/page-path/normalize-path-sep';\nimport { normalizePagePath } from '../shared/lib/page-path/normalize-page-path';\nimport { normalizeAppPath } from '../shared/lib/router/utils/app-paths';\nimport { encodeMatchers } from './webpack/loaders/next-middleware-loader';\nimport { isAppRouteRoute } from '../lib/is-app-route-route';\nimport { normalizeMetadataPageToRoute, normalizeMetadataRoute } from '../lib/metadata/get-metadata-route';\nimport { getRouteLoaderEntry } from './webpack/loaders/next-route-loader';\nimport { isInternalComponent, isNonRoutePagesPage } from '../lib/is-internal-component';\nimport { isMetadataRouteFile } from '../lib/metadata/is-metadata-route';\nimport { RouteKind } from '../server/route-kind';\nimport { encodeToBase64 } from './webpack/loaders/utils';\nimport { normalizeCatchAllRoutes } from './normalize-catchall-routes';\nimport { PAGE_TYPES } from '../lib/page-types';\nimport { isAppPageRoute } from '../lib/is-app-page-route';\nexport function sortByPageExts(pageExtensions) {\n    return (a, b)=>{\n        // prioritize entries according to pageExtensions order\n        // for consistency as fs order can differ across systems\n        // NOTE: this is reversed so preferred comes last and\n        // overrides prior\n        const aExt = extname(a);\n        const bExt = extname(b);\n        const aNoExt = a.substring(0, a.length - aExt.length);\n        const bNoExt = a.substring(0, b.length - bExt.length);\n        if (aNoExt !== bNoExt) return 0;\n        // find extension index (skip '.' as pageExtensions doesn't have it)\n        const aExtIndex = pageExtensions.indexOf(aExt.substring(1));\n        const bExtIndex = pageExtensions.indexOf(bExt.substring(1));\n        return bExtIndex - aExtIndex;\n    };\n}\nexport async function getStaticInfoIncludingLayouts({ isInsideAppDir, pageExtensions, pageFilePath, appDir, config: nextConfig, isDev, page }) {\n    // TODO: sync types for pages: PAGE_TYPES, ROUTER_TYPE, 'app' | 'pages', etc.\n    const pageType = isInsideAppDir ? PAGE_TYPES.APP : PAGE_TYPES.PAGES;\n    const pageStaticInfo = await getPageStaticInfo({\n        nextConfig,\n        pageFilePath,\n        isDev,\n        page,\n        pageType\n    });\n    if (pageStaticInfo.type === PAGE_TYPES.PAGES || !appDir) {\n        return pageStaticInfo;\n    }\n    const segments = [\n        pageStaticInfo\n    ];\n    // inherit from layout files only if it's a page route\n    if (isAppPageRoute(page)) {\n        const layoutFiles = [];\n        const potentialLayoutFiles = pageExtensions.map((ext)=>'layout.' + ext);\n        let dir = dirname(pageFilePath);\n        // Uses startsWith to not include directories further up.\n        while(dir.startsWith(appDir)){\n            for (const potentialLayoutFile of potentialLayoutFiles){\n                const layoutFile = join(dir, potentialLayoutFile);\n                if (!fs.existsSync(layoutFile)) {\n                    continue;\n                }\n                layoutFiles.push(layoutFile);\n            }\n            // Walk up the directory tree\n            dir = join(dir, '..');\n        }\n        for (const layoutFile of layoutFiles){\n            const layoutStaticInfo = await getAppPageStaticInfo({\n                nextConfig,\n                pageFilePath: layoutFile,\n                isDev,\n                page,\n                pageType: isInsideAppDir ? PAGE_TYPES.APP : PAGE_TYPES.PAGES\n            });\n            segments.unshift(layoutStaticInfo);\n        }\n    }\n    const config = reduceAppConfig(segments);\n    return {\n        ...pageStaticInfo,\n        config,\n        runtime: config.runtime,\n        preferredRegion: config.preferredRegion,\n        maxDuration: config.maxDuration\n    };\n}\n/**\n * For a given page path removes the provided extensions.\n */ export function getPageFromPath(pagePath, pageExtensions) {\n    let page = normalizePathSep(pagePath.replace(new RegExp(`\\\\.+(${pageExtensions.join('|')})$`), ''));\n    page = page.replace(/\\/index$/, '');\n    return page === '' ? '/' : page;\n}\nexport function getPageFilePath({ absolutePagePath, pagesDir, appDir, rootDir }) {\n    if (absolutePagePath.startsWith(PAGES_DIR_ALIAS) && pagesDir) {\n        return absolutePagePath.replace(PAGES_DIR_ALIAS, pagesDir);\n    }\n    if (absolutePagePath.startsWith(APP_DIR_ALIAS) && appDir) {\n        return absolutePagePath.replace(APP_DIR_ALIAS, appDir);\n    }\n    if (absolutePagePath.startsWith(ROOT_DIR_ALIAS)) {\n        return absolutePagePath.replace(ROOT_DIR_ALIAS, rootDir);\n    }\n    return require.resolve(absolutePagePath);\n}\n/**\n * Creates a mapping of route to page file path for a given list of page paths.\n * For example ['/middleware.ts'] is turned into  { '/middleware': `${ROOT_DIR_ALIAS}/middleware.ts` }\n */ export async function createPagesMapping({ isDev, pageExtensions, pagePaths, pagesType, pagesDir, appDir }) {\n    const isAppRoute = pagesType === 'app';\n    const pages = {};\n    const promises = pagePaths.map(async (pagePath)=>{\n        // Do not process .d.ts files as routes\n        if (pagePath.endsWith('.d.ts') && pageExtensions.includes('ts')) {\n            return;\n        }\n        let pageKey = getPageFromPath(pagePath, pageExtensions);\n        if (isAppRoute) {\n            pageKey = pageKey.replace(/%5F/g, '_');\n            if (pageKey === '/not-found') {\n                pageKey = UNDERSCORE_NOT_FOUND_ROUTE_ENTRY;\n            }\n        }\n        const normalizedPath = normalizePathSep(join(pagesType === 'pages' ? PAGES_DIR_ALIAS : pagesType === 'app' ? APP_DIR_ALIAS : ROOT_DIR_ALIAS, pagePath));\n        let route = pagesType === 'app' ? normalizeMetadataRoute(pageKey) : pageKey;\n        if (pagesType === 'app' && isMetadataRouteFile(pagePath, pageExtensions, true)) {\n            const filePath = join(appDir, pagePath);\n            const staticInfo = await getPageStaticInfo({\n                nextConfig: {},\n                pageFilePath: filePath,\n                isDev,\n                page: pageKey,\n                pageType: pagesType\n            });\n            route = normalizeMetadataPageToRoute(route, !!(staticInfo.generateImageMetadata || staticInfo.generateSitemaps));\n        }\n        pages[route] = normalizedPath;\n    });\n    await Promise.all(promises);\n    switch(pagesType){\n        case PAGE_TYPES.ROOT:\n            {\n                return pages;\n            }\n        case PAGE_TYPES.APP:\n            {\n                const hasAppPages = Object.keys(pages).some((page)=>page.endsWith('/page'));\n                return {\n                    // If there's any app pages existed, add a default not-found page.\n                    // If there's any custom not-found page existed, it will override the default one.\n                    ...hasAppPages && {\n                        [UNDERSCORE_NOT_FOUND_ROUTE_ENTRY]: 'next/dist/client/components/not-found-error'\n                    },\n                    ...pages\n                };\n            }\n        case PAGE_TYPES.PAGES:\n            {\n                if (isDev) {\n                    delete pages['/_app'];\n                    delete pages['/_error'];\n                    delete pages['/_document'];\n                }\n                // In development we always alias these to allow Webpack to fallback to\n                // the correct source file so that HMR can work properly when a file is\n                // added or removed.\n                const root = isDev && pagesDir ? PAGES_DIR_ALIAS : 'next/dist/pages';\n                return {\n                    '/_app': `${root}/_app`,\n                    '/_error': `${root}/_error`,\n                    '/_document': `${root}/_document`,\n                    ...pages\n                };\n            }\n        default:\n            {\n                return {};\n            }\n    }\n}\nexport function getEdgeServerEntry(opts) {\n    var _opts_config_experimental_sri;\n    if (opts.pagesType === 'app' && isAppRouteRoute(opts.page) && opts.appDirLoader) {\n        const loaderParams = {\n            absolutePagePath: opts.absolutePagePath,\n            page: opts.page,\n            appDirLoader: Buffer.from(opts.appDirLoader || '').toString('base64'),\n            nextConfig: Buffer.from(JSON.stringify(opts.config)).toString('base64'),\n            preferredRegion: opts.preferredRegion,\n            middlewareConfig: Buffer.from(JSON.stringify(opts.middlewareConfig || {})).toString('base64'),\n            cacheHandlers: JSON.stringify(opts.config.experimental.cacheHandlers || {})\n        };\n        return {\n            import: `next-edge-app-route-loader?${stringify(loaderParams)}!`,\n            layer: WEBPACK_LAYERS.reactServerComponents\n        };\n    }\n    if (isMiddlewareFile(opts.page)) {\n        var _opts_middleware;\n        const loaderParams = {\n            absolutePagePath: opts.absolutePagePath,\n            page: opts.page,\n            rootDir: opts.rootDir,\n            matchers: ((_opts_middleware = opts.middleware) == null ? void 0 : _opts_middleware.matchers) ? encodeMatchers(opts.middleware.matchers) : '',\n            preferredRegion: opts.preferredRegion,\n            middlewareConfig: Buffer.from(JSON.stringify(opts.middlewareConfig || {})).toString('base64')\n        };\n        return {\n            import: `next-middleware-loader?${stringify(loaderParams)}!`,\n            layer: WEBPACK_LAYERS.middleware\n        };\n    }\n    if (isAPIRoute(opts.page)) {\n        const loaderParams = {\n            absolutePagePath: opts.absolutePagePath,\n            page: opts.page,\n            rootDir: opts.rootDir,\n            preferredRegion: opts.preferredRegion,\n            middlewareConfig: Buffer.from(JSON.stringify(opts.middlewareConfig || {})).toString('base64')\n        };\n        return {\n            import: `next-edge-function-loader?${stringify(loaderParams)}!`,\n            layer: WEBPACK_LAYERS.apiEdge\n        };\n    }\n    const loaderParams = {\n        absolute500Path: opts.pages['/500'] || '',\n        absoluteAppPath: opts.pages['/_app'],\n        absoluteDocumentPath: opts.pages['/_document'],\n        absoluteErrorPath: opts.pages['/_error'],\n        absolutePagePath: opts.absolutePagePath,\n        dev: opts.isDev,\n        isServerComponent: opts.isServerComponent,\n        page: opts.page,\n        stringifiedConfig: Buffer.from(JSON.stringify(opts.config)).toString('base64'),\n        pagesType: opts.pagesType,\n        appDirLoader: Buffer.from(opts.appDirLoader || '').toString('base64'),\n        sriEnabled: !opts.isDev && !!((_opts_config_experimental_sri = opts.config.experimental.sri) == null ? void 0 : _opts_config_experimental_sri.algorithm),\n        cacheHandler: opts.config.cacheHandler,\n        preferredRegion: opts.preferredRegion,\n        middlewareConfig: Buffer.from(JSON.stringify(opts.middlewareConfig || {})).toString('base64'),\n        serverActions: opts.config.experimental.serverActions,\n        cacheHandlers: JSON.stringify(opts.config.experimental.cacheHandlers || {})\n    };\n    return {\n        import: `next-edge-ssr-loader?${JSON.stringify(loaderParams)}!`,\n        // The Edge bundle includes the server in its entrypoint, so it has to\n        // be in the SSR layer â€” we later convert the page request to the RSC layer\n        // via a webpack rule.\n        layer: opts.appDirLoader ? WEBPACK_LAYERS.serverSideRendering : undefined\n    };\n}\nexport function getInstrumentationEntry(opts) {\n    // the '../' is needed to make sure the file is not chunked\n    const filename = `${opts.isEdgeServer ? 'edge-' : opts.isDev ? '' : '../'}${INSTRUMENTATION_HOOK_FILENAME}.js`;\n    return {\n        import: opts.absolutePagePath,\n        filename,\n        layer: WEBPACK_LAYERS.instrument\n    };\n}\nexport function getAppLoader() {\n    return process.env.BUILTIN_APP_LOADER ? `builtin:next-app-loader` : 'next-app-loader';\n}\nexport function getAppEntry(opts) {\n    if (process.env.NEXT_RSPACK && process.env.BUILTIN_APP_LOADER) {\n        ;\n        opts.projectRoot = normalize(join(__dirname, '../../..'));\n    }\n    return {\n        import: `${getAppLoader()}?${stringify(opts)}!`,\n        layer: WEBPACK_LAYERS.reactServerComponents\n    };\n}\nexport function getClientEntry(opts) {\n    const loaderOptions = {\n        absolutePagePath: opts.absolutePagePath,\n        page: opts.page\n    };\n    const pageLoader = `next-client-pages-loader?${stringify(loaderOptions)}!`;\n    // Make sure next/router is a dependency of _app or else chunk splitting\n    // might cause the router to not be able to load causing hydration\n    // to fail\n    return opts.page === '/_app' ? [\n        pageLoader,\n        require.resolve('../client/router')\n    ] : pageLoader;\n}\nexport function runDependingOnPageType(params) {\n    if (params.pageType === PAGE_TYPES.ROOT && isInstrumentationHookFile(params.page)) {\n        params.onServer();\n        params.onEdgeServer();\n        return;\n    }\n    if (isMiddlewareFile(params.page)) {\n        if (params.pageRuntime === 'nodejs') {\n            params.onServer();\n            return;\n        } else {\n            params.onEdgeServer();\n            return;\n        }\n    }\n    if (isAPIRoute(params.page)) {\n        if (isEdgeRuntime(params.pageRuntime)) {\n            params.onEdgeServer();\n            return;\n        }\n        params.onServer();\n        return;\n    }\n    if (params.page === '/_document') {\n        params.onServer();\n        return;\n    }\n    if (params.page === '/_app' || params.page === '/_error' || params.page === '/404' || params.page === '/500') {\n        params.onClient();\n        params.onServer();\n        return;\n    }\n    if (isEdgeRuntime(params.pageRuntime)) {\n        params.onClient();\n        params.onEdgeServer();\n        return;\n    }\n    params.onClient();\n    params.onServer();\n    return;\n}\nexport async function createEntrypoints(params) {\n    const { config, pages, pagesDir, isDev, rootDir, rootPaths, appDir, appPaths, pageExtensions } = params;\n    const edgeServer = {};\n    const server = {};\n    const client = {};\n    let middlewareMatchers = undefined;\n    let appPathsPerRoute = {};\n    if (appDir && appPaths) {\n        for(const pathname in appPaths){\n            const normalizedPath = normalizeAppPath(pathname);\n            const actualPath = appPaths[pathname];\n            if (!appPathsPerRoute[normalizedPath]) {\n                appPathsPerRoute[normalizedPath] = [];\n            }\n            appPathsPerRoute[normalizedPath].push(// TODO-APP: refactor to pass the page path from createPagesMapping instead.\n            getPageFromPath(actualPath, pageExtensions).replace(APP_DIR_ALIAS, ''));\n        }\n        // TODO: find a better place to do this\n        normalizeCatchAllRoutes(appPathsPerRoute);\n        // Make sure to sort parallel routes to make the result deterministic.\n        appPathsPerRoute = Object.fromEntries(Object.entries(appPathsPerRoute).map(([k, v])=>[\n                k,\n                v.sort()\n            ]));\n    }\n    const getEntryHandler = (mappings, pagesType)=>async (page)=>{\n            const bundleFile = normalizePagePath(page);\n            const clientBundlePath = posix.join(pagesType, bundleFile);\n            const serverBundlePath = pagesType === PAGE_TYPES.PAGES ? posix.join('pages', bundleFile) : pagesType === PAGE_TYPES.APP ? posix.join('app', bundleFile) : bundleFile.slice(1);\n            const absolutePagePath = mappings[page];\n            // Handle paths that have aliases\n            const pageFilePath = getPageFilePath({\n                absolutePagePath,\n                pagesDir,\n                appDir,\n                rootDir\n            });\n            const isInsideAppDir = !!appDir && (absolutePagePath.startsWith(APP_DIR_ALIAS) || absolutePagePath.startsWith(appDir));\n            const staticInfo = await getStaticInfoIncludingLayouts({\n                isInsideAppDir,\n                pageExtensions,\n                pageFilePath,\n                appDir,\n                config,\n                isDev,\n                page\n            });\n            // TODO(timneutkens): remove this\n            const isServerComponent = isInsideAppDir && staticInfo.rsc !== RSC_MODULE_TYPES.client;\n            if (isMiddlewareFile(page)) {\n                var _staticInfo_middleware;\n                middlewareMatchers = ((_staticInfo_middleware = staticInfo.middleware) == null ? void 0 : _staticInfo_middleware.matchers) ?? [\n                    {\n                        regexp: '.*',\n                        originalSource: '/:path*'\n                    }\n                ];\n            }\n            const isInstrumentation = isInstrumentationHookFile(page) && pagesType === PAGE_TYPES.ROOT;\n            let pageRuntime = staticInfo == null ? void 0 : staticInfo.runtime;\n            if (isMiddlewareFile(page) && !config.experimental.nodeMiddleware && pageRuntime === 'nodejs') {\n                Log.warn('nodejs runtime support for middleware requires experimental.nodeMiddleware be enabled in your next.config');\n                pageRuntime = 'edge';\n            }\n            runDependingOnPageType({\n                page,\n                pageRuntime: staticInfo.runtime,\n                pageType: pagesType,\n                onClient: ()=>{\n                    if (isServerComponent || isInsideAppDir) {\n                    // We skip the initial entries for server component pages and let the\n                    // server compiler inject them instead.\n                    } else {\n                        client[clientBundlePath] = getClientEntry({\n                            absolutePagePath,\n                            page\n                        });\n                    }\n                },\n                onServer: ()=>{\n                    if (pagesType === 'app' && appDir) {\n                        const matchedAppPaths = appPathsPerRoute[normalizeAppPath(page)];\n                        server[serverBundlePath] = getAppEntry({\n                            page,\n                            name: serverBundlePath,\n                            pagePath: absolutePagePath,\n                            appDir,\n                            appPaths: matchedAppPaths,\n                            pageExtensions,\n                            basePath: config.basePath,\n                            assetPrefix: config.assetPrefix,\n                            nextConfigOutput: config.output,\n                            nextConfigExperimentalUseEarlyImport: config.experimental.useEarlyImport ? true : undefined,\n                            preferredRegion: staticInfo.preferredRegion,\n                            middlewareConfig: encodeToBase64(staticInfo.middleware || {})\n                        });\n                    } else if (isInstrumentation) {\n                        server[serverBundlePath.replace('src/', '')] = getInstrumentationEntry({\n                            absolutePagePath,\n                            isEdgeServer: false,\n                            isDev: false\n                        });\n                    } else if (isMiddlewareFile(page)) {\n                        server[serverBundlePath.replace('src/', '')] = getEdgeServerEntry({\n                            ...params,\n                            rootDir,\n                            absolutePagePath: absolutePagePath,\n                            bundlePath: clientBundlePath,\n                            isDev: false,\n                            isServerComponent,\n                            page,\n                            middleware: staticInfo == null ? void 0 : staticInfo.middleware,\n                            pagesType,\n                            preferredRegion: staticInfo.preferredRegion,\n                            middlewareConfig: staticInfo.middleware\n                        });\n                    } else if (isAPIRoute(page)) {\n                        server[serverBundlePath] = [\n                            getRouteLoaderEntry({\n                                kind: RouteKind.PAGES_API,\n                                page,\n                                absolutePagePath,\n                                preferredRegion: staticInfo.preferredRegion,\n                                middlewareConfig: staticInfo.middleware || {}\n                            })\n                        ];\n                    } else if (!isMiddlewareFile(page) && !isInternalComponent(absolutePagePath) && !isNonRoutePagesPage(page)) {\n                        server[serverBundlePath] = [\n                            getRouteLoaderEntry({\n                                kind: RouteKind.PAGES,\n                                page,\n                                pages,\n                                absolutePagePath,\n                                preferredRegion: staticInfo.preferredRegion,\n                                middlewareConfig: staticInfo.middleware ?? {}\n                            })\n                        ];\n                    } else {\n                        server[serverBundlePath] = [\n                            absolutePagePath\n                        ];\n                    }\n                },\n                onEdgeServer: ()=>{\n                    let appDirLoader = '';\n                    if (isInstrumentation) {\n                        edgeServer[serverBundlePath.replace('src/', '')] = getInstrumentationEntry({\n                            absolutePagePath,\n                            isEdgeServer: true,\n                            isDev: false\n                        });\n                    } else {\n                        if (pagesType === 'app') {\n                            const matchedAppPaths = appPathsPerRoute[normalizeAppPath(page)];\n                            appDirLoader = getAppEntry({\n                                name: serverBundlePath,\n                                page,\n                                pagePath: absolutePagePath,\n                                appDir: appDir,\n                                appPaths: matchedAppPaths,\n                                pageExtensions,\n                                basePath: config.basePath,\n                                assetPrefix: config.assetPrefix,\n                                nextConfigOutput: config.output,\n                                // This isn't used with edge as it needs to be set on the entry module, which will be the `edgeServerEntry` instead.\n                                // Still passing it here for consistency.\n                                preferredRegion: staticInfo.preferredRegion,\n                                middlewareConfig: Buffer.from(JSON.stringify(staticInfo.middleware || {})).toString('base64')\n                            }).import;\n                        }\n                        edgeServer[serverBundlePath] = getEdgeServerEntry({\n                            ...params,\n                            rootDir,\n                            absolutePagePath: absolutePagePath,\n                            bundlePath: clientBundlePath,\n                            isDev: false,\n                            isServerComponent,\n                            page,\n                            middleware: staticInfo == null ? void 0 : staticInfo.middleware,\n                            pagesType,\n                            appDirLoader,\n                            preferredRegion: staticInfo.preferredRegion,\n                            middlewareConfig: staticInfo.middleware\n                        });\n                    }\n                }\n            });\n        };\n    const promises = [];\n    if (appPaths) {\n        const entryHandler = getEntryHandler(appPaths, PAGE_TYPES.APP);\n        promises.push(Promise.all(Object.keys(appPaths).map(entryHandler)));\n    }\n    if (rootPaths) {\n        promises.push(Promise.all(Object.keys(rootPaths).map(getEntryHandler(rootPaths, PAGE_TYPES.ROOT))));\n    }\n    promises.push(Promise.all(Object.keys(pages).map(getEntryHandler(pages, PAGE_TYPES.PAGES))));\n    await Promise.all(promises);\n    // Optimization: If there's only one instrumentation hook in edge compiler, which means there's no edge server entry.\n    // We remove the edge instrumentation entry from edge compiler as it can be pure server side.\n    if (edgeServer.instrumentation && Object.keys(edgeServer).length === 1) {\n        delete edgeServer.instrumentation;\n    }\n    return {\n        client,\n        server,\n        edgeServer,\n        middlewareMatchers\n    };\n}\nexport function finalizeEntrypoint({ name, compilerType, value, isServerComponent, hasAppDir }) {\n    const entry = typeof value !== 'object' || Array.isArray(value) ? {\n        import: value\n    } : value;\n    const isApi = name.startsWith('pages/api/');\n    const isInstrumentation = isInstrumentationHookFilename(name);\n    switch(compilerType){\n        case COMPILER_NAMES.server:\n            {\n                const layer = isApi ? WEBPACK_LAYERS.apiNode : isInstrumentation ? WEBPACK_LAYERS.instrument : isServerComponent ? WEBPACK_LAYERS.reactServerComponents : name.startsWith('pages/') ? WEBPACK_LAYERS.pagesDirNode : undefined;\n                return {\n                    publicPath: isApi ? '' : undefined,\n                    runtime: isApi ? 'webpack-api-runtime' : 'webpack-runtime',\n                    layer,\n                    ...entry\n                };\n            }\n        case COMPILER_NAMES.edgeServer:\n            {\n                return {\n                    layer: isApi ? WEBPACK_LAYERS.apiEdge : isMiddlewareFilename(name) || isInstrumentation ? WEBPACK_LAYERS.middleware : name.startsWith('pages/') ? WEBPACK_LAYERS.pagesDirEdge : undefined,\n                    library: {\n                        name: [\n                            '_ENTRIES',\n                            `middleware_[name]`\n                        ],\n                        type: 'assign'\n                    },\n                    runtime: EDGE_RUNTIME_WEBPACK,\n                    asyncChunks: false,\n                    ...entry\n                };\n            }\n        case COMPILER_NAMES.client:\n            {\n                const isAppLayer = hasAppDir && (name === CLIENT_STATIC_FILES_RUNTIME_MAIN_APP || name === APP_CLIENT_INTERNALS || name.startsWith('app/'));\n                if (// Client special cases\n                name !== CLIENT_STATIC_FILES_RUNTIME_POLYFILLS && name !== CLIENT_STATIC_FILES_RUNTIME_MAIN && name !== CLIENT_STATIC_FILES_RUNTIME_MAIN_APP && name !== CLIENT_STATIC_FILES_RUNTIME_AMP && name !== CLIENT_STATIC_FILES_RUNTIME_REACT_REFRESH) {\n                    if (isAppLayer) {\n                        return {\n                            dependOn: CLIENT_STATIC_FILES_RUNTIME_MAIN_APP,\n                            layer: WEBPACK_LAYERS.appPagesBrowser,\n                            ...entry\n                        };\n                    }\n                    return {\n                        dependOn: name.startsWith('pages/') && name !== 'pages/_app' ? 'pages/_app' : CLIENT_STATIC_FILES_RUNTIME_MAIN,\n                        layer: WEBPACK_LAYERS.pagesDirBrowser,\n                        ...entry\n                    };\n                }\n                if (isAppLayer) {\n                    return {\n                        layer: WEBPACK_LAYERS.appPagesBrowser,\n                        ...entry\n                    };\n                }\n                return {\n                    layer: WEBPACK_LAYERS.pagesDirBrowser,\n                    ...entry\n                };\n            }\n        default:\n            {\n                // Should never happen.\n                throw Object.defineProperty(new Error('Invalid compiler type'), \"__NEXT_ERROR_CODE\", {\n                    value: \"E498\",\n                    enumerable: false,\n                    configurable: true\n                });\n            }\n    }\n}\n\n//# sourceMappingURL=entries.js.map"
        }
    ]
}