{
    "sourceFile": "node_modules/next/dist/esm/build/normalize-catchall-routes.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892747596,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import { isInterceptionRouteAppPath } from '../shared/lib/router/utils/interception-routes';\nimport { AppPathnameNormalizer } from '../server/normalizers/built/app/app-pathname-normalizer';\n/**\n * This function will transform the appPaths in order to support catch-all routes and parallel routes.\n * It will traverse the appPaths, looking for catch-all routes and try to find parallel routes that could match\n * the catch-all. If it finds a match, it will add the catch-all to the parallel route's list of possible routes.\n *\n * @param appPaths The appPaths to transform\n */ export function normalizeCatchAllRoutes(appPaths, normalizer = new AppPathnameNormalizer()) {\n    const catchAllRoutes = [\n        ...new Set(Object.values(appPaths).flat().filter(isCatchAllRoute)// Sorting is important because we want to match the most specific path.\n        .sort((a, b)=>b.split('/').length - a.split('/').length))\n    ];\n    // interception routes should only be matched by a single entrypoint\n    // we don't want to push a catch-all route to an interception route\n    // because it would mean the interception would be handled by the wrong page component\n    const filteredAppPaths = Object.keys(appPaths).filter((route)=>!isInterceptionRouteAppPath(route));\n    for (const appPath of filteredAppPaths){\n        for (const catchAllRoute of catchAllRoutes){\n            const normalizedCatchAllRoute = normalizer.normalize(catchAllRoute);\n            const normalizedCatchAllRouteBasePath = normalizedCatchAllRoute.slice(0, normalizedCatchAllRoute.search(catchAllRouteRegex));\n            if (// check if the appPath could match the catch-all\n            appPath.startsWith(normalizedCatchAllRouteBasePath) && // check if there's not already a slot value that could match the catch-all\n            !appPaths[appPath].some((path)=>hasMatchedSlots(path, catchAllRoute))) {\n                // optional catch-all routes are not currently supported, but leaving this logic in place\n                // for when they are eventually supported.\n                if (isOptionalCatchAll(catchAllRoute)) {\n                    // optional catch-all routes should match both the root segment and any segment after it\n                    // for example, `/[[...slug]]` should match `/` and `/foo` and `/foo/bar`\n                    appPaths[appPath].push(catchAllRoute);\n                } else if (isCatchAll(catchAllRoute)) {\n                    // regular catch-all (single bracket) should only match segments after it\n                    // for example, `/[...slug]` should match `/foo` and `/foo/bar` but not `/`\n                    if (normalizedCatchAllRouteBasePath !== appPath) {\n                        appPaths[appPath].push(catchAllRoute);\n                    }\n                }\n            }\n        }\n    }\n}\nfunction hasMatchedSlots(path1, path2) {\n    const slots1 = path1.split('/').filter(isMatchableSlot);\n    const slots2 = path2.split('/').filter(isMatchableSlot);\n    // if the catch-all route does not have the same number of slots as the app path, it can't match\n    if (slots1.length !== slots2.length) return false;\n    // compare the slots in both paths. For there to be a match, each slot must be the same\n    for(let i = 0; i < slots1.length; i++){\n        if (slots1[i] !== slots2[i]) return false;\n    }\n    return true;\n}\n/**\n * Returns true for slots that should be considered when checking for match compatibility.\n * Excludes children slots because these are similar to having a segment-level `page`\n * which would cause a slot length mismatch when comparing it to a catch-all route.\n */ function isMatchableSlot(segment) {\n    return segment.startsWith('@') && segment !== '@children';\n}\nconst catchAllRouteRegex = /\\[?\\[\\.\\.\\./;\nfunction isCatchAllRoute(pathname) {\n    // Optional catch-all slots are not currently supported, and as such they are not considered when checking for match compatability.\n    return !isOptionalCatchAll(pathname) && isCatchAll(pathname);\n}\nfunction isOptionalCatchAll(pathname) {\n    return pathname.includes('[[...');\n}\nfunction isCatchAll(pathname) {\n    return pathname.includes('[...');\n}\n\n//# sourceMappingURL=normalize-catchall-routes.js.map"
        }
    ]
}