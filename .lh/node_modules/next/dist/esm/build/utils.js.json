{
    "sourceFile": "node_modules/next/dist/esm/build/utils.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892751755,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import '../server/require-hook';\nimport '../server/node-polyfill-crypto';\nimport '../server/node-environment';\nimport { green, yellow, red, cyan, white, bold, underline } from '../lib/picocolors';\nimport getGzipSize from 'next/dist/compiled/gzip-size';\nimport textTable from 'next/dist/compiled/text-table';\nimport path from 'path';\nimport { promises as fs } from 'fs';\nimport { isValidElementType } from 'next/dist/compiled/react-is';\nimport stripAnsi from 'next/dist/compiled/strip-ansi';\nimport browserslist from 'next/dist/compiled/browserslist';\nimport { SSG_GET_INITIAL_PROPS_CONFLICT, SERVER_PROPS_GET_INIT_PROPS_CONFLICT, SERVER_PROPS_SSG_CONFLICT, MIDDLEWARE_FILENAME, INSTRUMENTATION_HOOK_FILENAME, WEBPACK_LAYERS } from '../lib/constants';\nimport { MODERN_BROWSERSLIST_TARGET, UNDERSCORE_NOT_FOUND_ROUTE } from '../shared/lib/constants';\nimport prettyBytes from '../lib/pretty-bytes';\nimport { isDynamicRoute } from '../shared/lib/router/utils/is-dynamic';\nimport { findPageFile } from '../server/lib/find-page-file';\nimport { isEdgeRuntime } from '../lib/is-edge-runtime';\nimport * as Log from './output/log';\nimport { loadComponents } from '../server/load-components';\nimport { trace } from '../trace';\nimport { setHttpClientAndAgentOptions } from '../server/setup-http-agent-env';\nimport { Sema } from 'next/dist/compiled/async-sema';\nimport { denormalizePagePath } from '../shared/lib/page-path/denormalize-page-path';\nimport { normalizePagePath } from '../shared/lib/page-path/normalize-page-path';\nimport { getRuntimeContext } from '../server/web/sandbox';\nimport { isClientReference } from '../lib/client-and-server-references';\nimport { normalizeAppPath } from '../shared/lib/router/utils/app-paths';\nimport { denormalizeAppPagePath } from '../shared/lib/page-path/denormalize-app-path';\nimport { RouteKind } from '../server/route-kind';\nimport { isInterceptionRouteAppPath } from '../shared/lib/router/utils/interception-routes';\nimport { checkIsRoutePPREnabled } from '../server/lib/experimental/ppr';\nimport { collectSegments } from './segment-config/app/app-segments';\nimport { createIncrementalCache } from '../export/helpers/create-incremental-cache';\nimport { collectRootParamKeys } from './segment-config/app/collect-root-param-keys';\nimport { buildAppStaticPaths } from './static-paths/app';\nimport { buildPagesStaticPaths } from './static-paths/pages';\nimport { formatExpire, formatRevalidate } from './output/format';\n// Use `print()` for expected console output\nconst print = console.log;\nconst RESERVED_PAGE = /^\\/(_app|_error|_document|api(\\/|$))/;\nconst fileGzipStats = {};\nconst fsStatGzip = (file)=>{\n    const cached = fileGzipStats[file];\n    if (cached) return cached;\n    return fileGzipStats[file] = getGzipSize.file(file);\n};\nconst fileSize = async (file)=>(await fs.stat(file)).size;\nconst fileStats = {};\nconst fsStat = (file)=>{\n    const cached = fileStats[file];\n    if (cached) return cached;\n    return fileStats[file] = fileSize(file);\n};\nexport function unique(main, sub) {\n    return [\n        ...new Set([\n            ...main,\n            ...sub\n        ])\n    ];\n}\nexport function difference(main, sub) {\n    const a = new Set(main);\n    const b = new Set(sub);\n    return [\n        ...a\n    ].filter((x)=>!b.has(x));\n}\n/**\n * Return an array of the items shared by both arrays.\n */ function intersect(main, sub) {\n    const a = new Set(main);\n    const b = new Set(sub);\n    return [\n        ...new Set([\n            ...a\n        ].filter((x)=>b.has(x)))\n    ];\n}\nfunction sum(a) {\n    return a.reduce((size, stat)=>size + stat, 0);\n}\nlet cachedBuildManifest;\nlet cachedAppBuildManifest;\nlet lastCompute;\nlet lastComputePageInfo;\nexport async function computeFromManifest(manifests, distPath, gzipSize = true, pageInfos) {\n    var _manifests_app, _files_app;\n    if (Object.is(cachedBuildManifest, manifests.build) && lastComputePageInfo === !!pageInfos && Object.is(cachedAppBuildManifest, manifests.app)) {\n        return lastCompute;\n    }\n    // Determine the files that are in pages and app and count them, this will\n    // tell us if they are unique or common.\n    const countBuildFiles = (map, key, manifest)=>{\n        for (const file of manifest[key]){\n            if (key === '/_app') {\n                map.set(file, Infinity);\n            } else if (map.has(file)) {\n                map.set(file, map.get(file) + 1);\n            } else {\n                map.set(file, 1);\n            }\n        }\n    };\n    const files = {\n        pages: {\n            each: new Map(),\n            expected: 0\n        }\n    };\n    for(const key in manifests.build.pages){\n        if (pageInfos) {\n            const pageInfo = pageInfos.get(key);\n            // don't include AMP pages since they don't rely on shared bundles\n            // AMP First pages are not under the pageInfos key\n            if (pageInfo == null ? void 0 : pageInfo.isHybridAmp) {\n                continue;\n            }\n        }\n        files.pages.expected++;\n        countBuildFiles(files.pages.each, key, manifests.build.pages);\n    }\n    // Collect the build files form the app manifest.\n    if ((_manifests_app = manifests.app) == null ? void 0 : _manifests_app.pages) {\n        files.app = {\n            each: new Map(),\n            expected: 0\n        };\n        for(const key in manifests.app.pages){\n            files.app.expected++;\n            countBuildFiles(files.app.each, key, manifests.app.pages);\n        }\n    }\n    const getSize = gzipSize ? fsStatGzip : fsStat;\n    const stats = new Map();\n    // For all of the files in the pages and app manifests, compute the file size\n    // at once.\n    await Promise.all([\n        ...new Set([\n            ...files.pages.each.keys(),\n            ...((_files_app = files.app) == null ? void 0 : _files_app.each.keys()) ?? []\n        ])\n    ].map(async (f)=>{\n        try {\n            // Add the file size to the stats.\n            stats.set(f, await getSize(path.join(distPath, f)));\n        } catch  {}\n    }));\n    const groupFiles = async (listing)=>{\n        const entries = [\n            ...listing.each.entries()\n        ];\n        const shapeGroup = (group)=>group.reduce((acc, [f])=>{\n                acc.files.push(f);\n                const size = stats.get(f);\n                if (typeof size === 'number') {\n                    acc.size.total += size;\n                }\n                return acc;\n            }, {\n                files: [],\n                size: {\n                    total: 0\n                }\n            });\n        return {\n            unique: shapeGroup(entries.filter(([, len])=>len === 1)),\n            common: shapeGroup(entries.filter(([, len])=>len === listing.expected || len === Infinity))\n        };\n    };\n    lastCompute = {\n        router: {\n            pages: await groupFiles(files.pages),\n            app: files.app ? await groupFiles(files.app) : undefined\n        },\n        sizes: stats\n    };\n    cachedBuildManifest = manifests.build;\n    cachedAppBuildManifest = manifests.app;\n    lastComputePageInfo = !!pageInfos;\n    return lastCompute;\n}\nexport function isMiddlewareFilename(file) {\n    return file === MIDDLEWARE_FILENAME || file === `src/${MIDDLEWARE_FILENAME}`;\n}\nexport function isInstrumentationHookFilename(file) {\n    return file === INSTRUMENTATION_HOOK_FILENAME || file === `src/${INSTRUMENTATION_HOOK_FILENAME}`;\n}\nconst filterAndSortList = (list, routeType, hasCustomApp)=>{\n    let pages;\n    if (routeType === 'app') {\n        // filter out static app route of /favicon.ico\n        pages = list.filter((e)=>e !== '/favicon.ico');\n    } else {\n        // filter built-in pages\n        pages = list.slice().filter((e)=>!(e === '/_document' || e === '/_error' || !hasCustomApp && e === '/_app'));\n    }\n    return pages.sort((a, b)=>a.localeCompare(b));\n};\nexport function collectRoutesUsingEdgeRuntime(input) {\n    const routesUsingEdgeRuntime = {};\n    for (const [route, info] of input.entries()){\n        if (isEdgeRuntime(info.runtime)) {\n            routesUsingEdgeRuntime[route] = 0;\n        }\n    }\n    return routesUsingEdgeRuntime;\n}\nexport async function printTreeView(lists, pageInfos, { distPath, buildId, pagesDir, pageExtensions, buildManifest, appBuildManifest, middlewareManifest, useStaticPages404, gzipSize = true }) {\n    var _lists_app, _middlewareManifest_middleware;\n    const getPrettySize = (_size, { strong } = {})=>{\n        const size = process.env.__NEXT_PRIVATE_DETERMINISTIC_BUILD_OUTPUT ? 'N/A kB' : prettyBytes(_size);\n        return strong ? white(bold(size)) : size;\n    };\n    // Can be overridden for test purposes to omit the build duration output.\n    const MIN_DURATION = process.env.__NEXT_PRIVATE_DETERMINISTIC_BUILD_OUTPUT ? Infinity // Don't ever log build durations.\n     : 300;\n    const getPrettyDuration = (_duration)=>{\n        const duration = `${_duration} ms`;\n        // green for 300-1000ms\n        if (_duration < 1000) return green(duration);\n        // yellow for 1000-2000ms\n        if (_duration < 2000) return yellow(duration);\n        // red for >= 2000ms\n        return red(bold(duration));\n    };\n    const getCleanName = (fileName)=>fileName// Trim off `static/`\n        .replace(/^static\\//, '')// Re-add `static/` for root files\n        .replace(/^<buildId>/, 'static')// Remove file hash\n        .replace(/(?:^|[.-])([0-9a-z]{6})[0-9a-z]{14}(?=\\.)/, '.$1');\n    // Check if we have a custom app.\n    const hasCustomApp = !!(pagesDir && await findPageFile(pagesDir, '/_app', pageExtensions, false));\n    // Collect all the symbols we use so we can print the icons out.\n    const usedSymbols = new Set();\n    const messages = [];\n    const stats = await computeFromManifest({\n        build: buildManifest,\n        app: appBuildManifest\n    }, distPath, gzipSize, pageInfos);\n    const printFileTree = async ({ list, routerType })=>{\n        var _stats_router_routerType, _stats_router_routerType1;\n        const filteredPages = filterAndSortList(list, routerType, hasCustomApp);\n        if (filteredPages.length === 0) {\n            return;\n        }\n        let showRevalidate = false;\n        let showExpire = false;\n        for (const page of filteredPages){\n            var _pageInfos_get;\n            const cacheControl = (_pageInfos_get = pageInfos.get(page)) == null ? void 0 : _pageInfos_get.initialCacheControl;\n            if (cacheControl == null ? void 0 : cacheControl.revalidate) {\n                showRevalidate = true;\n            }\n            if (cacheControl == null ? void 0 : cacheControl.expire) {\n                showExpire = true;\n            }\n            if (showRevalidate && showExpire) {\n                break;\n            }\n        }\n        messages.push([\n            routerType === 'app' ? 'Route (app)' : 'Route (pages)',\n            'Size',\n            'First Load JS',\n            showRevalidate ? 'Revalidate' : '',\n            showExpire ? 'Expire' : ''\n        ].map((entry)=>underline(entry)));\n        filteredPages.forEach((item, i, arr)=>{\n            var _pageInfo_ssgPageDurations, _buildManifest_pages_item, _pageInfo_ssgPageRoutes;\n            const border = i === 0 ? arr.length === 1 ? '─' : '┌' : i === arr.length - 1 ? '└' : '├';\n            const pageInfo = pageInfos.get(item);\n            const ampFirst = buildManifest.ampFirstPages.includes(item);\n            const totalDuration = ((pageInfo == null ? void 0 : pageInfo.pageDuration) || 0) + ((pageInfo == null ? void 0 : (_pageInfo_ssgPageDurations = pageInfo.ssgPageDurations) == null ? void 0 : _pageInfo_ssgPageDurations.reduce((a, b)=>a + (b || 0), 0)) || 0);\n            let symbol;\n            if (item === '/_app' || item === '/_app.server') {\n                symbol = ' ';\n            } else if (isEdgeRuntime(pageInfo == null ? void 0 : pageInfo.runtime)) {\n                symbol = 'ƒ';\n            } else if (pageInfo == null ? void 0 : pageInfo.isRoutePPREnabled) {\n                if (// If the page has an empty prelude, then it's equivalent to a dynamic page\n                (pageInfo == null ? void 0 : pageInfo.hasEmptyPrelude) || // ensure we don't mark dynamic paths that postponed as being dynamic\n                // since in this case we're able to partially prerender it\n                pageInfo.isDynamicAppRoute && !pageInfo.hasPostponed) {\n                    symbol = 'ƒ';\n                } else if (!(pageInfo == null ? void 0 : pageInfo.hasPostponed)) {\n                    symbol = '○';\n                } else {\n                    symbol = '◐';\n                }\n            } else if (pageInfo == null ? void 0 : pageInfo.isStatic) {\n                symbol = '○';\n            } else if (pageInfo == null ? void 0 : pageInfo.isSSG) {\n                symbol = '●';\n            } else {\n                symbol = 'ƒ';\n            }\n            usedSymbols.add(symbol);\n            messages.push([\n                `${border} ${symbol} ${item}${totalDuration > MIN_DURATION ? ` (${getPrettyDuration(totalDuration)})` : ''}`,\n                pageInfo ? ampFirst ? cyan('AMP') : pageInfo.size >= 0 ? getPrettySize(pageInfo.size) : '' : '',\n                pageInfo ? ampFirst ? cyan('AMP') : pageInfo.size >= 0 ? getPrettySize(pageInfo.totalSize, {\n                    strong: true\n                }) : '' : '',\n                showRevalidate && (pageInfo == null ? void 0 : pageInfo.initialCacheControl) ? formatRevalidate(pageInfo.initialCacheControl) : '',\n                showExpire && (pageInfo == null ? void 0 : pageInfo.initialCacheControl) ? formatExpire(pageInfo.initialCacheControl) : ''\n            ]);\n            const uniqueCssFiles = ((_buildManifest_pages_item = buildManifest.pages[item]) == null ? void 0 : _buildManifest_pages_item.filter((file)=>{\n                var _stats_router_routerType;\n                return file.endsWith('.css') && ((_stats_router_routerType = stats.router[routerType]) == null ? void 0 : _stats_router_routerType.unique.files.includes(file));\n            })) || [];\n            if (uniqueCssFiles.length > 0) {\n                const contSymbol = i === arr.length - 1 ? ' ' : '├';\n                uniqueCssFiles.forEach((file, index, { length })=>{\n                    const innerSymbol = index === length - 1 ? '└' : '├';\n                    const size = stats.sizes.get(file);\n                    messages.push([\n                        `${contSymbol}   ${innerSymbol} ${getCleanName(file)}`,\n                        typeof size === 'number' ? getPrettySize(size) : '',\n                        '',\n                        '',\n                        ''\n                    ]);\n                });\n            }\n            if (pageInfo == null ? void 0 : (_pageInfo_ssgPageRoutes = pageInfo.ssgPageRoutes) == null ? void 0 : _pageInfo_ssgPageRoutes.length) {\n                const totalRoutes = pageInfo.ssgPageRoutes.length;\n                const contSymbol = i === arr.length - 1 ? ' ' : '├';\n                let routes;\n                if (pageInfo.ssgPageDurations && pageInfo.ssgPageDurations.some((d)=>d > MIN_DURATION)) {\n                    const previewPages = totalRoutes === 8 ? 8 : Math.min(totalRoutes, 7);\n                    const routesWithDuration = pageInfo.ssgPageRoutes.map((route, idx)=>({\n                            route,\n                            duration: pageInfo.ssgPageDurations[idx] || 0\n                        })).sort(({ duration: a }, { duration: b })=>// Sort by duration\n                        // keep too small durations in original order at the end\n                        a <= MIN_DURATION && b <= MIN_DURATION ? 0 : b - a);\n                    routes = routesWithDuration.slice(0, previewPages);\n                    const remainingRoutes = routesWithDuration.slice(previewPages);\n                    if (remainingRoutes.length) {\n                        const remaining = remainingRoutes.length;\n                        const avgDuration = Math.round(remainingRoutes.reduce((total, { duration })=>total + duration, 0) / remainingRoutes.length);\n                        routes.push({\n                            route: `[+${remaining} more paths]`,\n                            duration: 0,\n                            avgDuration\n                        });\n                    }\n                } else {\n                    const previewPages = totalRoutes === 4 ? 4 : Math.min(totalRoutes, 3);\n                    routes = pageInfo.ssgPageRoutes.slice(0, previewPages).map((route)=>({\n                            route,\n                            duration: 0\n                        }));\n                    if (totalRoutes > previewPages) {\n                        const remaining = totalRoutes - previewPages;\n                        routes.push({\n                            route: `[+${remaining} more paths]`,\n                            duration: 0\n                        });\n                    }\n                }\n                routes.forEach(({ route, duration, avgDuration }, index, { length })=>{\n                    var _pageInfos_get;\n                    const innerSymbol = index === length - 1 ? '└' : '├';\n                    const initialCacheControl = (_pageInfos_get = pageInfos.get(route)) == null ? void 0 : _pageInfos_get.initialCacheControl;\n                    messages.push([\n                        `${contSymbol}   ${innerSymbol} ${route}${duration > MIN_DURATION ? ` (${getPrettyDuration(duration)})` : ''}${avgDuration && avgDuration > MIN_DURATION ? ` (avg ${getPrettyDuration(avgDuration)})` : ''}`,\n                        '',\n                        '',\n                        showRevalidate && initialCacheControl ? formatRevalidate(initialCacheControl) : '',\n                        showExpire && initialCacheControl ? formatExpire(initialCacheControl) : ''\n                    ]);\n                });\n            }\n        });\n        const sharedFilesSize = (_stats_router_routerType = stats.router[routerType]) == null ? void 0 : _stats_router_routerType.common.size.total;\n        const sharedFiles = process.env.__NEXT_PRIVATE_DETERMINISTIC_BUILD_OUTPUT ? [] : ((_stats_router_routerType1 = stats.router[routerType]) == null ? void 0 : _stats_router_routerType1.common.files) ?? [];\n        messages.push([\n            '+ First Load JS shared by all',\n            typeof sharedFilesSize === 'number' ? getPrettySize(sharedFilesSize, {\n                strong: true\n            }) : '',\n            '',\n            '',\n            ''\n        ]);\n        const sharedCssFiles = [];\n        const sharedJsChunks = [\n            ...sharedFiles.filter((file)=>{\n                if (file.endsWith('.css')) {\n                    sharedCssFiles.push(file);\n                    return false;\n                }\n                return true;\n            }).map((e)=>e.replace(buildId, '<buildId>')).sort(),\n            ...sharedCssFiles.map((e)=>e.replace(buildId, '<buildId>')).sort()\n        ];\n        // if the some chunk are less than 10kb or we don't know the size, we only show the total size of the rest\n        const tenKbLimit = 10 * 1000;\n        let restChunkSize = 0;\n        let restChunkCount = 0;\n        sharedJsChunks.forEach((fileName, index, { length })=>{\n            const innerSymbol = index + restChunkCount === length - 1 ? '└' : '├';\n            const originalName = fileName.replace('<buildId>', buildId);\n            const cleanName = getCleanName(fileName);\n            const size = stats.sizes.get(originalName);\n            if (!size || size < tenKbLimit) {\n                restChunkCount++;\n                restChunkSize += size || 0;\n                return;\n            }\n            messages.push([\n                `  ${innerSymbol} ${cleanName}`,\n                getPrettySize(size),\n                '',\n                '',\n                ''\n            ]);\n        });\n        if (restChunkCount > 0) {\n            messages.push([\n                `  └ other shared chunks (total)`,\n                getPrettySize(restChunkSize),\n                '',\n                '',\n                ''\n            ]);\n        }\n    };\n    // If enabled, then print the tree for the app directory.\n    if (lists.app && stats.router.app) {\n        await printFileTree({\n            routerType: 'app',\n            list: lists.app\n        });\n        messages.push([\n            '',\n            '',\n            '',\n            '',\n            ''\n        ]);\n    }\n    pageInfos.set('/404', {\n        ...pageInfos.get('/404') || pageInfos.get('/_error'),\n        isStatic: useStaticPages404\n    });\n    // If there's no app /_notFound page present, then the 404 is still using the pages/404\n    if (!lists.pages.includes('/404') && !((_lists_app = lists.app) == null ? void 0 : _lists_app.includes(UNDERSCORE_NOT_FOUND_ROUTE))) {\n        lists.pages = [\n            ...lists.pages,\n            '/404'\n        ];\n    }\n    // Print the tree view for the pages directory.\n    await printFileTree({\n        routerType: 'pages',\n        list: lists.pages\n    });\n    const middlewareInfo = (_middlewareManifest_middleware = middlewareManifest.middleware) == null ? void 0 : _middlewareManifest_middleware['/'];\n    if ((middlewareInfo == null ? void 0 : middlewareInfo.files.length) > 0) {\n        const middlewareSizes = await Promise.all(middlewareInfo.files.map((dep)=>`${distPath}/${dep}`).map(gzipSize ? fsStatGzip : fsStat));\n        messages.push([\n            '',\n            '',\n            '',\n            '',\n            ''\n        ]);\n        messages.push([\n            'ƒ Middleware',\n            getPrettySize(sum(middlewareSizes), {\n                strong: true\n            }),\n            '',\n            '',\n            ''\n        ]);\n    }\n    print(textTable(messages, {\n        align: [\n            'l',\n            'r',\n            'r',\n            'r',\n            'r'\n        ],\n        stringLength: (str)=>stripAnsi(str).length\n    }));\n    const staticFunctionInfo = lists.app && stats.router.app ? 'generateStaticParams' : 'getStaticProps';\n    print();\n    print(textTable([\n        usedSymbols.has('○') && [\n            '○',\n            '(Static)',\n            'prerendered as static content'\n        ],\n        usedSymbols.has('●') && [\n            '●',\n            '(SSG)',\n            `prerendered as static HTML (uses ${cyan(staticFunctionInfo)})`\n        ],\n        usedSymbols.has('◐') && [\n            '◐',\n            '(Partial Prerender)',\n            'prerendered as static HTML with dynamic server-streamed content'\n        ],\n        usedSymbols.has('ƒ') && [\n            'ƒ',\n            '(Dynamic)',\n            `server-rendered on demand`\n        ]\n    ].filter((x)=>x), {\n        align: [\n            'l',\n            'l',\n            'l'\n        ],\n        stringLength: (str)=>stripAnsi(str).length\n    }));\n    print();\n}\nexport function printCustomRoutes({ redirects, rewrites, headers }) {\n    const printRoutes = (routes, type)=>{\n        const isRedirects = type === 'Redirects';\n        const isHeaders = type === 'Headers';\n        print(underline(type));\n        /*\n        ┌ source\n        ├ permanent/statusCode\n        └ destination\n     */ const routesStr = routes.map((route)=>{\n            let routeStr = `┌ source: ${route.source}\\n`;\n            if (!isHeaders) {\n                const r = route;\n                routeStr += `${isRedirects ? '├' : '└'} destination: ${r.destination}\\n`;\n            }\n            if (isRedirects) {\n                const r = route;\n                routeStr += `└ ${r.statusCode ? `status: ${r.statusCode}` : `permanent: ${r.permanent}`}\\n`;\n            }\n            if (isHeaders) {\n                const r = route;\n                routeStr += `└ headers:\\n`;\n                for(let i = 0; i < r.headers.length; i++){\n                    const header = r.headers[i];\n                    const last = i === headers.length - 1;\n                    routeStr += `  ${last ? '└' : '├'} ${header.key}: ${header.value}\\n`;\n                }\n            }\n            return routeStr;\n        }).join('\\n');\n        print(`${routesStr}\\n`);\n    };\n    print();\n    if (redirects.length) {\n        printRoutes(redirects, 'Redirects');\n    }\n    if (headers.length) {\n        printRoutes(headers, 'Headers');\n    }\n    const combinedRewrites = [\n        ...rewrites.beforeFiles,\n        ...rewrites.afterFiles,\n        ...rewrites.fallback\n    ];\n    if (combinedRewrites.length) {\n        printRoutes(combinedRewrites, 'Rewrites');\n    }\n}\nexport async function getJsPageSizeInKb(routerType, page, distPath, buildManifest, appBuildManifest, gzipSize = true, cachedStats) {\n    const pageManifest = routerType === 'pages' ? buildManifest : appBuildManifest;\n    if (!pageManifest) {\n        throw Object.defineProperty(new Error('expected appBuildManifest with an \"app\" pageType'), \"__NEXT_ERROR_CODE\", {\n            value: \"E29\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    // Normalize appBuildManifest keys\n    if (routerType === 'app') {\n        pageManifest.pages = Object.entries(pageManifest.pages).reduce((acc, [key, value])=>{\n            const newKey = normalizeAppPath(key);\n            acc[newKey] = value;\n            return acc;\n        }, {});\n    }\n    // If stats was not provided, then compute it again.\n    const stats = cachedStats ?? await computeFromManifest({\n        build: buildManifest,\n        app: appBuildManifest\n    }, distPath, gzipSize);\n    const pageData = stats.router[routerType];\n    if (!pageData) {\n        // This error shouldn't happen and represents an error in Next.js.\n        throw Object.defineProperty(new Error('expected \"app\" manifest data with an \"app\" pageType'), \"__NEXT_ERROR_CODE\", {\n            value: \"E76\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    const pagePath = routerType === 'pages' ? denormalizePagePath(page) : denormalizeAppPagePath(page);\n    const fnFilterJs = (entry)=>entry.endsWith('.js');\n    const pageFiles = (pageManifest.pages[pagePath] ?? []).filter(fnFilterJs);\n    const appFiles = (pageManifest.pages['/_app'] ?? []).filter(fnFilterJs);\n    const fnMapRealPath = (dep)=>`${distPath}/${dep}`;\n    const allFilesReal = unique(pageFiles, appFiles).map(fnMapRealPath);\n    const selfFilesReal = difference(// Find the files shared by the pages files and the unique files...\n    intersect(pageFiles, pageData.unique.files), // but without the common files.\n    pageData.common.files).map(fnMapRealPath);\n    const getSize = gzipSize ? fsStatGzip : fsStat;\n    // Try to get the file size from the page data if available, otherwise do a\n    // raw compute.\n    const getCachedSize = async (file)=>{\n        const key = file.slice(distPath.length + 1);\n        const size = stats.sizes.get(key);\n        // If the size wasn't in the stats bundle, then get it from the file\n        // directly.\n        if (typeof size !== 'number') {\n            return getSize(file);\n        }\n        return size;\n    };\n    try {\n        // Doesn't use `Promise.all`, as we'd double compute duplicate files. This\n        // function is memoized, so the second one will instantly resolve.\n        const allFilesSize = sum(await Promise.all(allFilesReal.map(getCachedSize)));\n        const selfFilesSize = sum(await Promise.all(selfFilesReal.map(getCachedSize)));\n        return [\n            selfFilesSize,\n            allFilesSize\n        ];\n    } catch  {}\n    return [\n        -1,\n        -1\n    ];\n}\nexport async function isPageStatic({ dir, page, distDir, configFileName, runtimeEnvConfig, httpAgentOptions, locales, defaultLocale, parentId, pageRuntime, edgeInfo, pageType, dynamicIO, authInterrupts, originalAppPath, isrFlushToDisk, maxMemoryCacheSize, nextConfigOutput, cacheHandler, cacheHandlers, cacheLifeProfiles, pprConfig, buildId, sriEnabled }) {\n    await createIncrementalCache({\n        cacheHandler,\n        cacheHandlers,\n        distDir,\n        dir,\n        flushToDisk: isrFlushToDisk,\n        cacheMaxMemorySize: maxMemoryCacheSize\n    });\n    const isPageStaticSpan = trace('is-page-static-utils', parentId);\n    return isPageStaticSpan.traceAsyncFn(async ()=>{\n        require('../shared/lib/runtime-config.external').setConfig(runtimeEnvConfig);\n        setHttpClientAndAgentOptions({\n            httpAgentOptions\n        });\n        let componentsResult;\n        let prerenderedRoutes;\n        let prerenderFallbackMode;\n        let appConfig = {};\n        let rootParamKeys;\n        let isClientComponent = false;\n        const pathIsEdgeRuntime = isEdgeRuntime(pageRuntime);\n        if (pathIsEdgeRuntime) {\n            const runtime = await getRuntimeContext({\n                paths: edgeInfo.files.map((file)=>path.join(distDir, file)),\n                edgeFunctionEntry: {\n                    ...edgeInfo,\n                    wasm: (edgeInfo.wasm ?? []).map((binding)=>({\n                            ...binding,\n                            filePath: path.join(distDir, binding.filePath)\n                        }))\n                },\n                name: edgeInfo.name,\n                useCache: true,\n                distDir\n            });\n            const mod = (await runtime.context._ENTRIES[`middleware_${edgeInfo.name}`]).ComponentMod;\n            // This is not needed during require.\n            const buildManifest = {};\n            isClientComponent = isClientReference(mod);\n            componentsResult = {\n                Component: mod.default,\n                Document: mod.Document,\n                App: mod.App,\n                routeModule: mod.routeModule,\n                page,\n                ComponentMod: mod,\n                pageConfig: mod.config || {},\n                buildManifest,\n                reactLoadableManifest: {},\n                getServerSideProps: mod.getServerSideProps,\n                getStaticPaths: mod.getStaticPaths,\n                getStaticProps: mod.getStaticProps\n            };\n        } else {\n            componentsResult = await loadComponents({\n                distDir,\n                page: originalAppPath || page,\n                isAppPath: pageType === 'app',\n                isDev: false,\n                sriEnabled\n            });\n        }\n        const Comp = componentsResult.Component;\n        const routeModule = componentsResult.routeModule;\n        let isRoutePPREnabled = false;\n        if (pageType === 'app') {\n            const ComponentMod = componentsResult.ComponentMod;\n            isClientComponent = isClientReference(componentsResult.ComponentMod);\n            let segments;\n            try {\n                segments = await collectSegments(componentsResult);\n            } catch (err) {\n                throw Object.defineProperty(new Error(`Failed to collect configuration for ${page}`, {\n                    cause: err\n                }), \"__NEXT_ERROR_CODE\", {\n                    value: \"E434\",\n                    enumerable: false,\n                    configurable: true\n                });\n            }\n            appConfig = reduceAppConfig(segments);\n            if (appConfig.dynamic === 'force-static' && pathIsEdgeRuntime) {\n                Log.warn(`Page \"${page}\" is using runtime = 'edge' which is currently incompatible with dynamic = 'force-static'. Please remove either \"runtime\" or \"force-static\" for correct behavior`);\n            }\n            rootParamKeys = collectRootParamKeys(componentsResult);\n            // A page supports partial prerendering if it is an app page and either\n            // the whole app has PPR enabled or this page has PPR enabled when we're\n            // in incremental mode.\n            isRoutePPREnabled = routeModule.definition.kind === RouteKind.APP_PAGE && !isInterceptionRouteAppPath(page) && checkIsRoutePPREnabled(pprConfig, appConfig);\n            // If force dynamic was set and we don't have PPR enabled, then set the\n            // revalidate to 0.\n            // TODO: (PPR) remove this once PPR is enabled by default\n            if (appConfig.dynamic === 'force-dynamic' && !isRoutePPREnabled) {\n                appConfig.revalidate = 0;\n            }\n            // If the page is dynamic and we're not in edge runtime, then we need to\n            // build the static paths. The edge runtime doesn't support static\n            // paths.\n            if (isDynamicRoute(page) && !pathIsEdgeRuntime) {\n                ;\n                ({ prerenderedRoutes, fallbackMode: prerenderFallbackMode } = await buildAppStaticPaths({\n                    dir,\n                    page,\n                    dynamicIO,\n                    authInterrupts,\n                    segments,\n                    distDir,\n                    requestHeaders: {},\n                    isrFlushToDisk,\n                    maxMemoryCacheSize,\n                    cacheHandler,\n                    cacheLifeProfiles,\n                    ComponentMod,\n                    nextConfigOutput,\n                    isRoutePPREnabled,\n                    buildId,\n                    rootParamKeys\n                }));\n            }\n        } else {\n            if (!Comp || !isValidElementType(Comp) || typeof Comp === 'string') {\n                throw Object.defineProperty(new Error('INVALID_DEFAULT_EXPORT'), \"__NEXT_ERROR_CODE\", {\n                    value: \"E457\",\n                    enumerable: false,\n                    configurable: true\n                });\n            }\n        }\n        const hasGetInitialProps = !!(Comp == null ? void 0 : Comp.getInitialProps);\n        const hasStaticProps = !!componentsResult.getStaticProps;\n        const hasStaticPaths = !!componentsResult.getStaticPaths;\n        const hasServerProps = !!componentsResult.getServerSideProps;\n        // A page cannot be prerendered _and_ define a data requirement. That's\n        // contradictory!\n        if (hasGetInitialProps && hasStaticProps) {\n            throw Object.defineProperty(new Error(SSG_GET_INITIAL_PROPS_CONFLICT), \"__NEXT_ERROR_CODE\", {\n                value: \"E394\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n        if (hasGetInitialProps && hasServerProps) {\n            throw Object.defineProperty(new Error(SERVER_PROPS_GET_INIT_PROPS_CONFLICT), \"__NEXT_ERROR_CODE\", {\n                value: \"E394\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n        if (hasStaticProps && hasServerProps) {\n            throw Object.defineProperty(new Error(SERVER_PROPS_SSG_CONFLICT), \"__NEXT_ERROR_CODE\", {\n                value: \"E394\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n        const pageIsDynamic = isDynamicRoute(page);\n        // A page cannot have static parameters if it is not a dynamic page.\n        if (hasStaticProps && hasStaticPaths && !pageIsDynamic) {\n            throw Object.defineProperty(new Error(`getStaticPaths can only be used with dynamic pages, not '${page}'.` + `\\nLearn more: https://nextjs.org/docs/routing/dynamic-routes`), \"__NEXT_ERROR_CODE\", {\n                value: \"E356\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n        if (hasStaticProps && pageIsDynamic && !hasStaticPaths) {\n            throw Object.defineProperty(new Error(`getStaticPaths is required for dynamic SSG pages and is missing for '${page}'.` + `\\nRead more: https://nextjs.org/docs/messages/invalid-getstaticpaths-value`), \"__NEXT_ERROR_CODE\", {\n                value: \"E255\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n        if (hasStaticProps && hasStaticPaths) {\n            ;\n            ({ prerenderedRoutes, fallbackMode: prerenderFallbackMode } = await buildPagesStaticPaths({\n                page,\n                locales,\n                defaultLocale,\n                configFileName,\n                getStaticPaths: componentsResult.getStaticPaths\n            }));\n        }\n        const isNextImageImported = globalThis.__NEXT_IMAGE_IMPORTED;\n        const config = isClientComponent ? {} : componentsResult.pageConfig;\n        let isStatic = false;\n        if (!hasStaticProps && !hasGetInitialProps && !hasServerProps) {\n            isStatic = true;\n        }\n        // When PPR is enabled, any route may be completely static, so\n        // mark this route as static.\n        if (isRoutePPREnabled) {\n            isStatic = true;\n        }\n        return {\n            isStatic,\n            isRoutePPREnabled,\n            isHybridAmp: config.amp === 'hybrid',\n            isAmpOnly: config.amp === true,\n            prerenderFallbackMode,\n            prerenderedRoutes,\n            rootParamKeys,\n            hasStaticProps,\n            hasServerProps,\n            isNextImageImported,\n            appConfig\n        };\n    }).catch((err)=>{\n        if (err.message === 'INVALID_DEFAULT_EXPORT') {\n            throw err;\n        }\n        console.error(err);\n        throw Object.defineProperty(new Error(`Failed to collect page data for ${page}`), \"__NEXT_ERROR_CODE\", {\n            value: \"E414\",\n            enumerable: false,\n            configurable: true\n        });\n    });\n}\n/**\n * Collect the app config from the generate param segments. This only gets a\n * subset of the config options.\n *\n * @param segments the generate param segments\n * @returns the reduced app config\n */ export function reduceAppConfig(segments) {\n    const config = {};\n    for (const segment of segments){\n        const { dynamic, fetchCache, preferredRegion, revalidate, experimental_ppr, runtime, maxDuration } = segment.config || {};\n        // TODO: should conflicting configs here throw an error\n        // e.g. if layout defines one region but page defines another\n        if (typeof preferredRegion !== 'undefined') {\n            config.preferredRegion = preferredRegion;\n        }\n        if (typeof dynamic !== 'undefined') {\n            config.dynamic = dynamic;\n        }\n        if (typeof fetchCache !== 'undefined') {\n            config.fetchCache = fetchCache;\n        }\n        if (typeof revalidate !== 'undefined') {\n            config.revalidate = revalidate;\n        }\n        // Any revalidate number overrides false, and shorter revalidate overrides\n        // longer (initially).\n        if (typeof revalidate === 'number' && (typeof config.revalidate !== 'number' || revalidate < config.revalidate)) {\n            config.revalidate = revalidate;\n        }\n        // If partial prerendering has been set, only override it if the current\n        // value is provided as it's resolved from root layout to leaf page.\n        if (typeof experimental_ppr !== 'undefined') {\n            config.experimental_ppr = experimental_ppr;\n        }\n        if (typeof runtime !== 'undefined') {\n            config.runtime = runtime;\n        }\n        if (typeof maxDuration !== 'undefined') {\n            config.maxDuration = maxDuration;\n        }\n    }\n    return config;\n}\nexport async function hasCustomGetInitialProps({ page, distDir, runtimeEnvConfig, checkingApp, sriEnabled }) {\n    require('../shared/lib/runtime-config.external').setConfig(runtimeEnvConfig);\n    const components = await loadComponents({\n        distDir,\n        page: page,\n        isAppPath: false,\n        isDev: false,\n        sriEnabled\n    });\n    let mod = components.ComponentMod;\n    if (checkingApp) {\n        mod = await mod._app || mod.default || mod;\n    } else {\n        mod = mod.default || mod;\n    }\n    mod = await mod;\n    return mod.getInitialProps !== mod.origGetInitialProps;\n}\nexport async function getDefinedNamedExports({ page, distDir, runtimeEnvConfig, sriEnabled }) {\n    require('../shared/lib/runtime-config.external').setConfig(runtimeEnvConfig);\n    const components = await loadComponents({\n        distDir,\n        page: page,\n        isAppPath: false,\n        isDev: false,\n        sriEnabled\n    });\n    return Object.keys(components.ComponentMod).filter((key)=>{\n        return typeof components.ComponentMod[key] !== 'undefined';\n    });\n}\nexport function detectConflictingPaths(combinedPages, ssgPages, additionalGeneratedSSGPaths) {\n    const conflictingPaths = new Map();\n    const dynamicSsgPages = [\n        ...ssgPages\n    ].filter((page)=>isDynamicRoute(page));\n    const additionalSsgPathsByPath = {};\n    additionalGeneratedSSGPaths.forEach((paths, pathsPage)=>{\n        additionalSsgPathsByPath[pathsPage] ||= {};\n        paths.forEach((curPath)=>{\n            const currentPath = curPath.toLowerCase();\n            additionalSsgPathsByPath[pathsPage][currentPath] = curPath;\n        });\n    });\n    additionalGeneratedSSGPaths.forEach((paths, pathsPage)=>{\n        paths.forEach((curPath)=>{\n            const lowerPath = curPath.toLowerCase();\n            let conflictingPage = combinedPages.find((page)=>page.toLowerCase() === lowerPath);\n            if (conflictingPage) {\n                conflictingPaths.set(lowerPath, [\n                    {\n                        path: curPath,\n                        page: pathsPage\n                    },\n                    {\n                        path: conflictingPage,\n                        page: conflictingPage\n                    }\n                ]);\n            } else {\n                let conflictingPath;\n                conflictingPage = dynamicSsgPages.find((page)=>{\n                    if (page === pathsPage) return false;\n                    conflictingPath = additionalGeneratedSSGPaths.get(page) == null ? undefined : additionalSsgPathsByPath[page][lowerPath];\n                    return conflictingPath;\n                });\n                if (conflictingPage && conflictingPath) {\n                    conflictingPaths.set(lowerPath, [\n                        {\n                            path: curPath,\n                            page: pathsPage\n                        },\n                        {\n                            path: conflictingPath,\n                            page: conflictingPage\n                        }\n                    ]);\n                }\n            }\n        });\n    });\n    if (conflictingPaths.size > 0) {\n        let conflictingPathsOutput = '';\n        conflictingPaths.forEach((pathItems)=>{\n            pathItems.forEach((pathItem, idx)=>{\n                const isDynamic = pathItem.page !== pathItem.path;\n                if (idx > 0) {\n                    conflictingPathsOutput += 'conflicts with ';\n                }\n                conflictingPathsOutput += `path: \"${pathItem.path}\"${isDynamic ? ` from page: \"${pathItem.page}\" ` : ' '}`;\n            });\n            conflictingPathsOutput += '\\n';\n        });\n        Log.error('Conflicting paths returned from getStaticPaths, paths must be unique per page.\\n' + 'See more info here: https://nextjs.org/docs/messages/conflicting-ssg-paths\\n\\n' + conflictingPathsOutput);\n        process.exit(1);\n    }\n}\nexport async function copyTracedFiles(dir, distDir, pageKeys, appPageKeys, tracingRoot, serverConfig, middlewareManifest, hasNodeMiddleware, hasInstrumentationHook, staticPages) {\n    const outputPath = path.join(distDir, 'standalone');\n    let moduleType = false;\n    const nextConfig = {\n        ...serverConfig,\n        distDir: `./${path.relative(dir, distDir)}`\n    };\n    try {\n        const packageJsonPath = path.join(distDir, '../package.json');\n        const packageJsonContent = await fs.readFile(packageJsonPath, 'utf8');\n        const packageJson = JSON.parse(packageJsonContent);\n        moduleType = packageJson.type === 'module';\n        // we always copy the package.json to the standalone\n        // folder to ensure any resolving logic is maintained\n        const packageJsonOutputPath = path.join(outputPath, path.relative(tracingRoot, dir), 'package.json');\n        await fs.mkdir(path.dirname(packageJsonOutputPath), {\n            recursive: true\n        });\n        await fs.writeFile(packageJsonOutputPath, packageJsonContent);\n    } catch  {}\n    const copiedFiles = new Set();\n    await fs.rm(outputPath, {\n        recursive: true,\n        force: true\n    });\n    async function handleTraceFiles(traceFilePath) {\n        const traceData = JSON.parse(await fs.readFile(traceFilePath, 'utf8'));\n        const copySema = new Sema(10, {\n            capacity: traceData.files.length\n        });\n        const traceFileDir = path.dirname(traceFilePath);\n        await Promise.all(traceData.files.map(async (relativeFile)=>{\n            await copySema.acquire();\n            const tracedFilePath = path.join(traceFileDir, relativeFile);\n            const fileOutputPath = path.join(outputPath, path.relative(tracingRoot, tracedFilePath));\n            if (!copiedFiles.has(fileOutputPath)) {\n                copiedFiles.add(fileOutputPath);\n                await fs.mkdir(path.dirname(fileOutputPath), {\n                    recursive: true\n                });\n                const symlink = await fs.readlink(tracedFilePath).catch(()=>null);\n                if (symlink) {\n                    try {\n                        await fs.symlink(symlink, fileOutputPath);\n                    } catch (e) {\n                        if (e.code !== 'EEXIST') {\n                            throw e;\n                        }\n                    }\n                } else {\n                    await fs.copyFile(tracedFilePath, fileOutputPath);\n                }\n            }\n            await copySema.release();\n        }));\n    }\n    async function handleEdgeFunction(page) {\n        var _page_wasm, _page_assets;\n        async function handleFile(file) {\n            const originalPath = path.join(distDir, file);\n            const fileOutputPath = path.join(outputPath, path.relative(tracingRoot, distDir), file);\n            await fs.mkdir(path.dirname(fileOutputPath), {\n                recursive: true\n            });\n            await fs.copyFile(originalPath, fileOutputPath);\n        }\n        await Promise.all([\n            page.files.map(handleFile),\n            (_page_wasm = page.wasm) == null ? void 0 : _page_wasm.map((file)=>handleFile(file.filePath)),\n            (_page_assets = page.assets) == null ? void 0 : _page_assets.map((file)=>handleFile(file.filePath))\n        ]);\n    }\n    const edgeFunctionHandlers = [];\n    for (const middleware of Object.values(middlewareManifest.middleware)){\n        if (isMiddlewareFilename(middleware.name)) {\n            edgeFunctionHandlers.push(handleEdgeFunction(middleware));\n        }\n    }\n    for (const page of Object.values(middlewareManifest.functions)){\n        edgeFunctionHandlers.push(handleEdgeFunction(page));\n    }\n    await Promise.all(edgeFunctionHandlers);\n    for (const page of pageKeys){\n        if (middlewareManifest.functions.hasOwnProperty(page)) {\n            continue;\n        }\n        const route = normalizePagePath(page);\n        if (staticPages.has(route)) {\n            continue;\n        }\n        const pageFile = path.join(distDir, 'server', 'pages', `${normalizePagePath(page)}.js`);\n        const pageTraceFile = `${pageFile}.nft.json`;\n        await handleTraceFiles(pageTraceFile).catch((err)=>{\n            if (err.code !== 'ENOENT' || page !== '/404' && page !== '/500') {\n                Log.warn(`Failed to copy traced files for ${pageFile}`, err);\n            }\n        });\n    }\n    if (hasNodeMiddleware) {\n        const middlewareFile = path.join(distDir, 'server', 'middleware.js');\n        const middlewareTrace = `${middlewareFile}.nft.json`;\n        await handleTraceFiles(middlewareTrace);\n    }\n    if (appPageKeys) {\n        for (const page of appPageKeys){\n            if (middlewareManifest.functions.hasOwnProperty(page)) {\n                continue;\n            }\n            const pageFile = path.join(distDir, 'server', 'app', `${page}.js`);\n            const pageTraceFile = `${pageFile}.nft.json`;\n            await handleTraceFiles(pageTraceFile).catch((err)=>{\n                Log.warn(`Failed to copy traced files for ${pageFile}`, err);\n            });\n        }\n    }\n    if (hasInstrumentationHook) {\n        await handleTraceFiles(path.join(distDir, 'server', 'instrumentation.js.nft.json'));\n    }\n    await handleTraceFiles(path.join(distDir, 'next-server.js.nft.json'));\n    const serverOutputPath = path.join(outputPath, path.relative(tracingRoot, dir), 'server.js');\n    await fs.mkdir(path.dirname(serverOutputPath), {\n        recursive: true\n    });\n    await fs.writeFile(serverOutputPath, `${moduleType ? `performance.mark('next-start');\nimport path from 'path'\nimport { fileURLToPath } from 'url'\nimport module from 'module'\nconst require = module.createRequire(import.meta.url)\nconst __dirname = fileURLToPath(new URL('.', import.meta.url))\n` : `const path = require('path')`}\n\nconst dir = path.join(__dirname)\n\nprocess.env.NODE_ENV = 'production'\nprocess.chdir(__dirname)\n\nconst currentPort = parseInt(process.env.PORT, 10) || 3000\nconst hostname = process.env.HOSTNAME || '0.0.0.0'\n\nlet keepAliveTimeout = parseInt(process.env.KEEP_ALIVE_TIMEOUT, 10)\nconst nextConfig = ${JSON.stringify(nextConfig)}\n\nprocess.env.__NEXT_PRIVATE_STANDALONE_CONFIG = JSON.stringify(nextConfig)\n\nrequire('next')\nconst { startServer } = require('next/dist/server/lib/start-server')\n\nif (\n  Number.isNaN(keepAliveTimeout) ||\n  !Number.isFinite(keepAliveTimeout) ||\n  keepAliveTimeout < 0\n) {\n  keepAliveTimeout = undefined\n}\n\nstartServer({\n  dir,\n  isDev: false,\n  config: nextConfig,\n  hostname,\n  port: currentPort,\n  allowRetry: false,\n  keepAliveTimeout,\n}).catch((err) => {\n  console.error(err);\n  process.exit(1);\n});`);\n}\nexport function isReservedPage(page) {\n    return RESERVED_PAGE.test(page);\n}\nexport function isAppBuiltinNotFoundPage(page) {\n    return /next[\\\\/]dist[\\\\/]client[\\\\/]components[\\\\/]not-found-error/.test(page);\n}\nexport function isCustomErrorPage(page) {\n    return page === '/404' || page === '/500';\n}\nexport function isMiddlewareFile(file) {\n    return file === `/${MIDDLEWARE_FILENAME}` || file === `/src/${MIDDLEWARE_FILENAME}`;\n}\nexport function isInstrumentationHookFile(file) {\n    return file === `/${INSTRUMENTATION_HOOK_FILENAME}` || file === `/src/${INSTRUMENTATION_HOOK_FILENAME}`;\n}\nexport function getPossibleInstrumentationHookFilenames(folder, extensions) {\n    const files = [];\n    for (const extension of extensions){\n        files.push(path.join(folder, `${INSTRUMENTATION_HOOK_FILENAME}.${extension}`), path.join(folder, `src`, `${INSTRUMENTATION_HOOK_FILENAME}.${extension}`));\n    }\n    return files;\n}\nexport function getPossibleMiddlewareFilenames(folder, extensions) {\n    return extensions.map((extension)=>path.join(folder, `${MIDDLEWARE_FILENAME}.${extension}`));\n}\nexport class NestedMiddlewareError extends Error {\n    constructor(nestedFileNames, mainDir, pagesOrAppDir){\n        super(`Nested Middleware is not allowed, found:\\n` + `${nestedFileNames.map((file)=>`pages${file}`).join('\\n')}\\n` + `Please move your code to a single file at ${path.join(path.posix.sep, path.relative(mainDir, path.resolve(pagesOrAppDir, '..')), 'middleware')} instead.\\n` + `Read More - https://nextjs.org/docs/messages/nested-middleware`);\n    }\n}\nexport function getSupportedBrowsers(dir, isDevelopment) {\n    let browsers;\n    try {\n        const browsersListConfig = browserslist.loadConfig({\n            path: dir,\n            env: isDevelopment ? 'development' : 'production'\n        });\n        // Running `browserslist` resolves `extends` and other config features into a list of browsers\n        if (browsersListConfig && browsersListConfig.length > 0) {\n            browsers = browserslist(browsersListConfig);\n        }\n    } catch  {}\n    // When user has browserslist use that target\n    if (browsers && browsers.length > 0) {\n        return browsers;\n    }\n    // Uses modern browsers as the default.\n    return MODERN_BROWSERSLIST_TARGET;\n}\nexport function isWebpackServerOnlyLayer(layer) {\n    return Boolean(layer && WEBPACK_LAYERS.GROUP.serverOnly.includes(layer));\n}\nexport function isWebpackClientOnlyLayer(layer) {\n    return Boolean(layer && WEBPACK_LAYERS.GROUP.clientOnly.includes(layer));\n}\nexport function isWebpackDefaultLayer(layer) {\n    return layer === null || layer === undefined || layer === WEBPACK_LAYERS.pagesDirBrowser || layer === WEBPACK_LAYERS.pagesDirEdge || layer === WEBPACK_LAYERS.pagesDirNode;\n}\nexport function isWebpackBundledLayer(layer) {\n    return Boolean(layer && WEBPACK_LAYERS.GROUP.bundled.includes(layer));\n}\nexport function isWebpackAppPagesLayer(layer) {\n    return Boolean(layer && WEBPACK_LAYERS.GROUP.appPages.includes(layer));\n}\nexport function collectMeta({ status, headers }) {\n    const meta = {};\n    if (status !== 200) {\n        meta.status = status;\n    }\n    if (headers && Object.keys(headers).length) {\n        meta.headers = {};\n        // normalize header values as initialHeaders\n        // must be Record<string, string>\n        for(const key in headers){\n            // set-cookie is already handled - the middleware cookie setting case\n            // isn't needed for the prerender manifest since it can't read cookies\n            if (key === 'x-middleware-set-cookie') continue;\n            let value = headers[key];\n            if (Array.isArray(value)) {\n                if (key === 'set-cookie') {\n                    value = value.join(',');\n                } else {\n                    value = value[value.length - 1];\n                }\n            }\n            if (typeof value === 'string') {\n                meta.headers[key] = value;\n            }\n        }\n    }\n    return meta;\n}\n\n//# sourceMappingURL=utils.js.map"
        }
    ]
}