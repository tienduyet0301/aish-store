{
    "sourceFile": "node_modules/next/dist/esm/build/analysis/get-page-static-info.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892744972,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import { promises as fs } from 'fs';\nimport { LRUCache } from '../../server/lib/lru-cache';\nimport { extractExportedConstValue, UnsupportedValueError } from './extract-const-value';\nimport { parseModule } from './parse-module';\nimport * as Log from '../output/log';\nimport { SERVER_RUNTIME } from '../../lib/constants';\nimport { tryToParsePath } from '../../lib/try-to-parse-path';\nimport { isAPIRoute } from '../../lib/is-api-route';\nimport { isEdgeRuntime } from '../../lib/is-edge-runtime';\nimport { RSC_MODULE_TYPES } from '../../shared/lib/constants';\nimport { PAGE_TYPES } from '../../lib/page-types';\nimport { AppSegmentConfigSchemaKeys, parseAppSegmentConfig } from '../segment-config/app/app-segment-config';\nimport { reportZodError } from '../../shared/lib/zod';\nimport { PagesSegmentConfigSchemaKeys, parsePagesSegmentConfig } from '../segment-config/pages/pages-segment-config';\nimport { MiddlewareConfigInputSchema, SourceSchema } from '../segment-config/middleware/middleware-config';\nimport { normalizeAppPath } from '../../shared/lib/router/utils/app-paths';\nimport { normalizePagePath } from '../../shared/lib/page-path/normalize-page-path';\nconst PARSE_PATTERN = /(?<!(_jsx|jsx-))runtime|preferredRegion|getStaticProps|getServerSideProps|generateStaticParams|export const|generateImageMetadata|generateSitemaps/;\nconst CLIENT_MODULE_LABEL = /\\/\\* __next_internal_client_entry_do_not_use__ ([^ ]*) (cjs|auto) \\*\\//;\nconst ACTION_MODULE_LABEL = /\\/\\* __next_internal_action_entry_do_not_use__ (\\{[^}]+\\}) \\*\\//;\nconst CLIENT_DIRECTIVE = 'use client';\nconst SERVER_ACTION_DIRECTIVE = 'use server';\nexport function getRSCModuleInformation(source, isReactServerLayer) {\n    const actionsJson = source.match(ACTION_MODULE_LABEL);\n    const parsedActionsMeta = actionsJson ? JSON.parse(actionsJson[1]) : undefined;\n    const clientInfoMatch = source.match(CLIENT_MODULE_LABEL);\n    const isClientRef = !!clientInfoMatch;\n    if (!isReactServerLayer) {\n        return {\n            type: RSC_MODULE_TYPES.client,\n            actionIds: parsedActionsMeta,\n            isClientRef\n        };\n    }\n    const clientRefsString = clientInfoMatch == null ? void 0 : clientInfoMatch[1];\n    const clientRefs = clientRefsString ? clientRefsString.split(',') : [];\n    const clientEntryType = clientInfoMatch == null ? void 0 : clientInfoMatch[2];\n    const type = clientInfoMatch ? RSC_MODULE_TYPES.client : RSC_MODULE_TYPES.server;\n    return {\n        type,\n        actionIds: parsedActionsMeta,\n        clientRefs,\n        clientEntryType,\n        isClientRef\n    };\n}\n/**\n * Receives a parsed AST from SWC and checks if it belongs to a module that\n * requires a runtime to be specified. Those are:\n *   - Modules with `export function getStaticProps | getServerSideProps`\n *   - Modules with `export { getStaticProps | getServerSideProps } <from ...>`\n *   - Modules with `export const runtime = ...`\n */ function checkExports(ast, expectedExports, page) {\n    const exportsSet = new Set([\n        'getStaticProps',\n        'getServerSideProps',\n        'generateImageMetadata',\n        'generateSitemaps',\n        'generateStaticParams'\n    ]);\n    if (!Array.isArray(ast == null ? void 0 : ast.body)) {\n        return {};\n    }\n    try {\n        let getStaticProps = false;\n        let getServerSideProps = false;\n        let generateImageMetadata = false;\n        let generateSitemaps = false;\n        let generateStaticParams = false;\n        let exports = new Set();\n        let directives = new Set();\n        let hasLeadingNonDirectiveNode = false;\n        for (const node of ast.body){\n            var _node_declaration, _node_declaration1, _node_declaration_identifier, _node_declaration2;\n            // There should be no non-string literals nodes before directives\n            if (node.type === 'ExpressionStatement' && node.expression.type === 'StringLiteral') {\n                if (!hasLeadingNonDirectiveNode) {\n                    const directive = node.expression.value;\n                    if (CLIENT_DIRECTIVE === directive) {\n                        directives.add('client');\n                    }\n                    if (SERVER_ACTION_DIRECTIVE === directive) {\n                        directives.add('server');\n                    }\n                }\n            } else {\n                hasLeadingNonDirectiveNode = true;\n            }\n            if (node.type === 'ExportDeclaration' && ((_node_declaration = node.declaration) == null ? void 0 : _node_declaration.type) === 'VariableDeclaration') {\n                var _node_declaration3;\n                for (const declaration of (_node_declaration3 = node.declaration) == null ? void 0 : _node_declaration3.declarations){\n                    if (expectedExports.includes(declaration.id.value)) {\n                        exports.add(declaration.id.value);\n                    }\n                }\n            }\n            if (node.type === 'ExportDeclaration' && ((_node_declaration1 = node.declaration) == null ? void 0 : _node_declaration1.type) === 'FunctionDeclaration' && exportsSet.has((_node_declaration_identifier = node.declaration.identifier) == null ? void 0 : _node_declaration_identifier.value)) {\n                const id = node.declaration.identifier.value;\n                getServerSideProps = id === 'getServerSideProps';\n                getStaticProps = id === 'getStaticProps';\n                generateImageMetadata = id === 'generateImageMetadata';\n                generateSitemaps = id === 'generateSitemaps';\n                generateStaticParams = id === 'generateStaticParams';\n            }\n            if (node.type === 'ExportDeclaration' && ((_node_declaration2 = node.declaration) == null ? void 0 : _node_declaration2.type) === 'VariableDeclaration') {\n                var _node_declaration_declarations_, _node_declaration4;\n                const id = (_node_declaration4 = node.declaration) == null ? void 0 : (_node_declaration_declarations_ = _node_declaration4.declarations[0]) == null ? void 0 : _node_declaration_declarations_.id.value;\n                if (exportsSet.has(id)) {\n                    getServerSideProps = id === 'getServerSideProps';\n                    getStaticProps = id === 'getStaticProps';\n                    generateImageMetadata = id === 'generateImageMetadata';\n                    generateSitemaps = id === 'generateSitemaps';\n                    generateStaticParams = id === 'generateStaticParams';\n                }\n            }\n            if (node.type === 'ExportNamedDeclaration') {\n                for (const specifier of node.specifiers){\n                    var _specifier_orig;\n                    if (specifier.type === 'ExportSpecifier' && ((_specifier_orig = specifier.orig) == null ? void 0 : _specifier_orig.type) === 'Identifier') {\n                        const value = specifier.orig.value;\n                        if (!getServerSideProps && value === 'getServerSideProps') {\n                            getServerSideProps = true;\n                        }\n                        if (!getStaticProps && value === 'getStaticProps') {\n                            getStaticProps = true;\n                        }\n                        if (!generateImageMetadata && value === 'generateImageMetadata') {\n                            generateImageMetadata = true;\n                        }\n                        if (!generateSitemaps && value === 'generateSitemaps') {\n                            generateSitemaps = true;\n                        }\n                        if (!generateStaticParams && value === 'generateStaticParams') {\n                            generateStaticParams = true;\n                        }\n                        if (expectedExports.includes(value) && !exports.has(value)) {\n                            // An export was found that was actually a re-export, and not a\n                            // literal value. We should warn here.\n                            Log.warn(`Next.js can't recognize the exported \\`${value}\\` field in \"${page}\", it may be re-exported from another file. The default config will be used instead.`);\n                        }\n                    }\n                }\n            }\n        }\n        return {\n            getStaticProps,\n            getServerSideProps,\n            generateImageMetadata,\n            generateSitemaps,\n            generateStaticParams,\n            directives,\n            exports\n        };\n    } catch  {}\n    return {};\n}\nasync function tryToReadFile(filePath, shouldThrow) {\n    try {\n        return await fs.readFile(filePath, {\n            encoding: 'utf8'\n        });\n    } catch (error) {\n        if (shouldThrow) {\n            error.message = `Next.js ERROR: Failed to read file ${filePath}:\\n${error.message}`;\n            throw error;\n        }\n    }\n}\n/**\n * @internal - required to exclude zod types from the build\n */ export function getMiddlewareMatchers(matcherOrMatchers, nextConfig) {\n    const matchers = Array.isArray(matcherOrMatchers) ? matcherOrMatchers : [\n        matcherOrMatchers\n    ];\n    const { i18n } = nextConfig;\n    return matchers.map((matcher)=>{\n        matcher = typeof matcher === 'string' ? {\n            source: matcher\n        } : matcher;\n        const originalSource = matcher.source;\n        let { source, ...rest } = matcher;\n        const isRoot = source === '/';\n        if ((i18n == null ? void 0 : i18n.locales) && matcher.locale !== false) {\n            source = `/:nextInternalLocale((?!_next/)[^/.]{1,})${isRoot ? '' : source}`;\n        }\n        source = `/:nextData(_next/data/[^/]{1,})?${source}${isRoot ? `(${nextConfig.i18n ? '|\\\\.json|' : ''}/?index|/?index\\\\.json)?` : '{(\\\\.json)}?'}`;\n        if (nextConfig.basePath) {\n            source = `${nextConfig.basePath}${source}`;\n        }\n        // Validate that the source is still.\n        const result = SourceSchema.safeParse(source);\n        if (!result.success) {\n            reportZodError('Failed to parse middleware source', result.error);\n            // We need to exit here because middleware being built occurs before we\n            // finish setting up the server. Exiting here is the only way to ensure\n            // that we don't hang.\n            process.exit(1);\n        }\n        return {\n            ...rest,\n            // We know that parsed.regexStr is not undefined because we already\n            // checked that the source is valid.\n            regexp: tryToParsePath(result.data).regexStr,\n            originalSource: originalSource || source\n        };\n    });\n}\nfunction parseMiddlewareConfig(page, rawConfig, nextConfig) {\n    // If there's no config to parse, then return nothing.\n    if (typeof rawConfig !== 'object' || !rawConfig) return {};\n    const input = MiddlewareConfigInputSchema.safeParse(rawConfig);\n    if (!input.success) {\n        reportZodError(`${page} contains invalid middleware config`, input.error);\n        // We need to exit here because middleware being built occurs before we\n        // finish setting up the server. Exiting here is the only way to ensure\n        // that we don't hang.\n        process.exit(1);\n    }\n    const config = {};\n    if (input.data.matcher) {\n        config.matchers = getMiddlewareMatchers(input.data.matcher, nextConfig);\n    }\n    if (input.data.unstable_allowDynamic) {\n        config.unstable_allowDynamic = Array.isArray(input.data.unstable_allowDynamic) ? input.data.unstable_allowDynamic : [\n            input.data.unstable_allowDynamic\n        ];\n    }\n    if (input.data.regions) {\n        config.regions = input.data.regions;\n    }\n    return config;\n}\nconst apiRouteWarnings = new LRUCache(250);\nfunction warnAboutExperimentalEdge(apiRoute) {\n    if (process.env.NODE_ENV === 'production' && process.env.NEXT_PRIVATE_BUILD_WORKER === '1') {\n        return;\n    }\n    if (apiRouteWarnings.has(apiRoute)) {\n        return;\n    }\n    Log.warn(apiRoute ? `${apiRoute} provided runtime 'experimental-edge'. It can be updated to 'edge' instead.` : `You are using an experimental edge runtime, the API might change.`);\n    apiRouteWarnings.set(apiRoute, 1);\n}\nexport let hadUnsupportedValue = false;\nconst warnedUnsupportedValueMap = new LRUCache(250, ()=>1);\nfunction warnAboutUnsupportedValue(pageFilePath, page, error) {\n    hadUnsupportedValue = true;\n    const isProductionBuild = process.env.NODE_ENV === 'production';\n    if (// we only log for the server compilation so it's not\n    // duplicated due to webpack build worker having fresh\n    // module scope for each compiler\n    process.env.NEXT_COMPILER_NAME !== 'server' || isProductionBuild && warnedUnsupportedValueMap.has(pageFilePath)) {\n        return;\n    }\n    warnedUnsupportedValueMap.set(pageFilePath, true);\n    const message = `Next.js can't recognize the exported \\`config\\` field in ` + (page ? `route \"${page}\"` : `\"${pageFilePath}\"`) + ':\\n' + error.message + (error.path ? ` at \"${error.path}\"` : '') + '.\\n' + 'Read More - https://nextjs.org/docs/messages/invalid-page-config';\n    // for a build we use `Log.error` instead of throwing\n    // so that all errors can be logged before exiting the process\n    if (isProductionBuild) {\n        Log.error(message);\n    } else {\n        throw Object.defineProperty(new Error(message), \"__NEXT_ERROR_CODE\", {\n            value: \"E394\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n}\nexport async function getAppPageStaticInfo({ pageFilePath, nextConfig, isDev, page }) {\n    const content = await tryToReadFile(pageFilePath, !isDev);\n    if (!content || !PARSE_PATTERN.test(content)) {\n        return {\n            type: PAGE_TYPES.APP,\n            config: undefined,\n            runtime: undefined,\n            preferredRegion: undefined,\n            maxDuration: undefined\n        };\n    }\n    const ast = await parseModule(pageFilePath, content);\n    const { generateStaticParams, generateImageMetadata, generateSitemaps, exports, directives } = checkExports(ast, AppSegmentConfigSchemaKeys, page);\n    const { type: rsc } = getRSCModuleInformation(content, true);\n    const exportedConfig = {};\n    if (exports) {\n        for (const property of exports){\n            try {\n                exportedConfig[property] = extractExportedConstValue(ast, property);\n            } catch (e) {\n                if (e instanceof UnsupportedValueError) {\n                    warnAboutUnsupportedValue(pageFilePath, page, e);\n                }\n            }\n        }\n    }\n    try {\n        exportedConfig.config = extractExportedConstValue(ast, 'config');\n    } catch (e) {\n        if (e instanceof UnsupportedValueError) {\n            warnAboutUnsupportedValue(pageFilePath, page, e);\n        }\n    // `export config` doesn't exist, or other unknown error thrown by swc, silence them\n    }\n    const route = normalizeAppPath(page);\n    const config = parseAppSegmentConfig(exportedConfig, route);\n    // Prevent edge runtime and generateStaticParams in the same file.\n    if (isEdgeRuntime(config.runtime) && generateStaticParams) {\n        throw Object.defineProperty(new Error(`Page \"${page}\" cannot use both \\`export const runtime = 'edge'\\` and export \\`generateStaticParams\\`.`), \"__NEXT_ERROR_CODE\", {\n            value: \"E42\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    // Prevent use client and generateStaticParams in the same file.\n    if ((directives == null ? void 0 : directives.has('client')) && generateStaticParams) {\n        throw Object.defineProperty(new Error(`Page \"${page}\" cannot use both \"use client\" and export function \"generateStaticParams()\".`), \"__NEXT_ERROR_CODE\", {\n            value: \"E475\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    return {\n        type: PAGE_TYPES.APP,\n        rsc,\n        generateImageMetadata,\n        generateSitemaps,\n        generateStaticParams,\n        config,\n        middleware: parseMiddlewareConfig(page, exportedConfig.config, nextConfig),\n        runtime: config.runtime,\n        preferredRegion: config.preferredRegion,\n        maxDuration: config.maxDuration\n    };\n}\nexport async function getPagesPageStaticInfo({ pageFilePath, nextConfig, isDev, page }) {\n    var _config_config, _config_config1, _config_config2;\n    const content = await tryToReadFile(pageFilePath, !isDev);\n    if (!content || !PARSE_PATTERN.test(content)) {\n        return {\n            type: PAGE_TYPES.PAGES,\n            config: undefined,\n            runtime: undefined,\n            preferredRegion: undefined,\n            maxDuration: undefined\n        };\n    }\n    const ast = await parseModule(pageFilePath, content);\n    const { getServerSideProps, getStaticProps, exports } = checkExports(ast, PagesSegmentConfigSchemaKeys, page);\n    const { type: rsc } = getRSCModuleInformation(content, true);\n    const exportedConfig = {};\n    if (exports) {\n        for (const property of exports){\n            try {\n                exportedConfig[property] = extractExportedConstValue(ast, property);\n            } catch (e) {\n                if (e instanceof UnsupportedValueError) {\n                    warnAboutUnsupportedValue(pageFilePath, page, e);\n                }\n            }\n        }\n    }\n    try {\n        exportedConfig.config = extractExportedConstValue(ast, 'config');\n    } catch (e) {\n        if (e instanceof UnsupportedValueError) {\n            warnAboutUnsupportedValue(pageFilePath, page, e);\n        }\n    // `export config` doesn't exist, or other unknown error thrown by swc, silence them\n    }\n    // Validate the config.\n    const route = normalizePagePath(page);\n    const config = parsePagesSegmentConfig(exportedConfig, route);\n    const isAnAPIRoute = isAPIRoute(route);\n    const resolvedRuntime = config.runtime ?? ((_config_config = config.config) == null ? void 0 : _config_config.runtime);\n    if (resolvedRuntime === SERVER_RUNTIME.experimentalEdge) {\n        warnAboutExperimentalEdge(isAnAPIRoute ? page : null);\n    }\n    if (resolvedRuntime === SERVER_RUNTIME.edge && page && !isAnAPIRoute) {\n        const message = `Page ${page} provided runtime 'edge', the edge runtime for rendering is currently experimental. Use runtime 'experimental-edge' instead.`;\n        if (isDev) {\n            Log.error(message);\n        } else {\n            throw Object.defineProperty(new Error(message), \"__NEXT_ERROR_CODE\", {\n                value: \"E394\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n    }\n    return {\n        type: PAGE_TYPES.PAGES,\n        getStaticProps,\n        getServerSideProps,\n        rsc,\n        config,\n        middleware: parseMiddlewareConfig(page, exportedConfig.config, nextConfig),\n        runtime: resolvedRuntime,\n        preferredRegion: (_config_config1 = config.config) == null ? void 0 : _config_config1.regions,\n        maxDuration: config.maxDuration ?? ((_config_config2 = config.config) == null ? void 0 : _config_config2.maxDuration)\n    };\n}\n/**\n * For a given pageFilePath and nextConfig, if the config supports it, this\n * function will read the file and return the runtime that should be used.\n * It will look into the file content only if the page *requires* a runtime\n * to be specified, that is, when gSSP or gSP is used.\n * Related discussion: https://github.com/vercel/next.js/discussions/34179\n */ export async function getPageStaticInfo(params) {\n    if (params.pageType === PAGE_TYPES.APP) {\n        return getAppPageStaticInfo(params);\n    }\n    return getPagesPageStaticInfo(params);\n}\n\n//# sourceMappingURL=get-page-static-info.js.map"
        }
    ]
}