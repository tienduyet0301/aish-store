{
    "sourceFile": "node_modules/next/dist/esm/build/webpack/utils.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892761643,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import { getAppLoader } from '../entries';\nimport { spans as webpackCompilationSpans } from './plugins/profiling-plugin';\nimport { compilationSpans as rspackCompilationSpans } from './plugins/rspack-profiling-plugin';\nexport function traverseModules(compilation, callback, filterChunkGroup) {\n    compilation.chunkGroups.forEach((chunkGroup)=>{\n        if (filterChunkGroup && !filterChunkGroup(chunkGroup)) {\n            return;\n        }\n        chunkGroup.chunks.forEach((chunk)=>{\n            const chunkModules = compilation.chunkGraph.getChunkModulesIterable(chunk);\n            for (const mod of chunkModules){\n                var _compilation_chunkGraph_getModuleId;\n                const modId = (_compilation_chunkGraph_getModuleId = compilation.chunkGraph.getModuleId(mod)) == null ? void 0 : _compilation_chunkGraph_getModuleId.toString();\n                if (modId) callback(mod, chunk, chunkGroup, modId);\n                const anyModule = mod;\n                if (anyModule.modules) {\n                    for (const subMod of anyModule.modules)if (modId) callback(subMod, chunk, chunkGroup, modId);\n                }\n            }\n        });\n    });\n}\n// Loop over all the entry modules.\nexport function forEachEntryModule(compilation, callback) {\n    for (const [name, entry] of compilation.entries.entries()){\n        var _entry_dependencies;\n        // Skip for entries under pages/\n        if (name.startsWith('pages/')) {\n            continue;\n        }\n        // Check if the page entry is a server component or not.\n        const entryDependency = (_entry_dependencies = entry.dependencies) == null ? void 0 : _entry_dependencies[0];\n        // Ensure only next-app-loader entries are handled.\n        if (!entryDependency || !entryDependency.request) continue;\n        const request = entryDependency.request;\n        if (!request.startsWith('next-edge-ssr-loader?') && !request.startsWith('next-edge-app-route-loader?') && !request.startsWith(`${getAppLoader()}?`)) continue;\n        let entryModule = compilation.moduleGraph.getResolvedModule(entryDependency);\n        if (request.startsWith('next-edge-ssr-loader?') || request.startsWith('next-edge-app-route-loader?')) {\n            entryModule.dependencies.forEach((dependency)=>{\n                const modRequest = dependency.request;\n                if (modRequest == null ? void 0 : modRequest.includes(getAppLoader())) {\n                    entryModule = compilation.moduleGraph.getResolvedModule(dependency);\n                }\n            });\n        }\n        callback({\n            name,\n            entryModule\n        });\n    }\n}\nexport function formatBarrelOptimizedResource(resource, matchResource) {\n    return `${resource}@${matchResource}`;\n}\nexport function getModuleReferencesInOrder(module, moduleGraph) {\n    if ('getOutgoingConnectionsInOrder' in moduleGraph && typeof moduleGraph.getOutgoingConnectionsInOrder === 'function') {\n        return moduleGraph.getOutgoingConnectionsInOrder(module);\n    }\n    const connections = [];\n    for (const connection of moduleGraph.getOutgoingConnections(module)){\n        if (connection.dependency && connection.module) {\n            connections.push({\n                connection,\n                index: moduleGraph.getParentBlockIndex(connection.dependency)\n            });\n        }\n    }\n    connections.sort((a, b)=>a.index - b.index);\n    return connections.map((c)=>c.connection);\n}\nexport function getCompilationSpan(compilation) {\n    const compilationSpans = process.env.NEXT_RSPACK ? rspackCompilationSpans : webpackCompilationSpans;\n    return compilationSpans.get(compilation);\n}\n\n//# sourceMappingURL=utils.js.map"
        }
    ]
}