{
    "sourceFile": "node_modules/next/dist/esm/build/webpack/plugins/flight-manifest-plugin.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892758849,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */ import path from 'path';\nimport { webpack, sources } from 'next/dist/compiled/webpack/webpack';\nimport { APP_CLIENT_INTERNALS, BARREL_OPTIMIZATION_PREFIX, CLIENT_REFERENCE_MANIFEST, SYSTEM_ENTRYPOINTS } from '../../../shared/lib/constants';\nimport { relative } from 'path';\nimport { getProxiedPluginState } from '../../build-context';\nimport { WEBPACK_LAYERS } from '../../../lib/constants';\nimport { normalizePagePath } from '../../../shared/lib/page-path/normalize-page-path';\nimport { CLIENT_STATIC_FILES_RUNTIME_MAIN_APP } from '../../../shared/lib/constants';\nimport { getDeploymentIdQueryOrEmptyString } from '../../deployment-id';\nimport { formatBarrelOptimizedResource, getModuleReferencesInOrder } from '../utils';\nimport { encodeURIPath } from '../../../shared/lib/encode-uri-path';\nconst pluginState = getProxiedPluginState({\n    ssrModules: {},\n    edgeSsrModules: {},\n    rscModules: {},\n    edgeRscModules: {}\n});\nfunction getAppPathRequiredChunks(chunkGroup, excludedFiles) {\n    const deploymentIdChunkQuery = getDeploymentIdQueryOrEmptyString();\n    const chunks = [];\n    chunkGroup.chunks.forEach((chunk)=>{\n        if (SYSTEM_ENTRYPOINTS.has(chunk.name || '')) {\n            return null;\n        }\n        // Get the actual chunk file names from the chunk file list.\n        // It's possible that the chunk is generated via `import()`, in\n        // that case the chunk file name will be '[name].[contenthash]'\n        // instead of '[name]-[chunkhash]'.\n        if (chunk.id != null) {\n            const chunkId = '' + chunk.id;\n            chunk.files.forEach((file)=>{\n                // It's possible that a chunk also emits CSS files, that will\n                // be handled separatedly.\n                if (!file.endsWith('.js')) return null;\n                if (file.endsWith('.hot-update.js')) return null;\n                if (excludedFiles.has(file)) return null;\n                // We encode the file as a URI because our server (and many other services such as S3)\n                // expect to receive reserved characters such as `[` and `]` as encoded. This was\n                // previously done for dynamic chunks by patching the webpack runtime but we want\n                // these filenames to be managed by React's Flight runtime instead and so we need\n                // to implement any special handling of the file name here.\n                return chunks.push(chunkId, encodeURIPath(file) + deploymentIdChunkQuery);\n            });\n        }\n    });\n    return chunks;\n}\n// Normalize the entry names to their \"group names\" so a page can easily track\n// all the manifest items it needs from parent groups by looking up the group\n// segments:\n// - app/foo/loading -> app/foo\n// - app/foo/page -> app/foo\n// - app/(group)/@named/foo/page -> app/foo\n// - app/(.)foo/(..)bar/loading -> app/bar\n// - app/[...catchAll]/page -> app\n// - app/foo/@slot/[...catchAll]/page -> app/foo\nfunction entryNameToGroupName(entryName) {\n    let groupName = entryName.slice(0, entryName.lastIndexOf('/'))// Remove slots\n    .replace(/\\/@[^/]+/g, '')// Remove the group with lookahead to make sure it's not interception route\n    .replace(/\\/\\([^/]+\\)(?=(\\/|$))/g, '')// Remove catch-all routes since they should be part of the parent group that the catch-all would apply to.\n    // This is necessary to support parallel routes since multiple page components can be rendered on the same page.\n    // In order to do that, we need to ensure that the manifests are merged together by putting them in the same group.\n    .replace(/\\/\\[?\\[\\.\\.\\.[^\\]]*]]?/g, '');\n    // Interception routes\n    groupName = groupName.replace(/^.+\\/\\(\\.\\.\\.\\)/g, 'app/').replace(/\\/\\(\\.\\)/g, '/');\n    // Interception routes (recursive)\n    while(/\\/[^/]+\\/\\(\\.\\.\\)/.test(groupName)){\n        groupName = groupName.replace(/\\/[^/]+\\/\\(\\.\\.\\)/g, '/');\n    }\n    return groupName;\n}\nfunction mergeManifest(manifest, manifestToMerge) {\n    Object.assign(manifest.clientModules, manifestToMerge.clientModules);\n    Object.assign(manifest.ssrModuleMapping, manifestToMerge.ssrModuleMapping);\n    Object.assign(manifest.edgeSSRModuleMapping, manifestToMerge.edgeSSRModuleMapping);\n    Object.assign(manifest.entryCSSFiles, manifestToMerge.entryCSSFiles);\n    Object.assign(manifest.rscModuleMapping, manifestToMerge.rscModuleMapping);\n    Object.assign(manifest.edgeRscModuleMapping, manifestToMerge.edgeRscModuleMapping);\n}\nconst PLUGIN_NAME = 'ClientReferenceManifestPlugin';\nexport class ClientReferenceManifestPlugin {\n    constructor(options){\n        this.dev = false;\n        this.dev = options.dev;\n        this.appDir = options.appDir;\n        this.appDirBase = path.dirname(this.appDir) + path.sep;\n        this.experimentalInlineCss = options.experimentalInlineCss;\n    }\n    apply(compiler) {\n        compiler.hooks.compilation.tap(PLUGIN_NAME, (compilation)=>{\n            compilation.hooks.processAssets.tap({\n                name: PLUGIN_NAME,\n                // Have to be in the optimize stage to run after updating the CSS\n                // asset hash via extract mini css plugin.\n                stage: webpack.Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE_HASH\n            }, ()=>this.createAsset(compilation, compiler.context));\n        });\n    }\n    createAsset(compilation, context) {\n        var _compilation_entrypoints_get;\n        const manifestsPerGroup = new Map();\n        const manifestEntryFiles = [];\n        const configuredCrossOriginLoading = compilation.outputOptions.crossOriginLoading;\n        const crossOriginMode = typeof configuredCrossOriginLoading === 'string' ? configuredCrossOriginLoading === 'use-credentials' ? configuredCrossOriginLoading : '' // === 'anonymous'\n         : undefined;\n        if (typeof compilation.outputOptions.publicPath !== 'string') {\n            throw Object.defineProperty(new Error('Expected webpack publicPath to be a string when using App Router. To customize where static assets are loaded from, use the `assetPrefix` option in next.config.js. If you are customizing your webpack config please make sure you are not modifying or removing the publicPath configuration option'), \"__NEXT_ERROR_CODE\", {\n                value: \"E136\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n        const prefix = compilation.outputOptions.publicPath || '';\n        // We want to omit any files that will always be loaded on any App Router page\n        // because they will already be loaded by the main entrypoint.\n        const rootMainFiles = new Set();\n        (_compilation_entrypoints_get = compilation.entrypoints.get(CLIENT_STATIC_FILES_RUNTIME_MAIN_APP)) == null ? void 0 : _compilation_entrypoints_get.getFiles().forEach((file)=>{\n            if (/(?<!\\.hot-update)\\.(js|css)($|\\?)/.test(file)) {\n                rootMainFiles.add(file.replace(/\\\\/g, '/'));\n            }\n        });\n        for (let [entryName, entrypoint] of compilation.entrypoints){\n            if (entryName === CLIENT_STATIC_FILES_RUNTIME_MAIN_APP || entryName === APP_CLIENT_INTERNALS) {\n                entryName = '';\n            } else if (!/^app[\\\\/]/.test(entryName)) {\n                continue;\n            }\n            const manifest = {\n                moduleLoading: {\n                    prefix,\n                    crossOrigin: crossOriginMode\n                },\n                ssrModuleMapping: {},\n                edgeSSRModuleMapping: {},\n                clientModules: {},\n                entryCSSFiles: {},\n                rscModuleMapping: {},\n                edgeRscModuleMapping: {}\n            };\n            // Absolute path without the extension\n            const chunkEntryName = (this.appDirBase + entryName).replace(/[\\\\/]/g, path.sep);\n            manifest.entryCSSFiles[chunkEntryName] = entrypoint.getFiles().filter((f)=>!f.startsWith('static/css/pages/') && f.endsWith('.css')).map((file)=>{\n                const source = compilation.getAsset(file).source.source();\n                if (this.experimentalInlineCss && // Inline CSS currently does not work properly with HMR, so we only\n                // inline CSS in production.\n                !this.dev) {\n                    return {\n                        inlined: true,\n                        path: file,\n                        content: typeof source === 'string' ? source : source.toString()\n                    };\n                }\n                return {\n                    inlined: false,\n                    path: file\n                };\n            });\n            const requiredChunks = getAppPathRequiredChunks(entrypoint, rootMainFiles);\n            const recordModule = (modId, mod)=>{\n                var _mod_resourceResolveData, _mod_resourceResolveData1, _mod_matchResource;\n                let resource = mod.type === 'css/mini-extract' ? mod.identifier().slice(mod.identifier().lastIndexOf('!') + 1) : mod.resource;\n                if (!resource) {\n                    return;\n                }\n                const moduleReferences = manifest.clientModules;\n                const moduleIdMapping = manifest.ssrModuleMapping;\n                const edgeModuleIdMapping = manifest.edgeSSRModuleMapping;\n                const rscIdMapping = manifest.rscModuleMapping;\n                const edgeRscIdMapping = manifest.edgeRscModuleMapping;\n                // Note that this isn't that reliable as webpack is still possible to assign\n                // additional queries to make sure there's no conflict even using the `named`\n                // module ID strategy.\n                let ssrNamedModuleId = relative(context, ((_mod_resourceResolveData = mod.resourceResolveData) == null ? void 0 : _mod_resourceResolveData.path) || resource);\n                const rscNamedModuleId = relative(context, ((_mod_resourceResolveData1 = mod.resourceResolveData) == null ? void 0 : _mod_resourceResolveData1.path) || resource);\n                if (!ssrNamedModuleId.startsWith('.')) ssrNamedModuleId = `./${ssrNamedModuleId.replace(/\\\\/g, '/')}`;\n                // The client compiler will always use the CJS Next.js build, so here we\n                // also add the mapping for the ESM build (Edge runtime) to consume.\n                const esmResource = /[\\\\/]next[\\\\/]dist[\\\\/]/.test(resource) ? resource.replace(/[\\\\/]next[\\\\/]dist[\\\\/]/, '/next/dist/esm/'.replace(/\\//g, path.sep)) : null;\n                // An extra query param is added to the resource key when it's optimized\n                // through the Barrel Loader. That's because the same file might be created\n                // as multiple modules (depending on what you import from it).\n                // See also: webpack/loaders/next-flight-loader/index.ts.\n                if ((_mod_matchResource = mod.matchResource) == null ? void 0 : _mod_matchResource.startsWith(BARREL_OPTIMIZATION_PREFIX)) {\n                    ssrNamedModuleId = formatBarrelOptimizedResource(ssrNamedModuleId, mod.matchResource);\n                    resource = formatBarrelOptimizedResource(resource, mod.matchResource);\n                }\n                function addClientReference() {\n                    var _pluginState_ssrModules_ssrNamedModuleId, _pluginState_edgeSsrModules_ssrNamedModuleId;\n                    const isAsync = Boolean(compilation.moduleGraph.isAsync(mod) || ((_pluginState_ssrModules_ssrNamedModuleId = pluginState.ssrModules[ssrNamedModuleId]) == null ? void 0 : _pluginState_ssrModules_ssrNamedModuleId.async) || ((_pluginState_edgeSsrModules_ssrNamedModuleId = pluginState.edgeSsrModules[ssrNamedModuleId]) == null ? void 0 : _pluginState_edgeSsrModules_ssrNamedModuleId.async));\n                    const exportName = resource;\n                    manifest.clientModules[exportName] = {\n                        id: modId,\n                        name: '*',\n                        chunks: requiredChunks,\n                        async: isAsync\n                    };\n                    if (esmResource) {\n                        const edgeExportName = esmResource;\n                        manifest.clientModules[edgeExportName] = manifest.clientModules[exportName];\n                    }\n                }\n                function addSSRIdMapping() {\n                    const exportName = resource;\n                    const moduleInfo = pluginState.ssrModules[ssrNamedModuleId];\n                    if (moduleInfo) {\n                        moduleIdMapping[modId] = moduleIdMapping[modId] || {};\n                        moduleIdMapping[modId]['*'] = {\n                            ...manifest.clientModules[exportName],\n                            // During SSR, we don't have external chunks to load on the server\n                            // side with our architecture of Webpack / Turbopack. We can keep\n                            // this field empty to save some bytes.\n                            chunks: [],\n                            id: moduleInfo.moduleId,\n                            async: moduleInfo.async\n                        };\n                    }\n                    const edgeModuleInfo = pluginState.edgeSsrModules[ssrNamedModuleId];\n                    if (edgeModuleInfo) {\n                        edgeModuleIdMapping[modId] = edgeModuleIdMapping[modId] || {};\n                        edgeModuleIdMapping[modId]['*'] = {\n                            ...manifest.clientModules[exportName],\n                            // During SSR, we don't have external chunks to load on the server\n                            // side with our architecture of Webpack / Turbopack. We can keep\n                            // this field empty to save some bytes.\n                            chunks: [],\n                            id: edgeModuleInfo.moduleId,\n                            async: edgeModuleInfo.async\n                        };\n                    }\n                }\n                function addRSCIdMapping() {\n                    const exportName = resource;\n                    const moduleInfo = pluginState.rscModules[rscNamedModuleId];\n                    if (moduleInfo) {\n                        rscIdMapping[modId] = rscIdMapping[modId] || {};\n                        rscIdMapping[modId]['*'] = {\n                            ...manifest.clientModules[exportName],\n                            // During SSR, we don't have external chunks to load on the server\n                            // side with our architecture of Webpack / Turbopack. We can keep\n                            // this field empty to save some bytes.\n                            chunks: [],\n                            id: moduleInfo.moduleId,\n                            async: moduleInfo.async\n                        };\n                    }\n                    const edgeModuleInfo = pluginState.ssrModules[rscNamedModuleId];\n                    if (edgeModuleInfo) {\n                        edgeRscIdMapping[modId] = edgeRscIdMapping[modId] || {};\n                        edgeRscIdMapping[modId]['*'] = {\n                            ...manifest.clientModules[exportName],\n                            // During SSR, we don't have external chunks to load on the server\n                            // side with our architecture of Webpack / Turbopack. We can keep\n                            // this field empty to save some bytes.\n                            chunks: [],\n                            id: edgeModuleInfo.moduleId,\n                            async: edgeModuleInfo.async\n                        };\n                    }\n                }\n                addClientReference();\n                addSSRIdMapping();\n                addRSCIdMapping();\n                manifest.clientModules = moduleReferences;\n                manifest.ssrModuleMapping = moduleIdMapping;\n                manifest.edgeSSRModuleMapping = edgeModuleIdMapping;\n                manifest.rscModuleMapping = rscIdMapping;\n                manifest.edgeRscModuleMapping = edgeRscIdMapping;\n            };\n            const checkedChunkGroups = new Set();\n            const checkedChunks = new Set();\n            function recordChunkGroup(chunkGroup) {\n                // Ensure recursion is stopped if we've already checked this chunk group.\n                if (checkedChunkGroups.has(chunkGroup)) return;\n                checkedChunkGroups.add(chunkGroup);\n                // Only apply following logic to client module requests from client entry,\n                // or if the module is marked as client module. That's because other\n                // client modules don't need to be in the manifest at all as they're\n                // never be referenced by the server/client boundary.\n                // This saves a lot of bytes in the manifest.\n                chunkGroup.chunks.forEach((chunk)=>{\n                    // Ensure recursion is stopped if we've already checked this chunk.\n                    if (checkedChunks.has(chunk)) return;\n                    checkedChunks.add(chunk);\n                    const entryMods = compilation.chunkGraph.getChunkEntryModulesIterable(chunk);\n                    for (const mod of entryMods){\n                        if (mod.layer !== WEBPACK_LAYERS.appPagesBrowser) continue;\n                        const request = mod.request;\n                        if (!request || !request.includes('next-flight-client-entry-loader.js?')) {\n                            continue;\n                        }\n                        const connections = getModuleReferencesInOrder(mod, compilation.moduleGraph);\n                        for (const connection of connections){\n                            const dependency = connection.dependency;\n                            if (!dependency) continue;\n                            const clientEntryMod = compilation.moduleGraph.getResolvedModule(dependency);\n                            const modId = compilation.chunkGraph.getModuleId(clientEntryMod);\n                            if (modId !== null) {\n                                recordModule(modId, clientEntryMod);\n                            } else {\n                                var _connection_module;\n                                // If this is a concatenation, register each child to the parent ID.\n                                if (((_connection_module = connection.module) == null ? void 0 : _connection_module.constructor.name) === 'ConcatenatedModule') {\n                                    const concatenatedMod = connection.module;\n                                    const concatenatedModId = compilation.chunkGraph.getModuleId(concatenatedMod);\n                                    if (concatenatedModId) {\n                                        recordModule(concatenatedModId, clientEntryMod);\n                                    }\n                                }\n                            }\n                        }\n                    }\n                });\n                // Walk through all children chunk groups too.\n                for (const child of chunkGroup.childrenIterable){\n                    recordChunkGroup(child);\n                }\n            }\n            recordChunkGroup(entrypoint);\n            // A page's entry name can have extensions. For example, these are both valid:\n            // - app/foo/page\n            // - app/foo/page.page\n            if (/\\/page(\\.[^/]+)?$/.test(entryName)) {\n                manifestEntryFiles.push(entryName.replace(/\\/page(\\.[^/]+)?$/, '/page'));\n            }\n            // We also need to create manifests for route handler entrypoints to\n            // enable `'use cache'`.\n            if (/\\/route$/.test(entryName)) {\n                manifestEntryFiles.push(entryName);\n            }\n            const groupName = entryNameToGroupName(entryName);\n            if (!manifestsPerGroup.has(groupName)) {\n                manifestsPerGroup.set(groupName, []);\n            }\n            manifestsPerGroup.get(groupName).push(manifest);\n        }\n        // Generate per-page manifests.\n        for (const pageName of manifestEntryFiles){\n            const mergedManifest = {\n                moduleLoading: {\n                    prefix,\n                    crossOrigin: crossOriginMode\n                },\n                ssrModuleMapping: {},\n                edgeSSRModuleMapping: {},\n                clientModules: {},\n                entryCSSFiles: {},\n                rscModuleMapping: {},\n                edgeRscModuleMapping: {}\n            };\n            const segments = [\n                ...entryNameToGroupName(pageName).split('/'),\n                'page'\n            ];\n            let group = '';\n            for (const segment of segments){\n                for (const manifest of manifestsPerGroup.get(group) || []){\n                    mergeManifest(mergedManifest, manifest);\n                }\n                group += (group ? '/' : '') + segment;\n            }\n            const json = JSON.stringify(mergedManifest);\n            const pagePath = pageName.replace(/%5F/g, '_');\n            const pageBundlePath = normalizePagePath(pagePath.slice('app'.length));\n            compilation.emitAsset('server/app' + pageBundlePath + '_' + CLIENT_REFERENCE_MANIFEST + '.js', new sources.RawSource(`globalThis.__RSC_MANIFEST=(globalThis.__RSC_MANIFEST||{});globalThis.__RSC_MANIFEST[${JSON.stringify(pagePath.slice('app'.length))}]=${json}`));\n        }\n    }\n}\n\n//# sourceMappingURL=flight-manifest-plugin.js.map"
        }
    ]
}