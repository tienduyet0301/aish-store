{
    "sourceFile": "node_modules/next/dist/esm/build/webpack/plugins/slow-module-detection-plugin.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892760403,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import { yellow, green, blue } from '../../../lib/picocolors';\nconst PLUGIN_NAME = 'SlowModuleDetectionPlugin';\nconst TreeSymbols = {\n    VERTICAL_LINE: '│  ',\n    BRANCH: '├─ '\n};\nconst PATH_TRUNCATION_LENGTH = 120;\n// Matches node_modules paths, including pnpm-style paths\nconst NODE_MODULES_PATH_PATTERN = /node_modules(?:\\/\\.pnpm)?\\/(.*)/;\nconst getModuleIdentifier = (module)=>{\n    const debugId = module.debugId;\n    return String(debugId);\n};\nconst getModuleDisplayName = (module)=>{\n    const resourcePath = 'resource' in module && typeof module.resource === 'string' ? module.resource : undefined;\n    if (!resourcePath) {\n        return undefined;\n    }\n    let displayPath = resourcePath.replace(process.cwd(), '.');\n    const nodeModulesMatch = displayPath.match(NODE_MODULES_PATH_PATTERN);\n    if (nodeModulesMatch) {\n        return nodeModulesMatch[1];\n    }\n    return displayPath;\n};\n/**\n * Truncates a path to a maximum length. If the path exceeds this length,\n * it will be truncated in the middle and replaced with '...'.\n */ function truncatePath(path, maxLength) {\n    // If the path length is within the limit, return it as is\n    if (path.length <= maxLength) return path;\n    // Calculate the available length for the start and end segments after accounting for '...'\n    const availableLength = maxLength - 3;\n    const startSegmentLength = Math.ceil(availableLength / 2);\n    const endSegmentLength = Math.floor(availableLength / 2);\n    // Extract the start and end segments of the path\n    const startSegment = path.slice(0, startSegmentLength);\n    const endSegment = path.slice(-endSegmentLength);\n    // Return the truncated path with '...' in the middle\n    return `${startSegment}...${endSegment}`;\n}\nclass ModuleBuildTimeAnalyzer {\n    constructor(options){\n        this.options = options;\n        this.pendingModules = [];\n        this.modules = new Map();\n        this.moduleParents = new Map();\n        this.moduleChildren = new Map();\n        this.isFinalized = false;\n        this.moduleBuildTimes = new WeakMap();\n        this.buildTimeThresholdMs = options.buildTimeThresholdMs;\n    }\n    recordModuleBuildTime(module, duration) {\n        // Webpack guarantees that no more modules will be built after finishModules hook is called,\n        // where we generate the report. This check is just a defensive measure.\n        if (this.isFinalized) {\n            throw Object.defineProperty(new Error(`Invariant (SlowModuleDetectionPlugin): Module is recorded after the report is generated. This is a Next.js internal bug.`), \"__NEXT_ERROR_CODE\", {\n                value: \"E630\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n        if (duration < this.buildTimeThresholdMs) {\n            return; // Skip fast modules\n        }\n        this.moduleBuildTimes.set(module, duration);\n        this.pendingModules.push(module);\n    }\n    /**\n   * For each slow module, traverses up the dependency chain to find all ancestor modules.\n   * Builds a directed graph where:\n   * 1. Each slow module and its ancestors become nodes\n   * 2. Edges represent \"imported by\" relationships\n   * 3. Root nodes are entry points with no parents\n   *\n   * The resulting graph allows us to visualize the import chains that led to slow builds.\n   */ prepareReport(compilation) {\n        for (const module of this.pendingModules){\n            const chain = new Set();\n            // Walk up the module graph until we hit a root module (no issuer) to populate the chain\n            {\n                let currentModule = module;\n                chain.add(currentModule);\n                while(true){\n                    const issuerModule = compilation.moduleGraph.getIssuer(currentModule);\n                    if (!issuerModule) break;\n                    if (chain.has(issuerModule)) {\n                        throw Object.defineProperty(new Error(`Invariant (SlowModuleDetectionPlugin): Circular dependency detected in module graph. This is a Next.js internal bug.`), \"__NEXT_ERROR_CODE\", {\n                            value: \"E631\",\n                            enumerable: false,\n                            configurable: true\n                        });\n                    }\n                    chain.add(issuerModule);\n                    currentModule = issuerModule;\n                }\n            }\n            // Add all visited modules to our graph and create parent-child relationships\n            let previousModule = null;\n            for (const currentModule of chain){\n                const moduleId = getModuleIdentifier(currentModule);\n                if (!this.modules.has(moduleId)) {\n                    this.modules.set(moduleId, currentModule);\n                }\n                if (previousModule) {\n                    this.moduleParents.set(previousModule, currentModule);\n                    let parentChildren = this.moduleChildren.get(currentModule);\n                    if (!parentChildren) {\n                        parentChildren = new Map();\n                        this.moduleChildren.set(currentModule, parentChildren);\n                    }\n                    parentChildren.set(getModuleIdentifier(previousModule), previousModule);\n                }\n                previousModule = currentModule;\n            }\n        }\n        this.isFinalized = true;\n    }\n    generateReport(compilation) {\n        if (!this.isFinalized) {\n            this.prepareReport(compilation);\n        }\n        // Find root modules (those with no parents)\n        const rootModules = [\n            ...this.modules.values()\n        ].filter((node)=>!this.moduleParents.has(node));\n        const formatModuleNode = (node, depth)=>{\n            const moduleName = getModuleDisplayName(node) || '';\n            if (!moduleName) {\n                return formatChildModules(node, depth);\n            }\n            const prefix = ' ' + TreeSymbols.VERTICAL_LINE.repeat(depth) + TreeSymbols.BRANCH;\n            const moduleText = blue(truncatePath(moduleName, PATH_TRUNCATION_LENGTH - prefix.length));\n            const buildTimeMs = this.moduleBuildTimes.get(node);\n            const duration = buildTimeMs ? yellow(` (${Math.ceil(buildTimeMs)}ms)`) : '';\n            return prefix + moduleText + duration + '\\n' + formatChildModules(node, depth + 1);\n        };\n        const formatChildModules = (node, depth)=>{\n            const children = this.moduleChildren.get(node);\n            if (!children) return '';\n            return [\n                ...children\n            ].map(([_, child])=>formatModuleNode(child, depth)).join('');\n        };\n        const report = rootModules.map((root)=>formatModuleNode(root, 0)).join('');\n        if (report) {\n            console.log(green(`🐌 Detected slow modules while compiling ${this.options.compilerType}:`) + '\\n' + report);\n        }\n    }\n}\nexport default class SlowModuleDetectionPlugin {\n    constructor(options){\n        this.options = options;\n        this.apply = (compiler)=>{\n            compiler.hooks.compilation.tap(PLUGIN_NAME, (compilation)=>{\n                const analyzer = new ModuleBuildTimeAnalyzer(this.options);\n                const moduleBuildStartTimes = new WeakMap();\n                compilation.hooks.buildModule.tap(PLUGIN_NAME, (module)=>{\n                    moduleBuildStartTimes.set(module, performance.now());\n                });\n                compilation.hooks.succeedModule.tap(PLUGIN_NAME, (module)=>{\n                    const startTime = moduleBuildStartTimes.get(module);\n                    if (!startTime) {\n                        throw Object.defineProperty(new Error(`Invariant (SlowModuleDetectionPlugin): Unable to find the start time for a module build. This is a Next.js internal bug.`), \"__NEXT_ERROR_CODE\", {\n                            value: \"E629\",\n                            enumerable: false,\n                            configurable: true\n                        });\n                    }\n                    analyzer.recordModuleBuildTime(module, performance.now() - startTime);\n                });\n                compilation.hooks.finishModules.tap(PLUGIN_NAME, ()=>{\n                    analyzer.generateReport(compilation);\n                });\n            });\n        };\n    }\n}\n\n//# sourceMappingURL=slow-module-detection-plugin.js.map"
        }
    ]
}