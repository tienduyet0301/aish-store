{
    "sourceFile": "node_modules/next/dist/esm/build/webpack/plugins/profiling-plugin.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892760137,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import { NormalModule } from 'next/dist/compiled/webpack/webpack';\nimport path from 'path';\nconst pluginName = 'ProfilingPlugin';\nexport const spans = new WeakMap();\nconst moduleSpansByCompilation = new WeakMap();\nconst makeSpanByCompilation = new WeakMap();\nconst sealSpanByCompilation = new WeakMap();\nexport const webpackInvalidSpans = new WeakMap();\nconst TRACE_LABELS_SEAL = [\n    'module assets',\n    'create chunk assets',\n    'asset render',\n    'asset emit',\n    'store asset'\n];\nfunction inTraceLabelsSeal(label) {\n    return TRACE_LABELS_SEAL.some((l)=>label.startsWith(l));\n}\nexport class ProfilingPlugin {\n    constructor({ runWebpackSpan, rootDir }){\n        this.runWebpackSpan = runWebpackSpan;\n        this.rootDir = rootDir;\n    }\n    apply(compiler) {\n        this.traceTopLevelHooks(compiler);\n        this.traceCompilationHooks(compiler);\n        this.compiler = compiler;\n    }\n    traceHookPair(spanName, startHook, stopHook, { parentSpan, attrs, onStart, onStop } = {}) {\n        let span;\n        startHook.tap({\n            name: pluginName,\n            stage: -Infinity\n        }, (...params)=>{\n            const name = typeof spanName === 'function' ? spanName() : spanName;\n            const attributes = attrs ? attrs(...params) : attrs;\n            span = parentSpan ? parentSpan(...params).traceChild(name, attributes) : this.runWebpackSpan.traceChild(name, attributes);\n            if (onStart) onStart(span, ...params);\n        });\n        stopHook.tap({\n            name: pluginName,\n            stage: Infinity\n        }, (...params)=>{\n            // `stopHook` may be triggered when `startHook` has not in cases\n            // where `stopHook` is used as the terminating event for more\n            // than one pair of hooks.\n            if (!span) {\n                return;\n            }\n            if (onStop) onStop(span, ...params);\n            span.stop();\n        });\n    }\n    traceTopLevelHooks(compiler) {\n        this.traceHookPair('webpack-compilation', compiler.hooks.compilation, compiler.hooks.afterCompile, {\n            parentSpan: ()=>webpackInvalidSpans.get(compiler) || this.runWebpackSpan,\n            attrs: ()=>({\n                    name: compiler.name\n                }),\n            onStart: (span, compilation)=>{\n                spans.set(compilation, span);\n                spans.set(compiler, span);\n                moduleSpansByCompilation.set(compilation, new WeakMap());\n            }\n        });\n        if (compiler.options.mode === 'development') {\n            this.traceHookPair(()=>`webpack-invalidated-${compiler.name}`, compiler.hooks.invalid, compiler.hooks.done, {\n                onStart: (span)=>webpackInvalidSpans.set(compiler, span),\n                onStop: ()=>webpackInvalidSpans.delete(compiler),\n                attrs: (fileName)=>({\n                        trigger: fileName ? path.relative(this.rootDir, fileName).replaceAll(path.sep, '/') : 'manual'\n                    })\n            });\n        }\n    }\n    traceCompilationHooks(compiler) {\n        this.traceHookPair('emit', compiler.hooks.emit, compiler.hooks.afterEmit, {\n            parentSpan: ()=>webpackInvalidSpans.get(compiler) || this.runWebpackSpan\n        });\n        this.traceHookPair('make', compiler.hooks.make, compiler.hooks.finishMake, {\n            parentSpan: (compilation)=>{\n                const compilationSpan = spans.get(compilation);\n                if (!compilationSpan) {\n                    return webpackInvalidSpans.get(compiler) || this.runWebpackSpan;\n                }\n                return compilationSpan;\n            },\n            onStart: (span, compilation)=>{\n                makeSpanByCompilation.set(compilation, span);\n            },\n            onStop: (_span, compilation)=>{\n                makeSpanByCompilation.delete(compilation);\n            }\n        });\n        compiler.hooks.compilation.tap({\n            name: pluginName,\n            stage: -Infinity\n        }, (compilation)=>{\n            compilation.hooks.buildModule.tap(pluginName, (module)=>{\n                var _compilation_moduleGraph;\n                const moduleType = (()=>{\n                    const r = module.userRequest;\n                    if (!r || r.endsWith('!')) {\n                        return '';\n                    } else {\n                        const resource = r.split('!').pop();\n                        const match = /^[^?]+\\.([^?]+)$/.exec(resource);\n                        return match ? match[1] : '';\n                    }\n                })();\n                const issuerModule = compilation == null ? void 0 : (_compilation_moduleGraph = compilation.moduleGraph) == null ? void 0 : _compilation_moduleGraph.getIssuer(module);\n                let span;\n                const moduleSpans = moduleSpansByCompilation.get(compilation);\n                const spanName = `build-module${moduleType ? `-${moduleType}` : ''}`;\n                const issuerSpan = issuerModule && (moduleSpans == null ? void 0 : moduleSpans.get(issuerModule));\n                if (issuerSpan) {\n                    span = issuerSpan.traceChild(spanName);\n                } else {\n                    let parentSpan;\n                    for (const incomingConnection of compilation.moduleGraph.getIncomingConnections(module)){\n                        const entrySpan = spans.get(incomingConnection.dependency);\n                        if (entrySpan) {\n                            parentSpan = entrySpan;\n                            break;\n                        }\n                    }\n                    if (!parentSpan) {\n                        const compilationSpan = spans.get(compilation);\n                        if (!compilationSpan) {\n                            return;\n                        }\n                        parentSpan = compilationSpan;\n                    }\n                    span = parentSpan.traceChild(spanName);\n                }\n                span.setAttribute('name', module.userRequest);\n                span.setAttribute('layer', module.layer);\n                moduleSpans.set(module, span);\n            });\n            const moduleHooks = NormalModule.getCompilationHooks(compilation);\n            moduleHooks.readResource.for(undefined).intercept({\n                register (tapInfo) {\n                    const fn = tapInfo.fn;\n                    tapInfo.fn = (loaderContext, callback)=>{\n                        fn(loaderContext, (err, result)=>{\n                            callback(err, result);\n                        });\n                    };\n                    return tapInfo;\n                }\n            });\n            moduleHooks.loader.tap(pluginName, (loaderContext, module)=>{\n                var _moduleSpansByCompilation_get;\n                const moduleSpan = (_moduleSpansByCompilation_get = moduleSpansByCompilation.get(compilation)) == null ? void 0 : _moduleSpansByCompilation_get.get(module);\n                loaderContext.currentTraceSpan = moduleSpan;\n            });\n            compilation.hooks.succeedModule.tap(pluginName, (module)=>{\n                var _moduleSpansByCompilation_get_get, _moduleSpansByCompilation_get;\n                moduleSpansByCompilation == null ? void 0 : (_moduleSpansByCompilation_get = moduleSpansByCompilation.get(compilation)) == null ? void 0 : (_moduleSpansByCompilation_get_get = _moduleSpansByCompilation_get.get(module)) == null ? void 0 : _moduleSpansByCompilation_get_get.stop();\n            });\n            compilation.hooks.failedModule.tap(pluginName, (module)=>{\n                var _moduleSpansByCompilation_get_get, _moduleSpansByCompilation_get;\n                moduleSpansByCompilation == null ? void 0 : (_moduleSpansByCompilation_get = moduleSpansByCompilation.get(compilation)) == null ? void 0 : (_moduleSpansByCompilation_get_get = _moduleSpansByCompilation_get.get(module)) == null ? void 0 : _moduleSpansByCompilation_get_get.stop();\n            });\n            this.traceHookPair('seal', compilation.hooks.seal, compilation.hooks.afterSeal, {\n                parentSpan: ()=>spans.get(compilation),\n                onStart (span) {\n                    sealSpanByCompilation.set(compilation, span);\n                },\n                onStop () {\n                    sealSpanByCompilation.delete(compilation);\n                }\n            });\n            compilation.hooks.addEntry.tap(pluginName, (entry)=>{\n                const parentSpan = makeSpanByCompilation.get(compilation) || spans.get(compilation);\n                if (!parentSpan) {\n                    return;\n                }\n                const addEntrySpan = parentSpan.traceChild('add-entry');\n                addEntrySpan.setAttribute('request', entry.request);\n                spans.set(entry, addEntrySpan);\n            });\n            compilation.hooks.succeedEntry.tap(pluginName, (entry)=>{\n                var _spans_get;\n                (_spans_get = spans.get(entry)) == null ? void 0 : _spans_get.stop();\n                spans.delete(entry);\n            });\n            compilation.hooks.failedEntry.tap(pluginName, (entry)=>{\n                var _spans_get;\n                (_spans_get = spans.get(entry)) == null ? void 0 : _spans_get.stop();\n                spans.delete(entry);\n            });\n            this.traceHookPair('chunk-graph', compilation.hooks.beforeChunks, compilation.hooks.afterChunks, {\n                parentSpan: ()=>sealSpanByCompilation.get(compilation) || spans.get(compilation)\n            });\n            this.traceHookPair('optimize', compilation.hooks.optimize, compilation.hooks.reviveModules, {\n                parentSpan: ()=>sealSpanByCompilation.get(compilation) || spans.get(compilation)\n            });\n            this.traceHookPair('optimize-modules', compilation.hooks.optimizeModules, compilation.hooks.afterOptimizeModules, {\n                parentSpan: ()=>sealSpanByCompilation.get(compilation) || spans.get(compilation)\n            });\n            this.traceHookPair('optimize-chunks', compilation.hooks.optimizeChunks, compilation.hooks.afterOptimizeChunks, {\n                parentSpan: ()=>sealSpanByCompilation.get(compilation) || spans.get(compilation)\n            });\n            this.traceHookPair('optimize-tree', compilation.hooks.optimizeTree, compilation.hooks.afterOptimizeTree, {\n                parentSpan: ()=>sealSpanByCompilation.get(compilation) || spans.get(compilation)\n            });\n            this.traceHookPair('optimize-chunk-modules', compilation.hooks.optimizeChunkModules, compilation.hooks.afterOptimizeChunkModules, {\n                parentSpan: ()=>sealSpanByCompilation.get(compilation) || spans.get(compilation)\n            });\n            this.traceHookPair('module-hash', compilation.hooks.beforeModuleHash, compilation.hooks.afterModuleHash, {\n                parentSpan: ()=>sealSpanByCompilation.get(compilation) || spans.get(compilation)\n            });\n            this.traceHookPair('code-generation', compilation.hooks.beforeCodeGeneration, compilation.hooks.afterCodeGeneration, {\n                parentSpan: ()=>sealSpanByCompilation.get(compilation) || spans.get(compilation)\n            });\n            this.traceHookPair('hash', compilation.hooks.beforeHash, compilation.hooks.afterHash, {\n                parentSpan: ()=>sealSpanByCompilation.get(compilation) || spans.get(compilation)\n            });\n            this.traceHookPair('code-generation-jobs', compilation.hooks.afterHash, compilation.hooks.beforeModuleAssets, {\n                parentSpan: ()=>sealSpanByCompilation.get(compilation) || spans.get(compilation)\n            });\n            const logs = new Map();\n            const originalTime = compilation.logger.time;\n            const originalTimeEnd = compilation.logger.timeEnd;\n            compilation.logger.time = (label)=>{\n                if (!inTraceLabelsSeal(label)) {\n                    return originalTime.call(compilation.logger, label);\n                }\n                const span = sealSpanByCompilation.get(compilation);\n                if (span) {\n                    logs.set(label, span.traceChild(label.replace(/ /g, '-')));\n                }\n                return originalTime.call(compilation.logger, label);\n            };\n            compilation.logger.timeEnd = (label)=>{\n                if (!inTraceLabelsSeal(label)) {\n                    return originalTimeEnd.call(compilation.logger, label);\n                }\n                const span = logs.get(label);\n                if (span) {\n                    span.stop();\n                    logs.delete(label);\n                }\n                return originalTimeEnd.call(compilation.logger, label);\n            };\n        });\n    }\n}\n\n//# sourceMappingURL=profiling-plugin.js.map"
        }
    ]
}