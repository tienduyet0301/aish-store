{
    "sourceFile": "node_modules/next/dist/esm/build/webpack/plugins/jsconfig-paths-plugin.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892758920,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * This webpack resolver is largely based on TypeScript's \"paths\" handling\n * The TypeScript license can be found here:\n * https://github.com/microsoft/TypeScript/blob/214df64e287804577afa1fea0184c18c40f7d1ca/LICENSE.txt\n */ import path from 'path';\nimport { debug } from 'next/dist/compiled/debug';\nconst log = debug('next:jsconfig-paths-plugin');\nconst asterisk = 0x2a;\nexport function hasZeroOrOneAsteriskCharacter(str) {\n    let seenAsterisk = false;\n    for(let i = 0; i < str.length; i++){\n        if (str.charCodeAt(i) === asterisk) {\n            if (!seenAsterisk) {\n                seenAsterisk = true;\n            } else {\n                // have already seen asterisk\n                return false;\n            }\n        }\n    }\n    return true;\n}\n/**\n * Determines whether a path starts with a relative path component (i.e. `.` or `..`).\n */ export function pathIsRelative(testPath) {\n    return /^\\.\\.?($|[\\\\/])/.test(testPath);\n}\nexport function tryParsePattern(pattern) {\n    // This should be verified outside of here and a proper error thrown.\n    const indexOfStar = pattern.indexOf('*');\n    return indexOfStar === -1 ? undefined : {\n        prefix: pattern.slice(0, indexOfStar),\n        suffix: pattern.slice(indexOfStar + 1)\n    };\n}\nfunction isPatternMatch({ prefix, suffix }, candidate) {\n    return candidate.length >= prefix.length + suffix.length && candidate.startsWith(prefix) && candidate.endsWith(suffix);\n}\n/** Return the object corresponding to the best pattern to match `candidate`. */ export function findBestPatternMatch(values, getPattern, candidate) {\n    let matchedValue;\n    // use length of prefix as betterness criteria\n    let longestMatchPrefixLength = -1;\n    for (const v of values){\n        const pattern = getPattern(v);\n        if (isPatternMatch(pattern, candidate) && pattern.prefix.length > longestMatchPrefixLength) {\n            longestMatchPrefixLength = pattern.prefix.length;\n            matchedValue = v;\n        }\n    }\n    return matchedValue;\n}\n/**\n * patternStrings contains both pattern strings (containing \"*\") and regular strings.\n * Return an exact match if possible, or a pattern match, or undefined.\n * (These are verified by verifyCompilerOptions to have 0 or 1 \"*\" characters.)\n */ export function matchPatternOrExact(patternStrings, candidate) {\n    const patterns = [];\n    for (const patternString of patternStrings){\n        if (!hasZeroOrOneAsteriskCharacter(patternString)) continue;\n        const pattern = tryParsePattern(patternString);\n        if (pattern) {\n            patterns.push(pattern);\n        } else if (patternString === candidate) {\n            // pattern was matched as is - no need to search further\n            return patternString;\n        }\n    }\n    return findBestPatternMatch(patterns, (_)=>_, candidate);\n}\n/**\n * Tests whether a value is string\n */ export function isString(text) {\n    return typeof text === 'string';\n}\n/**\n * Given that candidate matches pattern, returns the text matching the '*'.\n * E.g.: matchedText(tryParsePattern(\"foo*baz\"), \"foobarbaz\") === \"bar\"\n */ export function matchedText(pattern, candidate) {\n    return candidate.substring(pattern.prefix.length, candidate.length - pattern.suffix.length);\n}\nexport function patternText({ prefix, suffix }) {\n    return `${prefix}*${suffix}`;\n}\n/**\n * Calls the iterator function for each entry of the array\n * until the first result or error is reached\n */ function forEachBail(array, iterator, callback) {\n    if (array.length === 0) return callback();\n    let i = 0;\n    const next = ()=>{\n        let loop = undefined;\n        iterator(array[i++], (err, result)=>{\n            if (err || result !== undefined || i >= array.length) {\n                return callback(err, result);\n            }\n            if (loop === false) while(next());\n            loop = true;\n        });\n        if (!loop) loop = false;\n        return loop;\n    };\n    while(next());\n}\nconst NODE_MODULES_REGEX = /node_modules/;\nexport class JsConfigPathsPlugin {\n    constructor(paths, resolvedBaseUrl){\n        this.paths = paths;\n        this.resolvedBaseUrl = resolvedBaseUrl;\n        this.jsConfigPlugin = true;\n        log('tsconfig.json or jsconfig.json paths: %O', paths);\n        log('resolved baseUrl: %s', resolvedBaseUrl);\n    }\n    apply(resolver) {\n        const target = resolver.ensureHook('resolve');\n        resolver.getHook('described-resolve').tapAsync('JsConfigPathsPlugin', (request, resolveContext, callback)=>{\n            const resolvedBaseUrl = this.resolvedBaseUrl;\n            if (resolvedBaseUrl === undefined) {\n                return callback();\n            }\n            const paths = this.paths;\n            const pathsKeys = Object.keys(paths);\n            // If no aliases are added bail out\n            if (pathsKeys.length === 0) {\n                log('paths are empty, bailing out');\n                return callback();\n            }\n            const moduleName = request.request;\n            // Exclude node_modules from paths support (speeds up resolving)\n            if (request.path.match(NODE_MODULES_REGEX)) {\n                log('skipping request as it is inside node_modules %s', moduleName);\n                return callback();\n            }\n            if (path.posix.isAbsolute(moduleName) || process.platform === 'win32' && path.win32.isAbsolute(moduleName)) {\n                log('skipping request as it is an absolute path %s', moduleName);\n                return callback();\n            }\n            if (pathIsRelative(moduleName)) {\n                log('skipping request as it is a relative path %s', moduleName);\n                return callback();\n            }\n            // log('starting to resolve request %s', moduleName)\n            // If the module name does not match any of the patterns in `paths` we hand off resolving to webpack\n            const matchedPattern = matchPatternOrExact(pathsKeys, moduleName);\n            if (!matchedPattern) {\n                log('moduleName did not match any paths pattern %s', moduleName);\n                return callback();\n            }\n            const matchedStar = isString(matchedPattern) ? undefined : matchedText(matchedPattern, moduleName);\n            const matchedPatternText = isString(matchedPattern) ? matchedPattern : patternText(matchedPattern);\n            let triedPaths = [];\n            forEachBail(paths[matchedPatternText], (subst, pathCallback)=>{\n                const curPath = matchedStar ? subst.replace('*', matchedStar) : subst;\n                // Ensure .d.ts is not matched\n                if (curPath.endsWith('.d.ts')) {\n                    // try next path candidate\n                    return pathCallback();\n                }\n                const candidate = path.join(resolvedBaseUrl.baseUrl, curPath);\n                const obj = Object.assign({}, request, {\n                    request: candidate\n                });\n                resolver.doResolve(target, obj, `Aliased with tsconfig.json or jsconfig.json ${matchedPatternText} to ${candidate}`, resolveContext, (resolverErr, resolverResult)=>{\n                    if (resolverErr || resolverResult === undefined) {\n                        triedPaths.push(candidate);\n                        // try next path candidate\n                        return pathCallback();\n                    }\n                    return pathCallback(resolverErr, resolverResult);\n                });\n            }, callback);\n        });\n    }\n}\n\n//# sourceMappingURL=jsconfig-paths-plugin.js.map"
        }
    ]
}