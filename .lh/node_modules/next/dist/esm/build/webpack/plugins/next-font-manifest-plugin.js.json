{
    "sourceFile": "node_modules/next/dist/esm/build/webpack/plugins/next-font-manifest-plugin.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892759388,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import { webpack, sources } from 'next/dist/compiled/webpack/webpack';\nimport getRouteFromEntrypoint from '../../../server/get-route-from-entrypoint';\nimport { NEXT_FONT_MANIFEST } from '../../../shared/lib/constants';\nimport { traverseModules } from '../utils';\nimport path from 'path';\nconst PLUGIN_NAME = 'NextFontManifestPlugin';\n/**\n * When calling font functions with next/font, you can specify if you'd like the font to be preloaded (true by default).\n * e.g.: const inter = Inter({ subsets: ['latin'], preload: true })\n *\n * In that case, next-font-loader will emit the font file as [name].p.[ext] instead of [name].[ext]\n * This function returns those files from an array that can include both preloaded and non-preloaded files.\n */ function getPreloadedFontFiles(fontFiles) {\n    return fontFiles.filter((file)=>/\\.p\\.(woff|woff2|eot|ttf|otf)$/.test(file));\n}\n/**\n * Similarly to getPreloadedFontFiles, but returns true if some of the files includes -s in the name.\n * This means that a font is using size adjust in its fallback font.\n * This was added to enable adding data-size-adjust=\"true\" to the dom, used by the Google Aurora team to collect statistics.\n */ function getPageIsUsingSizeAdjust(fontFiles) {\n    return fontFiles.some((file)=>file.includes('-s'));\n}\n/**\n * The NextFontManifestPlugin collects all font files emitted by next-font-loader and creates a manifest file.\n * The manifest file is used in the Next.js render functions (_document.tsx for pages/ and app-render for app/) to add preload tags for the font files.\n * We only want to att preload fonts that are used by the current route.\n *\n * For pages/ the plugin finds the fonts imported in the entrypoint chunks and creates a map:\n * { [route]: fontFile[] }\n * When rendering the app in _document.tsx, it gets the font files to preload: manifest.pages[currentRouteBeingRendered].\n *\n * For app/, the manifest is a bit different.\n * Instead of creating a map of route to font files, it creates a map of the webpack module request to font files.\n * { [webpackModuleRequest]: fontFile[]]}\n * When creating the component tree in app-render it looks for font files to preload: manifest.app[moduleBeingRendered]\n */ export class NextFontManifestPlugin {\n    constructor(options){\n        this.appDir = options.appDir;\n    }\n    apply(compiler) {\n        compiler.hooks.make.tap(PLUGIN_NAME, (compilation)=>{\n            // In this stage the font files are emitted and we can collect all files emitted by each chunkGroup (entry).\n            compilation.hooks.processAssets.tap({\n                name: PLUGIN_NAME,\n                stage: webpack.Compilation.PROCESS_ASSETS_STAGE_ADDITIONS\n            }, ()=>{\n                const nextFontManifest = {\n                    pages: {},\n                    app: {},\n                    appUsingSizeAdjust: false,\n                    pagesUsingSizeAdjust: false\n                };\n                if (this.appDir) {\n                    const appDirBase = path.dirname(this.appDir) + path.sep;\n                    // After all modules are created, we collect the modules that was created by next-font-loader.\n                    traverseModules(compilation, (mod, _chunk, chunkGroup)=>{\n                        var _mod_request;\n                        if (mod == null ? void 0 : (_mod_request = mod.request) == null ? void 0 : _mod_request.includes('/next-font-loader/index.js?')) {\n                            var _mod_buildInfo;\n                            if (!((_mod_buildInfo = mod.buildInfo) == null ? void 0 : _mod_buildInfo.assets)) return;\n                            const chunkEntryName = (appDirBase + chunkGroup.name).replace(/[\\\\/]/g, path.sep);\n                            const modAssets = Object.keys(mod.buildInfo.assets);\n                            const fontFiles = modAssets.filter((file)=>/\\.(woff|woff2|eot|ttf|otf)$/.test(file));\n                            // Look if size-adjust fallback font is being used\n                            if (!nextFontManifest.appUsingSizeAdjust) {\n                                nextFontManifest.appUsingSizeAdjust = getPageIsUsingSizeAdjust(fontFiles);\n                            }\n                            const preloadedFontFiles = getPreloadedFontFiles(fontFiles);\n                            // Add an entry of the module's font files in the manifest.\n                            // We'll add an entry even if no files should preload.\n                            // When an entry is present but empty, instead of preloading the font files, a preconnect tag is added.\n                            if (fontFiles.length > 0) {\n                                if (!nextFontManifest.app[chunkEntryName]) {\n                                    nextFontManifest.app[chunkEntryName] = [];\n                                }\n                                nextFontManifest.app[chunkEntryName].push(...preloadedFontFiles);\n                            }\n                        }\n                    }, (chunkGroup)=>{\n                        var _chunkGroup_name;\n                        // Only loop through entrypoints that are under app/.\n                        return !!((_chunkGroup_name = chunkGroup.name) == null ? void 0 : _chunkGroup_name.startsWith('app/'));\n                    });\n                }\n                // Look at all the entrypoints created for pages/.\n                for (const entrypoint of compilation.entrypoints.values()){\n                    const pagePath = getRouteFromEntrypoint(entrypoint.name);\n                    if (!pagePath) {\n                        continue;\n                    }\n                    // Get font files from the chunks included in the entrypoint.\n                    const fontFiles = entrypoint.chunks.flatMap((chunk)=>[\n                            ...chunk.auxiliaryFiles\n                        ]).filter((file)=>/\\.(woff|woff2|eot|ttf|otf)$/.test(file));\n                    // Look if size-adjust fallback font is being used\n                    if (!nextFontManifest.pagesUsingSizeAdjust) {\n                        nextFontManifest.pagesUsingSizeAdjust = getPageIsUsingSizeAdjust(fontFiles);\n                    }\n                    const preloadedFontFiles = getPreloadedFontFiles(fontFiles);\n                    // Add an entry of the route's font files in the manifest.\n                    // We'll add an entry even if no files should preload.\n                    // When an entry is present but empty, instead of preloading the font files, a preconnect tag is added.\n                    if (fontFiles.length > 0) {\n                        nextFontManifest.pages[pagePath] = preloadedFontFiles;\n                    }\n                }\n                const manifest = JSON.stringify(nextFontManifest, null);\n                // Create manifest for edge\n                compilation.emitAsset(`server/${NEXT_FONT_MANIFEST}.js`, new sources.RawSource(`self.__NEXT_FONT_MANIFEST=${JSON.stringify(manifest)}`));\n                // Create manifest for server\n                compilation.emitAsset(`server/${NEXT_FONT_MANIFEST}.json`, new sources.RawSource(manifest));\n            });\n        });\n        return;\n    }\n}\n\n//# sourceMappingURL=next-font-manifest-plugin.js.map"
        }
    ]
}