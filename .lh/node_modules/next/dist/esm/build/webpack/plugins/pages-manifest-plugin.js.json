{
    "sourceFile": "node_modules/next/dist/esm/build/webpack/plugins/pages-manifest-plugin.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892760058,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import path from 'path';\nimport fs from 'fs/promises';\nimport { webpack, sources } from 'next/dist/compiled/webpack/webpack';\nimport { PAGES_MANIFEST, APP_PATHS_MANIFEST } from '../../../shared/lib/constants';\nimport getRouteFromEntrypoint from '../../../server/get-route-from-entrypoint';\nimport { normalizePathSep } from '../../../shared/lib/page-path/normalize-path-sep';\nexport let edgeServerPages = {};\nexport let nodeServerPages = {};\nexport let edgeServerAppPaths = {};\nexport let nodeServerAppPaths = {};\n// This plugin creates a pages-manifest.json from page entrypoints.\n// This is used for mapping paths like `/` to `.next/server/static/<buildid>/pages/index.js` when doing SSR\n// It's also used by next export to provide defaultPathMap\nexport default class PagesManifestPlugin {\n    constructor({ dev, distDir, isEdgeRuntime, appDirEnabled }){\n        this.dev = dev;\n        this.distDir = distDir;\n        this.isEdgeRuntime = isEdgeRuntime;\n        this.appDirEnabled = appDirEnabled;\n    }\n    async createAssets(compilation) {\n        const entrypoints = compilation.entrypoints;\n        const pages = {};\n        const appPaths = {};\n        for (const entrypoint of entrypoints.values()){\n            const pagePath = getRouteFromEntrypoint(entrypoint.name, this.appDirEnabled);\n            if (!pagePath) {\n                continue;\n            }\n            const files = entrypoint.getFiles().filter((file)=>!file.includes('webpack-runtime') && !file.includes('webpack-api-runtime') && file.endsWith('.js'));\n            // Skip entries which are empty\n            if (!files.length) {\n                continue;\n            }\n            // Write filename, replace any backslashes in path (on windows) with forwardslashes for cross-platform consistency.\n            let file = files[files.length - 1];\n            if (!this.dev) {\n                if (!this.isEdgeRuntime) {\n                    file = file.slice(3);\n                }\n            }\n            file = normalizePathSep(file);\n            if (entrypoint.name.startsWith('app/')) {\n                appPaths[pagePath] = file;\n            } else {\n                pages[pagePath] = file;\n            }\n        }\n        // This plugin is used by both the Node server and Edge server compilers,\n        // we need to merge both pages to generate the full manifest.\n        if (this.isEdgeRuntime) {\n            edgeServerPages = pages;\n            edgeServerAppPaths = appPaths;\n        } else {\n            nodeServerPages = pages;\n            nodeServerAppPaths = appPaths;\n        }\n        // handle parallel compilers writing to the same\n        // manifest path by merging existing manifest with new\n        const writeMergedManifest = async (manifestPath, entries)=>{\n            await fs.mkdir(path.dirname(manifestPath), {\n                recursive: true\n            });\n            await fs.writeFile(manifestPath, JSON.stringify({\n                ...await fs.readFile(manifestPath, 'utf8').then((res)=>JSON.parse(res)).catch(()=>({})),\n                ...entries\n            }, null, 2));\n        };\n        if (this.distDir) {\n            const pagesManifestPath = path.join(this.distDir, 'server', PAGES_MANIFEST);\n            await writeMergedManifest(pagesManifestPath, {\n                ...edgeServerPages,\n                ...nodeServerPages\n            });\n        } else {\n            const pagesManifestPath = (!this.dev && !this.isEdgeRuntime ? '../' : '') + PAGES_MANIFEST;\n            compilation.emitAsset(pagesManifestPath, new sources.RawSource(JSON.stringify({\n                ...edgeServerPages,\n                ...nodeServerPages\n            }, null, 2)));\n        }\n        if (this.appDirEnabled) {\n            if (this.distDir) {\n                const appPathsManifestPath = path.join(this.distDir, 'server', APP_PATHS_MANIFEST);\n                await writeMergedManifest(appPathsManifestPath, {\n                    ...edgeServerAppPaths,\n                    ...nodeServerAppPaths\n                });\n            } else {\n                compilation.emitAsset((!this.dev && !this.isEdgeRuntime ? '../' : '') + APP_PATHS_MANIFEST, new sources.RawSource(JSON.stringify({\n                    ...edgeServerAppPaths,\n                    ...nodeServerAppPaths\n                }, null, 2)));\n            }\n        }\n    }\n    apply(compiler) {\n        compiler.hooks.make.tap('NextJsPagesManifest', (compilation)=>{\n            compilation.hooks.processAssets.tapPromise({\n                name: 'NextJsPagesManifest',\n                stage: webpack.Compilation.PROCESS_ASSETS_STAGE_ADDITIONS\n            }, ()=>this.createAssets(compilation));\n        });\n    }\n}\n\n//# sourceMappingURL=pages-manifest-plugin.js.map"
        }
    ]
}