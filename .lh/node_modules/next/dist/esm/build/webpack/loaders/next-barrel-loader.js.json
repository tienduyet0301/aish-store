{
    "sourceFile": "node_modules/next/dist/esm/build/webpack/loaders/next-barrel-loader.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892754812,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * ## Barrel Optimizations\n *\n * This loader is used to optimize the imports of \"barrel\" files that have many\n * re-exports. Currently, both Node.js and Webpack have to enter all of these\n * submodules even if we only need a few of them.\n *\n * For example, say a file `foo.js` with the following contents:\n *\n *   export { a } from './a'\n *   export { b } from './b'\n *   export { c } from './c'\n *   ...\n *\n * If the user imports `a` only, this loader will accept the `names` option to\n * be `['a']`. Then, it request the \"__barrel_transform__\" SWC transform to load\n * `foo.js` and receive the following output:\n *\n *   export const __next_private_export_map__ = '[[\"a\",\"./a\",\"a\"],[\"b\",\"./b\",\"b\"],[\"c\",\"./c\",\"c\"],...]'\n *\n *   format: '[\"<imported identifier>\", \"<import path>\", \"<exported name>\"]'\n *   e.g.: import { a as b } from './module-a' => '[\"b\", \"./module-a\", \"a\"]'\n *\n * The export map, generated by SWC, is a JSON that represents the exports of\n * that module, their original file, and their original name (since you can do\n * `export { a as b }`).\n *\n * Then, this loader can safely remove all the exports that are not needed and\n * re-export the ones from `names`:\n *\n *   export { a } from './a'\n *\n * That's the basic situation and also the happy path.\n *\n *\n *\n * ## Wildcard Exports\n *\n * For wildcard exports (e.g. `export * from './a'`), it becomes a bit more complicated.\n * Say `foo.js` with the following contents:\n *\n *   export * from './a'\n *   export * from './b'\n *   export * from './c'\n *   ...\n *\n * If the user imports `bar` from it, SWC can never know which files are going to be\n * exporting `bar`. So, we have to keep all the wildcard exports and do the same\n * process recursively. This loader will return the following output:\n *\n *   export * from '__barrel_optimize__?names=bar&wildcard!=!./a'\n *   export * from '__barrel_optimize__?names=bar&wildcard!=!./b'\n *   export * from '__barrel_optimize__?names=bar&wildcard!=!./c'\n *   ...\n *\n * The \"!=!\" tells Webpack to use the same loader to process './a', './b', and './c'.\n * After the recursive process, the \"inner loaders\" will either return an empty string\n * or:\n *\n *   export * from './target'\n *\n * Where `target` is the file that exports `bar`.\n *\n *\n *\n * ## Non-Barrel Files\n *\n * If the file is not a barrel, we can't apply any optimizations. That's because\n * we can't easily remove things from the file. For example, say `foo.js` with:\n *\n *   const v = 1\n *   export function b () {\n *     return v\n *   }\n *\n * If the user imports `b` only, we can't remove the `const v = 1` even though\n * the file is side-effect free. In these caes, this loader will simply re-export\n * `foo.js`:\n *\n *   export * from './foo'\n *\n * Besides these cases, this loader also carefully handles the module cache so\n * SWC won't analyze the same file twice, and no instance of the same file will\n * be accidentally created as different instances.\n */ import path from 'path';\nimport { transform } from '../../swc';\n// This is a in-memory cache for the mapping of barrel exports. This only applies\n// to the packages that we optimize. It will never change (e.g. upgrading packages)\n// during the lifetime of the server so we can safely cache it.\n// There is also no need to collect the cache for the same reason.\nconst barrelTransformMappingCache = new Map();\nasync function getBarrelMapping(resourcePath, swcCacheDir, resolve, fs) {\n    if (barrelTransformMappingCache.has(resourcePath)) {\n        return barrelTransformMappingCache.get(resourcePath);\n    }\n    // This is a SWC transform specifically for `optimizeBarrelExports`. We don't\n    // care about other things but the export map only.\n    async function transpileSource(filename, source, isWildcard) {\n        const isTypeScript = filename.endsWith('.ts') || filename.endsWith('.tsx');\n        return new Promise((res)=>transform(source, {\n                filename,\n                inputSourceMap: undefined,\n                sourceFileName: filename,\n                optimizeBarrelExports: {\n                    wildcard: isWildcard\n                },\n                jsc: {\n                    parser: {\n                        syntax: isTypeScript ? 'typescript' : 'ecmascript',\n                        [isTypeScript ? 'tsx' : 'jsx']: true\n                    },\n                    experimental: {\n                        cacheRoot: swcCacheDir\n                    }\n                }\n            }).then((output)=>{\n                res(output.code);\n            }));\n    }\n    // Avoid circular `export *` dependencies\n    const visited = new Set();\n    async function getMatches(file, isWildcard, isClientEntry) {\n        if (visited.has(file)) {\n            return null;\n        }\n        visited.add(file);\n        const source = await new Promise((res, rej)=>{\n            fs.readFile(file, (err, data)=>{\n                if (err || data === undefined) {\n                    rej(err);\n                } else {\n                    res(data.toString());\n                }\n            });\n        });\n        const output = await transpileSource(file, source, isWildcard);\n        const matches = output.match(/^([^]*)export (const|var) __next_private_export_map__ = ('[^']+'|\"[^\"]+\")/);\n        if (!matches) {\n            return null;\n        }\n        const matchedDirectives = output.match(/^([^]*)export (const|var) __next_private_directive_list__ = '([^']+)'/);\n        const directiveList = matchedDirectives ? JSON.parse(matchedDirectives[3]) : [];\n        // \"use client\" in barrel files has to be transferred to the target file.\n        isClientEntry = directiveList.includes('use client');\n        let exportList = JSON.parse(matches[3].slice(1, -1));\n        const wildcardExports = [\n            ...output.matchAll(/export \\* from \"([^\"]+)\"/g)\n        ].map((match)=>match[1]);\n        // In the wildcard case, if the value is exported from another file, we\n        // redirect to that file (decl[0]). Otherwise, export from the current\n        // file itself.\n        if (isWildcard) {\n            for (const decl of exportList){\n                decl[1] = file;\n                decl[2] = decl[0];\n            }\n        }\n        // This recursively handles the wildcard exports (e.g. `export * from './a'`)\n        if (wildcardExports.length) {\n            await Promise.all(wildcardExports.map(async (req)=>{\n                const targetPath = await resolve(path.dirname(file), req.replace('__barrel_optimize__?names=__PLACEHOLDER__!=!', ''));\n                const targetMatches = await getMatches(targetPath, true, isClientEntry);\n                if (targetMatches) {\n                    // Merge the export list\n                    exportList = exportList.concat(targetMatches.exportList);\n                }\n            }));\n        }\n        return {\n            exportList,\n            wildcardExports,\n            isClientEntry\n        };\n    }\n    const res = await getMatches(resourcePath, false, false);\n    barrelTransformMappingCache.set(resourcePath, res);\n    return res;\n}\nconst NextBarrelLoader = async function() {\n    this.async();\n    this.cacheable(true);\n    const { names, swcCacheDir } = this.getOptions();\n    // For barrel optimizations, we always prefer the \"module\" field over the\n    // \"main\" field because ESM handling is more robust with better tree-shaking.\n    const resolve = this.getResolve({\n        mainFields: [\n            'module',\n            'main'\n        ]\n    });\n    const mapping = await getBarrelMapping(this.resourcePath, swcCacheDir, resolve, this.fs);\n    // `resolve` adds all sub-paths to the dependency graph. However, we already\n    // cached the mapping and we assume them to not change. So, we can safely\n    // clear the dependencies here to avoid unnecessary watchers which turned out\n    // to be very expensive.\n    this.clearDependencies();\n    if (!mapping) {\n        // This file isn't a barrel and we can't apply any optimizations. Let's re-export everything.\n        // Since this loader accepts `names` and the request is keyed with `names`, we can't simply\n        // return the original source here. That will create these imports with different names as\n        // different modules instances.\n        this.callback(null, `export * from ${JSON.stringify(this.resourcePath)}`);\n        return;\n    }\n    const exportList = mapping.exportList;\n    const isClientEntry = mapping.isClientEntry;\n    const exportMap = new Map();\n    for (const [name, filePath, orig] of exportList){\n        exportMap.set(name, [\n            filePath,\n            orig\n        ]);\n    }\n    let output = '';\n    let missedNames = [];\n    for (const name of names){\n        // If the name matches\n        if (exportMap.has(name)) {\n            const decl = exportMap.get(name);\n            if (decl[1] === '*') {\n                output += `\\nexport * as ${name} from ${JSON.stringify(decl[0])}`;\n            } else if (decl[1] === 'default') {\n                output += `\\nexport { default as ${name} } from ${JSON.stringify(decl[0])}`;\n            } else if (decl[1] === name) {\n                output += `\\nexport { ${name} } from ${JSON.stringify(decl[0])}`;\n            } else {\n                output += `\\nexport { ${decl[1]} as ${name} } from ${JSON.stringify(decl[0])}`;\n            }\n        } else {\n            missedNames.push(name);\n        }\n    }\n    // These are from wildcard exports.\n    if (missedNames.length > 0) {\n        for (const req of mapping.wildcardExports){\n            output += `\\nexport * from ${JSON.stringify(req.replace('__PLACEHOLDER__', missedNames.join(',') + '&wildcard'))}`;\n        }\n    }\n    // When it has `\"use client\"` inherited from its barrel files, we need to\n    // prefix it to this target file as well.\n    if (isClientEntry) {\n        output = `\"use client\";\\n${output}`;\n    }\n    this.callback(null, output);\n};\nexport default NextBarrelLoader;\n\n//# sourceMappingURL=next-barrel-loader.js.map"
        }
    ]
}