{
    "sourceFile": "node_modules/next/dist/esm/build/webpack/loaders/postcss-loader/src/index.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892757366,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import Warning from './Warning';\nimport SyntaxError from './Error';\nimport { normalizeSourceMap, normalizeSourceMapAfterPostcss } from './utils';\n/**\n * **PostCSS Loader**\n *\n * Loads && processes CSS with [PostCSS](https://github.com/postcss/postcss)\n */ export default async function loader(/** Source */ content, /** Source Map */ sourceMap, meta) {\n    const loaderSpan = this.currentTraceSpan.traceChild('postcss-loader');\n    const callback = this.async();\n    loaderSpan.traceAsyncFn(async ()=>{\n        const options = this.getOptions();\n        const file = this.resourcePath;\n        const useSourceMap = typeof options.sourceMap !== 'undefined' ? options.sourceMap : this.sourceMap;\n        const processOptions = {\n            from: file,\n            to: file\n        };\n        if (useSourceMap) {\n            processOptions.map = {\n                inline: false,\n                annotation: false,\n                ...processOptions.map\n            };\n        }\n        if (sourceMap && processOptions.map) {\n            processOptions.map.prev = loaderSpan.traceChild('normalize-source-map').traceFn(()=>normalizeSourceMap(sourceMap, this.context));\n        }\n        let root;\n        // Reuse PostCSS AST from other loaders\n        if (meta && meta.ast && meta.ast.type === 'postcss') {\n            ;\n            ({ root } = meta.ast);\n            loaderSpan.setAttribute('astUsed', 'true');\n        }\n        // Initializes postcss with plugins\n        const { postcssWithPlugins } = await options.postcss();\n        let result;\n        try {\n            result = await loaderSpan.traceChild('postcss-process').traceAsyncFn(()=>postcssWithPlugins.process(root || content, processOptions));\n        } catch (error) {\n            if (error.file) {\n                this.addDependency(error.file);\n            }\n            if (error.name === 'CssSyntaxError') {\n                throw Object.defineProperty(new SyntaxError(error), \"__NEXT_ERROR_CODE\", {\n                    value: \"E394\",\n                    enumerable: false,\n                    configurable: true\n                });\n            }\n            throw error;\n        }\n        for (const warning of result.warnings()){\n            this.emitWarning(Object.defineProperty(new Warning(warning), \"__NEXT_ERROR_CODE\", {\n                value: \"E394\",\n                enumerable: false,\n                configurable: true\n            }));\n        }\n        for (const message of result.messages){\n            // eslint-disable-next-line default-case\n            switch(message.type){\n                case 'dependency':\n                    this.addDependency(message.file);\n                    break;\n                case 'build-dependency':\n                    this.addBuildDependency(message.file);\n                    break;\n                case 'missing-dependency':\n                    this.addMissingDependency(message.file);\n                    break;\n                case 'context-dependency':\n                    this.addContextDependency(message.file);\n                    break;\n                case 'dir-dependency':\n                    this.addContextDependency(message.dir);\n                    break;\n                case 'asset':\n                    if (message.content && message.file) {\n                        this.emitFile(message.file, message.content, message.sourceMap, message.info);\n                    }\n            }\n        }\n        // eslint-disable-next-line no-undefined\n        let map = result.map ? result.map.toJSON() : undefined;\n        if (map && useSourceMap) {\n            map = normalizeSourceMapAfterPostcss(map, this.context);\n        }\n        const ast = {\n            type: 'postcss',\n            version: result.processor.version,\n            root: result.root\n        };\n        return [\n            result.css,\n            map,\n            {\n                ast\n            }\n        ];\n    }).then(([css, map, { ast }])=>{\n        callback == null ? void 0 : callback(null, css, map, {\n            ast\n        });\n    }, (err)=>{\n        callback == null ? void 0 : callback(err);\n    });\n}\n\n//# sourceMappingURL=index.js.map"
        }
    ]
}