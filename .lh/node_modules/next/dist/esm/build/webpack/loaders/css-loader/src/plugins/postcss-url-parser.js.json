{
    "sourceFile": "node_modules/next/dist/esm/build/webpack/loaders/css-loader/src/plugins/postcss-url-parser.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892753473,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import valueParser from 'next/dist/compiled/postcss-value-parser';\nimport { resolveRequests, normalizeUrl, requestify, isUrlRequestable, isDataUrl, // @ts-expect-error TODO: this export doesn't exist? Double check.\nWEBPACK_IGNORE_COMMENT_REGEXP } from '../utils';\nconst isUrlFunc = /url/i;\nconst isImageSetFunc = /^(?:-webkit-)?image-set$/i;\nconst needParseDeclaration = /(?:url|(?:-webkit-)?image-set)\\(/i;\nfunction getNodeFromUrlFunc(node) {\n    return node.nodes && node.nodes[0];\n}\nfunction getWebpackIgnoreCommentValue(index, nodes, inBetween) {\n    if (index === 0 && typeof inBetween !== 'undefined') {\n        return inBetween;\n    }\n    let prevValueNode = nodes[index - 1];\n    if (!prevValueNode) {\n        // eslint-disable-next-line consistent-return\n        return;\n    }\n    if (prevValueNode.type === 'space') {\n        if (!nodes[index - 2]) {\n            // eslint-disable-next-line consistent-return\n            return;\n        }\n        prevValueNode = nodes[index - 2];\n    }\n    if (prevValueNode.type !== 'comment') {\n        // eslint-disable-next-line consistent-return\n        return;\n    }\n    const matched = prevValueNode.value.match(WEBPACK_IGNORE_COMMENT_REGEXP);\n    return matched && matched[2] === 'true';\n}\nfunction shouldHandleURL(url, declaration, result, isSupportDataURLInNewURL) {\n    if (url.length === 0) {\n        result.warn(`Unable to find uri in '${declaration.toString()}'`, {\n            node: declaration\n        });\n        return false;\n    }\n    if (isDataUrl(url) && isSupportDataURLInNewURL) {\n        try {\n            decodeURIComponent(url);\n        } catch (ignoreError) {\n            return false;\n        }\n        return true;\n    }\n    if (!isUrlRequestable(url)) {\n        return false;\n    }\n    return true;\n}\nfunction parseDeclaration(declaration, key, result, isSupportDataURLInNewURL) {\n    if (!needParseDeclaration.test(declaration[key])) {\n        return;\n    }\n    const parsed = valueParser(declaration.raws && declaration.raws.value && declaration.raws.value.raw ? declaration.raws.value.raw : declaration[key]);\n    let inBetween;\n    if (declaration.raws && declaration.raws.between) {\n        const lastCommentIndex = declaration.raws.between.lastIndexOf('/*');\n        const matched = declaration.raws.between.slice(lastCommentIndex).match(WEBPACK_IGNORE_COMMENT_REGEXP);\n        if (matched) {\n            inBetween = matched[2] === 'true';\n        }\n    }\n    let isIgnoreOnDeclaration = false;\n    const prevNode = declaration.prev();\n    if (prevNode && prevNode.type === 'comment') {\n        const matched = prevNode.text.match(WEBPACK_IGNORE_COMMENT_REGEXP);\n        if (matched) {\n            isIgnoreOnDeclaration = matched[2] === 'true';\n        }\n    }\n    let needIgnore;\n    const parsedURLs = [];\n    parsed.walk((valueNode, index, valueNodes)=>{\n        if (valueNode.type !== 'function') {\n            return;\n        }\n        if (isUrlFunc.test(valueNode.value)) {\n            needIgnore = getWebpackIgnoreCommentValue(index, valueNodes, inBetween);\n            if (isIgnoreOnDeclaration && typeof needIgnore === 'undefined' || needIgnore) {\n                if (needIgnore) {\n                    // eslint-disable-next-line no-undefined\n                    needIgnore = undefined;\n                }\n                return;\n            }\n            const { nodes } = valueNode;\n            const isStringValue = nodes.length !== 0 && nodes[0].type === 'string';\n            let url = isStringValue ? nodes[0].value : valueParser.stringify(nodes);\n            url = normalizeUrl(url, isStringValue);\n            // Do not traverse inside `url`\n            if (!shouldHandleURL(url, declaration, result, isSupportDataURLInNewURL)) {\n                // eslint-disable-next-line consistent-return\n                return false;\n            }\n            const queryParts = url.split('!');\n            let prefix;\n            if (queryParts.length > 1) {\n                url = queryParts.pop();\n                prefix = queryParts.join('!');\n            }\n            parsedURLs.push({\n                declaration,\n                parsed,\n                node: getNodeFromUrlFunc(valueNode),\n                prefix,\n                url,\n                needQuotes: false\n            });\n            // eslint-disable-next-line consistent-return\n            return false;\n        } else if (isImageSetFunc.test(valueNode.value)) {\n            for (const [innerIndex, nNode] of valueNode.nodes.entries()){\n                const { type, value } = nNode;\n                if (type === 'function' && isUrlFunc.test(value)) {\n                    needIgnore = getWebpackIgnoreCommentValue(innerIndex, valueNode.nodes);\n                    if (isIgnoreOnDeclaration && typeof needIgnore === 'undefined' || needIgnore) {\n                        if (needIgnore) {\n                            // eslint-disable-next-line no-undefined\n                            needIgnore = undefined;\n                        }\n                        continue;\n                    }\n                    const { nodes } = nNode;\n                    const isStringValue = nodes.length !== 0 && nodes[0].type === 'string';\n                    let url = isStringValue ? nodes[0].value : valueParser.stringify(nodes);\n                    url = normalizeUrl(url, isStringValue);\n                    // Do not traverse inside `url`\n                    if (!shouldHandleURL(url, declaration, result, isSupportDataURLInNewURL)) {\n                        // eslint-disable-next-line consistent-return\n                        return false;\n                    }\n                    const queryParts = url.split('!');\n                    let prefix;\n                    if (queryParts.length > 1) {\n                        url = queryParts.pop();\n                        prefix = queryParts.join('!');\n                    }\n                    parsedURLs.push({\n                        declaration,\n                        parsed,\n                        node: getNodeFromUrlFunc(nNode),\n                        prefix,\n                        url,\n                        needQuotes: false\n                    });\n                } else if (type === 'string') {\n                    needIgnore = getWebpackIgnoreCommentValue(innerIndex, valueNode.nodes);\n                    if (isIgnoreOnDeclaration && typeof needIgnore === 'undefined' || needIgnore) {\n                        if (needIgnore) {\n                            // eslint-disable-next-line no-undefined\n                            needIgnore = undefined;\n                        }\n                        continue;\n                    }\n                    let url = normalizeUrl(value, true);\n                    // Do not traverse inside `url`\n                    if (!shouldHandleURL(url, declaration, result, isSupportDataURLInNewURL)) {\n                        // eslint-disable-next-line consistent-return\n                        return false;\n                    }\n                    const queryParts = url.split('!');\n                    let prefix;\n                    if (queryParts.length > 1) {\n                        url = queryParts.pop();\n                        prefix = queryParts.join('!');\n                    }\n                    parsedURLs.push({\n                        declaration,\n                        parsed,\n                        node: nNode,\n                        prefix,\n                        url,\n                        needQuotes: true\n                    });\n                }\n            }\n            // Do not traverse inside `image-set`\n            // eslint-disable-next-line consistent-return\n            return false;\n        }\n    });\n    // eslint-disable-next-line consistent-return\n    return parsedURLs;\n}\nconst plugin = (options = {})=>{\n    return {\n        postcssPlugin: 'postcss-url-parser',\n        prepare (result) {\n            const parsedDeclarations = [];\n            return {\n                Declaration (declaration) {\n                    const { isSupportDataURLInNewURL } = options;\n                    const parsedURL = parseDeclaration(declaration, 'value', result, isSupportDataURLInNewURL);\n                    if (!parsedURL) {\n                        return;\n                    }\n                    parsedDeclarations.push(...parsedURL);\n                },\n                async OnceExit () {\n                    if (parsedDeclarations.length === 0) {\n                        return;\n                    }\n                    const resolvedDeclarations = await Promise.all(parsedDeclarations.map(async (parsedDeclaration)=>{\n                        const { url } = parsedDeclaration;\n                        if (options.filter) {\n                            const needKeep = await options.filter(url);\n                            if (!needKeep) {\n                                // eslint-disable-next-line consistent-return\n                                return;\n                            }\n                        }\n                        if (isDataUrl(url)) {\n                            // eslint-disable-next-line consistent-return\n                            return parsedDeclaration;\n                        }\n                        const [pathname, query, hashOrQuery] = url.split(/(\\?)?#/, 3);\n                        let hash = query ? '?' : '';\n                        hash += hashOrQuery ? `#${hashOrQuery}` : '';\n                        const { needToResolveURL, rootContext } = options;\n                        const request = requestify(pathname, rootContext, // @ts-expect-error TODO: only 2 arguments allowed.\n                        needToResolveURL);\n                        if (!needToResolveURL) {\n                            // eslint-disable-next-line consistent-return\n                            return {\n                                ...parsedDeclaration,\n                                url: request,\n                                hash\n                            };\n                        }\n                        const { resolver, context } = options;\n                        const resolvedUrl = await resolveRequests(resolver, context, [\n                            ...new Set([\n                                request,\n                                url\n                            ])\n                        ]);\n                        if (!resolvedUrl) {\n                            // eslint-disable-next-line consistent-return\n                            return;\n                        }\n                        // eslint-disable-next-line consistent-return\n                        return {\n                            ...parsedDeclaration,\n                            url: resolvedUrl,\n                            hash\n                        };\n                    }));\n                    const urlToNameMap = new Map();\n                    const urlToReplacementMap = new Map();\n                    let hasUrlImportHelper = false;\n                    for(let index = 0; index <= resolvedDeclarations.length - 1; index++){\n                        const item = resolvedDeclarations[index];\n                        if (!item) {\n                            continue;\n                        }\n                        if (!hasUrlImportHelper) {\n                            options.imports.push({\n                                type: 'get_url_import',\n                                importName: '___CSS_LOADER_GET_URL_IMPORT___',\n                                url: options.urlHandler(require.resolve('../runtime/getUrl.js')),\n                                index: -1\n                            });\n                            hasUrlImportHelper = true;\n                        }\n                        const { url, prefix } = item;\n                        const newUrl = prefix ? `${prefix}!${url}` : url;\n                        let importName = urlToNameMap.get(newUrl);\n                        if (!importName) {\n                            importName = `___CSS_LOADER_URL_IMPORT_${urlToNameMap.size}___`;\n                            urlToNameMap.set(newUrl, importName);\n                            options.imports.push({\n                                type: 'url',\n                                importName,\n                                url: options.needToResolveURL ? options.urlHandler(newUrl) : JSON.stringify(newUrl),\n                                index\n                            });\n                        }\n                        const { hash, needQuotes } = item;\n                        const replacementKey = JSON.stringify({\n                            newUrl,\n                            hash,\n                            needQuotes\n                        });\n                        let replacementName = urlToReplacementMap.get(replacementKey);\n                        if (!replacementName) {\n                            replacementName = `___CSS_LOADER_URL_REPLACEMENT_${urlToReplacementMap.size}___`;\n                            urlToReplacementMap.set(replacementKey, replacementName);\n                            options.replacements.push({\n                                replacementName,\n                                importName,\n                                hash,\n                                needQuotes\n                            });\n                        }\n                        // eslint-disable-next-line no-param-reassign\n                        item.node.type = 'word';\n                        // eslint-disable-next-line no-param-reassign\n                        item.node.value = replacementName;\n                        // eslint-disable-next-line no-param-reassign\n                        item.declaration.value = item.parsed.toString();\n                    }\n                }\n            };\n        }\n    };\n};\nplugin.postcss = true;\nexport default plugin;\n\n//# sourceMappingURL=postcss-url-parser.js.map"
        }
    ]
}