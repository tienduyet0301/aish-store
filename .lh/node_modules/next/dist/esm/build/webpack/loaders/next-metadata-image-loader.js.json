{
    "sourceFile": "node_modules/next/dist/esm/build/webpack/loaders/next-metadata-image-loader.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892756541,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/*\n * This loader is responsible for extracting the metadata image info for rendering in html\n */ import { existsSync, promises as fs } from 'fs';\nimport path from 'path';\nimport loaderUtils from 'next/dist/compiled/loader-utils3';\nimport { getImageSize } from '../../../server/image-optimizer';\nimport { imageExtMimeTypeMap } from '../../../lib/mime-type';\nimport { WEBPACK_RESOURCE_QUERIES } from '../../../lib/constants';\nimport { normalizePathSep } from '../../../shared/lib/page-path/normalize-path-sep';\nimport { getLoaderModuleNamedExports } from './utils';\n// [NOTE] For turbopack, refer to app_page_loader_tree's write_metadata_item for\n// corresponding features.\nasync function nextMetadataImageLoader(content) {\n    const options = this.getOptions();\n    const { type, segment, pageExtensions, basePath } = options;\n    const { resourcePath, rootContext: context } = this;\n    const { name: fileNameBase, ext } = path.parse(resourcePath);\n    const useNumericSizes = type === 'twitter' || type === 'openGraph';\n    let extension = ext.slice(1);\n    if (extension === 'jpg') {\n        extension = 'jpeg';\n    }\n    const opts = {\n        context,\n        content\n    };\n    // No hash query for favicon.ico\n    const contentHash = type === 'favicon' ? '' : loaderUtils.interpolateName(this, '[contenthash]', opts);\n    const interpolatedName = loaderUtils.interpolateName(this, '[name].[ext]', opts);\n    const isDynamicResource = pageExtensions.includes(extension);\n    const pageSegment = isDynamicResource ? fileNameBase : interpolatedName;\n    const hashQuery = contentHash ? '?' + contentHash : '';\n    const pathnamePrefix = normalizePathSep(path.join(basePath, segment));\n    if (isDynamicResource) {\n        const exportedFieldsExcludingDefault = (await getLoaderModuleNamedExports(resourcePath, this)).filter((name)=>name !== 'default');\n        // re-export and spread as `exportedImageData` to avoid non-exported error\n        return `\\\n    import {\n      ${exportedFieldsExcludingDefault.map((field)=>`${field} as _${field}`).join(',')}\n    } from ${JSON.stringify(// This is an arbitrary resource query to ensure it's a new request, instead\n        // of sharing the same module with next-metadata-route-loader.\n        // Since here we only need export fields such as `size`, `alt` and\n        // `generateImageMetadata`, avoid sharing the same module can make this entry\n        // smaller.\n        resourcePath + '?' + WEBPACK_RESOURCE_QUERIES.metadataImageMeta)}\n    import { fillMetadataSegment } from 'next/dist/lib/metadata/get-metadata-route'\n\n    const imageModule = {\n      ${exportedFieldsExcludingDefault.map((field)=>`${field}: _${field}`).join(',')}\n    }\n\n    export default async function (props) {\n      const { __metadata_id__: _, ...params } = await props.params\n      const imageUrl = fillMetadataSegment(${JSON.stringify(pathnamePrefix)}, params, ${JSON.stringify(pageSegment)})\n\n      const { generateImageMetadata } = imageModule\n\n      function getImageMetadata(imageMetadata, idParam) {\n        const data = {\n          alt: imageMetadata.alt,\n          type: imageMetadata.contentType || 'image/png',\n          url: imageUrl + (idParam ? ('/' + idParam) : '') + ${JSON.stringify(hashQuery)},\n        }\n        const { size } = imageMetadata\n        if (size) {\n          ${type === 'twitter' || type === 'openGraph' ? 'data.width = size.width; data.height = size.height;' : 'data.sizes = size.width + \"x\" + size.height;'}\n        }\n        return data\n      }\n\n      if (generateImageMetadata) {\n        const imageMetadataArray = await generateImageMetadata({ params })\n        return imageMetadataArray.map((imageMetadata, index) => {\n          const idParam = (imageMetadata.id || index) + ''\n          return getImageMetadata(imageMetadata, idParam)\n        })\n      } else {\n        return [getImageMetadata(imageModule, '')]\n      }\n    }`;\n    }\n    const imageSize = await getImageSize(content).catch((err)=>err);\n    if (imageSize instanceof Error) {\n        const err = imageSize;\n        err.name = 'InvalidImageFormatError';\n        throw err;\n    }\n    const imageData = {\n        ...extension in imageExtMimeTypeMap && {\n            type: imageExtMimeTypeMap[extension]\n        },\n        ...useNumericSizes && imageSize.width != null && imageSize.height != null ? imageSize : {\n            sizes: // For SVGs, skip sizes and use \"any\" to let it scale automatically based on viewport,\n            // For the images doesn't provide the size properly, use \"any\" as well.\n            // If the size is presented, use the actual size for the image.\n            extension !== 'svg' && imageSize.width != null && imageSize.height != null ? `${imageSize.width}x${imageSize.height}` : 'any'\n        }\n    };\n    if (type === 'openGraph' || type === 'twitter') {\n        const altPath = path.join(path.dirname(resourcePath), fileNameBase + '.alt.txt');\n        if (existsSync(altPath)) {\n            imageData.alt = await fs.readFile(altPath, 'utf8');\n        }\n    }\n    return `\\\n  import { fillMetadataSegment } from 'next/dist/lib/metadata/get-metadata-route'\n\n  export default async (props) => {\n    const imageData = ${JSON.stringify(imageData)}\n    const imageUrl = fillMetadataSegment(${JSON.stringify(pathnamePrefix)}, await props.params, ${JSON.stringify(pageSegment)})\n\n    return [{\n      ...imageData,\n      url: imageUrl + ${JSON.stringify(type === 'favicon' ? '' : hashQuery)},\n    }]\n  }`;\n}\nexport const raw = true;\nexport default nextMetadataImageLoader;\n\n//# sourceMappingURL=next-metadata-image-loader.js.map"
        }
    ]
}