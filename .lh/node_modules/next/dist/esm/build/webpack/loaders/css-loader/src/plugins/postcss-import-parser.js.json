{
    "sourceFile": "node_modules/next/dist/esm/build/webpack/loaders/css-loader/src/plugins/postcss-import-parser.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892753416,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import valueParser from 'next/dist/compiled/postcss-value-parser';\nimport { normalizeUrl, resolveRequests, isUrlRequestable, requestify, // @ts-expect-error TODO: this export doesn't exist? Double check.\nWEBPACK_IGNORE_COMMENT_REGEXP } from '../utils';\nfunction parseNode(atRule, key) {\n    // Convert only top-level @import\n    if (atRule.parent.type !== 'root') {\n        return;\n    }\n    if (atRule.raws && atRule.raws.afterName && atRule.raws.afterName.trim().length > 0) {\n        const lastCommentIndex = atRule.raws.afterName.lastIndexOf('/*');\n        const matched = atRule.raws.afterName.slice(lastCommentIndex).match(WEBPACK_IGNORE_COMMENT_REGEXP);\n        if (matched && matched[2] === 'true') {\n            return;\n        }\n    }\n    const prevNode = atRule.prev();\n    if (prevNode && prevNode.type === 'comment') {\n        const matched = prevNode.text.match(WEBPACK_IGNORE_COMMENT_REGEXP);\n        if (matched && matched[2] === 'true') {\n            return;\n        }\n    }\n    // Nodes do not exists - `@import url('http://') :root {}`\n    if (atRule.nodes) {\n        const error = Object.defineProperty(new Error(\"It looks like you didn't end your @import statement correctly. Child nodes are attached to it.\"), \"__NEXT_ERROR_CODE\", {\n            value: \"E341\",\n            enumerable: false,\n            configurable: true\n        });\n        error.node = atRule;\n        throw error;\n    }\n    const { nodes: paramsNodes } = valueParser(atRule[key]);\n    // No nodes - `@import ;`\n    // Invalid type - `@import foo-bar;`\n    if (paramsNodes.length === 0 || paramsNodes[0].type !== 'string' && paramsNodes[0].type !== 'function') {\n        const error = Object.defineProperty(new Error(`Unable to find uri in \"${atRule.toString()}\"`), \"__NEXT_ERROR_CODE\", {\n            value: \"E215\",\n            enumerable: false,\n            configurable: true\n        });\n        error.node = atRule;\n        throw error;\n    }\n    let isStringValue;\n    let url;\n    if (paramsNodes[0].type === 'string') {\n        isStringValue = true;\n        url = paramsNodes[0].value;\n    } else {\n        // Invalid function - `@import nourl(test.css);`\n        if (paramsNodes[0].value.toLowerCase() !== 'url') {\n            const error = Object.defineProperty(new Error(`Unable to find uri in \"${atRule.toString()}\"`), \"__NEXT_ERROR_CODE\", {\n                value: \"E215\",\n                enumerable: false,\n                configurable: true\n            });\n            error.node = atRule;\n            throw error;\n        }\n        isStringValue = paramsNodes[0].nodes.length !== 0 && paramsNodes[0].nodes[0].type === 'string';\n        url = isStringValue ? paramsNodes[0].nodes[0].value : valueParser.stringify(paramsNodes[0].nodes);\n    }\n    url = normalizeUrl(url, isStringValue);\n    const isRequestable = isUrlRequestable(url);\n    let prefix;\n    if (isRequestable) {\n        const queryParts = url.split('!');\n        if (queryParts.length > 1) {\n            url = queryParts.pop();\n            prefix = queryParts.join('!');\n        }\n    }\n    // Empty url - `@import \"\";` or `@import url();`\n    if (url.trim().length === 0) {\n        const error = Object.defineProperty(new Error(`Unable to find uri in \"${atRule.toString()}\"`), \"__NEXT_ERROR_CODE\", {\n            value: \"E215\",\n            enumerable: false,\n            configurable: true\n        });\n        error.node = atRule;\n        throw error;\n    }\n    const mediaNodes = paramsNodes.slice(1);\n    let media;\n    if (mediaNodes.length > 0) {\n        media = valueParser.stringify(mediaNodes).trim().toLowerCase();\n    }\n    // eslint-disable-next-line consistent-return\n    return {\n        atRule,\n        prefix,\n        url,\n        media,\n        isRequestable\n    };\n}\nconst plugin = (options = {})=>{\n    return {\n        postcssPlugin: 'postcss-import-parser',\n        prepare (result) {\n            const parsedAtRules = [];\n            return {\n                AtRule: {\n                    import (atRule) {\n                        let parsedAtRule;\n                        try {\n                            // @ts-expect-error TODO: there is no third argument?\n                            parsedAtRule = parseNode(atRule, 'params', result);\n                        } catch (error) {\n                            result.warn(error.message, {\n                                node: error.node\n                            });\n                        }\n                        if (!parsedAtRule) {\n                            return;\n                        }\n                        parsedAtRules.push(parsedAtRule);\n                    }\n                },\n                async OnceExit () {\n                    if (parsedAtRules.length === 0) {\n                        return;\n                    }\n                    const resolvedAtRules = await Promise.all(parsedAtRules.map(async (parsedAtRule)=>{\n                        const { atRule, isRequestable, prefix, url, media } = parsedAtRule;\n                        if (options.filter) {\n                            const needKeep = await options.filter(url, media);\n                            if (!needKeep) {\n                                return;\n                            }\n                        }\n                        if (isRequestable) {\n                            const request = requestify(url, options.rootContext);\n                            const { resolver, context } = options;\n                            const resolvedUrl = await resolveRequests(resolver, context, [\n                                ...new Set([\n                                    request,\n                                    url\n                                ])\n                            ]);\n                            if (!resolvedUrl) {\n                                return;\n                            }\n                            if (resolvedUrl === options.resourcePath) {\n                                atRule.remove();\n                                return;\n                            }\n                            atRule.remove();\n                            // eslint-disable-next-line consistent-return\n                            return {\n                                url: resolvedUrl,\n                                media,\n                                prefix,\n                                isRequestable\n                            };\n                        }\n                        atRule.remove();\n                        // eslint-disable-next-line consistent-return\n                        return {\n                            url,\n                            media,\n                            prefix,\n                            isRequestable\n                        };\n                    }));\n                    const urlToNameMap = new Map();\n                    for(let index = 0; index <= resolvedAtRules.length - 1; index++){\n                        const resolvedAtRule = resolvedAtRules[index];\n                        if (!resolvedAtRule) {\n                            continue;\n                        }\n                        const { url, isRequestable, media } = resolvedAtRule;\n                        if (!isRequestable) {\n                            options.api.push({\n                                url,\n                                media,\n                                index\n                            });\n                            continue;\n                        }\n                        const { prefix } = resolvedAtRule;\n                        const newUrl = prefix ? `${prefix}!${url}` : url;\n                        let importName = urlToNameMap.get(newUrl);\n                        if (!importName) {\n                            importName = `___CSS_LOADER_AT_RULE_IMPORT_${urlToNameMap.size}___`;\n                            urlToNameMap.set(newUrl, importName);\n                            options.imports.push({\n                                type: 'rule_import',\n                                importName,\n                                url: options.urlHandler(newUrl),\n                                index\n                            });\n                        }\n                        options.api.push({\n                            importName,\n                            media,\n                            index\n                        });\n                    }\n                }\n            };\n        }\n    };\n};\nplugin.postcss = true;\nexport default plugin;\n\n//# sourceMappingURL=postcss-import-parser.js.map"
        }
    ]
}