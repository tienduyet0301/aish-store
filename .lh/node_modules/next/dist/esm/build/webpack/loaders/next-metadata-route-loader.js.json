{
    "sourceFile": "node_modules/next/dist/esm/build/webpack/loaders/next-metadata-route-loader.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892756609,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import fs from 'fs';\nimport path from 'path';\nimport { imageExtMimeTypeMap } from '../../../lib/mime-type';\nimport { getLoaderModuleNamedExports } from './utils';\nfunction errorOnBadHandler(resourcePath) {\n    return `\n  if (typeof handler !== 'function') {\n    throw new Error('Default export is missing in ${JSON.stringify(resourcePath)}')\n  }\n  `;\n}\n/* re-export the userland route configs */ async function createReExportsCode(resourcePath, loaderContext) {\n    const exportNames = await getLoaderModuleNamedExports(resourcePath, loaderContext);\n    // Re-export configs but avoid conflicted exports\n    const reExportNames = exportNames.filter((name)=>name !== 'default' && name !== 'generateSitemaps');\n    return reExportNames.length > 0 ? `export { ${reExportNames.join(', ')} } from ${JSON.stringify(resourcePath)}\\n` : '';\n}\nconst cacheHeader = {\n    none: 'no-cache, no-store',\n    longCache: 'public, immutable, no-transform, max-age=31536000',\n    revalidate: 'public, max-age=0, must-revalidate'\n};\nexport function getFilenameAndExtension(resourcePath) {\n    const filename = path.basename(resourcePath);\n    const [name, ext] = filename.split('.', 2);\n    return {\n        name,\n        ext\n    };\n}\nfunction getContentType(resourcePath) {\n    let { name, ext } = getFilenameAndExtension(resourcePath);\n    if (ext === 'jpg') ext = 'jpeg';\n    if (name === 'favicon' && ext === 'ico') return 'image/x-icon';\n    if (name === 'sitemap') return 'application/xml';\n    if (name === 'robots') return 'text/plain';\n    if (name === 'manifest') return 'application/manifest+json';\n    if (ext === 'png' || ext === 'jpeg' || ext === 'ico' || ext === 'svg') {\n        return imageExtMimeTypeMap[ext];\n    }\n    return 'text/plain';\n}\nasync function getStaticAssetRouteCode(resourcePath, fileBaseName) {\n    const cache = fileBaseName === 'favicon' ? 'public, max-age=0, must-revalidate' : process.env.NODE_ENV !== 'production' ? cacheHeader.none : cacheHeader.longCache;\n    const isTwitter = fileBaseName === 'twitter-image';\n    const isOpenGraph = fileBaseName === 'opengraph-image';\n    // Twitter image file size limit is 5MB.\n    // General Open Graph image file size limit is 8MB.\n    // x-ref: https://developer.x.com/en/docs/x-for-websites/cards/overview/summary\n    // x-ref(facebook): https://developers.facebook.com/docs/sharing/webmasters/images\n    const fileSizeLimit = isTwitter ? 5 : 8;\n    const imgName = isTwitter ? 'Twitter' : 'Open Graph';\n    const code = `\\\n/* static asset route */\nimport { NextResponse } from 'next/server'\n\nconst contentType = ${JSON.stringify(getContentType(resourcePath))}\nconst buffer = Buffer.from(${JSON.stringify((await fs.promises.readFile(resourcePath)).toString('base64'))}, 'base64'\n  )\n\nif (${isTwitter || isOpenGraph}) {\n  const fileSizeInMB = buffer.byteLength / 1024 / 1024\n  if (fileSizeInMB > ${fileSizeLimit}) {\n    throw new Error('File size for ${imgName} image ${JSON.stringify(resourcePath)} exceeds ${fileSizeLimit}MB. ' +\n    \\`(Current: \\${fileSizeInMB.toFixed(2)}MB)\\n\\` +\n    'Read more: https://nextjs.org/docs/app/api-reference/file-conventions/metadata/opengraph-image#image-files-jpg-png-gif'\n    )\n  }\n}\n\nexport function GET() {\n  return new NextResponse(buffer, {\n    headers: {\n      'Content-Type': contentType,\n      'Cache-Control': ${JSON.stringify(cache)},\n    },\n  })\n}\n\nexport const dynamic = 'force-static'\n`;\n    return code;\n}\nasync function getDynamicTextRouteCode(resourcePath, loaderContext) {\n    return `\\\n/* dynamic asset route */\nimport { NextResponse } from 'next/server'\nimport handler from ${JSON.stringify(resourcePath)}\nimport { resolveRouteData } from 'next/dist/build/webpack/loaders/metadata/resolve-route-data'\n\nconst contentType = ${JSON.stringify(getContentType(resourcePath))}\nconst fileType = ${JSON.stringify(getFilenameAndExtension(resourcePath).name)}\n\n${errorOnBadHandler(resourcePath)}\n${await createReExportsCode(resourcePath, loaderContext)}\n\nexport async function GET() {\n  const data = await handler()\n  const content = resolveRouteData(data, fileType)\n\n  return new NextResponse(content, {\n    headers: {\n      'Content-Type': contentType,\n      'Cache-Control': ${JSON.stringify(cacheHeader.revalidate)},\n    },\n  })\n}\n`;\n}\n// <metadata-image>/[id]/route.js\nasync function getDynamicImageRouteCode(resourcePath, loaderContext) {\n    return `\\\n/* dynamic image route */\nimport { NextResponse } from 'next/server'\nimport * as userland from ${JSON.stringify(resourcePath)}\n\nconst imageModule = { ...userland }\n\nconst handler = imageModule.default\nconst generateImageMetadata = imageModule.generateImageMetadata\n\n${errorOnBadHandler(resourcePath)}\n${await createReExportsCode(resourcePath, loaderContext)}\n\nexport async function GET(_, ctx) {\n  const params = await ctx.params\n  const { __metadata_id__, ...rest } = params || {}\n  const restParams = params ? rest : undefined\n  const targetId = __metadata_id__\n  let id = undefined\n  \n  if (generateImageMetadata) {\n    const imageMetadata = await generateImageMetadata({ params: restParams })\n    id = imageMetadata.find((item) => {\n      if (process.env.NODE_ENV !== 'production') {\n        if (item?.id == null) {\n          throw new Error('id property is required for every item returned from generateImageMetadata')\n        }\n      }\n      return item.id.toString() === targetId\n    })?.id\n    if (id == null) {\n      return new NextResponse('Not Found', {\n        status: 404,\n      })\n    }\n  }\n\n  return handler({ params: restParams, id })\n}\n`;\n}\nasync function getDynamicSitemapRouteCode(resourcePath, loaderContext) {\n    let staticGenerationCode = '';\n    const exportNames = await getLoaderModuleNamedExports(resourcePath, loaderContext);\n    const hasGenerateSitemaps = exportNames.includes('generateSitemaps');\n    if (process.env.NODE_ENV === 'production' && hasGenerateSitemaps) {\n        staticGenerationCode = `\\\n    /* dynamic sitemap route */\n    export async function generateStaticParams() {\n      const sitemaps = await sitemapModule.generateSitemaps()\n      const params = []\n\n      for (const item of sitemaps) {\n        params.push({ __metadata_id__: item.id.toString() + '.xml' })\n      }\n      return params\n    }\n    `;\n    }\n    const code = `\\\nimport { NextResponse } from 'next/server'\nimport * as userland from ${JSON.stringify(resourcePath)}\nimport { resolveRouteData } from 'next/dist/build/webpack/loaders/metadata/resolve-route-data'\n\nconst sitemapModule = { ...userland }\nconst handler = sitemapModule.default\nconst contentType = ${JSON.stringify(getContentType(resourcePath))}\nconst fileType = ${JSON.stringify(getFilenameAndExtension(resourcePath).name)}\n\n${errorOnBadHandler(resourcePath)}\n${await createReExportsCode(resourcePath, loaderContext)}\n\nexport async function GET(_, ctx) {\n  const { __metadata_id__: id, ...params } = await ctx.params || {}\n  const hasXmlExtension = id ? id.endsWith('.xml') : false\n\n  if (id && !hasXmlExtension) {\n    return new NextResponse('Not Found', {\n      status: 404,\n    })\n  }\n\n  if (process.env.NODE_ENV !== 'production' && sitemapModule.generateSitemaps) {\n    const sitemaps = await sitemapModule.generateSitemaps()\n    for (const item of sitemaps) {\n      if (item?.id == null) {\n        throw new Error('id property is required for every item returned from generateSitemaps')\n      }\n    }\n  }\n\n  const targetId = id && hasXmlExtension ? id.slice(0, -4) : undefined\n\n  const data = await handler({ id: targetId })\n  const content = resolveRouteData(data, fileType)\n\n  return new NextResponse(content, {\n    headers: {\n      'Content-Type': contentType,\n      'Cache-Control': ${JSON.stringify(cacheHeader.revalidate)},\n    },\n  })\n}\n\n${staticGenerationCode}\n`;\n    return code;\n}\n// When it's static route, it could be favicon.ico, sitemap.xml, robots.txt etc.\n// TODO-METADATA: improve the cache control strategy\nconst nextMetadataRouterLoader = async function() {\n    const { isDynamicRouteExtension, filePath } = this.getOptions();\n    const { name: fileBaseName } = getFilenameAndExtension(filePath);\n    this.addDependency(filePath);\n    let code = '';\n    if (isDynamicRouteExtension === '1') {\n        if (fileBaseName === 'robots' || fileBaseName === 'manifest') {\n            code = await getDynamicTextRouteCode(filePath, this);\n        } else if (fileBaseName === 'sitemap') {\n            code = await getDynamicSitemapRouteCode(filePath, this);\n        } else {\n            code = await getDynamicImageRouteCode(filePath, this);\n        }\n    } else {\n        code = await getStaticAssetRouteCode(filePath, fileBaseName);\n    }\n    return code;\n};\nexport default nextMetadataRouterLoader;\n\n//# sourceMappingURL=next-metadata-route-loader.js.map"
        }
    ]
}