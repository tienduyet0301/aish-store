{
    "sourceFile": "node_modules/next/dist/esm/build/webpack/loaders/css-loader/src/index.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892753230,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/ import CssSyntaxError from './CssSyntaxError';\nimport Warning from '../../postcss-loader/src/Warning';\nimport { stringifyRequest } from '../../../stringify-request';\nconst moduleRegExp = /\\.module\\.\\w+$/i;\nfunction getModulesOptions(rawOptions, loaderContext) {\n    const { resourcePath } = loaderContext;\n    if (typeof rawOptions.modules === 'undefined') {\n        const isModules = moduleRegExp.test(resourcePath);\n        if (!isModules) {\n            return false;\n        }\n    } else if (typeof rawOptions.modules === 'boolean' && rawOptions.modules === false) {\n        return false;\n    }\n    let modulesOptions = {\n        compileType: rawOptions.icss ? 'icss' : 'module',\n        auto: true,\n        mode: 'local',\n        exportGlobals: false,\n        localIdentName: '[hash:base64]',\n        localIdentContext: loaderContext.rootContext,\n        localIdentHashPrefix: '',\n        // eslint-disable-next-line no-undefined\n        localIdentRegExp: undefined,\n        namedExport: false,\n        exportLocalsConvention: 'asIs',\n        exportOnlyLocals: false\n    };\n    if (typeof rawOptions.modules === 'boolean' || typeof rawOptions.modules === 'string') {\n        modulesOptions.mode = typeof rawOptions.modules === 'string' ? rawOptions.modules : 'local';\n    } else {\n        if (rawOptions.modules) {\n            if (typeof rawOptions.modules.auto === 'boolean') {\n                const isModules = rawOptions.modules.auto && moduleRegExp.test(resourcePath);\n                if (!isModules) {\n                    return false;\n                }\n            } else if (rawOptions.modules.auto instanceof RegExp) {\n                const isModules = rawOptions.modules.auto.test(resourcePath);\n                if (!isModules) {\n                    return false;\n                }\n            } else if (typeof rawOptions.modules.auto === 'function') {\n                const isModule = rawOptions.modules.auto(resourcePath);\n                if (!isModule) {\n                    return false;\n                }\n            }\n            if (rawOptions.modules.namedExport === true && typeof rawOptions.modules.exportLocalsConvention === 'undefined') {\n                modulesOptions.exportLocalsConvention = 'camelCaseOnly';\n            }\n        }\n        modulesOptions = {\n            ...modulesOptions,\n            ...rawOptions.modules || {}\n        };\n    }\n    if (typeof modulesOptions.mode === 'function') {\n        modulesOptions.mode = modulesOptions.mode(loaderContext.resourcePath);\n    }\n    if (modulesOptions.namedExport === true) {\n        if (rawOptions.esModule === false) {\n            throw Object.defineProperty(new Error('The \"modules.namedExport\" option requires the \"esModules\" option to be enabled'), \"__NEXT_ERROR_CODE\", {\n                value: \"E103\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n        if (modulesOptions.exportLocalsConvention !== 'camelCaseOnly') {\n            throw Object.defineProperty(new Error('The \"modules.namedExport\" option requires the \"modules.exportLocalsConvention\" option to be \"camelCaseOnly\"'), \"__NEXT_ERROR_CODE\", {\n                value: \"E23\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n    }\n    return modulesOptions;\n}\nfunction normalizeOptions(rawOptions, loaderContext) {\n    if (rawOptions.icss) {\n        loaderContext.emitWarning(Object.defineProperty(new Error('The \"icss\" option is deprecated, use \"modules.compileType: \"icss\"\" instead'), \"__NEXT_ERROR_CODE\", {\n            value: \"E476\",\n            enumerable: false,\n            configurable: true\n        }));\n    }\n    const modulesOptions = getModulesOptions(rawOptions, loaderContext);\n    return {\n        url: typeof rawOptions.url === 'undefined' ? true : rawOptions.url,\n        import: typeof rawOptions.import === 'undefined' ? true : rawOptions.import,\n        modules: modulesOptions,\n        // TODO remove in the next major release\n        icss: typeof rawOptions.icss === 'undefined' ? false : rawOptions.icss,\n        sourceMap: typeof rawOptions.sourceMap === 'boolean' ? rawOptions.sourceMap : loaderContext.sourceMap,\n        importLoaders: typeof rawOptions.importLoaders === 'string' ? parseInt(rawOptions.importLoaders, 10) : rawOptions.importLoaders,\n        esModule: typeof rawOptions.esModule === 'undefined' ? true : rawOptions.esModule,\n        fontLoader: rawOptions.fontLoader\n    };\n}\nexport default async function loader(content, map, meta) {\n    const rawOptions = this.getOptions();\n    const plugins = [];\n    const callback = this.async();\n    const loaderSpan = this.currentTraceSpan.traceChild('css-loader');\n    loaderSpan.traceAsyncFn(async ()=>{\n        let options;\n        try {\n            options = normalizeOptions(rawOptions, this);\n        } catch (error) {\n            throw error;\n        }\n        const { postcss } = await rawOptions.postcss();\n        const { shouldUseModulesPlugins, shouldUseImportPlugin, shouldUseURLPlugin, shouldUseIcssPlugin, getPreRequester, getExportCode, getFilter, getImportCode, getModuleCode, getModulesPlugins, normalizeSourceMap, sort } = require('./utils');\n        const { icssParser, importParser, urlParser } = require('./plugins');\n        const replacements = [];\n        // if it's a font loader next-font-loader will have exports that should be exported as is\n        const exports = options.fontLoader ? meta.exports : [];\n        if (shouldUseModulesPlugins(options)) {\n            plugins.push(...getModulesPlugins(options, this, meta));\n        }\n        const importPluginImports = [];\n        const importPluginApi = [];\n        if (shouldUseImportPlugin(options)) {\n            const resolver = this.getResolve({\n                conditionNames: [\n                    'style'\n                ],\n                extensions: [\n                    '.css'\n                ],\n                mainFields: [\n                    'css',\n                    'style',\n                    'main',\n                    '...'\n                ],\n                mainFiles: [\n                    'index',\n                    '...'\n                ],\n                restrictions: [\n                    /\\.css$/i\n                ]\n            });\n            plugins.push(importParser({\n                imports: importPluginImports,\n                api: importPluginApi,\n                context: this.context,\n                rootContext: this.rootContext,\n                filter: getFilter(options.import, this.resourcePath),\n                resolver,\n                urlHandler: (url)=>stringifyRequest(this, getPreRequester(this)(options.importLoaders) + url)\n            }));\n        }\n        const urlPluginImports = [];\n        if (shouldUseURLPlugin(options)) {\n            const urlResolver = this.getResolve({\n                conditionNames: [\n                    'asset'\n                ],\n                mainFields: [\n                    'asset'\n                ],\n                mainFiles: [],\n                extensions: []\n            });\n            plugins.push(urlParser({\n                imports: urlPluginImports,\n                replacements,\n                context: this.context,\n                rootContext: this.rootContext,\n                filter: getFilter(options.url, this.resourcePath),\n                resolver: urlResolver,\n                urlHandler: (url)=>stringifyRequest(this, url)\n            }));\n        }\n        const icssPluginImports = [];\n        const icssPluginApi = [];\n        if (shouldUseIcssPlugin(options)) {\n            const icssResolver = this.getResolve({\n                conditionNames: [\n                    'style'\n                ],\n                extensions: [],\n                mainFields: [\n                    'css',\n                    'style',\n                    'main',\n                    '...'\n                ],\n                mainFiles: [\n                    'index',\n                    '...'\n                ]\n            });\n            plugins.push(icssParser({\n                imports: icssPluginImports,\n                api: icssPluginApi,\n                replacements,\n                exports,\n                context: this.context,\n                rootContext: this.rootContext,\n                resolver: icssResolver,\n                urlHandler: (url)=>stringifyRequest(this, getPreRequester(this)(options.importLoaders) + url)\n            }));\n        }\n        // Reuse CSS AST (PostCSS AST e.g 'postcss-loader') to avoid reparsing\n        if (meta) {\n            const { ast } = meta;\n            if (ast && ast.type === 'postcss') {\n                // eslint-disable-next-line no-param-reassign\n                content = ast.root;\n                loaderSpan.setAttribute('astUsed', 'true');\n            }\n        }\n        const { resourcePath } = this;\n        let result;\n        try {\n            result = await postcss(plugins).process(content, {\n                from: resourcePath,\n                to: resourcePath,\n                map: options.sourceMap ? {\n                    prev: map ? normalizeSourceMap(map, resourcePath) : null,\n                    inline: false,\n                    annotation: false\n                } : false\n            });\n        } catch (error) {\n            if (error.file) {\n                this.addDependency(error.file);\n            }\n            throw error.name === 'CssSyntaxError' ? Object.defineProperty(new CssSyntaxError(error), \"__NEXT_ERROR_CODE\", {\n                value: \"E394\",\n                enumerable: false,\n                configurable: true\n            }) : error;\n        }\n        for (const warning of result.warnings()){\n            this.emitWarning(Object.defineProperty(new Warning(warning), \"__NEXT_ERROR_CODE\", {\n                value: \"E394\",\n                enumerable: false,\n                configurable: true\n            }));\n        }\n        const imports = [\n            ...icssPluginImports.sort(sort),\n            ...importPluginImports.sort(sort),\n            ...urlPluginImports.sort(sort)\n        ];\n        const api = [\n            ...importPluginApi.sort(sort),\n            ...icssPluginApi.sort(sort)\n        ];\n        if (options.modules.exportOnlyLocals !== true) {\n            imports.unshift({\n                importName: '___CSS_LOADER_API_IMPORT___',\n                url: stringifyRequest(this, require.resolve('./runtime/api'))\n            });\n        }\n        const importCode = getImportCode(imports, options);\n        const moduleCode = getModuleCode(result, api, replacements, options, this);\n        const exportCode = getExportCode(exports, replacements, options);\n        return `${importCode}${moduleCode}${exportCode}`;\n    }).then((code)=>{\n        callback(null, code);\n    }, (err)=>{\n        callback(err);\n    });\n}\n\n//# sourceMappingURL=index.js.map"
        }
    ]
}