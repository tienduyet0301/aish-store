{
    "sourceFile": "node_modules/next/dist/esm/build/type-check.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892751685,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import path from 'path';\nimport * as Log from './output/log';\nimport { Worker } from '../lib/worker';\nimport { verifyAndLint } from '../lib/verifyAndLint';\nimport createSpinner from './spinner';\nimport { eventTypeCheckCompleted } from '../telemetry/events';\nimport isError from '../lib/is-error';\n/**\n * typescript will be loaded in \"next/lib/verify-typescript-setup\" and\n * then passed to \"next/lib/typescript/runTypeCheck\" as a parameter.\n *\n * Since it is impossible to pass a function from main thread to a worker,\n * instead of running \"next/lib/typescript/runTypeCheck\" in a worker,\n * we will run entire \"next/lib/verify-typescript-setup\" in a worker instead.\n */ function verifyTypeScriptSetup(dir, distDir, intentDirs, typeCheckPreflight, tsconfigPath, disableStaticImages, cacheDir, enableWorkerThreads, hasAppDir, hasPagesDir) {\n    const typeCheckWorker = new Worker(require.resolve('../lib/verify-typescript-setup'), {\n        exposedMethods: [\n            'verifyTypeScriptSetup'\n        ],\n        numWorkers: 1,\n        enableWorkerThreads,\n        maxRetries: 0\n    });\n    return typeCheckWorker.verifyTypeScriptSetup({\n        dir,\n        distDir,\n        intentDirs,\n        typeCheckPreflight,\n        tsconfigPath,\n        disableStaticImages,\n        cacheDir,\n        hasAppDir,\n        hasPagesDir\n    }).then((result)=>{\n        typeCheckWorker.end();\n        return result;\n    }).catch(()=>{\n        // The error is already logged in the worker, we simply exit the main thread to prevent the\n        // `Jest worker encountered 1 child process exceptions, exceeding retry limit` from showing up\n        process.exit(1);\n    });\n}\nexport async function startTypeChecking({ cacheDir, config, dir, ignoreESLint, nextBuildSpan, pagesDir, runLint, shouldLint, telemetry, appDir }) {\n    const ignoreTypeScriptErrors = Boolean(config.typescript.ignoreBuildErrors);\n    const eslintCacheDir = path.join(cacheDir, 'eslint/');\n    if (ignoreTypeScriptErrors) {\n        Log.info('Skipping validation of types');\n    }\n    if (runLint && ignoreESLint) {\n        // only print log when build require lint while ignoreESLint is enabled\n        Log.info('Skipping linting');\n    }\n    let typeCheckingAndLintingSpinnerPrefixText;\n    let typeCheckingAndLintingSpinner;\n    if (!ignoreTypeScriptErrors && shouldLint) {\n        typeCheckingAndLintingSpinnerPrefixText = 'Linting and checking validity of types';\n    } else if (!ignoreTypeScriptErrors) {\n        typeCheckingAndLintingSpinnerPrefixText = 'Checking validity of types';\n    } else if (shouldLint) {\n        typeCheckingAndLintingSpinnerPrefixText = 'Linting';\n    }\n    // we will not create a spinner if both ignoreTypeScriptErrors and ignoreESLint are\n    // enabled, but we will still verifying project's tsconfig and dependencies.\n    if (typeCheckingAndLintingSpinnerPrefixText) {\n        typeCheckingAndLintingSpinner = createSpinner(typeCheckingAndLintingSpinnerPrefixText);\n    }\n    const typeCheckStart = process.hrtime();\n    try {\n        const [[verifyResult, typeCheckEnd]] = await Promise.all([\n            nextBuildSpan.traceChild('verify-typescript-setup').traceAsyncFn(()=>verifyTypeScriptSetup(dir, config.distDir, [\n                    pagesDir,\n                    appDir\n                ].filter(Boolean), !ignoreTypeScriptErrors, config.typescript.tsconfigPath, config.images.disableStaticImages, cacheDir, config.experimental.workerThreads, !!appDir, !!pagesDir).then((resolved)=>{\n                    const checkEnd = process.hrtime(typeCheckStart);\n                    return [\n                        resolved,\n                        checkEnd\n                    ];\n                })),\n            shouldLint && nextBuildSpan.traceChild('verify-and-lint').traceAsyncFn(async ()=>{\n                var _config_eslint;\n                await verifyAndLint(dir, eslintCacheDir, (_config_eslint = config.eslint) == null ? void 0 : _config_eslint.dirs, config.experimental.workerThreads, telemetry);\n            })\n        ]);\n        typeCheckingAndLintingSpinner == null ? void 0 : typeCheckingAndLintingSpinner.stopAndPersist();\n        if (!ignoreTypeScriptErrors && verifyResult) {\n            var _verifyResult_result, _verifyResult_result1, _verifyResult_result2;\n            telemetry.record(eventTypeCheckCompleted({\n                durationInSeconds: typeCheckEnd[0],\n                typescriptVersion: verifyResult.version,\n                inputFilesCount: (_verifyResult_result = verifyResult.result) == null ? void 0 : _verifyResult_result.inputFilesCount,\n                totalFilesCount: (_verifyResult_result1 = verifyResult.result) == null ? void 0 : _verifyResult_result1.totalFilesCount,\n                incremental: (_verifyResult_result2 = verifyResult.result) == null ? void 0 : _verifyResult_result2.incremental\n            }));\n        }\n    } catch (err) {\n        // prevent showing jest-worker internal error as it\n        // isn't helpful for users and clutters output\n        if (isError(err) && err.message === 'Call retries were exceeded') {\n            await telemetry.flush();\n            process.exit(1);\n        }\n        throw err;\n    }\n}\n\n//# sourceMappingURL=type-check.js.map"
        }
    ]
}