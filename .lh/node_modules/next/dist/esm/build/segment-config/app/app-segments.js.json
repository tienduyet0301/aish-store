{
    "sourceFile": "node_modules/next/dist/esm/build/segment-config/app/app-segments.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892749190,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import { parseAppSegmentConfig } from './app-segment-config';\nimport { InvariantError } from '../../../shared/lib/invariant-error';\nimport { isAppRouteRouteModule, isAppPageRouteModule } from '../../../server/route-modules/checks';\nimport { isClientReference } from '../../../lib/client-and-server-references';\nimport { getSegmentParam } from '../../../server/app-render/get-segment-param';\nimport { getLayoutOrPageModule } from '../../../server/lib/app-dir-module';\nimport { PAGE_SEGMENT_KEY } from '../../../shared/lib/segment';\n/**\n * Parses the app config and attaches it to the segment.\n */ function attach(segment, userland, route) {\n    // If the userland is not an object, then we can't do anything with it.\n    if (typeof userland !== 'object' || userland === null) {\n        return;\n    }\n    // Try to parse the application configuration.\n    const config = parseAppSegmentConfig(userland, route);\n    // If there was any keys on the config, then attach it to the segment.\n    if (Object.keys(config).length > 0) {\n        segment.config = config;\n    }\n    if ('generateStaticParams' in userland && typeof userland.generateStaticParams === 'function') {\n        var _segment_config;\n        segment.generateStaticParams = userland.generateStaticParams;\n        // Validate that `generateStaticParams` makes sense in this context.\n        if (((_segment_config = segment.config) == null ? void 0 : _segment_config.runtime) === 'edge') {\n            throw Object.defineProperty(new Error('Edge runtime is not supported with `generateStaticParams`.'), \"__NEXT_ERROR_CODE\", {\n                value: \"E502\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n    }\n}\n/**\n * Walks the loader tree and collects the generate parameters for each segment.\n *\n * @param routeModule the app page route module\n * @returns the segments for the app page route module\n */ async function collectAppPageSegments(routeModule) {\n    // We keep track of unique segments, since with parallel routes, it's possible\n    // to see the same segment multiple times.\n    const uniqueSegments = new Map();\n    const queue = [\n        [\n            routeModule.userland.loaderTree,\n            []\n        ]\n    ];\n    while(queue.length > 0){\n        var _getSegmentParam;\n        const [loaderTree, currentSegments] = queue.shift();\n        const [name, parallelRoutes] = loaderTree;\n        // Process current node\n        const { mod: userland, filePath } = await getLayoutOrPageModule(loaderTree);\n        const isClientComponent = userland && isClientReference(userland);\n        const param = (_getSegmentParam = getSegmentParam(name)) == null ? void 0 : _getSegmentParam.param;\n        const segment = {\n            name,\n            param,\n            filePath,\n            config: undefined,\n            isDynamicSegment: !!param,\n            generateStaticParams: undefined\n        };\n        // Only server components can have app segment configurations\n        if (!isClientComponent) {\n            attach(segment, userland, routeModule.definition.pathname);\n        }\n        // Create a unique key for the segment\n        const segmentKey = getSegmentKey(segment);\n        if (!uniqueSegments.has(segmentKey)) {\n            uniqueSegments.set(segmentKey, segment);\n        }\n        const updatedSegments = [\n            ...currentSegments,\n            segment\n        ];\n        // If this is a page segment, we've reached a leaf node\n        if (name === PAGE_SEGMENT_KEY) {\n            // Add all segments in the current path\n            updatedSegments.forEach((seg)=>{\n                const key = getSegmentKey(seg);\n                uniqueSegments.set(key, seg);\n            });\n        }\n        // Add all parallel routes to the queue\n        for(const parallelRouteKey in parallelRoutes){\n            const parallelRoute = parallelRoutes[parallelRouteKey];\n            queue.push([\n                parallelRoute,\n                updatedSegments\n            ]);\n        }\n    }\n    return Array.from(uniqueSegments.values());\n}\nfunction getSegmentKey(segment) {\n    return `${segment.name}-${segment.filePath ?? ''}-${segment.param ?? ''}`;\n}\n/**\n * Collects the segments for a given app route module.\n *\n * @param routeModule the app route module\n * @returns the segments for the app route module\n */ function collectAppRouteSegments(routeModule) {\n    // Get the pathname parts, slice off the first element (which is empty).\n    const parts = routeModule.definition.pathname.split('/').slice(1);\n    if (parts.length === 0) {\n        throw Object.defineProperty(new InvariantError('Expected at least one segment'), \"__NEXT_ERROR_CODE\", {\n            value: \"E580\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    // Generate all the segments.\n    const segments = parts.map((name)=>{\n        var _getSegmentParam;\n        const param = (_getSegmentParam = getSegmentParam(name)) == null ? void 0 : _getSegmentParam.param;\n        return {\n            name,\n            param,\n            filePath: undefined,\n            isDynamicSegment: !!param,\n            config: undefined,\n            generateStaticParams: undefined\n        };\n    });\n    // We know we have at least one, we verified this above. We should get the\n    // last segment which represents the root route module.\n    const segment = segments[segments.length - 1];\n    segment.filePath = routeModule.definition.filename;\n    // Extract the segment config from the userland module.\n    attach(segment, routeModule.userland, routeModule.definition.pathname);\n    return segments;\n}\n/**\n * Collects the segments for a given route module.\n *\n * @param components the loaded components\n * @returns the segments for the route module\n */ export function collectSegments({ routeModule }) {\n    if (isAppRouteRouteModule(routeModule)) {\n        return collectAppRouteSegments(routeModule);\n    }\n    if (isAppPageRouteModule(routeModule)) {\n        return collectAppPageSegments(routeModule);\n    }\n    throw Object.defineProperty(new InvariantError('Expected a route module to be one of app route or page'), \"__NEXT_ERROR_CODE\", {\n        value: \"E568\",\n        enumerable: false,\n        configurable: true\n    });\n}\n\n//# sourceMappingURL=app-segments.js.map"
        }
    ]
}