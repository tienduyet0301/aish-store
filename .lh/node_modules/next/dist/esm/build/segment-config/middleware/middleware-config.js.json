{
    "sourceFile": "node_modules/next/dist/esm/build/segment-config/middleware/middleware-config.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892749373,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import picomatch from 'next/dist/compiled/picomatch';\nimport { z } from 'next/dist/compiled/zod';\nimport { tryToParsePath } from '../../../lib/try-to-parse-path';\nconst RouteHasSchema = z.discriminatedUnion('type', [\n    z.object({\n        type: z.enum([\n            'header',\n            'query',\n            'cookie'\n        ]),\n        key: z.string({\n            required_error: 'key is required when type is header, query or cookie'\n        }),\n        value: z.string({\n            invalid_type_error: 'value must be a string'\n        }).optional()\n    }).strict(),\n    z.object({\n        type: z.literal('host'),\n        value: z.string({\n            required_error: 'host must have a value'\n        })\n    }).strict()\n]);\n/**\n * @internal - required to exclude zod types from the build\n */ export const SourceSchema = z.string({\n    required_error: 'source is required'\n}).max(4096, 'exceeds max built length of 4096 for route').superRefine((val, ctx)=>{\n    if (!val.startsWith('/')) {\n        return ctx.addIssue({\n            code: z.ZodIssueCode.custom,\n            message: `source must start with /`\n        });\n    }\n    const { error, regexStr } = tryToParsePath(val);\n    if (error || !regexStr) {\n        ctx.addIssue({\n            code: z.ZodIssueCode.custom,\n            message: `Invalid source '${val}': ${error.message}`\n        });\n    }\n});\nconst MiddlewareMatcherInputSchema = z.object({\n    locale: z.union([\n        z.literal(false),\n        z.undefined()\n    ]).optional(),\n    has: z.array(RouteHasSchema).optional(),\n    missing: z.array(RouteHasSchema).optional(),\n    source: SourceSchema\n}).strict();\nconst MiddlewareConfigMatcherInputSchema = z.union([\n    SourceSchema,\n    z.array(z.union([\n        SourceSchema,\n        MiddlewareMatcherInputSchema\n    ], {\n        invalid_type_error: 'must be an array of strings or middleware matchers'\n    }))\n]);\nconst GlobSchema = z.string().superRefine((val, ctx)=>{\n    try {\n        picomatch(val);\n    } catch (err) {\n        ctx.addIssue({\n            code: z.ZodIssueCode.custom,\n            message: `Invalid glob pattern '${val}': ${err.message}`\n        });\n    }\n});\n/**\n * @internal - required to exclude zod types from the build\n */ export const MiddlewareConfigInputSchema = z.object({\n    /**\n   * The matcher for the middleware.\n   */ matcher: MiddlewareConfigMatcherInputSchema.optional(),\n    /**\n   * The regions that the middleware should run in.\n   */ regions: z.union([\n        z.string(),\n        z.array(z.string())\n    ]).optional(),\n    /**\n   * A glob, or an array of globs, ignoring dynamic code evaluation for specific\n   * files. The globs are relative to your application root folder.\n   */ unstable_allowDynamic: z.union([\n        GlobSchema,\n        z.array(GlobSchema)\n    ]).optional()\n});\n/**\n * The keys of the configuration for a middleware.\n *\n * @internal - required to exclude zod types from the build\n */ export const MiddlewareConfigInputSchemaKeys = MiddlewareConfigInputSchema.keyof().options;\n\n//# sourceMappingURL=middleware-config.js.map"
        }
    ]
}