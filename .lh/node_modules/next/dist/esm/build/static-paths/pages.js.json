{
    "sourceFile": "node_modules/next/dist/esm/build/static-paths/pages.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892749660,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import { normalizeLocalePath } from '../../shared/lib/i18n/normalize-locale-path';\nimport { parseStaticPathsResult } from '../../lib/fallback';\nimport escapePathDelimiters from '../../shared/lib/router/utils/escape-path-delimiters';\nimport { removeTrailingSlash } from '../../shared/lib/router/utils/remove-trailing-slash';\nimport { getRouteMatcher } from '../../shared/lib/router/utils/route-matcher';\nimport { getRouteRegex } from '../../shared/lib/router/utils/route-regex';\nimport { encodeParam, normalizePathname } from './utils';\nexport async function buildPagesStaticPaths({ page, getStaticPaths, configFileName, locales, defaultLocale }) {\n    const prerenderedRoutes = [];\n    const _routeRegex = getRouteRegex(page);\n    const _routeMatcher = getRouteMatcher(_routeRegex);\n    // Get the default list of allowed params.\n    const routeParameterKeys = Object.keys(_routeMatcher(page));\n    const staticPathsResult = await getStaticPaths({\n        // We create a copy here to avoid having the types of `getStaticPaths`\n        // change. This ensures that users can't mutate this array and have it\n        // poison the reference.\n        locales: [\n            ...locales ?? []\n        ],\n        defaultLocale\n    });\n    const expectedReturnVal = `Expected: { paths: [], fallback: boolean }\\n` + `See here for more info: https://nextjs.org/docs/messages/invalid-getstaticpaths-value`;\n    if (!staticPathsResult || typeof staticPathsResult !== 'object' || Array.isArray(staticPathsResult)) {\n        throw Object.defineProperty(new Error(`Invalid value returned from getStaticPaths in ${page}. Received ${typeof staticPathsResult} ${expectedReturnVal}`), \"__NEXT_ERROR_CODE\", {\n            value: \"E241\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    const invalidStaticPathKeys = Object.keys(staticPathsResult).filter((key)=>!(key === 'paths' || key === 'fallback'));\n    if (invalidStaticPathKeys.length > 0) {\n        throw Object.defineProperty(new Error(`Extra keys returned from getStaticPaths in ${page} (${invalidStaticPathKeys.join(', ')}) ${expectedReturnVal}`), \"__NEXT_ERROR_CODE\", {\n            value: \"E38\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    if (!(typeof staticPathsResult.fallback === 'boolean' || staticPathsResult.fallback === 'blocking')) {\n        throw Object.defineProperty(new Error(`The \\`fallback\\` key must be returned from getStaticPaths in ${page}.\\n` + expectedReturnVal), \"__NEXT_ERROR_CODE\", {\n            value: \"E243\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    const toPrerender = staticPathsResult.paths;\n    if (!Array.isArray(toPrerender)) {\n        throw Object.defineProperty(new Error(`Invalid \\`paths\\` value returned from getStaticPaths in ${page}.\\n` + `\\`paths\\` must be an array of strings or objects of shape { params: [key: string]: string }`), \"__NEXT_ERROR_CODE\", {\n            value: \"E83\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    toPrerender.forEach((entry)=>{\n        // For a string-provided path, we must make sure it matches the dynamic\n        // route.\n        if (typeof entry === 'string') {\n            entry = removeTrailingSlash(entry);\n            const localePathResult = normalizeLocalePath(entry, locales);\n            let cleanedEntry = entry;\n            if (localePathResult.detectedLocale) {\n                cleanedEntry = entry.slice(localePathResult.detectedLocale.length + 1);\n            } else if (defaultLocale) {\n                entry = `/${defaultLocale}${entry}`;\n            }\n            const result = _routeMatcher(cleanedEntry);\n            if (!result) {\n                throw Object.defineProperty(new Error(`The provided path \\`${cleanedEntry}\\` does not match the page: \\`${page}\\`.`), \"__NEXT_ERROR_CODE\", {\n                    value: \"E481\",\n                    enumerable: false,\n                    configurable: true\n                });\n            }\n            // If leveraging the string paths variant the entry should already be\n            // encoded so we decode the segments ensuring we only escape path\n            // delimiters\n            prerenderedRoutes.push({\n                pathname: entry.split('/').map((segment)=>escapePathDelimiters(decodeURIComponent(segment), true)).join('/'),\n                encodedPathname: entry,\n                fallbackRouteParams: undefined,\n                fallbackMode: parseStaticPathsResult(staticPathsResult.fallback),\n                fallbackRootParams: undefined\n            });\n        } else {\n            const invalidKeys = Object.keys(entry).filter((key)=>key !== 'params' && key !== 'locale');\n            if (invalidKeys.length) {\n                throw Object.defineProperty(new Error(`Additional keys were returned from \\`getStaticPaths\\` in page \"${page}\". ` + `URL Parameters intended for this dynamic route must be nested under the \\`params\\` key, i.e.:` + `\\n\\n\\treturn { params: { ${routeParameterKeys.map((k)=>`${k}: ...`).join(', ')} } }` + `\\n\\nKeys that need to be moved: ${invalidKeys.join(', ')}.\\n`), \"__NEXT_ERROR_CODE\", {\n                    value: \"E322\",\n                    enumerable: false,\n                    configurable: true\n                });\n            }\n            const { params = {} } = entry;\n            let builtPage = page;\n            let encodedBuiltPage = page;\n            routeParameterKeys.forEach((validParamKey)=>{\n                const { repeat, optional } = _routeRegex.groups[validParamKey];\n                let paramValue = params[validParamKey];\n                if (optional && params.hasOwnProperty(validParamKey) && (paramValue === null || paramValue === undefined || paramValue === false)) {\n                    paramValue = [];\n                }\n                if (repeat && !Array.isArray(paramValue) || !repeat && typeof paramValue !== 'string' || typeof paramValue === 'undefined') {\n                    throw Object.defineProperty(new Error(`A required parameter (${validParamKey}) was not provided as ${repeat ? 'an array' : 'a string'} received ${typeof paramValue} in getStaticPaths for ${page}`), \"__NEXT_ERROR_CODE\", {\n                        value: \"E620\",\n                        enumerable: false,\n                        configurable: true\n                    });\n                }\n                let replaced = `[${repeat ? '...' : ''}${validParamKey}]`;\n                if (optional) {\n                    replaced = `[${replaced}]`;\n                }\n                builtPage = builtPage.replace(replaced, encodeParam(paramValue, (value)=>escapePathDelimiters(value, true)));\n                encodedBuiltPage = encodedBuiltPage.replace(replaced, encodeParam(paramValue, encodeURIComponent));\n            });\n            if (!builtPage && !encodedBuiltPage) {\n                return;\n            }\n            if (entry.locale && !(locales == null ? void 0 : locales.includes(entry.locale))) {\n                throw Object.defineProperty(new Error(`Invalid locale returned from getStaticPaths for ${page}, the locale ${entry.locale} is not specified in ${configFileName}`), \"__NEXT_ERROR_CODE\", {\n                    value: \"E358\",\n                    enumerable: false,\n                    configurable: true\n                });\n            }\n            const curLocale = entry.locale || defaultLocale || '';\n            prerenderedRoutes.push({\n                pathname: normalizePathname(`${curLocale ? `/${curLocale}` : ''}${curLocale && builtPage === '/' ? '' : builtPage}`),\n                encodedPathname: normalizePathname(`${curLocale ? `/${curLocale}` : ''}${curLocale && encodedBuiltPage === '/' ? '' : encodedBuiltPage}`),\n                fallbackRouteParams: undefined,\n                fallbackMode: parseStaticPathsResult(staticPathsResult.fallback),\n                fallbackRootParams: undefined\n            });\n        }\n    });\n    const seen = new Set();\n    return {\n        fallbackMode: parseStaticPathsResult(staticPathsResult.fallback),\n        prerenderedRoutes: prerenderedRoutes.filter((route)=>{\n            if (seen.has(route.pathname)) return false;\n            // Filter out duplicate paths.\n            seen.add(route.pathname);\n            return true;\n        })\n    };\n}\n\n//# sourceMappingURL=pages.js.map"
        }
    ]
}