{
    "sourceFile": "node_modules/next/dist/esm/build/swc/generated-native.d.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892749877,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "// Manual additions to make the generated types below work.\n\nimport type { TurbopackResult } from './types'\n\nexport type TurboTasks = { readonly __tag: unique symbol }\nexport type ExternalEndpoint = { readonly __tag: unique symbol }\nexport type NextTurboTasks = { readonly __tag: unique symbol }\nexport type RefCell = { readonly __tag: unique symbol }\nexport type NapiRouteHas = {\n  type: string\n  key?: string\n  value?: string\n  readonly __tag: unique symbol\n}\n\nexport function lightningCssTransform(args: object): Promise<unknown>\nexport function lightningCssTransformStyleAttribute(\n  args: object\n): Promise<unknown>\n\n// GENERATED-TYPES-BELOW\n// DO NOT MANUALLY EDIT THESE TYPES\n// You can regenerate this file by running `pnpm swc-build-native` in the root of the repo.\n\n/* tslint:disable */\n/* eslint-disable */\n\n/* auto-generated by NAPI-RS */\n\nexport class ExternalObject<T> {\n  readonly '': {\n    readonly '': unique symbol\n    [K: symbol]: T\n  }\n}\nexport interface TransformOutput {\n  code: string\n  map?: string\n  output?: string\n  diagnostics: Array<string>\n}\nexport declare function mdxCompile(\n  value: string,\n  option: Buffer,\n  signal?: AbortSignal | undefined | null\n): Promise<unknown>\nexport declare function mdxCompileSync(value: string, option: Buffer): string\nexport declare function minify(\n  input: Buffer,\n  opts: Buffer,\n  signal?: AbortSignal | undefined | null\n): Promise<TransformOutput>\nexport declare function minifySync(input: Buffer, opts: Buffer): TransformOutput\nexport interface NapiEndpointConfig {}\nexport interface NapiServerPath {\n  path: string\n  contentHash: string\n}\nexport interface NapiWrittenEndpoint {\n  type: string\n  entryPath?: string\n  clientPaths: Array<string>\n  serverPaths: Array<NapiServerPath>\n  config: NapiEndpointConfig\n}\nexport declare function endpointWriteToDisk(endpoint: {\n  __napiType: 'Endpoint'\n}): Promise<TurbopackResult>\nexport declare function endpointServerChangedSubscribe(\n  endpoint: { __napiType: 'Endpoint' },\n  issues: boolean,\n  func: (...args: any[]) => any\n): { __napiType: 'RootTask' }\nexport declare function endpointClientChangedSubscribe(\n  endpoint: { __napiType: 'Endpoint' },\n  func: (...args: any[]) => any\n): { __napiType: 'RootTask' }\nexport interface NapiEnvVar {\n  name: string\n  value: string\n}\nexport interface NapiDraftModeOptions {\n  previewModeId: string\n  previewModeEncryptionKey: string\n  previewModeSigningKey: string\n}\nexport interface NapiWatchOptions {\n  /** Whether to watch the filesystem for file changes. */\n  enable: boolean\n  /**\n   * Enable polling at a certain interval if the native file watching doesn't work (e.g.\n   * docker).\n   */\n  pollIntervalMs?: number\n}\nexport interface NapiProjectOptions {\n  /**\n   * A root path from which all files must be nested under. Trying to access\n   * a file outside this root will fail. Think of this as a chroot.\n   */\n  rootPath: string\n  /** A path inside the root_path which contains the app/pages directories. */\n  projectPath: string\n  /**\n   * next.config's distDir. Project initialization occurs eariler than\n   * deserializing next.config, so passing it as separate option.\n   */\n  distDir: string\n  /** Filesystem watcher options. */\n  watch: NapiWatchOptions\n  /** The contents of next.config.js, serialized to JSON. */\n  nextConfig: string\n  /** The contents of ts/config read by load-jsconfig, serialized to JSON. */\n  jsConfig: string\n  /** A map of environment variables to use when compiling code. */\n  env: Array<NapiEnvVar>\n  /**\n   * A map of environment variables which should get injected at compile\n   * time.\n   */\n  defineEnv: NapiDefineEnv\n  /** The mode in which Next.js is running. */\n  dev: boolean\n  /** The server actions encryption key. */\n  encryptionKey: string\n  /** The build id. */\n  buildId: string\n  /** Options for draft mode. */\n  previewProps: NapiDraftModeOptions\n  /** The browserslist query to use for targeting browsers. */\n  browserslistQuery: string\n  /**\n   * When the code is minified, this opts out of the default mangling of\n   * local names for variables, functions etc., which can be useful for\n   * debugging/profiling purposes.\n   */\n  noMangling: boolean\n}\n/** [NapiProjectOptions] with all fields optional. */\nexport interface NapiPartialProjectOptions {\n  /**\n   * A root path from which all files must be nested under. Trying to access\n   * a file outside this root will fail. Think of this as a chroot.\n   */\n  rootPath?: string\n  /** A path inside the root_path which contains the app/pages directories. */\n  projectPath?: string\n  /**\n   * next.config's distDir. Project initialization occurs eariler than\n   * deserializing next.config, so passing it as separate option.\n   */\n  distDir?: string | undefined | null\n  /** Filesystem watcher options. */\n  watch?: NapiWatchOptions\n  /** The contents of next.config.js, serialized to JSON. */\n  nextConfig?: string\n  /** The contents of ts/config read by load-jsconfig, serialized to JSON. */\n  jsConfig?: string\n  /** A map of environment variables to use when compiling code. */\n  env?: Array<NapiEnvVar>\n  /**\n   * A map of environment variables which should get injected at compile\n   * time.\n   */\n  defineEnv?: NapiDefineEnv\n  /** The mode in which Next.js is running. */\n  dev?: boolean\n  /** The server actions encryption key. */\n  encryptionKey?: string\n  /** The build id. */\n  buildId?: string\n  /** Options for draft mode. */\n  previewProps?: NapiDraftModeOptions\n  /** The browserslist query to use for targeting browsers. */\n  browserslistQuery?: string\n  /**\n   * When the code is minified, this opts out of the default mangling of\n   * local names for variables, functions etc., which can be useful for\n   * debugging/profiling purposes.\n   */\n  noMangling?: boolean\n}\nexport interface NapiDefineEnv {\n  client: Array<NapiEnvVar>\n  edge: Array<NapiEnvVar>\n  nodejs: Array<NapiEnvVar>\n}\nexport interface NapiTurboEngineOptions {\n  /** Use the new backend with persistent caching enabled. */\n  persistentCaching?: boolean\n  /** An upper bound of memory that turbopack will attempt to stay under. */\n  memoryLimit?: number\n  /** Track dependencies between tasks. If false, any change during build will error. */\n  dependencyTracking?: boolean\n}\nexport declare function projectNew(\n  options: NapiProjectOptions,\n  turboEngineOptions: NapiTurboEngineOptions\n): Promise<{ __napiType: 'Project' }>\nexport declare function projectUpdate(\n  project: { __napiType: 'Project' },\n  options: NapiPartialProjectOptions\n): Promise<void>\n/**\n * Runs exit handlers for the project registered using the [`ExitHandler`] API.\n *\n * This is called by `project_shutdown`, so if you're calling that API, you shouldn't call this\n * one.\n */\nexport declare function projectOnExit(project: {\n  __napiType: 'Project'\n}): Promise<void>\n/**\n * Runs `project_on_exit`, and then waits for turbo_tasks to gracefully shut down.\n *\n * This is used in builds where it's important that we completely persist turbo-tasks to disk, but\n * it's skipped in the development server (`project_on_exit` is used instead with a short timeout),\n * where we prioritize fast exit and user responsiveness over all else.\n */\nexport declare function projectShutdown(project: {\n  __napiType: 'Project'\n}): Promise<void>\nexport interface AppPageNapiRoute {\n  /** The relative path from project_path to the route file */\n  originalName?: string\n  htmlEndpoint?: ExternalObject<ExternalEndpoint>\n  rscEndpoint?: ExternalObject<ExternalEndpoint>\n}\nexport interface NapiRoute {\n  /** The router path */\n  pathname: string\n  /** The relative path from project_path to the route file */\n  originalName?: string\n  /** The type of route, eg a Page or App */\n  type: string\n  pages?: Array<AppPageNapiRoute>\n  endpoint?: ExternalObject<ExternalEndpoint>\n  htmlEndpoint?: ExternalObject<ExternalEndpoint>\n  rscEndpoint?: ExternalObject<ExternalEndpoint>\n  dataEndpoint?: ExternalObject<ExternalEndpoint>\n}\nexport interface NapiMiddleware {\n  endpoint: ExternalObject<ExternalEndpoint>\n}\nexport interface NapiInstrumentation {\n  nodeJs: ExternalObject<ExternalEndpoint>\n  edge: ExternalObject<ExternalEndpoint>\n}\nexport interface NapiEntrypoints {\n  routes: Array<NapiRoute>\n  middleware?: NapiMiddleware\n  instrumentation?: NapiInstrumentation\n  pagesDocumentEndpoint: ExternalObject<ExternalEndpoint>\n  pagesAppEndpoint: ExternalObject<ExternalEndpoint>\n  pagesErrorEndpoint: ExternalObject<ExternalEndpoint>\n}\nexport declare function projectWriteAllEntrypointsToDisk(\n  project: { __napiType: 'Project' },\n  appDirOnly: boolean\n): Promise<TurbopackResult>\nexport declare function projectEntrypointsSubscribe(\n  project: { __napiType: 'Project' },\n  func: (...args: any[]) => any\n): { __napiType: 'RootTask' }\nexport declare function projectHmrEvents(\n  project: { __napiType: 'Project' },\n  identifier: string,\n  func: (...args: any[]) => any\n): { __napiType: 'RootTask' }\nexport interface HmrIdentifiers {\n  identifiers: Array<string>\n}\nexport declare function projectHmrIdentifiersSubscribe(\n  project: { __napiType: 'Project' },\n  func: (...args: any[]) => any\n): { __napiType: 'RootTask' }\nexport interface NapiUpdateMessage {\n  updateType: string\n  value?: NapiUpdateInfo\n}\nexport interface NapiUpdateInfo {\n  duration: number\n  tasks: number\n}\n/**\n * Subscribes to lifecycle events of the compilation.\n *\n * Emits an [UpdateMessage::Start] event when any computation starts.\n * Emits an [UpdateMessage::End] event when there was no computation for the\n * specified time (`aggregation_ms`). The [UpdateMessage::End] event contains\n * information about the computations that happened since the\n * [UpdateMessage::Start] event. It contains the duration of the computation\n * (excluding the idle time that was spend waiting for `aggregation_ms`), and\n * the number of tasks that were executed.\n *\n * The signature of the `func` is `(update_message: UpdateMessage) => void`.\n */\nexport declare function projectUpdateInfoSubscribe(\n  project: { __napiType: 'Project' },\n  aggregationMs: number,\n  func: (...args: any[]) => any\n): void\nexport interface StackFrame {\n  isServer: boolean\n  isInternal?: boolean\n  originalFile?: string\n  file: string\n  line?: number\n  column?: number\n  methodName?: string\n}\nexport declare function projectTraceSource(\n  project: { __napiType: 'Project' },\n  frame: StackFrame,\n  currentDirectoryFileUrl: string\n): Promise<StackFrame | null>\nexport declare function projectGetSourceForAsset(\n  project: { __napiType: 'Project' },\n  filePath: string\n): Promise<string | null>\nexport declare function projectGetSourceMap(\n  project: { __napiType: 'Project' },\n  filePath: string\n): Promise<string | null>\nexport declare function projectGetSourceMapSync(\n  project: { __napiType: 'Project' },\n  filePath: string\n): string | null\nexport declare function rootTaskDispose(rootTask: {\n  __napiType: 'RootTask'\n}): void\nexport interface NapiIssue {\n  severity: string\n  stage: string\n  filePath: string\n  title: any\n  description?: any\n  detail?: any\n  source?: NapiIssueSource\n  documentationLink: string\n  subIssues: Array<NapiIssue>\n}\nexport interface NapiIssueSource {\n  source: NapiSource\n  range?: NapiIssueSourceRange\n}\nexport interface NapiIssueSourceRange {\n  start: NapiSourcePos\n  end: NapiSourcePos\n}\nexport interface NapiSource {\n  ident: string\n  content?: string\n}\nexport interface NapiSourcePos {\n  line: number\n  column: number\n}\nexport interface NapiDiagnostic {\n  category: string\n  name: string\n  payload: Record<string, string>\n}\nexport declare function parse(\n  src: string,\n  options: Buffer,\n  filename?: string | undefined | null,\n  signal?: AbortSignal | undefined | null\n): Promise<string>\nexport declare function isReactCompilerRequired(\n  filename: string,\n  signal?: AbortSignal | undefined | null\n): Promise<boolean>\nexport declare function transform(\n  src: string | Buffer | undefined,\n  isModule: boolean,\n  options: Buffer,\n  signal?: AbortSignal | undefined | null\n): Promise<unknown>\nexport declare function transformSync(\n  src: string | Buffer | undefined,\n  isModule: boolean,\n  options: Buffer\n): object\nexport declare function startTurbopackTraceServer(path: string): void\nexport interface NextBuildContext {\n  /** The root directory of the workspace. */\n  root?: string\n  /** The project's directory. */\n  dir?: string\n  /**\n   * next.config.js's distDir. Current there's some early stage setup\n   * requires this Before construct a context to read next.config.js,\n   * which we passes separately here.\n   */\n  distDir?: string\n  /** The build ID. */\n  buildId?: string\n  /** The rewrites, as computed by Next.js. */\n  rewrites?: NapiRewrites\n  defineEnv: NapiDefineEnv\n}\n/** Keep in sync with [`next_core::next_config::Rewrites`] */\nexport interface NapiRewrites {\n  fallback: Array<NapiRewrite>\n  afterFiles: Array<NapiRewrite>\n  beforeFiles: Array<NapiRewrite>\n}\n/** Keep in sync with [`next_core::next_config::Rewrite`] */\nexport interface NapiRewrite {\n  source: string\n  destination: string\n  basePath?: boolean\n  locale?: boolean\n  has?: Array<NapiRouteHas>\n  missing?: Array<NapiRouteHas>\n}\nexport declare function getTargetTriple(): string\n/**\n * Initialize tracing subscriber to emit traces. This configures subscribers\n * for Trace Event Format <https://docs.google.com/document/d/1CvAClvFfyA5R-PhYUmn5OOQtYMH4h6I0nSsKchNAySU/preview>.\n */\nexport declare function initCustomTraceSubscriber(\n  traceOutFilePath?: string | undefined | null\n): ExternalObject<RefCell>\n/**\n * Teardown currently running tracing subscriber to flush out remaining traces.\n * This should be called when parent node.js process exits, otherwise generated\n * trace may drop traces in the buffer.\n */\nexport declare function teardownTraceSubscriber(\n  guardExternal: ExternalObject<RefCell>\n): void\n"
        }
    ]
}