{
    "sourceFile": "node_modules/next/dist/esm/build/swc/index.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892750034,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/* eslint-disable @typescript-eslint/no-use-before-define */ import path from 'path';\nimport { pathToFileURL } from 'url';\nimport { arch, platform } from 'os';\nimport { platformArchTriples } from 'next/dist/compiled/@napi-rs/triples';\nimport * as Log from '../output/log';\nimport { getParserOptions } from './options';\nimport { eventSwcLoadFailure } from '../../telemetry/events/swc-load-failure';\nimport { patchIncorrectLockfile } from '../../lib/patch-incorrect-lockfile';\nimport { downloadNativeNextSwc, downloadWasmSwc } from '../../lib/download-swc';\nimport { isDeepStrictEqual } from 'util';\nimport { getDefineEnv } from '../webpack/plugins/define-env-plugin';\nimport { getReactCompilerLoader } from '../get-babel-loader-config';\nimport { TurbopackInternalError } from '../../shared/lib/turbopack/utils';\nconst nextVersion = \"15.3.1\";\nconst ArchName = arch();\nconst PlatformName = platform();\nfunction infoLog(...args) {\n    if (process.env.NEXT_PRIVATE_BUILD_WORKER) {\n        return;\n    }\n    if (process.env.DEBUG) {\n        Log.info(...args);\n    }\n}\n/**\n * Based on napi-rs's target triples, returns triples that have corresponding next-swc binaries.\n */ export function getSupportedArchTriples() {\n    const { darwin, win32, linux, freebsd, android } = platformArchTriples;\n    return {\n        darwin,\n        win32: {\n            arm64: win32.arm64,\n            ia32: win32.ia32.filter((triple)=>triple.abi === 'msvc'),\n            x64: win32.x64.filter((triple)=>triple.abi === 'msvc')\n        },\n        linux: {\n            // linux[x64] includes `gnux32` abi, with x64 arch.\n            x64: linux.x64.filter((triple)=>triple.abi !== 'gnux32'),\n            arm64: linux.arm64,\n            // This target is being deprecated, however we keep it in `knownDefaultWasmFallbackTriples` for now\n            arm: linux.arm\n        },\n        // Below targets are being deprecated, however we keep it in `knownDefaultWasmFallbackTriples` for now\n        freebsd: {\n            x64: freebsd.x64\n        },\n        android: {\n            arm64: android.arm64,\n            arm: android.arm\n        }\n    };\n}\nconst triples = (()=>{\n    var _supportedArchTriples_PlatformName, _platformArchTriples_PlatformName;\n    const supportedArchTriples = getSupportedArchTriples();\n    const targetTriple = (_supportedArchTriples_PlatformName = supportedArchTriples[PlatformName]) == null ? void 0 : _supportedArchTriples_PlatformName[ArchName];\n    // If we have supported triple, return it right away\n    if (targetTriple) {\n        return targetTriple;\n    }\n    // If there isn't corresponding target triple in `supportedArchTriples`, check if it's excluded from original raw triples\n    // Otherwise, it is completely unsupported platforms.\n    let rawTargetTriple = (_platformArchTriples_PlatformName = platformArchTriples[PlatformName]) == null ? void 0 : _platformArchTriples_PlatformName[ArchName];\n    if (rawTargetTriple) {\n        Log.warn(`Trying to load next-swc for target triple ${rawTargetTriple}, but there next-swc does not have native bindings support`);\n    } else {\n        Log.warn(`Trying to load next-swc for unsupported platforms ${PlatformName}/${ArchName}`);\n    }\n    return [];\n})();\n// Allow to specify an absolute path to the custom turbopack binary to load.\n// If one of env variables is set, `loadNative` will try to use specified\n// binary instead. This is thin, naive interface\n// - `loadBindings` will not validate neither path nor the binary.\n//\n// Note these are internal flag: there's no stability, feature guarantee.\nconst __INTERNAL_CUSTOM_TURBOPACK_BINDINGS = process.env.__INTERNAL_CUSTOM_TURBOPACK_BINDINGS;\nfunction checkVersionMismatch(pkgData) {\n    const version = pkgData.version;\n    if (version && version !== nextVersion) {\n        Log.warn(`Mismatching @next/swc version, detected: ${version} while Next.js is on ${nextVersion}. Please ensure these match`);\n    }\n}\n// These are the platforms we'll try to load wasm bindings first,\n// only try to load native bindings if loading wasm binding somehow fails.\n// Fallback to native binding is for migration period only,\n// once we can verify loading-wasm-first won't cause visible regressions,\n// we'll not include native bindings for these platform at all.\nconst knownDefaultWasmFallbackTriples = [\n    'x86_64-unknown-freebsd',\n    'aarch64-linux-android',\n    'arm-linux-androideabi',\n    'armv7-unknown-linux-gnueabihf',\n    'i686-pc-windows-msvc'\n];\n// The last attempt's error code returned when cjs require to native bindings fails.\n// If node.js throws an error without error code, this should be `unknown` instead of undefined.\n// For the wasm-first targets (`knownDefaultWasmFallbackTriples`) this will be `unsupported_target`.\nlet lastNativeBindingsLoadErrorCode = undefined;\nlet nativeBindings;\nlet wasmBindings;\nlet downloadWasmPromise;\nlet pendingBindings;\nlet swcTraceFlushGuard;\nlet downloadNativeBindingsPromise = undefined;\nexport const lockfilePatchPromise = {};\nexport async function loadBindings(useWasmBinary = false) {\n    // Increase Rust stack size as some npm packages being compiled need more than the default.\n    if (!process.env.RUST_MIN_STACK) {\n        process.env.RUST_MIN_STACK = '8388608';\n    }\n    if (pendingBindings) {\n        return pendingBindings;\n    }\n    // rust needs stdout to be blocking, otherwise it will throw an error (on macOS at least) when writing a lot of data (logs) to it\n    // see https://github.com/napi-rs/napi-rs/issues/1630\n    // and https://github.com/nodejs/node/blob/main/doc/api/process.md#a-note-on-process-io\n    if (process.stdout._handle != null) {\n        // @ts-ignore\n        process.stdout._handle.setBlocking == null ? void 0 : process.stdout._handle.setBlocking.call(process.stdout._handle, true);\n    }\n    if (process.stderr._handle != null) {\n        // @ts-ignore\n        process.stderr._handle.setBlocking == null ? void 0 : process.stderr._handle.setBlocking.call(process.stderr._handle, true);\n    }\n    pendingBindings = new Promise(async (resolve, _reject)=>{\n        if (!lockfilePatchPromise.cur) {\n            // always run lockfile check once so that it gets patched\n            // even if it doesn't fail to load locally\n            lockfilePatchPromise.cur = patchIncorrectLockfile(process.cwd()).catch(console.error);\n        }\n        let attempts = [];\n        const disableWasmFallback = process.env.NEXT_DISABLE_SWC_WASM;\n        const unsupportedPlatform = triples.some((triple)=>!!(triple == null ? void 0 : triple.raw) && knownDefaultWasmFallbackTriples.includes(triple.raw));\n        const isWebContainer = process.versions.webcontainer;\n        // Normal execution relies on the param `useWasmBinary` flag to load, but\n        // in certain cases where there isn't a native binary we always load wasm fallback first.\n        const shouldLoadWasmFallbackFirst = !disableWasmFallback && useWasmBinary || unsupportedPlatform || isWebContainer;\n        if (!unsupportedPlatform && useWasmBinary) {\n            Log.warn(`experimental.useWasmBinary is not an option for supported platform ${PlatformName}/${ArchName} and will be ignored.`);\n        }\n        if (shouldLoadWasmFallbackFirst) {\n            lastNativeBindingsLoadErrorCode = 'unsupported_target';\n            const fallbackBindings = await tryLoadWasmWithFallback(attempts);\n            if (fallbackBindings) {\n                return resolve(fallbackBindings);\n            }\n        }\n        // Trickle down loading `fallback` bindings:\n        //\n        // - First, try to load native bindings installed in node_modules.\n        // - If that fails with `ERR_MODULE_NOT_FOUND`, treat it as case of https://github.com/npm/cli/issues/4828\n        // that host system where generated package lock is not matching to the guest system running on, try to manually\n        // download corresponding target triple and load it. This won't be triggered if native bindings are failed to load\n        // with other reasons than `ERR_MODULE_NOT_FOUND`.\n        // - Lastly, falls back to wasm binding where possible.\n        try {\n            return resolve(loadNative());\n        } catch (a) {\n            if (Array.isArray(a) && a.every((m)=>m.includes('it was not installed'))) {\n                let fallbackBindings = await tryLoadNativeWithFallback(attempts);\n                if (fallbackBindings) {\n                    return resolve(fallbackBindings);\n                }\n            }\n            attempts = attempts.concat(a);\n        }\n        // For these platforms we already tried to load wasm and failed, skip reattempt\n        if (!shouldLoadWasmFallbackFirst && !disableWasmFallback) {\n            const fallbackBindings = await tryLoadWasmWithFallback(attempts);\n            if (fallbackBindings) {\n                return resolve(fallbackBindings);\n            }\n        }\n        logLoadFailure(attempts, true);\n    });\n    return pendingBindings;\n}\nasync function tryLoadNativeWithFallback(attempts) {\n    const nativeBindingsDirectory = path.join(path.dirname(require.resolve('next/package.json')), 'next-swc-fallback');\n    if (!downloadNativeBindingsPromise) {\n        downloadNativeBindingsPromise = downloadNativeNextSwc(nextVersion, nativeBindingsDirectory, triples.map((triple)=>triple.platformArchABI));\n    }\n    await downloadNativeBindingsPromise;\n    try {\n        return loadNative(nativeBindingsDirectory);\n    } catch (a) {\n        attempts.push(...[].concat(a));\n    }\n    return undefined;\n}\nasync function tryLoadWasmWithFallback(attempts) {\n    try {\n        let bindings = await loadWasm('');\n        // @ts-expect-error TODO: this event has a wrong type.\n        eventSwcLoadFailure({\n            wasm: 'enabled',\n            nativeBindingsErrorCode: lastNativeBindingsLoadErrorCode\n        });\n        return bindings;\n    } catch (a) {\n        attempts.push(...[].concat(a));\n    }\n    try {\n        // if not installed already download wasm package on-demand\n        // we download to a custom directory instead of to node_modules\n        // as node_module import attempts are cached and can't be re-attempted\n        // x-ref: https://github.com/nodejs/modules/issues/307\n        const wasmDirectory = path.join(path.dirname(require.resolve('next/package.json')), 'wasm');\n        if (!downloadWasmPromise) {\n            downloadWasmPromise = downloadWasmSwc(nextVersion, wasmDirectory);\n        }\n        await downloadWasmPromise;\n        let bindings = await loadWasm(wasmDirectory);\n        // @ts-expect-error TODO: this event has a wrong type.\n        eventSwcLoadFailure({\n            wasm: 'fallback',\n            nativeBindingsErrorCode: lastNativeBindingsLoadErrorCode\n        });\n        // still log native load attempts so user is\n        // aware it failed and should be fixed\n        for (const attempt of attempts){\n            Log.warn(attempt);\n        }\n        return bindings;\n    } catch (a) {\n        attempts.push(...[].concat(a));\n    }\n}\nfunction loadBindingsSync() {\n    let attempts = [];\n    try {\n        return loadNative();\n    } catch (a) {\n        attempts = attempts.concat(a);\n    }\n    // we can leverage the wasm bindings if they are already\n    // loaded\n    if (wasmBindings) {\n        return wasmBindings;\n    }\n    logLoadFailure(attempts);\n    throw Object.defineProperty(new Error('Failed to load bindings', {\n        cause: attempts\n    }), \"__NEXT_ERROR_CODE\", {\n        value: \"E424\",\n        enumerable: false,\n        configurable: true\n    });\n}\nlet loggingLoadFailure = false;\nfunction logLoadFailure(attempts, triedWasm = false) {\n    // make sure we only emit the event and log the failure once\n    if (loggingLoadFailure) return;\n    loggingLoadFailure = true;\n    for (let attempt of attempts){\n        Log.warn(attempt);\n    }\n    // @ts-expect-error TODO: this event has a wrong type.\n    eventSwcLoadFailure({\n        wasm: triedWasm ? 'failed' : undefined,\n        nativeBindingsErrorCode: lastNativeBindingsLoadErrorCode\n    }).then(()=>lockfilePatchPromise.cur || Promise.resolve()).finally(()=>{\n        Log.error(`Failed to load SWC binary for ${PlatformName}/${ArchName}, see more info here: https://nextjs.org/docs/messages/failed-loading-swc`);\n        process.exit(1);\n    });\n}\nexport function createDefineEnv({ isTurbopack, clientRouterFilters, config, dev, distDir, fetchCacheKeyPrefix, hasRewrites, middlewareMatchers }) {\n    let defineEnv = {\n        client: [],\n        edge: [],\n        nodejs: []\n    };\n    for (const variant of Object.keys(defineEnv)){\n        defineEnv[variant] = rustifyEnv(getDefineEnv({\n            isTurbopack,\n            clientRouterFilters,\n            config,\n            dev,\n            distDir,\n            fetchCacheKeyPrefix,\n            hasRewrites,\n            isClient: variant === 'client',\n            isEdgeServer: variant === 'edge',\n            isNodeOrEdgeCompilation: variant === 'nodejs' || variant === 'edge',\n            isNodeServer: variant === 'nodejs',\n            middlewareMatchers\n        }));\n    }\n    return defineEnv;\n}\nfunction rustifyEnv(env) {\n    return Object.entries(env).filter(([_, value])=>value != null).map(([name, value])=>({\n            name,\n            value\n        }));\n}\n// TODO(sokra) Support wasm option.\nfunction bindingToApi(binding, _wasm) {\n    const cancel = new class Cancel extends Error {\n    }();\n    /**\n   * Utility function to ensure all variants of an enum are handled.\n   */ function invariant(never, computeMessage) {\n        throw Object.defineProperty(new Error(`Invariant: ${computeMessage(never)}`), \"__NEXT_ERROR_CODE\", {\n            value: \"E193\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    async function withErrorCause(fn) {\n        try {\n            return await fn();\n        } catch (nativeError) {\n            throw TurbopackInternalError.createAndRecordTelemetry(nativeError);\n        }\n    }\n    /**\n   * Calls a native function and streams the result.\n   * If useBuffer is true, all values will be preserved, potentially buffered\n   * if consumed slower than produced. Else, only the latest value will be\n   * preserved.\n   */ function subscribe(useBuffer, nativeFunction) {\n        // A buffer of produced items. This will only contain values if the\n        // consumer is slower than the producer.\n        let buffer = [];\n        // A deferred value waiting for the next produced item. This will only\n        // exist if the consumer is faster than the producer.\n        let waiting;\n        let canceled = false;\n        // The native function will call this every time it emits a new result. We\n        // either need to notify a waiting consumer, or buffer the new result until\n        // the consumer catches up.\n        function emitResult(err, value) {\n            if (waiting) {\n                let { resolve, reject } = waiting;\n                waiting = undefined;\n                if (err) reject(err);\n                else resolve(value);\n            } else {\n                const item = {\n                    err,\n                    value\n                };\n                if (useBuffer) buffer.push(item);\n                else buffer[0] = item;\n            }\n        }\n        async function* createIterator() {\n            const task = await withErrorCause(()=>nativeFunction(emitResult));\n            try {\n                while(!canceled){\n                    if (buffer.length > 0) {\n                        const item = buffer.shift();\n                        if (item.err) throw item.err;\n                        yield item.value;\n                    } else {\n                        // eslint-disable-next-line no-loop-func\n                        yield new Promise((resolve, reject)=>{\n                            waiting = {\n                                resolve,\n                                reject\n                            };\n                        });\n                    }\n                }\n            } catch (e) {\n                if (e === cancel) return;\n                if (e instanceof Error) {\n                    throw TurbopackInternalError.createAndRecordTelemetry(e);\n                }\n                throw e;\n            } finally{\n                if (task) {\n                    binding.rootTaskDispose(task);\n                }\n            }\n        }\n        const iterator = createIterator();\n        iterator.return = async ()=>{\n            canceled = true;\n            if (waiting) waiting.reject(cancel);\n            return {\n                value: undefined,\n                done: true\n            };\n        };\n        return iterator;\n    }\n    async function rustifyProjectOptions(options) {\n        return {\n            ...options,\n            nextConfig: await serializeNextConfig(options.nextConfig, options.projectPath),\n            jsConfig: JSON.stringify(options.jsConfig),\n            env: rustifyEnv(options.env)\n        };\n    }\n    async function rustifyPartialProjectOptions(options) {\n        return {\n            ...options,\n            nextConfig: options.nextConfig && await serializeNextConfig(options.nextConfig, options.projectPath),\n            jsConfig: options.jsConfig && JSON.stringify(options.jsConfig),\n            env: options.env && rustifyEnv(options.env)\n        };\n    }\n    class ProjectImpl {\n        constructor(nativeProject){\n            this._nativeProject = nativeProject;\n        }\n        async update(options) {\n            await withErrorCause(async ()=>binding.projectUpdate(this._nativeProject, await rustifyPartialProjectOptions(options)));\n        }\n        async writeAllEntrypointsToDisk(appDirOnly) {\n            return await withErrorCause(async ()=>{\n                const napiEndpoints = await binding.projectWriteAllEntrypointsToDisk(this._nativeProject, appDirOnly);\n                return napiEntrypointsToRawEntrypoints(napiEndpoints);\n            });\n        }\n        entrypointsSubscribe() {\n            const subscription = subscribe(false, async (callback)=>binding.projectEntrypointsSubscribe(this._nativeProject, callback));\n            return async function*() {\n                for await (const entrypoints of subscription){\n                    yield napiEntrypointsToRawEntrypoints(entrypoints);\n                }\n            }();\n        }\n        hmrEvents(identifier) {\n            return subscribe(true, async (callback)=>binding.projectHmrEvents(this._nativeProject, identifier, callback));\n        }\n        hmrIdentifiersSubscribe() {\n            return subscribe(false, async (callback)=>binding.projectHmrIdentifiersSubscribe(this._nativeProject, callback));\n        }\n        traceSource(stackFrame, currentDirectoryFileUrl) {\n            return binding.projectTraceSource(this._nativeProject, stackFrame, currentDirectoryFileUrl);\n        }\n        getSourceForAsset(filePath) {\n            return binding.projectGetSourceForAsset(this._nativeProject, filePath);\n        }\n        getSourceMap(filePath) {\n            return binding.projectGetSourceMap(this._nativeProject, filePath);\n        }\n        getSourceMapSync(filePath) {\n            return binding.projectGetSourceMapSync(this._nativeProject, filePath);\n        }\n        updateInfoSubscribe(aggregationMs) {\n            return subscribe(true, async (callback)=>binding.projectUpdateInfoSubscribe(this._nativeProject, aggregationMs, callback));\n        }\n        shutdown() {\n            return binding.projectShutdown(this._nativeProject);\n        }\n        onExit() {\n            return binding.projectOnExit(this._nativeProject);\n        }\n    }\n    class EndpointImpl {\n        constructor(nativeEndpoint){\n            this._nativeEndpoint = nativeEndpoint;\n        }\n        async writeToDisk() {\n            return await withErrorCause(()=>binding.endpointWriteToDisk(this._nativeEndpoint));\n        }\n        async clientChanged() {\n            const clientSubscription = subscribe(false, async (callback)=>binding.endpointClientChangedSubscribe(await this._nativeEndpoint, callback));\n            await clientSubscription.next();\n            return clientSubscription;\n        }\n        async serverChanged(includeIssues) {\n            const serverSubscription = subscribe(false, async (callback)=>binding.endpointServerChangedSubscribe(await this._nativeEndpoint, includeIssues, callback));\n            await serverSubscription.next();\n            return serverSubscription;\n        }\n    }\n    /**\n   * Returns a new copy of next.js config object to avoid mutating the original.\n   *\n   * Also it does some augmentation to the configuration as well, for example set the\n   * turbopack's rules if `experimental.reactCompilerOptions` is set.\n   */ function augmentNextConfig(originalNextConfig, projectPath) {\n        var _nextConfig_experimental;\n        let nextConfig = {\n            ...originalNextConfig\n        };\n        const reactCompilerOptions = (_nextConfig_experimental = nextConfig.experimental) == null ? void 0 : _nextConfig_experimental.reactCompiler;\n        // It is not easy to set the rules inside of rust as resolving, and passing the context identical to the webpack\n        // config is bit hard, also we can reuse same codes between webpack config in here.\n        if (reactCompilerOptions) {\n            var _nextConfig_turbopack;\n            const ruleKeys = [\n                '*.ts',\n                '*.js',\n                '*.jsx',\n                '*.tsx'\n            ];\n            if (Object.keys((nextConfig == null ? void 0 : (_nextConfig_turbopack = nextConfig.turbopack) == null ? void 0 : _nextConfig_turbopack.rules) ?? []).some((key)=>ruleKeys.includes(key))) {\n                Log.warn(`The React Compiler cannot be enabled automatically because 'turbopack.rules' contains a rule for '*.ts', '*.js', '*.jsx', and '*.tsx'. Remove this rule, or add 'babel-loader' and 'babel-plugin-react-compiler' to the Turbopack configuration manually.`);\n            } else {\n                if (!nextConfig.turbopack) {\n                    nextConfig.turbopack = {};\n                }\n                if (!nextConfig.turbopack.rules) {\n                    nextConfig.turbopack.rules = {};\n                }\n                for (const key of [\n                    '*.ts',\n                    '*.js',\n                    '*.jsx',\n                    '*.tsx'\n                ]){\n                    nextConfig.turbopack.rules[key] = {\n                        browser: {\n                            foreign: false,\n                            loaders: [\n                                getReactCompilerLoader(originalNextConfig.experimental.reactCompiler, projectPath, nextConfig.dev, false, undefined)\n                            ]\n                        }\n                    };\n                }\n            }\n        }\n        return nextConfig;\n    }\n    async function serializeNextConfig(nextConfig, projectPath) {\n        var _nextConfigSerializable_experimental_turbo, _nextConfigSerializable_experimental;\n        // Avoid mutating the existing `nextConfig` object.\n        let nextConfigSerializable = augmentNextConfig(nextConfig, projectPath);\n        nextConfigSerializable.generateBuildId = await (nextConfig.generateBuildId == null ? void 0 : nextConfig.generateBuildId.call(nextConfig));\n        // TODO: these functions takes arguments, have to be supported in a different way\n        nextConfigSerializable.exportPathMap = {};\n        nextConfigSerializable.webpack = nextConfig.webpack && {};\n        if ((_nextConfigSerializable_experimental = nextConfigSerializable.experimental) == null ? void 0 : (_nextConfigSerializable_experimental_turbo = _nextConfigSerializable_experimental.turbo) == null ? void 0 : _nextConfigSerializable_experimental_turbo.rules) {\n            var _nextConfigSerializable_turbopack;\n            ensureLoadersHaveSerializableOptions((_nextConfigSerializable_turbopack = nextConfigSerializable.turbopack) == null ? void 0 : _nextConfigSerializable_turbopack.rules);\n        }\n        nextConfigSerializable.modularizeImports = nextConfigSerializable.modularizeImports ? Object.fromEntries(Object.entries(nextConfigSerializable.modularizeImports).map(([mod, config])=>[\n                mod,\n                {\n                    ...config,\n                    transform: typeof config.transform === 'string' ? config.transform : Object.entries(config.transform).map(([key, value])=>[\n                            key,\n                            value\n                        ])\n                }\n            ])) : undefined;\n        // loaderFile is an absolute path, we need it to be relative for turbopack.\n        if (nextConfigSerializable.images.loaderFile) {\n            nextConfigSerializable.images = {\n                ...nextConfig.images,\n                loaderFile: './' + path.relative(projectPath, nextConfig.images.loaderFile)\n            };\n        }\n        return JSON.stringify(nextConfigSerializable, null, 2);\n    }\n    function ensureLoadersHaveSerializableOptions(turbopackRules) {\n        for (const [glob, rule] of Object.entries(turbopackRules)){\n            if (Array.isArray(rule)) {\n                checkLoaderItems(rule, glob);\n            } else {\n                checkConfigItem(rule, glob);\n            }\n        }\n        function checkConfigItem(rule, glob) {\n            if (!rule) return;\n            if ('loaders' in rule) {\n                checkLoaderItems(rule.loaders, glob);\n            } else {\n                for(const key in rule){\n                    const inner = rule[key];\n                    if (typeof inner === 'object' && inner) {\n                        checkConfigItem(inner, glob);\n                    }\n                }\n            }\n        }\n        function checkLoaderItems(loaderItems, glob) {\n            for (const loaderItem of loaderItems){\n                if (typeof loaderItem !== 'string' && !isDeepStrictEqual(loaderItem, JSON.parse(JSON.stringify(loaderItem)))) {\n                    throw Object.defineProperty(new Error(`loader ${loaderItem.loader} for match \"${glob}\" does not have serializable options. Ensure that options passed are plain JavaScript objects and values.`), \"__NEXT_ERROR_CODE\", {\n                        value: \"E491\",\n                        enumerable: false,\n                        configurable: true\n                    });\n                }\n            }\n        }\n    }\n    function napiEntrypointsToRawEntrypoints(entrypoints) {\n        const routes = new Map();\n        for (const { pathname, ...nativeRoute } of entrypoints.routes){\n            let route;\n            const routeType = nativeRoute.type;\n            switch(routeType){\n                case 'page':\n                    route = {\n                        type: 'page',\n                        htmlEndpoint: new EndpointImpl(nativeRoute.htmlEndpoint),\n                        dataEndpoint: new EndpointImpl(nativeRoute.dataEndpoint)\n                    };\n                    break;\n                case 'page-api':\n                    route = {\n                        type: 'page-api',\n                        endpoint: new EndpointImpl(nativeRoute.endpoint)\n                    };\n                    break;\n                case 'app-page':\n                    route = {\n                        type: 'app-page',\n                        pages: nativeRoute.pages.map((page)=>({\n                                originalName: page.originalName,\n                                htmlEndpoint: new EndpointImpl(page.htmlEndpoint),\n                                rscEndpoint: new EndpointImpl(page.rscEndpoint)\n                            }))\n                    };\n                    break;\n                case 'app-route':\n                    route = {\n                        type: 'app-route',\n                        originalName: nativeRoute.originalName,\n                        endpoint: new EndpointImpl(nativeRoute.endpoint)\n                    };\n                    break;\n                case 'conflict':\n                    route = {\n                        type: 'conflict'\n                    };\n                    break;\n                default:\n                    const _exhaustiveCheck = routeType;\n                    invariant(nativeRoute, ()=>`Unknown route type: ${_exhaustiveCheck}`);\n            }\n            routes.set(pathname, route);\n        }\n        const napiMiddlewareToMiddleware = (middleware)=>({\n                endpoint: new EndpointImpl(middleware.endpoint),\n                runtime: middleware.runtime,\n                matcher: middleware.matcher\n            });\n        const middleware = entrypoints.middleware ? napiMiddlewareToMiddleware(entrypoints.middleware) : undefined;\n        const napiInstrumentationToInstrumentation = (instrumentation)=>({\n                nodeJs: new EndpointImpl(instrumentation.nodeJs),\n                edge: new EndpointImpl(instrumentation.edge)\n            });\n        const instrumentation = entrypoints.instrumentation ? napiInstrumentationToInstrumentation(entrypoints.instrumentation) : undefined;\n        return {\n            routes,\n            middleware,\n            instrumentation,\n            pagesDocumentEndpoint: new EndpointImpl(entrypoints.pagesDocumentEndpoint),\n            pagesAppEndpoint: new EndpointImpl(entrypoints.pagesAppEndpoint),\n            pagesErrorEndpoint: new EndpointImpl(entrypoints.pagesErrorEndpoint),\n            issues: entrypoints.issues,\n            diagnostics: entrypoints.diagnostics\n        };\n    }\n    return async function createProject(options, turboEngineOptions) {\n        return new ProjectImpl(await binding.projectNew(await rustifyProjectOptions(options), turboEngineOptions || {}));\n    };\n}\nasync function loadWasm(importPath = '') {\n    if (wasmBindings) {\n        return wasmBindings;\n    }\n    let attempts = [];\n    for (let pkg of [\n        '@next/swc-wasm-nodejs',\n        '@next/swc-wasm-web'\n    ]){\n        try {\n            let pkgPath = pkg;\n            if (importPath) {\n                // the import path must be exact when not in node_modules\n                pkgPath = path.join(importPath, pkg, 'wasm.js');\n            }\n            let bindings = await import(pathToFileURL(pkgPath).toString());\n            if (pkg === '@next/swc-wasm-web') {\n                bindings = await bindings.default();\n            }\n            infoLog('next-swc build: wasm build @next/swc-wasm-web');\n            // Note wasm binary does not support async intefaces yet, all async\n            // interface coereces to sync interfaces.\n            wasmBindings = {\n                css: {\n                    lightning: {\n                        transform: function(_options) {\n                            throw Object.defineProperty(new Error('`css.lightning.transform` is not supported by the wasm bindings.'), \"__NEXT_ERROR_CODE\", {\n                                value: \"E330\",\n                                enumerable: false,\n                                configurable: true\n                            });\n                        },\n                        transformStyleAttr: function(_options) {\n                            throw Object.defineProperty(new Error('`css.lightning.transformStyleAttr` is not supported by the wasm bindings.'), \"__NEXT_ERROR_CODE\", {\n                                value: \"E324\",\n                                enumerable: false,\n                                configurable: true\n                            });\n                        }\n                    }\n                },\n                isWasm: true,\n                transform (src, options) {\n                    // TODO: we can remove fallback to sync interface once new stable version of next-swc gets published (current v12.2)\n                    return (bindings == null ? void 0 : bindings.transform) ? bindings.transform(src.toString(), options) : Promise.resolve(bindings.transformSync(src.toString(), options));\n                },\n                transformSync (src, options) {\n                    return bindings.transformSync(src.toString(), options);\n                },\n                minify (src, options) {\n                    return (bindings == null ? void 0 : bindings.minify) ? bindings.minify(src.toString(), options) : Promise.resolve(bindings.minifySync(src.toString(), options));\n                },\n                minifySync (src, options) {\n                    return bindings.minifySync(src.toString(), options);\n                },\n                parse (src, options) {\n                    return (bindings == null ? void 0 : bindings.parse) ? bindings.parse(src.toString(), options) : Promise.resolve(bindings.parseSync(src.toString(), options));\n                },\n                getTargetTriple () {\n                    return undefined;\n                },\n                turbo: {\n                    createProject: function(_options, _turboEngineOptions) {\n                        throw Object.defineProperty(new Error('`turbo.createProject` is not supported by the wasm bindings.'), \"__NEXT_ERROR_CODE\", {\n                            value: \"E403\",\n                            enumerable: false,\n                            configurable: true\n                        });\n                    },\n                    startTurbopackTraceServer: function(_traceFilePath) {\n                        throw Object.defineProperty(new Error('`turbo.startTurbopackTraceServer` is not supported by the wasm bindings.'), \"__NEXT_ERROR_CODE\", {\n                            value: \"E13\",\n                            enumerable: false,\n                            configurable: true\n                        });\n                    }\n                },\n                mdx: {\n                    compile (src, options) {\n                        return bindings.mdxCompile(src, getMdxOptions(options));\n                    },\n                    compileSync (src, options) {\n                        return bindings.mdxCompileSync(src, getMdxOptions(options));\n                    }\n                },\n                reactCompiler: {\n                    isReactCompilerRequired (_filename) {\n                        return Promise.resolve(true);\n                    }\n                }\n            };\n            return wasmBindings;\n        } catch (e) {\n            // Only log attempts for loading wasm when loading as fallback\n            if (importPath) {\n                if ((e == null ? void 0 : e.code) === 'ERR_MODULE_NOT_FOUND') {\n                    attempts.push(`Attempted to load ${pkg}, but it was not installed`);\n                } else {\n                    attempts.push(`Attempted to load ${pkg}, but an error occurred: ${e.message ?? e}`);\n                }\n            }\n        }\n    }\n    throw attempts;\n}\nfunction loadNative(importPath) {\n    if (nativeBindings) {\n        return nativeBindings;\n    }\n    const customBindings = !!__INTERNAL_CUSTOM_TURBOPACK_BINDINGS ? require(__INTERNAL_CUSTOM_TURBOPACK_BINDINGS) : null;\n    let bindings = customBindings;\n    let attempts = [];\n    const NEXT_TEST_NATIVE_DIR = process.env.NEXT_TEST_NATIVE_DIR;\n    for (const triple of triples){\n        if (NEXT_TEST_NATIVE_DIR) {\n            try {\n                // Use the binary directly to skip `pnpm pack` for testing as it's slow because of the large native binary.\n                bindings = require(`${NEXT_TEST_NATIVE_DIR}/next-swc.${triple.platformArchABI}.node`);\n                infoLog('next-swc build: local built @next/swc from NEXT_TEST_NATIVE_DIR');\n                break;\n            } catch (e) {}\n        } else {\n            try {\n                bindings = require(`@next/swc/native/next-swc.${triple.platformArchABI}.node`);\n                infoLog('next-swc build: local built @next/swc');\n                break;\n            } catch (e) {}\n        }\n    }\n    if (!bindings) {\n        for (const triple of triples){\n            let pkg = importPath ? path.join(importPath, `@next/swc-${triple.platformArchABI}`, `next-swc.${triple.platformArchABI}.node`) : `@next/swc-${triple.platformArchABI}`;\n            try {\n                bindings = require(pkg);\n                if (!importPath) {\n                    checkVersionMismatch(require(`${pkg}/package.json`));\n                }\n                break;\n            } catch (e) {\n                if ((e == null ? void 0 : e.code) === 'MODULE_NOT_FOUND') {\n                    attempts.push(`Attempted to load ${pkg}, but it was not installed`);\n                } else {\n                    attempts.push(`Attempted to load ${pkg}, but an error occurred: ${e.message ?? e}`);\n                }\n                lastNativeBindingsLoadErrorCode = (e == null ? void 0 : e.code) ?? 'unknown';\n            }\n        }\n    }\n    if (bindings) {\n        nativeBindings = {\n            isWasm: false,\n            transform (src, options) {\n                var _options_jsc;\n                const isModule = typeof src !== 'undefined' && typeof src !== 'string' && !Buffer.isBuffer(src);\n                options = options || {};\n                if (options == null ? void 0 : (_options_jsc = options.jsc) == null ? void 0 : _options_jsc.parser) {\n                    options.jsc.parser.syntax = options.jsc.parser.syntax ?? 'ecmascript';\n                }\n                return bindings.transform(isModule ? JSON.stringify(src) : src, isModule, toBuffer(options));\n            },\n            transformSync (src, options) {\n                var _options_jsc;\n                if (typeof src === 'undefined') {\n                    throw Object.defineProperty(new Error(\"transformSync doesn't implement reading the file from filesystem\"), \"__NEXT_ERROR_CODE\", {\n                        value: \"E292\",\n                        enumerable: false,\n                        configurable: true\n                    });\n                } else if (Buffer.isBuffer(src)) {\n                    throw Object.defineProperty(new Error(\"transformSync doesn't implement taking the source code as Buffer\"), \"__NEXT_ERROR_CODE\", {\n                        value: \"E387\",\n                        enumerable: false,\n                        configurable: true\n                    });\n                }\n                const isModule = typeof src !== 'string';\n                options = options || {};\n                if (options == null ? void 0 : (_options_jsc = options.jsc) == null ? void 0 : _options_jsc.parser) {\n                    options.jsc.parser.syntax = options.jsc.parser.syntax ?? 'ecmascript';\n                }\n                return bindings.transformSync(isModule ? JSON.stringify(src) : src, isModule, toBuffer(options));\n            },\n            minify (src, options) {\n                return bindings.minify(toBuffer(src), toBuffer(options ?? {}));\n            },\n            minifySync (src, options) {\n                return bindings.minifySync(toBuffer(src), toBuffer(options ?? {}));\n            },\n            parse (src, options) {\n                return bindings.parse(src, toBuffer(options ?? {}));\n            },\n            getTargetTriple: bindings.getTargetTriple,\n            initCustomTraceSubscriber: bindings.initCustomTraceSubscriber,\n            teardownTraceSubscriber: bindings.teardownTraceSubscriber,\n            turbo: {\n                createProject: bindingToApi(customBindings ?? bindings, false),\n                startTurbopackTraceServer (traceFilePath) {\n                    Log.warn('Turbopack trace server started. View trace at https://turbo-trace-viewer.vercel.app/');\n                    (customBindings ?? bindings).startTurbopackTraceServer(traceFilePath);\n                }\n            },\n            mdx: {\n                compile (src, options) {\n                    return bindings.mdxCompile(src, toBuffer(getMdxOptions(options)));\n                },\n                compileSync (src, options) {\n                    bindings.mdxCompileSync(src, toBuffer(getMdxOptions(options)));\n                }\n            },\n            css: {\n                lightning: {\n                    transform (transformOptions) {\n                        return bindings.lightningCssTransform(transformOptions);\n                    },\n                    transformStyleAttr (transformAttrOptions) {\n                        return bindings.lightningCssTransformStyleAttribute(transformAttrOptions);\n                    }\n                }\n            },\n            reactCompiler: {\n                isReactCompilerRequired: (filename)=>{\n                    return bindings.isReactCompilerRequired(filename);\n                }\n            }\n        };\n        return nativeBindings;\n    }\n    throw attempts;\n}\n/// Build a mdx options object contains default values that\n/// can be parsed with serde_wasm_bindgen.\nfunction getMdxOptions(options = {}) {\n    return {\n        ...options,\n        development: options.development ?? false,\n        jsx: options.jsx ?? false,\n        mdxType: options.mdxType ?? 'commonMark'\n    };\n}\nfunction toBuffer(t) {\n    return Buffer.from(JSON.stringify(t));\n}\nexport async function isWasm() {\n    let bindings = await loadBindings();\n    return bindings.isWasm;\n}\nexport async function transform(src, options) {\n    let bindings = await loadBindings();\n    return bindings.transform(src, options);\n}\nexport function transformSync(src, options) {\n    let bindings = loadBindingsSync();\n    return bindings.transformSync(src, options);\n}\nexport async function minify(src, options) {\n    let bindings = await loadBindings();\n    return bindings.minify(src, options);\n}\nexport async function isReactCompilerRequired(filename) {\n    let bindings = await loadBindings();\n    return bindings.reactCompiler.isReactCompilerRequired(filename);\n}\nexport async function parse(src, options) {\n    let bindings = await loadBindings();\n    let parserOptions = getParserOptions(options);\n    return bindings.parse(src, parserOptions).then((astStr)=>JSON.parse(astStr));\n}\nexport function getBinaryMetadata() {\n    var _bindings_getTargetTriple;\n    let bindings;\n    try {\n        bindings = loadNative();\n    } catch (e) {\n    // Suppress exceptions, this fn allows to fail to load native bindings\n    }\n    return {\n        target: bindings == null ? void 0 : (_bindings_getTargetTriple = bindings.getTargetTriple) == null ? void 0 : _bindings_getTargetTriple.call(bindings)\n    };\n}\n/**\n * Initialize trace subscriber to emit traces.\n *\n */ export function initCustomTraceSubscriber(traceFileName) {\n    if (swcTraceFlushGuard) {\n        // Wasm binary doesn't support trace emission\n        let bindings = loadNative();\n        swcTraceFlushGuard = bindings.initCustomTraceSubscriber == null ? void 0 : bindings.initCustomTraceSubscriber.call(bindings, traceFileName);\n    }\n}\nfunction once(fn) {\n    let executed = false;\n    return function() {\n        if (!executed) {\n            executed = true;\n            fn();\n        }\n    };\n}\n/**\n * Teardown swc's trace subscriber if there's an initialized flush guard exists.\n *\n * This is workaround to amend behavior with process.exit\n * (https://github.com/vercel/next.js/blob/4db8c49cc31e4fc182391fae6903fb5ef4e8c66e/packages/next/bin/next.ts#L134=)\n * seems preventing napi's cleanup hook execution (https://github.com/swc-project/swc/blob/main/crates/node/src/util.rs#L48-L51=),\n *\n * instead parent process manually drops guard when process gets signal to exit.\n */ export const teardownTraceSubscriber = once(()=>{\n    try {\n        let bindings = loadNative();\n        if (swcTraceFlushGuard) {\n            bindings.teardownTraceSubscriber == null ? void 0 : bindings.teardownTraceSubscriber.call(bindings, swcTraceFlushGuard);\n        }\n    } catch (e) {\n    // Suppress exceptions, this fn allows to fail to load native bindings\n    }\n});\n\n//# sourceMappingURL=index.js.map"
        }
    ]
}