{
    "sourceFile": "node_modules/next/dist/esm/build/babel/plugins/next-page-config.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892745669,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import { types as BabelTypes } from 'next/dist/compiled/babel/core';\nimport { STRING_LITERAL_DROP_BUNDLE } from '../../../shared/lib/constants';\nconst CONFIG_KEY = 'config';\n// replace program path with just a variable with the drop identifier\nfunction replaceBundle(path, t) {\n    path.parentPath.replaceWith(t.program([\n        t.variableDeclaration('const', [\n            t.variableDeclarator(t.identifier(STRING_LITERAL_DROP_BUNDLE), t.stringLiteral(`${STRING_LITERAL_DROP_BUNDLE} ${Date.now()}`))\n        ])\n    ], []));\n}\nfunction errorMessage(state, details) {\n    const pageName = (state.filename || '').split(state.cwd || '').pop() || 'unknown';\n    return `Invalid page config export found. ${details} in file ${pageName}. See: https://nextjs.org/docs/messages/invalid-page-config`;\n}\n// config to parsing pageConfig for client bundles\nexport default function nextPageConfig({ types: t }) {\n    return {\n        visitor: {\n            Program: {\n                enter (path, state) {\n                    path.traverse({\n                        ExportDeclaration (exportPath, exportState) {\n                            var _exportPath_node_specifiers;\n                            if (BabelTypes.isExportNamedDeclaration(exportPath.node) && ((_exportPath_node_specifiers = exportPath.node.specifiers) == null ? void 0 : _exportPath_node_specifiers.some((specifier)=>{\n                                return (t.isIdentifier(specifier.exported) ? specifier.exported.name : specifier.exported.value) === CONFIG_KEY;\n                            })) && BabelTypes.isStringLiteral(exportPath.node.source)) {\n                                throw Object.defineProperty(new Error(errorMessage(exportState, 'Expected object but got export from')), \"__NEXT_ERROR_CODE\", {\n                                    value: \"E394\",\n                                    enumerable: false,\n                                    configurable: true\n                                });\n                            }\n                        },\n                        ExportNamedDeclaration (exportPath, exportState) {\n                            var _exportPath_node_declaration, _exportPath_scope_getBinding;\n                            if (exportState.bundleDropped || !exportPath.node.declaration && exportPath.node.specifiers.length === 0) {\n                                return;\n                            }\n                            const config = {};\n                            const declarations = [\n                                ...((_exportPath_node_declaration = exportPath.node.declaration) == null ? void 0 : _exportPath_node_declaration.declarations) || [],\n                                (_exportPath_scope_getBinding = exportPath.scope.getBinding(CONFIG_KEY)) == null ? void 0 : _exportPath_scope_getBinding.path.node\n                            ].filter(Boolean);\n                            for (const specifier of exportPath.node.specifiers){\n                                if ((t.isIdentifier(specifier.exported) ? specifier.exported.name : specifier.exported.value) === CONFIG_KEY) {\n                                    // export {} from 'somewhere'\n                                    if (BabelTypes.isStringLiteral(exportPath.node.source)) {\n                                        throw Object.defineProperty(new Error(errorMessage(exportState, `Expected object but got import`)), \"__NEXT_ERROR_CODE\", {\n                                            value: \"E394\",\n                                            enumerable: false,\n                                            configurable: true\n                                        });\n                                    // import hello from 'world'\n                                    // export { hello as config }\n                                    } else if (BabelTypes.isIdentifier(specifier.local)) {\n                                        var _exportPath_scope_getBinding1;\n                                        if (BabelTypes.isImportSpecifier((_exportPath_scope_getBinding1 = exportPath.scope.getBinding(specifier.local.name)) == null ? void 0 : _exportPath_scope_getBinding1.path.node)) {\n                                            throw Object.defineProperty(new Error(errorMessage(exportState, `Expected object but got import`)), \"__NEXT_ERROR_CODE\", {\n                                                value: \"E394\",\n                                                enumerable: false,\n                                                configurable: true\n                                            });\n                                        }\n                                    }\n                                }\n                            }\n                            for (const declaration of declarations){\n                                if (!BabelTypes.isIdentifier(declaration.id, {\n                                    name: CONFIG_KEY\n                                })) {\n                                    continue;\n                                }\n                                let { init } = declaration;\n                                if (BabelTypes.isTSAsExpression(init)) {\n                                    init = init.expression;\n                                }\n                                if (!BabelTypes.isObjectExpression(init)) {\n                                    const got = init ? init.type : 'undefined';\n                                    throw Object.defineProperty(new Error(errorMessage(exportState, `Expected object but got ${got}`)), \"__NEXT_ERROR_CODE\", {\n                                        value: \"E394\",\n                                        enumerable: false,\n                                        configurable: true\n                                    });\n                                }\n                                for (const prop of init.properties){\n                                    if (BabelTypes.isSpreadElement(prop)) {\n                                        throw Object.defineProperty(new Error(errorMessage(exportState, `Property spread is not allowed`)), \"__NEXT_ERROR_CODE\", {\n                                            value: \"E394\",\n                                            enumerable: false,\n                                            configurable: true\n                                        });\n                                    }\n                                    const { name } = prop.key;\n                                    if (BabelTypes.isIdentifier(prop.key, {\n                                        name: 'amp'\n                                    })) {\n                                        if (!BabelTypes.isObjectProperty(prop)) {\n                                            throw Object.defineProperty(new Error(errorMessage(exportState, `Invalid property \"${name}\"`)), \"__NEXT_ERROR_CODE\", {\n                                                value: \"E394\",\n                                                enumerable: false,\n                                                configurable: true\n                                            });\n                                        }\n                                        if (!BabelTypes.isBooleanLiteral(prop.value) && !BabelTypes.isStringLiteral(prop.value)) {\n                                            throw Object.defineProperty(new Error(errorMessage(exportState, `Invalid value for \"${name}\"`)), \"__NEXT_ERROR_CODE\", {\n                                                value: \"E394\",\n                                                enumerable: false,\n                                                configurable: true\n                                            });\n                                        }\n                                        config.amp = prop.value.value;\n                                    }\n                                }\n                            }\n                            if (config.amp === true) {\n                                var _exportState_file_opts, _exportState_file;\n                                if (!((_exportState_file = exportState.file) == null ? void 0 : (_exportState_file_opts = _exportState_file.opts) == null ? void 0 : _exportState_file_opts.caller.isDev)) {\n                                    // don't replace bundle in development so HMR can track\n                                    // dependencies and trigger reload when they are changed\n                                    replaceBundle(exportPath, t);\n                                }\n                                exportState.bundleDropped = true;\n                                return;\n                            }\n                        }\n                    }, state);\n                }\n            }\n        }\n    };\n}\n\n//# sourceMappingURL=next-page-config.js.map"
        }
    ]
}