{
    "sourceFile": "node_modules/next/dist/esm/build/babel/plugins/next-ssg-transform.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892745798,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import { SERVER_PROPS_SSG_CONFLICT } from '../../../lib/constants';\nimport { SERVER_PROPS_ID, STATIC_PROPS_ID } from '../../../shared/lib/constants';\nexport const EXPORT_NAME_GET_STATIC_PROPS = 'getStaticProps';\nexport const EXPORT_NAME_GET_STATIC_PATHS = 'getStaticPaths';\nexport const EXPORT_NAME_GET_SERVER_PROPS = 'getServerSideProps';\nconst ssgExports = new Set([\n    EXPORT_NAME_GET_STATIC_PROPS,\n    EXPORT_NAME_GET_STATIC_PATHS,\n    EXPORT_NAME_GET_SERVER_PROPS,\n    // legacy methods added so build doesn't fail from importing\n    // server-side only methods\n    `unstable_getStaticProps`,\n    `unstable_getStaticPaths`,\n    `unstable_getServerProps`,\n    `unstable_getServerSideProps`\n]);\nfunction decorateSsgExport(t, path, state) {\n    const gsspName = state.isPrerender ? STATIC_PROPS_ID : SERVER_PROPS_ID;\n    const gsspId = t.identifier(gsspName);\n    const addGsspExport = (exportPath)=>{\n        if (state.done) {\n            return;\n        }\n        state.done = true;\n        const [pageCompPath] = exportPath.replaceWithMultiple([\n            t.exportNamedDeclaration(t.variableDeclaration(// We use 'var' instead of 'let' or 'const' for ES5 support. Since\n            // this runs in `Program#exit`, no ES2015 transforms (preset env)\n            // will be ran against this code.\n            'var', [\n                t.variableDeclarator(gsspId, t.booleanLiteral(true))\n            ]), [\n                t.exportSpecifier(gsspId, gsspId)\n            ]),\n            exportPath.node\n        ]);\n        exportPath.scope.registerDeclaration(pageCompPath);\n    };\n    path.traverse({\n        ExportDefaultDeclaration (exportDefaultPath) {\n            addGsspExport(exportDefaultPath);\n        },\n        ExportNamedDeclaration (exportNamedPath) {\n            addGsspExport(exportNamedPath);\n        }\n    });\n}\nconst isDataIdentifier = (name, state)=>{\n    if (ssgExports.has(name)) {\n        if (name === EXPORT_NAME_GET_SERVER_PROPS) {\n            if (state.isPrerender) {\n                throw Object.defineProperty(new Error(SERVER_PROPS_SSG_CONFLICT), \"__NEXT_ERROR_CODE\", {\n                    value: \"E394\",\n                    enumerable: false,\n                    configurable: true\n                });\n            }\n            state.isServerProps = true;\n        } else {\n            if (state.isServerProps) {\n                throw Object.defineProperty(new Error(SERVER_PROPS_SSG_CONFLICT), \"__NEXT_ERROR_CODE\", {\n                    value: \"E394\",\n                    enumerable: false,\n                    configurable: true\n                });\n            }\n            state.isPrerender = true;\n        }\n        return true;\n    }\n    return false;\n};\nexport default function nextTransformSsg({ types: t }) {\n    function getIdentifier(path) {\n        const parentPath = path.parentPath;\n        if (parentPath.type === 'VariableDeclarator') {\n            const pp = parentPath;\n            const name = pp.get('id');\n            return name.node.type === 'Identifier' ? name : null;\n        }\n        if (parentPath.type === 'AssignmentExpression') {\n            const pp = parentPath;\n            const name = pp.get('left');\n            return name.node.type === 'Identifier' ? name : null;\n        }\n        if (path.node.type === 'ArrowFunctionExpression') {\n            return null;\n        }\n        return path.node.id && path.node.id.type === 'Identifier' ? path.get('id') : null;\n    }\n    function isIdentifierReferenced(ident) {\n        const b = ident.scope.getBinding(ident.node.name);\n        if (b == null ? void 0 : b.referenced) {\n            // Functions can reference themselves, so we need to check if there's a\n            // binding outside the function scope or not.\n            if (b.path.type === 'FunctionDeclaration') {\n                return !b.constantViolations.concat(b.referencePaths)// Check that every reference is contained within the function:\n                .every((ref)=>ref.findParent((p)=>p === b.path));\n            }\n            return true;\n        }\n        return false;\n    }\n    function markFunction(path, state) {\n        const ident = getIdentifier(path);\n        if ((ident == null ? void 0 : ident.node) && isIdentifierReferenced(ident)) {\n            state.refs.add(ident);\n        }\n    }\n    function markImport(path, state) {\n        const local = path.get('local');\n        if (isIdentifierReferenced(local)) {\n            state.refs.add(local);\n        }\n    }\n    return {\n        visitor: {\n            Program: {\n                enter (path, state) {\n                    state.refs = new Set();\n                    state.isPrerender = false;\n                    state.isServerProps = false;\n                    state.done = false;\n                    path.traverse({\n                        VariableDeclarator (variablePath, variableState) {\n                            if (variablePath.node.id.type === 'Identifier') {\n                                const local = variablePath.get('id');\n                                if (isIdentifierReferenced(local)) {\n                                    variableState.refs.add(local);\n                                }\n                            } else if (variablePath.node.id.type === 'ObjectPattern') {\n                                const pattern = variablePath.get('id');\n                                const properties = pattern.get('properties');\n                                properties.forEach((p)=>{\n                                    const local = p.get(p.node.type === 'ObjectProperty' ? 'value' : p.node.type === 'RestElement' ? 'argument' : function() {\n                                        throw Object.defineProperty(new Error('invariant'), \"__NEXT_ERROR_CODE\", {\n                                            value: \"E400\",\n                                            enumerable: false,\n                                            configurable: true\n                                        });\n                                    }());\n                                    if (isIdentifierReferenced(local)) {\n                                        variableState.refs.add(local);\n                                    }\n                                });\n                            } else if (variablePath.node.id.type === 'ArrayPattern') {\n                                const pattern = variablePath.get('id');\n                                const elements = pattern.get('elements');\n                                elements.forEach((e)=>{\n                                    var _e_node, _e_node1;\n                                    let local;\n                                    if (((_e_node = e.node) == null ? void 0 : _e_node.type) === 'Identifier') {\n                                        local = e;\n                                    } else if (((_e_node1 = e.node) == null ? void 0 : _e_node1.type) === 'RestElement') {\n                                        local = e.get('argument');\n                                    } else {\n                                        return;\n                                    }\n                                    if (isIdentifierReferenced(local)) {\n                                        variableState.refs.add(local);\n                                    }\n                                });\n                            }\n                        },\n                        FunctionDeclaration: markFunction,\n                        FunctionExpression: markFunction,\n                        ArrowFunctionExpression: markFunction,\n                        ImportSpecifier: markImport,\n                        ImportDefaultSpecifier: markImport,\n                        ImportNamespaceSpecifier: markImport,\n                        ExportNamedDeclaration (exportNamedPath, exportNamedState) {\n                            const specifiers = exportNamedPath.get('specifiers');\n                            if (specifiers.length) {\n                                specifiers.forEach((s)=>{\n                                    if (isDataIdentifier(t.isIdentifier(s.node.exported) ? s.node.exported.name : s.node.exported.value, exportNamedState)) {\n                                        s.remove();\n                                    }\n                                });\n                                if (exportNamedPath.node.specifiers.length < 1) {\n                                    exportNamedPath.remove();\n                                }\n                                return;\n                            }\n                            const decl = exportNamedPath.get('declaration');\n                            if (decl == null || decl.node == null) {\n                                return;\n                            }\n                            switch(decl.node.type){\n                                case 'FunctionDeclaration':\n                                    {\n                                        const name = decl.node.id.name;\n                                        if (isDataIdentifier(name, exportNamedState)) {\n                                            exportNamedPath.remove();\n                                        }\n                                        break;\n                                    }\n                                case 'VariableDeclaration':\n                                    {\n                                        const inner = decl.get('declarations');\n                                        inner.forEach((d)=>{\n                                            if (d.node.id.type !== 'Identifier') {\n                                                return;\n                                            }\n                                            const name = d.node.id.name;\n                                            if (isDataIdentifier(name, exportNamedState)) {\n                                                d.remove();\n                                            }\n                                        });\n                                        break;\n                                    }\n                                default:\n                                    {\n                                        break;\n                                    }\n                            }\n                        }\n                    }, state);\n                    if (!state.isPrerender && !state.isServerProps) {\n                        return;\n                    }\n                    const refs = state.refs;\n                    let count;\n                    function sweepFunction(sweepPath) {\n                        const ident = getIdentifier(sweepPath);\n                        if ((ident == null ? void 0 : ident.node) && refs.has(ident) && !isIdentifierReferenced(ident)) {\n                            ++count;\n                            if (t.isAssignmentExpression(sweepPath.parentPath.node) || t.isVariableDeclarator(sweepPath.parentPath.node)) {\n                                sweepPath.parentPath.remove();\n                            } else {\n                                sweepPath.remove();\n                            }\n                        }\n                    }\n                    function sweepImport(sweepPath) {\n                        const local = sweepPath.get('local');\n                        if (refs.has(local) && !isIdentifierReferenced(local)) {\n                            ++count;\n                            sweepPath.remove();\n                            if (sweepPath.parent.specifiers.length === 0) {\n                                sweepPath.parentPath.remove();\n                            }\n                        }\n                    }\n                    do {\n                        ;\n                        path.scope.crawl();\n                        count = 0;\n                        path.traverse({\n                            // eslint-disable-next-line no-loop-func\n                            VariableDeclarator (variablePath) {\n                                if (variablePath.node.id.type === 'Identifier') {\n                                    const local = variablePath.get('id');\n                                    if (refs.has(local) && !isIdentifierReferenced(local)) {\n                                        ++count;\n                                        variablePath.remove();\n                                    }\n                                } else if (variablePath.node.id.type === 'ObjectPattern') {\n                                    const pattern = variablePath.get('id');\n                                    const beforeCount = count;\n                                    const properties = pattern.get('properties');\n                                    properties.forEach((p)=>{\n                                        const local = p.get(p.node.type === 'ObjectProperty' ? 'value' : p.node.type === 'RestElement' ? 'argument' : function() {\n                                            throw Object.defineProperty(new Error('invariant'), \"__NEXT_ERROR_CODE\", {\n                                                value: \"E400\",\n                                                enumerable: false,\n                                                configurable: true\n                                            });\n                                        }());\n                                        if (refs.has(local) && !isIdentifierReferenced(local)) {\n                                            ++count;\n                                            p.remove();\n                                        }\n                                    });\n                                    if (beforeCount !== count && pattern.get('properties').length < 1) {\n                                        variablePath.remove();\n                                    }\n                                } else if (variablePath.node.id.type === 'ArrayPattern') {\n                                    const pattern = variablePath.get('id');\n                                    const beforeCount = count;\n                                    const elements = pattern.get('elements');\n                                    elements.forEach((e)=>{\n                                        var _e_node, _e_node1;\n                                        let local;\n                                        if (((_e_node = e.node) == null ? void 0 : _e_node.type) === 'Identifier') {\n                                            local = e;\n                                        } else if (((_e_node1 = e.node) == null ? void 0 : _e_node1.type) === 'RestElement') {\n                                            local = e.get('argument');\n                                        } else {\n                                            return;\n                                        }\n                                        if (refs.has(local) && !isIdentifierReferenced(local)) {\n                                            ++count;\n                                            e.remove();\n                                        }\n                                    });\n                                    if (beforeCount !== count && pattern.get('elements').length < 1) {\n                                        variablePath.remove();\n                                    }\n                                }\n                            },\n                            FunctionDeclaration: sweepFunction,\n                            FunctionExpression: sweepFunction,\n                            ArrowFunctionExpression: sweepFunction,\n                            ImportSpecifier: sweepImport,\n                            ImportDefaultSpecifier: sweepImport,\n                            ImportNamespaceSpecifier: sweepImport\n                        });\n                    }while (count);\n                    decorateSsgExport(t, path, state);\n                }\n            }\n        }\n    };\n}\n\n//# sourceMappingURL=next-ssg-transform.js.map"
        }
    ]
}