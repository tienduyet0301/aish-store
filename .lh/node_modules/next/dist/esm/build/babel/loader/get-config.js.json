{
    "sourceFile": "node_modules/next/dist/esm/build/babel/loader/get-config.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892745117,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import { readFileSync } from 'fs';\nimport JSON5 from 'next/dist/compiled/json5';\nimport { createConfigItem, loadOptions } from 'next/dist/compiled/babel/core';\nimport loadConfig from 'next/dist/compiled/babel/core-lib-config';\nimport { consumeIterator } from './util';\nimport * as Log from '../../output/log';\nimport jsx from 'next/dist/compiled/babel/plugin-syntax-jsx';\nimport { isReactCompilerRequired } from '../../swc';\nconst nextDistPath = /(next[\\\\/]dist[\\\\/]shared[\\\\/]lib)|(next[\\\\/]dist[\\\\/]client)|(next[\\\\/]dist[\\\\/]pages)/;\nconst fileExtensionRegex = /\\.([a-z]+)$/;\nfunction getCacheCharacteristics(loaderOptions, source, filename) {\n    var _fileExtensionRegex_exec;\n    const { isServer, pagesDir } = loaderOptions;\n    const isPageFile = filename.startsWith(pagesDir);\n    const isNextDist = nextDistPath.test(filename);\n    const hasModuleExports = source.indexOf('module.exports') !== -1;\n    const fileExt = ((_fileExtensionRegex_exec = fileExtensionRegex.exec(filename)) == null ? void 0 : _fileExtensionRegex_exec[1]) || 'unknown';\n    return {\n        isServer,\n        isPageFile,\n        isNextDist,\n        hasModuleExports,\n        fileExt\n    };\n}\n/**\n * Return an array of Babel plugins, conditioned upon loader options and\n * source file characteristics.\n */ function getPlugins(loaderOptions, cacheCharacteristics) {\n    const { isServer, isPageFile, isNextDist, hasModuleExports } = cacheCharacteristics;\n    const { development } = loaderOptions;\n    const hasReactRefresh = loaderOptions.transformMode !== 'standalone' ? loaderOptions.hasReactRefresh : false;\n    const applyCommonJsItem = hasModuleExports ? createConfigItem(require('../plugins/commonjs'), {\n        type: 'plugin'\n    }) : null;\n    const reactRefreshItem = hasReactRefresh ? createConfigItem([\n        require('next/dist/compiled/react-refresh/babel'),\n        {\n            skipEnvCheck: true\n        }\n    ], {\n        type: 'plugin'\n    }) : null;\n    const pageConfigItem = !isServer && isPageFile ? createConfigItem([\n        require('../plugins/next-page-config')\n    ], {\n        type: 'plugin'\n    }) : null;\n    const disallowExportAllItem = !isServer && isPageFile ? createConfigItem([\n        require('../plugins/next-page-disallow-re-export-all-exports')\n    ], {\n        type: 'plugin'\n    }) : null;\n    const transformDefineItem = createConfigItem([\n        require.resolve('next/dist/compiled/babel/plugin-transform-define'),\n        {\n            'process.env.NODE_ENV': development ? 'development' : 'production',\n            'typeof window': isServer ? 'undefined' : 'object',\n            'process.browser': isServer ? false : true\n        },\n        'next-js-transform-define-instance'\n    ], {\n        type: 'plugin'\n    });\n    const nextSsgItem = !isServer && isPageFile ? createConfigItem([\n        require.resolve('../plugins/next-ssg-transform')\n    ], {\n        type: 'plugin'\n    }) : null;\n    const commonJsItem = isNextDist ? createConfigItem(require('next/dist/compiled/babel/plugin-transform-modules-commonjs'), {\n        type: 'plugin'\n    }) : null;\n    const nextFontUnsupported = createConfigItem([\n        require('../plugins/next-font-unsupported')\n    ], {\n        type: 'plugin'\n    });\n    return [\n        reactRefreshItem,\n        pageConfigItem,\n        disallowExportAllItem,\n        applyCommonJsItem,\n        transformDefineItem,\n        nextSsgItem,\n        commonJsItem,\n        nextFontUnsupported\n    ].filter(Boolean);\n}\nconst isJsonFile = /\\.(json|babelrc)$/;\nconst isJsFile = /\\.js$/;\n/**\n * While this function does block execution while reading from disk, it\n * should not introduce any issues.  The function is only invoked when\n * generating a fresh config, and only a small handful of configs should\n * be generated during compilation.\n */ function getCustomBabelConfig(configFilePath) {\n    if (isJsonFile.exec(configFilePath)) {\n        const babelConfigRaw = readFileSync(configFilePath, 'utf8');\n        return JSON5.parse(babelConfigRaw);\n    } else if (isJsFile.exec(configFilePath)) {\n        return require(configFilePath);\n    }\n    throw Object.defineProperty(new Error('The Next.js Babel loader does not support .mjs or .cjs config files.'), \"__NEXT_ERROR_CODE\", {\n        value: \"E477\",\n        enumerable: false,\n        configurable: true\n    });\n}\nlet babelConfigWarned = false;\n/**\n * Check if custom babel configuration from user only contains options that\n * can be migrated into latest Next.js features supported by SWC.\n *\n * This raises soft warning messages only, not making any errors yet.\n */ function checkCustomBabelConfigDeprecation(config) {\n    if (!config || Object.keys(config).length === 0) {\n        return;\n    }\n    const { plugins, presets, ...otherOptions } = config;\n    if (Object.keys(otherOptions ?? {}).length > 0) {\n        return;\n    }\n    if (babelConfigWarned) {\n        return;\n    }\n    babelConfigWarned = true;\n    const isPresetReadyToDeprecate = !presets || presets.length === 0 || presets.length === 1 && presets[0] === 'next/babel';\n    const pluginReasons = [];\n    const unsupportedPlugins = [];\n    if (Array.isArray(plugins)) {\n        for (const plugin of plugins){\n            const pluginName = Array.isArray(plugin) ? plugin[0] : plugin;\n            // [NOTE]: We cannot detect if the user uses babel-plugin-macro based transform plugins,\n            // such as `styled-components/macro` in here.\n            switch(pluginName){\n                case 'styled-components':\n                case 'babel-plugin-styled-components':\n                    pluginReasons.push(`\\t- 'styled-components' can be enabled via 'compiler.styledComponents' in 'next.config.js'`);\n                    break;\n                case '@emotion/babel-plugin':\n                    pluginReasons.push(`\\t- '@emotion/babel-plugin' can be enabled via 'compiler.emotion' in 'next.config.js'`);\n                    break;\n                case 'babel-plugin-relay':\n                    pluginReasons.push(`\\t- 'babel-plugin-relay' can be enabled via 'compiler.relay' in 'next.config.js'`);\n                    break;\n                case 'react-remove-properties':\n                    pluginReasons.push(`\\t- 'react-remove-properties' can be enabled via 'compiler.reactRemoveProperties' in 'next.config.js'`);\n                    break;\n                case 'transform-remove-console':\n                    pluginReasons.push(`\\t- 'transform-remove-console' can be enabled via 'compiler.removeConsole' in 'next.config.js'`);\n                    break;\n                default:\n                    unsupportedPlugins.push(pluginName);\n                    break;\n            }\n        }\n    }\n    if (isPresetReadyToDeprecate && unsupportedPlugins.length === 0) {\n        Log.warn(`It looks like there is a custom Babel configuration that can be removed${pluginReasons.length > 0 ? ':' : '.'}`);\n        if (pluginReasons.length > 0) {\n            Log.warn(`Next.js supports the following features natively: `);\n            Log.warn(pluginReasons.join(''));\n            Log.warn(`For more details configuration options, please refer https://nextjs.org/docs/architecture/nextjs-compiler#supported-features`);\n        }\n    }\n}\n/**\n * Generate a new, flat Babel config, ready to be handed to Babel-traverse.\n * This config should have no unresolved overrides, presets, etc.\n */ async function getFreshConfig(cacheCharacteristics, loaderOptions, target, filename, inputSourceMap) {\n    const hasReactCompiler = await (async ()=>{\n        if (loaderOptions.reactCompilerPlugins && loaderOptions.reactCompilerPlugins.length === 0) {\n            return false;\n        }\n        if (/[/\\\\]node_modules[/\\\\]/.test(filename)) {\n            return false;\n        }\n        if (loaderOptions.reactCompilerExclude && loaderOptions.reactCompilerExclude(filename)) {\n            return false;\n        }\n        if (!await isReactCompilerRequired(filename)) {\n            return false;\n        }\n        return true;\n    })();\n    const reactCompilerPluginsIfEnabled = hasReactCompiler ? loaderOptions.reactCompilerPlugins ?? [] : [];\n    let { isServer, pagesDir, srcDir, development } = loaderOptions;\n    let options = {\n        babelrc: false,\n        cloneInputAst: false,\n        filename,\n        inputSourceMap: inputSourceMap || undefined,\n        // Ensure that Webpack will get a full absolute path in the sourcemap\n        // so that it can properly map the module back to its internal cached\n        // modules.\n        sourceFileName: filename,\n        sourceMaps: this.sourceMap\n    };\n    const baseCaller = {\n        name: 'next-babel-turbo-loader',\n        supportsStaticESM: true,\n        supportsDynamicImport: true,\n        // Provide plugins with insight into webpack target.\n        // https://github.com/babel/babel-loader/issues/787\n        target: target,\n        // Webpack 5 supports TLA behind a flag. We enable it by default\n        // for Babel, and then webpack will throw an error if the experimental\n        // flag isn't enabled.\n        supportsTopLevelAwait: true,\n        isServer,\n        srcDir,\n        pagesDir,\n        isDev: development,\n        ...loaderOptions.caller\n    };\n    if (loaderOptions.transformMode === 'standalone') {\n        if (!reactCompilerPluginsIfEnabled.length) {\n            return null;\n        }\n        options.plugins = [\n            jsx,\n            ...reactCompilerPluginsIfEnabled\n        ];\n        options.presets = [\n            [\n                require('next/dist/compiled/babel/preset-typescript'),\n                {\n                    allowNamespaces: true\n                }\n            ]\n        ];\n        options.caller = baseCaller;\n    } else {\n        let { configFile, hasJsxRuntime } = loaderOptions;\n        let customConfig = configFile ? getCustomBabelConfig(configFile) : undefined;\n        checkCustomBabelConfigDeprecation(customConfig);\n        // Set the default sourcemap behavior based on Webpack's mapping flag,\n        // but allow users to override if they want.\n        options.sourceMaps = loaderOptions.sourceMaps === undefined ? this.sourceMap : loaderOptions.sourceMaps;\n        options.plugins = [\n            ...getPlugins(loaderOptions, cacheCharacteristics),\n            ...reactCompilerPluginsIfEnabled,\n            ...(customConfig == null ? void 0 : customConfig.plugins) || []\n        ];\n        // target can be provided in babelrc\n        options.target = isServer ? undefined : customConfig == null ? void 0 : customConfig.target;\n        // env can be provided in babelrc\n        options.env = customConfig == null ? void 0 : customConfig.env;\n        options.presets = (()=>{\n            // If presets is defined the user will have next/babel in their babelrc\n            if (customConfig == null ? void 0 : customConfig.presets) {\n                return customConfig.presets;\n            }\n            // If presets is not defined the user will likely have \"env\" in their babelrc\n            if (customConfig) {\n                return undefined;\n            }\n            // If no custom config is provided the default is to use next/babel\n            return [\n                'next/babel'\n            ];\n        })();\n        options.overrides = loaderOptions.overrides;\n        options.caller = {\n            ...baseCaller,\n            hasJsxRuntime\n        };\n    }\n    // Babel does strict checks on the config so undefined is not allowed\n    if (typeof options.target === 'undefined') {\n        delete options.target;\n    }\n    Object.defineProperty(options.caller, 'onWarning', {\n        enumerable: false,\n        writable: false,\n        value: (reason)=>{\n            if (!(reason instanceof Error)) {\n                reason = Object.defineProperty(new Error(reason), \"__NEXT_ERROR_CODE\", {\n                    value: \"E394\",\n                    enumerable: false,\n                    configurable: true\n                });\n            }\n            this.emitWarning(reason);\n        }\n    });\n    const loadedOptions = loadOptions(options);\n    const config = consumeIterator(loadConfig(loadedOptions));\n    return config;\n}\n/**\n * Each key returned here corresponds with a Babel config that can be shared.\n * The conditions of permissible sharing between files is dependent on specific\n * file attributes and Next.js compiler states: `CharacteristicsGermaneToCaching`.\n */ function getCacheKey(cacheCharacteristics) {\n    const { isServer, isPageFile, isNextDist, hasModuleExports, fileExt } = cacheCharacteristics;\n    const flags = 0 | (isServer ? 1 : 0) | (isPageFile ? 2 : 0) | (isNextDist ? 4 : 0) | (hasModuleExports ? 8 : 0);\n    return fileExt + flags;\n}\nconst configCache = new Map();\nconst configFiles = new Set();\nexport default async function getConfig({ source, target, loaderOptions, filename, inputSourceMap }) {\n    const cacheCharacteristics = getCacheCharacteristics(loaderOptions, source, filename);\n    if (loaderOptions.transformMode === 'default' && loaderOptions.configFile) {\n        // Ensures webpack invalidates the cache for this loader when the config file changes\n        this.addDependency(loaderOptions.configFile);\n    }\n    const cacheKey = getCacheKey(cacheCharacteristics);\n    if (configCache.has(cacheKey)) {\n        const cachedConfig = configCache.get(cacheKey);\n        if (!cachedConfig) {\n            return null;\n        }\n        return {\n            ...cachedConfig,\n            options: {\n                ...cachedConfig.options,\n                cwd: loaderOptions.cwd,\n                root: loaderOptions.cwd,\n                filename,\n                sourceFileName: filename\n            }\n        };\n    }\n    if (loaderOptions.transformMode === 'default' && loaderOptions.configFile && !configFiles.has(loaderOptions.configFile)) {\n        configFiles.add(loaderOptions.configFile);\n        Log.info(`Using external babel configuration from ${loaderOptions.configFile}`);\n    }\n    const freshConfig = await getFreshConfig.call(this, cacheCharacteristics, loaderOptions, target, filename, inputSourceMap);\n    configCache.set(cacheKey, freshConfig);\n    return freshConfig;\n}\n\n//# sourceMappingURL=get-config.js.map"
        }
    ]
}