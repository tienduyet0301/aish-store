{
    "sourceFile": "node_modules/next/dist/esm/export/worker.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892799703,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import '../server/node-environment';\nprocess.env.NEXT_IS_EXPORT_WORKER = 'true';\nimport { extname, join, dirname, sep } from 'path';\nimport fs from 'fs/promises';\nimport { loadComponents } from '../server/load-components';\nimport { isDynamicRoute } from '../shared/lib/router/utils/is-dynamic';\nimport { normalizePagePath } from '../shared/lib/page-path/normalize-page-path';\nimport { normalizeLocalePath } from '../shared/lib/i18n/normalize-locale-path';\nimport { trace } from '../trace';\nimport { setHttpClientAndAgentOptions } from '../server/setup-http-agent-env';\nimport isError from '../lib/is-error';\nimport { addRequestMeta } from '../server/request-meta';\nimport { normalizeAppPath } from '../shared/lib/router/utils/app-paths';\nimport { createRequestResponseMocks } from '../server/lib/mock-request';\nimport { isAppRouteRoute } from '../lib/is-app-route-route';\nimport { hasNextSupport } from '../server/ci-info';\nimport { exportAppRoute } from './routes/app-route';\nimport { exportAppPage, prospectiveRenderAppPage } from './routes/app-page';\nimport { exportPagesPage } from './routes/pages';\nimport { getParams } from './helpers/get-params';\nimport { createIncrementalCache } from './helpers/create-incremental-cache';\nimport { isPostpone } from '../server/lib/router-utils/is-postpone';\nimport { isDynamicUsageError } from './helpers/is-dynamic-usage-error';\nimport { isBailoutToCSRError } from '../shared/lib/lazy-dynamic/bailout-to-csr';\nimport { turborepoTraceAccess, TurborepoAccessTraceResult } from '../build/turborepo-access-trace';\nimport { getFallbackRouteParams } from '../server/request/fallback-params';\nimport { needsExperimentalReact } from '../lib/needs-experimental-react';\nimport { isStaticGenBailoutError } from '../client/components/static-generation-bailout';\nimport { MultiFileWriter } from '../lib/multi-file-writer';\nconst envConfig = require('../shared/lib/runtime-config.external');\nglobalThis.__NEXT_DATA__ = {\n    nextExport: true\n};\nclass TimeoutError extends Error {\n    constructor(...args){\n        super(...args), this.code = 'NEXT_EXPORT_TIMEOUT_ERROR';\n    }\n}\nclass ExportPageError extends Error {\n    constructor(...args){\n        super(...args), this.code = 'NEXT_EXPORT_PAGE_ERROR';\n    }\n}\nasync function exportPageImpl(input, fileWriter) {\n    var _req_url;\n    const { path, pathMap, distDir, pagesDataDir, buildExport = false, serverRuntimeConfig, subFolders = false, optimizeCss, disableOptimizedLoading, debugOutput = false, enableExperimentalReact, ampValidatorPath, trailingSlash, sriEnabled } = input;\n    if (enableExperimentalReact) {\n        process.env.__NEXT_EXPERIMENTAL_REACT = 'true';\n    }\n    const { page, // The parameters that are currently unknown.\n    _fallbackRouteParams = [], // Check if this is an `app/` page.\n    _isAppDir: isAppDir = false, // Check if this should error when dynamic usage is detected.\n    _isDynamicError: isDynamicError = false, // If this page supports partial prerendering, then we need to pass that to\n    // the renderOpts.\n    _isRoutePPREnabled: isRoutePPREnabled, // If this is a prospective render, we don't actually want to persist the\n    // result, we just want to use it to error the build if there's a problem.\n    _isProspectiveRender: isProspectiveRender = false, // Pull the original query out.\n    query: originalQuery = {} } = pathMap;\n    const fallbackRouteParams = getFallbackRouteParams(_fallbackRouteParams);\n    let query = {\n        ...originalQuery\n    };\n    const pathname = normalizeAppPath(page);\n    const isDynamic = isDynamicRoute(page);\n    const outDir = isAppDir ? join(distDir, 'server/app') : input.outDir;\n    const filePath = normalizePagePath(path);\n    const ampPath = `${filePath}.amp`;\n    let renderAmpPath = ampPath;\n    let updatedPath = pathMap._ssgPath || path;\n    let locale = pathMap._locale || input.renderOpts.locale;\n    if (input.renderOpts.locale) {\n        const localePathResult = normalizeLocalePath(path, input.renderOpts.locales);\n        if (localePathResult.detectedLocale) {\n            updatedPath = localePathResult.pathname;\n            locale = localePathResult.detectedLocale;\n            if (locale === input.renderOpts.defaultLocale) {\n                renderAmpPath = `${normalizePagePath(updatedPath)}.amp`;\n            }\n        }\n    }\n    // We need to show a warning if they try to provide query values\n    // for an auto-exported page since they won't be available\n    const hasOrigQueryValues = Object.keys(originalQuery).length > 0;\n    // Check if the page is a specified dynamic route\n    const { pathname: nonLocalizedPath } = normalizeLocalePath(path, input.renderOpts.locales);\n    let params;\n    if (isDynamic && page !== nonLocalizedPath) {\n        const normalizedPage = isAppDir ? normalizeAppPath(page) : page;\n        params = getParams(normalizedPage, updatedPath);\n    }\n    const { req, res } = createRequestResponseMocks({\n        url: updatedPath\n    });\n    // If this is a status code page, then set the response code.\n    for (const statusCode of [\n        404,\n        500\n    ]){\n        if ([\n            `/${statusCode}`,\n            `/${statusCode}.html`,\n            `/${statusCode}/index.html`\n        ].some((p)=>p === updatedPath || `/${locale}${p}` === updatedPath)) {\n            res.statusCode = statusCode;\n        }\n    }\n    // Ensure that the URL has a trailing slash if it's configured.\n    if (trailingSlash && !((_req_url = req.url) == null ? void 0 : _req_url.endsWith('/'))) {\n        req.url += '/';\n    }\n    if (locale && buildExport && input.renderOpts.domainLocales && input.renderOpts.domainLocales.some((dl)=>{\n        var _dl_locales;\n        return dl.defaultLocale === locale || ((_dl_locales = dl.locales) == null ? void 0 : _dl_locales.includes(locale || ''));\n    })) {\n        addRequestMeta(req, 'isLocaleDomain', true);\n    }\n    envConfig.setConfig({\n        serverRuntimeConfig,\n        publicRuntimeConfig: input.renderOpts.runtimeConfig\n    });\n    const getHtmlFilename = (p)=>subFolders ? `${p}${sep}index.html` : `${p}.html`;\n    let htmlFilename = getHtmlFilename(filePath);\n    // dynamic routes can provide invalid extensions e.g. /blog/[...slug] returns an\n    // extension of `.slug]`\n    const pageExt = isDynamic || isAppDir ? '' : extname(page);\n    const pathExt = isDynamic || isAppDir ? '' : extname(path);\n    // force output 404.html for backwards compat\n    if (path === '/404.html') {\n        htmlFilename = path;\n    } else if (pageExt !== pathExt && pathExt !== '') {\n        const isBuiltinPaths = [\n            '/500',\n            '/404'\n        ].some((p)=>p === path || p === path + '.html');\n        // If the ssg path has .html extension, and it's not builtin paths, use it directly\n        // Otherwise, use that as the filename instead\n        const isHtmlExtPath = !isBuiltinPaths && path.endsWith('.html');\n        htmlFilename = isHtmlExtPath ? getHtmlFilename(path) : path;\n    } else if (path === '/') {\n        // If the path is the root, just use index.html\n        htmlFilename = 'index.html';\n    }\n    const baseDir = join(outDir, dirname(htmlFilename));\n    let htmlFilepath = join(outDir, htmlFilename);\n    await fs.mkdir(baseDir, {\n        recursive: true\n    });\n    const components = await loadComponents({\n        distDir,\n        page,\n        isAppPath: isAppDir,\n        isDev: false,\n        sriEnabled\n    });\n    // Handle App Routes.\n    if (isAppDir && isAppRouteRoute(page)) {\n        return exportAppRoute(req, res, params, page, components.routeModule, input.renderOpts.incrementalCache, input.renderOpts.cacheLifeProfiles, htmlFilepath, fileWriter, input.renderOpts.experimental, input.buildId);\n    }\n    const renderOpts = {\n        ...components,\n        ...input.renderOpts,\n        ampPath: renderAmpPath,\n        params,\n        optimizeCss,\n        disableOptimizedLoading,\n        locale,\n        supportsDynamicResponse: false,\n        // During the export phase in next build, we always enable the streaming metadata since if there's\n        // any dynamic access in metadata we can determine it in the build phase.\n        // If it's static, then it won't affect anything.\n        // If it's dynamic, then it can be handled when request hits the route.\n        serveStreamingMetadata: true,\n        experimental: {\n            ...input.renderOpts.experimental,\n            isRoutePPREnabled\n        }\n    };\n    if (hasNextSupport) {\n        renderOpts.isRevalidate = true;\n    }\n    // Handle App Pages\n    if (isAppDir) {\n        const sharedContext = {\n            buildId: input.buildId\n        };\n        // If this is a prospective render, don't return any metrics or revalidate\n        // timings as we aren't persisting this render (it was only to error).\n        if (isProspectiveRender) {\n            return prospectiveRenderAppPage(req, res, page, pathname, query, fallbackRouteParams, renderOpts, sharedContext);\n        }\n        return exportAppPage(req, res, page, path, pathname, query, fallbackRouteParams, renderOpts, htmlFilepath, debugOutput, isDynamicError, fileWriter, sharedContext);\n    }\n    const sharedContext = {\n        buildId: input.buildId,\n        deploymentId: input.renderOpts.deploymentId,\n        customServer: undefined\n    };\n    const renderContext = {\n        isFallback: pathMap._pagesFallback ?? false,\n        isDraftMode: false,\n        developmentNotFoundSourcePage: undefined\n    };\n    return exportPagesPage(req, res, path, page, query, params, htmlFilepath, htmlFilename, ampPath, subFolders, outDir, ampValidatorPath, pagesDataDir, buildExport, isDynamic, sharedContext, renderContext, hasOrigQueryValues, renderOpts, components, fileWriter);\n}\nexport async function exportPages(input) {\n    const { exportPathMap, paths, dir, distDir, outDir, cacheHandler, cacheMaxMemorySize, fetchCacheKeyPrefix, pagesDataDir, renderOpts, nextConfig, options } = input;\n    // If the fetch cache was enabled, we need to create an incremental\n    // cache instance for this page.\n    const incrementalCache = await createIncrementalCache({\n        cacheHandler,\n        cacheMaxMemorySize,\n        fetchCacheKeyPrefix,\n        distDir,\n        dir,\n        // skip writing to disk in minimal mode for now, pending some\n        // changes to better support it\n        flushToDisk: !hasNextSupport,\n        cacheHandlers: nextConfig.experimental.cacheHandlers\n    });\n    renderOpts.incrementalCache = incrementalCache;\n    const maxConcurrency = nextConfig.experimental.staticGenerationMaxConcurrency ?? 8;\n    const results = [];\n    const exportPageWithRetry = async (path, maxAttempts)=>{\n        const pathMap = exportPathMap[path];\n        const { page } = exportPathMap[path];\n        const pageKey = page !== path ? `${page}: ${path}` : path;\n        let attempt = 0;\n        let result;\n        while(attempt < maxAttempts){\n            try {\n                var _nextConfig_experimental_amp, _nextConfig_experimental_sri;\n                result = await Promise.race([\n                    exportPage({\n                        path,\n                        pathMap,\n                        distDir,\n                        outDir,\n                        pagesDataDir,\n                        renderOpts,\n                        ampValidatorPath: ((_nextConfig_experimental_amp = nextConfig.experimental.amp) == null ? void 0 : _nextConfig_experimental_amp.validator) || undefined,\n                        trailingSlash: nextConfig.trailingSlash,\n                        serverRuntimeConfig: nextConfig.serverRuntimeConfig,\n                        subFolders: nextConfig.trailingSlash && !options.buildExport,\n                        buildExport: options.buildExport,\n                        optimizeCss: nextConfig.experimental.optimizeCss,\n                        disableOptimizedLoading: nextConfig.experimental.disableOptimizedLoading,\n                        parentSpanId: input.parentSpanId,\n                        httpAgentOptions: nextConfig.httpAgentOptions,\n                        debugOutput: options.debugOutput,\n                        enableExperimentalReact: needsExperimentalReact(nextConfig),\n                        sriEnabled: Boolean((_nextConfig_experimental_sri = nextConfig.experimental.sri) == null ? void 0 : _nextConfig_experimental_sri.algorithm),\n                        buildId: input.buildId\n                    }),\n                    // If exporting the page takes longer than the timeout, reject the promise.\n                    new Promise((_, reject)=>{\n                        setTimeout(()=>{\n                            reject(new TimeoutError());\n                        }, nextConfig.staticPageGenerationTimeout * 1000);\n                    })\n                ]);\n                // If there was an error in the export, throw it immediately. In the catch block, we might retry the export,\n                // or immediately fail the build, depending on user configuration. We might also continue on and attempt other pages.\n                if (result && 'error' in result) {\n                    throw new ExportPageError();\n                }\n                break;\n            } catch (err) {\n                // The only error that should be caught here is an ExportError, as `exportPage` doesn't throw and instead returns an object with an `error` property.\n                // This is an overly cautious check to ensure that we don't accidentally catch an unexpected error.\n                if (!(err instanceof ExportPageError || err instanceof TimeoutError)) {\n                    throw err;\n                }\n                if (err instanceof TimeoutError) {\n                    // If the export times out, we will restart the worker up to 3 times.\n                    maxAttempts = 3;\n                }\n                // We've reached the maximum number of attempts\n                if (attempt >= maxAttempts - 1) {\n                    // Log a message if we've reached the maximum number of attempts.\n                    // We only care to do this if maxAttempts was configured.\n                    if (maxAttempts > 1) {\n                        console.info(`Failed to build ${pageKey} after ${maxAttempts} attempts.`);\n                    }\n                    // If prerenderEarlyExit is enabled, we'll exit the build immediately.\n                    if (nextConfig.experimental.prerenderEarlyExit) {\n                        console.error(`Export encountered an error on ${pageKey}, exiting the build.`);\n                        process.exit(1);\n                    } else {\n                    // Otherwise, this is a no-op. The build will continue, and a summary of failed pages will be displayed at the end.\n                    }\n                } else {\n                    // Otherwise, we have more attempts to make. Wait before retrying\n                    if (err instanceof TimeoutError) {\n                        console.info(`Failed to build ${pageKey} (attempt ${attempt + 1} of ${maxAttempts}) because it took more than ${nextConfig.staticPageGenerationTimeout} seconds. Retrying again shortly.`);\n                    } else {\n                        console.info(`Failed to build ${pageKey} (attempt ${attempt + 1} of ${maxAttempts}). Retrying again shortly.`);\n                    }\n                    // Exponential backoff with random jitter to avoid thundering herd on retries\n                    const baseDelay = 500 // 500ms\n                    ;\n                    const maxDelay = 2000 // 2 seconds\n                    ;\n                    const delay = Math.min(baseDelay * Math.pow(2, attempt), maxDelay);\n                    const jitter = Math.random() * 0.3 * delay // Add up to 30% random jitter\n                    ;\n                    await new Promise((r)=>setTimeout(r, delay + jitter));\n                }\n            }\n            attempt++;\n        }\n        return {\n            result,\n            path,\n            pageKey\n        };\n    };\n    for(let i = 0; i < paths.length; i += maxConcurrency){\n        const subset = paths.slice(i, i + maxConcurrency);\n        const subsetResults = await Promise.all(subset.map((path)=>exportPageWithRetry(path, nextConfig.experimental.staticGenerationRetryCount ?? 1)));\n        results.push(...subsetResults);\n    }\n    return results;\n}\nasync function exportPage(input) {\n    trace('export-page', input.parentSpanId).setAttribute('path', input.path);\n    // Configure the http agent.\n    setHttpClientAndAgentOptions({\n        httpAgentOptions: input.httpAgentOptions\n    });\n    const fileWriter = new MultiFileWriter({\n        writeFile: (filePath, data)=>fs.writeFile(filePath, data),\n        mkdir: (dir)=>fs.mkdir(dir, {\n                recursive: true\n            })\n    });\n    const exportPageSpan = trace('export-page-worker', input.parentSpanId);\n    const start = Date.now();\n    const turborepoAccessTraceResult = new TurborepoAccessTraceResult();\n    // Export the page.\n    let result;\n    try {\n        result = await exportPageSpan.traceAsyncFn(()=>turborepoTraceAccess(()=>exportPageImpl(input, fileWriter), turborepoAccessTraceResult));\n        // Wait for all the files to flush to disk.\n        await fileWriter.wait();\n        // If there was no result, then we can exit early.\n        if (!result) return;\n        // If there was an error, then we can exit early.\n        if ('error' in result) {\n            return {\n                error: result.error,\n                duration: Date.now() - start\n            };\n        }\n    } catch (err) {\n        console.error(`Error occurred prerendering page \"${input.path}\". Read more: https://nextjs.org/docs/messages/prerender-error`);\n        // bailoutToCSRError errors should not leak to the user as they are not actionable; they're\n        // a framework signal\n        if (!isBailoutToCSRError(err)) {\n            // A static generation bailout error is a framework signal to fail static generation but\n            // and will encode a reason in the error message. If there is a message, we'll print it.\n            // Otherwise there's nothing to show as we don't want to leak an error internal error stack to the user.\n            if (isStaticGenBailoutError(err)) {\n                if (err.message) {\n                    console.error(`Error: ${err.message}`);\n                }\n            } else if (isError(err) && err.stack) {\n                console.error(err.stack);\n            } else {\n                console.error(err);\n            }\n        }\n        return {\n            error: true,\n            duration: Date.now() - start\n        };\n    }\n    // Notify the parent process that we processed a page (used by the progress activity indicator)\n    process.send == null ? void 0 : process.send.call(process, [\n        3,\n        {\n            type: 'activity'\n        }\n    ]);\n    // Otherwise we can return the result.\n    return {\n        duration: Date.now() - start,\n        ampValidations: result.ampValidations,\n        cacheControl: result.cacheControl,\n        metadata: result.metadata,\n        ssgNotFound: result.ssgNotFound,\n        hasEmptyPrelude: result.hasEmptyPrelude,\n        hasPostponed: result.hasPostponed,\n        turborepoAccessTraceResult: turborepoAccessTraceResult.serialize(),\n        fetchMetrics: result.fetchMetrics\n    };\n}\nprocess.on('unhandledRejection', (err)=>{\n    // if it's a postpone error, it'll be handled later\n    // when the postponed promise is actually awaited.\n    if (isPostpone(err)) {\n        return;\n    }\n    // we don't want to log these errors\n    if (isDynamicUsageError(err)) {\n        return;\n    }\n    console.error(err);\n});\nprocess.on('rejectionHandled', ()=>{\n// It is ok to await a Promise late in Next.js as it allows for better\n// prefetching patterns to avoid waterfalls. We ignore logging these.\n// We should've already errored in anyway unhandledRejection.\n});\nconst FATAL_UNHANDLED_NEXT_API_EXIT_CODE = 78;\nprocess.on('uncaughtException', (err)=>{\n    if (isDynamicUsageError(err)) {\n        console.error('A Next.js API that uses exceptions to signal framework behavior was uncaught. This suggests improper usage of a Next.js API. The original error is printed below and the build will now exit.');\n        console.error(err);\n        process.exit(FATAL_UNHANDLED_NEXT_API_EXIT_CODE);\n    } else {\n        console.error(err);\n    }\n});\n\n//# sourceMappingURL=worker.js.map"
        }
    ]
}