{
    "sourceFile": "node_modules/next/dist/esm/client/components/react-dev-overlay/server/middleware-webpack.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892768321,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import { constants as FS, promises as fs } from 'fs';\nimport { findSourceMap } from 'module';\nimport path from 'path';\nimport { fileURLToPath, pathToFileURL } from 'url';\nimport { SourceMapConsumer } from 'next/dist/compiled/source-map08';\nimport { getSourceMapFromFile } from '../utils/get-source-map-from-file';\nimport { launchEditor } from '../utils/launch-editor';\nimport { getOriginalCodeFrame } from './shared';\nimport { middlewareResponse } from './middleware-response';\nexport { getServerError } from '../utils/node-stack-frames';\nexport { parseStack } from '../utils/parse-stack';\nexport { getSourceMapFromFile };\nimport { formatFrameSourceFile } from '../utils/webpack-module-path';\nimport { inspect } from 'util';\nfunction shouldIgnoreSource(sourceURL) {\n    return sourceURL.includes('node_modules') || // Only relevant for when Next.js is symlinked e.g. in the Next.js monorepo\n    sourceURL.includes('next/dist') || sourceURL.startsWith('node:');\n}\nfunction getModuleById(id, compilation) {\n    const { chunkGraph, modules } = compilation;\n    return [\n        ...modules\n    ].find((module)=>chunkGraph.getModuleId(module) === id);\n}\nfunction findModuleNotFoundFromError(errorMessage) {\n    var _errorMessage_match;\n    return errorMessage == null ? void 0 : (_errorMessage_match = errorMessage.match(/'([^']+)' module/)) == null ? void 0 : _errorMessage_match[1];\n}\nfunction getSourcePath(source) {\n    if (source.startsWith('file://')) {\n        return fileURLToPath(source);\n    }\n    return source.replace(/^(webpack:\\/\\/\\/|webpack:\\/\\/|webpack:\\/\\/_N_E\\/)/, '');\n}\n/**\n * @returns 1-based lines and 0-based columns\n */ async function findOriginalSourcePositionAndContent(sourceMap, position) {\n    let consumer;\n    try {\n        consumer = await new SourceMapConsumer(sourceMap);\n    } catch (cause) {\n        throw Object.defineProperty(new Error(\"\" + sourceMap.file + \": Invalid source map. Only conformant source maps can be used to find the original code.\", {\n            cause\n        }), \"__NEXT_ERROR_CODE\", {\n            value: \"E635\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    try {\n        var _position_lineNumber, _position_column;\n        const sourcePosition = consumer.originalPositionFor({\n            line: (_position_lineNumber = position.lineNumber) != null ? _position_lineNumber : 1,\n            // 0-based columns out requires 0-based columns in.\n            column: ((_position_column = position.column) != null ? _position_column : 1) - 1\n        });\n        if (!sourcePosition.source) {\n            return null;\n        }\n        var _consumer_sourceContentFor;\n        const sourceContent = (_consumer_sourceContentFor = consumer.sourceContentFor(sourcePosition.source, /* returnNullOnMissing */ true)) != null ? _consumer_sourceContentFor : null;\n        return {\n            sourcePosition,\n            sourceContent\n        };\n    } finally{\n        consumer.destroy();\n    }\n}\nexport function getIgnoredSources(sourceMap) {\n    var _sourceMap_ignoreList;\n    const ignoreList = new Set((_sourceMap_ignoreList = sourceMap.ignoreList) != null ? _sourceMap_ignoreList : []);\n    var _sourceMap_sources;\n    const moduleFilenames = (_sourceMap_sources = sourceMap == null ? void 0 : sourceMap.sources) != null ? _sourceMap_sources : [];\n    for(let index = 0; index < moduleFilenames.length; index++){\n        // bundlerFilePath case: webpack://./app/page.tsx\n        const webpackSourceURL = moduleFilenames[index];\n        // Format the path to the normal file path\n        const formattedFilePath = formatFrameSourceFile(webpackSourceURL);\n        if (shouldIgnoreSource(formattedFilePath)) {\n            ignoreList.add(index);\n        }\n    }\n    const ignoredSources = sourceMap.sources.map((source, index)=>{\n        var _sourceMap_sourcesContent;\n        var _sourceMap_sourcesContent_index;\n        return {\n            url: source,\n            ignored: ignoreList.has(sourceMap.sources.indexOf(source)),\n            content: (_sourceMap_sourcesContent_index = (_sourceMap_sourcesContent = sourceMap.sourcesContent) == null ? void 0 : _sourceMap_sourcesContent[index]) != null ? _sourceMap_sourcesContent_index : null\n        };\n    });\n    return ignoredSources;\n}\nfunction isIgnoredSource(source, sourcePosition) {\n    if (sourcePosition.source == null) {\n        return true;\n    }\n    for (const ignoredSource of source.ignoredSources){\n        if (ignoredSource.ignored && ignoredSource.url === sourcePosition.source) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction findOriginalSourcePositionAndContentFromCompilation(moduleId, importedModule, compilation) {\n    var _module_buildInfo_importLocByPath, _module_buildInfo;\n    const module = getModuleById(moduleId, compilation);\n    var _module_buildInfo_importLocByPath_get;\n    return (_module_buildInfo_importLocByPath_get = module == null ? void 0 : (_module_buildInfo = module.buildInfo) == null ? void 0 : (_module_buildInfo_importLocByPath = _module_buildInfo.importLocByPath) == null ? void 0 : _module_buildInfo_importLocByPath.get(importedModule)) != null ? _module_buildInfo_importLocByPath_get : null;\n}\nexport async function createOriginalStackFrame(param) {\n    let { source, rootDirectory, frame, errorMessage } = param;\n    var // We ignore the sourcemapped name since it won't be the correct name.\n    // The callsite will point to the column of the variable name instead of the\n    // name of the enclosing function.\n    // TODO(NDX-531): Spy on prepareStackTrace to get the enclosing line number for method name mapping.\n    // default is not a valid identifier in JS so webpack uses a custom variable when it's an unnamed default export\n    // Resolve it back to `default` for the method name if the source position didn't have the method.\n    _frame_methodName_replace, _frame_methodName;\n    const moduleNotFound = findModuleNotFoundFromError(errorMessage);\n    const result = await (()=>{\n        if (moduleNotFound) {\n            if (source.type === 'file') {\n                return undefined;\n            }\n            return findOriginalSourcePositionAndContentFromCompilation(source.moduleId, moduleNotFound, source.compilation);\n        }\n        return findOriginalSourcePositionAndContent(source.sourceMap, frame);\n    })();\n    if (!result) {\n        return null;\n    }\n    const { sourcePosition, sourceContent } = result;\n    if (!sourcePosition.source) {\n        return null;\n    }\n    const ignored = isIgnoredSource(source, sourcePosition) || // If the source file is externals, should be excluded even it's not ignored source.\n    // e.g. webpack://next/dist/.. needs to be ignored\n    shouldIgnoreSource(source.moduleURL);\n    const sourcePath = getSourcePath(// When sourcePosition.source is the loader path the modulePath is generally better.\n    (sourcePosition.source.includes('|') ? source.moduleURL : sourcePosition.source) || source.moduleURL);\n    const filePath = path.resolve(rootDirectory, sourcePath);\n    const resolvedFilePath = path.relative(rootDirectory, filePath);\n    var _sourcePosition_column;\n    const traced = {\n        file: resolvedFilePath,\n        lineNumber: sourcePosition.line,\n        column: ((_sourcePosition_column = sourcePosition.column) != null ? _sourcePosition_column : 0) + 1,\n        methodName: (_frame_methodName = frame.methodName) == null ? void 0 : (_frame_methodName_replace = _frame_methodName.replace('__WEBPACK_DEFAULT_EXPORT__', 'default')) == null ? void 0 : _frame_methodName_replace.replace('__webpack_exports__.', ''),\n        arguments: [],\n        ignored\n    };\n    return {\n        originalStackFrame: traced,\n        originalCodeFrame: getOriginalCodeFrame(traced, sourceContent)\n    };\n}\nasync function getSourceMapFromCompilation(id, compilation) {\n    try {\n        const module = getModuleById(id, compilation);\n        if (!module) {\n            return undefined;\n        }\n        // @ts-expect-error The types for `CodeGenerationResults.get` require a\n        // runtime to be passed as second argument, but apparently it also works\n        // without it.\n        const codeGenerationResult = compilation.codeGenerationResults.get(module);\n        const source = codeGenerationResult == null ? void 0 : codeGenerationResult.sources.get('javascript');\n        var _source_map;\n        return (_source_map = source == null ? void 0 : source.map()) != null ? _source_map : undefined;\n    } catch (err) {\n        console.error('Failed to lookup module by ID (\"' + id + '\"):', err);\n        return undefined;\n    }\n}\nasync function getSource(sourceURL, options) {\n    const { getCompilations } = options;\n    // Rspack is now using file:// URLs for source maps. Remove the rsc prefix to produce the file:/// url.\n    sourceURL = sourceURL.replace(/(.*)\\/(?=file:\\/\\/)/, '');\n    let nativeSourceMap;\n    try {\n        nativeSourceMap = findSourceMap(sourceURL);\n    } catch (cause) {\n        throw Object.defineProperty(new Error(\"\" + sourceURL + \": Invalid source map. Only conformant source maps can be used to find the original code.\", {\n            cause\n        }), \"__NEXT_ERROR_CODE\", {\n            value: \"E635\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    if (nativeSourceMap !== undefined) {\n        const sourceMapPayload = nativeSourceMap.payload;\n        return {\n            type: 'file',\n            sourceMap: sourceMapPayload,\n            ignoredSources: getIgnoredSources(sourceMapPayload),\n            moduleURL: sourceURL\n        };\n    }\n    if (path.isAbsolute(sourceURL)) {\n        sourceURL = pathToFileURL(sourceURL).href;\n    }\n    if (sourceURL.startsWith('file:')) {\n        const sourceMap = await getSourceMapFromFile(sourceURL);\n        return sourceMap ? {\n            type: 'file',\n            sourceMap,\n            ignoredSources: getIgnoredSources(sourceMap),\n            moduleURL: sourceURL\n        } : undefined;\n    }\n    // webpack-internal:///./src/hello.tsx => ./src/hello.tsx\n    // rsc://React/Server/webpack-internal:///(rsc)/./src/hello.tsx?42 => (rsc)/./src/hello.tsx\n    // webpack://_N_E/./src/hello.tsx => ./src/hello.tsx\n    const moduleId = sourceURL.replace(/^(rsc:\\/\\/React\\/[^/]+\\/)?(webpack-internal:\\/\\/\\/|webpack:\\/\\/(_N_E\\/)?)/, '').replace(/\\?\\d+$/, '');\n    // (rsc)/./src/hello.tsx => ./src/hello.tsx\n    const moduleURL = moduleId.replace(/^(\\(.*\\)\\/?)/, '');\n    for (const compilation of getCompilations()){\n        const sourceMap = await getSourceMapFromCompilation(moduleId, compilation);\n        if (sourceMap) {\n            const ignoredSources = getIgnoredSources(sourceMap);\n            return {\n                type: 'bundle',\n                sourceMap,\n                compilation,\n                moduleId,\n                moduleURL,\n                ignoredSources\n            };\n        }\n    }\n    return undefined;\n}\nfunction getOriginalStackFrames(param) {\n    let { isServer, isEdgeServer, isAppDirectory, frames, clientStats, serverStats, edgeServerStats, rootDirectory } = param;\n    return Promise.all(frames.map((frame)=>getOriginalStackFrame({\n            isServer,\n            isEdgeServer,\n            isAppDirectory,\n            frame,\n            clientStats,\n            serverStats,\n            edgeServerStats,\n            rootDirectory\n        }).then((value)=>{\n            return {\n                status: 'fulfilled',\n                value\n            };\n        }, (reason)=>{\n            return {\n                status: 'rejected',\n                reason: inspect(reason, {\n                    colors: false\n                })\n            };\n        })));\n}\nasync function getOriginalStackFrame(param) {\n    let { isServer, isEdgeServer, isAppDirectory, frame, clientStats, serverStats, edgeServerStats, rootDirectory } = param;\n    var _frame_file;\n    const filename = (_frame_file = frame.file) != null ? _frame_file : '';\n    const source = await getSource(filename, {\n        getCompilations: ()=>{\n            const compilations = [];\n            // Try Client Compilation first. In `pages` we leverage\n            // `isClientError` to check. In `app` it depends on if it's a server\n            // / client component and when the code throws. E.g. during HTML\n            // rendering it's the server/edge compilation.\n            if (!isEdgeServer && !isServer || isAppDirectory) {\n                var _clientStats;\n                const compilation = (_clientStats = clientStats()) == null ? void 0 : _clientStats.compilation;\n                if (compilation) {\n                    compilations.push(compilation);\n                }\n            }\n            // Try Server Compilation. In `pages` this could be something\n            // imported in getServerSideProps/getStaticProps as the code for\n            // those is tree-shaken. In `app` this finds server components and\n            // code that was imported from a server component. It also covers\n            // when client component code throws during HTML rendering.\n            if (isServer || isAppDirectory) {\n                var _serverStats;\n                const compilation = (_serverStats = serverStats()) == null ? void 0 : _serverStats.compilation;\n                if (compilation) {\n                    compilations.push(compilation);\n                }\n            }\n            // Try Edge Server Compilation. Both cases are the same as Server\n            // Compilation, main difference is that it covers `runtime: 'edge'`\n            // pages/app routes.\n            if (isEdgeServer || isAppDirectory) {\n                var _edgeServerStats;\n                const compilation = (_edgeServerStats = edgeServerStats()) == null ? void 0 : _edgeServerStats.compilation;\n                if (compilation) {\n                    compilations.push(compilation);\n                }\n            }\n            return compilations;\n        }\n    });\n    let defaultNormalizedStackFrameLocation = frame.file;\n    if (defaultNormalizedStackFrameLocation !== null && defaultNormalizedStackFrameLocation.startsWith('file://')) {\n        defaultNormalizedStackFrameLocation = path.relative(rootDirectory, fileURLToPath(defaultNormalizedStackFrameLocation));\n    }\n    var _frame_column;\n    // This stack frame is used for the one that couldn't locate the source or source mapped frame\n    const defaultStackFrame = {\n        file: defaultNormalizedStackFrameLocation,\n        lineNumber: frame.lineNumber,\n        column: (_frame_column = frame.column) != null ? _frame_column : 1,\n        methodName: frame.methodName,\n        ignored: shouldIgnoreSource(filename),\n        arguments: []\n    };\n    if (!source) {\n        // return original stack frame with no source map\n        return {\n            originalStackFrame: defaultStackFrame,\n            originalCodeFrame: null\n        };\n    }\n    const originalStackFrameResponse = await createOriginalStackFrame({\n        frame,\n        source,\n        rootDirectory\n    });\n    if (!originalStackFrameResponse) {\n        return {\n            originalStackFrame: defaultStackFrame,\n            originalCodeFrame: null\n        };\n    }\n    return originalStackFrameResponse;\n}\nexport function getOverlayMiddleware(options) {\n    const { rootDirectory, clientStats, serverStats, edgeServerStats } = options;\n    return async function(req, res, next) {\n        const { pathname, searchParams } = new URL(\"http://n\" + req.url);\n        if (pathname === '/__nextjs_original-stack-frames') {\n            if (req.method !== 'POST') {\n                return middlewareResponse.badRequest(res);\n            }\n            const body = await new Promise((resolve, reject)=>{\n                let data = '';\n                req.on('data', (chunk)=>{\n                    data += chunk;\n                });\n                req.on('end', ()=>resolve(data));\n                req.on('error', reject);\n            });\n            try {\n                const { frames, isServer, isEdgeServer, isAppDirectory } = JSON.parse(body);\n                return middlewareResponse.json(res, await getOriginalStackFrames({\n                    isServer,\n                    isEdgeServer,\n                    isAppDirectory,\n                    frames: frames.map((frame)=>{\n                        var _frame_lineNumber, _frame_column;\n                        return {\n                            ...frame,\n                            lineNumber: (_frame_lineNumber = frame.lineNumber) != null ? _frame_lineNumber : 0,\n                            column: (_frame_column = frame.column) != null ? _frame_column : 0\n                        };\n                    }),\n                    clientStats,\n                    serverStats,\n                    edgeServerStats,\n                    rootDirectory\n                }));\n            } catch (err) {\n                return middlewareResponse.badRequest(res);\n            }\n        } else if (pathname === '/__nextjs_launch-editor') {\n            var _searchParams_get, _searchParams_get1;\n            const frame = {\n                file: searchParams.get('file'),\n                methodName: searchParams.get('methodName'),\n                lineNumber: parseInt((_searchParams_get = searchParams.get('lineNumber')) != null ? _searchParams_get : '0', 10) || 0,\n                column: parseInt((_searchParams_get1 = searchParams.get('column')) != null ? _searchParams_get1 : '0', 10) || 0,\n                arguments: searchParams.getAll('arguments').filter(Boolean)\n            };\n            if (!frame.file) return middlewareResponse.badRequest(res);\n            // frame files may start with their webpack layer, like (middleware)/middleware.js\n            const filePath = path.resolve(rootDirectory, frame.file.replace(/^\\([^)]+\\)\\//, ''));\n            const fileExists = await fs.access(filePath, FS.F_OK).then(()=>true, ()=>false);\n            if (!fileExists) return middlewareResponse.notFound(res);\n            try {\n                var _frame_column;\n                launchEditor(filePath, frame.lineNumber, (_frame_column = frame.column) != null ? _frame_column : 1);\n            } catch (err) {\n                console.log('Failed to launch editor:', err);\n                return middlewareResponse.internalServerError(res);\n            }\n            return middlewareResponse.noContent(res);\n        }\n        return next();\n    };\n}\nexport function getSourceMapMiddleware(options) {\n    const { clientStats, serverStats, edgeServerStats } = options;\n    return async function(req, res, next) {\n        const { pathname, searchParams } = new URL(\"http://n\" + req.url);\n        if (pathname !== '/__nextjs_source-map') {\n            return next();\n        }\n        const filename = searchParams.get('filename');\n        if (!filename) {\n            return middlewareResponse.badRequest(res);\n        }\n        let source;\n        try {\n            source = await getSource(filename, {\n                getCompilations: ()=>{\n                    const compilations = [];\n                    for (const stats of [\n                        clientStats(),\n                        serverStats(),\n                        edgeServerStats()\n                    ]){\n                        if (stats == null ? void 0 : stats.compilation) {\n                            compilations.push(stats.compilation);\n                        }\n                    }\n                    return compilations;\n                }\n            });\n        } catch (error) {\n            return middlewareResponse.internalServerError(res, error);\n        }\n        if (!source) {\n            return middlewareResponse.noContent(res);\n        }\n        return middlewareResponse.json(res, source.sourceMap);\n    };\n}\n\n//# sourceMappingURL=middleware-webpack.js.map"
        }
    ]
}