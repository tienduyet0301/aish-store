{
    "sourceFile": "node_modules/next/dist/esm/client/components/react-dev-overlay/ui/components/code-frame/parse-code-frame.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892769770,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import Anser from 'next/dist/compiled/anser';\nimport stripAnsi from 'next/dist/compiled/strip-ansi';\n// Strip leading spaces out of the code frame\nexport function formatCodeFrame(codeFrame) {\n    const lines = codeFrame.split(/\\r?\\n/g);\n    // Find the minimum length of leading spaces after `|` in the code frame\n    const miniLeadingSpacesLength = lines.map((line)=>/^>? +\\d+ +\\| [ ]+/.exec(stripAnsi(line)) === null ? null : /^>? +\\d+ +\\| ( *)/.exec(stripAnsi(line))).filter(Boolean).map((v)=>v.pop()).reduce((c, n)=>isNaN(c) ? n.length : Math.min(c, n.length), NaN);\n    // When the minimum length of leading spaces is greater than 1, remove them\n    // from the code frame to help the indentation looks better when there's a lot leading spaces.\n    if (miniLeadingSpacesLength > 1) {\n        return lines.map((line, a)=>~(a = line.indexOf('|')) ? line.substring(0, a) + line.substring(a).replace(\"^\\\\ {\" + miniLeadingSpacesLength + \"}\", '') : line).join('\\n');\n    }\n    return lines.join('\\n');\n}\nexport function groupCodeFrameLines(formattedFrame) {\n    // Map the decoded lines to a format that can be rendered\n    const decoded = Anser.ansiToJson(formattedFrame, {\n        json: true,\n        use_classes: true,\n        remove_empty: true\n    });\n    const lines = [];\n    let line = [];\n    for (const token of decoded){\n        if (token.content === '\\n') {\n            lines.push(line);\n            line = [];\n        } else {\n            line.push(token);\n        }\n    }\n    if (line.length > 0) {\n        lines.push(line);\n    }\n    return lines;\n}\nexport function parseLineNumberFromCodeFrameLine(line, stackFrame) {\n    var _line_, _line_1, _stackFrame_lineNumber;\n    let lineNumberToken;\n    let lineNumber;\n    // parse line number from line first 2 tokens\n    // e.g. ` > 1 | const foo = 'bar'` => `1`, first token is `1 |`\n    // e.g. `  2 | const foo = 'bar'` => `2`. first 2 tokens are ' ' and ' 2 |'\n    // console.log('line', line)\n    if (((_line_ = line[0]) == null ? void 0 : _line_.content) === '>' || ((_line_1 = line[0]) == null ? void 0 : _line_1.content) === ' ') {\n        var _lineNumberToken_content_replace, _lineNumberToken_content;\n        lineNumberToken = line[1];\n        lineNumber = lineNumberToken == null ? void 0 : (_lineNumberToken_content = lineNumberToken.content) == null ? void 0 : (_lineNumberToken_content_replace = _lineNumberToken_content.replace('|', '')) == null ? void 0 : _lineNumberToken_content_replace.trim();\n    }\n    // When the line number is possibly undefined, it can be just the non-source code line\n    // e.g. the ^ sign can also take a line, we skip rendering line number for it\n    return {\n        lineNumber,\n        isErroredLine: lineNumber === ((_stackFrame_lineNumber = stackFrame.lineNumber) == null ? void 0 : _stackFrame_lineNumber.toString())\n    };\n}\n\n//# sourceMappingURL=parse-code-frame.js.map"
        }
    ]
}