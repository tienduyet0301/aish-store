{
    "sourceFile": "node_modules/next/dist/esm/client/components/react-dev-overlay/app/hot-reloader-client.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892767368,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/// <reference types=\"webpack/module.d.ts\" />\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nimport { useCallback, useEffect, startTransition, useMemo, useRef } from 'react';\nimport stripAnsi from 'next/dist/compiled/strip-ansi';\nimport formatWebpackMessages from '../utils/format-webpack-messages';\nimport { useRouter } from '../../navigation';\nimport { ACTION_BEFORE_REFRESH, ACTION_BUILD_ERROR, ACTION_BUILD_OK, ACTION_DEBUG_INFO, ACTION_DEV_INDICATOR, ACTION_REFRESH, ACTION_STATIC_INDICATOR, ACTION_UNHANDLED_ERROR, ACTION_UNHANDLED_REJECTION, ACTION_VERSION_INFO, REACT_REFRESH_FULL_RELOAD, reportInvalidHmrMessage, useErrorOverlayReducer } from '../shared';\nimport { parseStack } from '../utils/parse-stack';\nimport { AppDevOverlay } from './app-dev-overlay';\nimport { useErrorHandler } from '../../errors/use-error-handler';\nimport { RuntimeErrorHandler } from '../../errors/runtime-error-handler';\nimport { useSendMessage, useTurbopack, useWebsocket, useWebsocketPing } from '../utils/use-websocket';\nimport { parseComponentStack } from '../utils/parse-component-stack';\nimport { HMR_ACTIONS_SENT_TO_BROWSER } from '../../../../server/dev/hot-reloader-types';\nimport { REACT_REFRESH_FULL_RELOAD_FROM_ERROR } from '../shared';\nimport { useUntrackedPathname } from '../../navigation-untracked';\nimport { getReactStitchedError } from '../../errors/stitched-error';\nimport { handleDevBuildIndicatorHmrEvents } from '../../../dev/dev-build-indicator/internal/handle-dev-build-indicator-hmr-events';\nimport reportHmrLatency from '../utils/report-hmr-latency';\nimport { TurbopackHmr } from '../utils/turbopack-hot-reloader-common';\nimport { NEXT_HMR_REFRESH_HASH_COOKIE } from '../../app-router-headers';\nlet mostRecentCompilationHash = null;\nlet __nextDevClientId = Math.round(Math.random() * 100 + Date.now());\nlet reloading = false;\nlet webpackStartMsSinceEpoch = null;\nconst turbopackHmr = process.env.TURBOPACK ? new TurbopackHmr() : null;\nlet pendingHotUpdateWebpack = Promise.resolve();\nlet resolvePendingHotUpdateWebpack = ()=>{};\nfunction setPendingHotUpdateWebpack() {\n    pendingHotUpdateWebpack = new Promise((resolve)=>{\n        resolvePendingHotUpdateWebpack = ()=>{\n            resolve();\n        };\n    });\n}\nexport function waitForWebpackRuntimeHotUpdate() {\n    return pendingHotUpdateWebpack;\n}\n// There is a newer version of the code available.\nfunction handleAvailableHash(hash) {\n    // Update last known compilation hash.\n    mostRecentCompilationHash = hash;\n}\n/**\n * Is there a newer version of this code available?\n * For webpack: Check if the hash changed compared to __webpack_hash__\n * For Turbopack: Always true because it doesn't have __webpack_hash__\n */ function isUpdateAvailable() {\n    if (process.env.TURBOPACK) {\n        return true;\n    }\n    /* globals __webpack_hash__ */ // __webpack_hash__ is the hash of the current compilation.\n    // It's a global variable injected by Webpack.\n    return mostRecentCompilationHash !== __webpack_hash__;\n}\n// Webpack disallows updates in other states.\nfunction canApplyUpdates() {\n    return module.hot.status() === 'idle';\n}\nfunction afterApplyUpdates(fn) {\n    if (canApplyUpdates()) {\n        fn();\n    } else {\n        function handler(status) {\n            if (status === 'idle') {\n                module.hot.removeStatusHandler(handler);\n                fn();\n            }\n        }\n        module.hot.addStatusHandler(handler);\n    }\n}\nfunction performFullReload(err, sendMessage) {\n    const stackTrace = err && (err.stack && err.stack.split('\\n').slice(0, 5).join('\\n') || err.message || err + '');\n    sendMessage(JSON.stringify({\n        event: 'client-full-reload',\n        stackTrace,\n        hadRuntimeError: !!RuntimeErrorHandler.hadRuntimeError,\n        dependencyChain: err ? err.dependencyChain : undefined\n    }));\n    if (reloading) return;\n    reloading = true;\n    window.location.reload();\n}\n// Attempt to update code on the fly, fall back to a hard reload.\nfunction tryApplyUpdatesWebpack(sendMessage, dispatcher) {\n    if (!isUpdateAvailable() || !canApplyUpdates()) {\n        resolvePendingHotUpdateWebpack();\n        dispatcher.onBuildOk();\n        reportHmrLatency(sendMessage, [], webpackStartMsSinceEpoch, Date.now());\n        return;\n    }\n    function handleApplyUpdates(err, updatedModules) {\n        if (err || RuntimeErrorHandler.hadRuntimeError || updatedModules == null) {\n            if (err) {\n                console.warn(REACT_REFRESH_FULL_RELOAD);\n            } else if (RuntimeErrorHandler.hadRuntimeError) {\n                console.warn(REACT_REFRESH_FULL_RELOAD_FROM_ERROR);\n            }\n            performFullReload(err, sendMessage);\n            return;\n        }\n        dispatcher.onBuildOk();\n        if (isUpdateAvailable()) {\n            // While we were updating, there was a new update! Do it again.\n            tryApplyUpdatesWebpack(sendMessage, dispatcher);\n            return;\n        }\n        dispatcher.onRefresh();\n        resolvePendingHotUpdateWebpack();\n        reportHmrLatency(sendMessage, updatedModules, webpackStartMsSinceEpoch, Date.now());\n        if (process.env.__NEXT_TEST_MODE) {\n            afterApplyUpdates(()=>{\n                if (self.__NEXT_HMR_CB) {\n                    self.__NEXT_HMR_CB();\n                    self.__NEXT_HMR_CB = null;\n                }\n            });\n        }\n    }\n    // https://webpack.js.org/api/hot-module-replacement/#check\n    module.hot.check(/* autoApply */ false).then((updatedModules)=>{\n        if (updatedModules == null) {\n            return null;\n        }\n        // We should always handle an update, even if updatedModules is empty (but\n        // non-null) for any reason. That's what webpack would normally do:\n        // https://github.com/webpack/webpack/blob/3aa6b6bc3a64/lib/hmr/HotModuleReplacement.runtime.js#L296-L298\n        dispatcher.onBeforeRefresh();\n        // https://webpack.js.org/api/hot-module-replacement/#apply\n        return module.hot.apply();\n    }).then((updatedModules)=>{\n        handleApplyUpdates(null, updatedModules);\n    }, (err)=>{\n        handleApplyUpdates(err, null);\n    });\n}\n/** Handles messages from the server for the App Router. */ function processMessage(obj, sendMessage, processTurbopackMessage, router, dispatcher, appIsrManifestRef, pathnameRef) {\n    if (!('action' in obj)) {\n        return;\n    }\n    function handleErrors(errors) {\n        // \"Massage\" webpack messages.\n        const formatted = formatWebpackMessages({\n            errors: errors,\n            warnings: []\n        });\n        // Only show the first error.\n        dispatcher.onBuildError(formatted.errors[0]);\n        // Also log them to the console.\n        for(let i = 0; i < formatted.errors.length; i++){\n            console.error(stripAnsi(formatted.errors[i]));\n        }\n        // Do not attempt to reload now.\n        // We will reload on next success instead.\n        if (process.env.__NEXT_TEST_MODE) {\n            if (self.__NEXT_HMR_CB) {\n                self.__NEXT_HMR_CB(formatted.errors[0]);\n                self.__NEXT_HMR_CB = null;\n            }\n        }\n    }\n    function handleHotUpdate() {\n        if (process.env.TURBOPACK) {\n            const hmrUpdate = turbopackHmr.onBuilt();\n            if (hmrUpdate != null) {\n                reportHmrLatency(sendMessage, [\n                    ...hmrUpdate.updatedModules\n                ], hmrUpdate.startMsSinceEpoch, hmrUpdate.endMsSinceEpoch, // suppress the `client-hmr-latency` event if the update was a no-op:\n                hmrUpdate.hasUpdates);\n            }\n            dispatcher.onBuildOk();\n        } else {\n            tryApplyUpdatesWebpack(sendMessage, dispatcher);\n        }\n    }\n    switch(obj.action){\n        case HMR_ACTIONS_SENT_TO_BROWSER.ISR_MANIFEST:\n            {\n                if (process.env.__NEXT_DEV_INDICATOR) {\n                    if (appIsrManifestRef) {\n                        appIsrManifestRef.current = obj.data;\n                        // handle initial status on receiving manifest\n                        // navigation is handled in useEffect for pathname changes\n                        // as we'll receive the updated manifest before usePathname\n                        // triggers for new value\n                        if (pathnameRef.current in obj.data) {\n                            dispatcher.onStaticIndicator(true);\n                        } else {\n                            dispatcher.onStaticIndicator(false);\n                        }\n                    }\n                }\n                break;\n            }\n        case HMR_ACTIONS_SENT_TO_BROWSER.BUILDING:\n            {\n                if (process.env.TURBOPACK) {\n                    turbopackHmr.onBuilding();\n                } else {\n                    webpackStartMsSinceEpoch = Date.now();\n                    setPendingHotUpdateWebpack();\n                    console.log('[Fast Refresh] rebuilding');\n                }\n                break;\n            }\n        case HMR_ACTIONS_SENT_TO_BROWSER.BUILT:\n        case HMR_ACTIONS_SENT_TO_BROWSER.SYNC:\n            {\n                if (obj.hash) {\n                    handleAvailableHash(obj.hash);\n                }\n                const { errors, warnings } = obj;\n                // Is undefined when it's a 'built' event\n                if ('versionInfo' in obj) dispatcher.onVersionInfo(obj.versionInfo);\n                if ('debug' in obj && obj.debug) dispatcher.onDebugInfo(obj.debug);\n                if ('devIndicator' in obj) dispatcher.onDevIndicator(obj.devIndicator);\n                const hasErrors = Boolean(errors && errors.length);\n                // Compilation with errors (e.g. syntax error or missing modules).\n                if (hasErrors) {\n                    sendMessage(JSON.stringify({\n                        event: 'client-error',\n                        errorCount: errors.length,\n                        clientId: __nextDevClientId\n                    }));\n                    handleErrors(errors);\n                    return;\n                }\n                const hasWarnings = Boolean(warnings && warnings.length);\n                if (hasWarnings) {\n                    sendMessage(JSON.stringify({\n                        event: 'client-warning',\n                        warningCount: warnings.length,\n                        clientId: __nextDevClientId\n                    }));\n                    // Print warnings to the console.\n                    const formattedMessages = formatWebpackMessages({\n                        warnings: warnings,\n                        errors: []\n                    });\n                    for(let i = 0; i < formattedMessages.warnings.length; i++){\n                        if (i === 5) {\n                            console.warn('There were more warnings in other files.\\n' + 'You can find a complete log in the terminal.');\n                            break;\n                        }\n                        console.warn(stripAnsi(formattedMessages.warnings[i]));\n                    }\n                // No early return here as we need to apply modules in the same way between warnings only and compiles without warnings\n                }\n                sendMessage(JSON.stringify({\n                    event: 'client-success',\n                    clientId: __nextDevClientId\n                }));\n                if (obj.action === HMR_ACTIONS_SENT_TO_BROWSER.BUILT) {\n                    handleHotUpdate();\n                }\n                return;\n            }\n        case HMR_ACTIONS_SENT_TO_BROWSER.TURBOPACK_CONNECTED:\n            {\n                processTurbopackMessage({\n                    type: HMR_ACTIONS_SENT_TO_BROWSER.TURBOPACK_CONNECTED,\n                    data: {\n                        sessionId: obj.data.sessionId\n                    }\n                });\n                break;\n            }\n        case HMR_ACTIONS_SENT_TO_BROWSER.TURBOPACK_MESSAGE:\n            {\n                turbopackHmr.onTurbopackMessage(obj);\n                dispatcher.onBeforeRefresh();\n                processTurbopackMessage({\n                    type: HMR_ACTIONS_SENT_TO_BROWSER.TURBOPACK_MESSAGE,\n                    data: obj.data\n                });\n                if (RuntimeErrorHandler.hadRuntimeError) {\n                    console.warn(REACT_REFRESH_FULL_RELOAD_FROM_ERROR);\n                    performFullReload(null, sendMessage);\n                }\n                dispatcher.onRefresh();\n                break;\n            }\n        // TODO-APP: make server component change more granular\n        case HMR_ACTIONS_SENT_TO_BROWSER.SERVER_COMPONENT_CHANGES:\n            {\n                turbopackHmr == null ? void 0 : turbopackHmr.onServerComponentChanges();\n                sendMessage(JSON.stringify({\n                    event: 'server-component-reload-page',\n                    clientId: __nextDevClientId,\n                    hash: obj.hash\n                }));\n                // Store the latest hash in a session cookie so that it's sent back to the\n                // server with any subsequent requests.\n                document.cookie = NEXT_HMR_REFRESH_HASH_COOKIE + \"=\" + obj.hash;\n                if (RuntimeErrorHandler.hadRuntimeError) {\n                    if (reloading) return;\n                    reloading = true;\n                    return window.location.reload();\n                }\n                startTransition(()=>{\n                    router.hmrRefresh();\n                    dispatcher.onRefresh();\n                });\n                if (process.env.__NEXT_TEST_MODE) {\n                    if (self.__NEXT_HMR_CB) {\n                        self.__NEXT_HMR_CB();\n                        self.__NEXT_HMR_CB = null;\n                    }\n                }\n                return;\n            }\n        case HMR_ACTIONS_SENT_TO_BROWSER.RELOAD_PAGE:\n            {\n                turbopackHmr == null ? void 0 : turbopackHmr.onReloadPage();\n                sendMessage(JSON.stringify({\n                    event: 'client-reload-page',\n                    clientId: __nextDevClientId\n                }));\n                if (reloading) return;\n                reloading = true;\n                return window.location.reload();\n            }\n        case HMR_ACTIONS_SENT_TO_BROWSER.ADDED_PAGE:\n        case HMR_ACTIONS_SENT_TO_BROWSER.REMOVED_PAGE:\n            {\n                turbopackHmr == null ? void 0 : turbopackHmr.onPageAddRemove();\n                // TODO-APP: potentially only refresh if the currently viewed page was added/removed.\n                return router.hmrRefresh();\n            }\n        case HMR_ACTIONS_SENT_TO_BROWSER.SERVER_ERROR:\n            {\n                const { errorJSON } = obj;\n                if (errorJSON) {\n                    const { message, stack } = JSON.parse(errorJSON);\n                    const error = Object.defineProperty(new Error(message), \"__NEXT_ERROR_CODE\", {\n                        value: \"E394\",\n                        enumerable: false,\n                        configurable: true\n                    });\n                    error.stack = stack;\n                    handleErrors([\n                        error\n                    ]);\n                }\n                return;\n            }\n        case HMR_ACTIONS_SENT_TO_BROWSER.DEV_PAGES_MANIFEST_UPDATE:\n            {\n                return;\n            }\n        default:\n            {}\n    }\n}\nexport default function HotReload(param) {\n    let { assetPrefix, children, globalError } = param;\n    const [state, dispatch] = useErrorOverlayReducer('app');\n    const dispatcher = useMemo(()=>{\n        return {\n            onBuildOk () {\n                dispatch({\n                    type: ACTION_BUILD_OK\n                });\n            },\n            onBuildError (message) {\n                dispatch({\n                    type: ACTION_BUILD_ERROR,\n                    message\n                });\n            },\n            onBeforeRefresh () {\n                dispatch({\n                    type: ACTION_BEFORE_REFRESH\n                });\n            },\n            onRefresh () {\n                dispatch({\n                    type: ACTION_REFRESH\n                });\n            },\n            onVersionInfo (versionInfo) {\n                dispatch({\n                    type: ACTION_VERSION_INFO,\n                    versionInfo\n                });\n            },\n            onStaticIndicator (status) {\n                dispatch({\n                    type: ACTION_STATIC_INDICATOR,\n                    staticIndicator: status\n                });\n            },\n            onDebugInfo (debugInfo) {\n                dispatch({\n                    type: ACTION_DEBUG_INFO,\n                    debugInfo\n                });\n            },\n            onDevIndicator (devIndicator) {\n                dispatch({\n                    type: ACTION_DEV_INDICATOR,\n                    devIndicator\n                });\n            }\n        };\n    }, [\n        dispatch\n    ]);\n    const handleOnUnhandledError = useCallback((error)=>{\n        // Component stack is added to the error in use-error-handler in case there was a hydration error\n        const componentStackTrace = error._componentStack;\n        dispatch({\n            type: ACTION_UNHANDLED_ERROR,\n            reason: error,\n            frames: parseStack(error.stack || ''),\n            componentStackFrames: typeof componentStackTrace === 'string' ? parseComponentStack(componentStackTrace) : undefined\n        });\n    }, [\n        dispatch\n    ]);\n    const handleOnUnhandledRejection = useCallback((reason)=>{\n        const stitchedError = getReactStitchedError(reason);\n        dispatch({\n            type: ACTION_UNHANDLED_REJECTION,\n            reason: stitchedError,\n            frames: parseStack(stitchedError.stack || '')\n        });\n    }, [\n        dispatch\n    ]);\n    useErrorHandler(handleOnUnhandledError, handleOnUnhandledRejection);\n    const webSocketRef = useWebsocket(assetPrefix);\n    useWebsocketPing(webSocketRef);\n    const sendMessage = useSendMessage(webSocketRef);\n    const processTurbopackMessage = useTurbopack(sendMessage, (err)=>performFullReload(err, sendMessage));\n    const router = useRouter();\n    // We don't want access of the pathname for the dev tools to trigger a dynamic\n    // access (as the dev overlay will never be present in production).\n    const pathname = useUntrackedPathname();\n    const appIsrManifestRef = useRef({});\n    const pathnameRef = useRef(pathname);\n    if (process.env.__NEXT_DEV_INDICATOR) {\n        // this conditional is only for dead-code elimination which\n        // isn't a runtime conditional only build-time so ignore hooks rule\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        useEffect(()=>{\n            pathnameRef.current = pathname;\n            const appIsrManifest = appIsrManifestRef.current;\n            if (appIsrManifest) {\n                if (pathname && pathname in appIsrManifest) {\n                    try {\n                        dispatcher.onStaticIndicator(true);\n                    } catch (reason) {\n                        let message = '';\n                        if (reason instanceof DOMException) {\n                            var _reason_stack;\n                            // Most likely a SecurityError, because of an unavailable localStorage\n                            message = (_reason_stack = reason.stack) != null ? _reason_stack : reason.message;\n                        } else if (reason instanceof Error) {\n                            var _reason_stack1;\n                            message = 'Error: ' + reason.message + '\\n' + ((_reason_stack1 = reason.stack) != null ? _reason_stack1 : '');\n                        } else {\n                            message = 'Unexpected Exception: ' + reason;\n                        }\n                        console.warn('[HMR] ' + message);\n                    }\n                } else {\n                    dispatcher.onStaticIndicator(false);\n                }\n            }\n        }, [\n            pathname,\n            dispatcher\n        ]);\n    }\n    useEffect(()=>{\n        const websocket = webSocketRef.current;\n        if (!websocket) return;\n        const handler = (event)=>{\n            try {\n                const obj = JSON.parse(event.data);\n                handleDevBuildIndicatorHmrEvents(obj);\n                processMessage(obj, sendMessage, processTurbopackMessage, router, dispatcher, appIsrManifestRef, pathnameRef);\n            } catch (err) {\n                reportInvalidHmrMessage(event, err);\n            }\n        };\n        websocket.addEventListener('message', handler);\n        return ()=>websocket.removeEventListener('message', handler);\n    }, [\n        sendMessage,\n        router,\n        webSocketRef,\n        dispatcher,\n        processTurbopackMessage,\n        appIsrManifestRef\n    ]);\n    return /*#__PURE__*/ _jsx(AppDevOverlay, {\n        state: state,\n        globalError: globalError,\n        children: children\n    });\n}\n\n//# sourceMappingURL=hot-reloader-client.js.map"
        }
    ]
}