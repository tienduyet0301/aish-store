{
    "sourceFile": "node_modules/next/dist/esm/client/components/react-dev-overlay/ui/components/errors/dev-tools-indicator/utils.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892772945,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import { useEffect } from 'react';\nexport function useFocusTrap(rootRef, triggerRef, active, onOpenFocus) {\n    useEffect(()=>{\n        let rootNode = null;\n        function onTab(e) {\n            if (e.key !== 'Tab' || rootNode === null) {\n                return;\n            }\n            const [firstFocusableNode, lastFocusableNode] = getFocusableNodes(rootNode);\n            const activeElement = getActiveElement(rootNode);\n            if (e.shiftKey) {\n                if (activeElement === firstFocusableNode) {\n                    lastFocusableNode == null ? void 0 : lastFocusableNode.focus();\n                    e.preventDefault();\n                }\n            } else {\n                if (activeElement === lastFocusableNode) {\n                    firstFocusableNode == null ? void 0 : firstFocusableNode.focus();\n                    e.preventDefault();\n                }\n            }\n        }\n        const id = setTimeout(()=>{\n            // Grab this on next tick to ensure the content is mounted\n            rootNode = rootRef.current;\n            if (active) {\n                if (onOpenFocus) {\n                    onOpenFocus();\n                } else {\n                    rootNode == null ? void 0 : rootNode.focus();\n                }\n                rootNode == null ? void 0 : rootNode.addEventListener('keydown', onTab);\n            } else {\n                const activeElement = getActiveElement(rootNode);\n                // Only restore focus if the focus was previously on the content.\n                // This avoids us accidentally focusing on mount when the\n                // user could want to interact with their own app instead.\n                if (triggerRef && (rootNode == null ? void 0 : rootNode.contains(activeElement))) {\n                    var _triggerRef_current;\n                    (_triggerRef_current = triggerRef.current) == null ? void 0 : _triggerRef_current.focus();\n                }\n            }\n        });\n        return ()=>{\n            clearTimeout(id);\n            rootNode == null ? void 0 : rootNode.removeEventListener('keydown', onTab);\n        };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [\n        active\n    ]);\n}\nfunction getActiveElement(node) {\n    const root = node == null ? void 0 : node.getRootNode();\n    return root instanceof ShadowRoot ? root == null ? void 0 : root.activeElement : null;\n}\nfunction getFocusableNodes(node) {\n    const focusableElements = node.querySelectorAll('button, [href], input, select, textarea, [tabindex]:not([tabindex=\"-1\"])');\n    if (!focusableElements) return [];\n    return [\n        focusableElements[0],\n        focusableElements[focusableElements.length - 1]\n    ];\n}\n//////////////////////////////////////////////////////////////////////////////////////\nexport function useClickOutside(rootRef, triggerRef, active, close) {\n    useEffect(()=>{\n        if (!active) {\n            return;\n        }\n        function handleClickOutside(event) {\n            var _rootRef_current, _triggerRef_current;\n            if (!(((_rootRef_current = rootRef.current) == null ? void 0 : _rootRef_current.getBoundingClientRect()) ? event.clientX >= rootRef.current.getBoundingClientRect().left && event.clientX <= rootRef.current.getBoundingClientRect().right && event.clientY >= rootRef.current.getBoundingClientRect().top && event.clientY <= rootRef.current.getBoundingClientRect().bottom : false) && !(((_triggerRef_current = triggerRef.current) == null ? void 0 : _triggerRef_current.getBoundingClientRect()) ? event.clientX >= triggerRef.current.getBoundingClientRect().left && event.clientX <= triggerRef.current.getBoundingClientRect().right && event.clientY >= triggerRef.current.getBoundingClientRect().top && event.clientY <= triggerRef.current.getBoundingClientRect().bottom : false)) {\n                close();\n            }\n        }\n        function handleKeyDown(event) {\n            if (event.key === 'Escape') {\n                close();\n            }\n        }\n        document.addEventListener('mousedown', handleClickOutside);\n        document.addEventListener('keydown', handleKeyDown);\n        return ()=>{\n            document.removeEventListener('mousedown', handleClickOutside);\n            document.removeEventListener('keydown', handleKeyDown);\n        };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [\n        active\n    ]);\n}\n//////////////////////////////////////////////////////////////////////////////////////\nexport const MENU_DURATION_MS = 200;\nexport const MENU_CURVE = 'cubic-bezier(0.175, 0.885, 0.32, 1.1)';\n\n//# sourceMappingURL=utils.js.map"
        }
    ]
}