{
    "sourceFile": "node_modules/next/dist/esm/client/components/react-dev-overlay/utils/turbopack-hot-reloader-common.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892779005,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import { _ as _class_private_field_loose_base } from \"@swc/helpers/_/_class_private_field_loose_base\";\nimport { _ as _class_private_field_loose_key } from \"@swc/helpers/_/_class_private_field_loose_key\";\n// How long to wait before reporting the HMR start, used to suppress irrelevant\n// `BUILDING` events. Does not impact reported latency.\nconst TURBOPACK_HMR_START_DELAY_MS = 100;\nvar _updatedModules = /*#__PURE__*/ _class_private_field_loose_key(\"_updatedModules\"), _startMsSinceEpoch = /*#__PURE__*/ _class_private_field_loose_key(\"_startMsSinceEpoch\"), _lastUpdateMsSinceEpoch = /*#__PURE__*/ _class_private_field_loose_key(\"_lastUpdateMsSinceEpoch\"), _deferredReportHmrStartId = /*#__PURE__*/ _class_private_field_loose_key(\"_deferredReportHmrStartId\"), // HACK: Turbopack tends to generate a lot of irrelevant \"BUILDING\" actions,\n// as it reports *any* compilation, including fully no-op/cached compilations\n// and those unrelated to HMR. Fixing this would require significant\n// architectural changes.\n//\n// Work around this by deferring any \"rebuilding\" message by 100ms. If we get\n// a BUILT event within that threshold and nothing has changed, just suppress\n// the message entirely.\n_runDeferredReportHmrStart = /*#__PURE__*/ _class_private_field_loose_key(\"_runDeferredReportHmrStart\"), _cancelDeferredReportHmrStart = /*#__PURE__*/ _class_private_field_loose_key(\"_cancelDeferredReportHmrStart\"), /** Helper for other `onEvent` methods. */ _onUpdate = /*#__PURE__*/ _class_private_field_loose_key(\"_onUpdate\");\nexport class TurbopackHmr {\n    onBuilding() {\n        _class_private_field_loose_base(this, _lastUpdateMsSinceEpoch)[_lastUpdateMsSinceEpoch] = undefined;\n        _class_private_field_loose_base(this, _cancelDeferredReportHmrStart)[_cancelDeferredReportHmrStart]();\n        _class_private_field_loose_base(this, _startMsSinceEpoch)[_startMsSinceEpoch] = Date.now();\n        // report the HMR start after a short delay\n        _class_private_field_loose_base(this, _deferredReportHmrStartId)[_deferredReportHmrStartId] = setTimeout(()=>_class_private_field_loose_base(this, _runDeferredReportHmrStart)[_runDeferredReportHmrStart](), // debugging feature: don't defer/suppress noisy no-op HMR update messages\n        self.__NEXT_HMR_TURBOPACK_REPORT_NOISY_NOOP_EVENTS ? 0 : TURBOPACK_HMR_START_DELAY_MS);\n    }\n    onTurbopackMessage(msg) {\n        _class_private_field_loose_base(this, _onUpdate)[_onUpdate]();\n        const updatedModules = extractModulesFromTurbopackMessage(msg.data);\n        for (const module of updatedModules){\n            _class_private_field_loose_base(this, _updatedModules)[_updatedModules].add(module);\n        }\n    }\n    onServerComponentChanges() {\n        _class_private_field_loose_base(this, _onUpdate)[_onUpdate]();\n    }\n    onReloadPage() {\n        _class_private_field_loose_base(this, _onUpdate)[_onUpdate]();\n    }\n    onPageAddRemove() {\n        _class_private_field_loose_base(this, _onUpdate)[_onUpdate]();\n    }\n    /**\n   * @returns `null` if the caller should ignore the update entirely. Returns an\n   *   object with `hasUpdates: false` if the caller should report the end of\n   *   the HMR in the browser console, but the HMR was a no-op.\n   */ onBuilt() {\n        // Check that we got *any* `TurbopackMessageAction`, even if\n        // `updatedModules` is empty (not everything gets recorded there).\n        //\n        // There's also a case where `onBuilt` gets called before `onBuilding`,\n        // which can happen during initial page load. Ignore that too!\n        const hasUpdates = _class_private_field_loose_base(this, _lastUpdateMsSinceEpoch)[_lastUpdateMsSinceEpoch] != null && _class_private_field_loose_base(this, _startMsSinceEpoch)[_startMsSinceEpoch] != null;\n        if (!hasUpdates && _class_private_field_loose_base(this, _deferredReportHmrStartId)[_deferredReportHmrStartId] != null) {\n            // suppress the update entirely\n            _class_private_field_loose_base(this, _cancelDeferredReportHmrStart)[_cancelDeferredReportHmrStart]();\n            return null;\n        }\n        _class_private_field_loose_base(this, _runDeferredReportHmrStart)[_runDeferredReportHmrStart]();\n        var _class_private_field_loose_base__lastUpdateMsSinceEpoch;\n        const result = {\n            hasUpdates,\n            updatedModules: _class_private_field_loose_base(this, _updatedModules)[_updatedModules],\n            startMsSinceEpoch: _class_private_field_loose_base(this, _startMsSinceEpoch)[_startMsSinceEpoch],\n            endMsSinceEpoch: (_class_private_field_loose_base__lastUpdateMsSinceEpoch = _class_private_field_loose_base(this, _lastUpdateMsSinceEpoch)[_lastUpdateMsSinceEpoch]) != null ? _class_private_field_loose_base__lastUpdateMsSinceEpoch : Date.now()\n        };\n        _class_private_field_loose_base(this, _updatedModules)[_updatedModules] = new Set();\n        return result;\n    }\n    constructor(){\n        Object.defineProperty(this, _runDeferredReportHmrStart, {\n            value: runDeferredReportHmrStart\n        });\n        Object.defineProperty(this, _cancelDeferredReportHmrStart, {\n            value: cancelDeferredReportHmrStart\n        });\n        Object.defineProperty(this, _onUpdate, {\n            value: onUpdate\n        });\n        Object.defineProperty(this, _updatedModules, {\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, _startMsSinceEpoch, {\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, _lastUpdateMsSinceEpoch, {\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, _deferredReportHmrStartId, {\n            writable: true,\n            value: void 0\n        });\n        _class_private_field_loose_base(this, _updatedModules)[_updatedModules] = new Set();\n    }\n}\nfunction runDeferredReportHmrStart() {\n    if (_class_private_field_loose_base(this, _deferredReportHmrStartId)[_deferredReportHmrStartId] != null) {\n        console.log('[Fast Refresh] rebuilding');\n        _class_private_field_loose_base(this, _cancelDeferredReportHmrStart)[_cancelDeferredReportHmrStart]();\n    }\n}\nfunction cancelDeferredReportHmrStart() {\n    clearTimeout(_class_private_field_loose_base(this, _deferredReportHmrStartId)[_deferredReportHmrStartId]);\n    _class_private_field_loose_base(this, _deferredReportHmrStartId)[_deferredReportHmrStartId] = undefined;\n}\nfunction onUpdate() {\n    _class_private_field_loose_base(this, _runDeferredReportHmrStart)[_runDeferredReportHmrStart]();\n    _class_private_field_loose_base(this, _lastUpdateMsSinceEpoch)[_lastUpdateMsSinceEpoch] = Date.now();\n}\nfunction extractModulesFromTurbopackMessage(data) {\n    const updatedModules = new Set();\n    const updates = Array.isArray(data) ? data : [\n        data\n    ];\n    for (const update of updates){\n        // TODO this won't capture changes to CSS since they don't result in a \"merged\" update\n        if (update.type !== 'partial' || update.instruction.type !== 'ChunkListUpdate' || update.instruction.merged === undefined) {\n            continue;\n        }\n        for (const mergedUpdate of update.instruction.merged){\n            for (const name of Object.keys(mergedUpdate.entries)){\n                const res = /(.*)\\s+\\[.*/.exec(name);\n                if (res === null) {\n                    console.error('[Turbopack HMR] Expected module to match pattern: ' + name);\n                    continue;\n                }\n                updatedModules.add(res[1]);\n            }\n        }\n    }\n    return updatedModules;\n}\n\n//# sourceMappingURL=turbopack-hot-reloader-common.js.map"
        }
    ]
}