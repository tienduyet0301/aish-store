{
    "sourceFile": "node_modules/next/dist/esm/client/components/react-dev-overlay/server/middleware-turbopack.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892768228,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import { getOriginalCodeFrame } from './shared';\nimport { middlewareResponse } from './middleware-response';\nimport fs, { constants as FS } from 'fs/promises';\nimport path from 'path';\nimport url from 'url';\nimport { launchEditor } from '../utils/launch-editor';\nimport { SourceMapConsumer } from 'next/dist/compiled/source-map08';\nimport { getSourceMapFromFile } from '../utils/get-source-map-from-file';\nimport { findSourceMap } from 'node:module';\nimport { pathToFileURL } from 'node:url';\nimport { inspect } from 'node:util';\nfunction shouldIgnorePath(modulePath) {\n    return modulePath.includes('node_modules') || // Only relevant for when Next.js is symlinked e.g. in the Next.js monorepo\n    modulePath.includes('next/dist') || modulePath.startsWith('node:');\n}\nconst currentSourcesByFile = new Map();\nasync function batchedTraceSource(project, frame) {\n    const file = frame.file ? decodeURIComponent(frame.file) : undefined;\n    if (!file) return;\n    // For node internals they cannot traced the actual source code with project.traceSource,\n    // we need an early return to indicate it's ignored to avoid the unknown scheme error from `project.traceSource`.\n    if (file.startsWith('node:')) {\n        var _frame_line, _frame_column, _frame_methodName;\n        return {\n            frame: {\n                file,\n                lineNumber: (_frame_line = frame.line) != null ? _frame_line : 0,\n                column: (_frame_column = frame.column) != null ? _frame_column : 0,\n                methodName: (_frame_methodName = frame.methodName) != null ? _frame_methodName : '<unknown>',\n                ignored: true,\n                arguments: []\n            },\n            source: null\n        };\n    }\n    const currentDirectoryFileUrl = pathToFileURL(process.cwd()).href;\n    const sourceFrame = await project.traceSource(frame, currentDirectoryFileUrl);\n    if (!sourceFrame) {\n        var _frame_line1, _frame_column1, _frame_methodName1;\n        return {\n            frame: {\n                file,\n                lineNumber: (_frame_line1 = frame.line) != null ? _frame_line1 : 0,\n                column: (_frame_column1 = frame.column) != null ? _frame_column1 : 0,\n                methodName: (_frame_methodName1 = frame.methodName) != null ? _frame_methodName1 : '<unknown>',\n                ignored: shouldIgnorePath(file),\n                arguments: []\n            },\n            source: null\n        };\n    }\n    let source = null;\n    const originalFile = sourceFrame.originalFile;\n    // Don't look up source for node_modules or internals. These can often be large bundled files.\n    const ignored = shouldIgnorePath(originalFile != null ? originalFile : sourceFrame.file) || // isInternal means resource starts with turbopack:///[turbopack]\n    !!sourceFrame.isInternal;\n    if (originalFile && !ignored) {\n        let sourcePromise = currentSourcesByFile.get(originalFile);\n        if (!sourcePromise) {\n            sourcePromise = project.getSourceForAsset(originalFile);\n            currentSourcesByFile.set(originalFile, sourcePromise);\n            setTimeout(()=>{\n                // Cache file reads for 100ms, as frames will often reference the same\n                // files and can be large.\n                currentSourcesByFile.delete(originalFile);\n            }, 100);\n        }\n        source = await sourcePromise;\n    }\n    var _sourceFrame_line, _sourceFrame_column, // We ignore the sourcemapped name since it won't be the correct name.\n    // The callsite will point to the column of the variable name instead of the\n    // name of the enclosing function.\n    // TODO(NDX-531): Spy on prepareStackTrace to get the enclosing line number for method name mapping.\n    _frame_methodName2;\n    // TODO: get ignoredList from turbopack source map\n    const ignorableFrame = {\n        file: sourceFrame.file,\n        lineNumber: (_sourceFrame_line = sourceFrame.line) != null ? _sourceFrame_line : 0,\n        column: (_sourceFrame_column = sourceFrame.column) != null ? _sourceFrame_column : 0,\n        methodName: (_frame_methodName2 = frame.methodName) != null ? _frame_methodName2 : '<unknown>',\n        ignored,\n        arguments: []\n    };\n    return {\n        frame: ignorableFrame,\n        source\n    };\n}\nfunction parseFile(fileParam) {\n    if (!fileParam) {\n        return undefined;\n    }\n    // rsc://React/Server/file://<filename>?42 => file://<filename>\n    return fileParam.replace(/^rsc:\\/\\/React\\/[^/]+\\//, '').replace(/\\?\\d+$/, '');\n}\nfunction createStackFrames(body) {\n    const { frames, isServer } = body;\n    return frames.map((frame)=>{\n        const file = parseFile(frame.file);\n        if (!file) {\n            return undefined;\n        }\n        var _frame_methodName, _frame_lineNumber, _frame_column;\n        return {\n            file,\n            methodName: (_frame_methodName = frame.methodName) != null ? _frame_methodName : '<unknown>',\n            line: (_frame_lineNumber = frame.lineNumber) != null ? _frame_lineNumber : 0,\n            column: (_frame_column = frame.column) != null ? _frame_column : 0,\n            isServer\n        };\n    }).filter((f)=>f !== undefined);\n}\nfunction createStackFrame(searchParams) {\n    const file = parseFile(searchParams.get('file'));\n    if (!file) {\n        return undefined;\n    }\n    var _searchParams_get, _searchParams_get1, _searchParams_get2;\n    return {\n        file,\n        methodName: (_searchParams_get = searchParams.get('methodName')) != null ? _searchParams_get : '<unknown>',\n        line: parseInt((_searchParams_get1 = searchParams.get('lineNumber')) != null ? _searchParams_get1 : '0', 10) || 0,\n        column: parseInt((_searchParams_get2 = searchParams.get('column')) != null ? _searchParams_get2 : '0', 10) || 0,\n        isServer: searchParams.get('isServer') === 'true'\n    };\n}\n/**\n * Finds the sourcemap payload applicable to a given frame.\n * Equal to the input unless an Index Source Map is used.\n */ function findApplicableSourceMapPayload(frame, payload) {\n    if ('sections' in payload) {\n        var _frame_line;\n        const frameLine = (_frame_line = frame.line) != null ? _frame_line : 0;\n        var _frame_column;\n        const frameColumn = (_frame_column = frame.column) != null ? _frame_column : 0;\n        // Sections must not overlap and must be sorted: https://tc39.es/source-map/#section-object\n        // Therefore the last section that has an offset less than or equal to the frame is the applicable one.\n        // TODO(veil): Binary search\n        let section = payload.sections[0];\n        for(let i = 0; i < payload.sections.length && payload.sections[i].offset.line <= frameLine && payload.sections[i].offset.column <= frameColumn; i++){\n            section = payload.sections[i];\n        }\n        return section === undefined ? undefined : section.map;\n    } else {\n        return payload;\n    }\n}\n/**\n * @returns 1-based lines and 0-based columns\n */ async function nativeTraceSource(frame) {\n    const sourceURL = decodeURIComponent(frame.file);\n    let sourceMapPayload;\n    try {\n        var _findSourceMap;\n        sourceMapPayload = (_findSourceMap = findSourceMap(sourceURL)) == null ? void 0 : _findSourceMap.payload;\n    } catch (cause) {\n        throw Object.defineProperty(new Error(\"\" + sourceURL + \": Invalid source map. Only conformant source maps can be used to find the original code.\", {\n            cause\n        }), \"__NEXT_ERROR_CODE\", {\n            value: \"E635\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    if (sourceMapPayload !== undefined) {\n        let consumer;\n        try {\n            consumer = await new SourceMapConsumer(sourceMapPayload);\n        } catch (cause) {\n            throw Object.defineProperty(new Error(\"\" + sourceURL + \": Invalid source map. Only conformant source maps can be used to find the original code.\", {\n                cause\n            }), \"__NEXT_ERROR_CODE\", {\n                value: \"E635\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n        let traced;\n        try {\n            var _frame_line, _frame_column;\n            const originalPosition = consumer.originalPositionFor({\n                line: (_frame_line = frame.line) != null ? _frame_line : 1,\n                // 0-based columns out requires 0-based columns in.\n                column: ((_frame_column = frame.column) != null ? _frame_column : 1) - 1\n            });\n            if (originalPosition.source === null) {\n                traced = null;\n            } else {\n                var _consumer_sourceContentFor;\n                const sourceContent = (_consumer_sourceContentFor = consumer.sourceContentFor(originalPosition.source, /* returnNullOnMissing */ true)) != null ? _consumer_sourceContentFor : null;\n                traced = {\n                    originalPosition,\n                    sourceContent\n                };\n            }\n        } finally{\n            consumer.destroy();\n        }\n        if (traced !== null) {\n            var // We ignore the sourcemapped name since it won't be the correct name.\n            // The callsite will point to the column of the variable name instead of the\n            // name of the enclosing function.\n            // TODO(NDX-531): Spy on prepareStackTrace to get the enclosing line number for method name mapping.\n            _frame_methodName_replace, _frame_methodName;\n            const { originalPosition, sourceContent } = traced;\n            const applicableSourceMap = findApplicableSourceMapPayload(frame, sourceMapPayload);\n            // TODO(veil): Upstream a method to sourcemap consumer that immediately says if a frame is ignored or not.\n            let ignored = false;\n            if (applicableSourceMap === undefined) {\n                console.error('No applicable source map found in sections for frame', frame);\n            } else {\n                var _applicableSourceMap_ignoreList;\n                // TODO: O(n^2). Consider moving `ignoreList` into a Set\n                const sourceIndex = applicableSourceMap.sources.indexOf(originalPosition.source);\n                var _applicableSourceMap_ignoreList_includes;\n                ignored = (_applicableSourceMap_ignoreList_includes = (_applicableSourceMap_ignoreList = applicableSourceMap.ignoreList) == null ? void 0 : _applicableSourceMap_ignoreList.includes(sourceIndex)) != null ? _applicableSourceMap_ignoreList_includes : // When sourcemap is not available, fallback to checking `frame.file`.\n                // e.g. In pages router, nextjs server code is not bundled into the page.\n                shouldIgnorePath(frame.file);\n            }\n            var _originalPosition_column, _originalPosition_line;\n            const originalStackFrame = {\n                methodName: ((_frame_methodName = frame.methodName) == null ? void 0 : (_frame_methodName_replace = _frame_methodName.replace('__WEBPACK_DEFAULT_EXPORT__', 'default')) == null ? void 0 : _frame_methodName_replace.replace('__webpack_exports__.', '')) || '<unknown>',\n                column: ((_originalPosition_column = originalPosition.column) != null ? _originalPosition_column : 0) + 1,\n                file: originalPosition.source,\n                lineNumber: (_originalPosition_line = originalPosition.line) != null ? _originalPosition_line : 0,\n                // TODO: c&p from async createOriginalStackFrame but why not frame.arguments?\n                arguments: [],\n                ignored\n            };\n            return {\n                frame: originalStackFrame,\n                source: sourceContent\n            };\n        }\n    }\n    return undefined;\n}\nasync function createOriginalStackFrame(project, projectPath, frame) {\n    var _ref;\n    const traced = (_ref = await nativeTraceSource(frame)) != null ? _ref : // TODO(veil): When would the bundler know more than native?\n    // If it's faster, try the bundler first and fall back to native later.\n    await batchedTraceSource(project, frame);\n    if (!traced) {\n        return null;\n    }\n    let normalizedStackFrameLocation = traced.frame.file;\n    if (normalizedStackFrameLocation !== null && normalizedStackFrameLocation.startsWith('file://')) {\n        normalizedStackFrameLocation = path.relative(projectPath, url.fileURLToPath(normalizedStackFrameLocation));\n    }\n    return {\n        originalStackFrame: {\n            arguments: traced.frame.arguments,\n            column: traced.frame.column,\n            file: normalizedStackFrameLocation,\n            ignored: traced.frame.ignored,\n            lineNumber: traced.frame.lineNumber,\n            methodName: traced.frame.methodName\n        },\n        originalCodeFrame: getOriginalCodeFrame(traced.frame, traced.source)\n    };\n}\nexport function getOverlayMiddleware(project, projectPath) {\n    return async function(req, res, next) {\n        const { pathname, searchParams } = new URL(req.url, 'http://n');\n        if (pathname === '/__nextjs_original-stack-frames') {\n            if (req.method !== 'POST') {\n                return middlewareResponse.badRequest(res);\n            }\n            const body = await new Promise((resolve, reject)=>{\n                let data = '';\n                req.on('data', (chunk)=>{\n                    data += chunk;\n                });\n                req.on('end', ()=>resolve(data));\n                req.on('error', reject);\n            });\n            const request = JSON.parse(body);\n            const stackFrames = createStackFrames(request);\n            const result = await Promise.all(stackFrames.map(async (frame)=>{\n                try {\n                    const stackFrame = await createOriginalStackFrame(project, projectPath, frame);\n                    if (stackFrame === null) {\n                        return {\n                            status: 'rejected',\n                            reason: 'Failed to create original stack frame'\n                        };\n                    }\n                    return {\n                        status: 'fulfilled',\n                        value: stackFrame\n                    };\n                } catch (error) {\n                    return {\n                        status: 'rejected',\n                        reason: inspect(error, {\n                            colors: false\n                        })\n                    };\n                }\n            }));\n            return middlewareResponse.json(res, result);\n        } else if (pathname === '/__nextjs_launch-editor') {\n            const frame = createStackFrame(searchParams);\n            if (!frame) return middlewareResponse.badRequest(res);\n            const fileExists = await fs.access(frame.file, FS.F_OK).then(()=>true, ()=>false);\n            if (!fileExists) return middlewareResponse.notFound(res);\n            try {\n                var _frame_line, _frame_column;\n                launchEditor(frame.file, (_frame_line = frame.line) != null ? _frame_line : 1, (_frame_column = frame.column) != null ? _frame_column : 1);\n            } catch (err) {\n                console.log('Failed to launch editor:', err);\n                return middlewareResponse.internalServerError(res);\n            }\n            return middlewareResponse.noContent(res);\n        }\n        return next();\n    };\n}\nexport function getSourceMapMiddleware(project) {\n    return async function(req, res, next) {\n        const { pathname, searchParams } = new URL(req.url, 'http://n');\n        if (pathname !== '/__nextjs_source-map') {\n            return next();\n        }\n        let filename = searchParams.get('filename');\n        if (!filename) {\n            return middlewareResponse.badRequest(res);\n        }\n        // TODO(veil): Always try the native version first.\n        // Externals could also be files that aren't bundled via Webpack.\n        if (filename.startsWith('webpack://') || filename.startsWith('webpack-internal:///')) {\n            const sourceMap = findSourceMap(filename);\n            if (sourceMap) {\n                return middlewareResponse.json(res, sourceMap.payload);\n            }\n            return middlewareResponse.noContent(res);\n        }\n        try {\n            // Turbopack chunk filenames might be URL-encoded.\n            filename = decodeURI(filename);\n            if (path.isAbsolute(filename)) {\n                filename = url.pathToFileURL(filename).href;\n            }\n            const sourceMapString = await project.getSourceMap(filename);\n            if (sourceMapString) {\n                return middlewareResponse.jsonString(res, sourceMapString);\n            }\n            if (filename.startsWith('file:')) {\n                const sourceMap = await getSourceMapFromFile(filename);\n                if (sourceMap) {\n                    return middlewareResponse.json(res, sourceMap);\n                }\n            }\n        } catch (error) {\n            console.error('Failed to get source map:', error);\n        }\n        middlewareResponse.noContent(res);\n    };\n}\n\n//# sourceMappingURL=middleware-turbopack.js.map"
        }
    ]
}