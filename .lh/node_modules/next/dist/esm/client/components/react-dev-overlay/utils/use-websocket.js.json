{
    "sourceFile": "node_modules/next/dist/esm/client/components/react-dev-overlay/utils/use-websocket.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892779069,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import { useCallback, useContext, useEffect, useRef } from 'react';\nimport { GlobalLayoutRouterContext } from '../../../../shared/lib/app-router-context.shared-runtime';\nimport { getSocketUrl } from './get-socket-url';\nexport function useWebsocket(assetPrefix) {\n    const webSocketRef = useRef(undefined);\n    useEffect(()=>{\n        if (webSocketRef.current) {\n            return;\n        }\n        const url = getSocketUrl(assetPrefix);\n        webSocketRef.current = new window.WebSocket(\"\" + url + \"/_next/webpack-hmr\");\n    }, [\n        assetPrefix\n    ]);\n    return webSocketRef;\n}\nexport function useSendMessage(webSocketRef) {\n    const sendMessage = useCallback((data)=>{\n        const socket = webSocketRef.current;\n        if (!socket || socket.readyState !== socket.OPEN) {\n            return;\n        }\n        return socket.send(data);\n    }, [\n        webSocketRef\n    ]);\n    return sendMessage;\n}\nexport function useTurbopack(sendMessage, onUpdateError) {\n    const turbopackState = useRef({\n        init: false,\n        // Until the dynamic import resolves, queue any turbopack messages which will be replayed.\n        queue: [],\n        callback: undefined\n    });\n    const processTurbopackMessage = useCallback((msg)=>{\n        const { callback, queue } = turbopackState.current;\n        if (callback) {\n            callback(msg);\n        } else {\n            queue.push(msg);\n        }\n    }, []);\n    useEffect(()=>{\n        const { current: initCurrent } = turbopackState;\n        // TODO(WEB-1589): only install if `process.turbopack` set.\n        if (initCurrent.init) {\n            return;\n        }\n        initCurrent.init = true;\n        import(// @ts-expect-error requires \"moduleResolution\": \"node16\" in tsconfig.json and not .ts extension\n        '@vercel/turbopack-ecmascript-runtime/browser/dev/hmr-client/hmr-client.ts').then((param)=>{\n            let { connect } = param;\n            const { current } = turbopackState;\n            connect({\n                addMessageListener (cb) {\n                    current.callback = cb;\n                    // Replay all Turbopack messages before we were able to establish the HMR client.\n                    for (const msg of current.queue){\n                        cb(msg);\n                    }\n                    current.queue = undefined;\n                },\n                sendMessage,\n                onUpdateError\n            });\n        });\n    }, [\n        sendMessage,\n        onUpdateError\n    ]);\n    return processTurbopackMessage;\n}\nexport function useWebsocketPing(websocketRef) {\n    const sendMessage = useSendMessage(websocketRef);\n    const { tree } = useContext(GlobalLayoutRouterContext);\n    useEffect(()=>{\n        // Never send pings when using Turbopack as it's not used.\n        // Pings were originally used to keep track of active routes in on-demand-entries with webpack.\n        if (process.env.TURBOPACK) {\n            return;\n        }\n        // Taken from on-demand-entries-client.js\n        const interval = setInterval(()=>{\n            sendMessage(JSON.stringify({\n                event: 'ping',\n                tree,\n                appDirRoute: true\n            }));\n        }, 2500);\n        return ()=>clearInterval(interval);\n    }, [\n        tree,\n        sendMessage\n    ]);\n}\n\n//# sourceMappingURL=use-websocket.js.map"
        }
    ]
}