{
    "sourceFile": "node_modules/next/dist/esm/client/components/react-dev-overlay/shared.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892768442,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "var _process_env___NEXT_DEV_INDICATOR;\nimport { useReducer } from 'react';\nexport const ACTION_STATIC_INDICATOR = 'static-indicator';\nexport const ACTION_BUILD_OK = 'build-ok';\nexport const ACTION_BUILD_ERROR = 'build-error';\nexport const ACTION_BEFORE_REFRESH = 'before-fast-refresh';\nexport const ACTION_REFRESH = 'fast-refresh';\nexport const ACTION_VERSION_INFO = 'version-info';\nexport const ACTION_UNHANDLED_ERROR = 'unhandled-error';\nexport const ACTION_UNHANDLED_REJECTION = 'unhandled-rejection';\nexport const ACTION_DEBUG_INFO = 'debug-info';\nexport const ACTION_DEV_INDICATOR = 'dev-indicator';\nexport const STORAGE_KEY_THEME = '__nextjs-dev-tools-theme';\nexport const STORAGE_KEY_POSITION = '__nextjs-dev-tools-position';\nexport const STORAGE_KEY_SCALE = '__nextjs-dev-tools-scale';\nfunction pushErrorFilterDuplicates(errors, err) {\n    return [\n        ...errors.filter((e)=>{\n            // Filter out duplicate errors\n            return e.event.reason.stack !== err.event.reason.stack;\n        }),\n        err\n    ];\n}\nconst shouldDisableDevIndicator = ((_process_env___NEXT_DEV_INDICATOR = process.env.__NEXT_DEV_INDICATOR) == null ? void 0 : _process_env___NEXT_DEV_INDICATOR.toString()) === 'false';\nexport const INITIAL_OVERLAY_STATE = {\n    nextId: 1,\n    buildError: null,\n    errors: [],\n    notFound: false,\n    staticIndicator: false,\n    /* \n    This is set to `true` when we can reliably know\n    whether the indicator is in disabled state or not.  \n    Otherwise the surface would flicker because the disabled flag loads from the config.\n  */ showIndicator: false,\n    disableDevIndicator: false,\n    refreshState: {\n        type: 'idle'\n    },\n    versionInfo: {\n        installed: '0.0.0',\n        staleness: 'unknown'\n    },\n    debugInfo: {\n        devtoolsFrontendUrl: undefined\n    }\n};\nfunction getInitialState(routerType) {\n    return {\n        ...INITIAL_OVERLAY_STATE,\n        routerType\n    };\n}\nexport function useErrorOverlayReducer(routerType) {\n    return useReducer((state, action)=>{\n        switch(action.type){\n            case ACTION_DEBUG_INFO:\n                {\n                    return {\n                        ...state,\n                        debugInfo: action.debugInfo\n                    };\n                }\n            case ACTION_STATIC_INDICATOR:\n                {\n                    return {\n                        ...state,\n                        staticIndicator: action.staticIndicator\n                    };\n                }\n            case ACTION_BUILD_OK:\n                {\n                    return {\n                        ...state,\n                        buildError: null\n                    };\n                }\n            case ACTION_BUILD_ERROR:\n                {\n                    return {\n                        ...state,\n                        buildError: action.message\n                    };\n                }\n            case ACTION_BEFORE_REFRESH:\n                {\n                    return {\n                        ...state,\n                        refreshState: {\n                            type: 'pending',\n                            errors: []\n                        }\n                    };\n                }\n            case ACTION_REFRESH:\n                {\n                    return {\n                        ...state,\n                        buildError: null,\n                        errors: // Errors can come in during updates. In this case, UNHANDLED_ERROR\n                        // and UNHANDLED_REJECTION events might be dispatched between the\n                        // BEFORE_REFRESH and the REFRESH event. We want to keep those errors\n                        // around until the next refresh. Otherwise we run into a race\n                        // condition where those errors would be cleared on refresh completion\n                        // before they can be displayed.\n                        state.refreshState.type === 'pending' ? state.refreshState.errors : [],\n                        refreshState: {\n                            type: 'idle'\n                        }\n                    };\n                }\n            case ACTION_UNHANDLED_ERROR:\n            case ACTION_UNHANDLED_REJECTION:\n                {\n                    switch(state.refreshState.type){\n                        case 'idle':\n                            {\n                                return {\n                                    ...state,\n                                    nextId: state.nextId + 1,\n                                    errors: pushErrorFilterDuplicates(state.errors, {\n                                        id: state.nextId,\n                                        event: action\n                                    })\n                                };\n                            }\n                        case 'pending':\n                            {\n                                return {\n                                    ...state,\n                                    nextId: state.nextId + 1,\n                                    refreshState: {\n                                        ...state.refreshState,\n                                        errors: pushErrorFilterDuplicates(state.refreshState.errors, {\n                                            id: state.nextId,\n                                            event: action\n                                        })\n                                    }\n                                };\n                            }\n                        default:\n                            return state;\n                    }\n                }\n            case ACTION_VERSION_INFO:\n                {\n                    return {\n                        ...state,\n                        versionInfo: action.versionInfo\n                    };\n                }\n            case ACTION_DEV_INDICATOR:\n                {\n                    return {\n                        ...state,\n                        showIndicator: true,\n                        disableDevIndicator: shouldDisableDevIndicator || !!action.devIndicator.disabledUntil\n                    };\n                }\n            default:\n                {\n                    return state;\n                }\n        }\n    }, getInitialState(routerType));\n}\nexport const REACT_REFRESH_FULL_RELOAD = '[Fast Refresh] performing full reload\\n\\n' + \"Fast Refresh will perform a full reload when you edit a file that's imported by modules outside of the React rendering tree.\\n\" + 'You might have a file which exports a React component but also exports a value that is imported by a non-React component file.\\n' + 'Consider migrating the non-React component export to a separate file and importing it into both files.\\n\\n' + 'It is also possible the parent component of the component you edited is a class component, which disables Fast Refresh.\\n' + 'Fast Refresh requires at least one parent function component in your React tree.';\nexport const REACT_REFRESH_FULL_RELOAD_FROM_ERROR = '[Fast Refresh] performing full reload because your application had an unrecoverable error';\nexport function reportInvalidHmrMessage(message, err) {\n    console.warn('[HMR] Invalid message: ' + JSON.stringify(message) + '\\n' + (err instanceof Error && (err == null ? void 0 : err.stack) || ''));\n}\n\n//# sourceMappingURL=shared.js.map"
        }
    ]
}