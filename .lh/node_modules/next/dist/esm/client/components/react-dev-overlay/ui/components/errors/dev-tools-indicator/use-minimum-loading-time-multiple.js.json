{
    "sourceFile": "node_modules/next/dist/esm/client/components/react-dev-overlay/ui/components/errors/dev-tools-indicator/use-minimum-loading-time-multiple.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892772674,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import { useEffect, useRef, useState } from 'react';\n/**\n * A React hook that ensures a loading state persists\n * at least up to the next multiple of a given interval (default: 750ms).\n *\n * For example, if you're done loading at 1200ms, it forces you to wait\n * until 1500ms. If itâ€™s 1800ms, it waits until 2250ms, etc.\n *\n * @param isLoadingTrigger - Boolean that triggers the loading state\n * @param interval - The time interval multiple in ms (default: 750ms)\n * @returns Current loading state that respects multiples of the interval\n */ export function useMinimumLoadingTimeMultiple(isLoadingTrigger, interval) {\n    if (interval === void 0) interval = 750;\n    const [isLoading, setIsLoading] = useState(false);\n    const loadStartTimeRef = useRef(null);\n    const timeoutIdRef = useRef(null);\n    useEffect(()=>{\n        // Clear any pending timeout to avoid overlap\n        if (timeoutIdRef.current) {\n            clearTimeout(timeoutIdRef.current);\n            timeoutIdRef.current = null;\n        }\n        if (isLoadingTrigger) {\n            // If we enter \"loading\" state, record start time if not already\n            if (loadStartTimeRef.current === null) {\n                loadStartTimeRef.current = Date.now();\n            }\n            setIsLoading(true);\n        } else {\n            // If we're exiting the \"loading\" state:\n            if (loadStartTimeRef.current === null) {\n                // No start time was recorded, so just stop loading immediately\n                setIsLoading(false);\n            } else {\n                // How long we've been \"loading\"\n                const timeDiff = Date.now() - loadStartTimeRef.current;\n                // Next multiple of `interval` after `timeDiff`\n                const nextMultiple = interval * Math.ceil(timeDiff / interval);\n                // Remaining time needed to reach that multiple\n                const remainingTime = nextMultiple - timeDiff;\n                if (remainingTime > 0) {\n                    // If not yet at that multiple, schedule the final step\n                    timeoutIdRef.current = setTimeout(()=>{\n                        setIsLoading(false);\n                        loadStartTimeRef.current = null;\n                    }, remainingTime);\n                } else {\n                    // We're already past the multiple boundary\n                    setIsLoading(false);\n                    loadStartTimeRef.current = null;\n                }\n            }\n        }\n        // Cleanup when effect is about to re-run or component unmounts\n        return ()=>{\n            if (timeoutIdRef.current) {\n                clearTimeout(timeoutIdRef.current);\n            }\n        };\n    }, [\n        isLoadingTrigger,\n        interval\n    ]);\n    return isLoading;\n}\n\n//# sourceMappingURL=use-minimum-loading-time-multiple.js.map"
        }
    ]
}