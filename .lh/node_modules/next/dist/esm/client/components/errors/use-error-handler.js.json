{
    "sourceFile": "node_modules/next/dist/esm/client/components/errors/use-error-handler.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892764540,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import { useEffect } from 'react';\nimport { attachHydrationErrorState } from './attach-hydration-error-state';\nimport { isNextRouterError } from '../is-next-router-error';\nimport { storeHydrationErrorStateFromConsoleArgs } from './hydration-error-info';\nimport { formatConsoleArgs, parseConsoleArgs } from '../../lib/console';\nimport isError from '../../../lib/is-error';\nimport { createConsoleError } from './console-error';\nimport { enqueueConsecutiveDedupedError } from './enqueue-client-error';\nimport { getReactStitchedError } from '../errors/stitched-error';\nconst queueMicroTask = globalThis.queueMicrotask || ((cb)=>Promise.resolve().then(cb));\nconst errorQueue = [];\nconst errorHandlers = [];\nconst rejectionQueue = [];\nconst rejectionHandlers = [];\nexport function handleConsoleError(originError, consoleErrorArgs) {\n    let error;\n    const { environmentName } = parseConsoleArgs(consoleErrorArgs);\n    if (isError(originError)) {\n        error = createConsoleError(originError, environmentName);\n    } else {\n        error = createConsoleError(formatConsoleArgs(consoleErrorArgs), environmentName);\n    }\n    error = getReactStitchedError(error);\n    storeHydrationErrorStateFromConsoleArgs(...consoleErrorArgs);\n    attachHydrationErrorState(error);\n    enqueueConsecutiveDedupedError(errorQueue, error);\n    for (const handler of errorHandlers){\n        // Delayed the error being passed to React Dev Overlay,\n        // avoid the state being synchronously updated in the component.\n        queueMicroTask(()=>{\n            handler(error);\n        });\n    }\n}\nexport function handleClientError(originError) {\n    let error;\n    if (isError(originError)) {\n        error = originError;\n    } else {\n        // If it's not an error, format the args into an error\n        const formattedErrorMessage = originError + '';\n        error = Object.defineProperty(new Error(formattedErrorMessage), \"__NEXT_ERROR_CODE\", {\n            value: \"E394\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    error = getReactStitchedError(error);\n    attachHydrationErrorState(error);\n    enqueueConsecutiveDedupedError(errorQueue, error);\n    for (const handler of errorHandlers){\n        // Delayed the error being passed to React Dev Overlay,\n        // avoid the state being synchronously updated in the component.\n        queueMicroTask(()=>{\n            handler(error);\n        });\n    }\n}\nexport function useErrorHandler(handleOnUnhandledError, handleOnUnhandledRejection) {\n    useEffect(()=>{\n        // Handle queued errors.\n        errorQueue.forEach(handleOnUnhandledError);\n        rejectionQueue.forEach(handleOnUnhandledRejection);\n        // Listen to new errors.\n        errorHandlers.push(handleOnUnhandledError);\n        rejectionHandlers.push(handleOnUnhandledRejection);\n        return ()=>{\n            // Remove listeners.\n            errorHandlers.splice(errorHandlers.indexOf(handleOnUnhandledError), 1);\n            rejectionHandlers.splice(rejectionHandlers.indexOf(handleOnUnhandledRejection), 1);\n            // Reset error queues.\n            errorQueue.splice(0, errorQueue.length);\n            rejectionQueue.splice(0, rejectionQueue.length);\n        };\n    }, [\n        handleOnUnhandledError,\n        handleOnUnhandledRejection\n    ]);\n}\nfunction onUnhandledError(event) {\n    if (isNextRouterError(event.error)) {\n        event.preventDefault();\n        return false;\n    }\n    // When there's an error property present, we log the error to error overlay.\n    // Otherwise we don't do anything as it's not logging in the console either.\n    if (event.error) {\n        handleClientError(event.error);\n    }\n}\nfunction onUnhandledRejection(ev) {\n    const reason = ev == null ? void 0 : ev.reason;\n    if (isNextRouterError(reason)) {\n        ev.preventDefault();\n        return;\n    }\n    let error = reason;\n    if (error && !isError(error)) {\n        error = Object.defineProperty(new Error(error + ''), \"__NEXT_ERROR_CODE\", {\n            value: \"E394\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    rejectionQueue.push(error);\n    for (const handler of rejectionHandlers){\n        handler(error);\n    }\n}\nexport function handleGlobalErrors() {\n    if (typeof window !== 'undefined') {\n        try {\n            // Increase the number of stack frames on the client\n            Error.stackTraceLimit = 50;\n        } catch (e) {}\n        window.addEventListener('error', onUnhandledError);\n        window.addEventListener('unhandledrejection', onUnhandledRejection);\n    }\n}\n\n//# sourceMappingURL=use-error-handler.js.map"
        }
    ]
}