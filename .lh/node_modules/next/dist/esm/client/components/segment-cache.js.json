{
    "sourceFile": "node_modules/next/dist/esm/client/components/segment-cache.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892784884,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * Entry point to the Segment Cache implementation.\n *\n * All code related to the Segment Cache lives `segment-cache-impl` directory.\n * Callers access it through this indirection.\n *\n * This is to ensure the code is dead code eliminated from the bundle if the\n * flag is disabled.\n *\n * TODO: This is super tedious. Since experimental flags are an essential part\n * of our workflow, we should establish a better pattern for dead code\n * elimination. Ideally it would be done at the bundler level, like how React's\n * build process works. In the React repo, you don't even need to add any extra\n * configuration per experiment â€” if the code is not reachable, it gets stripped\n * from the build automatically by Rollup. Or, shorter term, we could stub out\n * experimental modules at build time by updating the build config, i.e. a more\n * automated version of what I'm doing manually in this file.\n */ const notEnabled = ()=>{\n    throw Object.defineProperty(new Error('Segment Cache experiment is not enabled. This is a bug in Next.js.'), \"__NEXT_ERROR_CODE\", {\n        value: \"E654\",\n        enumerable: false,\n        configurable: true\n    });\n};\nexport const prefetch = process.env.__NEXT_CLIENT_SEGMENT_CACHE ? function() {\n    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n        args[_key] = arguments[_key];\n    }\n    return require('./segment-cache-impl/prefetch').prefetch(...args);\n} : notEnabled;\nexport const navigate = process.env.__NEXT_CLIENT_SEGMENT_CACHE ? function() {\n    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n        args[_key] = arguments[_key];\n    }\n    return require('./segment-cache-impl/navigation').navigate(...args);\n} : notEnabled;\nexport const revalidateEntireCache = process.env.__NEXT_CLIENT_SEGMENT_CACHE ? function() {\n    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n        args[_key] = arguments[_key];\n    }\n    return require('./segment-cache-impl/cache').revalidateEntireCache(...args);\n} : notEnabled;\nexport const getCurrentCacheVersion = process.env.__NEXT_CLIENT_SEGMENT_CACHE ? function() {\n    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n        args[_key] = arguments[_key];\n    }\n    return require('./segment-cache-impl/cache').getCurrentCacheVersion(...args);\n} : notEnabled;\nexport const schedulePrefetchTask = process.env.__NEXT_CLIENT_SEGMENT_CACHE ? function() {\n    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n        args[_key] = arguments[_key];\n    }\n    return require('./segment-cache-impl/scheduler').schedulePrefetchTask(...args);\n} : notEnabled;\nexport const cancelPrefetchTask = process.env.__NEXT_CLIENT_SEGMENT_CACHE ? function() {\n    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n        args[_key] = arguments[_key];\n    }\n    return require('./segment-cache-impl/scheduler').cancelPrefetchTask(...args);\n} : notEnabled;\nexport const reschedulePrefetchTask = process.env.__NEXT_CLIENT_SEGMENT_CACHE ? function() {\n    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n        args[_key] = arguments[_key];\n    }\n    return require('./segment-cache-impl/scheduler').reschedulePrefetchTask(...args);\n} : notEnabled;\nexport const createCacheKey = process.env.__NEXT_CLIENT_SEGMENT_CACHE ? function() {\n    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n        args[_key] = arguments[_key];\n    }\n    return require('./segment-cache-impl/cache-key').createCacheKey(...args);\n} : notEnabled;\n/**\n * Below are public constants. They're small enough that we don't need to\n * DCE them.\n */ export var NavigationResultTag = /*#__PURE__*/ function(NavigationResultTag) {\n    NavigationResultTag[NavigationResultTag[\"MPA\"] = 0] = \"MPA\";\n    NavigationResultTag[NavigationResultTag[\"Success\"] = 1] = \"Success\";\n    NavigationResultTag[NavigationResultTag[\"NoOp\"] = 2] = \"NoOp\";\n    NavigationResultTag[NavigationResultTag[\"Async\"] = 3] = \"Async\";\n    return NavigationResultTag;\n}({});\n/**\n * The priority of the prefetch task. Higher numbers are higher priority.\n */ export var PrefetchPriority = /*#__PURE__*/ function(PrefetchPriority) {\n    /**\n   * Assigned to any visible link that was hovered/touched at some point. This\n   * is not removed on mouse exit, because a link that was momentarily\n   * hovered is more likely to to be interacted with than one that was not.\n   */ PrefetchPriority[PrefetchPriority[\"Intent\"] = 2] = \"Intent\";\n    /**\n   * The default priority for prefetch tasks.\n   */ PrefetchPriority[PrefetchPriority[\"Default\"] = 1] = \"Default\";\n    /**\n   * Assigned to tasks when they spawn non-blocking background work, like\n   * revalidating a partially cached entry to see if more data is available.\n   */ PrefetchPriority[PrefetchPriority[\"Background\"] = 0] = \"Background\";\n    return PrefetchPriority;\n}({});\n\n//# sourceMappingURL=segment-cache.js.map"
        }
    ]
}