{
    "sourceFile": "node_modules/next/dist/esm/client/components/error-boundary.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892764056,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "'use client';\nimport { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from \"react/jsx-runtime\";\nimport React from 'react';\nimport { useUntrackedPathname } from './navigation-untracked';\nimport { isNextRouterError } from './is-next-router-error';\nimport { handleHardNavError } from './nav-failure-handler';\nconst workAsyncStorage = typeof window === 'undefined' ? require('../../server/app-render/work-async-storage.external').workAsyncStorage : undefined;\nconst styles = {\n    error: {\n        // https://github.com/sindresorhus/modern-normalize/blob/main/modern-normalize.css#L38-L52\n        fontFamily: 'system-ui,\"Segoe UI\",Roboto,Helvetica,Arial,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\"',\n        height: '100vh',\n        textAlign: 'center',\n        display: 'flex',\n        flexDirection: 'column',\n        alignItems: 'center',\n        justifyContent: 'center'\n    },\n    text: {\n        fontSize: '14px',\n        fontWeight: 400,\n        lineHeight: '28px',\n        margin: '0 8px'\n    }\n};\n// if we are revalidating we want to re-throw the error so the\n// function crashes so we can maintain our previous cache\n// instead of caching the error page\nfunction HandleISRError(param) {\n    let { error } = param;\n    if (workAsyncStorage) {\n        const store = workAsyncStorage.getStore();\n        if ((store == null ? void 0 : store.isRevalidate) || (store == null ? void 0 : store.isStaticGeneration)) {\n            console.error(error);\n            throw error;\n        }\n    }\n    return null;\n}\nexport class ErrorBoundaryHandler extends React.Component {\n    static getDerivedStateFromError(error) {\n        if (isNextRouterError(error)) {\n            // Re-throw if an expected internal Next.js router error occurs\n            // this means it should be handled by a different boundary (such as a NotFound boundary in a parent segment)\n            throw error;\n        }\n        return {\n            error\n        };\n    }\n    static getDerivedStateFromProps(props, state) {\n        const { error } = state;\n        // if we encounter an error while\n        // a navigation is pending we shouldn't render\n        // the error boundary and instead should fallback\n        // to a hard navigation to attempt recovering\n        if (process.env.__NEXT_APP_NAV_FAIL_HANDLING) {\n            if (error && handleHardNavError(error)) {\n                // clear error so we don't render anything\n                return {\n                    error: null,\n                    previousPathname: props.pathname\n                };\n            }\n        }\n        /**\n     * Handles reset of the error boundary when a navigation happens.\n     * Ensures the error boundary does not stay enabled when navigating to a new page.\n     * Approach of setState in render is safe as it checks the previous pathname and then overrides\n     * it as outlined in https://react.dev/reference/react/useState#storing-information-from-previous-renders\n     */ if (props.pathname !== state.previousPathname && state.error) {\n            return {\n                error: null,\n                previousPathname: props.pathname\n            };\n        }\n        return {\n            error: state.error,\n            previousPathname: props.pathname\n        };\n    }\n    // Explicit type is needed to avoid the generated `.d.ts` having a wide return type that could be specific to the `@types/react` version.\n    render() {\n        if (this.state.error) {\n            return /*#__PURE__*/ _jsxs(_Fragment, {\n                children: [\n                    /*#__PURE__*/ _jsx(HandleISRError, {\n                        error: this.state.error\n                    }),\n                    this.props.errorStyles,\n                    this.props.errorScripts,\n                    /*#__PURE__*/ _jsx(this.props.errorComponent, {\n                        error: this.state.error,\n                        reset: this.reset\n                    })\n                ]\n            });\n        }\n        return this.props.children;\n    }\n    constructor(props){\n        super(props), this.reset = ()=>{\n            this.setState({\n                error: null\n            });\n        };\n        this.state = {\n            error: null,\n            previousPathname: this.props.pathname\n        };\n    }\n}\nexport function GlobalError(param) {\n    let { error } = param;\n    const digest = error == null ? void 0 : error.digest;\n    return /*#__PURE__*/ _jsxs(\"html\", {\n        id: \"__next_error__\",\n        children: [\n            /*#__PURE__*/ _jsx(\"head\", {}),\n            /*#__PURE__*/ _jsxs(\"body\", {\n                children: [\n                    /*#__PURE__*/ _jsx(HandleISRError, {\n                        error: error\n                    }),\n                    /*#__PURE__*/ _jsx(\"div\", {\n                        style: styles.error,\n                        children: /*#__PURE__*/ _jsxs(\"div\", {\n                            children: [\n                                /*#__PURE__*/ _jsxs(\"h2\", {\n                                    style: styles.text,\n                                    children: [\n                                        \"Application error: a \",\n                                        digest ? 'server' : 'client',\n                                        \"-side exception has occurred while loading \",\n                                        window.location.hostname,\n                                        \" (see the\",\n                                        ' ',\n                                        digest ? 'server logs' : 'browser console',\n                                        \" for more information).\"\n                                    ]\n                                }),\n                                digest ? /*#__PURE__*/ _jsx(\"p\", {\n                                    style: styles.text,\n                                    children: \"Digest: \" + digest\n                                }) : null\n                            ]\n                        })\n                    })\n                ]\n            })\n        ]\n    });\n}\n// Exported so that the import signature in the loaders can be identical to user\n// supplied custom global error signatures.\nexport default GlobalError;\n/**\n * Handles errors through `getDerivedStateFromError`.\n * Renders the provided error component and provides a way to `reset` the error boundary state.\n */ /**\n * Renders error boundary with the provided \"errorComponent\" property as the fallback.\n * If no \"errorComponent\" property is provided it renders the children without an error boundary.\n */ export function ErrorBoundary(param) {\n    let { errorComponent, errorStyles, errorScripts, children } = param;\n    // When we're rendering the missing params shell, this will return null. This\n    // is because we won't be rendering any not found boundaries or error\n    // boundaries for the missing params shell. When this runs on the client\n    // (where these errors can occur), we will get the correct pathname.\n    const pathname = useUntrackedPathname();\n    if (errorComponent) {\n        return /*#__PURE__*/ _jsx(ErrorBoundaryHandler, {\n            pathname: pathname,\n            errorComponent: errorComponent,\n            errorStyles: errorStyles,\n            errorScripts: errorScripts,\n            children: children\n        });\n    }\n    return /*#__PURE__*/ _jsx(_Fragment, {\n        children: children\n    });\n}\n\n//# sourceMappingURL=error-boundary.js.map"
        }
    ]
}