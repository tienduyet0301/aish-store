{
    "sourceFile": "node_modules/next/dist/esm/client/components/promise-queue.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892767094,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/*\n    This is a simple promise queue that allows you to limit the number of concurrent promises\n    that are running at any given time. It's used to limit the number of concurrent\n    prefetch requests that are being made to the server but could be used for other\n    things as well.\n*/ import { _ as _class_private_field_loose_base } from \"@swc/helpers/_/_class_private_field_loose_base\";\nimport { _ as _class_private_field_loose_key } from \"@swc/helpers/_/_class_private_field_loose_key\";\nvar _maxConcurrency = /*#__PURE__*/ _class_private_field_loose_key(\"_maxConcurrency\"), _runningCount = /*#__PURE__*/ _class_private_field_loose_key(\"_runningCount\"), _queue = /*#__PURE__*/ _class_private_field_loose_key(\"_queue\"), _processNext = /*#__PURE__*/ _class_private_field_loose_key(\"_processNext\");\nexport class PromiseQueue {\n    enqueue(promiseFn) {\n        let taskResolve;\n        let taskReject;\n        const taskPromise = new Promise((resolve, reject)=>{\n            taskResolve = resolve;\n            taskReject = reject;\n        });\n        const task = async ()=>{\n            try {\n                _class_private_field_loose_base(this, _runningCount)[_runningCount]++;\n                const result = await promiseFn();\n                taskResolve(result);\n            } catch (error) {\n                taskReject(error);\n            } finally{\n                _class_private_field_loose_base(this, _runningCount)[_runningCount]--;\n                _class_private_field_loose_base(this, _processNext)[_processNext]();\n            }\n        };\n        const enqueueResult = {\n            promiseFn: taskPromise,\n            task\n        };\n        // wonder if we should take a LIFO approach here\n        _class_private_field_loose_base(this, _queue)[_queue].push(enqueueResult);\n        _class_private_field_loose_base(this, _processNext)[_processNext]();\n        return taskPromise;\n    }\n    bump(promiseFn) {\n        const index = _class_private_field_loose_base(this, _queue)[_queue].findIndex((item)=>item.promiseFn === promiseFn);\n        if (index > -1) {\n            const bumpedItem = _class_private_field_loose_base(this, _queue)[_queue].splice(index, 1)[0];\n            _class_private_field_loose_base(this, _queue)[_queue].unshift(bumpedItem);\n            _class_private_field_loose_base(this, _processNext)[_processNext](true);\n        }\n    }\n    constructor(maxConcurrency = 5){\n        Object.defineProperty(this, _processNext, {\n            value: processNext\n        });\n        Object.defineProperty(this, _maxConcurrency, {\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, _runningCount, {\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, _queue, {\n            writable: true,\n            value: void 0\n        });\n        _class_private_field_loose_base(this, _maxConcurrency)[_maxConcurrency] = maxConcurrency;\n        _class_private_field_loose_base(this, _runningCount)[_runningCount] = 0;\n        _class_private_field_loose_base(this, _queue)[_queue] = [];\n    }\n}\nfunction processNext(forced) {\n    if (forced === void 0) forced = false;\n    if ((_class_private_field_loose_base(this, _runningCount)[_runningCount] < _class_private_field_loose_base(this, _maxConcurrency)[_maxConcurrency] || forced) && _class_private_field_loose_base(this, _queue)[_queue].length > 0) {\n        var _class_private_field_loose_base__queue_shift;\n        (_class_private_field_loose_base__queue_shift = _class_private_field_loose_base(this, _queue)[_queue].shift()) == null ? void 0 : _class_private_field_loose_base__queue_shift.task();\n    }\n}\n\n//# sourceMappingURL=promise-queue.js.map"
        }
    ]
}