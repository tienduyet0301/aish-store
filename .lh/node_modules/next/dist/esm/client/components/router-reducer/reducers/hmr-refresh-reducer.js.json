{
    "sourceFile": "node_modules/next/dist/esm/client/components/router-reducer/reducers/hmr-refresh-reducer.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892783059,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import { fetchServerResponse } from '../fetch-server-response';\nimport { createHrefFromUrl } from '../create-href-from-url';\nimport { applyRouterStatePatchToTree } from '../apply-router-state-patch-to-tree';\nimport { isNavigatingToNewRootLayout } from '../is-navigating-to-new-root-layout';\nimport { handleExternalUrl } from './navigate-reducer';\nimport { handleMutable } from '../handle-mutable';\nimport { applyFlightData } from '../apply-flight-data';\nimport { createEmptyCacheNode } from '../../app-router';\nimport { handleSegmentMismatch } from '../handle-segment-mismatch';\nimport { hasInterceptionRouteInCurrentTree } from './has-interception-route-in-current-tree';\n// A version of refresh reducer that keeps the cache around instead of wiping all of it.\nfunction hmrRefreshReducerImpl(state, action) {\n    const { origin } = action;\n    const mutable = {};\n    const href = state.canonicalUrl;\n    mutable.preserveCustomHistoryState = false;\n    const cache = createEmptyCacheNode();\n    // If the current tree was intercepted, the nextUrl should be included in the request.\n    // This is to ensure that the refresh request doesn't get intercepted, accidentally triggering the interception route.\n    const includeNextUrl = hasInterceptionRouteInCurrentTree(state.tree);\n    // TODO-APP: verify that `href` is not an external url.\n    // Fetch data from the root of the tree.\n    const navigatedAt = Date.now();\n    cache.lazyData = fetchServerResponse(new URL(href, origin), {\n        flightRouterState: [\n            state.tree[0],\n            state.tree[1],\n            state.tree[2],\n            'refetch'\n        ],\n        nextUrl: includeNextUrl ? state.nextUrl : null,\n        isHmrRefresh: true\n    });\n    return cache.lazyData.then((param)=>{\n        let { flightData, canonicalUrl: canonicalUrlOverride } = param;\n        // Handle case when navigating to page in `pages` from `app`\n        if (typeof flightData === 'string') {\n            return handleExternalUrl(state, mutable, flightData, state.pushRef.pendingPush);\n        }\n        // Remove cache.lazyData as it has been resolved at this point.\n        cache.lazyData = null;\n        let currentTree = state.tree;\n        let currentCache = state.cache;\n        for (const normalizedFlightData of flightData){\n            const { tree: treePatch, isRootRender } = normalizedFlightData;\n            if (!isRootRender) {\n                // TODO-APP: handle this case better\n                console.log('REFRESH FAILED');\n                return state;\n            }\n            const newTree = applyRouterStatePatchToTree(// TODO-APP: remove ''\n            [\n                ''\n            ], currentTree, treePatch, state.canonicalUrl);\n            if (newTree === null) {\n                return handleSegmentMismatch(state, action, treePatch);\n            }\n            if (isNavigatingToNewRootLayout(currentTree, newTree)) {\n                return handleExternalUrl(state, mutable, href, state.pushRef.pendingPush);\n            }\n            const canonicalUrlOverrideHref = canonicalUrlOverride ? createHrefFromUrl(canonicalUrlOverride) : undefined;\n            if (canonicalUrlOverride) {\n                mutable.canonicalUrl = canonicalUrlOverrideHref;\n            }\n            const applied = applyFlightData(navigatedAt, currentCache, cache, normalizedFlightData);\n            if (applied) {\n                mutable.cache = cache;\n                currentCache = cache;\n            }\n            mutable.patchedTree = newTree;\n            mutable.canonicalUrl = href;\n            currentTree = newTree;\n        }\n        return handleMutable(state, mutable);\n    }, ()=>state);\n}\nfunction hmrRefreshReducerNoop(state, _action) {\n    return state;\n}\nexport const hmrRefreshReducer = process.env.NODE_ENV === 'production' ? hmrRefreshReducerNoop : hmrRefreshReducerImpl;\n\n//# sourceMappingURL=hmr-refresh-reducer.js.map"
        }
    ]
}