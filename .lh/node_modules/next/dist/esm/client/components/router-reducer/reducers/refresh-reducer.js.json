{
    "sourceFile": "node_modules/next/dist/esm/client/components/router-reducer/reducers/refresh-reducer.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892783560,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import { fetchServerResponse } from '../fetch-server-response';\nimport { createHrefFromUrl } from '../create-href-from-url';\nimport { applyRouterStatePatchToTree } from '../apply-router-state-patch-to-tree';\nimport { isNavigatingToNewRootLayout } from '../is-navigating-to-new-root-layout';\nimport { handleExternalUrl } from './navigate-reducer';\nimport { handleMutable } from '../handle-mutable';\nimport { fillLazyItemsTillLeafWithHead } from '../fill-lazy-items-till-leaf-with-head';\nimport { createEmptyCacheNode } from '../../app-router';\nimport { handleSegmentMismatch } from '../handle-segment-mismatch';\nimport { hasInterceptionRouteInCurrentTree } from './has-interception-route-in-current-tree';\nimport { refreshInactiveParallelSegments } from '../refetch-inactive-parallel-segments';\nimport { revalidateEntireCache } from '../../segment-cache';\nexport function refreshReducer(state, action) {\n    const { origin } = action;\n    const mutable = {};\n    const href = state.canonicalUrl;\n    let currentTree = state.tree;\n    mutable.preserveCustomHistoryState = false;\n    const cache = createEmptyCacheNode();\n    // If the current tree was intercepted, the nextUrl should be included in the request.\n    // This is to ensure that the refresh request doesn't get intercepted, accidentally triggering the interception route.\n    const includeNextUrl = hasInterceptionRouteInCurrentTree(state.tree);\n    // TODO-APP: verify that `href` is not an external url.\n    // Fetch data from the root of the tree.\n    cache.lazyData = fetchServerResponse(new URL(href, origin), {\n        flightRouterState: [\n            currentTree[0],\n            currentTree[1],\n            currentTree[2],\n            'refetch'\n        ],\n        nextUrl: includeNextUrl ? state.nextUrl : null\n    });\n    const navigatedAt = Date.now();\n    return cache.lazyData.then(async (param)=>{\n        let { flightData, canonicalUrl: canonicalUrlOverride } = param;\n        // Handle case when navigating to page in `pages` from `app`\n        if (typeof flightData === 'string') {\n            return handleExternalUrl(state, mutable, flightData, state.pushRef.pendingPush);\n        }\n        // Remove cache.lazyData as it has been resolved at this point.\n        cache.lazyData = null;\n        for (const normalizedFlightData of flightData){\n            const { tree: treePatch, seedData: cacheNodeSeedData, head, isRootRender } = normalizedFlightData;\n            if (!isRootRender) {\n                // TODO-APP: handle this case better\n                console.log('REFRESH FAILED');\n                return state;\n            }\n            const newTree = applyRouterStatePatchToTree(// TODO-APP: remove ''\n            [\n                ''\n            ], currentTree, treePatch, state.canonicalUrl);\n            if (newTree === null) {\n                return handleSegmentMismatch(state, action, treePatch);\n            }\n            if (isNavigatingToNewRootLayout(currentTree, newTree)) {\n                return handleExternalUrl(state, mutable, href, state.pushRef.pendingPush);\n            }\n            const canonicalUrlOverrideHref = canonicalUrlOverride ? createHrefFromUrl(canonicalUrlOverride) : undefined;\n            if (canonicalUrlOverride) {\n                mutable.canonicalUrl = canonicalUrlOverrideHref;\n            }\n            // Handles case where prefetch only returns the router tree patch without rendered components.\n            if (cacheNodeSeedData !== null) {\n                const rsc = cacheNodeSeedData[1];\n                const loading = cacheNodeSeedData[3];\n                cache.rsc = rsc;\n                cache.prefetchRsc = null;\n                cache.loading = loading;\n                fillLazyItemsTillLeafWithHead(navigatedAt, cache, // Existing cache is not passed in as `router.refresh()` has to invalidate the entire cache.\n                undefined, treePatch, cacheNodeSeedData, head, undefined);\n                if (process.env.__NEXT_CLIENT_SEGMENT_CACHE) {\n                    revalidateEntireCache(state.nextUrl, newTree);\n                } else {\n                    mutable.prefetchCache = new Map();\n                }\n            }\n            await refreshInactiveParallelSegments({\n                navigatedAt,\n                state,\n                updatedTree: newTree,\n                updatedCache: cache,\n                includeNextUrl,\n                canonicalUrl: mutable.canonicalUrl || state.canonicalUrl\n            });\n            mutable.cache = cache;\n            mutable.patchedTree = newTree;\n            currentTree = newTree;\n        }\n        return handleMutable(state, mutable);\n    }, ()=>state);\n}\n\n//# sourceMappingURL=refresh-reducer.js.map"
        }
    ]
}