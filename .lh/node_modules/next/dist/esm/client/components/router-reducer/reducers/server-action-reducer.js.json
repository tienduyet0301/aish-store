{
    "sourceFile": "node_modules/next/dist/esm/client/components/router-reducer/reducers/server-action-reducer.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892783727,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import { callServer } from '../../../app-call-server';\nimport { findSourceMapURL } from '../../../app-find-source-map-url';\nimport { ACTION_HEADER, NEXT_IS_PRERENDER_HEADER, NEXT_ROUTER_STATE_TREE_HEADER, NEXT_URL, RSC_CONTENT_TYPE_HEADER } from '../../app-router-headers';\n// // eslint-disable-next-line import/no-extraneous-dependencies\n// import { createFromFetch } from 'react-server-dom-webpack/client'\n// // eslint-disable-next-line import/no-extraneous-dependencies\n// import { encodeReply } from 'react-server-dom-webpack/client'\nconst { createFromFetch, createTemporaryReferenceSet, encodeReply } = !!process.env.NEXT_RUNTIME ? require('react-server-dom-webpack/client.edge') : require('react-server-dom-webpack/client');\nimport { PrefetchKind } from '../router-reducer-types';\nimport { assignLocation } from '../../../assign-location';\nimport { createHrefFromUrl } from '../create-href-from-url';\nimport { handleExternalUrl } from './navigate-reducer';\nimport { applyRouterStatePatchToTree } from '../apply-router-state-patch-to-tree';\nimport { isNavigatingToNewRootLayout } from '../is-navigating-to-new-root-layout';\nimport { handleMutable } from '../handle-mutable';\nimport { fillLazyItemsTillLeafWithHead } from '../fill-lazy-items-till-leaf-with-head';\nimport { createEmptyCacheNode } from '../../app-router';\nimport { hasInterceptionRouteInCurrentTree } from './has-interception-route-in-current-tree';\nimport { handleSegmentMismatch } from '../handle-segment-mismatch';\nimport { refreshInactiveParallelSegments } from '../refetch-inactive-parallel-segments';\nimport { normalizeFlightData } from '../../../flight-data-helpers';\nimport { getRedirectError } from '../../redirect';\nimport { RedirectType } from '../../redirect-error';\nimport { createSeededPrefetchCacheEntry } from '../prefetch-cache-utils';\nimport { removeBasePath } from '../../../remove-base-path';\nimport { hasBasePath } from '../../../has-base-path';\nimport { extractInfoFromServerReferenceId, omitUnusedArgs } from '../../../../shared/lib/server-reference-info';\nimport { revalidateEntireCache } from '../../segment-cache';\nasync function fetchServerAction(state, nextUrl, param) {\n    let { actionId, actionArgs } = param;\n    const temporaryReferences = createTemporaryReferenceSet();\n    const info = extractInfoFromServerReferenceId(actionId);\n    // TODO: Currently, we're only omitting unused args for the experimental \"use\n    // cache\" functions. Once the server reference info byte feature is stable, we\n    // should apply this to server actions as well.\n    const usedArgs = info.type === 'use-cache' ? omitUnusedArgs(actionArgs, info) : actionArgs;\n    const body = await encodeReply(usedArgs, {\n        temporaryReferences\n    });\n    const res = await fetch('', {\n        method: 'POST',\n        headers: {\n            Accept: RSC_CONTENT_TYPE_HEADER,\n            [ACTION_HEADER]: actionId,\n            [NEXT_ROUTER_STATE_TREE_HEADER]: encodeURIComponent(JSON.stringify(state.tree)),\n            ...process.env.NEXT_DEPLOYMENT_ID ? {\n                'x-deployment-id': process.env.NEXT_DEPLOYMENT_ID\n            } : {},\n            ...nextUrl ? {\n                [NEXT_URL]: nextUrl\n            } : {}\n        },\n        body\n    });\n    const redirectHeader = res.headers.get('x-action-redirect');\n    const [location, _redirectType] = (redirectHeader == null ? void 0 : redirectHeader.split(';')) || [];\n    let redirectType;\n    switch(_redirectType){\n        case 'push':\n            redirectType = RedirectType.push;\n            break;\n        case 'replace':\n            redirectType = RedirectType.replace;\n            break;\n        default:\n            redirectType = undefined;\n    }\n    const isPrerender = !!res.headers.get(NEXT_IS_PRERENDER_HEADER);\n    let revalidatedParts;\n    try {\n        const revalidatedHeader = JSON.parse(res.headers.get('x-action-revalidated') || '[[],0,0]');\n        revalidatedParts = {\n            paths: revalidatedHeader[0] || [],\n            tag: !!revalidatedHeader[1],\n            cookie: revalidatedHeader[2]\n        };\n    } catch (e) {\n        revalidatedParts = {\n            paths: [],\n            tag: false,\n            cookie: false\n        };\n    }\n    const redirectLocation = location ? assignLocation(location, new URL(state.canonicalUrl, window.location.href)) : undefined;\n    const contentType = res.headers.get('content-type');\n    if (contentType == null ? void 0 : contentType.startsWith(RSC_CONTENT_TYPE_HEADER)) {\n        const response = await createFromFetch(Promise.resolve(res), {\n            callServer,\n            findSourceMapURL,\n            temporaryReferences\n        });\n        if (location) {\n            // if it was a redirection, then result is just a regular RSC payload\n            return {\n                actionFlightData: normalizeFlightData(response.f),\n                redirectLocation,\n                redirectType,\n                revalidatedParts,\n                isPrerender\n            };\n        }\n        return {\n            actionResult: response.a,\n            actionFlightData: normalizeFlightData(response.f),\n            redirectLocation,\n            redirectType,\n            revalidatedParts,\n            isPrerender\n        };\n    }\n    // Handle invalid server action responses\n    if (res.status >= 400) {\n        // The server can respond with a text/plain error message, but we'll fallback to something generic\n        // if there isn't one.\n        const error = contentType === 'text/plain' ? await res.text() : 'An unexpected response was received from the server.';\n        throw Object.defineProperty(new Error(error), \"__NEXT_ERROR_CODE\", {\n            value: \"E394\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    return {\n        redirectLocation,\n        redirectType,\n        revalidatedParts,\n        isPrerender\n    };\n}\n/*\n * This reducer is responsible for calling the server action and processing any side-effects from the server action.\n * It does not mutate the state by itself but rather delegates to other reducers to do the actual mutation.\n */ export function serverActionReducer(state, action) {\n    const { resolve, reject } = action;\n    const mutable = {};\n    let currentTree = state.tree;\n    mutable.preserveCustomHistoryState = false;\n    // only pass along the `nextUrl` param (used for interception routes) if the current route was intercepted.\n    // If the route has been intercepted, the action should be as well.\n    // Otherwise the server action might be intercepted with the wrong action id\n    // (ie, one that corresponds with the intercepted route)\n    const nextUrl = state.nextUrl && hasInterceptionRouteInCurrentTree(state.tree) ? state.nextUrl : null;\n    const navigatedAt = Date.now();\n    return fetchServerAction(state, nextUrl, action).then(async (param)=>{\n        let { actionResult, actionFlightData: flightData, redirectLocation, redirectType, isPrerender, revalidatedParts } = param;\n        let redirectHref;\n        // honor the redirect type instead of defaulting to push in case of server actions.\n        if (redirectLocation) {\n            if (redirectType === RedirectType.replace) {\n                state.pushRef.pendingPush = false;\n                mutable.pendingPush = false;\n            } else {\n                state.pushRef.pendingPush = true;\n                mutable.pendingPush = true;\n            }\n            redirectHref = createHrefFromUrl(redirectLocation, false);\n            mutable.canonicalUrl = redirectHref;\n        }\n        if (!flightData) {\n            resolve(actionResult);\n            // If there is a redirect but no flight data we need to do a mpaNavigation.\n            if (redirectLocation) {\n                return handleExternalUrl(state, mutable, redirectLocation.href, state.pushRef.pendingPush);\n            }\n            return state;\n        }\n        if (typeof flightData === 'string') {\n            // Handle case when navigating to page in `pages` from `app`\n            resolve(actionResult);\n            return handleExternalUrl(state, mutable, flightData, state.pushRef.pendingPush);\n        }\n        const actionRevalidated = revalidatedParts.paths.length > 0 || revalidatedParts.tag || revalidatedParts.cookie;\n        for (const normalizedFlightData of flightData){\n            const { tree: treePatch, seedData: cacheNodeSeedData, head, isRootRender } = normalizedFlightData;\n            if (!isRootRender) {\n                // TODO-APP: handle this case better\n                console.log('SERVER ACTION APPLY FAILED');\n                resolve(actionResult);\n                return state;\n            }\n            // Given the path can only have two items the items are only the router state and rsc for the root.\n            const newTree = applyRouterStatePatchToTree(// TODO-APP: remove ''\n            [\n                ''\n            ], currentTree, treePatch, redirectHref ? redirectHref : state.canonicalUrl);\n            if (newTree === null) {\n                resolve(actionResult);\n                return handleSegmentMismatch(state, action, treePatch);\n            }\n            if (isNavigatingToNewRootLayout(currentTree, newTree)) {\n                resolve(actionResult);\n                return handleExternalUrl(state, mutable, redirectHref || state.canonicalUrl, state.pushRef.pendingPush);\n            }\n            // The server sent back RSC data for the server action, so we need to apply it to the cache.\n            if (cacheNodeSeedData !== null) {\n                const rsc = cacheNodeSeedData[1];\n                const cache = createEmptyCacheNode();\n                cache.rsc = rsc;\n                cache.prefetchRsc = null;\n                cache.loading = cacheNodeSeedData[3];\n                fillLazyItemsTillLeafWithHead(navigatedAt, cache, // Existing cache is not passed in as server actions have to invalidate the entire cache.\n                undefined, treePatch, cacheNodeSeedData, head, undefined);\n                mutable.cache = cache;\n                if (process.env.__NEXT_CLIENT_SEGMENT_CACHE) {\n                    revalidateEntireCache(state.nextUrl, newTree);\n                } else {\n                    mutable.prefetchCache = new Map();\n                }\n                if (actionRevalidated) {\n                    await refreshInactiveParallelSegments({\n                        navigatedAt,\n                        state,\n                        updatedTree: newTree,\n                        updatedCache: cache,\n                        includeNextUrl: Boolean(nextUrl),\n                        canonicalUrl: mutable.canonicalUrl || state.canonicalUrl\n                    });\n                }\n            }\n            mutable.patchedTree = newTree;\n            currentTree = newTree;\n        }\n        if (redirectLocation && redirectHref) {\n            if (!process.env.__NEXT_CLIENT_SEGMENT_CACHE && !actionRevalidated) {\n                // Because the RedirectBoundary will trigger a navigation, we need to seed the prefetch cache\n                // with the FlightData that we got from the server action for the target page, so that it's\n                // available when the page is navigated to and doesn't need to be re-fetched.\n                // We only do this if the server action didn't revalidate any data, as in that case the\n                // client cache will be cleared and the data will be re-fetched anyway.\n                // NOTE: We don't do this in the Segment Cache implementation.\n                // Dynamic data should never be placed into the cache, unless it's\n                // \"converted\" to static data using <Link prefetch={true}>. What we\n                // do instead is re-prefetch links and forms whenever the cache is\n                // invalidated.\n                createSeededPrefetchCacheEntry({\n                    url: redirectLocation,\n                    data: {\n                        flightData,\n                        canonicalUrl: undefined,\n                        couldBeIntercepted: false,\n                        prerendered: false,\n                        postponed: false,\n                        // TODO: We should be able to set this if the server action\n                        // returned a fully static response.\n                        staleTime: -1\n                    },\n                    tree: state.tree,\n                    prefetchCache: state.prefetchCache,\n                    nextUrl: state.nextUrl,\n                    kind: isPrerender ? PrefetchKind.FULL : PrefetchKind.AUTO\n                });\n                mutable.prefetchCache = state.prefetchCache;\n            }\n            // If the action triggered a redirect, the action promise will be rejected with\n            // a redirect so that it's handled by RedirectBoundary as we won't have a valid\n            // action result to resolve the promise with. This will effectively reset the state of\n            // the component that called the action as the error boundary will remount the tree.\n            // The status code doesn't matter here as the action handler will have already sent\n            // a response with the correct status code.\n            reject(getRedirectError(hasBasePath(redirectHref) ? removeBasePath(redirectHref) : redirectHref, redirectType || RedirectType.push));\n        } else {\n            resolve(actionResult);\n        }\n        return handleMutable(state, mutable);\n    }, (e)=>{\n        // When the server action is rejected we don't update the state and instead call the reject handler of the promise.\n        reject(e);\n        return state;\n    });\n}\n\n//# sourceMappingURL=server-action-reducer.js.map"
        }
    ]
}