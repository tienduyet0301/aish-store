{
    "sourceFile": "node_modules/next/dist/esm/client/index.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892787596,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/* global location */ // imports polyfill from `@next/polyfill-module` after build.\nimport { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from \"react/jsx-runtime\";\nimport '../build/polyfills/polyfill-module';\nimport React from 'react';\nimport ReactDOM from 'react-dom/client';\nimport { HeadManagerContext } from '../shared/lib/head-manager-context.shared-runtime';\nimport mitt from '../shared/lib/mitt';\nimport { RouterContext } from '../shared/lib/router-context.shared-runtime';\nimport { handleSmoothScroll } from '../shared/lib/router/utils/handle-smooth-scroll';\nimport { isDynamicRoute } from '../shared/lib/router/utils/is-dynamic';\nimport { urlQueryToSearchParams, assign } from '../shared/lib/router/utils/querystring';\nimport { setConfig } from '../shared/lib/runtime-config.external';\nimport { getURL, loadGetInitialProps, ST } from '../shared/lib/utils';\nimport { Portal } from './portal';\nimport initHeadManager from './head-manager';\nimport PageLoader from './page-loader';\nimport { RouteAnnouncer } from './route-announcer';\nimport { createRouter, makePublicRouterInstance } from './router';\nimport { getProperError } from '../lib/is-error';\nimport { ImageConfigContext } from '../shared/lib/image-config-context.shared-runtime';\nimport { removeBasePath } from './remove-base-path';\nimport { hasBasePath } from './has-base-path';\nimport { AppRouterContext } from '../shared/lib/app-router-context.shared-runtime';\nimport { adaptForAppRouterInstance, adaptForPathParams, adaptForSearchParams, PathnameContextProviderAdapter } from '../shared/lib/router/adapters';\nimport { SearchParamsContext, PathParamsContext } from '../shared/lib/hooks-client-context.shared-runtime';\nimport { onRecoverableError } from './react-client-callbacks/on-recoverable-error';\nimport tracer from './tracing/tracer';\nimport { isNextRouterError } from './components/is-next-router-error';\nexport const version = \"15.3.1\";\nexport let router;\nexport const emitter = mitt();\nconst looseToArray = (input)=>[].slice.call(input);\nlet initialData;\nlet defaultLocale = undefined;\nlet asPath;\nlet pageLoader;\nlet appElement;\nlet headManager;\nlet initialMatchesMiddleware = false;\nlet lastAppProps;\nlet lastRenderReject;\nlet devClient;\nlet CachedApp, onPerfEntry;\nlet CachedComponent;\nclass Container extends React.Component {\n    componentDidCatch(componentErr, info) {\n        this.props.fn(componentErr, info);\n    }\n    componentDidMount() {\n        this.scrollToHash();\n        // We need to replace the router state if:\n        // - the page was (auto) exported and has a query string or search (hash)\n        // - it was auto exported and is a dynamic route (to provide params)\n        // - if it is a client-side skeleton (fallback render)\n        // - if middleware matches the current page (may have rewrite params)\n        // - if rewrites in next.config.js match (may have rewrite params)\n        if (router.isSsr && (initialData.isFallback || initialData.nextExport && (isDynamicRoute(router.pathname) || location.search || process.env.__NEXT_HAS_REWRITES || initialMatchesMiddleware) || initialData.props && initialData.props.__N_SSG && (location.search || process.env.__NEXT_HAS_REWRITES || initialMatchesMiddleware))) {\n            // update query on mount for exported pages\n            router.replace(router.pathname + '?' + String(assign(urlQueryToSearchParams(router.query), new URLSearchParams(location.search))), asPath, {\n                // @ts-ignore\n                // WARNING: `_h` is an internal option for handing Next.js\n                // client-side hydration. Your app should _never_ use this property.\n                // It may change at any time without notice.\n                _h: 1,\n                // Fallback pages must trigger the data fetch, so the transition is\n                // not shallow.\n                // Other pages (strictly updating query) happens shallowly, as data\n                // requirements would already be present.\n                shallow: !initialData.isFallback && !initialMatchesMiddleware\n            }).catch((err)=>{\n                if (!err.cancelled) throw err;\n            });\n        }\n    }\n    componentDidUpdate() {\n        this.scrollToHash();\n    }\n    scrollToHash() {\n        let { hash } = location;\n        hash = hash && hash.substring(1);\n        if (!hash) return;\n        const el = document.getElementById(hash);\n        if (!el) return;\n        // If we call scrollIntoView() in here without a setTimeout\n        // it won't scroll properly.\n        setTimeout(()=>el.scrollIntoView(), 0);\n    }\n    render() {\n        if (process.env.NODE_ENV === 'production') {\n            return this.props.children;\n        } else {\n            const { PagesDevOverlay } = require('./components/react-dev-overlay/pages/pages-dev-overlay');\n            return /*#__PURE__*/ _jsx(PagesDevOverlay, {\n                children: this.props.children\n            });\n        }\n    }\n}\nexport async function initialize(opts) {\n    if (opts === void 0) opts = {};\n    // This makes sure this specific lines are removed in production\n    if (process.env.NODE_ENV === 'development') {\n        tracer.onSpanEnd(require('./tracing/report-to-socket').default);\n        devClient = opts.devClient;\n    }\n    initialData = JSON.parse(document.getElementById('__NEXT_DATA__').textContent);\n    window.__NEXT_DATA__ = initialData;\n    defaultLocale = initialData.defaultLocale;\n    const prefix = initialData.assetPrefix || '';\n    self.__next_set_public_path__(\"\" + prefix + \"/_next/\") //eslint-disable-line\n    ;\n    // Initialize next/config with the environment configuration\n    setConfig({\n        serverRuntimeConfig: {},\n        publicRuntimeConfig: initialData.runtimeConfig || {}\n    });\n    asPath = getURL();\n    // make sure not to attempt stripping basePath for 404s\n    if (hasBasePath(asPath)) {\n        asPath = removeBasePath(asPath);\n    }\n    if (process.env.__NEXT_I18N_SUPPORT) {\n        const { normalizeLocalePath } = require('../shared/lib/i18n/normalize-locale-path');\n        const { detectDomainLocale } = require('../shared/lib/i18n/detect-domain-locale');\n        const { parseRelativeUrl } = require('../shared/lib/router/utils/parse-relative-url');\n        const { formatUrl } = require('../shared/lib/router/utils/format-url');\n        if (initialData.locales) {\n            const parsedAs = parseRelativeUrl(asPath);\n            const localePathResult = normalizeLocalePath(parsedAs.pathname, initialData.locales);\n            if (localePathResult.detectedLocale) {\n                parsedAs.pathname = localePathResult.pathname;\n                asPath = formatUrl(parsedAs);\n            } else {\n                // derive the default locale if it wasn't detected in the asPath\n                // since we don't prerender static pages with all possible default\n                // locales\n                defaultLocale = initialData.locale;\n            }\n            // attempt detecting default locale based on hostname\n            const detectedDomain = detectDomainLocale(process.env.__NEXT_I18N_DOMAINS, window.location.hostname);\n            // TODO: investigate if defaultLocale needs to be populated after\n            // hydration to prevent mismatched renders\n            if (detectedDomain) {\n                defaultLocale = detectedDomain.defaultLocale;\n            }\n        }\n    }\n    if (initialData.scriptLoader) {\n        const { initScriptLoader } = require('./script');\n        initScriptLoader(initialData.scriptLoader);\n    }\n    pageLoader = new PageLoader(initialData.buildId, prefix);\n    const register = (param)=>{\n        let [r, f] = param;\n        return pageLoader.routeLoader.onEntrypoint(r, f);\n    };\n    if (window.__NEXT_P) {\n        // Defer page registration for another tick. This will increase the overall\n        // latency in hydrating the page, but reduce the total blocking time.\n        window.__NEXT_P.map((p)=>setTimeout(()=>register(p), 0));\n    }\n    window.__NEXT_P = [];\n    window.__NEXT_P.push = register;\n    headManager = initHeadManager();\n    headManager.getIsSsr = ()=>{\n        return router.isSsr;\n    };\n    appElement = document.getElementById('__next');\n    return {\n        assetPrefix: prefix\n    };\n}\nfunction renderApp(App, appProps) {\n    return /*#__PURE__*/ _jsx(App, {\n        ...appProps\n    });\n}\nfunction AppContainer(param) {\n    let { children } = param;\n    // Create a memoized value for next/navigation router context.\n    const adaptedForAppRouter = React.useMemo(()=>{\n        return adaptForAppRouterInstance(router);\n    }, []);\n    var _self___NEXT_DATA___autoExport;\n    return /*#__PURE__*/ _jsx(Container, {\n        fn: (error)=>// TODO: Fix disabled eslint rule\n            // eslint-disable-next-line @typescript-eslint/no-use-before-define\n            renderError({\n                App: CachedApp,\n                err: error\n            }).catch((err)=>console.error('Error rendering page: ', err)),\n        children: /*#__PURE__*/ _jsx(AppRouterContext.Provider, {\n            value: adaptedForAppRouter,\n            children: /*#__PURE__*/ _jsx(SearchParamsContext.Provider, {\n                value: adaptForSearchParams(router),\n                children: /*#__PURE__*/ _jsx(PathnameContextProviderAdapter, {\n                    router: router,\n                    isAutoExport: (_self___NEXT_DATA___autoExport = self.__NEXT_DATA__.autoExport) != null ? _self___NEXT_DATA___autoExport : false,\n                    children: /*#__PURE__*/ _jsx(PathParamsContext.Provider, {\n                        value: adaptForPathParams(router),\n                        children: /*#__PURE__*/ _jsx(RouterContext.Provider, {\n                            value: makePublicRouterInstance(router),\n                            children: /*#__PURE__*/ _jsx(HeadManagerContext.Provider, {\n                                value: headManager,\n                                children: /*#__PURE__*/ _jsx(ImageConfigContext.Provider, {\n                                    value: process.env.__NEXT_IMAGE_OPTS,\n                                    children: children\n                                })\n                            })\n                        })\n                    })\n                })\n            })\n        })\n    });\n}\nconst wrapApp = (App)=>(wrappedAppProps)=>{\n        const appProps = {\n            ...wrappedAppProps,\n            Component: CachedComponent,\n            err: initialData.err,\n            router\n        };\n        return /*#__PURE__*/ _jsx(AppContainer, {\n            children: renderApp(App, appProps)\n        });\n    };\n// This method handles all runtime and debug errors.\n// 404 and 500 errors are special kind of errors\n// and they are still handle via the main render method.\nfunction renderError(renderErrorProps) {\n    let { App, err } = renderErrorProps;\n    // In development runtime errors are caught by our overlay\n    // In production we catch runtime errors using componentDidCatch which will trigger renderError\n    if (process.env.NODE_ENV !== 'production') {\n        // A Next.js rendering runtime error is always unrecoverable\n        // FIXME: let's make this recoverable (error in GIP client-transition)\n        devClient.onUnrecoverableError();\n        // We need to render an empty <App> so that the `<ReactDevOverlay>` can\n        // render itself.\n        // TODO: Fix disabled eslint rule\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return doRender({\n            App: ()=>null,\n            props: {},\n            Component: ()=>null,\n            styleSheets: []\n        });\n    }\n    // Make sure we log the error to the console, otherwise users can't track down issues.\n    console.error(err);\n    console.error(\"A client-side exception has occurred, see here for more info: https://nextjs.org/docs/messages/client-side-exception-occurred\");\n    return pageLoader.loadPage('/_error').then((param)=>{\n        let { page: ErrorComponent, styleSheets } = param;\n        return (lastAppProps == null ? void 0 : lastAppProps.Component) === ErrorComponent ? import('../pages/_error').then((errorModule)=>{\n            return import('../pages/_app').then((appModule)=>{\n                App = appModule.default;\n                renderErrorProps.App = App;\n                return errorModule;\n            });\n        }).then((m)=>({\n                ErrorComponent: m.default,\n                styleSheets: []\n            })) : {\n            ErrorComponent,\n            styleSheets\n        };\n    }).then((param)=>{\n        let { ErrorComponent, styleSheets } = param;\n        var _renderErrorProps_props;\n        // In production we do a normal render with the `ErrorComponent` as component.\n        // If we've gotten here upon initial render, we can use the props from the server.\n        // Otherwise, we need to call `getInitialProps` on `App` before mounting.\n        const AppTree = wrapApp(App);\n        const appCtx = {\n            Component: ErrorComponent,\n            AppTree,\n            router,\n            ctx: {\n                err,\n                pathname: initialData.page,\n                query: initialData.query,\n                asPath,\n                AppTree\n            }\n        };\n        return Promise.resolve(((_renderErrorProps_props = renderErrorProps.props) == null ? void 0 : _renderErrorProps_props.err) ? renderErrorProps.props : loadGetInitialProps(App, appCtx)).then((initProps)=>// TODO: Fix disabled eslint rule\n            // eslint-disable-next-line @typescript-eslint/no-use-before-define\n            doRender({\n                ...renderErrorProps,\n                err,\n                Component: ErrorComponent,\n                styleSheets,\n                props: initProps\n            }));\n    });\n}\n// Dummy component that we render as a child of Root so that we can\n// toggle the correct styles before the page is rendered.\nfunction Head(param) {\n    let { callback } = param;\n    // We use `useLayoutEffect` to guarantee the callback is executed\n    // as soon as React flushes the update.\n    React.useLayoutEffect(()=>callback(), [\n        callback\n    ]);\n    return null;\n}\nconst performanceMarks = {\n    navigationStart: 'navigationStart',\n    beforeRender: 'beforeRender',\n    afterRender: 'afterRender',\n    afterHydrate: 'afterHydrate',\n    routeChange: 'routeChange'\n};\nconst performanceMeasures = {\n    hydration: 'Next.js-hydration',\n    beforeHydration: 'Next.js-before-hydration',\n    routeChangeToRender: 'Next.js-route-change-to-render',\n    render: 'Next.js-render'\n};\nlet reactRoot = null;\n// On initial render a hydrate should always happen\nlet shouldHydrate = true;\nfunction clearMarks() {\n    ;\n    [\n        performanceMarks.beforeRender,\n        performanceMarks.afterHydrate,\n        performanceMarks.afterRender,\n        performanceMarks.routeChange\n    ].forEach((mark)=>performance.clearMarks(mark));\n}\nfunction markHydrateComplete() {\n    if (!ST) return;\n    performance.mark(performanceMarks.afterHydrate) // mark end of hydration\n    ;\n    const hasBeforeRenderMark = performance.getEntriesByName(performanceMarks.beforeRender, 'mark').length;\n    if (hasBeforeRenderMark) {\n        const beforeHydrationMeasure = performance.measure(performanceMeasures.beforeHydration, performanceMarks.navigationStart, performanceMarks.beforeRender);\n        const hydrationMeasure = performance.measure(performanceMeasures.hydration, performanceMarks.beforeRender, performanceMarks.afterHydrate);\n        if (process.env.NODE_ENV === 'development' && // Old versions of Safari don't return `PerformanceMeasure`s from `performance.measure()`\n        beforeHydrationMeasure && hydrationMeasure) {\n            tracer.startSpan('navigation-to-hydration', {\n                startTime: performance.timeOrigin + beforeHydrationMeasure.startTime,\n                attributes: {\n                    pathname: location.pathname,\n                    query: location.search\n                }\n            }).end(performance.timeOrigin + hydrationMeasure.startTime + hydrationMeasure.duration);\n        }\n    }\n    if (onPerfEntry) {\n        performance.getEntriesByName(performanceMeasures.hydration).forEach(onPerfEntry);\n    }\n    clearMarks();\n}\nfunction markRenderComplete() {\n    if (!ST) return;\n    performance.mark(performanceMarks.afterRender) // mark end of render\n    ;\n    const navStartEntries = performance.getEntriesByName(performanceMarks.routeChange, 'mark');\n    if (!navStartEntries.length) return;\n    const hasBeforeRenderMark = performance.getEntriesByName(performanceMarks.beforeRender, 'mark').length;\n    if (hasBeforeRenderMark) {\n        performance.measure(performanceMeasures.routeChangeToRender, navStartEntries[0].name, performanceMarks.beforeRender);\n        performance.measure(performanceMeasures.render, performanceMarks.beforeRender, performanceMarks.afterRender);\n        if (onPerfEntry) {\n            performance.getEntriesByName(performanceMeasures.render).forEach(onPerfEntry);\n            performance.getEntriesByName(performanceMeasures.routeChangeToRender).forEach(onPerfEntry);\n        }\n    }\n    clearMarks();\n    [\n        performanceMeasures.routeChangeToRender,\n        performanceMeasures.render\n    ].forEach((measure)=>performance.clearMeasures(measure));\n}\nfunction renderReactElement(domEl, fn) {\n    // mark start of hydrate/render\n    if (ST) {\n        performance.mark(performanceMarks.beforeRender);\n    }\n    const reactEl = fn(shouldHydrate ? markHydrateComplete : markRenderComplete);\n    if (!reactRoot) {\n        // Unlike with createRoot, you don't need a separate root.render() call here\n        reactRoot = ReactDOM.hydrateRoot(domEl, reactEl, {\n            onRecoverableError\n        });\n        // TODO: Remove shouldHydrate variable when React 18 is stable as it can depend on `reactRoot` existing\n        shouldHydrate = false;\n    } else {\n        const startTransition = React.startTransition;\n        startTransition(()=>{\n            reactRoot.render(reactEl);\n        });\n    }\n}\nfunction Root(param) {\n    let { callbacks, children } = param;\n    // We use `useLayoutEffect` to guarantee the callbacks are executed\n    // as soon as React flushes the update\n    React.useLayoutEffect(()=>callbacks.forEach((callback)=>callback()), [\n        callbacks\n    ]);\n    if (process.env.__NEXT_TEST_MODE) {\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        React.useEffect(()=>{\n            window.__NEXT_HYDRATED = true;\n            window.__NEXT_HYDRATED_AT = performance.now();\n            if (window.__NEXT_HYDRATED_CB) {\n                window.__NEXT_HYDRATED_CB();\n            }\n        }, []);\n    }\n    return children;\n}\nfunction doRender(input) {\n    let { App, Component, props, err } = input;\n    let styleSheets = 'initial' in input ? undefined : input.styleSheets;\n    Component = Component || lastAppProps.Component;\n    props = props || lastAppProps.props;\n    const appProps = {\n        ...props,\n        Component,\n        err,\n        router\n    };\n    // lastAppProps has to be set before ReactDom.render to account for ReactDom throwing an error.\n    lastAppProps = appProps;\n    let canceled = false;\n    let resolvePromise;\n    const renderPromise = new Promise((resolve, reject)=>{\n        if (lastRenderReject) {\n            lastRenderReject();\n        }\n        resolvePromise = ()=>{\n            lastRenderReject = null;\n            resolve();\n        };\n        lastRenderReject = ()=>{\n            canceled = true;\n            lastRenderReject = null;\n            const error = Object.defineProperty(new Error('Cancel rendering route'), \"__NEXT_ERROR_CODE\", {\n                value: \"E503\",\n                enumerable: false,\n                configurable: true\n            });\n            error.cancelled = true;\n            reject(error);\n        };\n    });\n    // This function has a return type to ensure it doesn't start returning a\n    // Promise. It should remain synchronous.\n    function onStart() {\n        if (!styleSheets || // We use `style-loader` in development, so we don't need to do anything\n        // unless we're in production:\n        process.env.NODE_ENV !== 'production') {\n            return false;\n        }\n        const currentStyleTags = looseToArray(document.querySelectorAll('style[data-n-href]'));\n        const currentHrefs = new Set(currentStyleTags.map((tag)=>tag.getAttribute('data-n-href')));\n        const noscript = document.querySelector('noscript[data-n-css]');\n        const nonce = noscript == null ? void 0 : noscript.getAttribute('data-n-css');\n        styleSheets.forEach((param)=>{\n            let { href, text } = param;\n            if (!currentHrefs.has(href)) {\n                const styleTag = document.createElement('style');\n                styleTag.setAttribute('data-n-href', href);\n                styleTag.setAttribute('media', 'x');\n                if (nonce) {\n                    styleTag.setAttribute('nonce', nonce);\n                }\n                document.head.appendChild(styleTag);\n                styleTag.appendChild(document.createTextNode(text));\n            }\n        });\n        return true;\n    }\n    function onHeadCommit() {\n        if (// Turbopack has it's own css injection handling, this code ends up removing the CSS.\n        !process.env.TURBOPACK && // We use `style-loader` in development, so we don't need to do anything\n        // unless we're in production:\n        process.env.NODE_ENV === 'production' && // We can skip this during hydration. Running it wont cause any harm, but\n        // we may as well save the CPU cycles:\n        styleSheets && // Ensure this render was not canceled\n        !canceled) {\n            const desiredHrefs = new Set(styleSheets.map((s)=>s.href));\n            const currentStyleTags = looseToArray(document.querySelectorAll('style[data-n-href]'));\n            const currentHrefs = currentStyleTags.map((tag)=>tag.getAttribute('data-n-href'));\n            // Toggle `<style>` tags on or off depending on if they're needed:\n            for(let idx = 0; idx < currentHrefs.length; ++idx){\n                if (desiredHrefs.has(currentHrefs[idx])) {\n                    currentStyleTags[idx].removeAttribute('media');\n                } else {\n                    currentStyleTags[idx].setAttribute('media', 'x');\n                }\n            }\n            // Reorder styles into intended order:\n            let referenceNode = document.querySelector('noscript[data-n-css]');\n            if (// This should be an invariant:\n            referenceNode) {\n                styleSheets.forEach((param)=>{\n                    let { href } = param;\n                    const targetTag = document.querySelector('style[data-n-href=\"' + href + '\"]');\n                    if (// This should be an invariant:\n                    targetTag) {\n                        referenceNode.parentNode.insertBefore(targetTag, referenceNode.nextSibling);\n                        referenceNode = targetTag;\n                    }\n                });\n            }\n            // Finally, clean up server rendered stylesheets:\n            looseToArray(document.querySelectorAll('link[data-n-p]')).forEach((el)=>{\n                el.parentNode.removeChild(el);\n            });\n        }\n        if (input.scroll) {\n            const { x, y } = input.scroll;\n            handleSmoothScroll(()=>{\n                window.scrollTo(x, y);\n            });\n        }\n    }\n    function onRootCommit() {\n        resolvePromise();\n    }\n    onStart();\n    const elem = /*#__PURE__*/ _jsxs(_Fragment, {\n        children: [\n            /*#__PURE__*/ _jsx(Head, {\n                callback: onHeadCommit\n            }),\n            /*#__PURE__*/ _jsxs(AppContainer, {\n                children: [\n                    renderApp(App, appProps),\n                    /*#__PURE__*/ _jsx(Portal, {\n                        type: \"next-route-announcer\",\n                        children: /*#__PURE__*/ _jsx(RouteAnnouncer, {})\n                    })\n                ]\n            })\n        ]\n    });\n    // We catch runtime errors using componentDidCatch which will trigger renderError\n    renderReactElement(appElement, (callback)=>/*#__PURE__*/ _jsx(Root, {\n            callbacks: [\n                callback,\n                onRootCommit\n            ],\n            children: process.env.__NEXT_STRICT_MODE ? /*#__PURE__*/ _jsx(React.StrictMode, {\n                children: elem\n            }) : elem\n        }));\n    return renderPromise;\n}\nasync function render(renderingProps) {\n    // if an error occurs in a server-side page (e.g. in getInitialProps),\n    // skip re-rendering the error page client-side as data-fetching operations\n    // will already have been done on the server and NEXT_DATA contains the correct\n    // data for straight-forward hydration of the error page\n    if (renderingProps.err && // renderingProps.Component might be undefined if there is a top/module-level error\n    (typeof renderingProps.Component === 'undefined' || !renderingProps.isHydratePass)) {\n        await renderError(renderingProps);\n        return;\n    }\n    try {\n        await doRender(renderingProps);\n    } catch (err) {\n        const renderErr = getProperError(err);\n        // bubble up cancelation errors\n        if (renderErr.cancelled) {\n            throw renderErr;\n        }\n        if (process.env.NODE_ENV === 'development') {\n            // Ensure this error is displayed in the overlay in development\n            setTimeout(()=>{\n                throw renderErr;\n            });\n        }\n        await renderError({\n            ...renderingProps,\n            err: renderErr\n        });\n    }\n}\nexport async function hydrate(opts) {\n    let initialErr = initialData.err;\n    try {\n        const appEntrypoint = await pageLoader.routeLoader.whenEntrypoint('/_app');\n        if ('error' in appEntrypoint) {\n            throw appEntrypoint.error;\n        }\n        const { component: app, exports: mod } = appEntrypoint;\n        CachedApp = app;\n        if (mod && mod.reportWebVitals) {\n            onPerfEntry = (param)=>{\n                let { id, name, startTime, value, duration, entryType, entries, attribution } = param;\n                // Combines timestamp with random number for unique ID\n                const uniqueID = Date.now() + \"-\" + (Math.floor(Math.random() * (9e12 - 1)) + 1e12);\n                let perfStartEntry;\n                if (entries && entries.length) {\n                    perfStartEntry = entries[0].startTime;\n                }\n                const webVitals = {\n                    id: id || uniqueID,\n                    name,\n                    startTime: startTime || perfStartEntry,\n                    value: value == null ? duration : value,\n                    label: entryType === 'mark' || entryType === 'measure' ? 'custom' : 'web-vital'\n                };\n                if (attribution) {\n                    webVitals.attribution = attribution;\n                }\n                mod.reportWebVitals(webVitals);\n            };\n        }\n        const pageEntrypoint = // The dev server fails to serve script assets when there's a hydration\n        // error, so we need to skip waiting for the entrypoint.\n        process.env.NODE_ENV === 'development' && initialData.err ? {\n            error: initialData.err\n        } : await pageLoader.routeLoader.whenEntrypoint(initialData.page);\n        if ('error' in pageEntrypoint) {\n            throw pageEntrypoint.error;\n        }\n        CachedComponent = pageEntrypoint.component;\n        if (process.env.NODE_ENV !== 'production') {\n            const { isValidElementType } = require('next/dist/compiled/react-is');\n            if (!isValidElementType(CachedComponent)) {\n                throw Object.defineProperty(new Error('The default export is not a React Component in page: \"' + initialData.page + '\"'), \"__NEXT_ERROR_CODE\", {\n                    value: \"E286\",\n                    enumerable: false,\n                    configurable: true\n                });\n            }\n        }\n    } catch (error) {\n        // This catches errors like throwing in the top level of a module\n        initialErr = getProperError(error);\n    }\n    if (process.env.NODE_ENV === 'development') {\n        const getServerError = require('./components/react-dev-overlay/pages/client').getServerError;\n        // Server-side runtime errors need to be re-thrown on the client-side so\n        // that the overlay is rendered.\n        if (initialErr) {\n            if (initialErr === initialData.err) {\n                setTimeout(()=>{\n                    let error;\n                    try {\n                        // Generate a new error object. We `throw` it because some browsers\n                        // will set the `stack` when thrown, and we want to ensure ours is\n                        // not overridden when we re-throw it below.\n                        throw Object.defineProperty(new Error(initialErr.message), \"__NEXT_ERROR_CODE\", {\n                            value: \"E394\",\n                            enumerable: false,\n                            configurable: true\n                        });\n                    } catch (e) {\n                        error = e;\n                    }\n                    error.name = initialErr.name;\n                    error.stack = initialErr.stack;\n                    const errSource = initialErr.source;\n                    // In development, error the navigation API usage in runtime,\n                    // since it's not allowed to be used in pages router as it doesn't contain error boundary like app router.\n                    if (isNextRouterError(initialErr)) {\n                        error.message = 'Next.js navigation API is not allowed to be used in Pages Router.';\n                    }\n                    throw getServerError(error, errSource);\n                });\n            } else {\n                setTimeout(()=>{\n                    throw initialErr;\n                });\n            }\n        }\n    }\n    if (window.__NEXT_PRELOADREADY) {\n        await window.__NEXT_PRELOADREADY(initialData.dynamicIds);\n    }\n    router = createRouter(initialData.page, initialData.query, asPath, {\n        initialProps: initialData.props,\n        pageLoader,\n        App: CachedApp,\n        Component: CachedComponent,\n        wrapApp,\n        err: initialErr,\n        isFallback: Boolean(initialData.isFallback),\n        subscription: (info, App, scroll)=>render(Object.assign({}, info, {\n                App,\n                scroll\n            })),\n        locale: initialData.locale,\n        locales: initialData.locales,\n        defaultLocale,\n        domainLocales: initialData.domainLocales,\n        isPreview: initialData.isPreview\n    });\n    initialMatchesMiddleware = await router._initialMatchesMiddlewarePromise;\n    const renderCtx = {\n        App: CachedApp,\n        initial: true,\n        Component: CachedComponent,\n        props: initialData.props,\n        err: initialErr,\n        isHydratePass: true\n    };\n    if (opts == null ? void 0 : opts.beforeRender) {\n        await opts.beforeRender();\n    }\n    render(renderCtx);\n}\n\n//# sourceMappingURL=index.js.map"
        }
    ]
}