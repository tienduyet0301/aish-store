{
    "sourceFile": "node_modules/next/dist/esm/client/react-client-callbacks/error-boundary-callbacks.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892790491,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "// This file is only used in app router due to the specific error state handling.\nimport { getReactStitchedError } from '../components/errors/stitched-error';\nimport { handleClientError } from '../components/errors/use-error-handler';\nimport { isNextRouterError } from '../components/is-next-router-error';\nimport { isBailoutToCSRError } from '../../shared/lib/lazy-dynamic/bailout-to-csr';\nimport { reportGlobalError } from './report-global-error';\nimport { originConsoleError } from '../components/globals/intercept-console-error';\nimport { ErrorBoundaryHandler, GlobalError as DefaultErrorBoundary } from '../components/error-boundary';\nexport function onCaughtError(err, errorInfo) {\n    var _errorInfo_errorBoundary;\n    const errorBoundaryComponent = (_errorInfo_errorBoundary = errorInfo.errorBoundary) == null ? void 0 : _errorInfo_errorBoundary.constructor;\n    let isImplicitErrorBoundary;\n    if (process.env.NODE_ENV !== 'production') {\n        const { AppDevOverlayErrorBoundary } = require('../components/react-dev-overlay/app/app-dev-overlay-error-boundary');\n        isImplicitErrorBoundary = errorBoundaryComponent === AppDevOverlayErrorBoundary;\n    }\n    isImplicitErrorBoundary = isImplicitErrorBoundary || errorBoundaryComponent === ErrorBoundaryHandler && errorInfo.errorBoundary.props.errorComponent === DefaultErrorBoundary;\n    if (isImplicitErrorBoundary) {\n        // We don't consider errors caught unless they're caught by an explicit error\n        // boundary. The built-in ones are considered implicit.\n        // This mimics how the same app would behave without Next.js.\n        return onUncaughtError(err, errorInfo);\n    }\n    // Skip certain custom errors which are not expected to be reported on client\n    if (isBailoutToCSRError(err) || isNextRouterError(err)) return;\n    if (process.env.NODE_ENV !== 'production') {\n        var _errorInfo_componentStack;\n        const errorBoundaryName = (// read react component displayName\n        errorBoundaryComponent == null ? void 0 : errorBoundaryComponent.displayName) || (errorBoundaryComponent == null ? void 0 : errorBoundaryComponent.name) || 'Unknown';\n        const componentThatErroredFrame = errorInfo == null ? void 0 : (_errorInfo_componentStack = errorInfo.componentStack) == null ? void 0 : _errorInfo_componentStack.split('\\n')[1];\n        var // regex to match the function name in the stack trace\n        // example 1: at Page (http://localhost:3000/_next/static/chunks/pages/index.js?ts=1631600000000:2:1)\n        // example 2: Page@http://localhost:3000/_next/static/chunks/pages/index.js?ts=1631600000000:2:1\n        _componentThatErroredFrame_match;\n        // Match chrome or safari stack trace\n        const matches = (_componentThatErroredFrame_match = componentThatErroredFrame == null ? void 0 : componentThatErroredFrame.match(/\\s+at (\\w+)\\s+|(\\w+)@/)) != null ? _componentThatErroredFrame_match : [];\n        const componentThatErroredName = matches[1] || matches[2] || 'Unknown';\n        // Create error location with errored component and error boundary, to match the behavior of default React onCaughtError handler.\n        const errorBoundaryMessage = \"It was handled by the <\" + errorBoundaryName + \"> error boundary.\";\n        const componentErrorMessage = componentThatErroredName ? \"The above error occurred in the <\" + componentThatErroredName + \"> component.\" : \"The above error occurred in one of your components.\";\n        const errorLocation = componentErrorMessage + \" \" + errorBoundaryMessage;\n        const stitchedError = getReactStitchedError(err);\n        // TODO: change to passing down errorInfo later\n        // In development mode, pass along the component stack to the error\n        if (errorInfo.componentStack) {\n            ;\n            stitchedError._componentStack = errorInfo.componentStack;\n        }\n        // Log and report the error with location but without modifying the error stack\n        originConsoleError('%o\\n\\n%s', err, errorLocation);\n        handleClientError(stitchedError);\n    } else {\n        originConsoleError(err);\n    }\n}\nexport function onUncaughtError(err, errorInfo) {\n    // Skip certain custom errors which are not expected to be reported on client\n    if (isBailoutToCSRError(err) || isNextRouterError(err)) return;\n    if (process.env.NODE_ENV !== 'production') {\n        const stitchedError = getReactStitchedError(err);\n        // TODO: change to passing down errorInfo later\n        // In development mode, pass along the component stack to the error\n        if (errorInfo.componentStack) {\n            ;\n            stitchedError._componentStack = errorInfo.componentStack;\n        }\n        // TODO: Add an adendum to the overlay telling people about custom error boundaries.\n        reportGlobalError(stitchedError);\n    } else {\n        reportGlobalError(err);\n    }\n}\n\n//# sourceMappingURL=error-boundary-callbacks.js.map"
        }
    ]
}