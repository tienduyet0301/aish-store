{
    "sourceFile": "node_modules/next/dist/esm/client/app-webpack.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892763096,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "// Override chunk URL mapping in the webpack runtime\n// https://github.com/webpack/webpack/blob/2738eebc7880835d88c727d364ad37f3ec557593/lib/RuntimeGlobals.js#L204\nimport { getDeploymentIdQueryOrEmptyString } from '../build/deployment-id';\nimport { encodeURIPath } from '../shared/lib/encode-uri-path';\n// If we have a deployment ID, we need to append it to the webpack chunk names\n// I am keeping the process check explicit so this can be statically optimized\nif (process.env.NEXT_DEPLOYMENT_ID) {\n    const suffix = getDeploymentIdQueryOrEmptyString();\n    // eslint-disable-next-line no-undef\n    const getChunkScriptFilename = __webpack_require__.u;\n    // eslint-disable-next-line no-undef\n    __webpack_require__.u = function() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        return(// We encode the chunk filename because our static server matches against and encoded\n        // filename path.\n        encodeURIPath(getChunkScriptFilename(...args)) + suffix);\n    };\n    // eslint-disable-next-line no-undef\n    const getChunkCssFilename = __webpack_require__.k;\n    // eslint-disable-next-line no-undef\n    __webpack_require__.k = function() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        return getChunkCssFilename(...args) + suffix;\n    };\n    // eslint-disable-next-line no-undef\n    const getMiniCssFilename = __webpack_require__.miniCssF;\n    // eslint-disable-next-line no-undef\n    __webpack_require__.miniCssF = function() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        return getMiniCssFilename(...args) + suffix;\n    };\n} else {\n    // eslint-disable-next-line no-undef\n    const getChunkScriptFilename = __webpack_require__.u;\n    // eslint-disable-next-line no-undef\n    __webpack_require__.u = function() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        return(// We encode the chunk filename because our static server matches against and encoded\n        // filename path.\n        encodeURIPath(getChunkScriptFilename(...args)));\n    };\n// We don't need to override __webpack_require__.k because we don't modify\n// the css chunk name when not using deployment id suffixes\n// WE don't need to override __webpack_require__.miniCssF because we don't modify\n// the mini css chunk name when not using deployment id suffixes\n}\n\n//# sourceMappingURL=app-webpack.js.map"
        }
    ]
}