{
    "sourceFile": "node_modules/next/dist/esm/lib/typescript/writeConfigurationDefaults.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892817844,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import { promises as fs } from 'fs';\nimport { bold, cyan, white } from '../picocolors';\nimport * as CommentJson from 'next/dist/compiled/comment-json';\nimport semver from 'next/dist/compiled/semver';\nimport os from 'os';\nimport { getTypeScriptConfiguration } from './getTypeScriptConfiguration';\nimport * as Log from '../../build/output/log';\nfunction getDesiredCompilerOptions(ts, tsOptions) {\n    const o = {\n        target: {\n            suggested: 'ES2017',\n            reason: 'For top-level `await`. Note: Next.js only polyfills for the esmodules target.'\n        },\n        // These are suggested values and will be set when not present in the\n        // tsconfig.json\n        lib: {\n            suggested: [\n                'dom',\n                'dom.iterable',\n                'esnext'\n            ]\n        },\n        allowJs: {\n            suggested: true\n        },\n        skipLibCheck: {\n            suggested: true\n        },\n        strict: {\n            suggested: false\n        },\n        ...semver.lt(ts.version, '5.0.0') ? {\n            forceConsistentCasingInFileNames: {\n                suggested: true\n            }\n        } : undefined,\n        noEmit: {\n            suggested: true\n        },\n        ...semver.gte(ts.version, '4.4.2') ? {\n            incremental: {\n                suggested: true\n            }\n        } : undefined,\n        // These values are required and cannot be changed by the user\n        // Keep this in sync with the webpack config\n        // 'parsedValue' matches the output value from ts.parseJsonConfigFileContent()\n        module: {\n            parsedValue: ts.ModuleKind.ESNext,\n            // All of these values work:\n            parsedValues: [\n                semver.gte(ts.version, '5.4.0') && ts.ModuleKind.Preserve,\n                ts.ModuleKind.ES2020,\n                ts.ModuleKind.ESNext,\n                ts.ModuleKind.CommonJS,\n                ts.ModuleKind.AMD,\n                ts.ModuleKind.NodeNext,\n                ts.ModuleKind.Node16\n            ],\n            value: 'esnext',\n            reason: 'for dynamic import() support'\n        },\n        // TODO: Semver check not needed once Next.js repo uses 5.4.\n        ...semver.gte(ts.version, '5.4.0') && (tsOptions == null ? void 0 : tsOptions.module) === ts.ModuleKind.Preserve ? {\n        } : {\n            esModuleInterop: {\n                value: true,\n                reason: 'requirement for SWC / babel'\n            },\n            moduleResolution: {\n                // In TypeScript 5.0, `NodeJs` has renamed to `Node10`\n                parsedValue: ts.ModuleResolutionKind.Bundler ?? ts.ModuleResolutionKind.NodeNext ?? ts.ModuleResolutionKind.Node10 ?? ts.ModuleResolutionKind.NodeJs,\n                // All of these values work:\n                parsedValues: [\n                    ts.ModuleResolutionKind.Node10 ?? ts.ModuleResolutionKind.NodeJs,\n                    // only newer TypeScript versions have this field, it\n                    // will be filtered for new versions of TypeScript\n                    ts.ModuleResolutionKind.Node12,\n                    ts.ModuleResolutionKind.Node16,\n                    ts.ModuleResolutionKind.NodeNext,\n                    ts.ModuleResolutionKind.Bundler\n                ].filter((val)=>typeof val !== 'undefined'),\n                value: 'node',\n                reason: 'to match webpack resolution'\n            },\n            resolveJsonModule: {\n                value: true,\n                reason: 'to match webpack resolution'\n            }\n        },\n        ...(tsOptions == null ? void 0 : tsOptions.verbatimModuleSyntax) === true ? undefined : {\n            isolatedModules: {\n                value: true,\n                reason: 'requirement for SWC / Babel'\n            }\n        },\n        jsx: {\n            parsedValue: ts.JsxEmit.Preserve,\n            value: 'preserve',\n            reason: 'next.js implements its own optimized jsx transform'\n        }\n    };\n    return o;\n}\nexport function getRequiredConfiguration(ts) {\n    const res = {};\n    const desiredCompilerOptions = getDesiredCompilerOptions(ts);\n    for (const optionKey of Object.keys(desiredCompilerOptions)){\n        const ev = desiredCompilerOptions[optionKey];\n        if (!('value' in ev)) {\n            continue;\n        }\n        res[optionKey] = ev.parsedValue ?? ev.value;\n    }\n    return res;\n}\nconst localDevTestFilesExcludeAction = 'NEXT_PRIVATE_LOCAL_DEV_TEST_FILES_EXCLUDE';\nexport async function writeConfigurationDefaults(ts, tsConfigPath, isFirstTimeSetup, hasAppDir, distDir, hasPagesDir) {\n    var _userTsConfig_compilerOptions;\n    if (isFirstTimeSetup) {\n        await fs.writeFile(tsConfigPath, '{}' + os.EOL);\n    }\n    const { options: tsOptions, raw: rawConfig } = await getTypeScriptConfiguration(ts, tsConfigPath, true);\n    const userTsConfigContent = await fs.readFile(tsConfigPath, {\n        encoding: 'utf8'\n    });\n    const userTsConfig = CommentJson.parse(userTsConfigContent);\n    if (userTsConfig.compilerOptions == null && !('extends' in rawConfig)) {\n        userTsConfig.compilerOptions = {};\n        isFirstTimeSetup = true;\n    }\n    const desiredCompilerOptions = getDesiredCompilerOptions(ts, tsOptions);\n    const suggestedActions = [];\n    const requiredActions = [];\n    for (const optionKey of Object.keys(desiredCompilerOptions)){\n        const check = desiredCompilerOptions[optionKey];\n        if ('suggested' in check) {\n            if (!(optionKey in tsOptions)) {\n                if (!userTsConfig.compilerOptions) {\n                    userTsConfig.compilerOptions = {};\n                }\n                userTsConfig.compilerOptions[optionKey] = check.suggested;\n                suggestedActions.push(cyan(optionKey) + ' was set to ' + bold(check.suggested) + (check.reason ? ` (${check.reason})` : ''));\n            }\n        } else if ('value' in check) {\n            var _check_parsedValues;\n            const ev = tsOptions[optionKey];\n            if (!('parsedValues' in check ? (_check_parsedValues = check.parsedValues) == null ? void 0 : _check_parsedValues.includes(ev) : 'parsedValue' in check ? check.parsedValue === ev : check.value === ev)) {\n                if (!userTsConfig.compilerOptions) {\n                    userTsConfig.compilerOptions = {};\n                }\n                userTsConfig.compilerOptions[optionKey] = check.value;\n                requiredActions.push(cyan(optionKey) + ' was set to ' + bold(check.value) + ` (${check.reason})`);\n            }\n        } else {\n            // eslint-disable-next-line @typescript-eslint/no-unused-vars\n            const _ = check;\n        }\n    }\n    const nextAppTypes = `${distDir}/types/**/*.ts`;\n    if (!('include' in rawConfig)) {\n        userTsConfig.include = hasAppDir ? [\n            'next-env.d.ts',\n            nextAppTypes,\n            '**/*.ts',\n            '**/*.tsx'\n        ] : [\n            'next-env.d.ts',\n            '**/*.ts',\n            '**/*.tsx'\n        ];\n        suggestedActions.push(cyan('include') + ' was set to ' + bold(hasAppDir ? `['next-env.d.ts', '${nextAppTypes}', '**/*.ts', '**/*.tsx']` : `['next-env.d.ts', '**/*.ts', '**/*.tsx']`));\n    } else if (hasAppDir && !rawConfig.include.includes(nextAppTypes)) {\n        if (!Array.isArray(userTsConfig.include)) {\n            userTsConfig.include = [];\n        }\n        // rawConfig will resolve all extends and include paths (ex: tsconfig.json, tsconfig.base.json, etc.)\n        // if it doesn't match userTsConfig then update the userTsConfig to add the\n        // rawConfig's includes in addition to nextAppTypes\n        if (rawConfig.include.length !== userTsConfig.include.length || JSON.stringify(rawConfig.include.sort()) !== JSON.stringify(userTsConfig.include.sort())) {\n            userTsConfig.include.push(...rawConfig.include, nextAppTypes);\n            suggestedActions.push(cyan('include') + ' was set to ' + bold(`[${[\n                ...rawConfig.include,\n                nextAppTypes\n            ].map((i)=>`'${i}'`).join(', ')}]`));\n        } else {\n            userTsConfig.include.push(nextAppTypes);\n            suggestedActions.push(cyan('include') + ' was updated to add ' + bold(`'${nextAppTypes}'`));\n        }\n    }\n    // Enable the Next.js typescript plugin.\n    if (hasAppDir) {\n        // Check if the config or the resolved config has the plugin already.\n        const plugins = [\n            ...Array.isArray(tsOptions.plugins) ? tsOptions.plugins : [],\n            ...userTsConfig.compilerOptions && Array.isArray(userTsConfig.compilerOptions.plugins) ? userTsConfig.compilerOptions.plugins : []\n        ];\n        const hasNextPlugin = plugins.some(({ name })=>name === 'next');\n        // If the TS config extends on another config, we can't add the `plugin` field\n        // because that will override the parent config's plugins.\n        // Instead we have to show a message to the user to add the plugin manually.\n        if (!userTsConfig.compilerOptions || plugins.length && !hasNextPlugin && 'extends' in rawConfig && (!rawConfig.compilerOptions || !rawConfig.compilerOptions.plugins)) {\n            Log.info(`\\nYour ${bold('tsconfig.json')} extends another configuration, which means we cannot add the Next.js TypeScript plugin automatically. To improve your development experience, we recommend adding the Next.js plugin (\\`${cyan('\"plugins\": [{ \"name\": \"next\" }]')}\\`) manually to your TypeScript configuration. Learn more: https://nextjs.org/docs/app/api-reference/config/typescript#the-typescript-plugin\\n`);\n        } else if (!hasNextPlugin) {\n            if (!('plugins' in userTsConfig.compilerOptions)) {\n                userTsConfig.compilerOptions.plugins = [];\n            }\n            userTsConfig.compilerOptions.plugins.push({\n                name: 'next'\n            });\n            suggestedActions.push(cyan('plugins') + ' was updated to add ' + bold(`{ name: 'next' }`));\n        }\n        // If `strict` is set to `false` and `strictNullChecks` is set to `false`,\n        // then set `strictNullChecks` to `true`.\n        if (hasPagesDir && hasAppDir && !tsOptions.strict && !('strictNullChecks' in tsOptions)) {\n            userTsConfig.compilerOptions.strictNullChecks = true;\n            suggestedActions.push(cyan('strictNullChecks') + ' was set to ' + bold(`true`));\n        }\n    }\n    if (!('exclude' in rawConfig)) {\n        userTsConfig.exclude = [\n            'node_modules'\n        ];\n        suggestedActions.push(cyan('exclude') + ' was set to ' + bold(`['node_modules']`));\n    }\n    // During local development inside Next.js repo, exclude the test files coverage by the local tsconfig\n    if (process.env.NEXT_PRIVATE_LOCAL_DEV && userTsConfig.exclude) {\n        const tsGlob = '**/*.test.ts';\n        const tsxGlob = '**/*.test.tsx';\n        let hasUpdates = false;\n        if (!userTsConfig.exclude.includes(tsGlob)) {\n            userTsConfig.exclude.push(tsGlob);\n            hasUpdates = true;\n        }\n        if (!userTsConfig.exclude.includes(tsxGlob)) {\n            userTsConfig.exclude.push(tsxGlob);\n            hasUpdates = true;\n        }\n        if (hasUpdates) {\n            requiredActions.push(localDevTestFilesExcludeAction);\n        }\n    }\n    if (suggestedActions.length < 1 && requiredActions.length < 1) {\n        return;\n    }\n    await fs.writeFile(tsConfigPath, CommentJson.stringify(userTsConfig, null, 2) + os.EOL);\n    Log.info('');\n    if (isFirstTimeSetup) {\n        Log.info(`We detected TypeScript in your project and created a ${cyan('tsconfig.json')} file for you.`);\n        return;\n    }\n    Log.info(`We detected TypeScript in your project and reconfigured your ${cyan('tsconfig.json')} file for you.${((_userTsConfig_compilerOptions = userTsConfig.compilerOptions) == null ? void 0 : _userTsConfig_compilerOptions.strict) ? '' : ` Strict-mode is set to ${cyan('false')} by default.`}`);\n    if (suggestedActions.length) {\n        Log.info(`The following suggested values were added to your ${cyan('tsconfig.json')}. These values ${cyan('can be changed')} to fit your project's needs:\\n`);\n        suggestedActions.forEach((action)=>Log.info(`\\t- ${action}`));\n        Log.info('');\n    }\n    const requiredActionsToBeLogged = process.env.NEXT_PRIVATE_LOCAL_DEV ? requiredActions.filter((action)=>action !== localDevTestFilesExcludeAction) : requiredActions;\n    if (requiredActionsToBeLogged.length) {\n        Log.info(`The following ${white('mandatory changes')} were made to your ${cyan('tsconfig.json')}:\\n`);\n        requiredActionsToBeLogged.forEach((action)=>Log.info(`\\t- ${action}`));\n        Log.info('');\n    }\n}\n\n//# sourceMappingURL=writeConfigurationDefaults.js.map"
        }
    ]
}