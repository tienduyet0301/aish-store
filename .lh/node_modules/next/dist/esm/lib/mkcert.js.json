{
    "sourceFile": "node_modules/next/dist/esm/lib/mkcert.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892815345,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import fs from 'node:fs';\nimport path from 'node:path';\nimport { X509Certificate, createPrivateKey } from 'node:crypto';\nimport { getCacheDirectory } from './helpers/get-cache-directory';\nimport * as Log from '../build/output/log';\nimport { execSync } from 'node:child_process';\nconst { WritableStream } = require('node:stream/web');\nconst MKCERT_VERSION = 'v1.4.4';\nfunction getBinaryName() {\n    const platform = process.platform;\n    const arch = process.arch === 'x64' ? 'amd64' : process.arch;\n    if (platform === 'win32') {\n        return `mkcert-${MKCERT_VERSION}-windows-${arch}.exe`;\n    }\n    if (platform === 'darwin') {\n        return `mkcert-${MKCERT_VERSION}-darwin-${arch}`;\n    }\n    if (platform === 'linux') {\n        return `mkcert-${MKCERT_VERSION}-linux-${arch}`;\n    }\n    throw Object.defineProperty(new Error(`Unsupported platform: ${platform}`), \"__NEXT_ERROR_CODE\", {\n        value: \"E141\",\n        enumerable: false,\n        configurable: true\n    });\n}\nasync function downloadBinary() {\n    try {\n        const binaryName = getBinaryName();\n        const cacheDirectory = getCacheDirectory('mkcert');\n        const binaryPath = path.join(cacheDirectory, binaryName);\n        if (fs.existsSync(binaryPath)) {\n            return binaryPath;\n        }\n        const downloadUrl = `https://github.com/FiloSottile/mkcert/releases/download/${MKCERT_VERSION}/${binaryName}`;\n        await fs.promises.mkdir(cacheDirectory, {\n            recursive: true\n        });\n        Log.info(`Downloading mkcert package...`);\n        const response = await fetch(downloadUrl);\n        if (!response.ok || !response.body) {\n            throw Object.defineProperty(new Error(`request failed with status ${response.status}`), \"__NEXT_ERROR_CODE\", {\n                value: \"E109\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n        Log.info(`Download response was successful, writing to disk`);\n        const binaryWriteStream = fs.createWriteStream(binaryPath);\n        await response.body.pipeTo(new WritableStream({\n            write (chunk) {\n                return new Promise((resolve, reject)=>{\n                    binaryWriteStream.write(chunk, (error)=>{\n                        if (error) {\n                            reject(error);\n                            return;\n                        }\n                        resolve();\n                    });\n                });\n            },\n            close () {\n                return new Promise((resolve, reject)=>{\n                    binaryWriteStream.close((error)=>{\n                        if (error) {\n                            reject(error);\n                            return;\n                        }\n                        resolve();\n                    });\n                });\n            }\n        }));\n        await fs.promises.chmod(binaryPath, 493);\n        return binaryPath;\n    } catch (err) {\n        Log.error('Error downloading mkcert:', err);\n    }\n}\nexport async function createSelfSignedCertificate(host, certDir = 'certificates') {\n    try {\n        const binaryPath = await downloadBinary();\n        if (!binaryPath) throw Object.defineProperty(new Error('missing mkcert binary'), \"__NEXT_ERROR_CODE\", {\n            value: \"E198\",\n            enumerable: false,\n            configurable: true\n        });\n        const resolvedCertDir = path.resolve(process.cwd(), `./${certDir}`);\n        await fs.promises.mkdir(resolvedCertDir, {\n            recursive: true\n        });\n        const keyPath = path.resolve(resolvedCertDir, 'localhost-key.pem');\n        const certPath = path.resolve(resolvedCertDir, 'localhost.pem');\n        if (fs.existsSync(keyPath) && fs.existsSync(certPath)) {\n            const cert = new X509Certificate(fs.readFileSync(certPath));\n            const key = fs.readFileSync(keyPath);\n            if (cert.checkHost(host ?? 'localhost') && cert.checkPrivateKey(createPrivateKey(key))) {\n                Log.info('Using already generated self signed certificate');\n                const caLocation = execSync(`\"${binaryPath}\" -CAROOT`).toString().trim();\n                return {\n                    key: keyPath,\n                    cert: certPath,\n                    rootCA: `${caLocation}/rootCA.pem`\n                };\n            }\n        }\n        Log.info('Attempting to generate self signed certificate. This may prompt for your password');\n        const defaultHosts = [\n            'localhost',\n            '127.0.0.1',\n            '::1'\n        ];\n        const hosts = host && !defaultHosts.includes(host) ? [\n            ...defaultHosts,\n            host\n        ] : defaultHosts;\n        execSync(`\"${binaryPath}\" -install -key-file \"${keyPath}\" -cert-file \"${certPath}\" ${hosts.join(' ')}`, {\n            stdio: 'ignore'\n        });\n        const caLocation = execSync(`\"${binaryPath}\" -CAROOT`).toString().trim();\n        if (!fs.existsSync(keyPath) || !fs.existsSync(certPath)) {\n            throw Object.defineProperty(new Error('Certificate files not found'), \"__NEXT_ERROR_CODE\", {\n                value: \"E131\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n        Log.info(`CA Root certificate created in ${caLocation}`);\n        Log.info(`Certificates created in ${resolvedCertDir}`);\n        const gitignorePath = path.resolve(process.cwd(), './.gitignore');\n        if (fs.existsSync(gitignorePath)) {\n            const gitignore = await fs.promises.readFile(gitignorePath, 'utf8');\n            if (!gitignore.includes(certDir)) {\n                Log.info('Adding certificates to .gitignore');\n                await fs.promises.appendFile(gitignorePath, `\\n${certDir}`);\n            }\n        }\n        return {\n            key: keyPath,\n            cert: certPath,\n            rootCA: `${caLocation}/rootCA.pem`\n        };\n    } catch (err) {\n        Log.error('Failed to generate self-signed certificate. Falling back to http.', err);\n    }\n}\n\n//# sourceMappingURL=mkcert.js.map"
        }
    ]
}