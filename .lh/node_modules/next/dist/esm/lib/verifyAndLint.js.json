{
    "sourceFile": "node_modules/next/dist/esm/lib/verifyAndLint.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892818273,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import { red } from './picocolors';\nimport { Worker } from './worker';\nimport { existsSync } from 'fs';\nimport { join } from 'path';\nimport { ESLINT_DEFAULT_DIRS } from './constants';\nimport { eventLintCheckCompleted } from '../telemetry/events';\nimport { CompileError } from './compile-error';\nimport isError from './is-error';\nexport async function verifyAndLint(dir, cacheLocation, configLintDirs, enableWorkerThreads, telemetry) {\n    let lintWorkers;\n    try {\n        lintWorkers = new Worker(require.resolve('./eslint/runLintCheck'), {\n            exposedMethods: [\n                'runLintCheck'\n            ],\n            numWorkers: 1,\n            enableWorkerThreads,\n            maxRetries: 0\n        });\n        const lintDirs = (configLintDirs ?? ESLINT_DEFAULT_DIRS).reduce((res, d)=>{\n            const currDir = join(dir, d);\n            if (!existsSync(currDir)) return res;\n            res.push(currDir);\n            return res;\n        }, []);\n        const lintResults = await (lintWorkers == null ? void 0 : lintWorkers.runLintCheck(dir, lintDirs, {\n            lintDuringBuild: true,\n            eslintOptions: {\n                cacheLocation\n            }\n        }));\n        const lintOutput = typeof lintResults === 'string' ? lintResults : lintResults == null ? void 0 : lintResults.output;\n        if (typeof lintResults !== 'string' && (lintResults == null ? void 0 : lintResults.eventInfo)) {\n            telemetry.record(eventLintCheckCompleted({\n                ...lintResults.eventInfo,\n                buildLint: true\n            }));\n        }\n        if (typeof lintResults !== 'string' && (lintResults == null ? void 0 : lintResults.isError) && lintOutput) {\n            await telemetry.flush();\n            throw Object.defineProperty(new CompileError(lintOutput), \"__NEXT_ERROR_CODE\", {\n                value: \"E394\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n        if (lintOutput) {\n            console.log(lintOutput);\n        }\n    } catch (err) {\n        if (isError(err)) {\n            if (err.type === 'CompileError' || err instanceof CompileError) {\n                console.error(red('\\nFailed to compile.'));\n                console.error(err.message);\n                process.exit(1);\n            } else if (err.type === 'FatalError') {\n                console.error(err.message);\n                process.exit(1);\n            }\n        }\n        throw err;\n    } finally{\n        try {\n            lintWorkers == null ? void 0 : lintWorkers.end();\n        } catch  {}\n    }\n}\n\n//# sourceMappingURL=verifyAndLint.js.map"
        }
    ]
}