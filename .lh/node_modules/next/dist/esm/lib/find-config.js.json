{
    "sourceFile": "node_modules/next/dist/esm/lib/find-config.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892808131,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import findUp from 'next/dist/compiled/find-up';\nimport { readFile } from 'fs/promises';\nimport JSON5 from 'next/dist/compiled/json5';\nimport { pathToFileURL } from 'url';\nexport function findConfigPath(dir, key) {\n    // If we didn't find the configuration in `package.json`, we should look for\n    // known filenames.\n    return findUp([\n        `.${key}rc.json`,\n        `${key}.config.json`,\n        `.${key}rc.js`,\n        `${key}.config.js`,\n        `${key}.config.mjs`,\n        `${key}.config.cjs`\n    ], {\n        cwd: dir\n    });\n}\n// We'll allow configuration to be typed, but we force everything provided to\n// become optional. We do not perform any schema validation. We should maybe\n// force all the types to be `unknown` as well.\nexport async function findConfig(directory, key, _returnFile) {\n    // `package.json` configuration always wins. Let's check that first.\n    const packageJsonPath = await findUp('package.json', {\n        cwd: directory\n    });\n    let isESM = false;\n    if (packageJsonPath) {\n        try {\n            const packageJsonStr = await readFile(packageJsonPath, 'utf8');\n            const packageJson = JSON.parse(packageJsonStr);\n            if (typeof packageJson !== 'object') {\n                throw new Error() // Stop processing and continue\n                ;\n            }\n            if (packageJson.type === 'module') {\n                isESM = true;\n            }\n            if (packageJson[key] != null && typeof packageJson[key] === 'object') {\n                return packageJson[key];\n            }\n        } catch  {\n        // Ignore error and continue\n        }\n    }\n    const filePath = await findConfigPath(directory, key);\n    const esmImport = (path)=>{\n        // Skip mapping to absolute url with pathToFileURL on windows if it's jest\n        // https://github.com/nodejs/node/issues/31710#issuecomment-587345749\n        if (process.platform === 'win32' && !process.env.JEST_WORKER_ID) {\n            // on windows import(\"C:\\\\path\\\\to\\\\file\") is not valid, so we need to\n            // use file:// URLs\n            return import(pathToFileURL(path).toString());\n        } else {\n            return import(path);\n        }\n    };\n    if (filePath) {\n        if (filePath.endsWith('.js')) {\n            if (isESM) {\n                return (await esmImport(filePath)).default;\n            } else {\n                return require(filePath);\n            }\n        } else if (filePath.endsWith('.mjs')) {\n            return (await esmImport(filePath)).default;\n        } else if (filePath.endsWith('.cjs')) {\n            return require(filePath);\n        }\n        // We load JSON contents with JSON5 to allow users to comment in their\n        // configuration file. This pattern was popularized by TypeScript.\n        const fileContents = await readFile(filePath, 'utf8');\n        return JSON5.parse(fileContents);\n    }\n    return null;\n}\n\n//# sourceMappingURL=find-config.js.map"
        }
    ]
}