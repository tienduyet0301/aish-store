{
    "sourceFile": "node_modules/next/dist/esm/lib/metadata/resolve-metadata.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892813894,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "// eslint-disable-next-line import/no-extraneous-dependencies\nimport 'server-only';\nimport { cache } from 'react';\nimport { createDefaultMetadata, createDefaultViewport } from './default-metadata';\nimport { resolveOpenGraph, resolveTwitter } from './resolvers/resolve-opengraph';\nimport { resolveTitle } from './resolvers/resolve-title';\nimport { resolveAsArrayOrUndefined } from './generate/utils';\nimport { getComponentTypeModule, getLayoutOrPageModule } from '../../server/lib/app-dir-module';\nimport { interopDefault } from '../interop-default';\nimport { resolveAlternates, resolveAppleWebApp, resolveAppLinks, resolveRobots, resolveThemeColor, resolveVerification, resolveItunes, resolveFacebook, resolvePagination } from './resolvers/resolve-basics';\nimport { resolveIcons } from './resolvers/resolve-icons';\nimport { getTracer } from '../../server/lib/trace/tracer';\nimport { ResolveMetadataSpan } from '../../server/lib/trace/constants';\nimport { PAGE_SEGMENT_KEY } from '../../shared/lib/segment';\nimport * as Log from '../../build/output/log';\nimport { createServerParamsForMetadata } from '../../server/request/params';\nfunction isFavicon(icon) {\n    if (!icon) {\n        return false;\n    }\n    // turbopack appends a hash to all images\n    return (icon.url === '/favicon.ico' || icon.url.toString().startsWith('/favicon.ico?')) && icon.type === 'image/x-icon';\n}\nfunction mergeStaticMetadata(source, target, staticFilesMetadata, metadataContext, titleTemplates, leafSegmentStaticIcons) {\n    var _source_twitter, _source_openGraph;\n    if (!staticFilesMetadata) return;\n    const { icon, apple, openGraph, twitter, manifest } = staticFilesMetadata;\n    // Keep updating the static icons in the most leaf node\n    if (icon) {\n        leafSegmentStaticIcons.icon = icon;\n    }\n    if (apple) {\n        leafSegmentStaticIcons.apple = apple;\n    }\n    // file based metadata is specified and current level metadata twitter.images is not specified\n    if (twitter && !(source == null ? void 0 : (_source_twitter = source.twitter) == null ? void 0 : _source_twitter.hasOwnProperty('images'))) {\n        const resolvedTwitter = resolveTwitter({\n            ...target.twitter,\n            images: twitter\n        }, target.metadataBase, {\n            ...metadataContext,\n            isStaticMetadataRouteFile: true\n        }, titleTemplates.twitter);\n        target.twitter = resolvedTwitter;\n    }\n    // file based metadata is specified and current level metadata openGraph.images is not specified\n    if (openGraph && !(source == null ? void 0 : (_source_openGraph = source.openGraph) == null ? void 0 : _source_openGraph.hasOwnProperty('images'))) {\n        const resolvedOpenGraph = resolveOpenGraph({\n            ...target.openGraph,\n            images: openGraph\n        }, target.metadataBase, {\n            ...metadataContext,\n            isStaticMetadataRouteFile: true\n        }, titleTemplates.openGraph);\n        target.openGraph = resolvedOpenGraph;\n    }\n    if (manifest) {\n        target.manifest = manifest;\n    }\n    return target;\n}\n// Merge the source metadata into the resolved target metadata.\nfunction mergeMetadata({ source, target, staticFilesMetadata, titleTemplates, metadataContext, buildState, leafSegmentStaticIcons }) {\n    // If there's override metadata, prefer it otherwise fallback to the default metadata.\n    const metadataBase = typeof (source == null ? void 0 : source.metadataBase) !== 'undefined' ? source.metadataBase : target.metadataBase;\n    for(const key_ in source){\n        const key = key_;\n        switch(key){\n            case 'title':\n                {\n                    target.title = resolveTitle(source.title, titleTemplates.title);\n                    break;\n                }\n            case 'alternates':\n                {\n                    target.alternates = resolveAlternates(source.alternates, metadataBase, metadataContext);\n                    break;\n                }\n            case 'openGraph':\n                {\n                    target.openGraph = resolveOpenGraph(source.openGraph, metadataBase, metadataContext, titleTemplates.openGraph);\n                    break;\n                }\n            case 'twitter':\n                {\n                    target.twitter = resolveTwitter(source.twitter, metadataBase, metadataContext, titleTemplates.twitter);\n                    break;\n                }\n            case 'facebook':\n                target.facebook = resolveFacebook(source.facebook);\n                break;\n            case 'verification':\n                target.verification = resolveVerification(source.verification);\n                break;\n            case 'icons':\n                {\n                    target.icons = resolveIcons(source.icons);\n                    break;\n                }\n            case 'appleWebApp':\n                target.appleWebApp = resolveAppleWebApp(source.appleWebApp);\n                break;\n            case 'appLinks':\n                target.appLinks = resolveAppLinks(source.appLinks);\n                break;\n            case 'robots':\n                {\n                    target.robots = resolveRobots(source.robots);\n                    break;\n                }\n            case 'archives':\n            case 'assets':\n            case 'bookmarks':\n            case 'keywords':\n                {\n                    target[key] = resolveAsArrayOrUndefined(source[key]);\n                    break;\n                }\n            case 'authors':\n                {\n                    target[key] = resolveAsArrayOrUndefined(source.authors);\n                    break;\n                }\n            case 'itunes':\n                {\n                    target[key] = resolveItunes(source.itunes, metadataBase, metadataContext);\n                    break;\n                }\n            case 'pagination':\n                {\n                    target.pagination = resolvePagination(source.pagination, metadataBase, metadataContext);\n                    break;\n                }\n            // directly assign fields that fallback to null\n            case 'applicationName':\n            case 'description':\n            case 'generator':\n            case 'creator':\n            case 'publisher':\n            case 'category':\n            case 'classification':\n            case 'referrer':\n            case 'formatDetection':\n            case 'manifest':\n            case 'pinterest':\n                // @ts-ignore TODO: support inferring\n                target[key] = source[key] || null;\n                break;\n            case 'other':\n                target.other = Object.assign({}, target.other, source.other);\n                break;\n            case 'metadataBase':\n                target.metadataBase = metadataBase;\n                break;\n            default:\n                {\n                    if ((key === 'viewport' || key === 'themeColor' || key === 'colorScheme') && source[key] != null) {\n                        buildState.warnings.add(`Unsupported metadata ${key} is configured in metadata export in ${metadataContext.pathname}. Please move it to viewport export instead.\\nRead more: https://nextjs.org/docs/app/api-reference/functions/generate-viewport`);\n                    }\n                    break;\n                }\n        }\n    }\n    mergeStaticMetadata(source, target, staticFilesMetadata, metadataContext, titleTemplates, leafSegmentStaticIcons);\n}\nfunction mergeViewport({ target, source }) {\n    if (!source) return;\n    for(const key_ in source){\n        const key = key_;\n        switch(key){\n            case 'themeColor':\n                {\n                    target.themeColor = resolveThemeColor(source.themeColor);\n                    break;\n                }\n            case 'colorScheme':\n                target.colorScheme = source.colorScheme || null;\n                break;\n            default:\n                // always override the target with the source\n                // @ts-ignore viewport properties\n                target[key] = source[key];\n                break;\n        }\n    }\n}\nfunction getDefinedViewport(mod, props, tracingProps) {\n    if (typeof mod.generateViewport === 'function') {\n        const { route } = tracingProps;\n        return (parent)=>getTracer().trace(ResolveMetadataSpan.generateViewport, {\n                spanName: `generateViewport ${route}`,\n                attributes: {\n                    'next.page': route\n                }\n            }, ()=>mod.generateViewport(props, parent));\n    }\n    return mod.viewport || null;\n}\nfunction getDefinedMetadata(mod, props, tracingProps) {\n    if (typeof mod.generateMetadata === 'function') {\n        const { route } = tracingProps;\n        return (parent)=>getTracer().trace(ResolveMetadataSpan.generateMetadata, {\n                spanName: `generateMetadata ${route}`,\n                attributes: {\n                    'next.page': route\n                }\n            }, ()=>mod.generateMetadata(props, parent));\n    }\n    return mod.metadata || null;\n}\nasync function collectStaticImagesFiles(metadata, props, type) {\n    var _this;\n    if (!(metadata == null ? void 0 : metadata[type])) return undefined;\n    const iconPromises = metadata[type].map(async (imageModule)=>interopDefault(await imageModule(props)));\n    return (iconPromises == null ? void 0 : iconPromises.length) > 0 ? (_this = await Promise.all(iconPromises)) == null ? void 0 : _this.flat() : undefined;\n}\nasync function resolveStaticMetadata(modules, props) {\n    const { metadata } = modules;\n    if (!metadata) return null;\n    const [icon, apple, openGraph, twitter] = await Promise.all([\n        collectStaticImagesFiles(metadata, props, 'icon'),\n        collectStaticImagesFiles(metadata, props, 'apple'),\n        collectStaticImagesFiles(metadata, props, 'openGraph'),\n        collectStaticImagesFiles(metadata, props, 'twitter')\n    ]);\n    const staticMetadata = {\n        icon,\n        apple,\n        openGraph,\n        twitter,\n        manifest: metadata.manifest\n    };\n    return staticMetadata;\n}\n// [layout.metadata, static files metadata] -> ... -> [page.metadata, static files metadata]\nasync function collectMetadata({ tree, metadataItems, errorMetadataItem, props, route, errorConvention }) {\n    let mod;\n    let modType;\n    const hasErrorConventionComponent = Boolean(errorConvention && tree[2][errorConvention]);\n    if (errorConvention) {\n        mod = await getComponentTypeModule(tree, 'layout');\n        modType = errorConvention;\n    } else {\n        const { mod: layoutOrPageMod, modType: layoutOrPageModType } = await getLayoutOrPageModule(tree);\n        mod = layoutOrPageMod;\n        modType = layoutOrPageModType;\n    }\n    if (modType) {\n        route += `/${modType}`;\n    }\n    const staticFilesMetadata = await resolveStaticMetadata(tree[2], props);\n    const metadataExport = mod ? getDefinedMetadata(mod, props, {\n        route\n    }) : null;\n    metadataItems.push([\n        metadataExport,\n        staticFilesMetadata\n    ]);\n    if (hasErrorConventionComponent && errorConvention) {\n        const errorMod = await getComponentTypeModule(tree, errorConvention);\n        const errorMetadataExport = errorMod ? getDefinedMetadata(errorMod, props, {\n            route\n        }) : null;\n        errorMetadataItem[0] = errorMetadataExport;\n        errorMetadataItem[1] = staticFilesMetadata;\n    }\n}\n// [layout.metadata, static files metadata] -> ... -> [page.metadata, static files metadata]\nasync function collectViewport({ tree, viewportItems, errorViewportItemRef, props, route, errorConvention }) {\n    let mod;\n    let modType;\n    const hasErrorConventionComponent = Boolean(errorConvention && tree[2][errorConvention]);\n    if (errorConvention) {\n        mod = await getComponentTypeModule(tree, 'layout');\n        modType = errorConvention;\n    } else {\n        const { mod: layoutOrPageMod, modType: layoutOrPageModType } = await getLayoutOrPageModule(tree);\n        mod = layoutOrPageMod;\n        modType = layoutOrPageModType;\n    }\n    if (modType) {\n        route += `/${modType}`;\n    }\n    const viewportExport = mod ? getDefinedViewport(mod, props, {\n        route\n    }) : null;\n    viewportItems.push(viewportExport);\n    if (hasErrorConventionComponent && errorConvention) {\n        const errorMod = await getComponentTypeModule(tree, errorConvention);\n        const errorViewportExport = errorMod ? getDefinedViewport(errorMod, props, {\n            route\n        }) : null;\n        errorViewportItemRef.current = errorViewportExport;\n    }\n}\nconst resolveMetadataItems = cache(async function(tree, searchParams, errorConvention, getDynamicParamFromSegment, workStore) {\n    const parentParams = {};\n    const metadataItems = [];\n    const errorMetadataItem = [\n        null,\n        null\n    ];\n    const treePrefix = undefined;\n    return resolveMetadataItemsImpl(metadataItems, tree, treePrefix, parentParams, searchParams, errorConvention, errorMetadataItem, getDynamicParamFromSegment, workStore);\n});\nasync function resolveMetadataItemsImpl(metadataItems, tree, /** Provided tree can be nested subtree, this argument says what is the path of such subtree */ treePrefix, parentParams, searchParams, errorConvention, errorMetadataItem, getDynamicParamFromSegment, workStore) {\n    const [segment, parallelRoutes, { page }] = tree;\n    const currentTreePrefix = treePrefix && treePrefix.length ? [\n        ...treePrefix,\n        segment\n    ] : [\n        segment\n    ];\n    const isPage = typeof page !== 'undefined';\n    // Handle dynamic segment params.\n    const segmentParam = getDynamicParamFromSegment(segment);\n    /**\n   * Create object holding the parent params and current params\n   */ let currentParams = parentParams;\n    if (segmentParam && segmentParam.value !== null) {\n        currentParams = {\n            ...parentParams,\n            [segmentParam.param]: segmentParam.value\n        };\n    }\n    const params = createServerParamsForMetadata(currentParams, workStore);\n    let layerProps;\n    if (isPage) {\n        layerProps = {\n            params,\n            searchParams\n        };\n    } else {\n        layerProps = {\n            params\n        };\n    }\n    await collectMetadata({\n        tree,\n        metadataItems,\n        errorMetadataItem,\n        errorConvention,\n        props: layerProps,\n        route: currentTreePrefix// __PAGE__ shouldn't be shown in a route\n        .filter((s)=>s !== PAGE_SEGMENT_KEY).join('/')\n    });\n    for(const key in parallelRoutes){\n        const childTree = parallelRoutes[key];\n        await resolveMetadataItemsImpl(metadataItems, childTree, currentTreePrefix, currentParams, searchParams, errorConvention, errorMetadataItem, getDynamicParamFromSegment, workStore);\n    }\n    if (Object.keys(parallelRoutes).length === 0 && errorConvention) {\n        // If there are no parallel routes, place error metadata as the last item.\n        // e.g. layout -> layout -> not-found\n        metadataItems.push(errorMetadataItem);\n    }\n    return metadataItems;\n}\nconst resolveViewportItems = cache(async function(tree, searchParams, errorConvention, getDynamicParamFromSegment, workStore) {\n    const parentParams = {};\n    const viewportItems = [];\n    const errorViewportItemRef = {\n        current: null\n    };\n    const treePrefix = undefined;\n    return resolveViewportItemsImpl(viewportItems, tree, treePrefix, parentParams, searchParams, errorConvention, errorViewportItemRef, getDynamicParamFromSegment, workStore);\n});\nasync function resolveViewportItemsImpl(viewportItems, tree, /** Provided tree can be nested subtree, this argument says what is the path of such subtree */ treePrefix, parentParams, searchParams, errorConvention, errorViewportItemRef, getDynamicParamFromSegment, workStore) {\n    const [segment, parallelRoutes, { page }] = tree;\n    const currentTreePrefix = treePrefix && treePrefix.length ? [\n        ...treePrefix,\n        segment\n    ] : [\n        segment\n    ];\n    const isPage = typeof page !== 'undefined';\n    // Handle dynamic segment params.\n    const segmentParam = getDynamicParamFromSegment(segment);\n    /**\n   * Create object holding the parent params and current params\n   */ let currentParams = parentParams;\n    if (segmentParam && segmentParam.value !== null) {\n        currentParams = {\n            ...parentParams,\n            [segmentParam.param]: segmentParam.value\n        };\n    }\n    const params = createServerParamsForMetadata(currentParams, workStore);\n    let layerProps;\n    if (isPage) {\n        layerProps = {\n            params,\n            searchParams\n        };\n    } else {\n        layerProps = {\n            params\n        };\n    }\n    await collectViewport({\n        tree,\n        viewportItems,\n        errorViewportItemRef,\n        errorConvention,\n        props: layerProps,\n        route: currentTreePrefix// __PAGE__ shouldn't be shown in a route\n        .filter((s)=>s !== PAGE_SEGMENT_KEY).join('/')\n    });\n    for(const key in parallelRoutes){\n        const childTree = parallelRoutes[key];\n        await resolveViewportItemsImpl(viewportItems, childTree, currentTreePrefix, currentParams, searchParams, errorConvention, errorViewportItemRef, getDynamicParamFromSegment, workStore);\n    }\n    if (Object.keys(parallelRoutes).length === 0 && errorConvention) {\n        // If there are no parallel routes, place error metadata as the last item.\n        // e.g. layout -> layout -> not-found\n        viewportItems.push(errorViewportItemRef.current);\n    }\n    return viewportItems;\n}\nconst isTitleTruthy = (title)=>!!(title == null ? void 0 : title.absolute);\nconst hasTitle = (metadata)=>isTitleTruthy(metadata == null ? void 0 : metadata.title);\nfunction inheritFromMetadata(target, metadata) {\n    if (target) {\n        if (!hasTitle(target) && hasTitle(metadata)) {\n            target.title = metadata.title;\n        }\n        if (!target.description && metadata.description) {\n            target.description = metadata.description;\n        }\n    }\n}\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nconst commonOgKeys = [\n    'title',\n    'description',\n    'images'\n];\nfunction postProcessMetadata(metadata, favicon, titleTemplates, metadataContext) {\n    const { openGraph, twitter } = metadata;\n    if (openGraph) {\n        // If there's openGraph information but not configured in twitter,\n        // inherit them from openGraph metadata.\n        let autoFillProps = {};\n        const hasTwTitle = hasTitle(twitter);\n        const hasTwDescription = twitter == null ? void 0 : twitter.description;\n        const hasTwImages = Boolean((twitter == null ? void 0 : twitter.hasOwnProperty('images')) && twitter.images);\n        if (!hasTwTitle) {\n            if (isTitleTruthy(openGraph.title)) {\n                autoFillProps.title = openGraph.title;\n            } else if (metadata.title && isTitleTruthy(metadata.title)) {\n                autoFillProps.title = metadata.title;\n            }\n        }\n        if (!hasTwDescription) autoFillProps.description = openGraph.description || metadata.description || undefined;\n        if (!hasTwImages) autoFillProps.images = openGraph.images;\n        if (Object.keys(autoFillProps).length > 0) {\n            const partialTwitter = resolveTwitter(autoFillProps, metadata.metadataBase, metadataContext, titleTemplates.twitter);\n            if (metadata.twitter) {\n                metadata.twitter = Object.assign({}, metadata.twitter, {\n                    ...!hasTwTitle && {\n                        title: partialTwitter == null ? void 0 : partialTwitter.title\n                    },\n                    ...!hasTwDescription && {\n                        description: partialTwitter == null ? void 0 : partialTwitter.description\n                    },\n                    ...!hasTwImages && {\n                        images: partialTwitter == null ? void 0 : partialTwitter.images\n                    }\n                });\n            } else {\n                metadata.twitter = partialTwitter;\n            }\n        }\n    }\n    // If there's no title and description configured in openGraph or twitter,\n    // use the title and description from metadata.\n    inheritFromMetadata(openGraph, metadata);\n    inheritFromMetadata(twitter, metadata);\n    if (favicon) {\n        if (!metadata.icons) {\n            metadata.icons = {\n                icon: [],\n                apple: []\n            };\n        }\n        metadata.icons.icon.unshift(favicon);\n    }\n    return metadata;\n}\nfunction prerenderMetadata(metadataItems) {\n    // If the index is a function then it is a resolver and the next slot\n    // is the corresponding result. If the index is not a function it is the result\n    // itself.\n    const resolversAndResults = [];\n    for(let i = 0; i < metadataItems.length; i++){\n        const metadataExport = metadataItems[i][0];\n        getResult(resolversAndResults, metadataExport);\n    }\n    return resolversAndResults;\n}\nfunction prerenderViewport(viewportItems) {\n    // If the index is a function then it is a resolver and the next slot\n    // is the corresponding result. If the index is not a function it is the result\n    // itself.\n    const resolversAndResults = [];\n    for(let i = 0; i < viewportItems.length; i++){\n        const viewportExport = viewportItems[i];\n        getResult(resolversAndResults, viewportExport);\n    }\n    return resolversAndResults;\n}\nfunction getResult(resolversAndResults, exportForResult) {\n    if (typeof exportForResult === 'function') {\n        const result = exportForResult(new Promise((resolve)=>resolversAndResults.push(resolve)));\n        resolversAndResults.push(result);\n        if (result instanceof Promise) {\n            // since we eager execute generateMetadata and\n            // they can reject at anytime we need to ensure\n            // we attach the catch handler right away to\n            // prevent unhandled rejections crashing the process\n            result.catch((err)=>{\n                return {\n                    __nextError: err\n                };\n            });\n        }\n    } else if (typeof exportForResult === 'object') {\n        resolversAndResults.push(exportForResult);\n    } else {\n        resolversAndResults.push(null);\n    }\n}\nfunction resolvePendingResult(parentResult, resolveParentResult) {\n    // In dev we clone and freeze to prevent relying on mutating resolvedMetadata directly.\n    // In prod we just pass resolvedMetadata through without any copying.\n    if (process.env.NODE_ENV === 'development') {\n        parentResult = require('../../shared/lib/deep-freeze').deepFreeze(require('./clone-metadata').cloneMetadata(parentResult));\n    }\n    resolveParentResult(parentResult);\n}\nexport async function accumulateMetadata(metadataItems, metadataContext) {\n    const resolvedMetadata = createDefaultMetadata();\n    let titleTemplates = {\n        title: null,\n        twitter: null,\n        openGraph: null\n    };\n    const buildState = {\n        warnings: new Set()\n    };\n    let favicon;\n    // Collect the static icons in the most leaf node,\n    // since we don't collect all the static metadata icons in the parent segments.\n    const leafSegmentStaticIcons = {\n        icon: [],\n        apple: []\n    };\n    const resolversAndResults = prerenderMetadata(metadataItems);\n    let resultIndex = 0;\n    for(let i = 0; i < metadataItems.length; i++){\n        var _staticFilesMetadata_icon;\n        const staticFilesMetadata = metadataItems[i][1];\n        // Treat favicon as special case, it should be the first icon in the list\n        // i <= 1 represents root layout, and if current page is also at root\n        if (i <= 1 && isFavicon(staticFilesMetadata == null ? void 0 : (_staticFilesMetadata_icon = staticFilesMetadata.icon) == null ? void 0 : _staticFilesMetadata_icon[0])) {\n            var _staticFilesMetadata_icon1;\n            const iconMod = staticFilesMetadata == null ? void 0 : (_staticFilesMetadata_icon1 = staticFilesMetadata.icon) == null ? void 0 : _staticFilesMetadata_icon1.shift();\n            if (i === 0) favicon = iconMod;\n        }\n        let pendingMetadata = resolversAndResults[resultIndex++];\n        if (typeof pendingMetadata === 'function') {\n            // This metadata item had a `generateMetadata` and\n            // we need to provide the currently resolved metadata\n            // to it before we continue;\n            const resolveParentMetadata = pendingMetadata;\n            // we know that the next item is a result if this item\n            // was a resolver\n            pendingMetadata = resolversAndResults[resultIndex++];\n            resolvePendingResult(resolvedMetadata, resolveParentMetadata);\n        }\n        // Otherwise the item was either null or a static export\n        let metadata;\n        if (isPromiseLike(pendingMetadata)) {\n            metadata = await pendingMetadata;\n        } else {\n            metadata = pendingMetadata;\n        }\n        mergeMetadata({\n            target: resolvedMetadata,\n            source: metadata,\n            metadataContext,\n            staticFilesMetadata,\n            titleTemplates,\n            buildState,\n            leafSegmentStaticIcons\n        });\n        // If the layout is the same layer with page, skip the leaf layout and leaf page\n        // The leaf layout and page are the last two items\n        if (i < metadataItems.length - 2) {\n            var _resolvedMetadata_title, _resolvedMetadata_openGraph, _resolvedMetadata_twitter;\n            titleTemplates = {\n                title: ((_resolvedMetadata_title = resolvedMetadata.title) == null ? void 0 : _resolvedMetadata_title.template) || null,\n                openGraph: ((_resolvedMetadata_openGraph = resolvedMetadata.openGraph) == null ? void 0 : _resolvedMetadata_openGraph.title.template) || null,\n                twitter: ((_resolvedMetadata_twitter = resolvedMetadata.twitter) == null ? void 0 : _resolvedMetadata_twitter.title.template) || null\n            };\n        }\n    }\n    if (leafSegmentStaticIcons.icon.length > 0 || leafSegmentStaticIcons.apple.length > 0) {\n        if (!resolvedMetadata.icons) {\n            resolvedMetadata.icons = {\n                icon: [],\n                apple: []\n            };\n            if (leafSegmentStaticIcons.icon.length > 0) {\n                resolvedMetadata.icons.icon.unshift(...leafSegmentStaticIcons.icon);\n            }\n            if (leafSegmentStaticIcons.apple.length > 0) {\n                resolvedMetadata.icons.apple.unshift(...leafSegmentStaticIcons.apple);\n            }\n        }\n    }\n    // Only log warnings if there are any, and only once after the metadata resolving process is finished\n    if (buildState.warnings.size > 0) {\n        for (const warning of buildState.warnings){\n            Log.warn(warning);\n        }\n    }\n    return postProcessMetadata(resolvedMetadata, favicon, titleTemplates, metadataContext);\n}\nexport async function accumulateViewport(viewportItems) {\n    const resolvedViewport = createDefaultViewport();\n    const resolversAndResults = prerenderViewport(viewportItems);\n    let i = 0;\n    while(i < resolversAndResults.length){\n        let pendingViewport = resolversAndResults[i++];\n        if (typeof pendingViewport === 'function') {\n            // this viewport item had a `generateViewport` and\n            // we need to provide the currently resolved viewport\n            // to it before we continue;\n            const resolveParentViewport = pendingViewport;\n            // we know that the next item is a result if this item\n            // was a resolver\n            pendingViewport = resolversAndResults[i++];\n            resolvePendingResult(resolvedViewport, resolveParentViewport);\n        }\n        // Otherwise the item was either null or a static export\n        let viewport;\n        if (isPromiseLike(pendingViewport)) {\n            viewport = await pendingViewport;\n        } else {\n            viewport = pendingViewport;\n        }\n        mergeViewport({\n            target: resolvedViewport,\n            source: viewport\n        });\n    }\n    return resolvedViewport;\n}\n// Exposed API for metadata component, that directly resolve the loader tree and related context as resolved metadata.\nexport async function resolveMetadata(tree, searchParams, errorConvention, getDynamicParamFromSegment, workStore, metadataContext) {\n    const metadataItems = await resolveMetadataItems(tree, searchParams, errorConvention, getDynamicParamFromSegment, workStore);\n    return accumulateMetadata(metadataItems, metadataContext);\n}\n// Exposed API for viewport component, that directly resolve the loader tree and related context as resolved viewport.\nexport async function resolveViewport(tree, searchParams, errorConvention, getDynamicParamFromSegment, workStore) {\n    const viewportItems = await resolveViewportItems(tree, searchParams, errorConvention, getDynamicParamFromSegment, workStore);\n    return accumulateViewport(viewportItems);\n}\nfunction isPromiseLike(value) {\n    return typeof value === 'object' && value !== null && typeof value.then === 'function';\n}\n\n//# sourceMappingURL=resolve-metadata.js.map"
        }
    ]
}