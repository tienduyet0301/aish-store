{
    "sourceFile": "node_modules/next/dist/esm/lib/memory/gc-observer.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892811731,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import { PerformanceObserver } from 'perf_hooks';\nimport { warn } from '../../build/output/log';\nimport { bold } from '../picocolors';\nconst LONG_RUNNING_GC_THRESHOLD_MS = 15;\nconst gcEvents = [];\nconst obs = new PerformanceObserver((list)=>{\n    const entry = list.getEntries()[0];\n    gcEvents.push(entry);\n    if (entry.duration > LONG_RUNNING_GC_THRESHOLD_MS) {\n        warn(bold(`Long running GC detected: ${entry.duration.toFixed(2)}ms`));\n    }\n});\n/**\n * Starts recording garbage collection events in the process and warn on long\n * running GCs. To disable, call `stopObservingGc`.\n */ export function startObservingGc() {\n    obs.observe({\n        entryTypes: [\n            'gc'\n        ]\n    });\n}\nexport function stopObservingGc() {\n    obs.disconnect();\n}\n/**\n * Returns all recorded garbage collection events. This function will only\n * return information from when `startObservingGc` was enabled and before\n * `stopObservingGc` was called.\n */ export function getGcEvents() {\n    return gcEvents;\n}\n\n//# sourceMappingURL=gc-observer.js.map"
        }
    ]
}