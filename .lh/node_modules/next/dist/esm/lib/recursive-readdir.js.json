{
    "sourceFile": "node_modules/next/dist/esm/lib/recursive-readdir.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892816505,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import fs from 'fs/promises';\nimport path from 'path';\n/**\n * Recursively reads a directory and returns the list of pathnames.\n *\n * @param rootDirectory the directory to read\n * @param options options to control the behavior of the recursive read\n * @returns the list of pathnames\n */ export async function recursiveReadDir(rootDirectory, options = {}) {\n    // Grab our options.\n    const { pathnameFilter, ignoreFilter, ignorePartFilter, sortPathnames = true, relativePathnames = true } = options;\n    // The list of pathnames to return.\n    const pathnames = [];\n    /**\n   * Coerces the pathname to be relative if requested.\n   */ const coerce = relativePathnames ? (pathname)=>pathname.replace(rootDirectory, '') : (pathname)=>pathname;\n    // The queue of directories to scan.\n    let directories = [\n        rootDirectory\n    ];\n    while(directories.length > 0){\n        // Load all the files in each directory at the same time.\n        const results = await Promise.all(directories.map(async (directory)=>{\n            const result = {\n                directories: [],\n                pathnames: [],\n                links: []\n            };\n            try {\n                const dir = await fs.readdir(directory, {\n                    withFileTypes: true\n                });\n                for (const file of dir){\n                    // If enabled, ignore the file if it matches the ignore filter.\n                    if (ignorePartFilter && ignorePartFilter(file.name)) {\n                        continue;\n                    }\n                    // Handle each file.\n                    const absolutePathname = path.join(directory, file.name);\n                    // If enabled, ignore the file if it matches the ignore filter.\n                    if (ignoreFilter && ignoreFilter(absolutePathname)) {\n                        continue;\n                    }\n                    // If the file is a directory, then add it to the list of directories,\n                    // they'll be scanned on a later pass.\n                    if (file.isDirectory()) {\n                        result.directories.push(absolutePathname);\n                    } else if (file.isSymbolicLink()) {\n                        result.links.push(absolutePathname);\n                    } else if (!pathnameFilter || pathnameFilter(absolutePathname)) {\n                        result.pathnames.push(coerce(absolutePathname));\n                    }\n                }\n            } catch (err) {\n                // This can only happen when the underlying directory was removed. If\n                // anything other than this error occurs, re-throw it.\n                // if (err.code !== 'ENOENT') throw err\n                if (err.code !== 'ENOENT' || directory === rootDirectory) throw err;\n                // The error occurred, so abandon reading this directory.\n                return null;\n            }\n            return result;\n        }));\n        // Empty the directories, we'll fill it later if some of the files are\n        // directories.\n        directories = [];\n        // Keep track of any symbolic links we find, we'll resolve them later.\n        const links = [];\n        // For each result of directory scans...\n        for (const result of results){\n            // If the directory was removed, then skip it.\n            if (!result) continue;\n            // Add any directories to the list of directories to scan.\n            directories.push(...result.directories);\n            // Add any symbolic links to the list of symbolic links to resolve.\n            links.push(...result.links);\n            // Add any file pathnames to the list of pathnames.\n            pathnames.push(...result.pathnames);\n        }\n        // Resolve all the symbolic links we found if any.\n        if (links.length > 0) {\n            const resolved = await Promise.all(links.map(async (absolutePathname)=>{\n                try {\n                    return await fs.stat(absolutePathname);\n                } catch (err) {\n                    // This can only happen when the underlying link was removed. If\n                    // anything other than this error occurs, re-throw it.\n                    if (err.code !== 'ENOENT') throw err;\n                    // The error occurred, so abandon reading this directory.\n                    return null;\n                }\n            }));\n            for(let i = 0; i < links.length; i++){\n                const stats = resolved[i];\n                // If the link was removed, then skip it.\n                if (!stats) continue;\n                // We would have already ignored the file if it matched the ignore\n                // filter, so we don't need to check it again.\n                const absolutePathname = links[i];\n                if (stats.isDirectory()) {\n                    directories.push(absolutePathname);\n                } else if (!pathnameFilter || pathnameFilter(absolutePathname)) {\n                    pathnames.push(coerce(absolutePathname));\n                }\n            }\n        }\n    }\n    // Sort the pathnames in place if requested.\n    if (sortPathnames) {\n        pathnames.sort();\n    }\n    return pathnames;\n}\n\n//# sourceMappingURL=recursive-readdir.js.map"
        }
    ]
}