{
    "sourceFile": "node_modules/next/dist/esm/lib/generate-interception-routes-rewrites.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892809091,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import { pathToRegexp } from 'next/dist/compiled/path-to-regexp';\nimport { NEXT_URL } from '../client/components/app-router-headers';\nimport { extractInterceptionRouteInformation, isInterceptionRouteAppPath } from '../shared/lib/router/utils/interception-routes';\n// a function that converts normalised paths (e.g. /foo/[bar]/[baz]) to the format expected by pathToRegexp (e.g. /foo/:bar/:baz)\nfunction toPathToRegexpPath(path) {\n    return path.replace(/\\[\\[?([^\\]]+)\\]\\]?/g, (_, capture)=>{\n        // path-to-regexp only supports word characters, so we replace any non-word characters with underscores\n        const paramName = capture.replace(/\\W+/g, '_');\n        // handle catch-all segments (e.g. /foo/bar/[...baz] or /foo/bar/[[...baz]])\n        if (capture.startsWith('...')) {\n            return `:${capture.slice(3)}*`;\n        }\n        return ':' + paramName;\n    });\n}\nexport function generateInterceptionRoutesRewrites(appPaths, basePath = '') {\n    const rewrites = [];\n    for (const appPath of appPaths){\n        if (isInterceptionRouteAppPath(appPath)) {\n            const { interceptingRoute, interceptedRoute } = extractInterceptionRouteInformation(appPath);\n            const normalizedInterceptingRoute = `${interceptingRoute !== '/' ? toPathToRegexpPath(interceptingRoute) : ''}/(.*)?`;\n            const normalizedInterceptedRoute = toPathToRegexpPath(interceptedRoute);\n            const normalizedAppPath = toPathToRegexpPath(appPath);\n            // pathToRegexp returns a regex that matches the path, but we need to\n            // convert it to a string that can be used in a header value\n            // to the format that Next/the proxy expects\n            let interceptingRouteRegex = pathToRegexp(normalizedInterceptingRoute).toString().slice(2, -3);\n            rewrites.push({\n                source: `${basePath}${normalizedInterceptedRoute}`,\n                destination: `${basePath}${normalizedAppPath}`,\n                has: [\n                    {\n                        type: 'header',\n                        key: NEXT_URL,\n                        value: interceptingRouteRegex\n                    }\n                ]\n            });\n        }\n    }\n    return rewrites;\n}\nexport function isInterceptionRouteRewrite(route) {\n    var _route_has_, _route_has;\n    // When we generate interception rewrites in the above implementation, we always do so with only a single `has` condition.\n    return ((_route_has = route.has) == null ? void 0 : (_route_has_ = _route_has[0]) == null ? void 0 : _route_has_.key) === NEXT_URL;\n}\n\n//# sourceMappingURL=generate-interception-routes-rewrites.js.map"
        }
    ]
}