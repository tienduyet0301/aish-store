{
    "sourceFile": "node_modules/next/dist/esm/shared/lib/lazy-dynamic/loadable.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892849931,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from \"react/jsx-runtime\";\nimport { Suspense, Fragment, lazy } from 'react';\nimport { BailoutToCSR } from './dynamic-bailout-to-csr';\nimport { PreloadChunks } from './preload-chunks';\n// Normalize loader to return the module as form { default: Component } for `React.lazy`.\n// Also for backward compatible since next/dynamic allows to resolve a component directly with loader\n// Client component reference proxy need to be converted to a module.\nfunction convertModule(mod) {\n    // Check \"default\" prop before accessing it, as it could be client reference proxy that could break it reference.\n    // Cases:\n    // mod: { default: Component }\n    // mod: Component\n    // mod: { default: proxy(Component) }\n    // mod: proxy(Component)\n    const hasDefault = mod && 'default' in mod;\n    return {\n        default: hasDefault ? mod.default : mod\n    };\n}\nconst defaultOptions = {\n    loader: ()=>Promise.resolve(convertModule(()=>null)),\n    loading: null,\n    ssr: true\n};\nfunction Loadable(options) {\n    const opts = {\n        ...defaultOptions,\n        ...options\n    };\n    const Lazy = /*#__PURE__*/ lazy(()=>opts.loader().then(convertModule));\n    const Loading = opts.loading;\n    function LoadableComponent(props) {\n        const fallbackElement = Loading ? /*#__PURE__*/ _jsx(Loading, {\n            isLoading: true,\n            pastDelay: true,\n            error: null\n        }) : null;\n        // If it's non-SSR or provided a loading component, wrap it in a suspense boundary\n        const hasSuspenseBoundary = !opts.ssr || !!opts.loading;\n        const Wrap = hasSuspenseBoundary ? Suspense : Fragment;\n        const wrapProps = hasSuspenseBoundary ? {\n            fallback: fallbackElement\n        } : {};\n        const children = opts.ssr ? /*#__PURE__*/ _jsxs(_Fragment, {\n            children: [\n                typeof window === 'undefined' ? /*#__PURE__*/ _jsx(PreloadChunks, {\n                    moduleIds: opts.modules\n                }) : null,\n                /*#__PURE__*/ _jsx(Lazy, {\n                    ...props\n                })\n            ]\n        }) : /*#__PURE__*/ _jsx(BailoutToCSR, {\n            reason: \"next/dynamic\",\n            children: /*#__PURE__*/ _jsx(Lazy, {\n                ...props\n            })\n        });\n        return /*#__PURE__*/ _jsx(Wrap, {\n            ...wrapProps,\n            children: children\n        });\n    }\n    LoadableComponent.displayName = 'LoadableComponent';\n    return LoadableComponent;\n}\nexport default Loadable;\n\n//# sourceMappingURL=loadable.js.map"
        }
    ]
}