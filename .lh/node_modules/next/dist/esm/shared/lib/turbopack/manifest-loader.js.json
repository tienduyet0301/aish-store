{
    "sourceFile": "node_modules/next/dist/esm/shared/lib/turbopack/manifest-loader.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892853211,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import { pathToRegexp } from 'next/dist/compiled/path-to-regexp';\nimport { APP_BUILD_MANIFEST, APP_PATHS_MANIFEST, BUILD_MANIFEST, INTERCEPTION_ROUTE_REWRITE_MANIFEST, MIDDLEWARE_BUILD_MANIFEST, MIDDLEWARE_MANIFEST, NEXT_FONT_MANIFEST, PAGES_MANIFEST, SERVER_REFERENCE_MANIFEST, TURBOPACK_CLIENT_MIDDLEWARE_MANIFEST, WEBPACK_STATS } from '../constants';\nimport { join, posix } from 'path';\nimport { readFile } from 'fs/promises';\nimport { deleteCache } from '../../../server/dev/require-cache';\nimport { writeFileAtomic } from '../../../lib/fs/write-atomic';\nimport { isInterceptionRouteRewrite } from '../../../lib/generate-interception-routes-rewrites';\nimport { normalizeRewritesForBuildManifest, srcEmptySsgManifest, processRoute, createEdgeRuntimeManifest } from '../../../build/webpack/plugins/build-manifest-plugin';\nimport getAssetPathFromRoute from '../router/utils/get-asset-path-from-route';\nimport { getEntryKey } from './entry-key';\nimport { getSortedRoutes } from '../router/utils';\nimport { existsSync } from 'fs';\nimport { addMetadataIdToRoute, addRouteSuffix, removeRouteSuffix } from '../../../server/dev/turbopack-utils';\nimport { tryToParsePath } from '../../../lib/try-to-parse-path';\nconst getManifestPath = (page, distDir, name, type, firstCall)=>{\n    let manifestPath = posix.join(distDir, \"server\", type, type === 'middleware' || type === 'instrumentation' ? '' : type === 'app' ? page : getAssetPathFromRoute(page), name);\n    if (firstCall) {\n        const isSitemapRoute = /[\\\\/]sitemap(.xml)?\\/route$/.test(page);\n        // Check the ambiguity of /sitemap and /sitemap.xml\n        if (isSitemapRoute && !existsSync(manifestPath)) {\n            manifestPath = getManifestPath(page.replace(/\\/sitemap\\/route$/, '/sitemap.xml/route'), distDir, name, type, false);\n        }\n        // existsSync is faster than using the async version\n        if (!existsSync(manifestPath) && page.endsWith('/route')) {\n            // TODO: Improve implementation of metadata routes, currently it requires this extra check for the variants of the files that can be written.\n            let metadataPage = addRouteSuffix(addMetadataIdToRoute(removeRouteSuffix(page)));\n            manifestPath = getManifestPath(metadataPage, distDir, name, type, false);\n        }\n    }\n    return manifestPath;\n};\nasync function readPartialManifest(distDir, name, pageName, type) {\n    if (type === void 0) type = 'pages';\n    const page = pageName;\n    const manifestPath = getManifestPath(page, distDir, name, type, true);\n    return JSON.parse(await readFile(posix.join(manifestPath), 'utf-8'));\n}\nexport class TurbopackManifestLoader {\n    delete(key) {\n        this.actionManifests.delete(key);\n        this.appBuildManifests.delete(key);\n        this.appPathsManifests.delete(key);\n        this.buildManifests.delete(key);\n        this.fontManifests.delete(key);\n        this.middlewareManifests.delete(key);\n        this.pagesManifests.delete(key);\n        this.webpackStats.delete(key);\n    }\n    async loadActionManifest(pageName) {\n        this.actionManifests.set(getEntryKey('app', 'server', pageName), await readPartialManifest(this.distDir, \"\" + SERVER_REFERENCE_MANIFEST + \".json\", pageName, 'app'));\n    }\n    async mergeActionManifests(manifests) {\n        const manifest = {\n            node: {},\n            edge: {},\n            encryptionKey: this.encryptionKey\n        };\n        function mergeActionIds(actionEntries, other) {\n            for(const key in other){\n                var _actionEntries, _key;\n                var _;\n                const action = (_ = (_actionEntries = actionEntries)[_key = key]) != null ? _ : _actionEntries[_key] = {\n                    workers: {},\n                    layer: {}\n                };\n                Object.assign(action.workers, other[key].workers);\n                Object.assign(action.layer, other[key].layer);\n            }\n        }\n        for (const m of manifests){\n            mergeActionIds(manifest.node, m.node);\n            mergeActionIds(manifest.edge, m.edge);\n        }\n        for(const key in manifest.node){\n            const entry = manifest.node[key];\n            entry.workers = sortObjectByKey(entry.workers);\n            entry.layer = sortObjectByKey(entry.layer);\n        }\n        for(const key in manifest.edge){\n            const entry = manifest.edge[key];\n            entry.workers = sortObjectByKey(entry.workers);\n            entry.layer = sortObjectByKey(entry.layer);\n        }\n        return manifest;\n    }\n    async writeActionManifest() {\n        const actionManifest = await this.mergeActionManifests(this.actionManifests.values());\n        const actionManifestJsonPath = join(this.distDir, 'server', \"\" + SERVER_REFERENCE_MANIFEST + \".json\");\n        const actionManifestJsPath = join(this.distDir, 'server', \"\" + SERVER_REFERENCE_MANIFEST + \".js\");\n        const json = JSON.stringify(actionManifest, null, 2);\n        deleteCache(actionManifestJsonPath);\n        deleteCache(actionManifestJsPath);\n        await writeFileAtomic(actionManifestJsonPath, json);\n        await writeFileAtomic(actionManifestJsPath, \"self.__RSC_SERVER_MANIFEST=\" + JSON.stringify(json));\n    }\n    async loadAppBuildManifest(pageName) {\n        this.appBuildManifests.set(getEntryKey('app', 'server', pageName), await readPartialManifest(this.distDir, APP_BUILD_MANIFEST, pageName, 'app'));\n    }\n    mergeAppBuildManifests(manifests) {\n        const manifest = {\n            pages: {}\n        };\n        for (const m of manifests){\n            Object.assign(manifest.pages, m.pages);\n        }\n        manifest.pages = sortObjectByKey(manifest.pages);\n        return manifest;\n    }\n    async writeAppBuildManifest() {\n        const appBuildManifest = this.mergeAppBuildManifests(this.appBuildManifests.values());\n        const appBuildManifestPath = join(this.distDir, APP_BUILD_MANIFEST);\n        deleteCache(appBuildManifestPath);\n        await writeFileAtomic(appBuildManifestPath, JSON.stringify(appBuildManifest, null, 2));\n    }\n    async loadAppPathsManifest(pageName) {\n        this.appPathsManifests.set(getEntryKey('app', 'server', pageName), await readPartialManifest(this.distDir, APP_PATHS_MANIFEST, pageName, 'app'));\n    }\n    async writeAppPathsManifest() {\n        const appPathsManifest = this.mergePagesManifests(this.appPathsManifests.values());\n        const appPathsManifestPath = join(this.distDir, 'server', APP_PATHS_MANIFEST);\n        deleteCache(appPathsManifestPath);\n        await writeFileAtomic(appPathsManifestPath, JSON.stringify(appPathsManifest, null, 2));\n    }\n    async writeWebpackStats() {\n        const webpackStats = this.mergeWebpackStats(this.webpackStats.values());\n        const path = join(this.distDir, 'server', WEBPACK_STATS);\n        deleteCache(path);\n        await writeFileAtomic(path, JSON.stringify(webpackStats, null, 2));\n    }\n    async loadBuildManifest(pageName, type) {\n        if (type === void 0) type = 'pages';\n        this.buildManifests.set(getEntryKey(type, 'server', pageName), await readPartialManifest(this.distDir, BUILD_MANIFEST, pageName, type));\n    }\n    async loadWebpackStats(pageName, type) {\n        if (type === void 0) type = 'pages';\n        this.webpackStats.set(getEntryKey(type, 'client', pageName), await readPartialManifest(this.distDir, WEBPACK_STATS, pageName, type));\n    }\n    mergeWebpackStats(statsFiles) {\n        const entrypoints = {};\n        const assets = new Map();\n        const chunks = new Map();\n        const modules = new Map();\n        for (const statsFile of statsFiles){\n            if (statsFile.entrypoints) {\n                for (const [k, v] of Object.entries(statsFile.entrypoints)){\n                    if (!entrypoints[k]) {\n                        entrypoints[k] = v;\n                    }\n                }\n            }\n            if (statsFile.assets) {\n                for (const asset of statsFile.assets){\n                    if (!assets.has(asset.name)) {\n                        assets.set(asset.name, asset);\n                    }\n                }\n            }\n            if (statsFile.chunks) {\n                for (const chunk of statsFile.chunks){\n                    if (!chunks.has(chunk.name)) {\n                        chunks.set(chunk.name, chunk);\n                    }\n                }\n            }\n            if (statsFile.modules) {\n                for (const module of statsFile.modules){\n                    const id = module.id;\n                    if (id != null) {\n                        // Merge the chunk list for the module. This can vary across endpoints.\n                        const existing = modules.get(id);\n                        if (existing == null) {\n                            modules.set(id, module);\n                        } else if (module.chunks != null && existing.chunks != null) {\n                            for (const chunk of module.chunks){\n                                if (!existing.chunks.includes(chunk)) {\n                                    existing.chunks.push(chunk);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return {\n            entrypoints,\n            assets: [\n                ...assets.values()\n            ],\n            chunks: [\n                ...chunks.values()\n            ],\n            modules: [\n                ...modules.values()\n            ]\n        };\n    }\n    mergeBuildManifests(manifests) {\n        const manifest = {\n            pages: {\n                '/_app': []\n            },\n            // Something in next.js depends on these to exist even for app dir rendering\n            devFiles: [],\n            ampDevFiles: [],\n            polyfillFiles: [],\n            lowPriorityFiles: [\n                \"static/\" + this.buildId + \"/_ssgManifest.js\",\n                \"static/\" + this.buildId + \"/_buildManifest.js\"\n            ],\n            rootMainFiles: [],\n            ampFirstPages: []\n        };\n        for (const m of manifests){\n            Object.assign(manifest.pages, m.pages);\n            if (m.rootMainFiles.length) manifest.rootMainFiles = m.rootMainFiles;\n            // polyfillFiles should always be the same, so we can overwrite instead of actually merging\n            if (m.polyfillFiles.length) manifest.polyfillFiles = m.polyfillFiles;\n        }\n        manifest.pages = sortObjectByKey(manifest.pages);\n        return manifest;\n    }\n    async writeBuildManifest(entrypoints, devRewrites, productionRewrites) {\n        var _devRewrites_beforeFiles, _devRewrites_afterFiles, _devRewrites_fallback;\n        const rewrites = productionRewrites != null ? productionRewrites : {\n            ...devRewrites,\n            beforeFiles: ((_devRewrites_beforeFiles = devRewrites == null ? void 0 : devRewrites.beforeFiles) != null ? _devRewrites_beforeFiles : []).map(processRoute),\n            afterFiles: ((_devRewrites_afterFiles = devRewrites == null ? void 0 : devRewrites.afterFiles) != null ? _devRewrites_afterFiles : []).map(processRoute),\n            fallback: ((_devRewrites_fallback = devRewrites == null ? void 0 : devRewrites.fallback) != null ? _devRewrites_fallback : []).map(processRoute)\n        };\n        const buildManifest = this.mergeBuildManifests(this.buildManifests.values());\n        const buildManifestPath = join(this.distDir, BUILD_MANIFEST);\n        const middlewareBuildManifestPath = join(this.distDir, 'server', \"\" + MIDDLEWARE_BUILD_MANIFEST + \".js\");\n        const interceptionRewriteManifestPath = join(this.distDir, 'server', \"\" + INTERCEPTION_ROUTE_REWRITE_MANIFEST + \".js\");\n        deleteCache(buildManifestPath);\n        deleteCache(middlewareBuildManifestPath);\n        deleteCache(interceptionRewriteManifestPath);\n        await writeFileAtomic(buildManifestPath, JSON.stringify(buildManifest, null, 2));\n        await writeFileAtomic(middlewareBuildManifestPath, // we use globalThis here because middleware can be node\n        // which doesn't have \"self\"\n        createEdgeRuntimeManifest(buildManifest));\n        const interceptionRewrites = JSON.stringify(rewrites.beforeFiles.filter(isInterceptionRouteRewrite));\n        await writeFileAtomic(interceptionRewriteManifestPath, \"self.__INTERCEPTION_ROUTE_REWRITE_MANIFEST=\" + JSON.stringify(interceptionRewrites) + \";\");\n        const pagesKeys = [\n            ...entrypoints.page.keys()\n        ];\n        if (entrypoints.global.app) {\n            pagesKeys.push('/_app');\n        }\n        if (entrypoints.global.error) {\n            pagesKeys.push('/_error');\n        }\n        const sortedPageKeys = getSortedRoutes(pagesKeys);\n        const content = {\n            __rewrites: normalizeRewritesForBuildManifest(rewrites),\n            ...Object.fromEntries(sortedPageKeys.map((pathname)=>[\n                    pathname,\n                    [\n                        \"static/chunks/pages\" + (pathname === '/' ? '/index' : pathname) + \".js\"\n                    ]\n                ])),\n            sortedPages: sortedPageKeys\n        };\n        const buildManifestJs = \"self.__BUILD_MANIFEST = \" + JSON.stringify(content) + \";self.__BUILD_MANIFEST_CB && self.__BUILD_MANIFEST_CB()\";\n        await writeFileAtomic(join(this.distDir, 'static', this.buildId, '_buildManifest.js'), buildManifestJs);\n        await writeFileAtomic(join(this.distDir, 'static', this.buildId, '_ssgManifest.js'), srcEmptySsgManifest);\n    }\n    async writeClientMiddlewareManifest() {\n        var _middlewareManifest_middleware_;\n        const middlewareManifest = this.mergeMiddlewareManifests(this.middlewareManifests.values());\n        const matchers = (middlewareManifest == null ? void 0 : (_middlewareManifest_middleware_ = middlewareManifest.middleware['/']) == null ? void 0 : _middlewareManifest_middleware_.matchers) || [];\n        const clientMiddlewareManifestPath = join(this.distDir, 'static', this.buildId, \"\" + TURBOPACK_CLIENT_MIDDLEWARE_MANIFEST);\n        deleteCache(clientMiddlewareManifestPath);\n        await writeFileAtomic(clientMiddlewareManifestPath, JSON.stringify(matchers, null, 2));\n    }\n    async writeFallbackBuildManifest() {\n        const fallbackBuildManifest = this.mergeBuildManifests([\n            this.buildManifests.get(getEntryKey('pages', 'server', '_app')),\n            this.buildManifests.get(getEntryKey('pages', 'server', '_error'))\n        ].filter(Boolean));\n        const fallbackBuildManifestPath = join(this.distDir, \"fallback-\" + BUILD_MANIFEST);\n        deleteCache(fallbackBuildManifestPath);\n        await writeFileAtomic(fallbackBuildManifestPath, JSON.stringify(fallbackBuildManifest, null, 2));\n    }\n    async loadFontManifest(pageName, type) {\n        if (type === void 0) type = 'pages';\n        this.fontManifests.set(getEntryKey(type, 'server', pageName), await readPartialManifest(this.distDir, \"\" + NEXT_FONT_MANIFEST + \".json\", pageName, type));\n    }\n    mergeFontManifests(manifests) {\n        const manifest = {\n            app: {},\n            appUsingSizeAdjust: false,\n            pages: {},\n            pagesUsingSizeAdjust: false\n        };\n        for (const m of manifests){\n            Object.assign(manifest.app, m.app);\n            Object.assign(manifest.pages, m.pages);\n            manifest.appUsingSizeAdjust = manifest.appUsingSizeAdjust || m.appUsingSizeAdjust;\n            manifest.pagesUsingSizeAdjust = manifest.pagesUsingSizeAdjust || m.pagesUsingSizeAdjust;\n        }\n        manifest.app = sortObjectByKey(manifest.app);\n        manifest.pages = sortObjectByKey(manifest.pages);\n        return manifest;\n    }\n    async writeNextFontManifest() {\n        const fontManifest = this.mergeFontManifests(this.fontManifests.values());\n        const json = JSON.stringify(fontManifest, null, 2);\n        const fontManifestJsonPath = join(this.distDir, 'server', \"\" + NEXT_FONT_MANIFEST + \".json\");\n        const fontManifestJsPath = join(this.distDir, 'server', \"\" + NEXT_FONT_MANIFEST + \".js\");\n        deleteCache(fontManifestJsonPath);\n        deleteCache(fontManifestJsPath);\n        await writeFileAtomic(fontManifestJsonPath, json);\n        await writeFileAtomic(fontManifestJsPath, \"self.__NEXT_FONT_MANIFEST=\" + JSON.stringify(json));\n    }\n    /**\n   * @returns If the manifest was written or not\n   */ async loadMiddlewareManifest(pageName, type) {\n        const middlewareManifestPath = getManifestPath(pageName, this.distDir, MIDDLEWARE_MANIFEST, type, true);\n        // middlewareManifest is actually \"edge manifest\" and not all routes are edge runtime. If it is not written we skip it.\n        if (!existsSync(middlewareManifestPath)) {\n            return false;\n        }\n        this.middlewareManifests.set(getEntryKey(type === 'middleware' || type === 'instrumentation' ? 'root' : type, 'server', pageName), await readPartialManifest(this.distDir, MIDDLEWARE_MANIFEST, pageName, type));\n        return true;\n    }\n    getMiddlewareManifest(key) {\n        return this.middlewareManifests.get(key);\n    }\n    deleteMiddlewareManifest(key) {\n        return this.middlewareManifests.delete(key);\n    }\n    mergeMiddlewareManifests(manifests) {\n        const manifest = {\n            version: 3,\n            middleware: {},\n            sortedMiddleware: [],\n            functions: {}\n        };\n        let instrumentation = undefined;\n        for (const m of manifests){\n            Object.assign(manifest.functions, m.functions);\n            Object.assign(manifest.middleware, m.middleware);\n            if (m.instrumentation) {\n                instrumentation = m.instrumentation;\n            }\n        }\n        manifest.functions = sortObjectByKey(manifest.functions);\n        manifest.middleware = sortObjectByKey(manifest.middleware);\n        const updateFunctionDefinition = (fun)=>{\n            var _instrumentation_files;\n            return {\n                ...fun,\n                files: [\n                    ...(_instrumentation_files = instrumentation == null ? void 0 : instrumentation.files) != null ? _instrumentation_files : [],\n                    ...fun.files\n                ]\n            };\n        };\n        for (const key of Object.keys(manifest.middleware)){\n            const value = manifest.middleware[key];\n            manifest.middleware[key] = updateFunctionDefinition(value);\n        }\n        for (const key of Object.keys(manifest.functions)){\n            const value = manifest.functions[key];\n            manifest.functions[key] = updateFunctionDefinition(value);\n        }\n        for (const fun of Object.values(manifest.functions).concat(Object.values(manifest.middleware))){\n            for (const matcher of fun.matchers){\n                if (!matcher.regexp) {\n                    matcher.regexp = pathToRegexp(matcher.originalSource, [], {\n                        delimiter: '/',\n                        sensitive: false,\n                        strict: true\n                    }).source.replaceAll('\\\\/', '/');\n                }\n            }\n        }\n        manifest.sortedMiddleware = Object.keys(manifest.middleware);\n        return manifest;\n    }\n    async writeMiddlewareManifest() {\n        const middlewareManifest = this.mergeMiddlewareManifests(this.middlewareManifests.values());\n        // Normalize regexes as it uses path-to-regexp\n        for(const key in middlewareManifest.middleware){\n            middlewareManifest.middleware[key].matchers.forEach((matcher)=>{\n                if (!matcher.regexp.startsWith('^')) {\n                    const parsedPage = tryToParsePath(matcher.regexp);\n                    if (parsedPage.error || !parsedPage.regexStr) {\n                        throw Object.defineProperty(new Error(\"Invalid source: \" + matcher.regexp), \"__NEXT_ERROR_CODE\", {\n                            value: \"E442\",\n                            enumerable: false,\n                            configurable: true\n                        });\n                    }\n                    matcher.regexp = parsedPage.regexStr;\n                }\n            });\n        }\n        const middlewareManifestPath = join(this.distDir, 'server', MIDDLEWARE_MANIFEST);\n        deleteCache(middlewareManifestPath);\n        await writeFileAtomic(middlewareManifestPath, JSON.stringify(middlewareManifest, null, 2));\n    }\n    async loadPagesManifest(pageName) {\n        this.pagesManifests.set(getEntryKey('pages', 'server', pageName), await readPartialManifest(this.distDir, PAGES_MANIFEST, pageName));\n    }\n    mergePagesManifests(manifests) {\n        const manifest = {};\n        for (const m of manifests){\n            Object.assign(manifest, m);\n        }\n        return sortObjectByKey(manifest);\n    }\n    async writePagesManifest() {\n        const pagesManifest = this.mergePagesManifests(this.pagesManifests.values());\n        const pagesManifestPath = join(this.distDir, 'server', PAGES_MANIFEST);\n        deleteCache(pagesManifestPath);\n        await writeFileAtomic(pagesManifestPath, JSON.stringify(pagesManifest, null, 2));\n    }\n    async writeManifests(param) {\n        let { devRewrites, productionRewrites, entrypoints } = param;\n        await this.writeActionManifest();\n        await this.writeAppBuildManifest();\n        await this.writeAppPathsManifest();\n        await this.writeBuildManifest(entrypoints, devRewrites, productionRewrites);\n        await this.writeFallbackBuildManifest();\n        await this.writeMiddlewareManifest();\n        await this.writeClientMiddlewareManifest();\n        await this.writeNextFontManifest();\n        await this.writePagesManifest();\n        if (process.env.TURBOPACK_STATS != null) {\n            await this.writeWebpackStats();\n        }\n    }\n    constructor({ distDir, buildId, encryptionKey }){\n        this.actionManifests = new Map();\n        this.appBuildManifests = new Map();\n        this.appPathsManifests = new Map();\n        this.buildManifests = new Map();\n        this.fontManifests = new Map();\n        this.middlewareManifests = new Map();\n        this.pagesManifests = new Map();\n        this.webpackStats = new Map();\n        this.distDir = distDir;\n        this.buildId = buildId;\n        this.encryptionKey = encryptionKey;\n    }\n}\nfunction sortObjectByKey(obj) {\n    return Object.keys(obj).sort().reduce((acc, key)=>{\n        acc[key] = obj[key];\n        return acc;\n    }, {});\n}\n\n//# sourceMappingURL=manifest-loader.js.map"
        }
    ]
}