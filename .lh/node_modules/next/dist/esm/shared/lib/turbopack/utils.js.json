{
    "sourceFile": "node_modules/next/dist/esm/shared/lib/turbopack/utils.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892853264,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import { bold, green, magenta, red } from '../../../lib/picocolors';\nimport isInternal from '../is-internal';\nimport { decodeMagicIdentifier, MAGIC_IDENTIFIER_REGEX } from '../magic-identifier';\nimport * as Log from '../../../build/output/log';\nimport loadJsConfig from '../../../build/load-jsconfig';\nimport { eventErrorThrown } from '../../../telemetry/events';\nimport { traceGlobals } from '../../../trace/shared';\n// An error generated from emitted Turbopack issues. This can include build\n// errors caused by issues with user code.\nexport class ModuleBuildError extends Error {\n    constructor(...args){\n        super(...args), this.name = 'ModuleBuildError';\n    }\n}\n// An error caused by an internal issue in Turbopack. These should be written\n// to a log file and details should not be shown to the user.\nexport class TurbopackInternalError extends Error {\n    static createAndRecordTelemetry(cause) {\n        const error = new TurbopackInternalError(cause);\n        const telemetry = traceGlobals.get('telemetry');\n        if (telemetry) {\n            telemetry.record(eventErrorThrown(error));\n        } else {\n            console.error('Expected `telemetry` to be set in globals');\n        }\n        return error;\n    }\n    constructor(cause){\n        super(cause.message), this.name = 'TurbopackInternalError', // Manually set this as this isn't statically determinable\n        this.__NEXT_ERROR_CODE = 'TurbopackInternalError';\n        this.stack = cause.stack;\n    }\n}\n/**\n * Thin stopgap workaround layer to mimic existing wellknown-errors-plugin in webpack's build\n * to emit certain type of errors into cli.\n */ export function isWellKnownError(issue) {\n    const { title } = issue;\n    const formattedTitle = renderStyledStringToErrorAnsi(title);\n    // TODO: add more well known errors\n    if (formattedTitle.includes('Module not found') || formattedTitle.includes('Unknown module type')) {\n        return true;\n    }\n    return false;\n}\nexport function getIssueKey(issue) {\n    return issue.severity + \"-\" + issue.filePath + \"-\" + JSON.stringify(issue.title) + \"-\" + JSON.stringify(issue.description);\n}\nexport async function getTurbopackJsConfig(dir, nextConfig) {\n    const { jsConfig } = await loadJsConfig(dir, nextConfig);\n    return jsConfig != null ? jsConfig : {\n        compilerOptions: {}\n    };\n}\nexport function processIssues(currentEntryIssues, key, result, throwIssue, logErrors) {\n    const newIssues = new Map();\n    currentEntryIssues.set(key, newIssues);\n    const relevantIssues = new Set();\n    for (const issue of result.issues){\n        if (issue.severity !== 'error' && issue.severity !== 'fatal' && issue.severity !== 'warning') continue;\n        const issueKey = getIssueKey(issue);\n        newIssues.set(issueKey, issue);\n        if (issue.severity !== 'warning') {\n            if (throwIssue) {\n                const formatted = formatIssue(issue);\n                relevantIssues.add(formatted);\n            } else if (logErrors && isWellKnownError(issue)) {\n                const formatted = formatIssue(issue);\n                Log.error(formatted);\n            }\n        }\n    }\n    if (relevantIssues.size && throwIssue) {\n        throw Object.defineProperty(new ModuleBuildError([\n            ...relevantIssues\n        ].join('\\n\\n')), \"__NEXT_ERROR_CODE\", {\n            value: \"E394\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n}\nexport function formatIssue(issue) {\n    const { filePath, title, description, source } = issue;\n    let { documentationLink } = issue;\n    let formattedTitle = renderStyledStringToErrorAnsi(title).replace(/\\n/g, '\\n    ');\n    // TODO: Use error codes to identify these\n    // TODO: Generalize adapting Turbopack errors to Next.js errors\n    if (formattedTitle.includes('Module not found')) {\n        // For compatiblity with webpack\n        // TODO: include columns in webpack errors.\n        documentationLink = 'https://nextjs.org/docs/messages/module-not-found';\n    }\n    let formattedFilePath = filePath.replace('[project]/', './').replaceAll('/./', '/').replace('\\\\\\\\?\\\\', '');\n    let message = '';\n    if (source && source.range) {\n        const { start } = source.range;\n        message = formattedFilePath + \":\" + (start.line + 1) + \":\" + (start.column + 1) + \"\\n\" + formattedTitle;\n    } else if (formattedFilePath) {\n        message = formattedFilePath + \"\\n\" + formattedTitle;\n    } else {\n        message = formattedTitle;\n    }\n    message += '\\n';\n    if ((source == null ? void 0 : source.range) && source.source.content && // ignore Next.js/React internals, as these can often be huge bundled files.\n    !isInternal(filePath)) {\n        const { start, end } = source.range;\n        const { codeFrameColumns } = require('next/dist/compiled/babel/code-frame');\n        message += codeFrameColumns(source.source.content, {\n            start: {\n                line: start.line + 1,\n                column: start.column + 1\n            },\n            end: {\n                line: end.line + 1,\n                column: end.column + 1\n            }\n        }, {\n            forceColor: true\n        }).trim() + '\\n\\n';\n    }\n    if (description) {\n        message += renderStyledStringToErrorAnsi(description) + '\\n\\n';\n    }\n    // TODO: make it possible to enable this for debugging, but not in tests.\n    // if (detail) {\n    //   message += renderStyledStringToErrorAnsi(detail) + '\\n\\n'\n    // }\n    // TODO: Include a trace from the issue.\n    if (documentationLink) {\n        message += documentationLink + '\\n\\n';\n    }\n    return message;\n}\nexport function isRelevantWarning(issue) {\n    return issue.severity === 'warning' && !isNodeModulesIssue(issue);\n}\nfunction isNodeModulesIssue(issue) {\n    if (issue.severity === 'warning' && issue.stage === 'config') {\n        // Override for the externalize issue\n        // `Package foo (serverExternalPackages or default list) can't be external`\n        if (renderStyledStringToErrorAnsi(issue.title).includes(\"can't be external\")) {\n            return false;\n        }\n    }\n    return issue.severity === 'warning' && (issue.filePath.match(/^(?:.*[\\\\/])?node_modules(?:[\\\\/].*)?$/) !== null || // Ignore Next.js itself when running next directly in the monorepo where it is not inside\n    // node_modules anyway.\n    // TODO(mischnic) prevent matches when this is published to npm\n    issue.filePath.startsWith('[project]/packages/next/'));\n}\nexport function renderStyledStringToErrorAnsi(string) {\n    function decodeMagicIdentifiers(str) {\n        return str.replaceAll(MAGIC_IDENTIFIER_REGEX, (ident)=>{\n            try {\n                return magenta(\"{\" + decodeMagicIdentifier(ident) + \"}\");\n            } catch (e) {\n                return magenta(\"{\" + ident + \" (decoding failed: \" + e + \")}\");\n            }\n        });\n    }\n    switch(string.type){\n        case 'text':\n            return decodeMagicIdentifiers(string.value);\n        case 'strong':\n            return bold(red(decodeMagicIdentifiers(string.value)));\n        case 'code':\n            return green(decodeMagicIdentifiers(string.value));\n        case 'line':\n            return string.value.map(renderStyledStringToErrorAnsi).join('');\n        case 'stack':\n            return string.value.map(renderStyledStringToErrorAnsi).join('\\n');\n        default:\n            throw Object.defineProperty(new Error('Unknown StyledString type', string), \"__NEXT_ERROR_CODE\", {\n                value: \"E138\",\n                enumerable: false,\n                configurable: true\n            });\n    }\n}\nexport function isPersistentCachingEnabled(config) {\n    var _config_experimental;\n    return ((_config_experimental = config.experimental) == null ? void 0 : _config_experimental.turbopackPersistentCaching) || false;\n}\n\n//# sourceMappingURL=utils.js.map"
        }
    ]
}