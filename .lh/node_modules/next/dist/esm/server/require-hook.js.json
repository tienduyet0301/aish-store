{
    "sourceFile": "node_modules/next/dist/esm/server/require-hook.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892837813,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "// Synchronously inject a require hook for webpack and webpack/. It's required to use the internal ncc webpack version.\n// This is needed for userland plugins to attach to the same webpack instance as Next.js'.\n// Individually compiled modules are as defined for the compilation in bundles/webpack/packages/*.\n// This module will only be loaded once per process.\nconst path = require('path');\nconst mod = require('module');\nconst originalRequire = mod.prototype.require;\nconst resolveFilename = mod._resolveFilename;\nlet resolve = process.env.NEXT_MINIMAL ? __non_webpack_require__.resolve : require.resolve;\nexport const hookPropertyMap = new Map();\nexport const defaultOverrides = {\n    'styled-jsx': path.dirname(resolve('styled-jsx/package.json')),\n    'styled-jsx/style': resolve('styled-jsx/style'),\n    'styled-jsx/style.js': resolve('styled-jsx/style')\n};\nconst toResolveMap = (map)=>Object.entries(map).map(([key, value])=>[\n            key,\n            resolve(value)\n        ]);\nexport function addHookAliases(aliases = []) {\n    for (const [key, value] of aliases){\n        hookPropertyMap.set(key, value);\n    }\n}\naddHookAliases(toResolveMap(defaultOverrides));\nmod._resolveFilename = (function(originalResolveFilename, requestMap, request, parent, isMain, options) {\n    const hookResolved = requestMap.get(request);\n    if (hookResolved) request = hookResolved;\n    return originalResolveFilename.call(mod, request, parent, isMain, options);\n// We use `bind` here to avoid referencing outside variables to create potential memory leaks.\n}).bind(null, resolveFilename, hookPropertyMap);\n// This is a hack to make sure that if a user requires a Next.js module that wasn't bundled\n// that needs to point to the rendering runtime version, it will point to the correct one.\n// This can happen on `pages` when a user requires a dependency that uses next/image for example.\nmod.prototype.require = function(request) {\n    if (request.endsWith('.shared-runtime')) {\n        return originalRequire.call(this, `next/dist/server/route-modules/pages/vendored/contexts/${path.basename(request, '.shared-runtime')}`);\n    }\n    return originalRequire.call(this, request);\n};\n\n//# sourceMappingURL=require-hook.js.map"
        }
    ]
}