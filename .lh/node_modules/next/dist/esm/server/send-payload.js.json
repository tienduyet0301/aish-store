{
    "sourceFile": "node_modules/next/dist/esm/server/send-payload.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892844593,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import { isResSent } from '../shared/lib/utils';\nimport { generateETag } from './lib/etag';\nimport fresh from 'next/dist/compiled/fresh';\nimport { getCacheControlHeader } from './lib/cache-control';\nimport { RSC_CONTENT_TYPE_HEADER } from '../client/components/app-router-headers';\nexport function sendEtagResponse(req, res, etag) {\n    if (etag) {\n        /**\n     * The server generating a 304 response MUST generate any of the\n     * following header fields that would have been sent in a 200 (OK)\n     * response to the same request: Cache-Control, Content-Location, Date,\n     * ETag, Expires, and Vary. https://tools.ietf.org/html/rfc7232#section-4.1\n     */ res.setHeader('ETag', etag);\n    }\n    if (fresh(req.headers, {\n        etag\n    })) {\n        res.statusCode = 304;\n        res.end();\n        return true;\n    }\n    return false;\n}\nexport async function sendRenderResult({ req, res, result, type, generateEtags, poweredByHeader, cacheControl }) {\n    if (isResSent(res)) {\n        return;\n    }\n    if (poweredByHeader && type === 'html') {\n        res.setHeader('X-Powered-By', 'Next.js');\n    }\n    // If cache control is already set on the response we don't\n    // override it to allow users to customize it via next.config\n    if (cacheControl && !res.getHeader('Cache-Control')) {\n        res.setHeader('Cache-Control', getCacheControlHeader(cacheControl));\n    }\n    const payload = result.isDynamic ? null : result.toUnchunkedString();\n    if (generateEtags && payload !== null) {\n        const etag = generateETag(payload);\n        if (sendEtagResponse(req, res, etag)) {\n            return;\n        }\n    }\n    if (!res.getHeader('Content-Type')) {\n        res.setHeader('Content-Type', result.contentType ? result.contentType : type === 'rsc' ? RSC_CONTENT_TYPE_HEADER : type === 'json' ? 'application/json' : 'text/html; charset=utf-8');\n    }\n    if (payload) {\n        res.setHeader('Content-Length', Buffer.byteLength(payload));\n    }\n    if (req.method === 'HEAD') {\n        res.end(null);\n        return;\n    }\n    if (payload !== null) {\n        res.end(payload);\n        return;\n    }\n    // Pipe the render result to the response after we get a writer for it.\n    await result.pipeToNodeResponse(res);\n}\n\n//# sourceMappingURL=send-payload.js.map"
        }
    ]
}