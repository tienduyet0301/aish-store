{
    "sourceFile": "node_modules/next/dist/esm/server/web/spec-extension/revalidate.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892847216,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import { abortAndThrowOnSynchronousRequestDataAccess, postponeWithTracking } from '../../app-render/dynamic-rendering';\nimport { isDynamicRoute } from '../../../shared/lib/router/utils';\nimport { NEXT_CACHE_IMPLICIT_TAG_ID, NEXT_CACHE_SOFT_TAG_MAX_LENGTH } from '../../../lib/constants';\nimport { workAsyncStorage } from '../../app-render/work-async-storage.external';\nimport { workUnitAsyncStorage } from '../../app-render/work-unit-async-storage.external';\nimport { DynamicServerError } from '../../../client/components/hooks-server-context';\n/**\n * This function allows you to purge [cached data](https://nextjs.org/docs/app/building-your-application/caching) on-demand for a specific cache tag.\n *\n * Read more: [Next.js Docs: `revalidateTag`](https://nextjs.org/docs/app/api-reference/functions/revalidateTag)\n */ export function revalidateTag(tag) {\n    return revalidate([\n        tag\n    ], `revalidateTag ${tag}`);\n}\n/**\n * This function allows you to purge [cached data](https://nextjs.org/docs/app/building-your-application/caching) on-demand for a specific path.\n *\n * Read more: [Next.js Docs: `unstable_expirePath`](https://nextjs.org/docs/app/api-reference/functions/unstable_expirePath)\n */ export function unstable_expirePath(originalPath, type) {\n    if (originalPath.length > NEXT_CACHE_SOFT_TAG_MAX_LENGTH) {\n        console.warn(`Warning: expirePath received \"${originalPath}\" which exceeded max length of ${NEXT_CACHE_SOFT_TAG_MAX_LENGTH}. See more info here https://nextjs.org/docs/app/api-reference/functions/unstable_expirePath`);\n        return;\n    }\n    let normalizedPath = `${NEXT_CACHE_IMPLICIT_TAG_ID}${originalPath}`;\n    if (type) {\n        normalizedPath += `${normalizedPath.endsWith('/') ? '' : '/'}${type}`;\n    } else if (isDynamicRoute(originalPath)) {\n        console.warn(`Warning: a dynamic page path \"${originalPath}\" was passed to \"expirePath\", but the \"type\" parameter is missing. This has no effect by default, see more info here https://nextjs.org/docs/app/api-reference/functions/unstable_expirePath`);\n    }\n    return revalidate([\n        normalizedPath\n    ], `unstable_expirePath ${originalPath}`);\n}\n/**\n * This function allows you to purge [cached data](https://nextjs.org/docs/app/building-your-application/caching) on-demand for a specific cache tag.\n *\n * Read more: [Next.js Docs: `unstable_expireTag`](https://nextjs.org/docs/app/api-reference/functions/unstable_expireTag)\n */ export function unstable_expireTag(...tags) {\n    return revalidate(tags, `unstable_expireTag ${tags.join(', ')}`);\n}\n/**\n * This function allows you to purge [cached data](https://nextjs.org/docs/app/building-your-application/caching) on-demand for a specific path.\n *\n * Read more: [Next.js Docs: `revalidatePath`](https://nextjs.org/docs/app/api-reference/functions/revalidatePath)\n */ export function revalidatePath(originalPath, type) {\n    if (originalPath.length > NEXT_CACHE_SOFT_TAG_MAX_LENGTH) {\n        console.warn(`Warning: revalidatePath received \"${originalPath}\" which exceeded max length of ${NEXT_CACHE_SOFT_TAG_MAX_LENGTH}. See more info here https://nextjs.org/docs/app/api-reference/functions/revalidatePath`);\n        return;\n    }\n    let normalizedPath = `${NEXT_CACHE_IMPLICIT_TAG_ID}${originalPath}`;\n    if (type) {\n        normalizedPath += `${normalizedPath.endsWith('/') ? '' : '/'}${type}`;\n    } else if (isDynamicRoute(originalPath)) {\n        console.warn(`Warning: a dynamic page path \"${originalPath}\" was passed to \"revalidatePath\", but the \"type\" parameter is missing. This has no effect by default, see more info here https://nextjs.org/docs/app/api-reference/functions/revalidatePath`);\n    }\n    return revalidate([\n        normalizedPath\n    ], `revalidatePath ${originalPath}`);\n}\nfunction revalidate(tags, expression) {\n    const store = workAsyncStorage.getStore();\n    if (!store || !store.incrementalCache) {\n        throw Object.defineProperty(new Error(`Invariant: static generation store missing in ${expression}`), \"__NEXT_ERROR_CODE\", {\n            value: \"E263\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    const workUnitStore = workUnitAsyncStorage.getStore();\n    if (workUnitStore) {\n        if (workUnitStore.type === 'cache') {\n            throw Object.defineProperty(new Error(`Route ${store.route} used \"${expression}\" inside a \"use cache\" which is unsupported. To ensure revalidation is performed consistently it must always happen outside of renders and cached functions. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`), \"__NEXT_ERROR_CODE\", {\n                value: \"E181\",\n                enumerable: false,\n                configurable: true\n            });\n        } else if (workUnitStore.type === 'unstable-cache') {\n            throw Object.defineProperty(new Error(`Route ${store.route} used \"${expression}\" inside a function cached with \"unstable_cache(...)\" which is unsupported. To ensure revalidation is performed consistently it must always happen outside of renders and cached functions. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`), \"__NEXT_ERROR_CODE\", {\n                value: \"E306\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n        if (workUnitStore.phase === 'render') {\n            throw Object.defineProperty(new Error(`Route ${store.route} used \"${expression}\" during render which is unsupported. To ensure revalidation is performed consistently it must always happen outside of renders and cached functions. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`), \"__NEXT_ERROR_CODE\", {\n                value: \"E7\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n        if (workUnitStore.type === 'prerender') {\n            // dynamicIO Prerender\n            const error = Object.defineProperty(new Error(`Route ${store.route} used ${expression} without first calling \\`await connection()\\`.`), \"__NEXT_ERROR_CODE\", {\n                value: \"E406\",\n                enumerable: false,\n                configurable: true\n            });\n            abortAndThrowOnSynchronousRequestDataAccess(store.route, expression, error, workUnitStore);\n        } else if (workUnitStore.type === 'prerender-ppr') {\n            // PPR Prerender\n            postponeWithTracking(store.route, expression, workUnitStore.dynamicTracking);\n        } else if (workUnitStore.type === 'prerender-legacy') {\n            // legacy Prerender\n            workUnitStore.revalidate = 0;\n            const err = Object.defineProperty(new DynamicServerError(`Route ${store.route} couldn't be rendered statically because it used \\`${expression}\\`. See more info here: https://nextjs.org/docs/messages/dynamic-server-error`), \"__NEXT_ERROR_CODE\", {\n                value: \"E558\",\n                enumerable: false,\n                configurable: true\n            });\n            store.dynamicUsageDescription = expression;\n            store.dynamicUsageStack = err.stack;\n            throw err;\n        } else if (process.env.NODE_ENV === 'development' && workUnitStore && workUnitStore.type === 'request') {\n            workUnitStore.usedDynamic = true;\n        }\n    }\n    if (!store.pendingRevalidatedTags) {\n        store.pendingRevalidatedTags = [];\n    }\n    for (const tag of tags){\n        if (!store.pendingRevalidatedTags.includes(tag)) {\n            store.pendingRevalidatedTags.push(tag);\n        }\n    }\n    // TODO: only revalidate if the path matches\n    store.pathWasRevalidated = true;\n}\n\n//# sourceMappingURL=revalidate.js.map"
        }
    ]
}