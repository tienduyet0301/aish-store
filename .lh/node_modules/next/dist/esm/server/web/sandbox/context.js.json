{
    "sourceFile": "node_modules/next/dist/esm/server/web/sandbox/context.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892846526,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import { AsyncLocalStorage } from 'async_hooks';\nimport { COMPILER_NAMES, EDGE_UNSUPPORTED_NODE_APIS } from '../../../shared/lib/constants';\nimport { EdgeRuntime } from 'next/dist/compiled/edge-runtime';\nimport { readFileSync, promises as fs } from 'fs';\nimport { validateURL } from '../utils';\nimport { pick } from '../../../lib/pick';\nimport { fetchInlineAsset } from './fetch-inline-assets';\nimport { runInContext } from 'vm';\nimport BufferImplementation from 'node:buffer';\nimport EventsImplementation from 'node:events';\nimport AssertImplementation from 'node:assert';\nimport UtilImplementation from 'node:util';\nimport AsyncHooksImplementation from 'node:async_hooks';\nimport { intervalsManager, timeoutsManager } from './resource-managers';\nimport { createLocalRequestContext } from '../../after/builtin-request-context';\nimport { patchErrorInspectEdgeLite, patchErrorInspectNodeJS } from '../../patch-error-inspect';\nlet getServerError;\nlet decorateServerError;\nif (process.env.NODE_ENV === 'development') {\n    const middleware = require('../../../client/components/react-dev-overlay/server/middleware-webpack');\n    getServerError = middleware.getServerError;\n    decorateServerError = require('../../../shared/lib/error-source').decorateServerError;\n} else {\n    getServerError = (error, _)=>error;\n    decorateServerError = (_, __)=>{};\n}\n/**\n * A Map of cached module contexts indexed by the module name. It allows\n * to have a different cache scoped per module name or depending on the\n * provided module key on creation.\n */ const moduleContexts = new Map();\nconst pendingModuleCaches = new Map();\n/**\n * Same as clearModuleContext but for all module contexts.\n */ export async function clearAllModuleContexts() {\n    intervalsManager.removeAll();\n    timeoutsManager.removeAll();\n    moduleContexts.clear();\n    pendingModuleCaches.clear();\n}\n/**\n * For a given path a context, this function checks if there is any module\n * context that contains the path with an older content and, if that's the\n * case, removes the context from the cache.\n *\n * This function also clears all intervals and timeouts created by the\n * module context.\n */ export async function clearModuleContext(path) {\n    intervalsManager.removeAll();\n    timeoutsManager.removeAll();\n    const handleContext = (key, cache, context)=>{\n        if (cache == null ? void 0 : cache.paths.has(path)) {\n            context.delete(key);\n        }\n    };\n    for (const [key, cache] of moduleContexts){\n        handleContext(key, cache, moduleContexts);\n    }\n    for (const [key, cache] of pendingModuleCaches){\n        handleContext(key, await cache, pendingModuleCaches);\n    }\n}\nasync function loadWasm(wasm) {\n    const modules = {};\n    await Promise.all(wasm.map(async (binding)=>{\n        const module = await WebAssembly.compile(await fs.readFile(binding.filePath));\n        modules[binding.name] = module;\n    }));\n    return modules;\n}\nfunction buildEnvironmentVariablesFrom(injectedEnvironments) {\n    const pairs = Object.keys(process.env).map((key)=>[\n            key,\n            process.env[key]\n        ]);\n    const env = Object.fromEntries(pairs);\n    for (const key of Object.keys(injectedEnvironments)){\n        env[key] = injectedEnvironments[key];\n    }\n    env.NEXT_RUNTIME = 'edge';\n    return env;\n}\nfunction throwUnsupportedAPIError(name) {\n    const error = Object.defineProperty(new Error(`A Node.js API is used (${name}) which is not supported in the Edge Runtime.\nLearn more: https://nextjs.org/docs/api-reference/edge-runtime`), \"__NEXT_ERROR_CODE\", {\n        value: \"E97\",\n        enumerable: false,\n        configurable: true\n    });\n    decorateServerError(error, COMPILER_NAMES.edgeServer);\n    throw error;\n}\nfunction createProcessPolyfill(env) {\n    const processPolyfill = {\n        env: buildEnvironmentVariablesFrom(env)\n    };\n    const overriddenValue = {};\n    for (const key of Object.keys(process)){\n        if (key === 'env') continue;\n        Object.defineProperty(processPolyfill, key, {\n            get () {\n                if (overriddenValue[key] !== undefined) {\n                    return overriddenValue[key];\n                }\n                if (typeof process[key] === 'function') {\n                    return ()=>throwUnsupportedAPIError(`process.${key}`);\n                }\n                return undefined;\n            },\n            set (value) {\n                overriddenValue[key] = value;\n            },\n            enumerable: false\n        });\n    }\n    return processPolyfill;\n}\nfunction addStub(context, name) {\n    Object.defineProperty(context, name, {\n        get () {\n            return function() {\n                throwUnsupportedAPIError(name);\n            };\n        },\n        enumerable: false\n    });\n}\nfunction getDecorateUnhandledError(runtime) {\n    const EdgeRuntimeError = runtime.evaluate(`Error`);\n    return (error)=>{\n        if (error instanceof EdgeRuntimeError) {\n            decorateServerError(error, COMPILER_NAMES.edgeServer);\n        }\n    };\n}\nfunction getDecorateUnhandledRejection(runtime) {\n    const EdgeRuntimeError = runtime.evaluate(`Error`);\n    return (rejected)=>{\n        if (rejected.reason instanceof EdgeRuntimeError) {\n            decorateServerError(rejected.reason, COMPILER_NAMES.edgeServer);\n        }\n    };\n}\nconst NativeModuleMap = (()=>{\n    const mods = {\n        'node:buffer': pick(BufferImplementation, [\n            'constants',\n            'kMaxLength',\n            'kStringMaxLength',\n            'Buffer',\n            'SlowBuffer'\n        ]),\n        'node:events': pick(EventsImplementation, [\n            'EventEmitter',\n            'captureRejectionSymbol',\n            'defaultMaxListeners',\n            'errorMonitor',\n            'listenerCount',\n            'on',\n            'once'\n        ]),\n        'node:async_hooks': pick(AsyncHooksImplementation, [\n            'AsyncLocalStorage',\n            'AsyncResource'\n        ]),\n        'node:assert': pick(AssertImplementation, [\n            'AssertionError',\n            'deepEqual',\n            'deepStrictEqual',\n            'doesNotMatch',\n            'doesNotReject',\n            'doesNotThrow',\n            'equal',\n            'fail',\n            'ifError',\n            'match',\n            'notDeepEqual',\n            'notDeepStrictEqual',\n            'notEqual',\n            'notStrictEqual',\n            'ok',\n            'rejects',\n            'strict',\n            'strictEqual',\n            'throws'\n        ]),\n        'node:util': pick(UtilImplementation, [\n            '_extend',\n            'callbackify',\n            'format',\n            'inherits',\n            'promisify',\n            'types'\n        ])\n    };\n    return new Map(Object.entries(mods));\n})();\nexport const requestStore = new AsyncLocalStorage();\nexport const edgeSandboxNextRequestContext = createLocalRequestContext();\n/**\n * Create a module cache specific for the provided parameters. It includes\n * a runtime context, require cache and paths cache.\n */ async function createModuleContext(options) {\n    const warnedEvals = new Set();\n    const warnedWasmCodegens = new Set();\n    const { edgeFunctionEntry } = options;\n    const wasm = await loadWasm(edgeFunctionEntry.wasm ?? []);\n    const runtime = new EdgeRuntime({\n        codeGeneration: process.env.NODE_ENV !== 'production' ? {\n            strings: true,\n            wasm: true\n        } : undefined,\n        extend: (context)=>{\n            context.process = createProcessPolyfill(edgeFunctionEntry.env);\n            Object.defineProperty(context, 'require', {\n                enumerable: false,\n                value: (id)=>{\n                    const value = NativeModuleMap.get(id);\n                    if (!value) {\n                        throw Object.defineProperty(new TypeError('Native module not found: ' + id), \"__NEXT_ERROR_CODE\", {\n                            value: \"E546\",\n                            enumerable: false,\n                            configurable: true\n                        });\n                    }\n                    return value;\n                }\n            });\n            if (process.env.NODE_ENV !== 'production') {\n                context.__next_log_error__ = function(err) {\n                    options.onError(err);\n                };\n            }\n            context.__next_eval__ = function __next_eval__(fn) {\n                const key = fn.toString();\n                if (!warnedEvals.has(key)) {\n                    const warning = getServerError(Object.defineProperty(new Error(`Dynamic Code Evaluation (e. g. 'eval', 'new Function') not allowed in Edge Runtime\nLearn More: https://nextjs.org/docs/messages/edge-dynamic-code-evaluation`), \"__NEXT_ERROR_CODE\", {\n                        value: \"E149\",\n                        enumerable: false,\n                        configurable: true\n                    }), COMPILER_NAMES.edgeServer);\n                    warning.name = 'DynamicCodeEvaluationWarning';\n                    Error.captureStackTrace(warning, __next_eval__);\n                    warnedEvals.add(key);\n                    options.onWarning(warning);\n                }\n                return fn();\n            };\n            context.__next_webassembly_compile__ = function __next_webassembly_compile__(fn) {\n                const key = fn.toString();\n                if (!warnedWasmCodegens.has(key)) {\n                    const warning = getServerError(Object.defineProperty(new Error(`Dynamic WASM code generation (e. g. 'WebAssembly.compile') not allowed in Edge Runtime.\nLearn More: https://nextjs.org/docs/messages/edge-dynamic-code-evaluation`), \"__NEXT_ERROR_CODE\", {\n                        value: \"E184\",\n                        enumerable: false,\n                        configurable: true\n                    }), COMPILER_NAMES.edgeServer);\n                    warning.name = 'DynamicWasmCodeGenerationWarning';\n                    Error.captureStackTrace(warning, __next_webassembly_compile__);\n                    warnedWasmCodegens.add(key);\n                    options.onWarning(warning);\n                }\n                return fn();\n            };\n            context.__next_webassembly_instantiate__ = async function __next_webassembly_instantiate__(fn) {\n                const result = await fn();\n                // If a buffer is given, WebAssembly.instantiate returns an object\n                // containing both a module and an instance while it returns only an\n                // instance if a WASM module is given. Utilize the fact to determine\n                // if the WASM code generation happens.\n                //\n                // https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly/instantiate#primary_overload_%E2%80%94_taking_wasm_binary_code\n                const instantiatedFromBuffer = result.hasOwnProperty('module');\n                const key = fn.toString();\n                if (instantiatedFromBuffer && !warnedWasmCodegens.has(key)) {\n                    const warning = getServerError(Object.defineProperty(new Error(`Dynamic WASM code generation ('WebAssembly.instantiate' with a buffer parameter) not allowed in Edge Runtime.\nLearn More: https://nextjs.org/docs/messages/edge-dynamic-code-evaluation`), \"__NEXT_ERROR_CODE\", {\n                        value: \"E40\",\n                        enumerable: false,\n                        configurable: true\n                    }), COMPILER_NAMES.edgeServer);\n                    warning.name = 'DynamicWasmCodeGenerationWarning';\n                    Error.captureStackTrace(warning, __next_webassembly_instantiate__);\n                    warnedWasmCodegens.add(key);\n                    options.onWarning(warning);\n                }\n                return result;\n            };\n            const __fetch = context.fetch;\n            context.fetch = async (input, init = {})=>{\n                const callingError = Object.defineProperty(new Error('[internal]'), \"__NEXT_ERROR_CODE\", {\n                    value: \"E5\",\n                    enumerable: false,\n                    configurable: true\n                });\n                const assetResponse = await fetchInlineAsset({\n                    input,\n                    assets: options.edgeFunctionEntry.assets,\n                    distDir: options.distDir,\n                    context\n                });\n                if (assetResponse) {\n                    return assetResponse;\n                }\n                init.headers = new Headers(init.headers ?? {});\n                if (!init.headers.has('user-agent')) {\n                    init.headers.set(`user-agent`, `Next.js Middleware`);\n                }\n                const response = typeof input === 'object' && 'url' in input ? __fetch(input.url, {\n                    ...pick(input, [\n                        'method',\n                        'body',\n                        'cache',\n                        'credentials',\n                        'integrity',\n                        'keepalive',\n                        'mode',\n                        'redirect',\n                        'referrer',\n                        'referrerPolicy',\n                        'signal'\n                    ]),\n                    ...init,\n                    headers: {\n                        ...Object.fromEntries(input.headers),\n                        ...Object.fromEntries(init.headers)\n                    }\n                }) : __fetch(String(input), init);\n                return await response.catch((err)=>{\n                    callingError.message = err.message;\n                    err.stack = callingError.stack;\n                    throw err;\n                });\n            };\n            const __Request = context.Request;\n            context.Request = class extends __Request {\n                constructor(input, init){\n                    const url = typeof input !== 'string' && 'url' in input ? input.url : String(input);\n                    validateURL(url);\n                    super(url, init);\n                    this.next = init == null ? void 0 : init.next;\n                }\n            };\n            const __redirect = context.Response.redirect.bind(context.Response);\n            context.Response.redirect = (...args)=>{\n                validateURL(args[0]);\n                return __redirect(...args);\n            };\n            for (const name of EDGE_UNSUPPORTED_NODE_APIS){\n                addStub(context, name);\n            }\n            Object.assign(context, wasm);\n            context.performance = performance;\n            context.AsyncLocalStorage = AsyncLocalStorage;\n            // @ts-ignore the timeouts have weird types in the edge runtime\n            context.setInterval = (...args)=>intervalsManager.add(args);\n            // @ts-ignore the timeouts have weird types in the edge runtime\n            context.clearInterval = (interval)=>intervalsManager.remove(interval);\n            // @ts-ignore the timeouts have weird types in the edge runtime\n            context.setTimeout = (...args)=>timeoutsManager.add(args);\n            // @ts-ignore the timeouts have weird types in the edge runtime\n            context.clearTimeout = (timeout)=>timeoutsManager.remove(timeout);\n            // Duplicated from packages/next/src/server/after/builtin-request-context.ts\n            // because we need to use the sandboxed `Symbol.for`, not the one from the outside\n            const NEXT_REQUEST_CONTEXT_SYMBOL = context.Symbol.for('@next/request-context');\n            Object.defineProperty(context, NEXT_REQUEST_CONTEXT_SYMBOL, {\n                enumerable: false,\n                value: edgeSandboxNextRequestContext\n            });\n            return context;\n        }\n    });\n    const decorateUnhandledError = getDecorateUnhandledError(runtime);\n    runtime.context.addEventListener('error', decorateUnhandledError);\n    const decorateUnhandledRejection = getDecorateUnhandledRejection(runtime);\n    runtime.context.addEventListener('unhandledrejection', decorateUnhandledRejection);\n    patchErrorInspectEdgeLite(runtime.context.Error);\n    // An Error from within the Edge Runtime could also bubble up into the Node.js process.\n    // For example, uncaught errors are handled in the Node.js runtime.\n    patchErrorInspectNodeJS(runtime.context.Error);\n    return {\n        runtime,\n        paths: new Map(),\n        warnedEvals: new Set()\n    };\n}\nfunction getModuleContextShared(options) {\n    let deferredModuleContext = pendingModuleCaches.get(options.moduleName);\n    if (!deferredModuleContext) {\n        deferredModuleContext = createModuleContext(options);\n        pendingModuleCaches.set(options.moduleName, deferredModuleContext);\n    }\n    return deferredModuleContext;\n}\n/**\n * For a given module name this function will get a cached module\n * context or create it. It will return the module context along\n * with a function that allows to run some code from a given\n * filepath within the context.\n */ export async function getModuleContext(options) {\n    let lazyModuleContext;\n    if (options.useCache) {\n        lazyModuleContext = moduleContexts.get(options.moduleName) || await getModuleContextShared(options);\n    }\n    if (!lazyModuleContext) {\n        lazyModuleContext = await createModuleContext(options);\n        moduleContexts.set(options.moduleName, lazyModuleContext);\n    }\n    const moduleContext = lazyModuleContext;\n    const evaluateInContext = (filepath)=>{\n        if (!moduleContext.paths.has(filepath)) {\n            const content = readFileSync(filepath, 'utf-8');\n            try {\n                runInContext(content, moduleContext.runtime.context, {\n                    filename: filepath\n                });\n                moduleContext.paths.set(filepath, content);\n            } catch (error) {\n                if (options.useCache) {\n                    moduleContext == null ? void 0 : moduleContext.paths.delete(filepath);\n                }\n                throw error;\n            }\n        }\n    };\n    return {\n        ...moduleContext,\n        evaluateInContext\n    };\n}\n\n//# sourceMappingURL=context.js.map"
        }
    ]
}