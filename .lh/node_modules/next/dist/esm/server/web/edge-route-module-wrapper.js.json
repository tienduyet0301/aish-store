{
    "sourceFile": "node_modules/next/dist/esm/server/web/edge-route-module-wrapper.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892846086,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import './globals';\nimport { adapter } from './adapter';\nimport { IncrementalCache } from '../lib/incremental-cache';\nimport { RouteMatcher } from '../route-matchers/route-matcher';\nimport { internal_getCurrentFunctionWaitUntil } from './internal-edge-wait-until';\nimport { getUtils } from '../server-utils';\nimport { searchParamsToUrlQuery } from '../../shared/lib/router/utils/querystring';\nimport { CloseController, trackStreamConsumed } from './web-on-close';\nimport { getEdgePreviewProps } from './get-edge-preview-props';\n/**\n * EdgeRouteModuleWrapper is a wrapper around a route module.\n *\n * Note that this class should only be used in the edge runtime.\n */ export class EdgeRouteModuleWrapper {\n    /**\n   * The constructor is wrapped with private to ensure that it can only be\n   * constructed by the static wrap method.\n   *\n   * @param routeModule the route module to wrap\n   */ constructor(routeModule, nextConfig){\n        this.routeModule = routeModule;\n        this.nextConfig = nextConfig;\n        // TODO: (wyattjoh) possibly allow the module to define it's own matcher\n        this.matcher = new RouteMatcher(routeModule.definition);\n    }\n    /**\n   * This will wrap a module with the EdgeModuleWrapper and return a function\n   * that can be used as a handler for the edge runtime.\n   *\n   * @param module the module to wrap\n   * @param options any options that should be passed to the adapter and\n   *                override the ones passed from the runtime\n   * @returns a function that can be used as a handler for the edge runtime\n   */ static wrap(routeModule, options) {\n        // Create the module wrapper.\n        const wrapper = new EdgeRouteModuleWrapper(routeModule, options.nextConfig);\n        // Return the wrapping function.\n        return (opts)=>{\n            return adapter({\n                ...opts,\n                IncrementalCache,\n                // Bind the handler method to the wrapper so it still has context.\n                handler: wrapper.handler.bind(wrapper)\n            });\n        };\n    }\n    async handler(request, evt) {\n        const utils = getUtils({\n            pageIsDynamic: this.matcher.isDynamic,\n            page: this.matcher.definition.pathname,\n            basePath: request.nextUrl.basePath,\n            // We don't need the `handleRewrite` util, so can just pass an empty object\n            rewrites: {},\n            // only used for rewrites, so setting an arbitrary default value here\n            caseSensitive: false\n        });\n        const { params } = utils.normalizeDynamicRouteParams(searchParamsToUrlQuery(request.nextUrl.searchParams), false);\n        const waitUntil = evt.waitUntil.bind(evt);\n        const closeController = new CloseController();\n        const previewProps = getEdgePreviewProps();\n        // Create the context for the handler. This contains the params from the\n        // match (if any).\n        const context = {\n            params,\n            prerenderManifest: {\n                version: 4,\n                routes: {},\n                dynamicRoutes: {},\n                preview: previewProps,\n                notFoundRoutes: []\n            },\n            renderOpts: {\n                supportsDynamicResponse: true,\n                waitUntil,\n                onClose: closeController.onClose.bind(closeController),\n                onAfterTaskError: undefined,\n                experimental: {\n                    dynamicIO: !!process.env.__NEXT_DYNAMIC_IO,\n                    authInterrupts: !!process.env.__NEXT_EXPERIMENTAL_AUTH_INTERRUPTS\n                },\n                cacheLifeProfiles: this.nextConfig.experimental.cacheLife\n            },\n            sharedContext: {\n                buildId: ''\n            }\n        };\n        // Get the response from the handler.\n        let res = await this.routeModule.handle(request, context);\n        const waitUntilPromises = [\n            internal_getCurrentFunctionWaitUntil()\n        ];\n        if (context.renderOpts.pendingWaitUntil) {\n            waitUntilPromises.push(context.renderOpts.pendingWaitUntil);\n        }\n        evt.waitUntil(Promise.all(waitUntilPromises));\n        if (!res.body) {\n            // we can delay running it until a bit later --\n            // if it's needed, we'll have a `waitUntil` lock anyway.\n            setTimeout(()=>closeController.dispatchClose(), 0);\n        } else {\n            // NOTE: if this is a streaming response, onClose may be called later,\n            // so we can't rely on `closeController.listeners` -- it might be 0 at this point.\n            const trackedBody = trackStreamConsumed(res.body, ()=>closeController.dispatchClose());\n            res = new Response(trackedBody, {\n                status: res.status,\n                statusText: res.statusText,\n                headers: res.headers\n            });\n        }\n        return res;\n    }\n}\n\n//# sourceMappingURL=edge-route-module-wrapper.js.map"
        }
    ]
}