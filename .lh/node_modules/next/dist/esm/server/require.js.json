{
    "sourceFile": "node_modules/next/dist/esm/server/require.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892837876,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import path from 'path';\nimport { PAGES_MANIFEST, SERVER_DIRECTORY, APP_PATHS_MANIFEST } from '../shared/lib/constants';\nimport { normalizeLocalePath } from '../shared/lib/i18n/normalize-locale-path';\nimport { normalizePagePath } from '../shared/lib/page-path/normalize-page-path';\nimport { denormalizePagePath } from '../shared/lib/page-path/denormalize-page-path';\nimport { PageNotFoundError, MissingStaticPage } from '../shared/lib/utils';\nimport { LRUCache } from '../server/lib/lru-cache';\nimport { loadManifest } from './load-manifest';\nimport { promises } from 'fs';\nconst isDev = process.env.NODE_ENV === 'development';\nconst pagePathCache = !isDev ? new LRUCache(1000) : null;\nexport function getMaybePagePath(page, distDir, locales, isAppPath) {\n    const cacheKey = `${page}:${distDir}:${locales}:${isAppPath}`;\n    let pagePath = pagePathCache == null ? void 0 : pagePathCache.get(cacheKey);\n    // If we have a cached path, we can return it directly.\n    if (pagePath) return pagePath;\n    const serverBuildPath = path.join(distDir, SERVER_DIRECTORY);\n    let appPathsManifest;\n    if (isAppPath) {\n        appPathsManifest = loadManifest(path.join(serverBuildPath, APP_PATHS_MANIFEST), !isDev);\n    }\n    const pagesManifest = loadManifest(path.join(serverBuildPath, PAGES_MANIFEST), !isDev);\n    try {\n        page = denormalizePagePath(normalizePagePath(page));\n    } catch (err) {\n        console.error(err);\n        throw new PageNotFoundError(page);\n    }\n    const checkManifest = (manifest)=>{\n        let curPath = manifest[page];\n        if (!manifest[curPath] && locales) {\n            const manifestNoLocales = {};\n            for (const key of Object.keys(manifest)){\n                manifestNoLocales[normalizeLocalePath(key, locales).pathname] = pagesManifest[key];\n            }\n            curPath = manifestNoLocales[page];\n        }\n        return curPath;\n    };\n    if (appPathsManifest) {\n        pagePath = checkManifest(appPathsManifest);\n    }\n    if (!pagePath) {\n        pagePath = checkManifest(pagesManifest);\n    }\n    if (!pagePath) {\n        pagePathCache == null ? void 0 : pagePathCache.set(cacheKey, null);\n        return null;\n    }\n    pagePath = path.join(serverBuildPath, pagePath);\n    pagePathCache == null ? void 0 : pagePathCache.set(cacheKey, pagePath);\n    return pagePath;\n}\nexport function getPagePath(page, distDir, locales, isAppPath) {\n    const pagePath = getMaybePagePath(page, distDir, locales, isAppPath);\n    if (!pagePath) {\n        throw new PageNotFoundError(page);\n    }\n    return pagePath;\n}\nexport async function requirePage(page, distDir, isAppPath) {\n    const pagePath = getPagePath(page, distDir, undefined, isAppPath);\n    if (pagePath.endsWith('.html')) {\n        return promises.readFile(pagePath, 'utf8').catch((err)=>{\n            throw new MissingStaticPage(page, err.message);\n        });\n    }\n    // since require is synchronous we can set the specific runtime\n    // we are requiring for the require-hook and then clear after\n    try {\n        process.env.__NEXT_PRIVATE_RUNTIME_TYPE = isAppPath ? 'app' : 'pages';\n        const mod = process.env.NEXT_MINIMAL ? __non_webpack_require__(pagePath) : require(pagePath);\n        return mod;\n    } finally{\n        process.env.__NEXT_PRIVATE_RUNTIME_TYPE = '';\n    }\n}\n\n//# sourceMappingURL=require.js.map"
        }
    ]
}