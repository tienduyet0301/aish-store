{
    "sourceFile": "node_modules/next/dist/esm/server/app-render/create-component-tree.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892822920,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from \"react/jsx-runtime\";\nimport React from 'react';\nimport { isClientReference, isUseCacheFunction } from '../../lib/client-and-server-references';\nimport { getLayoutOrPageModule } from '../lib/app-dir-module';\nimport { interopDefault } from './interop-default';\nimport { parseLoaderTree } from './parse-loader-tree';\nimport { createComponentStylesAndScripts } from './create-component-styles-and-scripts';\nimport { getLayerAssets } from './get-layer-assets';\nimport { hasLoadingComponentInTree } from './has-loading-component-in-tree';\nimport { validateRevalidate } from '../lib/patch-fetch';\nimport { PARALLEL_ROUTE_DEFAULT_PATH } from '../../client/components/parallel-route-default';\nimport { getTracer } from '../lib/trace/tracer';\nimport { NextNodeServerSpan } from '../lib/trace/constants';\nimport { StaticGenBailoutError } from '../../client/components/static-generation-bailout';\nimport { workUnitAsyncStorage } from './work-unit-async-storage.external';\nimport { OUTLET_BOUNDARY_NAME } from '../../lib/metadata/metadata-constants';\n/**\n * Use the provided loader tree to create the React Component tree.\n */ export function createComponentTree(props) {\n    return getTracer().trace(NextNodeServerSpan.createComponentTree, {\n        spanName: 'build component tree'\n    }, ()=>createComponentTreeInternal(props));\n}\nfunction errorMissingDefaultExport(pagePath, convention) {\n    const normalizedPagePath = pagePath === '/' ? '' : pagePath;\n    throw Object.defineProperty(new Error(`The default export is not a React Component in \"${normalizedPagePath}/${convention}\"`), \"__NEXT_ERROR_CODE\", {\n        value: \"E45\",\n        enumerable: false,\n        configurable: true\n    });\n}\nconst cacheNodeKey = 'c';\nasync function createComponentTreeInternal({ loaderTree: tree, parentParams, rootLayoutIncluded, injectedCSS, injectedJS, injectedFontPreloadTags, getViewportReady, getMetadataReady, ctx, missingSlots, preloadCallbacks, authInterrupts, StreamingMetadata, StreamingMetadataOutlet }) {\n    const { renderOpts: { nextConfigOutput, experimental }, workStore, componentMod: { HTTPAccessFallbackBoundary, LayoutRouter, RenderFromTemplateContext, OutletBoundary, ClientPageRoot, ClientSegmentRoot, createServerSearchParamsForServerPage, createPrerenderSearchParamsForClientPage, createServerParamsForServerSegment, createPrerenderParamsForClientSegment, serverHooks: { DynamicServerError }, Postpone }, pagePath, getDynamicParamFromSegment, isPrefetch, query } = ctx;\n    const { page, layoutOrPagePath, segment, modules, parallelRoutes } = parseLoaderTree(tree);\n    const { layout, template, error, loading, 'not-found': notFound, forbidden, unauthorized } = modules;\n    const injectedCSSWithCurrentLayout = new Set(injectedCSS);\n    const injectedJSWithCurrentLayout = new Set(injectedJS);\n    const injectedFontPreloadTagsWithCurrentLayout = new Set(injectedFontPreloadTags);\n    const layerAssets = getLayerAssets({\n        preloadCallbacks,\n        ctx,\n        layoutOrPagePath,\n        injectedCSS: injectedCSSWithCurrentLayout,\n        injectedJS: injectedJSWithCurrentLayout,\n        injectedFontPreloadTags: injectedFontPreloadTagsWithCurrentLayout\n    });\n    const [Template, templateStyles, templateScripts] = template ? await createComponentStylesAndScripts({\n        ctx,\n        filePath: template[1],\n        getComponent: template[0],\n        injectedCSS: injectedCSSWithCurrentLayout,\n        injectedJS: injectedJSWithCurrentLayout\n    }) : [\n        React.Fragment\n    ];\n    const [ErrorComponent, errorStyles, errorScripts] = error ? await createComponentStylesAndScripts({\n        ctx,\n        filePath: error[1],\n        getComponent: error[0],\n        injectedCSS: injectedCSSWithCurrentLayout,\n        injectedJS: injectedJSWithCurrentLayout\n    }) : [];\n    const [Loading, loadingStyles, loadingScripts] = loading ? await createComponentStylesAndScripts({\n        ctx,\n        filePath: loading[1],\n        getComponent: loading[0],\n        injectedCSS: injectedCSSWithCurrentLayout,\n        injectedJS: injectedJSWithCurrentLayout\n    }) : [];\n    const isLayout = typeof layout !== 'undefined';\n    const isPage = typeof page !== 'undefined';\n    const { mod: layoutOrPageMod, modType } = await getTracer().trace(NextNodeServerSpan.getLayoutOrPageModule, {\n        hideSpan: !(isLayout || isPage),\n        spanName: 'resolve segment modules',\n        attributes: {\n            'next.segment': segment\n        }\n    }, ()=>getLayoutOrPageModule(tree));\n    /**\n   * Checks if the current segment is a root layout.\n   */ const rootLayoutAtThisLevel = isLayout && !rootLayoutIncluded;\n    /**\n   * Checks if the current segment or any level above it has a root layout.\n   */ const rootLayoutIncludedAtThisLevelOrAbove = rootLayoutIncluded || rootLayoutAtThisLevel;\n    const [NotFound, notFoundStyles] = notFound ? await createComponentStylesAndScripts({\n        ctx,\n        filePath: notFound[1],\n        getComponent: notFound[0],\n        injectedCSS: injectedCSSWithCurrentLayout,\n        injectedJS: injectedJSWithCurrentLayout\n    }) : [];\n    const [Forbidden, forbiddenStyles] = authInterrupts && forbidden ? await createComponentStylesAndScripts({\n        ctx,\n        filePath: forbidden[1],\n        getComponent: forbidden[0],\n        injectedCSS: injectedCSSWithCurrentLayout,\n        injectedJS: injectedJSWithCurrentLayout\n    }) : [];\n    const [Unauthorized, unauthorizedStyles] = authInterrupts && unauthorized ? await createComponentStylesAndScripts({\n        ctx,\n        filePath: unauthorized[1],\n        getComponent: unauthorized[0],\n        injectedCSS: injectedCSSWithCurrentLayout,\n        injectedJS: injectedJSWithCurrentLayout\n    }) : [];\n    let dynamic = layoutOrPageMod == null ? void 0 : layoutOrPageMod.dynamic;\n    if (nextConfigOutput === 'export') {\n        if (!dynamic || dynamic === 'auto') {\n            dynamic = 'error';\n        } else if (dynamic === 'force-dynamic') {\n            // force-dynamic is always incompatible with 'export'. We must interrupt the build\n            throw Object.defineProperty(new StaticGenBailoutError(`Page with \\`dynamic = \"force-dynamic\"\\` couldn't be exported. \\`output: \"export\"\\` requires all pages be renderable statically because there is no runtime server to dynamically render routes in this output format. Learn more: https://nextjs.org/docs/app/building-your-application/deploying/static-exports`), \"__NEXT_ERROR_CODE\", {\n                value: \"E527\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n    }\n    if (typeof dynamic === 'string') {\n        // the nested most config wins so we only force-static\n        // if it's configured above any parent that configured\n        // otherwise\n        if (dynamic === 'error') {\n            workStore.dynamicShouldError = true;\n        } else if (dynamic === 'force-dynamic') {\n            workStore.forceDynamic = true;\n            // TODO: (PPR) remove this bailout once PPR is the default\n            if (workStore.isStaticGeneration && !experimental.isRoutePPREnabled) {\n                // If the postpone API isn't available, we can't postpone the render and\n                // therefore we can't use the dynamic API.\n                const err = Object.defineProperty(new DynamicServerError(`Page with \\`dynamic = \"force-dynamic\"\\` won't be rendered statically.`), \"__NEXT_ERROR_CODE\", {\n                    value: \"E585\",\n                    enumerable: false,\n                    configurable: true\n                });\n                workStore.dynamicUsageDescription = err.message;\n                workStore.dynamicUsageStack = err.stack;\n                throw err;\n            }\n        } else {\n            workStore.dynamicShouldError = false;\n            workStore.forceStatic = dynamic === 'force-static';\n        }\n    }\n    if (typeof (layoutOrPageMod == null ? void 0 : layoutOrPageMod.fetchCache) === 'string') {\n        workStore.fetchCache = layoutOrPageMod == null ? void 0 : layoutOrPageMod.fetchCache;\n    }\n    if (typeof (layoutOrPageMod == null ? void 0 : layoutOrPageMod.revalidate) !== 'undefined') {\n        validateRevalidate(layoutOrPageMod == null ? void 0 : layoutOrPageMod.revalidate, workStore.route);\n    }\n    if (typeof (layoutOrPageMod == null ? void 0 : layoutOrPageMod.revalidate) === 'number') {\n        const defaultRevalidate = layoutOrPageMod.revalidate;\n        const workUnitStore = workUnitAsyncStorage.getStore();\n        if (workUnitStore) {\n            if (workUnitStore.type === 'prerender' || workUnitStore.type === 'prerender-legacy' || workUnitStore.type === 'prerender-ppr' || workUnitStore.type === 'cache') {\n                if (workUnitStore.revalidate > defaultRevalidate) {\n                    workUnitStore.revalidate = defaultRevalidate;\n                }\n            }\n        }\n        if (!workStore.forceStatic && workStore.isStaticGeneration && defaultRevalidate === 0 && // If the postpone API isn't available, we can't postpone the render and\n        // therefore we can't use the dynamic API.\n        !experimental.isRoutePPREnabled) {\n            const dynamicUsageDescription = `revalidate: 0 configured ${segment}`;\n            workStore.dynamicUsageDescription = dynamicUsageDescription;\n            throw Object.defineProperty(new DynamicServerError(dynamicUsageDescription), \"__NEXT_ERROR_CODE\", {\n                value: \"E394\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n    }\n    const isStaticGeneration = workStore.isStaticGeneration;\n    // Assume the segment we're rendering contains only partial data if PPR is\n    // enabled and this is a statically generated response. This is used by the\n    // client Segment Cache after a prefetch to determine if it can skip the\n    // second request to fill in the dynamic data.\n    //\n    // It's OK for this to be `true` when the data is actually fully static, but\n    // it's not OK for this to be `false` when the data possibly contains holes.\n    // Although the value here is overly pessimistic, for prefetches, it will be\n    // replaced by a more specific value when the data is later processed into\n    // per-segment responses (see collect-segment-data.tsx)\n    //\n    // For dynamic requests, this must always be `false` because dynamic responses\n    // are never partial.\n    const isPossiblyPartialResponse = isStaticGeneration && experimental.isRoutePPREnabled === true;\n    const LayoutOrPage = layoutOrPageMod ? interopDefault(layoutOrPageMod) : undefined;\n    /**\n   * The React Component to render.\n   */ let MaybeComponent = LayoutOrPage;\n    if (process.env.NODE_ENV === 'development') {\n        const { isValidElementType } = require('next/dist/compiled/react-is');\n        if (typeof MaybeComponent !== 'undefined' && !isValidElementType(MaybeComponent)) {\n            errorMissingDefaultExport(pagePath, modType ?? 'page');\n        }\n        if (typeof ErrorComponent !== 'undefined' && !isValidElementType(ErrorComponent)) {\n            errorMissingDefaultExport(pagePath, 'error');\n        }\n        if (typeof Loading !== 'undefined' && !isValidElementType(Loading)) {\n            errorMissingDefaultExport(pagePath, 'loading');\n        }\n        if (typeof NotFound !== 'undefined' && !isValidElementType(NotFound)) {\n            errorMissingDefaultExport(pagePath, 'not-found');\n        }\n        if (typeof Forbidden !== 'undefined' && !isValidElementType(Forbidden)) {\n            errorMissingDefaultExport(pagePath, 'forbidden');\n        }\n        if (typeof Unauthorized !== 'undefined' && !isValidElementType(Unauthorized)) {\n            errorMissingDefaultExport(pagePath, 'unauthorized');\n        }\n    }\n    // Handle dynamic segment params.\n    const segmentParam = getDynamicParamFromSegment(segment);\n    // Create object holding the parent params and current params\n    let currentParams = parentParams;\n    if (segmentParam && segmentParam.value !== null) {\n        currentParams = {\n            ...parentParams,\n            [segmentParam.param]: segmentParam.value\n        };\n    }\n    // Resolve the segment param\n    const actualSegment = segmentParam ? segmentParam.treeSegment : segment;\n    const metadata = StreamingMetadata ? /*#__PURE__*/ _jsx(StreamingMetadata, {}) : undefined;\n    // Use the same condition to render metadataOutlet as metadata\n    const metadataOutlet = StreamingMetadataOutlet ? /*#__PURE__*/ _jsx(StreamingMetadataOutlet, {}) : undefined;\n    const notFoundElement = NotFound ? /*#__PURE__*/ _jsxs(_Fragment, {\n        children: [\n            /*#__PURE__*/ _jsx(NotFound, {}),\n            notFoundStyles\n        ]\n    }) : undefined;\n    const forbiddenElement = Forbidden ? /*#__PURE__*/ _jsxs(_Fragment, {\n        children: [\n            /*#__PURE__*/ _jsx(Forbidden, {}),\n            forbiddenStyles\n        ]\n    }) : undefined;\n    const unauthorizedElement = Unauthorized ? /*#__PURE__*/ _jsxs(_Fragment, {\n        children: [\n            /*#__PURE__*/ _jsx(Unauthorized, {}),\n            unauthorizedStyles\n        ]\n    }) : undefined;\n    // TODO: Combine this `map` traversal with the loop below that turns the array\n    // into an object.\n    const parallelRouteMap = await Promise.all(Object.keys(parallelRoutes).map(async (parallelRouteKey)=>{\n        const isChildrenRouteKey = parallelRouteKey === 'children';\n        const parallelRoute = parallelRoutes[parallelRouteKey];\n        const notFoundComponent = isChildrenRouteKey ? notFoundElement : undefined;\n        const forbiddenComponent = isChildrenRouteKey ? forbiddenElement : undefined;\n        const unauthorizedComponent = isChildrenRouteKey ? unauthorizedElement : undefined;\n        // if we're prefetching and that there's a Loading component, we bail out\n        // otherwise we keep rendering for the prefetch.\n        // We also want to bail out if there's no Loading component in the tree.\n        let childCacheNodeSeedData = null;\n        if (// Before PPR, the way instant navigations work in Next.js is we\n        // prefetch everything up to the first route segment that defines a\n        // loading.tsx boundary. (We do the same if there's no loading\n        // boundary in the entire tree, because we don't want to prefetch too\n        // much) The rest of the tree is deferred until the actual navigation.\n        // It does not take into account whether the data is dynamic — even if\n        // the tree is completely static, it will still defer everything\n        // inside the loading boundary.\n        //\n        // This behavior predates PPR and is only relevant if the\n        // PPR flag is not enabled.\n        isPrefetch && (Loading || !hasLoadingComponentInTree(parallelRoute)) && // The approach with PPR is different — loading.tsx behaves like a\n        // regular Suspense boundary and has no special behavior.\n        //\n        // With PPR, we prefetch as deeply as possible, and only defer when\n        // dynamic data is accessed. If so, we only defer the nearest parent\n        // Suspense boundary of the dynamic data access, regardless of whether\n        // the boundary is defined by loading.tsx or a normal <Suspense>\n        // component in userspace.\n        //\n        // NOTE: In practice this usually means we'll end up prefetching more\n        // than we were before PPR, which may or may not be considered a\n        // performance regression by some apps. The plan is to address this\n        // before General Availability of PPR by introducing granular\n        // per-segment fetching, so we can reuse as much of the tree as\n        // possible during both prefetches and dynamic navigations. But during\n        // the beta period, we should be clear about this trade off in our\n        // communications.\n        !experimental.isRoutePPREnabled) {\n        // Don't prefetch this child. This will trigger a lazy fetch by the\n        // client router.\n        } else {\n            // Create the child component\n            if (process.env.NODE_ENV === 'development' && missingSlots) {\n                var _parsedTree_layoutOrPagePath;\n                // When we detect the default fallback (which triggers a 404), we collect the missing slots\n                // to provide more helpful debug information during development mode.\n                const parsedTree = parseLoaderTree(parallelRoute);\n                if ((_parsedTree_layoutOrPagePath = parsedTree.layoutOrPagePath) == null ? void 0 : _parsedTree_layoutOrPagePath.endsWith(PARALLEL_ROUTE_DEFAULT_PATH)) {\n                    missingSlots.add(parallelRouteKey);\n                }\n            }\n            const seedData = await createComponentTreeInternal({\n                loaderTree: parallelRoute,\n                parentParams: currentParams,\n                rootLayoutIncluded: rootLayoutIncludedAtThisLevelOrAbove,\n                injectedCSS: injectedCSSWithCurrentLayout,\n                injectedJS: injectedJSWithCurrentLayout,\n                injectedFontPreloadTags: injectedFontPreloadTagsWithCurrentLayout,\n                // `getMetadataReady` and `getViewportReady` are used to conditionally throw. In the case of parallel routes we will have more than one page\n                // but we only want to throw on the first one.\n                getMetadataReady: isChildrenRouteKey ? getMetadataReady : ()=>Promise.resolve(),\n                getViewportReady: isChildrenRouteKey ? getViewportReady : ()=>Promise.resolve(),\n                ctx,\n                missingSlots,\n                preloadCallbacks,\n                authInterrupts,\n                StreamingMetadata: isChildrenRouteKey ? StreamingMetadata : null,\n                // `StreamingMetadataOutlet` is used to conditionally throw. In the case of parallel routes we will have more than one page\n                // but we only want to throw on the first one.\n                StreamingMetadataOutlet: isChildrenRouteKey ? StreamingMetadataOutlet : null\n            });\n            childCacheNodeSeedData = seedData;\n        }\n        // This is turned back into an object below.\n        return [\n            parallelRouteKey,\n            /*#__PURE__*/ _jsx(LayoutRouter, {\n                parallelRouterKey: parallelRouteKey,\n                // TODO-APP: Add test for loading returning `undefined`. This currently can't be tested as the `webdriver()` tab will wait for the full page to load before returning.\n                error: ErrorComponent,\n                errorStyles: errorStyles,\n                errorScripts: errorScripts,\n                template: /*#__PURE__*/ _jsx(Template, {\n                    children: /*#__PURE__*/ _jsx(RenderFromTemplateContext, {})\n                }),\n                templateStyles: templateStyles,\n                templateScripts: templateScripts,\n                notFound: notFoundComponent,\n                forbidden: forbiddenComponent,\n                unauthorized: unauthorizedComponent\n            }),\n            childCacheNodeSeedData\n        ];\n    }));\n    // Convert the parallel route map into an object after all promises have been resolved.\n    let parallelRouteProps = {};\n    let parallelRouteCacheNodeSeedData = {};\n    for (const parallelRoute of parallelRouteMap){\n        const [parallelRouteKey, parallelRouteProp, flightData] = parallelRoute;\n        parallelRouteProps[parallelRouteKey] = parallelRouteProp;\n        parallelRouteCacheNodeSeedData[parallelRouteKey] = flightData;\n    }\n    const loadingData = Loading ? [\n        /*#__PURE__*/ _jsx(Loading, {}, \"l\"),\n        loadingStyles,\n        loadingScripts\n    ] : null;\n    // When the segment does not have a layout or page we still have to add the layout router to ensure the path holds the loading component\n    if (!MaybeComponent) {\n        return [\n            actualSegment,\n            /*#__PURE__*/ _jsxs(React.Fragment, {\n                children: [\n                    layerAssets,\n                    parallelRouteProps.children\n                ]\n            }, cacheNodeKey),\n            parallelRouteCacheNodeSeedData,\n            loadingData,\n            isPossiblyPartialResponse\n        ];\n    }\n    const Component = MaybeComponent;\n    // If force-dynamic is used and the current render supports postponing, we\n    // replace it with a node that will postpone the render. This ensures that the\n    // postpone is invoked during the react render phase and not during the next\n    // render phase.\n    // @TODO this does not actually do what it seems like it would or should do. The idea is that\n    // if we are rendering in a force-dynamic mode and we can postpone we should only make the segments\n    // that ask for force-dynamic to be dynamic, allowing other segments to still prerender. However\n    // because this comes after the children traversal and the static generation store is mutated every segment\n    // along the parent path of a force-dynamic segment will hit this condition effectively making the entire\n    // render force-dynamic. We should refactor this function so that we can correctly track which segments\n    // need to be dynamic\n    if (workStore.isStaticGeneration && workStore.forceDynamic && experimental.isRoutePPREnabled) {\n        return [\n            actualSegment,\n            /*#__PURE__*/ _jsxs(React.Fragment, {\n                children: [\n                    /*#__PURE__*/ _jsx(Postpone, {\n                        reason: 'dynamic = \"force-dynamic\" was used',\n                        route: workStore.route\n                    }),\n                    layerAssets\n                ]\n            }, cacheNodeKey),\n            parallelRouteCacheNodeSeedData,\n            loadingData,\n            true\n        ];\n    }\n    const isClientComponent = isClientReference(layoutOrPageMod);\n    if (process.env.NODE_ENV === 'development' && 'params' in parallelRouteProps) {\n        // @TODO consider making this an error and running the check in build as well\n        console.error(`\"params\" is a reserved prop in Layouts and Pages and cannot be used as the name of a parallel route in ${segment}`);\n    }\n    if (isPage) {\n        const PageComponent = Component;\n        // Assign searchParams to props if this is a page\n        let pageElement;\n        if (isClientComponent) {\n            if (isStaticGeneration) {\n                const promiseOfParams = createPrerenderParamsForClientSegment(currentParams, workStore);\n                const promiseOfSearchParams = createPrerenderSearchParamsForClientPage(workStore);\n                pageElement = /*#__PURE__*/ _jsx(ClientPageRoot, {\n                    Component: PageComponent,\n                    searchParams: query,\n                    params: currentParams,\n                    promises: [\n                        promiseOfSearchParams,\n                        promiseOfParams\n                    ]\n                });\n            } else {\n                pageElement = /*#__PURE__*/ _jsx(ClientPageRoot, {\n                    Component: PageComponent,\n                    searchParams: query,\n                    params: currentParams\n                });\n            }\n        } else {\n            // If we are passing params to a server component Page we need to track\n            // their usage in case the current render mode tracks dynamic API usage.\n            const params = createServerParamsForServerSegment(currentParams, workStore);\n            // TODO(useCache): Should we use this trick also if dynamicIO is enabled,\n            // instead of relying on the searchParams being a hanging promise?\n            if (!experimental.dynamicIO && isUseCacheFunction(PageComponent)) {\n                const UseCachePageComponent = PageComponent;\n                // The \"use cache\" wrapper takes care of converting this into an\n                // erroring search params promise when passing it to the original\n                // function.\n                const searchParams = Promise.resolve({});\n                pageElement = /*#__PURE__*/ _jsx(UseCachePageComponent, {\n                    params: params,\n                    searchParams: searchParams,\n                    $$isPageComponent: true\n                });\n            } else {\n                // If we are passing searchParams to a server component Page we need to\n                // track their usage in case the current render mode tracks dynamic API\n                // usage.\n                const searchParams = createServerSearchParamsForServerPage(query, workStore);\n                pageElement = /*#__PURE__*/ _jsx(PageComponent, {\n                    params: params,\n                    searchParams: searchParams\n                });\n            }\n        }\n        return [\n            actualSegment,\n            /*#__PURE__*/ _jsxs(React.Fragment, {\n                children: [\n                    pageElement,\n                    metadata,\n                    layerAssets,\n                    /*#__PURE__*/ _jsxs(OutletBoundary, {\n                        children: [\n                            /*#__PURE__*/ _jsx(MetadataOutlet, {\n                                ready: getViewportReady\n                            }),\n                            /*#__PURE__*/ _jsx(MetadataOutlet, {\n                                ready: getMetadataReady\n                            }),\n                            metadataOutlet\n                        ]\n                    })\n                ]\n            }, cacheNodeKey),\n            parallelRouteCacheNodeSeedData,\n            loadingData,\n            isPossiblyPartialResponse\n        ];\n    } else {\n        const SegmentComponent = Component;\n        const isRootLayoutWithChildrenSlotAndAtLeastOneMoreSlot = rootLayoutAtThisLevel && 'children' in parallelRoutes && Object.keys(parallelRoutes).length > 1;\n        let segmentNode;\n        if (isClientComponent) {\n            let clientSegment;\n            if (isStaticGeneration) {\n                const promiseOfParams = createPrerenderParamsForClientSegment(currentParams, workStore);\n                clientSegment = /*#__PURE__*/ _jsx(ClientSegmentRoot, {\n                    Component: SegmentComponent,\n                    slots: parallelRouteProps,\n                    params: currentParams,\n                    promise: promiseOfParams\n                });\n            } else {\n                clientSegment = /*#__PURE__*/ _jsx(ClientSegmentRoot, {\n                    Component: SegmentComponent,\n                    slots: parallelRouteProps,\n                    params: currentParams\n                });\n            }\n            if (isRootLayoutWithChildrenSlotAndAtLeastOneMoreSlot) {\n                let notfoundClientSegment;\n                let forbiddenClientSegment;\n                let unauthorizedClientSegment;\n                // TODO-APP: This is a hack to support unmatched parallel routes, which will throw `notFound()`.\n                // This ensures that a `HTTPAccessFallbackBoundary` is available for when that happens,\n                // but it's not ideal, as it needlessly invokes the `NotFound` component and renders the `RootLayout` twice.\n                // We should instead look into handling the fallback behavior differently in development mode so that it doesn't\n                // rely on the `NotFound` behavior.\n                notfoundClientSegment = createErrorBoundaryClientSegmentRoot({\n                    ErrorBoundaryComponent: NotFound,\n                    errorElement: notFoundElement,\n                    ClientSegmentRoot,\n                    layerAssets,\n                    SegmentComponent,\n                    currentParams\n                });\n                forbiddenClientSegment = createErrorBoundaryClientSegmentRoot({\n                    ErrorBoundaryComponent: Forbidden,\n                    errorElement: forbiddenElement,\n                    ClientSegmentRoot,\n                    layerAssets,\n                    SegmentComponent,\n                    currentParams\n                });\n                unauthorizedClientSegment = createErrorBoundaryClientSegmentRoot({\n                    ErrorBoundaryComponent: Unauthorized,\n                    errorElement: unauthorizedElement,\n                    ClientSegmentRoot,\n                    layerAssets,\n                    SegmentComponent,\n                    currentParams\n                });\n                if (notfoundClientSegment || forbiddenClientSegment || unauthorizedClientSegment) {\n                    segmentNode = /*#__PURE__*/ _jsxs(HTTPAccessFallbackBoundary, {\n                        notFound: notfoundClientSegment,\n                        forbidden: forbiddenClientSegment,\n                        unauthorized: unauthorizedClientSegment,\n                        children: [\n                            layerAssets,\n                            clientSegment\n                        ]\n                    }, cacheNodeKey);\n                } else {\n                    segmentNode = /*#__PURE__*/ _jsxs(React.Fragment, {\n                        children: [\n                            layerAssets,\n                            clientSegment\n                        ]\n                    }, cacheNodeKey);\n                }\n            } else {\n                segmentNode = /*#__PURE__*/ _jsxs(React.Fragment, {\n                    children: [\n                        layerAssets,\n                        clientSegment\n                    ]\n                }, cacheNodeKey);\n            }\n        } else {\n            const params = createServerParamsForServerSegment(currentParams, workStore);\n            let serverSegment = /*#__PURE__*/ _jsx(SegmentComponent, {\n                ...parallelRouteProps,\n                params: params\n            });\n            if (isRootLayoutWithChildrenSlotAndAtLeastOneMoreSlot) {\n                // TODO-APP: This is a hack to support unmatched parallel routes, which will throw `notFound()`.\n                // This ensures that a `HTTPAccessFallbackBoundary` is available for when that happens,\n                // but it's not ideal, as it needlessly invokes the `NotFound` component and renders the `RootLayout` twice.\n                // We should instead look into handling the fallback behavior differently in development mode so that it doesn't\n                // rely on the `NotFound` behavior.\n                segmentNode = /*#__PURE__*/ _jsxs(HTTPAccessFallbackBoundary, {\n                    notFound: NotFound ? /*#__PURE__*/ _jsxs(_Fragment, {\n                        children: [\n                            layerAssets,\n                            /*#__PURE__*/ _jsxs(SegmentComponent, {\n                                params: params,\n                                children: [\n                                    notFoundStyles,\n                                    /*#__PURE__*/ _jsx(NotFound, {})\n                                ]\n                            })\n                        ]\n                    }) : undefined,\n                    children: [\n                        layerAssets,\n                        serverSegment\n                    ]\n                }, cacheNodeKey);\n            } else {\n                segmentNode = /*#__PURE__*/ _jsxs(React.Fragment, {\n                    children: [\n                        layerAssets,\n                        serverSegment\n                    ]\n                }, cacheNodeKey);\n            }\n        }\n        // For layouts we just render the component\n        return [\n            actualSegment,\n            segmentNode,\n            parallelRouteCacheNodeSeedData,\n            loadingData,\n            isPossiblyPartialResponse\n        ];\n    }\n}\nasync function MetadataOutlet({ ready }) {\n    const r = ready();\n    // We can avoid a extra microtask by unwrapping the instrumented promise directly if available.\n    if (r.status === 'rejected') {\n        throw r.value;\n    } else if (r.status !== 'fulfilled') {\n        await r;\n    }\n    return null;\n}\nMetadataOutlet.displayName = OUTLET_BOUNDARY_NAME;\nfunction createErrorBoundaryClientSegmentRoot({ ErrorBoundaryComponent, errorElement, ClientSegmentRoot, layerAssets, SegmentComponent, currentParams }) {\n    if (ErrorBoundaryComponent) {\n        const notFoundParallelRouteProps = {\n            children: errorElement\n        };\n        return /*#__PURE__*/ _jsxs(_Fragment, {\n            children: [\n                layerAssets,\n                /*#__PURE__*/ _jsx(ClientSegmentRoot, {\n                    Component: SegmentComponent,\n                    slots: notFoundParallelRouteProps,\n                    params: currentParams\n                })\n            ]\n        });\n    }\n    return null;\n}\nexport function getRootParams(loaderTree, getDynamicParamFromSegment) {\n    return getRootParamsImpl({}, loaderTree, getDynamicParamFromSegment);\n}\nfunction getRootParamsImpl(parentParams, loaderTree, getDynamicParamFromSegment) {\n    const { segment, modules: { layout }, parallelRoutes } = parseLoaderTree(loaderTree);\n    const segmentParam = getDynamicParamFromSegment(segment);\n    let currentParams = parentParams;\n    if (segmentParam && segmentParam.value !== null) {\n        currentParams = {\n            ...parentParams,\n            [segmentParam.param]: segmentParam.value\n        };\n    }\n    const isRootLayout = typeof layout !== 'undefined';\n    if (isRootLayout) {\n        return currentParams;\n    } else if (!parallelRoutes.children) {\n        // This should really be an error but there are bugs in Turbopack that cause\n        // the _not-found LoaderTree to not have any layouts. For rootParams sake\n        // this is somewhat irrelevant when you are not customizing the 404 page.\n        // If you are customizing 404\n        // TODO update rootParams to make all params optional if `/app/not-found.tsx` is defined\n        return currentParams;\n    } else {\n        return getRootParamsImpl(currentParams, // We stop looking for root params as soon as we hit the first layout\n        // and it is not possible to use parallel route children above the root layout\n        // so every parallelRoutes object that this function can visit will necessarily\n        // have a single `children` prop and no others.\n        parallelRoutes.children, getDynamicParamFromSegment);\n    }\n}\n\n//# sourceMappingURL=create-component-tree.js.map"
        }
    ]
}