{
    "sourceFile": "node_modules/next/dist/esm/server/app-render/app-render.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892821594,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import { jsx as _jsx, jsxs as _jsxs } from \"react/jsx-runtime\";\nimport { workAsyncStorage } from '../app-render/work-async-storage.external';\nimport React from 'react';\nimport RenderResult from '../render-result';\nimport { chainStreams, renderToInitialFizzStream, createDocumentClosingStream, continueFizzStream, continueDynamicPrerender, continueStaticPrerender, continueDynamicHTMLResume, streamToBuffer, streamToString } from '../stream-utils/node-web-streams-helper';\nimport { stripInternalQueries } from '../internal-utils';\nimport { NEXT_HMR_REFRESH_HEADER, NEXT_ROUTER_PREFETCH_HEADER, NEXT_ROUTER_STATE_TREE_HEADER, NEXT_ROUTER_STALE_TIME_HEADER, NEXT_URL, RSC_HEADER, NEXT_ROUTER_SEGMENT_PREFETCH_HEADER, NEXT_HMR_REFRESH_HASH_COOKIE } from '../../client/components/app-router-headers';\nimport { createTrackedMetadataContext, createMetadataContext } from '../../lib/metadata/metadata-context';\nimport { createRequestStoreForRender } from '../async-storage/request-store';\nimport { createWorkStore } from '../async-storage/work-store';\nimport { getAccessFallbackErrorTypeByStatus, getAccessFallbackHTTPStatus, isHTTPAccessFallbackError } from '../../client/components/http-access-fallback/http-access-fallback';\nimport { getURLFromRedirectError, getRedirectStatusCodeFromError } from '../../client/components/redirect';\nimport { isRedirectError } from '../../client/components/redirect-error';\nimport { getImplicitTags } from '../lib/implicit-tags';\nimport { AppRenderSpan, NextNodeServerSpan } from '../lib/trace/constants';\nimport { getTracer } from '../lib/trace/tracer';\nimport { FlightRenderResult } from './flight-render-result';\nimport { createFlightReactServerErrorHandler, createHTMLReactServerErrorHandler, createHTMLErrorHandler, isUserLandError, getDigestForWellKnownError } from './create-error-handler';\nimport { getShortDynamicParamType, dynamicParamTypes } from './get-short-dynamic-param-type';\nimport { getSegmentParam } from './get-segment-param';\nimport { getScriptNonceFromHeader } from './get-script-nonce-from-header';\nimport { parseAndValidateFlightRouterState } from './parse-and-validate-flight-router-state';\nimport { createFlightRouterStateFromLoaderTree } from './create-flight-router-state-from-loader-tree';\nimport { handleAction } from './action-handler';\nimport { isBailoutToCSRError } from '../../shared/lib/lazy-dynamic/bailout-to-csr';\nimport { warn, error } from '../../build/output/log';\nimport { appendMutableCookies } from '../web/spec-extension/adapters/request-cookies';\nimport { createServerInsertedHTML } from './server-inserted-html';\nimport { getRequiredScripts } from './required-scripts';\nimport { addPathPrefix } from '../../shared/lib/router/utils/add-path-prefix';\nimport { makeGetServerInsertedHTML } from './make-get-server-inserted-html';\nimport { walkTreeWithFlightRouterState } from './walk-tree-with-flight-router-state';\nimport { createComponentTree, getRootParams } from './create-component-tree';\nimport { getAssetQueryString } from './get-asset-query-string';\nimport { setReferenceManifestsSingleton } from './encryption-utils';\nimport { DynamicState, parsePostponedState } from './postponed-state';\nimport { getDynamicDataPostponedState, getDynamicHTMLPostponedState, getPostponedFromState } from './postponed-state';\nimport { isDynamicServerError } from '../../client/components/hooks-server-context';\nimport { useFlightStream, createInlinedDataReadableStream } from './use-flight-response';\nimport { StaticGenBailoutError, isStaticGenBailoutError } from '../../client/components/static-generation-bailout';\nimport { getStackWithoutErrorMessage } from '../../lib/format-server-error';\nimport { accessedDynamicData, createPostponedAbortSignal, formatDynamicAPIAccesses, isPrerenderInterruptedError, createDynamicTrackingState, createDynamicValidationState, getFirstDynamicReason, trackAllowedDynamicAccess, throwIfDisallowedDynamic, consumeDynamicAccess } from './dynamic-rendering';\nimport { getClientComponentLoaderMetrics, wrapClientComponentLoader } from '../client-component-renderer-logger';\nimport { createServerModuleMap } from './action-utils';\nimport { isNodeNextRequest } from '../base-http/helpers';\nimport { parseParameter } from '../../shared/lib/router/utils/route-regex';\nimport { parseRelativeUrl } from '../../shared/lib/router/utils/parse-relative-url';\nimport AppRouter from '../../client/components/app-router';\nimport { getIsPossibleServerAction } from '../lib/server-action-request-meta';\nimport { createInitialRouterState } from '../../client/components/router-reducer/create-initial-router-state';\nimport { createMutableActionQueue } from '../../client/components/app-router-instance';\nimport { getRevalidateReason } from '../instrumentation/utils';\nimport { PAGE_SEGMENT_KEY } from '../../shared/lib/segment';\nimport { DynamicServerError } from '../../client/components/hooks-server-context';\nimport { ServerPrerenderStreamResult } from './app-render-prerender-utils';\nimport { ReactServerResult, createReactServerPrerenderResult, createReactServerPrerenderResultFromRender, prerenderAndAbortInSequentialTasks, prerenderServerWithPhases, prerenderClientWithPhases } from './app-render-prerender-utils';\nimport { printDebugThrownValueForProspectiveRender } from './prospective-render-utils';\nimport { scheduleInSequentialTasks } from './app-render-render-utils';\nimport { waitAtLeastOneReactRenderTask } from '../../lib/scheduler';\nimport { workUnitAsyncStorage } from './work-unit-async-storage.external';\nimport { CacheSignal } from './cache-signal';\nimport { getTracedMetadata } from '../lib/trace/utils';\nimport { InvariantError } from '../../shared/lib/invariant-error';\nimport './clean-async-snapshot.external';\nimport { INFINITE_CACHE } from '../../lib/constants';\nimport { createComponentStylesAndScripts } from './create-component-styles-and-scripts';\nimport { parseLoaderTree } from './parse-loader-tree';\nimport { createPrerenderResumeDataCache, createRenderResumeDataCache } from '../resume-data-cache/resume-data-cache';\nimport isError from '../../lib/is-error';\nimport { isUseCacheTimeoutError } from '../use-cache/use-cache-errors';\nimport { createServerInsertedMetadata } from './metadata-insertion/create-server-inserted-metadata';\nimport { getPreviouslyRevalidatedTags } from '../server-utils';\nimport { executeRevalidates } from '../revalidation-utils';\nconst flightDataPathHeadKey = 'h';\nfunction parseRequestHeaders(headers, options) {\n    const isDevWarmupRequest = options.isDevWarmup === true;\n    // dev warmup requests are treated as prefetch RSC requests\n    const isPrefetchRequest = isDevWarmupRequest || headers[NEXT_ROUTER_PREFETCH_HEADER.toLowerCase()] !== undefined;\n    const isHmrRefresh = headers[NEXT_HMR_REFRESH_HEADER.toLowerCase()] !== undefined;\n    // dev warmup requests are treated as prefetch RSC requests\n    const isRSCRequest = isDevWarmupRequest || headers[RSC_HEADER.toLowerCase()] !== undefined;\n    const shouldProvideFlightRouterState = isRSCRequest && (!isPrefetchRequest || !options.isRoutePPREnabled);\n    const flightRouterState = shouldProvideFlightRouterState ? parseAndValidateFlightRouterState(headers[NEXT_ROUTER_STATE_TREE_HEADER.toLowerCase()]) : undefined;\n    // Checks if this is a prefetch of the Route Tree by the Segment Cache\n    const isRouteTreePrefetchRequest = headers[NEXT_ROUTER_SEGMENT_PREFETCH_HEADER.toLowerCase()] === '/_tree';\n    const csp = headers['content-security-policy'] || headers['content-security-policy-report-only'];\n    const nonce = typeof csp === 'string' ? getScriptNonceFromHeader(csp) : undefined;\n    const previouslyRevalidatedTags = getPreviouslyRevalidatedTags(headers, options.previewModeId);\n    return {\n        flightRouterState,\n        isPrefetchRequest,\n        isRouteTreePrefetchRequest,\n        isHmrRefresh,\n        isRSCRequest,\n        isDevWarmupRequest,\n        nonce,\n        previouslyRevalidatedTags\n    };\n}\nfunction createNotFoundLoaderTree(loaderTree) {\n    // Align the segment with parallel-route-default in next-app-loader\n    const components = loaderTree[2];\n    return [\n        '',\n        {\n            children: [\n                PAGE_SEGMENT_KEY,\n                {},\n                {\n                    page: components['not-found']\n                }\n            ]\n        },\n        components\n    ];\n}\nfunction createDivergedMetadataComponents(Metadata, serveStreamingMetadata) {\n    function EmptyMetadata() {\n        return null;\n    }\n    const StreamingMetadata = serveStreamingMetadata ? Metadata : null;\n    const StaticMetadata = serveStreamingMetadata ? EmptyMetadata : Metadata;\n    return {\n        StaticMetadata,\n        StreamingMetadata\n    };\n}\n/**\n * Returns a function that parses the dynamic segment and return the associated value.\n */ function makeGetDynamicParamFromSegment(params, pagePath, fallbackRouteParams) {\n    return function getDynamicParamFromSegment(// [slug] / [[slug]] / [...slug]\n    segment) {\n        const segmentParam = getSegmentParam(segment);\n        if (!segmentParam) {\n            return null;\n        }\n        const key = segmentParam.param;\n        let value = params[key];\n        if (fallbackRouteParams && fallbackRouteParams.has(segmentParam.param)) {\n            value = fallbackRouteParams.get(segmentParam.param);\n        } else if (Array.isArray(value)) {\n            value = value.map((i)=>encodeURIComponent(i));\n        } else if (typeof value === 'string') {\n            value = encodeURIComponent(value);\n        }\n        if (!value) {\n            const isCatchall = segmentParam.type === 'catchall';\n            const isOptionalCatchall = segmentParam.type === 'optional-catchall';\n            if (isCatchall || isOptionalCatchall) {\n                const dynamicParamType = dynamicParamTypes[segmentParam.type];\n                // handle the case where an optional catchall does not have a value,\n                // e.g. `/dashboard/[[...slug]]` when requesting `/dashboard`\n                if (isOptionalCatchall) {\n                    return {\n                        param: key,\n                        value: null,\n                        type: dynamicParamType,\n                        treeSegment: [\n                            key,\n                            '',\n                            dynamicParamType\n                        ]\n                    };\n                }\n                // handle the case where a catchall or optional catchall does not have a value,\n                // e.g. `/foo/bar/hello` and `@slot/[...catchall]` or `@slot/[[...catchall]]` is matched\n                value = pagePath.split('/')// remove the first empty string\n                .slice(1)// replace any dynamic params with the actual values\n                .flatMap((pathSegment)=>{\n                    const param = parseParameter(pathSegment);\n                    // if the segment matches a param, return the param value\n                    // otherwise, it's a static segment, so just return that\n                    return params[param.key] ?? param.key;\n                });\n                return {\n                    param: key,\n                    value,\n                    type: dynamicParamType,\n                    // This value always has to be a string.\n                    treeSegment: [\n                        key,\n                        value.join('/'),\n                        dynamicParamType\n                    ]\n                };\n            }\n        }\n        const type = getShortDynamicParamType(segmentParam.type);\n        return {\n            param: key,\n            // The value that is passed to user code.\n            value: value,\n            // The value that is rendered in the router tree.\n            treeSegment: [\n                key,\n                Array.isArray(value) ? value.join('/') : value,\n                type\n            ],\n            type: type\n        };\n    };\n}\nfunction NonIndex({ pagePath, statusCode, isPossibleServerAction }) {\n    const is404Page = pagePath === '/404';\n    const isInvalidStatusCode = typeof statusCode === 'number' && statusCode > 400;\n    // Only render noindex for page request, skip for server actions\n    // TODO: is this correct if `isPossibleServerAction` is a false positive?\n    if (!isPossibleServerAction && (is404Page || isInvalidStatusCode)) {\n        return /*#__PURE__*/ _jsx(\"meta\", {\n            name: \"robots\",\n            content: \"noindex\"\n        });\n    }\n    return null;\n}\n/**\n * This is used by server actions & client-side navigations to generate RSC data from a client-side request.\n * This function is only called on \"dynamic\" requests (ie, there wasn't already a static response).\n * It uses request headers (namely `Next-Router-State-Tree`) to determine where to start rendering.\n */ async function generateDynamicRSCPayload(ctx, options) {\n    // Flight data that is going to be passed to the browser.\n    // Currently a single item array but in the future multiple patches might be combined in a single request.\n    // We initialize `flightData` to an empty string because the client router knows how to tolerate\n    // it (treating it as an MPA navigation). The only time this function wouldn't generate flight data\n    // is for server actions, if the server action handler instructs this function to skip it. When the server\n    // action reducer sees a falsy value, it'll simply resolve the action with no data.\n    let flightData = '';\n    const { componentMod: { tree: loaderTree, createMetadataComponents, MetadataBoundary, ViewportBoundary }, getDynamicParamFromSegment, appUsingSizeAdjustment, query, requestId, flightRouterState, workStore, url } = ctx;\n    const serveStreamingMetadata = !!ctx.renderOpts.serveStreamingMetadata;\n    if (!(options == null ? void 0 : options.skipFlight)) {\n        const preloadCallbacks = [];\n        const { ViewportTree, MetadataTree, getViewportReady, getMetadataReady, StreamingMetadataOutlet } = createMetadataComponents({\n            tree: loaderTree,\n            parsedQuery: query,\n            metadataContext: createTrackedMetadataContext(url.pathname, ctx.renderOpts, workStore),\n            getDynamicParamFromSegment,\n            appUsingSizeAdjustment,\n            workStore,\n            MetadataBoundary,\n            ViewportBoundary,\n            serveStreamingMetadata\n        });\n        const { StreamingMetadata, StaticMetadata } = createDivergedMetadataComponents(()=>{\n            return(// Adding requestId as react key to make metadata remount for each render\n            /*#__PURE__*/ _jsx(MetadataTree, {}, requestId));\n        }, serveStreamingMetadata);\n        flightData = (await walkTreeWithFlightRouterState({\n            ctx,\n            loaderTreeToFilter: loaderTree,\n            parentParams: {},\n            flightRouterState,\n            // For flight, render metadata inside leaf page\n            rscHead: /*#__PURE__*/ _jsxs(React.Fragment, {\n                children: [\n                    /*#__PURE__*/ _jsx(NonIndex, {\n                        pagePath: ctx.pagePath,\n                        statusCode: ctx.res.statusCode,\n                        isPossibleServerAction: ctx.isPossibleServerAction\n                    }),\n                    /*#__PURE__*/ _jsx(ViewportTree, {}, requestId),\n                    StreamingMetadata ? /*#__PURE__*/ _jsx(StreamingMetadata, {}) : null,\n                    /*#__PURE__*/ _jsx(StaticMetadata, {})\n                ]\n            }, flightDataPathHeadKey),\n            injectedCSS: new Set(),\n            injectedJS: new Set(),\n            injectedFontPreloadTags: new Set(),\n            rootLayoutIncluded: false,\n            getViewportReady,\n            getMetadataReady,\n            preloadCallbacks,\n            StreamingMetadataOutlet\n        })).map((path)=>path.slice(1)) // remove the '' (root) segment\n        ;\n    }\n    // If we have an action result, then this is a server action response.\n    // We can rely on this because `ActionResult` will always be a promise, even if\n    // the result is falsey.\n    if (options == null ? void 0 : options.actionResult) {\n        return {\n            a: options.actionResult,\n            f: flightData,\n            b: ctx.sharedContext.buildId\n        };\n    }\n    // Otherwise, it's a regular RSC response.\n    return {\n        b: ctx.sharedContext.buildId,\n        f: flightData,\n        S: workStore.isStaticGeneration\n    };\n}\nfunction createErrorContext(ctx, renderSource) {\n    return {\n        routerKind: 'App Router',\n        routePath: ctx.pagePath,\n        // TODO: is this correct if `isPossibleServerAction` is a false positive?\n        routeType: ctx.isPossibleServerAction ? 'action' : 'render',\n        renderSource,\n        revalidateReason: getRevalidateReason(ctx.workStore)\n    };\n}\n/**\n * Produces a RenderResult containing the Flight data for the given request. See\n * `generateDynamicRSCPayload` for information on the contents of the render result.\n */ async function generateDynamicFlightRenderResult(req, ctx, requestStore, options) {\n    const renderOpts = ctx.renderOpts;\n    function onFlightDataRenderError(err) {\n        return renderOpts.onInstrumentationRequestError == null ? void 0 : renderOpts.onInstrumentationRequestError.call(renderOpts, err, req, createErrorContext(ctx, 'react-server-components-payload'));\n    }\n    const onError = createFlightReactServerErrorHandler(!!renderOpts.dev, onFlightDataRenderError);\n    const RSCPayload = await workUnitAsyncStorage.run(requestStore, generateDynamicRSCPayload, ctx, options);\n    if (// We only want this behavior when running `next dev`\n    renderOpts.dev && // We only want this behavior when we have React's dev builds available\n    process.env.NODE_ENV === 'development' && // We only have a Prerender environment for projects opted into dynamicIO\n    renderOpts.experimental.dynamicIO) {\n        const [resolveValidation, validationOutlet] = createValidationOutlet();\n        RSCPayload._validation = validationOutlet;\n        spawnDynamicValidationInDev(resolveValidation, ctx.componentMod.tree, ctx, false, ctx.clientReferenceManifest, ctx.workStore.route, requestStore);\n    }\n    // For app dir, use the bundled version of Flight server renderer (renderToReadableStream)\n    // which contains the subset React.\n    const flightReadableStream = workUnitAsyncStorage.run(requestStore, ctx.componentMod.renderToReadableStream, RSCPayload, ctx.clientReferenceManifest.clientModules, {\n        onError,\n        temporaryReferences: options == null ? void 0 : options.temporaryReferences\n    });\n    return new FlightRenderResult(flightReadableStream, {\n        fetchMetrics: ctx.workStore.fetchMetrics\n    });\n}\n/**\n * Performs a \"warmup\" render of the RSC payload for a given route. This function is called by the server\n * prior to an actual render request in Dev mode only. It's purpose is to fill caches so the actual render\n * can accurately log activity in the right render context (Prerender vs Render).\n *\n * At the moment this implementation is mostly a fork of generateDynamicFlightRenderResult\n */ async function warmupDevRender(req, ctx) {\n    const { clientReferenceManifest, componentMod, getDynamicParamFromSegment, implicitTags, renderOpts, workStore } = ctx;\n    if (!renderOpts.dev) {\n        throw Object.defineProperty(new InvariantError('generateDynamicFlightRenderResult should never be called in `next start` mode.'), \"__NEXT_ERROR_CODE\", {\n            value: \"E523\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    const rootParams = getRootParams(componentMod.tree, getDynamicParamFromSegment);\n    function onFlightDataRenderError(err) {\n        return renderOpts.onInstrumentationRequestError == null ? void 0 : renderOpts.onInstrumentationRequestError.call(renderOpts, err, req, createErrorContext(ctx, 'react-server-components-payload'));\n    }\n    const onError = createFlightReactServerErrorHandler(true, onFlightDataRenderError);\n    // We're doing a dev warmup, so we should create a new resume data cache so\n    // we can fill it.\n    const prerenderResumeDataCache = createPrerenderResumeDataCache();\n    const renderController = new AbortController();\n    const prerenderController = new AbortController();\n    const cacheSignal = new CacheSignal();\n    const prerenderStore = {\n        type: 'prerender',\n        phase: 'render',\n        rootParams,\n        implicitTags,\n        renderSignal: renderController.signal,\n        controller: prerenderController,\n        cacheSignal,\n        dynamicTracking: null,\n        revalidate: INFINITE_CACHE,\n        expire: INFINITE_CACHE,\n        stale: INFINITE_CACHE,\n        tags: [],\n        prerenderResumeDataCache,\n        hmrRefreshHash: req.cookies[NEXT_HMR_REFRESH_HASH_COOKIE]\n    };\n    const rscPayload = await workUnitAsyncStorage.run(prerenderStore, generateDynamicRSCPayload, ctx);\n    // For app dir, use the bundled version of Flight server renderer (renderToReadableStream)\n    // which contains the subset React.\n    workUnitAsyncStorage.run(prerenderStore, componentMod.renderToReadableStream, rscPayload, clientReferenceManifest.clientModules, {\n        onError,\n        signal: renderController.signal\n    });\n    // Wait for all caches to be finished filling\n    await cacheSignal.cacheReady();\n    // We unset the cache so any late over-run renders aren't able to write into this cache\n    prerenderStore.prerenderResumeDataCache = null;\n    // Abort the render\n    renderController.abort();\n    // We don't really want to return a result here but the stack of functions\n    // that calls into renderToHTML... expects a result. We should refactor this to\n    // lift the warmup pathway outside of renderToHTML... but for now this suffices\n    return new FlightRenderResult('', {\n        fetchMetrics: workStore.fetchMetrics,\n        devRenderResumeDataCache: createRenderResumeDataCache(prerenderResumeDataCache)\n    });\n}\n/**\n * Crawlers will inadvertently think the canonicalUrl in the RSC payload should be crawled\n * when our intention is to just seed the router state with the current URL.\n * This function splits up the pathname so that we can later join it on\n * when we're ready to consume the path.\n */ function prepareInitialCanonicalUrl(url) {\n    return (url.pathname + url.search).split('/');\n}\n// This is the data necessary to render <AppRouter /> when no SSR errors are encountered\nasync function getRSCPayload(tree, ctx, is404) {\n    const injectedCSS = new Set();\n    const injectedJS = new Set();\n    const injectedFontPreloadTags = new Set();\n    let missingSlots;\n    // We only track missing parallel slots in development\n    if (process.env.NODE_ENV === 'development') {\n        missingSlots = new Set();\n    }\n    const { getDynamicParamFromSegment, query, appUsingSizeAdjustment, componentMod: { GlobalError, createMetadataComponents, MetadataBoundary, ViewportBoundary }, url, workStore } = ctx;\n    const initialTree = createFlightRouterStateFromLoaderTree(tree, getDynamicParamFromSegment, query);\n    const serveStreamingMetadata = !!ctx.renderOpts.serveStreamingMetadata;\n    const { ViewportTree, MetadataTree, getViewportReady, getMetadataReady, StreamingMetadataOutlet } = createMetadataComponents({\n        tree,\n        errorType: is404 ? 'not-found' : undefined,\n        parsedQuery: query,\n        metadataContext: createTrackedMetadataContext(url.pathname, ctx.renderOpts, workStore),\n        getDynamicParamFromSegment,\n        appUsingSizeAdjustment,\n        workStore,\n        MetadataBoundary,\n        ViewportBoundary,\n        serveStreamingMetadata\n    });\n    const preloadCallbacks = [];\n    const { StreamingMetadata, StaticMetadata } = createDivergedMetadataComponents(()=>{\n        return(// Not add requestId as react key to ensure segment prefetch could result consistently if nothing changed\n        /*#__PURE__*/ _jsx(MetadataTree, {}));\n    }, serveStreamingMetadata);\n    const seedData = await createComponentTree({\n        ctx,\n        loaderTree: tree,\n        parentParams: {},\n        injectedCSS,\n        injectedJS,\n        injectedFontPreloadTags,\n        rootLayoutIncluded: false,\n        getViewportReady,\n        getMetadataReady,\n        missingSlots,\n        preloadCallbacks,\n        authInterrupts: ctx.renderOpts.experimental.authInterrupts,\n        StreamingMetadata,\n        StreamingMetadataOutlet\n    });\n    // When the `vary` response header is present with `Next-URL`, that means there's a chance\n    // it could respond differently if there's an interception route. We provide this information\n    // to `AppRouter` so that it can properly seed the prefetch cache with a prefix, if needed.\n    const varyHeader = ctx.res.getHeader('vary');\n    const couldBeIntercepted = typeof varyHeader === 'string' && varyHeader.includes(NEXT_URL);\n    const initialHead = /*#__PURE__*/ _jsxs(React.Fragment, {\n        children: [\n            /*#__PURE__*/ _jsx(NonIndex, {\n                pagePath: ctx.pagePath,\n                statusCode: ctx.res.statusCode,\n                isPossibleServerAction: ctx.isPossibleServerAction\n            }),\n            /*#__PURE__*/ _jsx(ViewportTree, {}, ctx.requestId),\n            /*#__PURE__*/ _jsx(StaticMetadata, {})\n        ]\n    }, flightDataPathHeadKey);\n    const globalErrorStyles = await getGlobalErrorStyles(tree, ctx);\n    // Assume the head we're rendering contains only partial data if PPR is\n    // enabled and this is a statically generated response. This is used by the\n    // client Segment Cache after a prefetch to determine if it can skip the\n    // second request to fill in the dynamic data.\n    //\n    // See similar comment in create-component-tree.tsx for more context.\n    const isPossiblyPartialHead = workStore.isStaticGeneration && ctx.renderOpts.experimental.isRoutePPREnabled === true;\n    return {\n        // See the comment above the `Preloads` component (below) for why this is part of the payload\n        P: /*#__PURE__*/ _jsx(Preloads, {\n            preloadCallbacks: preloadCallbacks\n        }),\n        b: ctx.sharedContext.buildId,\n        p: ctx.assetPrefix,\n        c: prepareInitialCanonicalUrl(url),\n        i: !!couldBeIntercepted,\n        f: [\n            [\n                initialTree,\n                seedData,\n                initialHead,\n                isPossiblyPartialHead\n            ]\n        ],\n        m: missingSlots,\n        G: [\n            GlobalError,\n            globalErrorStyles\n        ],\n        s: typeof ctx.renderOpts.postponed === 'string',\n        S: workStore.isStaticGeneration\n    };\n}\n/**\n * Preload calls (such as `ReactDOM.preloadStyle` and `ReactDOM.preloadFont`) need to be called during rendering\n * in order to create the appropriate preload tags in the DOM, otherwise they're a no-op. Since we invoke\n * renderToReadableStream with a function that returns component props rather than a component itself, we use\n * this component to \"render  \" the preload calls.\n */ function Preloads({ preloadCallbacks }) {\n    preloadCallbacks.forEach((preloadFn)=>preloadFn());\n    return null;\n}\n// This is the data necessary to render <AppRouter /> when an error state is triggered\nasync function getErrorRSCPayload(tree, ctx, ssrError, errorType) {\n    const { getDynamicParamFromSegment, query, appUsingSizeAdjustment, componentMod: { GlobalError, createMetadataComponents, MetadataBoundary, ViewportBoundary }, url, requestId, workStore } = ctx;\n    const serveStreamingMetadata = !!ctx.renderOpts.serveStreamingMetadata;\n    const { MetadataTree, ViewportTree } = createMetadataComponents({\n        tree,\n        parsedQuery: query,\n        // We create an untracked metadata context here because we can't postpone\n        // again during the error render.\n        metadataContext: createMetadataContext(url.pathname, ctx.renderOpts),\n        errorType,\n        getDynamicParamFromSegment,\n        appUsingSizeAdjustment,\n        workStore,\n        MetadataBoundary,\n        ViewportBoundary,\n        serveStreamingMetadata: serveStreamingMetadata\n    });\n    const { StreamingMetadata, StaticMetadata } = createDivergedMetadataComponents(()=>/*#__PURE__*/ _jsx(React.Fragment, {\n            children: /*#__PURE__*/ _jsx(MetadataTree, {}, requestId)\n        }, flightDataPathHeadKey), serveStreamingMetadata);\n    const initialHead = /*#__PURE__*/ _jsxs(React.Fragment, {\n        children: [\n            /*#__PURE__*/ _jsx(NonIndex, {\n                pagePath: ctx.pagePath,\n                statusCode: ctx.res.statusCode,\n                isPossibleServerAction: ctx.isPossibleServerAction\n            }),\n            /*#__PURE__*/ _jsx(ViewportTree, {}, requestId),\n            process.env.NODE_ENV === 'development' && /*#__PURE__*/ _jsx(\"meta\", {\n                name: \"next-error\",\n                content: \"not-found\"\n            }),\n            StreamingMetadata ? /*#__PURE__*/ _jsx(StreamingMetadata, {}) : null,\n            /*#__PURE__*/ _jsx(StaticMetadata, {})\n        ]\n    }, flightDataPathHeadKey);\n    const initialTree = createFlightRouterStateFromLoaderTree(tree, getDynamicParamFromSegment, query);\n    let err = undefined;\n    if (ssrError) {\n        err = isError(ssrError) ? ssrError : Object.defineProperty(new Error(ssrError + ''), \"__NEXT_ERROR_CODE\", {\n            value: \"E394\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    // For metadata notFound error there's no global not found boundary on top\n    // so we create a not found page with AppRouter\n    const seedData = [\n        initialTree[0],\n        /*#__PURE__*/ _jsxs(\"html\", {\n            id: \"__next_error__\",\n            children: [\n                /*#__PURE__*/ _jsxs(\"head\", {\n                    children: [\n                        StreamingMetadata ? /*#__PURE__*/ _jsx(StreamingMetadata, {}) : null,\n                        /*#__PURE__*/ _jsx(StaticMetadata, {})\n                    ]\n                }),\n                /*#__PURE__*/ _jsx(\"body\", {\n                    children: process.env.NODE_ENV !== 'production' && err ? /*#__PURE__*/ _jsx(\"template\", {\n                        \"data-next-error-message\": err.message,\n                        \"data-next-error-digest\": 'digest' in err ? err.digest : '',\n                        \"data-next-error-stack\": err.stack\n                    }) : null\n                })\n            ]\n        }),\n        {},\n        null,\n        false\n    ];\n    const globalErrorStyles = await getGlobalErrorStyles(tree, ctx);\n    const isPossiblyPartialHead = workStore.isStaticGeneration && ctx.renderOpts.experimental.isRoutePPREnabled === true;\n    return {\n        b: ctx.sharedContext.buildId,\n        p: ctx.assetPrefix,\n        c: prepareInitialCanonicalUrl(url),\n        m: undefined,\n        i: false,\n        f: [\n            [\n                initialTree,\n                seedData,\n                initialHead,\n                isPossiblyPartialHead\n            ]\n        ],\n        G: [\n            GlobalError,\n            globalErrorStyles\n        ],\n        s: typeof ctx.renderOpts.postponed === 'string',\n        S: workStore.isStaticGeneration\n    };\n}\n// This component must run in an SSR context. It will render the RSC root component\nfunction App({ reactServerStream, preinitScripts, clientReferenceManifest, nonce, ServerInsertedHTMLProvider, ServerInsertedMetadataProvider }) {\n    preinitScripts();\n    const response = React.use(useFlightStream(reactServerStream, clientReferenceManifest, nonce));\n    const initialState = createInitialRouterState({\n        // This is not used during hydration, so we don't have to pass a\n        // real timestamp.\n        navigatedAt: -1,\n        initialFlightData: response.f,\n        initialCanonicalUrlParts: response.c,\n        initialParallelRoutes: new Map(),\n        // location is not initialized in the SSR render\n        // it's set to window.location during hydration\n        location: null,\n        couldBeIntercepted: response.i,\n        postponed: response.s,\n        prerendered: response.S\n    });\n    const actionQueue = createMutableActionQueue(initialState, null);\n    const { HeadManagerContext } = require('../../shared/lib/head-manager-context.shared-runtime');\n    return /*#__PURE__*/ _jsx(HeadManagerContext.Provider, {\n        value: {\n            appDir: true,\n            nonce\n        },\n        children: /*#__PURE__*/ _jsx(ServerInsertedMetadataProvider, {\n            children: /*#__PURE__*/ _jsx(ServerInsertedHTMLProvider, {\n                children: /*#__PURE__*/ _jsx(AppRouter, {\n                    actionQueue: actionQueue,\n                    globalErrorComponentAndStyles: response.G,\n                    assetPrefix: response.p\n                })\n            })\n        })\n    });\n}\n// @TODO our error stream should be probably just use the same root component. But it was previously\n// different I don't want to figure out if that is meaningful at this time so just keeping the behavior\n// consistent for now.\nfunction ErrorApp({ reactServerStream, preinitScripts, clientReferenceManifest, ServerInsertedMetadataProvider, ServerInsertedHTMLProvider, nonce }) {\n    preinitScripts();\n    const response = React.use(useFlightStream(reactServerStream, clientReferenceManifest, nonce));\n    const initialState = createInitialRouterState({\n        // This is not used during hydration, so we don't have to pass a\n        // real timestamp.\n        navigatedAt: -1,\n        initialFlightData: response.f,\n        initialCanonicalUrlParts: response.c,\n        initialParallelRoutes: new Map(),\n        // location is not initialized in the SSR render\n        // it's set to window.location during hydration\n        location: null,\n        couldBeIntercepted: response.i,\n        postponed: response.s,\n        prerendered: response.S\n    });\n    const actionQueue = createMutableActionQueue(initialState, null);\n    return /*#__PURE__*/ _jsx(ServerInsertedMetadataProvider, {\n        children: /*#__PURE__*/ _jsx(ServerInsertedHTMLProvider, {\n            children: /*#__PURE__*/ _jsx(AppRouter, {\n                actionQueue: actionQueue,\n                globalErrorComponentAndStyles: response.G,\n                assetPrefix: response.p\n            })\n        })\n    });\n}\nasync function renderToHTMLOrFlightImpl(req, res, url, pagePath, query, renderOpts, workStore, parsedRequestHeaders, requestEndedState, postponedState, serverComponentsHmrCache, sharedContext) {\n    const isNotFoundPath = pagePath === '/404';\n    if (isNotFoundPath) {\n        res.statusCode = 404;\n    }\n    // A unique request timestamp used by development to ensure that it's\n    // consistent and won't change during this request. This is important to\n    // avoid that resources can be deduped by React Float if the same resource is\n    // rendered or preloaded multiple times: `<link href=\"a.css?v={Date.now()}\"/>`.\n    const requestTimestamp = Date.now();\n    const { serverActionsManifest, ComponentMod, nextFontManifest, serverActions, assetPrefix = '', enableTainting } = renderOpts;\n    // We need to expose the bundled `require` API globally for\n    // react-server-dom-webpack. This is a hack until we find a better way.\n    if (ComponentMod.__next_app__) {\n        const instrumented = wrapClientComponentLoader(ComponentMod);\n        // @ts-ignore\n        globalThis.__next_require__ = instrumented.require;\n        // When we are prerendering if there is a cacheSignal for tracking\n        // cache reads we wrap the loadChunk in this tracking. This allows us\n        // to treat chunk loading with similar semantics as cache reads to avoid\n        // async loading chunks from causing a prerender to abort too early.\n        const __next_chunk_load__ = (...args)=>{\n            const loadingChunk = instrumented.loadChunk(...args);\n            trackChunkLoading(loadingChunk);\n            return loadingChunk;\n        };\n        // @ts-expect-error\n        globalThis.__next_chunk_load__ = __next_chunk_load__;\n    }\n    if (process.env.NODE_ENV === 'development') {\n        // reset isr status at start of request\n        const { pathname } = new URL(req.url || '/', 'http://n');\n        renderOpts.setIsrStatus == null ? void 0 : renderOpts.setIsrStatus.call(renderOpts, pathname, null);\n    }\n    if (// The type check here ensures that `req` is correctly typed, and the\n    // environment variable check provides dead code elimination.\n    process.env.NEXT_RUNTIME !== 'edge' && isNodeNextRequest(req)) {\n        req.originalRequest.on('end', ()=>{\n            requestEndedState.ended = true;\n            if ('performance' in globalThis) {\n                const metrics = getClientComponentLoaderMetrics({\n                    reset: true\n                });\n                if (metrics) {\n                    getTracer().startSpan(NextNodeServerSpan.clientComponentLoading, {\n                        startTime: metrics.clientComponentLoadStart,\n                        attributes: {\n                            'next.clientComponentLoadCount': metrics.clientComponentLoadCount,\n                            'next.span_type': NextNodeServerSpan.clientComponentLoading\n                        }\n                    }).end(metrics.clientComponentLoadStart + metrics.clientComponentLoadTimes);\n                }\n            }\n        });\n    }\n    const metadata = {};\n    const appUsingSizeAdjustment = !!(nextFontManifest == null ? void 0 : nextFontManifest.appUsingSizeAdjust);\n    // TODO: fix this typescript\n    const clientReferenceManifest = renderOpts.clientReferenceManifest;\n    const serverModuleMap = createServerModuleMap({\n        serverActionsManifest\n    });\n    setReferenceManifestsSingleton({\n        page: workStore.page,\n        clientReferenceManifest,\n        serverActionsManifest,\n        serverModuleMap\n    });\n    ComponentMod.patchFetch();\n    // Pull out the hooks/references from the component.\n    const { tree: loaderTree, taintObjectReference } = ComponentMod;\n    if (enableTainting) {\n        taintObjectReference('Do not pass process.env to client components since it will leak sensitive data', process.env);\n    }\n    workStore.fetchMetrics = [];\n    metadata.fetchMetrics = workStore.fetchMetrics;\n    // don't modify original query object\n    query = {\n        ...query\n    };\n    stripInternalQueries(query);\n    const { flightRouterState, isPrefetchRequest, isRSCRequest, isDevWarmupRequest, isHmrRefresh, nonce } = parsedRequestHeaders;\n    /**\n   * The metadata items array created in next-app-loader with all relevant information\n   * that we need to resolve the final metadata.\n   */ let requestId;\n    if (process.env.NEXT_RUNTIME === 'edge') {\n        requestId = crypto.randomUUID();\n    } else {\n        requestId = require('next/dist/compiled/nanoid').nanoid();\n    }\n    /**\n   * Dynamic parameters. E.g. when you visit `/dashboard/vercel` which is rendered by `/dashboard/[slug]` the value will be {\"slug\": \"vercel\"}.\n   */ const params = renderOpts.params ?? {};\n    const { isStaticGeneration, fallbackRouteParams } = workStore;\n    const getDynamicParamFromSegment = makeGetDynamicParamFromSegment(params, pagePath, fallbackRouteParams);\n    const isPossibleActionRequest = getIsPossibleServerAction(req);\n    const implicitTags = await getImplicitTags(workStore.page, url, fallbackRouteParams);\n    const ctx = {\n        componentMod: ComponentMod,\n        url,\n        renderOpts,\n        workStore,\n        parsedRequestHeaders,\n        getDynamicParamFromSegment,\n        query,\n        isPrefetch: isPrefetchRequest,\n        isPossibleServerAction: isPossibleActionRequest,\n        requestTimestamp,\n        appUsingSizeAdjustment,\n        flightRouterState,\n        requestId,\n        pagePath,\n        clientReferenceManifest,\n        assetPrefix,\n        isNotFoundPath,\n        nonce,\n        res,\n        sharedContext,\n        implicitTags\n    };\n    getTracer().setRootSpanAttribute('next.route', pagePath);\n    if (isStaticGeneration) {\n        var _metadata_cacheControl;\n        // We're either building or revalidating. In either case we need to\n        // prerender our page rather than render it.\n        const prerenderToStreamWithTracing = getTracer().wrap(AppRenderSpan.getBodyResult, {\n            spanName: `prerender route (app) ${pagePath}`,\n            attributes: {\n                'next.route': pagePath\n            }\n        }, prerenderToStream);\n        const response = await prerenderToStreamWithTracing(req, res, ctx, metadata, workStore, loaderTree);\n        // If we're debugging partial prerendering, print all the dynamic API accesses\n        // that occurred during the render.\n        // @TODO move into renderToStream function\n        if (response.dynamicAccess && accessedDynamicData(response.dynamicAccess) && renderOpts.isDebugDynamicAccesses) {\n            warn('The following dynamic usage was detected:');\n            for (const access of formatDynamicAPIAccesses(response.dynamicAccess)){\n                warn(access);\n            }\n        }\n        // If we encountered any unexpected errors during build we fail the\n        // prerendering phase and the build.\n        if (workStore.invalidUsageError) {\n            throw workStore.invalidUsageError;\n        }\n        if (response.digestErrorsMap.size) {\n            const buildFailingError = response.digestErrorsMap.values().next().value;\n            if (buildFailingError) throw buildFailingError;\n        }\n        // Pick first userland SSR error, which is also not a RSC error.\n        if (response.ssrErrors.length) {\n            const buildFailingError = response.ssrErrors.find((err)=>isUserLandError(err));\n            if (buildFailingError) throw buildFailingError;\n        }\n        const options = {\n            metadata\n        };\n        // If we have pending revalidates, wait until they are all resolved.\n        if (workStore.pendingRevalidates || workStore.pendingRevalidateWrites || workStore.pendingRevalidatedTags) {\n            const pendingPromise = executeRevalidates(workStore).finally(()=>{\n                if (process.env.NEXT_PRIVATE_DEBUG_CACHE) {\n                    console.log('pending revalidates promise finished for:', url);\n                }\n            });\n            if (renderOpts.waitUntil) {\n                renderOpts.waitUntil(pendingPromise);\n            } else {\n                options.waitUntil = pendingPromise;\n            }\n        }\n        if (response.collectedTags) {\n            metadata.fetchTags = response.collectedTags.join(',');\n        }\n        // Let the client router know how long to keep the cached entry around.\n        const staleHeader = String(response.collectedStale);\n        res.setHeader(NEXT_ROUTER_STALE_TIME_HEADER, staleHeader);\n        metadata.headers ??= {};\n        metadata.headers[NEXT_ROUTER_STALE_TIME_HEADER] = staleHeader;\n        // If force static is specifically set to false, we should not revalidate\n        // the page.\n        if (workStore.forceStatic === false || response.collectedRevalidate === 0) {\n            metadata.cacheControl = {\n                revalidate: 0,\n                expire: undefined\n            };\n        } else {\n            // Copy the cache control value onto the render result metadata.\n            metadata.cacheControl = {\n                revalidate: response.collectedRevalidate >= INFINITE_CACHE ? false : response.collectedRevalidate,\n                expire: response.collectedExpire >= INFINITE_CACHE ? undefined : response.collectedExpire\n            };\n        }\n        // provide bailout info for debugging\n        if (((_metadata_cacheControl = metadata.cacheControl) == null ? void 0 : _metadata_cacheControl.revalidate) === 0) {\n            metadata.staticBailoutInfo = {\n                description: workStore.dynamicUsageDescription,\n                stack: workStore.dynamicUsageStack\n            };\n        }\n        return new RenderResult(await streamToString(response.stream), options);\n    } else {\n        // We're rendering dynamically\n        const renderResumeDataCache = renderOpts.devRenderResumeDataCache ?? (postponedState == null ? void 0 : postponedState.renderResumeDataCache);\n        const rootParams = getRootParams(loaderTree, ctx.getDynamicParamFromSegment);\n        const requestStore = createRequestStoreForRender(req, res, url, rootParams, implicitTags, renderOpts.onUpdateCookies, renderOpts.previewProps, isHmrRefresh, serverComponentsHmrCache, renderResumeDataCache);\n        if (process.env.NODE_ENV === 'development' && renderOpts.setIsrStatus && // The type check here ensures that `req` is correctly typed, and the\n        // environment variable check provides dead code elimination.\n        process.env.NEXT_RUNTIME !== 'edge' && isNodeNextRequest(req) && !isDevWarmupRequest) {\n            const setIsrStatus = renderOpts.setIsrStatus;\n            req.originalRequest.on('end', ()=>{\n                if (!requestStore.usedDynamic && !workStore.forceDynamic) {\n                    // only node can be ISR so we only need to update the status here\n                    const { pathname } = new URL(req.url || '/', 'http://n');\n                    setIsrStatus(pathname, true);\n                }\n            });\n        }\n        if (isDevWarmupRequest) {\n            return warmupDevRender(req, ctx);\n        } else if (isRSCRequest) {\n            return generateDynamicFlightRenderResult(req, ctx, requestStore);\n        }\n        const renderToStreamWithTracing = getTracer().wrap(AppRenderSpan.getBodyResult, {\n            spanName: `render route (app) ${pagePath}`,\n            attributes: {\n                'next.route': pagePath\n            }\n        }, renderToStream);\n        let formState = null;\n        if (isPossibleActionRequest) {\n            // For action requests, we handle them differently with a special render result.\n            const actionRequestResult = await handleAction({\n                req,\n                res,\n                ComponentMod,\n                serverModuleMap,\n                generateFlight: generateDynamicFlightRenderResult,\n                workStore,\n                requestStore,\n                serverActions,\n                ctx\n            });\n            if (actionRequestResult) {\n                if (actionRequestResult.type === 'not-found') {\n                    const notFoundLoaderTree = createNotFoundLoaderTree(loaderTree);\n                    res.statusCode = 404;\n                    const stream = await renderToStreamWithTracing(requestStore, req, res, ctx, workStore, notFoundLoaderTree, formState, postponedState);\n                    return new RenderResult(stream, {\n                        metadata\n                    });\n                } else if (actionRequestResult.type === 'done') {\n                    if (actionRequestResult.result) {\n                        actionRequestResult.result.assignMetadata(metadata);\n                        return actionRequestResult.result;\n                    } else if (actionRequestResult.formState) {\n                        formState = actionRequestResult.formState;\n                    }\n                }\n            }\n        }\n        const options = {\n            metadata\n        };\n        const stream = await renderToStreamWithTracing(requestStore, req, res, ctx, workStore, loaderTree, formState, postponedState);\n        if (workStore.invalidUsageError) {\n            throw workStore.invalidUsageError;\n        }\n        // If we have pending revalidates, wait until they are all resolved.\n        if (workStore.pendingRevalidates || workStore.pendingRevalidateWrites || workStore.pendingRevalidatedTags) {\n            const pendingPromise = executeRevalidates(workStore).finally(()=>{\n                if (process.env.NEXT_PRIVATE_DEBUG_CACHE) {\n                    console.log('pending revalidates promise finished for:', url);\n                }\n            });\n            if (renderOpts.waitUntil) {\n                renderOpts.waitUntil(pendingPromise);\n            } else {\n                options.waitUntil = pendingPromise;\n            }\n        }\n        // Create the new render result for the response.\n        return new RenderResult(stream, options);\n    }\n}\nexport const renderToHTMLOrFlight = (req, res, pagePath, query, fallbackRouteParams, renderOpts, serverComponentsHmrCache, isDevWarmup, sharedContext)=>{\n    var _renderOpts_previewProps;\n    if (!req.url) {\n        throw Object.defineProperty(new Error('Invalid URL'), \"__NEXT_ERROR_CODE\", {\n            value: \"E182\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    const url = parseRelativeUrl(req.url, undefined, false);\n    // We read these values from the request object as, in certain cases,\n    // base-server will strip them to opt into different rendering behavior.\n    const parsedRequestHeaders = parseRequestHeaders(req.headers, {\n        isDevWarmup,\n        isRoutePPREnabled: renderOpts.experimental.isRoutePPREnabled === true,\n        previewModeId: (_renderOpts_previewProps = renderOpts.previewProps) == null ? void 0 : _renderOpts_previewProps.previewModeId\n    });\n    const { isPrefetchRequest, previouslyRevalidatedTags } = parsedRequestHeaders;\n    const requestEndedState = {\n        ended: false\n    };\n    let postponedState = null;\n    // If provided, the postpone state should be parsed so it can be provided to\n    // React.\n    if (typeof renderOpts.postponed === 'string') {\n        if (fallbackRouteParams) {\n            throw Object.defineProperty(new InvariantError('postponed state should not be provided when fallback params are provided'), \"__NEXT_ERROR_CODE\", {\n                value: \"E592\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n        postponedState = parsePostponedState(renderOpts.postponed, renderOpts.params);\n    }\n    if ((postponedState == null ? void 0 : postponedState.renderResumeDataCache) && renderOpts.devRenderResumeDataCache) {\n        throw Object.defineProperty(new InvariantError('postponed state and dev warmup immutable resume data cache should not be provided together'), \"__NEXT_ERROR_CODE\", {\n            value: \"E589\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    const workStore = createWorkStore({\n        page: renderOpts.routeModule.definition.page,\n        fallbackRouteParams,\n        renderOpts,\n        requestEndedState,\n        // @TODO move to workUnitStore of type Request\n        isPrefetchRequest,\n        buildId: sharedContext.buildId,\n        previouslyRevalidatedTags\n    });\n    return workAsyncStorage.run(workStore, // The function to run\n    renderToHTMLOrFlightImpl, // all of it's args\n    req, res, url, pagePath, query, renderOpts, workStore, parsedRequestHeaders, requestEndedState, postponedState, serverComponentsHmrCache, sharedContext);\n};\nasync function renderToStream(requestStore, req, res, ctx, workStore, tree, formState, postponedState) {\n    const renderOpts = ctx.renderOpts;\n    const ComponentMod = renderOpts.ComponentMod;\n    // TODO: fix this typescript\n    const clientReferenceManifest = renderOpts.clientReferenceManifest;\n    const { ServerInsertedHTMLProvider, renderServerInsertedHTML } = createServerInsertedHTML();\n    const { ServerInsertedMetadataProvider, getServerInsertedMetadata } = createServerInsertedMetadata(ctx.nonce);\n    const tracingMetadata = getTracedMetadata(getTracer().getTracePropagationData(), renderOpts.experimental.clientTraceMetadata);\n    const polyfills = renderOpts.buildManifest.polyfillFiles.filter((polyfill)=>polyfill.endsWith('.js') && !polyfill.endsWith('.module.js')).map((polyfill)=>{\n        var _renderOpts_subresourceIntegrityManifest;\n        return {\n            src: `${ctx.assetPrefix}/_next/${polyfill}${getAssetQueryString(ctx, false)}`,\n            integrity: (_renderOpts_subresourceIntegrityManifest = renderOpts.subresourceIntegrityManifest) == null ? void 0 : _renderOpts_subresourceIntegrityManifest[polyfill],\n            crossOrigin: renderOpts.crossOrigin,\n            noModule: true,\n            nonce: ctx.nonce\n        };\n    });\n    const [preinitScripts, bootstrapScript] = getRequiredScripts(renderOpts.buildManifest, // Why is assetPrefix optional on renderOpts?\n    // @TODO make it default empty string on renderOpts and get rid of it from ctx\n    ctx.assetPrefix, renderOpts.crossOrigin, renderOpts.subresourceIntegrityManifest, getAssetQueryString(ctx, true), ctx.nonce, renderOpts.page);\n    const reactServerErrorsByDigest = new Map();\n    const silenceLogger = false;\n    function onHTMLRenderRSCError(err) {\n        return renderOpts.onInstrumentationRequestError == null ? void 0 : renderOpts.onInstrumentationRequestError.call(renderOpts, err, req, createErrorContext(ctx, 'react-server-components'));\n    }\n    const serverComponentsErrorHandler = createHTMLReactServerErrorHandler(!!renderOpts.dev, !!renderOpts.nextExport, reactServerErrorsByDigest, silenceLogger, onHTMLRenderRSCError);\n    function onHTMLRenderSSRError(err) {\n        return renderOpts.onInstrumentationRequestError == null ? void 0 : renderOpts.onInstrumentationRequestError.call(renderOpts, err, req, createErrorContext(ctx, 'server-rendering'));\n    }\n    const allCapturedErrors = [];\n    const htmlRendererErrorHandler = createHTMLErrorHandler(!!renderOpts.dev, !!renderOpts.nextExport, reactServerErrorsByDigest, allCapturedErrors, silenceLogger, onHTMLRenderSSRError);\n    let reactServerResult = null;\n    const setHeader = res.setHeader.bind(res);\n    const appendHeader = res.appendHeader.bind(res);\n    try {\n        if (// We only want this behavior when running `next dev`\n        renderOpts.dev && // We only want this behavior when we have React's dev builds available\n        process.env.NODE_ENV === 'development' && // Edge routes never prerender so we don't have a Prerender environment for anything in edge runtime\n        process.env.NEXT_RUNTIME !== 'edge' && // We only have a Prerender environment for projects opted into dynamicIO\n        renderOpts.experimental.dynamicIO) {\n            // This is a dynamic render. We don't do dynamic tracking because we're not prerendering\n            const RSCPayload = await workUnitAsyncStorage.run(requestStore, getRSCPayload, tree, ctx, res.statusCode === 404);\n            const [resolveValidation, validationOutlet] = createValidationOutlet();\n            RSCPayload._validation = validationOutlet;\n            const reactServerStream = await workUnitAsyncStorage.run(requestStore, scheduleInSequentialTasks, ()=>{\n                requestStore.prerenderPhase = true;\n                return ComponentMod.renderToReadableStream(RSCPayload, clientReferenceManifest.clientModules, {\n                    onError: serverComponentsErrorHandler,\n                    environmentName: ()=>requestStore.prerenderPhase === true ? 'Prerender' : 'Server',\n                    filterStackFrame (url, _functionName) {\n                        // The default implementation filters out <anonymous> stack frames\n                        // but we want to retain them because current Server Components and\n                        // built-in Components in parent stacks don't have source location.\n                        return !url.startsWith('node:') && !url.includes('node_modules');\n                    }\n                });\n            }, ()=>{\n                requestStore.prerenderPhase = false;\n            });\n            spawnDynamicValidationInDev(resolveValidation, tree, ctx, res.statusCode === 404, clientReferenceManifest, workStore.route, requestStore);\n            reactServerResult = new ReactServerResult(reactServerStream);\n        } else {\n            // This is a dynamic render. We don't do dynamic tracking because we're not prerendering\n            const RSCPayload = await workUnitAsyncStorage.run(requestStore, getRSCPayload, tree, ctx, res.statusCode === 404);\n            reactServerResult = new ReactServerResult(workUnitAsyncStorage.run(requestStore, ComponentMod.renderToReadableStream, RSCPayload, clientReferenceManifest.clientModules, {\n                onError: serverComponentsErrorHandler\n            }));\n        }\n        // React doesn't start rendering synchronously but we want the RSC render to have a chance to start\n        // before we begin SSR rendering because we want to capture any available preload headers so we tick\n        // one task before continuing\n        await waitAtLeastOneReactRenderTask();\n        // If provided, the postpone state should be parsed as JSON so it can be\n        // provided to React.\n        if (typeof renderOpts.postponed === 'string') {\n            if ((postponedState == null ? void 0 : postponedState.type) === DynamicState.DATA) {\n                // We have a complete HTML Document in the prerender but we need to\n                // still include the new server component render because it was not included\n                // in the static prelude.\n                const inlinedReactServerDataStream = createInlinedDataReadableStream(reactServerResult.tee(), ctx.nonce, formState);\n                return chainStreams(inlinedReactServerDataStream, createDocumentClosingStream());\n            } else if (postponedState) {\n                // We assume we have dynamic HTML requiring a resume render to complete\n                const postponed = getPostponedFromState(postponedState);\n                const resume = require('react-dom/server.edge').resume;\n                const htmlStream = await workUnitAsyncStorage.run(requestStore, resume, /*#__PURE__*/ _jsx(App, {\n                    reactServerStream: reactServerResult.tee(),\n                    preinitScripts: preinitScripts,\n                    clientReferenceManifest: clientReferenceManifest,\n                    ServerInsertedHTMLProvider: ServerInsertedHTMLProvider,\n                    ServerInsertedMetadataProvider: ServerInsertedMetadataProvider,\n                    nonce: ctx.nonce\n                }), postponed, {\n                    onError: htmlRendererErrorHandler,\n                    nonce: ctx.nonce\n                });\n                const getServerInsertedHTML = makeGetServerInsertedHTML({\n                    polyfills,\n                    renderServerInsertedHTML,\n                    serverCapturedErrors: allCapturedErrors,\n                    basePath: renderOpts.basePath,\n                    tracingMetadata: tracingMetadata\n                });\n                return await continueDynamicHTMLResume(htmlStream, {\n                    inlinedDataStream: createInlinedDataReadableStream(reactServerResult.consume(), ctx.nonce, formState),\n                    getServerInsertedHTML,\n                    getServerInsertedMetadata\n                });\n            }\n        }\n        // This is a regular dynamic render\n        const renderToReadableStream = require('react-dom/server.edge').renderToReadableStream;\n        const htmlStream = await workUnitAsyncStorage.run(requestStore, renderToReadableStream, /*#__PURE__*/ _jsx(App, {\n            reactServerStream: reactServerResult.tee(),\n            preinitScripts: preinitScripts,\n            clientReferenceManifest: clientReferenceManifest,\n            ServerInsertedHTMLProvider: ServerInsertedHTMLProvider,\n            ServerInsertedMetadataProvider: ServerInsertedMetadataProvider,\n            nonce: ctx.nonce\n        }), {\n            onError: htmlRendererErrorHandler,\n            nonce: ctx.nonce,\n            onHeaders: (headers)=>{\n                headers.forEach((value, key)=>{\n                    appendHeader(key, value);\n                });\n            },\n            maxHeadersLength: renderOpts.reactMaxHeadersLength,\n            bootstrapScripts: [\n                bootstrapScript\n            ],\n            formState\n        });\n        const getServerInsertedHTML = makeGetServerInsertedHTML({\n            polyfills,\n            renderServerInsertedHTML,\n            serverCapturedErrors: allCapturedErrors,\n            basePath: renderOpts.basePath,\n            tracingMetadata: tracingMetadata\n        });\n        /**\n     * Rules of Static & Dynamic HTML:\n     *\n     *    1.) We must generate static HTML unless the caller explicitly opts\n     *        in to dynamic HTML support.\n     *\n     *    2.) If dynamic HTML support is requested, we must honor that request\n     *        or throw an error. It is the sole responsibility of the caller to\n     *        ensure they aren't e.g. requesting dynamic HTML for an AMP page.\n     *\n     *   3.) If `shouldWaitOnAllReady` is true, which indicates we need to\n     *       resolve all suspenses and generate a full HTML. e.g. when it's a\n     *       html limited bot requests, we produce the full HTML content.\n     *\n     * These rules help ensure that other existing features like request caching,\n     * coalescing, and ISR continue working as intended.\n     */ const generateStaticHTML = renderOpts.supportsDynamicResponse !== true || !!renderOpts.shouldWaitOnAllReady;\n        const validateRootLayout = renderOpts.dev;\n        return await continueFizzStream(htmlStream, {\n            inlinedDataStream: createInlinedDataReadableStream(reactServerResult.consume(), ctx.nonce, formState),\n            isStaticGeneration: generateStaticHTML,\n            getServerInsertedHTML,\n            getServerInsertedMetadata,\n            validateRootLayout\n        });\n    } catch (err) {\n        if (isStaticGenBailoutError(err) || typeof err === 'object' && err !== null && 'message' in err && typeof err.message === 'string' && err.message.includes('https://nextjs.org/docs/advanced-features/static-html-export')) {\n            // Ensure that \"next dev\" prints the red error overlay\n            throw err;\n        }\n        // If a bailout made it to this point, it means it wasn't wrapped inside\n        // a suspense boundary.\n        const shouldBailoutToCSR = isBailoutToCSRError(err);\n        if (shouldBailoutToCSR) {\n            const stack = getStackWithoutErrorMessage(err);\n            error(`${err.reason} should be wrapped in a suspense boundary at page \"${ctx.pagePath}\". Read more: https://nextjs.org/docs/messages/missing-suspense-with-csr-bailout\\n${stack}`);\n            throw err;\n        }\n        let errorType;\n        if (isHTTPAccessFallbackError(err)) {\n            res.statusCode = getAccessFallbackHTTPStatus(err);\n            errorType = getAccessFallbackErrorTypeByStatus(res.statusCode);\n        } else if (isRedirectError(err)) {\n            errorType = 'redirect';\n            res.statusCode = getRedirectStatusCodeFromError(err);\n            const redirectUrl = addPathPrefix(getURLFromRedirectError(err), renderOpts.basePath);\n            // If there were mutable cookies set, we need to set them on the\n            // response.\n            const headers = new Headers();\n            if (appendMutableCookies(headers, requestStore.mutableCookies)) {\n                setHeader('set-cookie', Array.from(headers.values()));\n            }\n            setHeader('location', redirectUrl);\n        } else if (!shouldBailoutToCSR) {\n            res.statusCode = 500;\n        }\n        const [errorPreinitScripts, errorBootstrapScript] = getRequiredScripts(renderOpts.buildManifest, ctx.assetPrefix, renderOpts.crossOrigin, renderOpts.subresourceIntegrityManifest, getAssetQueryString(ctx, false), ctx.nonce, '/_not-found/page');\n        const errorRSCPayload = await workUnitAsyncStorage.run(requestStore, getErrorRSCPayload, tree, ctx, reactServerErrorsByDigest.has(err.digest) ? null : err, errorType);\n        const errorServerStream = workUnitAsyncStorage.run(requestStore, ComponentMod.renderToReadableStream, errorRSCPayload, clientReferenceManifest.clientModules, {\n            onError: serverComponentsErrorHandler\n        });\n        if (reactServerResult === null) {\n            // We errored when we did not have an RSC stream to read from. This is not just a render\n            // error, we need to throw early\n            throw err;\n        }\n        try {\n            const fizzStream = await workUnitAsyncStorage.run(requestStore, renderToInitialFizzStream, {\n                ReactDOMServer: require('react-dom/server.edge'),\n                element: /*#__PURE__*/ _jsx(ErrorApp, {\n                    reactServerStream: errorServerStream,\n                    ServerInsertedMetadataProvider: ServerInsertedMetadataProvider,\n                    ServerInsertedHTMLProvider: ServerInsertedHTMLProvider,\n                    preinitScripts: errorPreinitScripts,\n                    clientReferenceManifest: clientReferenceManifest,\n                    nonce: ctx.nonce\n                }),\n                streamOptions: {\n                    nonce: ctx.nonce,\n                    // Include hydration scripts in the HTML\n                    bootstrapScripts: [\n                        errorBootstrapScript\n                    ],\n                    formState\n                }\n            });\n            /**\n       * Rules of Static & Dynamic HTML:\n       *\n       *    1.) We must generate static HTML unless the caller explicitly opts\n       *        in to dynamic HTML support.\n       *\n       *    2.) If dynamic HTML support is requested, we must honor that request\n       *        or throw an error. It is the sole responsibility of the caller to\n       *        ensure they aren't e.g. requesting dynamic HTML for an AMP page.\n       *    3.) If `shouldWaitOnAllReady` is true, which indicates we need to\n       *        resolve all suspenses and generate a full HTML. e.g. when it's a\n       *        html limited bot requests, we produce the full HTML content.\n       *\n       * These rules help ensure that other existing features like request caching,\n       * coalescing, and ISR continue working as intended.\n       */ const generateStaticHTML = renderOpts.supportsDynamicResponse !== true || !!renderOpts.shouldWaitOnAllReady;\n            const validateRootLayout = renderOpts.dev;\n            return await continueFizzStream(fizzStream, {\n                inlinedDataStream: createInlinedDataReadableStream(// This is intentionally using the readable datastream from the\n                // main render rather than the flight data from the error page\n                // render\n                reactServerResult.consume(), ctx.nonce, formState),\n                isStaticGeneration: generateStaticHTML,\n                getServerInsertedHTML: makeGetServerInsertedHTML({\n                    polyfills,\n                    renderServerInsertedHTML,\n                    serverCapturedErrors: [],\n                    basePath: renderOpts.basePath,\n                    tracingMetadata: tracingMetadata\n                }),\n                getServerInsertedMetadata,\n                validateRootLayout\n            });\n        } catch (finalErr) {\n            if (process.env.NODE_ENV === 'development' && isHTTPAccessFallbackError(finalErr)) {\n                const { bailOnRootNotFound } = require('../../client/components/dev-root-http-access-fallback-boundary');\n                bailOnRootNotFound();\n            }\n            throw finalErr;\n        }\n    }\n}\nfunction createValidationOutlet() {\n    let resolveValidation;\n    let outlet = new Promise((resolve)=>{\n        resolveValidation = resolve;\n    });\n    return [\n        resolveValidation,\n        outlet\n    ];\n}\nasync function spawnDynamicValidationInDev(resolveValidation, tree, ctx, isNotFound, clientReferenceManifest, route, requestStore) {\n    var _requestStore_cookies_get;\n    const { componentMod: ComponentMod, implicitTags } = ctx;\n    const rootParams = getRootParams(ComponentMod.tree, ctx.getDynamicParamFromSegment);\n    const hmrRefreshHash = (_requestStore_cookies_get = requestStore.cookies.get(NEXT_HMR_REFRESH_HASH_COOKIE)) == null ? void 0 : _requestStore_cookies_get.value;\n    // Prerender controller represents the lifetime of the prerender.\n    // It will be aborted when a Task is complete or a synchronously aborting\n    // API is called. Notably during cache-filling renders this does not actually\n    // terminate the render itself which will continue until all caches are filled\n    const initialServerPrerenderController = new AbortController();\n    // This controller represents the lifetime of the React render call. Notably\n    // during the cache-filling render it is different from the prerender controller\n    // because we don't want to end the react render until all caches are filled.\n    const initialServerRenderController = new AbortController();\n    const cacheSignal = new CacheSignal();\n    const prerenderResumeDataCache = createPrerenderResumeDataCache();\n    const initialServerPrerenderStore = {\n        type: 'prerender',\n        phase: 'render',\n        rootParams,\n        implicitTags,\n        renderSignal: initialServerRenderController.signal,\n        controller: initialServerPrerenderController,\n        cacheSignal,\n        dynamicTracking: null,\n        revalidate: INFINITE_CACHE,\n        expire: INFINITE_CACHE,\n        stale: INFINITE_CACHE,\n        tags: [],\n        prerenderResumeDataCache,\n        hmrRefreshHash\n    };\n    const initialClientController = new AbortController();\n    const initialClientPrerenderStore = {\n        type: 'prerender',\n        phase: 'render',\n        rootParams,\n        implicitTags,\n        renderSignal: initialClientController.signal,\n        controller: initialClientController,\n        cacheSignal,\n        dynamicTracking: null,\n        revalidate: INFINITE_CACHE,\n        expire: INFINITE_CACHE,\n        stale: INFINITE_CACHE,\n        tags: [],\n        prerenderResumeDataCache,\n        hmrRefreshHash\n    };\n    // We're not going to use the result of this render because the only time it could be used\n    // is if it completes in a microtask and that's likely very rare for any non-trivial app\n    const firstAttemptRSCPayload = await workUnitAsyncStorage.run(initialServerPrerenderStore, getRSCPayload, tree, ctx, isNotFound);\n    let initialServerStream;\n    try {\n        initialServerStream = workUnitAsyncStorage.run(initialServerPrerenderStore, ComponentMod.renderToReadableStream, firstAttemptRSCPayload, clientReferenceManifest.clientModules, {\n            onError: (err)=>{\n                const digest = getDigestForWellKnownError(err);\n                if (digest) {\n                    return digest;\n                }\n                if (initialServerPrerenderController.signal.aborted || initialServerRenderController.signal.aborted) {\n                    // The render aborted before this error was handled which indicates\n                    // the error is caused by unfinished components within the render\n                    return;\n                } else if (process.env.NEXT_DEBUG_BUILD || process.env.__NEXT_VERBOSE_LOGGING) {\n                    printDebugThrownValueForProspectiveRender(err, route);\n                }\n            },\n            signal: initialServerRenderController.signal\n        });\n    } catch (err) {\n        if (initialServerPrerenderController.signal.aborted || initialServerRenderController.signal.aborted) {\n        // These are expected errors that might error the prerender. we ignore them.\n        } else if (process.env.NEXT_DEBUG_BUILD || process.env.__NEXT_VERBOSE_LOGGING) {\n            // We don't normally log these errors because we are going to retry anyway but\n            // it can be useful for debugging Next.js itself to get visibility here when needed\n            printDebugThrownValueForProspectiveRender(err, route);\n        }\n    }\n    const nonce = '1';\n    const { ServerInsertedHTMLProvider } = createServerInsertedHTML();\n    const { ServerInsertedMetadataProvider } = createServerInsertedMetadata(nonce);\n    if (initialServerStream) {\n        const [warmupStream, renderStream] = initialServerStream.tee();\n        initialServerStream = null;\n        // Before we attempt the SSR initial render we need to ensure all client modules\n        // are already loaded.\n        await warmFlightResponse(warmupStream, clientReferenceManifest);\n        const prerender = require('react-dom/static.edge').prerender;\n        const pendingInitialClientResult = workUnitAsyncStorage.run(initialClientPrerenderStore, prerender, /*#__PURE__*/ _jsx(App, {\n            reactServerStream: renderStream,\n            preinitScripts: ()=>{},\n            clientReferenceManifest: clientReferenceManifest,\n            ServerInsertedHTMLProvider: ServerInsertedHTMLProvider,\n            ServerInsertedMetadataProvider: ServerInsertedMetadataProvider,\n            nonce: nonce\n        }), {\n            signal: initialClientController.signal,\n            onError: (err)=>{\n                const digest = getDigestForWellKnownError(err);\n                if (digest) {\n                    return digest;\n                }\n                if (initialClientController.signal.aborted) {\n                // These are expected errors that might error the prerender. we ignore them.\n                } else if (process.env.NEXT_DEBUG_BUILD || process.env.__NEXT_VERBOSE_LOGGING) {\n                    // We don't normally log these errors because we are going to retry anyway but\n                    // it can be useful for debugging Next.js itself to get visibility here when needed\n                    printDebugThrownValueForProspectiveRender(err, route);\n                }\n            }\n        });\n        pendingInitialClientResult.catch((err)=>{\n            if (initialClientController.signal.aborted) {\n            // We aborted the render normally and can ignore this error\n            } else {\n                // We're going to retry to so we normally would suppress this error but\n                // when verbose logging is on we print it\n                if (process.env.__NEXT_VERBOSE_LOGGING) {\n                    printDebugThrownValueForProspectiveRender(err, route);\n                }\n            }\n        });\n    }\n    await cacheSignal.cacheReady();\n    // It is important that we abort the SSR render first to avoid\n    // connection closed errors from having an incomplete RSC stream\n    initialClientController.abort();\n    initialServerRenderController.abort();\n    initialServerPrerenderController.abort();\n    // We've now filled caches and triggered any inadvertent sync bailouts\n    // due to lazy module initialization. We can restart our render to capture results\n    const finalServerController = new AbortController();\n    const serverDynamicTracking = createDynamicTrackingState(false);\n    const finalServerPrerenderStore = {\n        type: 'prerender',\n        phase: 'render',\n        rootParams,\n        implicitTags,\n        renderSignal: finalServerController.signal,\n        controller: finalServerController,\n        // During the final prerender we don't need to track cache access so we omit the signal\n        cacheSignal: null,\n        dynamicTracking: serverDynamicTracking,\n        revalidate: INFINITE_CACHE,\n        expire: INFINITE_CACHE,\n        stale: INFINITE_CACHE,\n        tags: [],\n        prerenderResumeDataCache,\n        hmrRefreshHash\n    };\n    const finalClientController = new AbortController();\n    const clientDynamicTracking = createDynamicTrackingState(false);\n    const dynamicValidation = createDynamicValidationState();\n    const finalClientPrerenderStore = {\n        type: 'prerender',\n        phase: 'render',\n        rootParams,\n        implicitTags,\n        renderSignal: finalClientController.signal,\n        controller: finalClientController,\n        // During the final prerender we don't need to track cache access so we omit the signal\n        cacheSignal: null,\n        dynamicTracking: clientDynamicTracking,\n        revalidate: INFINITE_CACHE,\n        expire: INFINITE_CACHE,\n        stale: INFINITE_CACHE,\n        tags: [],\n        prerenderResumeDataCache,\n        hmrRefreshHash\n    };\n    const finalServerPayload = await workUnitAsyncStorage.run(finalServerPrerenderStore, getRSCPayload, tree, ctx, isNotFound);\n    const serverPrerenderStreamResult = await prerenderServerWithPhases(finalServerController.signal, ()=>workUnitAsyncStorage.run(finalServerPrerenderStore, ComponentMod.renderToReadableStream, finalServerPayload, clientReferenceManifest.clientModules, {\n            onError: (err)=>{\n                if (isUseCacheTimeoutError(err)) {\n                    return err.digest;\n                }\n                if (finalServerController.signal.aborted && isPrerenderInterruptedError(err)) {\n                    return err.digest;\n                }\n                return getDigestForWellKnownError(err);\n            },\n            signal: finalServerController.signal\n        }), ()=>{\n        finalServerController.abort();\n    });\n    let rootDidError = false;\n    const serverPhasedStream = serverPrerenderStreamResult.asPhasedStream();\n    try {\n        const prerender = require('react-dom/static.edge').prerender;\n        await prerenderClientWithPhases(()=>workUnitAsyncStorage.run(finalClientPrerenderStore, prerender, /*#__PURE__*/ _jsx(App, {\n                reactServerStream: serverPhasedStream,\n                preinitScripts: ()=>{},\n                clientReferenceManifest: clientReferenceManifest,\n                ServerInsertedHTMLProvider: ServerInsertedHTMLProvider,\n                ServerInsertedMetadataProvider: ServerInsertedMetadataProvider,\n                nonce: ctx.nonce\n            }), {\n                signal: finalClientController.signal,\n                onError: (err, errorInfo)=>{\n                    if (isUseCacheTimeoutError(err)) {\n                        dynamicValidation.dynamicErrors.push(err);\n                        return;\n                    }\n                    if (isPrerenderInterruptedError(err) || finalClientController.signal.aborted) {\n                        if (!rootDidError) {\n                            // If the root errored before we observe this error then it wasn't caused by something dynamic.\n                            // If the root did not error or is erroring because of a sync dynamic API or a prerender interrupt error\n                            // then we are a dynamic route.\n                            requestStore.usedDynamic = true;\n                        }\n                        const componentStack = errorInfo.componentStack;\n                        if (typeof componentStack === 'string') {\n                            trackAllowedDynamicAccess(route, componentStack, dynamicValidation, serverDynamicTracking, clientDynamicTracking);\n                        }\n                        return;\n                    }\n                    return getDigestForWellKnownError(err);\n                }\n            }), ()=>{\n            finalClientController.abort();\n            serverPhasedStream.assertExhausted();\n        });\n    } catch (err) {\n        rootDidError = true;\n        if (isPrerenderInterruptedError(err) || finalClientController.signal.aborted) {\n        // we don't have a root because the abort errored in the root. We can just ignore this error\n        } else {\n        // If an error is thrown in the root before prerendering is aborted, we\n        // don't want to rethrow it here, otherwise this would lead to a hanging\n        // response and unhandled rejection. We also don't want to log it, because\n        // it's most likely already logged as part of the normal render. So we\n        // just fall through here, to make sure `resolveValidation` is called.\n        }\n    }\n    function LogDynamicValidation() {\n        try {\n            throwIfDisallowedDynamic(route, dynamicValidation, serverDynamicTracking, clientDynamicTracking);\n        } catch  {}\n        return null;\n    }\n    resolveValidation(/*#__PURE__*/ _jsx(LogDynamicValidation, {}));\n}\n/**\n * Determines whether we should generate static flight data.\n */ function shouldGenerateStaticFlightData(workStore) {\n    const { isStaticGeneration } = workStore;\n    if (!isStaticGeneration) return false;\n    return true;\n}\nasync function prerenderToStream(req, res, ctx, metadata, workStore, tree) {\n    // When prerendering formState is always null. We still include it\n    // because some shared APIs expect a formState value and this is slightly\n    // more explicit than making it an optional function argument\n    const formState = null;\n    const { assetPrefix, getDynamicParamFromSegment, implicitTags, nonce, pagePath, renderOpts } = ctx;\n    const rootParams = getRootParams(tree, getDynamicParamFromSegment);\n    const ComponentMod = renderOpts.ComponentMod;\n    // TODO: fix this typescript\n    const clientReferenceManifest = renderOpts.clientReferenceManifest;\n    const fallbackRouteParams = workStore.fallbackRouteParams;\n    const { ServerInsertedHTMLProvider, renderServerInsertedHTML } = createServerInsertedHTML();\n    const { ServerInsertedMetadataProvider, getServerInsertedMetadata } = createServerInsertedMetadata(nonce);\n    const tracingMetadata = getTracedMetadata(getTracer().getTracePropagationData(), renderOpts.experimental.clientTraceMetadata);\n    const polyfills = renderOpts.buildManifest.polyfillFiles.filter((polyfill)=>polyfill.endsWith('.js') && !polyfill.endsWith('.module.js')).map((polyfill)=>{\n        var _renderOpts_subresourceIntegrityManifest;\n        return {\n            src: `${assetPrefix}/_next/${polyfill}${getAssetQueryString(ctx, false)}`,\n            integrity: (_renderOpts_subresourceIntegrityManifest = renderOpts.subresourceIntegrityManifest) == null ? void 0 : _renderOpts_subresourceIntegrityManifest[polyfill],\n            crossOrigin: renderOpts.crossOrigin,\n            noModule: true,\n            nonce: nonce\n        };\n    });\n    const [preinitScripts, bootstrapScript] = getRequiredScripts(renderOpts.buildManifest, // Why is assetPrefix optional on renderOpts?\n    // @TODO make it default empty string on renderOpts and get rid of it from ctx\n    assetPrefix, renderOpts.crossOrigin, renderOpts.subresourceIntegrityManifest, getAssetQueryString(ctx, true), nonce, renderOpts.page);\n    const reactServerErrorsByDigest = new Map();\n    // We don't report errors during prerendering through our instrumentation hooks\n    const silenceLogger = !!renderOpts.experimental.isRoutePPREnabled;\n    function onHTMLRenderRSCError(err) {\n        return renderOpts.onInstrumentationRequestError == null ? void 0 : renderOpts.onInstrumentationRequestError.call(renderOpts, err, req, createErrorContext(ctx, 'react-server-components'));\n    }\n    const serverComponentsErrorHandler = createHTMLReactServerErrorHandler(!!renderOpts.dev, !!renderOpts.nextExport, reactServerErrorsByDigest, silenceLogger, onHTMLRenderRSCError);\n    function onHTMLRenderSSRError(err) {\n        return renderOpts.onInstrumentationRequestError == null ? void 0 : renderOpts.onInstrumentationRequestError.call(renderOpts, err, req, createErrorContext(ctx, 'server-rendering'));\n    }\n    const allCapturedErrors = [];\n    const htmlRendererErrorHandler = createHTMLErrorHandler(!!renderOpts.dev, !!renderOpts.nextExport, reactServerErrorsByDigest, allCapturedErrors, silenceLogger, onHTMLRenderSSRError);\n    let reactServerPrerenderResult = null;\n    const setMetadataHeader = (name)=>{\n        metadata.headers ??= {};\n        metadata.headers[name] = res.getHeader(name);\n    };\n    const setHeader = (name, value)=>{\n        res.setHeader(name, value);\n        setMetadataHeader(name);\n        return res;\n    };\n    const appendHeader = (name, value)=>{\n        if (Array.isArray(value)) {\n            value.forEach((item)=>{\n                res.appendHeader(name, item);\n            });\n        } else {\n            res.appendHeader(name, value);\n        }\n        setMetadataHeader(name);\n    };\n    let prerenderStore = null;\n    try {\n        if (renderOpts.experimental.dynamicIO) {\n            if (renderOpts.experimental.isRoutePPREnabled) {\n                /**\n         * dynamicIO with PPR\n         *\n         * The general approach is to render the RSC stream first allowing any cache reads to resolve.\n         * Once we have settled all cache reads we restart the render and abort after a single Task.\n         *\n         * Unlike with the non PPR case we can't synchronously abort the render when a dynamic API is used\n         * during the initial render because we need to ensure all caches can be filled as part of the initial Task\n         * and a synchronous abort might prevent us from filling all caches.\n         *\n         * Once the render is complete we allow the SSR render to finish and use a combination of the postponed state\n         * and the reactServerIsDynamic value to determine how to treat the resulting render\n         */ // Prerender controller represents the lifetime of the prerender.\n                // It will be aborted when a Task is complete or a synchronously aborting\n                // API is called. Notably during cache-filling renders this does not actually\n                // terminate the render itself which will continue until all caches are filled\n                const initialServerPrerenderController = new AbortController();\n                // This controller represents the lifetime of the React render call. Notably\n                // during the cache-filling render it is different from the prerender controller\n                // because we don't want to end the react render until all caches are filled.\n                const initialServerRenderController = new AbortController();\n                // The cacheSignal helps us track whether caches are still filling or we are ready\n                // to cut the render off.\n                const cacheSignal = new CacheSignal();\n                // The resume data cache here should use a fresh instance as it's\n                // performing a fresh prerender. If we get to implementing the\n                // prerendering of an already prerendered page, we should use the passed\n                // resume data cache instead.\n                const prerenderResumeDataCache = createPrerenderResumeDataCache();\n                const initialServerPrerenderStore = prerenderStore = {\n                    type: 'prerender',\n                    phase: 'render',\n                    rootParams,\n                    implicitTags,\n                    renderSignal: initialServerRenderController.signal,\n                    controller: initialServerPrerenderController,\n                    cacheSignal,\n                    dynamicTracking: null,\n                    revalidate: INFINITE_CACHE,\n                    expire: INFINITE_CACHE,\n                    stale: INFINITE_CACHE,\n                    tags: [\n                        ...implicitTags.tags\n                    ],\n                    prerenderResumeDataCache,\n                    hmrRefreshHash: undefined\n                };\n                // We're not going to use the result of this render because the only time it could be used\n                // is if it completes in a microtask and that's likely very rare for any non-trivial app\n                const initialServerPayload = await workUnitAsyncStorage.run(initialServerPrerenderStore, getRSCPayload, tree, ctx, res.statusCode === 404);\n                const pendingInitialServerResult = workUnitAsyncStorage.run(initialServerPrerenderStore, ComponentMod.prerender, initialServerPayload, clientReferenceManifest.clientModules, {\n                    onError: (err)=>{\n                        const digest = getDigestForWellKnownError(err);\n                        if (digest) {\n                            return digest;\n                        }\n                        if (initialServerPrerenderController.signal.aborted) {\n                            // The render aborted before this error was handled which indicates\n                            // the error is caused by unfinished components within the render\n                            return;\n                        } else if (process.env.NEXT_DEBUG_BUILD || process.env.__NEXT_VERBOSE_LOGGING) {\n                            printDebugThrownValueForProspectiveRender(err, workStore.route);\n                        }\n                    },\n                    // we don't care to track postpones during the prospective render because we need\n                    // to always do a final render anyway\n                    onPostpone: undefined,\n                    // We don't want to stop rendering until the cacheSignal is complete so we pass\n                    // a different signal to this render call than is used by dynamic APIs to signify\n                    // transitioning out of the prerender environment\n                    signal: initialServerRenderController.signal\n                });\n                await cacheSignal.cacheReady();\n                initialServerRenderController.abort();\n                initialServerPrerenderController.abort();\n                let initialServerResult;\n                try {\n                    initialServerResult = await createReactServerPrerenderResult(pendingInitialServerResult);\n                } catch (err) {\n                    if (initialServerRenderController.signal.aborted || initialServerPrerenderController.signal.aborted) {\n                    // These are expected errors that might error the prerender. we ignore them.\n                    } else if (process.env.NEXT_DEBUG_BUILD || process.env.__NEXT_VERBOSE_LOGGING) {\n                        // We don't normally log these errors because we are going to retry anyway but\n                        // it can be useful for debugging Next.js itself to get visibility here when needed\n                        printDebugThrownValueForProspectiveRender(err, workStore.route);\n                    }\n                }\n                if (initialServerResult) {\n                    // Before we attempt the SSR initial render we need to ensure all client modules\n                    // are already loaded.\n                    await warmFlightResponse(initialServerResult.asStream(), clientReferenceManifest);\n                    const initialClientController = new AbortController();\n                    const initialClientPrerenderStore = {\n                        type: 'prerender',\n                        phase: 'render',\n                        rootParams,\n                        implicitTags,\n                        renderSignal: initialClientController.signal,\n                        controller: initialClientController,\n                        cacheSignal: null,\n                        dynamicTracking: null,\n                        revalidate: INFINITE_CACHE,\n                        expire: INFINITE_CACHE,\n                        stale: INFINITE_CACHE,\n                        tags: [\n                            ...implicitTags.tags\n                        ],\n                        prerenderResumeDataCache,\n                        hmrRefreshHash: undefined\n                    };\n                    const prerender = require('react-dom/static.edge').prerender;\n                    await prerenderAndAbortInSequentialTasks(()=>workUnitAsyncStorage.run(initialClientPrerenderStore, prerender, /*#__PURE__*/ _jsx(App, {\n                            reactServerStream: initialServerResult.asUnclosingStream(),\n                            preinitScripts: preinitScripts,\n                            clientReferenceManifest: clientReferenceManifest,\n                            ServerInsertedHTMLProvider: ServerInsertedHTMLProvider,\n                            ServerInsertedMetadataProvider: ServerInsertedMetadataProvider,\n                            nonce: nonce\n                        }), {\n                            signal: initialClientController.signal,\n                            onError: (err)=>{\n                                const digest = getDigestForWellKnownError(err);\n                                if (digest) {\n                                    return digest;\n                                }\n                                if (initialClientController.signal.aborted) {\n                                // These are expected errors that might error the prerender. we ignore them.\n                                } else if (process.env.NEXT_DEBUG_BUILD || process.env.__NEXT_VERBOSE_LOGGING) {\n                                    // We don't normally log these errors because we are going to retry anyway but\n                                    // it can be useful for debugging Next.js itself to get visibility here when needed\n                                    printDebugThrownValueForProspectiveRender(err, workStore.route);\n                                }\n                            },\n                            bootstrapScripts: [\n                                bootstrapScript\n                            ]\n                        }), ()=>{\n                        initialClientController.abort();\n                    }).catch((err)=>{\n                        if (initialServerRenderController.signal.aborted || isPrerenderInterruptedError(err)) {\n                        // These are expected errors that might error the prerender. we ignore them.\n                        } else if (process.env.NEXT_DEBUG_BUILD || process.env.__NEXT_VERBOSE_LOGGING) {\n                            // We don't normally log these errors because we are going to retry anyway but\n                            // it can be useful for debugging Next.js itself to get visibility here when needed\n                            printDebugThrownValueForProspectiveRender(err, workStore.route);\n                        }\n                    });\n                }\n                let serverIsDynamic = false;\n                const finalServerController = new AbortController();\n                const serverDynamicTracking = createDynamicTrackingState(renderOpts.isDebugDynamicAccesses);\n                const finalRenderPrerenderStore = prerenderStore = {\n                    type: 'prerender',\n                    phase: 'render',\n                    rootParams,\n                    implicitTags,\n                    renderSignal: finalServerController.signal,\n                    controller: finalServerController,\n                    // During the final prerender we don't need to track cache access so we omit the signal\n                    cacheSignal: null,\n                    dynamicTracking: serverDynamicTracking,\n                    revalidate: INFINITE_CACHE,\n                    expire: INFINITE_CACHE,\n                    stale: INFINITE_CACHE,\n                    tags: [\n                        ...implicitTags.tags\n                    ],\n                    prerenderResumeDataCache,\n                    hmrRefreshHash: undefined\n                };\n                const finalAttemptRSCPayload = await workUnitAsyncStorage.run(finalRenderPrerenderStore, getRSCPayload, tree, ctx, res.statusCode === 404);\n                let prerenderIsPending = true;\n                const reactServerResult = reactServerPrerenderResult = await createReactServerPrerenderResult(prerenderAndAbortInSequentialTasks(async ()=>{\n                    const prerenderResult = await workUnitAsyncStorage.run(// The store to scope\n                    finalRenderPrerenderStore, // The function to run\n                    ComponentMod.prerender, // ... the arguments for the function to run\n                    finalAttemptRSCPayload, clientReferenceManifest.clientModules, {\n                        onError: (err)=>{\n                            return serverComponentsErrorHandler(err);\n                        },\n                        signal: finalServerController.signal\n                    });\n                    prerenderIsPending = false;\n                    return prerenderResult;\n                }, ()=>{\n                    if (finalServerController.signal.aborted) {\n                        // If the server controller is already aborted we must have called something\n                        // that required aborting the prerender synchronously such as with new Date()\n                        serverIsDynamic = true;\n                        return;\n                    }\n                    if (prerenderIsPending) {\n                        // If prerenderIsPending then we have blocked for longer than a Task and we assume\n                        // there is something unfinished.\n                        serverIsDynamic = true;\n                    }\n                    finalServerController.abort();\n                }));\n                const clientDynamicTracking = createDynamicTrackingState(renderOpts.isDebugDynamicAccesses);\n                const finalClientController = new AbortController();\n                const finalClientPrerenderStore = {\n                    type: 'prerender',\n                    phase: 'render',\n                    rootParams,\n                    implicitTags,\n                    renderSignal: finalClientController.signal,\n                    controller: finalClientController,\n                    // For HTML Generation we don't need to track cache reads (RSC only)\n                    cacheSignal: null,\n                    dynamicTracking: clientDynamicTracking,\n                    revalidate: INFINITE_CACHE,\n                    expire: INFINITE_CACHE,\n                    stale: INFINITE_CACHE,\n                    tags: [\n                        ...implicitTags.tags\n                    ],\n                    prerenderResumeDataCache,\n                    hmrRefreshHash: undefined\n                };\n                let clientIsDynamic = false;\n                let dynamicValidation = createDynamicValidationState();\n                const prerender = require('react-dom/static.edge').prerender;\n                let { prelude, postponed } = await prerenderAndAbortInSequentialTasks(()=>workUnitAsyncStorage.run(finalClientPrerenderStore, prerender, /*#__PURE__*/ _jsx(App, {\n                        reactServerStream: reactServerResult.asUnclosingStream(),\n                        preinitScripts: preinitScripts,\n                        clientReferenceManifest: clientReferenceManifest,\n                        ServerInsertedHTMLProvider: ServerInsertedHTMLProvider,\n                        ServerInsertedMetadataProvider: ServerInsertedMetadataProvider,\n                        nonce: nonce\n                    }), {\n                        signal: finalClientController.signal,\n                        onError: (err, errorInfo)=>{\n                            if (isPrerenderInterruptedError(err) || finalClientController.signal.aborted) {\n                                clientIsDynamic = true;\n                                const componentStack = errorInfo.componentStack;\n                                if (typeof componentStack === 'string') {\n                                    trackAllowedDynamicAccess(workStore.route, componentStack, dynamicValidation, serverDynamicTracking, clientDynamicTracking);\n                                }\n                                return;\n                            }\n                            return htmlRendererErrorHandler(err, errorInfo);\n                        },\n                        onHeaders: (headers)=>{\n                            headers.forEach((value, key)=>{\n                                appendHeader(key, value);\n                            });\n                        },\n                        maxHeadersLength: renderOpts.reactMaxHeadersLength,\n                        bootstrapScripts: [\n                            bootstrapScript\n                        ]\n                    }), ()=>{\n                    finalClientController.abort();\n                });\n                throwIfDisallowedDynamic(workStore.route, dynamicValidation, serverDynamicTracking, clientDynamicTracking);\n                const getServerInsertedHTML = makeGetServerInsertedHTML({\n                    polyfills,\n                    renderServerInsertedHTML,\n                    serverCapturedErrors: allCapturedErrors,\n                    basePath: renderOpts.basePath,\n                    tracingMetadata: tracingMetadata\n                });\n                const flightData = await streamToBuffer(reactServerResult.asStream());\n                metadata.flightData = flightData;\n                metadata.segmentData = await collectSegmentData(flightData, finalRenderPrerenderStore, ComponentMod, renderOpts, fallbackRouteParams);\n                if (serverIsDynamic || clientIsDynamic) {\n                    if (postponed != null) {\n                        // Dynamic HTML case\n                        metadata.postponed = await getDynamicHTMLPostponedState(postponed, fallbackRouteParams, prerenderResumeDataCache);\n                    } else {\n                        // Dynamic Data case\n                        metadata.postponed = await getDynamicDataPostponedState(prerenderResumeDataCache);\n                    }\n                    reactServerResult.consume();\n                    return {\n                        digestErrorsMap: reactServerErrorsByDigest,\n                        ssrErrors: allCapturedErrors,\n                        stream: await continueDynamicPrerender(prelude, {\n                            getServerInsertedHTML,\n                            getServerInsertedMetadata\n                        }),\n                        dynamicAccess: consumeDynamicAccess(serverDynamicTracking, clientDynamicTracking),\n                        // TODO: Should this include the SSR pass?\n                        collectedRevalidate: finalRenderPrerenderStore.revalidate,\n                        collectedExpire: finalRenderPrerenderStore.expire,\n                        collectedStale: finalRenderPrerenderStore.stale,\n                        collectedTags: finalRenderPrerenderStore.tags\n                    };\n                } else {\n                    // Static case\n                    if (workStore.forceDynamic) {\n                        throw Object.defineProperty(new StaticGenBailoutError('Invariant: a Page with `dynamic = \"force-dynamic\"` did not trigger the dynamic pathway. This is a bug in Next.js'), \"__NEXT_ERROR_CODE\", {\n                            value: \"E598\",\n                            enumerable: false,\n                            configurable: true\n                        });\n                    }\n                    let htmlStream = prelude;\n                    if (postponed != null) {\n                        // We postponed but nothing dynamic was used. We resume the render now and immediately abort it\n                        // so we can set all the postponed boundaries to client render mode before we store the HTML response\n                        const resume = require('react-dom/server.edge').resume;\n                        // We don't actually want to render anything so we just pass a stream\n                        // that never resolves. The resume call is going to abort immediately anyway\n                        const foreverStream = new ReadableStream();\n                        const resumeStream = await resume(/*#__PURE__*/ _jsx(App, {\n                            reactServerStream: foreverStream,\n                            preinitScripts: ()=>{},\n                            clientReferenceManifest: clientReferenceManifest,\n                            ServerInsertedHTMLProvider: ServerInsertedHTMLProvider,\n                            ServerInsertedMetadataProvider: ServerInsertedMetadataProvider,\n                            nonce: nonce\n                        }), JSON.parse(JSON.stringify(postponed)), {\n                            signal: createPostponedAbortSignal('static prerender resume'),\n                            onError: htmlRendererErrorHandler,\n                            nonce\n                        });\n                        // First we write everything from the prerender, then we write everything from the aborted resume render\n                        htmlStream = chainStreams(prelude, resumeStream);\n                    }\n                    return {\n                        digestErrorsMap: reactServerErrorsByDigest,\n                        ssrErrors: allCapturedErrors,\n                        stream: await continueStaticPrerender(htmlStream, {\n                            inlinedDataStream: createInlinedDataReadableStream(reactServerResult.consumeAsStream(), nonce, formState),\n                            getServerInsertedHTML,\n                            getServerInsertedMetadata\n                        }),\n                        dynamicAccess: consumeDynamicAccess(serverDynamicTracking, clientDynamicTracking),\n                        // TODO: Should this include the SSR pass?\n                        collectedRevalidate: finalRenderPrerenderStore.revalidate,\n                        collectedExpire: finalRenderPrerenderStore.expire,\n                        collectedStale: finalRenderPrerenderStore.stale,\n                        collectedTags: finalRenderPrerenderStore.tags\n                    };\n                }\n            } else {\n                /**\n         * dynamicIO without PPR\n         *\n         * The general approach is to render the RSC tree first allowing for any inflight\n         * caches to resolve. Once we have settled inflight caches we can check and see if any\n         * synchronous dynamic APIs were used. If so we don't need to bother doing anything more\n         * because the page will be dynamic on re-render anyway\n         *\n         * If no sync dynamic APIs were used we then re-render and abort after a single Task.\n         * If the render errors we know that the page has some dynamic IO. This assumes and relies\n         * upon caches reading from a in process memory cache and resolving in a microtask. While this\n         * is true from our own default cache implementation and if you don't exceed our LRU size it\n         * might not be true for custom cache implementations.\n         *\n         * Future implementations can do some different strategies during build like using IPC to\n         * synchronously fill caches during this special rendering mode. For now this heuristic should work\n         */ const cache = workStore.incrementalCache;\n                if (!cache) {\n                    throw Object.defineProperty(new Error('Expected incremental cache to exist. This is a bug in Next.js'), \"__NEXT_ERROR_CODE\", {\n                        value: \"E205\",\n                        enumerable: false,\n                        configurable: true\n                    });\n                }\n                // Prerender controller represents the lifetime of the prerender.\n                // It will be aborted when a Task is complete or a synchronously aborting\n                // API is called. Notably during cache-filling renders this does not actually\n                // terminate the render itself which will continue until all caches are filled\n                const initialServerPrerenderController = new AbortController();\n                // This controller represents the lifetime of the React render call. Notably\n                // during the cache-filling render it is different from the prerender controller\n                // because we don't want to end the react render until all caches are filled.\n                const initialServerRenderController = new AbortController();\n                const cacheSignal = new CacheSignal();\n                const prerenderResumeDataCache = createPrerenderResumeDataCache();\n                const initialServerPrerenderStore = prerenderStore = {\n                    type: 'prerender',\n                    phase: 'render',\n                    rootParams,\n                    implicitTags,\n                    renderSignal: initialServerRenderController.signal,\n                    controller: initialServerPrerenderController,\n                    cacheSignal,\n                    dynamicTracking: null,\n                    revalidate: INFINITE_CACHE,\n                    expire: INFINITE_CACHE,\n                    stale: INFINITE_CACHE,\n                    tags: [\n                        ...implicitTags.tags\n                    ],\n                    prerenderResumeDataCache,\n                    hmrRefreshHash: undefined\n                };\n                const initialClientController = new AbortController();\n                const initialClientPrerenderStore = prerenderStore = {\n                    type: 'prerender',\n                    phase: 'render',\n                    rootParams,\n                    implicitTags,\n                    renderSignal: initialClientController.signal,\n                    controller: initialClientController,\n                    cacheSignal,\n                    dynamicTracking: null,\n                    revalidate: INFINITE_CACHE,\n                    expire: INFINITE_CACHE,\n                    stale: INFINITE_CACHE,\n                    tags: [\n                        ...implicitTags.tags\n                    ],\n                    prerenderResumeDataCache,\n                    hmrRefreshHash: undefined\n                };\n                // We're not going to use the result of this render because the only time it could be used\n                // is if it completes in a microtask and that's likely very rare for any non-trivial app\n                const firstAttemptRSCPayload = await workUnitAsyncStorage.run(initialServerPrerenderStore, getRSCPayload, tree, ctx, res.statusCode === 404);\n                let initialServerStream;\n                try {\n                    initialServerStream = workUnitAsyncStorage.run(initialServerPrerenderStore, ComponentMod.renderToReadableStream, firstAttemptRSCPayload, clientReferenceManifest.clientModules, {\n                        onError: (err)=>{\n                            const digest = getDigestForWellKnownError(err);\n                            if (digest) {\n                                return digest;\n                            }\n                            if (initialServerPrerenderController.signal.aborted || initialServerRenderController.signal.aborted) {\n                                // The render aborted before this error was handled which indicates\n                                // the error is caused by unfinished components within the render\n                                return;\n                            } else if (process.env.NEXT_DEBUG_BUILD || process.env.__NEXT_VERBOSE_LOGGING) {\n                                printDebugThrownValueForProspectiveRender(err, workStore.route);\n                            }\n                        },\n                        signal: initialServerRenderController.signal\n                    });\n                } catch (err) {\n                    if (initialServerPrerenderController.signal.aborted || initialServerRenderController.signal.aborted) {\n                    // These are expected errors that might error the prerender. we ignore them.\n                    } else if (process.env.NEXT_DEBUG_BUILD || process.env.__NEXT_VERBOSE_LOGGING) {\n                        // We don't normally log these errors because we are going to retry anyway but\n                        // it can be useful for debugging Next.js itself to get visibility here when needed\n                        printDebugThrownValueForProspectiveRender(err, workStore.route);\n                    }\n                }\n                if (initialServerStream) {\n                    const [warmupStream, renderStream] = initialServerStream.tee();\n                    initialServerStream = null;\n                    // Before we attempt the SSR initial render we need to ensure all client modules\n                    // are already loaded.\n                    await warmFlightResponse(warmupStream, clientReferenceManifest);\n                    const prerender = require('react-dom/static.edge').prerender;\n                    const pendingInitialClientResult = workUnitAsyncStorage.run(initialClientPrerenderStore, prerender, /*#__PURE__*/ _jsx(App, {\n                        reactServerStream: renderStream,\n                        preinitScripts: preinitScripts,\n                        clientReferenceManifest: clientReferenceManifest,\n                        ServerInsertedHTMLProvider: ServerInsertedHTMLProvider,\n                        ServerInsertedMetadataProvider: ServerInsertedMetadataProvider,\n                        nonce: nonce\n                    }), {\n                        signal: initialClientController.signal,\n                        onError: (err)=>{\n                            const digest = getDigestForWellKnownError(err);\n                            if (digest) {\n                                return digest;\n                            }\n                            if (initialClientController.signal.aborted) {\n                            // These are expected errors that might error the prerender. we ignore them.\n                            } else if (process.env.NEXT_DEBUG_BUILD || process.env.__NEXT_VERBOSE_LOGGING) {\n                                // We don't normally log these errors because we are going to retry anyway but\n                                // it can be useful for debugging Next.js itself to get visibility here when needed\n                                printDebugThrownValueForProspectiveRender(err, workStore.route);\n                            }\n                        },\n                        bootstrapScripts: [\n                            bootstrapScript\n                        ]\n                    });\n                    pendingInitialClientResult.catch((err)=>{\n                        if (initialClientController.signal.aborted) {\n                        // We aborted the render normally and can ignore this error\n                        } else {\n                            // We're going to retry to so we normally would suppress this error but\n                            // when verbose logging is on we print it\n                            if (process.env.__NEXT_VERBOSE_LOGGING) {\n                                printDebugThrownValueForProspectiveRender(err, workStore.route);\n                            }\n                        }\n                    });\n                }\n                await cacheSignal.cacheReady();\n                // It is important that we abort the SSR render first to avoid\n                // connection closed errors from having an incomplete RSC stream\n                initialClientController.abort();\n                initialServerRenderController.abort();\n                initialServerPrerenderController.abort();\n                // We've now filled caches and triggered any inadvertant sync bailouts\n                // due to lazy module initialization. We can restart our render to capture results\n                let serverIsDynamic = false;\n                const finalServerController = new AbortController();\n                const serverDynamicTracking = createDynamicTrackingState(renderOpts.isDebugDynamicAccesses);\n                const finalServerPrerenderStore = prerenderStore = {\n                    type: 'prerender',\n                    phase: 'render',\n                    rootParams,\n                    implicitTags,\n                    renderSignal: finalServerController.signal,\n                    controller: finalServerController,\n                    // During the final prerender we don't need to track cache access so we omit the signal\n                    cacheSignal: null,\n                    dynamicTracking: serverDynamicTracking,\n                    revalidate: INFINITE_CACHE,\n                    expire: INFINITE_CACHE,\n                    stale: INFINITE_CACHE,\n                    tags: [\n                        ...implicitTags.tags\n                    ],\n                    prerenderResumeDataCache,\n                    hmrRefreshHash: undefined\n                };\n                let clientIsDynamic = false;\n                const finalClientController = new AbortController();\n                const clientDynamicTracking = createDynamicTrackingState(renderOpts.isDebugDynamicAccesses);\n                const dynamicValidation = createDynamicValidationState();\n                const finalClientPrerenderStore = prerenderStore = {\n                    type: 'prerender',\n                    phase: 'render',\n                    rootParams,\n                    implicitTags,\n                    renderSignal: finalClientController.signal,\n                    controller: finalClientController,\n                    // During the final prerender we don't need to track cache access so we omit the signal\n                    cacheSignal: null,\n                    dynamicTracking: clientDynamicTracking,\n                    revalidate: INFINITE_CACHE,\n                    expire: INFINITE_CACHE,\n                    stale: INFINITE_CACHE,\n                    tags: [\n                        ...implicitTags.tags\n                    ],\n                    prerenderResumeDataCache,\n                    hmrRefreshHash: undefined\n                };\n                const finalServerPayload = await workUnitAsyncStorage.run(finalServerPrerenderStore, getRSCPayload, tree, ctx, res.statusCode === 404);\n                const serverPrerenderStreamResult = reactServerPrerenderResult = await prerenderServerWithPhases(finalServerController.signal, ()=>workUnitAsyncStorage.run(finalServerPrerenderStore, ComponentMod.renderToReadableStream, finalServerPayload, clientReferenceManifest.clientModules, {\n                        onError: (err)=>{\n                            if (finalServerController.signal.aborted) {\n                                serverIsDynamic = true;\n                                if (isPrerenderInterruptedError(err)) {\n                                    return err.digest;\n                                }\n                                return getDigestForWellKnownError(err);\n                            }\n                            return serverComponentsErrorHandler(err);\n                        },\n                        signal: finalServerController.signal\n                    }), ()=>{\n                    finalServerController.abort();\n                });\n                let htmlStream;\n                const serverPhasedStream = serverPrerenderStreamResult.asPhasedStream();\n                try {\n                    const prerender = require('react-dom/static.edge').prerender;\n                    const result = await prerenderClientWithPhases(()=>workUnitAsyncStorage.run(finalClientPrerenderStore, prerender, /*#__PURE__*/ _jsx(App, {\n                            reactServerStream: serverPhasedStream,\n                            preinitScripts: preinitScripts,\n                            clientReferenceManifest: clientReferenceManifest,\n                            ServerInsertedHTMLProvider: ServerInsertedHTMLProvider,\n                            ServerInsertedMetadataProvider: ServerInsertedMetadataProvider,\n                            nonce: nonce\n                        }), {\n                            signal: finalClientController.signal,\n                            onError: (err, errorInfo)=>{\n                                if (isPrerenderInterruptedError(err) || finalClientController.signal.aborted) {\n                                    clientIsDynamic = true;\n                                    const componentStack = errorInfo.componentStack;\n                                    if (typeof componentStack === 'string') {\n                                        trackAllowedDynamicAccess(workStore.route, componentStack, dynamicValidation, serverDynamicTracking, clientDynamicTracking);\n                                    }\n                                    return;\n                                }\n                                return htmlRendererErrorHandler(err, errorInfo);\n                            },\n                            bootstrapScripts: [\n                                bootstrapScript\n                            ]\n                        }), ()=>{\n                        finalClientController.abort();\n                        serverPhasedStream.assertExhausted();\n                    });\n                    htmlStream = result.prelude;\n                } catch (err) {\n                    if (isPrerenderInterruptedError(err) || finalClientController.signal.aborted) {\n                    // we don't have a root because the abort errored in the root. We can just ignore this error\n                    } else {\n                        // This error is something else and should bubble up\n                        throw err;\n                    }\n                }\n                throwIfDisallowedDynamic(workStore.route, dynamicValidation, serverDynamicTracking, clientDynamicTracking);\n                if (serverIsDynamic || clientIsDynamic) {\n                    const dynamicReason = serverIsDynamic ? getFirstDynamicReason(serverDynamicTracking) : getFirstDynamicReason(clientDynamicTracking);\n                    if (dynamicReason) {\n                        throw Object.defineProperty(new DynamicServerError(`Route \"${workStore.route}\" couldn't be rendered statically because it used \\`${dynamicReason}\\`. See more info here: https://nextjs.org/docs/messages/next-prerender-data`), \"__NEXT_ERROR_CODE\", {\n                            value: \"E586\",\n                            enumerable: false,\n                            configurable: true\n                        });\n                    } else {\n                        throw Object.defineProperty(new DynamicServerError(`Route \"${workStore.route}\" couldn't be rendered statically it accessed data without explicitly caching it. See more info here: https://nextjs.org/docs/messages/next-prerender-data`), \"__NEXT_ERROR_CODE\", {\n                            value: \"E583\",\n                            enumerable: false,\n                            configurable: true\n                        });\n                    }\n                }\n                const flightData = await streamToBuffer(serverPrerenderStreamResult.asStream());\n                metadata.flightData = flightData;\n                metadata.segmentData = await collectSegmentData(flightData, finalClientPrerenderStore, ComponentMod, renderOpts, fallbackRouteParams);\n                const getServerInsertedHTML = makeGetServerInsertedHTML({\n                    polyfills,\n                    renderServerInsertedHTML,\n                    serverCapturedErrors: allCapturedErrors,\n                    basePath: renderOpts.basePath,\n                    tracingMetadata: tracingMetadata\n                });\n                const validateRootLayout = renderOpts.dev;\n                return {\n                    digestErrorsMap: reactServerErrorsByDigest,\n                    ssrErrors: allCapturedErrors,\n                    stream: await continueFizzStream(htmlStream, {\n                        inlinedDataStream: createInlinedDataReadableStream(serverPrerenderStreamResult.asStream(), nonce, formState),\n                        isStaticGeneration: true,\n                        getServerInsertedHTML,\n                        getServerInsertedMetadata,\n                        validateRootLayout\n                    }),\n                    dynamicAccess: consumeDynamicAccess(serverDynamicTracking, clientDynamicTracking),\n                    // TODO: Should this include the SSR pass?\n                    collectedRevalidate: finalServerPrerenderStore.revalidate,\n                    collectedExpire: finalServerPrerenderStore.expire,\n                    collectedStale: finalServerPrerenderStore.stale,\n                    collectedTags: finalServerPrerenderStore.tags\n                };\n            }\n        } else if (renderOpts.experimental.isRoutePPREnabled) {\n            // We're statically generating with PPR and need to do dynamic tracking\n            let dynamicTracking = createDynamicTrackingState(renderOpts.isDebugDynamicAccesses);\n            const prerenderResumeDataCache = createPrerenderResumeDataCache();\n            const reactServerPrerenderStore = prerenderStore = {\n                type: 'prerender-ppr',\n                phase: 'render',\n                rootParams,\n                implicitTags,\n                dynamicTracking,\n                revalidate: INFINITE_CACHE,\n                expire: INFINITE_CACHE,\n                stale: INFINITE_CACHE,\n                tags: [\n                    ...implicitTags.tags\n                ],\n                prerenderResumeDataCache\n            };\n            const RSCPayload = await workUnitAsyncStorage.run(reactServerPrerenderStore, getRSCPayload, tree, ctx, res.statusCode === 404);\n            const reactServerResult = reactServerPrerenderResult = await createReactServerPrerenderResultFromRender(workUnitAsyncStorage.run(reactServerPrerenderStore, ComponentMod.renderToReadableStream, // ... the arguments for the function to run\n            RSCPayload, clientReferenceManifest.clientModules, {\n                onError: serverComponentsErrorHandler\n            }));\n            const ssrPrerenderStore = {\n                type: 'prerender-ppr',\n                phase: 'render',\n                rootParams,\n                implicitTags,\n                dynamicTracking,\n                revalidate: INFINITE_CACHE,\n                expire: INFINITE_CACHE,\n                stale: INFINITE_CACHE,\n                tags: [\n                    ...implicitTags.tags\n                ],\n                prerenderResumeDataCache\n            };\n            const prerender = require('react-dom/static.edge').prerender;\n            const { prelude, postponed } = await workUnitAsyncStorage.run(ssrPrerenderStore, prerender, /*#__PURE__*/ _jsx(App, {\n                reactServerStream: reactServerResult.asUnclosingStream(),\n                preinitScripts: preinitScripts,\n                clientReferenceManifest: clientReferenceManifest,\n                ServerInsertedHTMLProvider: ServerInsertedHTMLProvider,\n                ServerInsertedMetadataProvider: ServerInsertedMetadataProvider,\n                nonce: nonce\n            }), {\n                onError: htmlRendererErrorHandler,\n                onHeaders: (headers)=>{\n                    headers.forEach((value, key)=>{\n                        appendHeader(key, value);\n                    });\n                },\n                maxHeadersLength: renderOpts.reactMaxHeadersLength,\n                bootstrapScripts: [\n                    bootstrapScript\n                ]\n            });\n            const getServerInsertedHTML = makeGetServerInsertedHTML({\n                polyfills,\n                renderServerInsertedHTML,\n                serverCapturedErrors: allCapturedErrors,\n                basePath: renderOpts.basePath,\n                tracingMetadata: tracingMetadata\n            });\n            // After awaiting here we've waited for the entire RSC render to complete. Crucially this means\n            // that when we detect whether we've used dynamic APIs below we know we'll have picked up even\n            // parts of the React Server render that might not be used in the SSR render.\n            const flightData = await streamToBuffer(reactServerResult.asStream());\n            if (shouldGenerateStaticFlightData(workStore)) {\n                metadata.flightData = flightData;\n                metadata.segmentData = await collectSegmentData(flightData, ssrPrerenderStore, ComponentMod, renderOpts, fallbackRouteParams);\n            }\n            /**\n       * When prerendering there are three outcomes to consider\n       *\n       *   Dynamic HTML:      The prerender has dynamic holes (caused by using Next.js Dynamic Rendering APIs)\n       *                      We will need to resume this result when requests are handled and we don't include\n       *                      any server inserted HTML or inlined flight data in the static HTML\n       *\n       *   Dynamic Data:      The prerender has no dynamic holes but dynamic APIs were used. We will not\n       *                      resume this render when requests are handled but we will generate new inlined\n       *                      flight data since it is dynamic and differences may end up reconciling on the client\n       *\n       *   Static:            The prerender has no dynamic holes and no dynamic APIs were used. We statically encode\n       *                      all server inserted HTML and flight data\n       */ // First we check if we have any dynamic holes in our HTML prerender\n            if (accessedDynamicData(dynamicTracking.dynamicAccesses)) {\n                if (postponed != null) {\n                    // Dynamic HTML case.\n                    metadata.postponed = await getDynamicHTMLPostponedState(postponed, fallbackRouteParams, prerenderResumeDataCache);\n                } else {\n                    // Dynamic Data case.\n                    metadata.postponed = await getDynamicDataPostponedState(prerenderResumeDataCache);\n                }\n                // Regardless of whether this is the Dynamic HTML or Dynamic Data case we need to ensure we include\n                // server inserted html in the static response because the html that is part of the prerender may depend on it\n                // It is possible in the set of stream transforms for Dynamic HTML vs Dynamic Data may differ but currently both states\n                // require the same set so we unify the code path here\n                reactServerResult.consume();\n                return {\n                    digestErrorsMap: reactServerErrorsByDigest,\n                    ssrErrors: allCapturedErrors,\n                    stream: await continueDynamicPrerender(prelude, {\n                        getServerInsertedHTML,\n                        getServerInsertedMetadata\n                    }),\n                    dynamicAccess: dynamicTracking.dynamicAccesses,\n                    // TODO: Should this include the SSR pass?\n                    collectedRevalidate: reactServerPrerenderStore.revalidate,\n                    collectedExpire: reactServerPrerenderStore.expire,\n                    collectedStale: reactServerPrerenderStore.stale,\n                    collectedTags: reactServerPrerenderStore.tags\n                };\n            } else if (fallbackRouteParams && fallbackRouteParams.size > 0) {\n                // Rendering the fallback case.\n                metadata.postponed = await getDynamicDataPostponedState(prerenderResumeDataCache);\n                return {\n                    digestErrorsMap: reactServerErrorsByDigest,\n                    ssrErrors: allCapturedErrors,\n                    stream: await continueDynamicPrerender(prelude, {\n                        getServerInsertedHTML,\n                        getServerInsertedMetadata\n                    }),\n                    dynamicAccess: dynamicTracking.dynamicAccesses,\n                    // TODO: Should this include the SSR pass?\n                    collectedRevalidate: reactServerPrerenderStore.revalidate,\n                    collectedExpire: reactServerPrerenderStore.expire,\n                    collectedStale: reactServerPrerenderStore.stale,\n                    collectedTags: reactServerPrerenderStore.tags\n                };\n            } else {\n                // Static case\n                // We still have not used any dynamic APIs. At this point we can produce an entirely static prerender response\n                if (workStore.forceDynamic) {\n                    throw Object.defineProperty(new StaticGenBailoutError('Invariant: a Page with `dynamic = \"force-dynamic\"` did not trigger the dynamic pathway. This is a bug in Next.js'), \"__NEXT_ERROR_CODE\", {\n                        value: \"E598\",\n                        enumerable: false,\n                        configurable: true\n                    });\n                }\n                let htmlStream = prelude;\n                if (postponed != null) {\n                    // We postponed but nothing dynamic was used. We resume the render now and immediately abort it\n                    // so we can set all the postponed boundaries to client render mode before we store the HTML response\n                    const resume = require('react-dom/server.edge').resume;\n                    // We don't actually want to render anything so we just pass a stream\n                    // that never resolves. The resume call is going to abort immediately anyway\n                    const foreverStream = new ReadableStream();\n                    const resumeStream = await resume(/*#__PURE__*/ _jsx(App, {\n                        reactServerStream: foreverStream,\n                        preinitScripts: ()=>{},\n                        clientReferenceManifest: clientReferenceManifest,\n                        ServerInsertedHTMLProvider: ServerInsertedHTMLProvider,\n                        ServerInsertedMetadataProvider: ServerInsertedMetadataProvider,\n                        nonce: nonce\n                    }), JSON.parse(JSON.stringify(postponed)), {\n                        signal: createPostponedAbortSignal('static prerender resume'),\n                        onError: htmlRendererErrorHandler,\n                        nonce\n                    });\n                    // First we write everything from the prerender, then we write everything from the aborted resume render\n                    htmlStream = chainStreams(prelude, resumeStream);\n                }\n                return {\n                    digestErrorsMap: reactServerErrorsByDigest,\n                    ssrErrors: allCapturedErrors,\n                    stream: await continueStaticPrerender(htmlStream, {\n                        inlinedDataStream: createInlinedDataReadableStream(reactServerResult.consumeAsStream(), nonce, formState),\n                        getServerInsertedHTML,\n                        getServerInsertedMetadata\n                    }),\n                    dynamicAccess: dynamicTracking.dynamicAccesses,\n                    // TODO: Should this include the SSR pass?\n                    collectedRevalidate: reactServerPrerenderStore.revalidate,\n                    collectedExpire: reactServerPrerenderStore.expire,\n                    collectedStale: reactServerPrerenderStore.stale,\n                    collectedTags: reactServerPrerenderStore.tags\n                };\n            }\n        } else {\n            const prerenderLegacyStore = prerenderStore = {\n                type: 'prerender-legacy',\n                phase: 'render',\n                rootParams,\n                implicitTags,\n                revalidate: INFINITE_CACHE,\n                expire: INFINITE_CACHE,\n                stale: INFINITE_CACHE,\n                tags: [\n                    ...implicitTags.tags\n                ]\n            };\n            // This is a regular static generation. We don't do dynamic tracking because we rely on\n            // the old-school dynamic error handling to bail out of static generation\n            const RSCPayload = await workUnitAsyncStorage.run(prerenderLegacyStore, getRSCPayload, tree, ctx, res.statusCode === 404);\n            const reactServerResult = reactServerPrerenderResult = await createReactServerPrerenderResultFromRender(workUnitAsyncStorage.run(prerenderLegacyStore, ComponentMod.renderToReadableStream, RSCPayload, clientReferenceManifest.clientModules, {\n                onError: serverComponentsErrorHandler\n            }));\n            const renderToReadableStream = require('react-dom/server.edge').renderToReadableStream;\n            const htmlStream = await workUnitAsyncStorage.run(prerenderLegacyStore, renderToReadableStream, /*#__PURE__*/ _jsx(App, {\n                reactServerStream: reactServerResult.asUnclosingStream(),\n                preinitScripts: preinitScripts,\n                clientReferenceManifest: clientReferenceManifest,\n                ServerInsertedHTMLProvider: ServerInsertedHTMLProvider,\n                ServerInsertedMetadataProvider: ServerInsertedMetadataProvider,\n                nonce: nonce\n            }), {\n                onError: htmlRendererErrorHandler,\n                nonce,\n                bootstrapScripts: [\n                    bootstrapScript\n                ]\n            });\n            if (shouldGenerateStaticFlightData(workStore)) {\n                const flightData = await streamToBuffer(reactServerResult.asStream());\n                metadata.flightData = flightData;\n                metadata.segmentData = await collectSegmentData(flightData, prerenderLegacyStore, ComponentMod, renderOpts, fallbackRouteParams);\n            }\n            const getServerInsertedHTML = makeGetServerInsertedHTML({\n                polyfills,\n                renderServerInsertedHTML,\n                serverCapturedErrors: allCapturedErrors,\n                basePath: renderOpts.basePath,\n                tracingMetadata: tracingMetadata\n            });\n            return {\n                digestErrorsMap: reactServerErrorsByDigest,\n                ssrErrors: allCapturedErrors,\n                stream: await continueFizzStream(htmlStream, {\n                    inlinedDataStream: createInlinedDataReadableStream(reactServerResult.consumeAsStream(), nonce, formState),\n                    isStaticGeneration: true,\n                    getServerInsertedHTML,\n                    getServerInsertedMetadata\n                }),\n                // TODO: Should this include the SSR pass?\n                collectedRevalidate: prerenderLegacyStore.revalidate,\n                collectedExpire: prerenderLegacyStore.expire,\n                collectedStale: prerenderLegacyStore.stale,\n                collectedTags: prerenderLegacyStore.tags\n            };\n        }\n    } catch (err) {\n        if (isStaticGenBailoutError(err) || typeof err === 'object' && err !== null && 'message' in err && typeof err.message === 'string' && err.message.includes('https://nextjs.org/docs/advanced-features/static-html-export')) {\n            // Ensure that \"next dev\" prints the red error overlay\n            throw err;\n        }\n        // If this is a static generation error, we need to throw it so that it\n        // can be handled by the caller if we're in static generation mode.\n        if (isDynamicServerError(err)) {\n            throw err;\n        }\n        // If a bailout made it to this point, it means it wasn't wrapped inside\n        // a suspense boundary.\n        const shouldBailoutToCSR = isBailoutToCSRError(err);\n        if (shouldBailoutToCSR) {\n            const stack = getStackWithoutErrorMessage(err);\n            error(`${err.reason} should be wrapped in a suspense boundary at page \"${pagePath}\". Read more: https://nextjs.org/docs/messages/missing-suspense-with-csr-bailout\\n${stack}`);\n            throw err;\n        }\n        // If we errored when we did not have an RSC stream to read from. This is\n        // not just a render error, we need to throw early.\n        if (reactServerPrerenderResult === null) {\n            throw err;\n        }\n        let errorType;\n        if (isHTTPAccessFallbackError(err)) {\n            res.statusCode = getAccessFallbackHTTPStatus(err);\n            errorType = getAccessFallbackErrorTypeByStatus(res.statusCode);\n        } else if (isRedirectError(err)) {\n            errorType = 'redirect';\n            res.statusCode = getRedirectStatusCodeFromError(err);\n            const redirectUrl = addPathPrefix(getURLFromRedirectError(err), renderOpts.basePath);\n            setHeader('location', redirectUrl);\n        } else if (!shouldBailoutToCSR) {\n            res.statusCode = 500;\n        }\n        const [errorPreinitScripts, errorBootstrapScript] = getRequiredScripts(renderOpts.buildManifest, assetPrefix, renderOpts.crossOrigin, renderOpts.subresourceIntegrityManifest, getAssetQueryString(ctx, false), nonce, '/_not-found/page');\n        const prerenderLegacyStore = prerenderStore = {\n            type: 'prerender-legacy',\n            phase: 'render',\n            rootParams,\n            implicitTags: implicitTags,\n            revalidate: typeof (prerenderStore == null ? void 0 : prerenderStore.revalidate) !== 'undefined' ? prerenderStore.revalidate : INFINITE_CACHE,\n            expire: typeof (prerenderStore == null ? void 0 : prerenderStore.expire) !== 'undefined' ? prerenderStore.expire : INFINITE_CACHE,\n            stale: typeof (prerenderStore == null ? void 0 : prerenderStore.stale) !== 'undefined' ? prerenderStore.stale : INFINITE_CACHE,\n            tags: [\n                ...(prerenderStore == null ? void 0 : prerenderStore.tags) || implicitTags.tags\n            ]\n        };\n        const errorRSCPayload = await workUnitAsyncStorage.run(prerenderLegacyStore, getErrorRSCPayload, tree, ctx, reactServerErrorsByDigest.has(err.digest) ? undefined : err, errorType);\n        const errorServerStream = workUnitAsyncStorage.run(prerenderLegacyStore, ComponentMod.renderToReadableStream, errorRSCPayload, clientReferenceManifest.clientModules, {\n            onError: serverComponentsErrorHandler\n        });\n        try {\n            const fizzStream = await renderToInitialFizzStream({\n                ReactDOMServer: require('react-dom/server.edge'),\n                element: /*#__PURE__*/ _jsx(ErrorApp, {\n                    reactServerStream: errorServerStream,\n                    ServerInsertedMetadataProvider: ServerInsertedMetadataProvider,\n                    ServerInsertedHTMLProvider: ServerInsertedHTMLProvider,\n                    preinitScripts: errorPreinitScripts,\n                    clientReferenceManifest: clientReferenceManifest,\n                    nonce: nonce\n                }),\n                streamOptions: {\n                    nonce,\n                    // Include hydration scripts in the HTML\n                    bootstrapScripts: [\n                        errorBootstrapScript\n                    ],\n                    formState\n                }\n            });\n            if (shouldGenerateStaticFlightData(workStore)) {\n                const flightData = await streamToBuffer(reactServerPrerenderResult.asStream());\n                metadata.flightData = flightData;\n                metadata.segmentData = await collectSegmentData(flightData, prerenderLegacyStore, ComponentMod, renderOpts, fallbackRouteParams);\n            }\n            const validateRootLayout = renderOpts.dev;\n            // This is intentionally using the readable datastream from the main\n            // render rather than the flight data from the error page render\n            const flightStream = reactServerPrerenderResult instanceof ServerPrerenderStreamResult ? reactServerPrerenderResult.asStream() : reactServerPrerenderResult.consumeAsStream();\n            return {\n                // Returning the error that was thrown so it can be used to handle\n                // the response in the caller.\n                digestErrorsMap: reactServerErrorsByDigest,\n                ssrErrors: allCapturedErrors,\n                stream: await continueFizzStream(fizzStream, {\n                    inlinedDataStream: createInlinedDataReadableStream(flightStream, nonce, formState),\n                    isStaticGeneration: true,\n                    getServerInsertedHTML: makeGetServerInsertedHTML({\n                        polyfills,\n                        renderServerInsertedHTML,\n                        serverCapturedErrors: [],\n                        basePath: renderOpts.basePath,\n                        tracingMetadata: tracingMetadata\n                    }),\n                    getServerInsertedMetadata,\n                    validateRootLayout\n                }),\n                dynamicAccess: null,\n                collectedRevalidate: prerenderStore !== null ? prerenderStore.revalidate : INFINITE_CACHE,\n                collectedExpire: prerenderStore !== null ? prerenderStore.expire : INFINITE_CACHE,\n                collectedStale: prerenderStore !== null ? prerenderStore.stale : INFINITE_CACHE,\n                collectedTags: prerenderStore !== null ? prerenderStore.tags : null\n            };\n        } catch (finalErr) {\n            if (process.env.NODE_ENV === 'development' && isHTTPAccessFallbackError(finalErr)) {\n                const { bailOnRootNotFound } = require('../../client/components/dev-root-http-access-fallback-boundary');\n                bailOnRootNotFound();\n            }\n            throw finalErr;\n        }\n    }\n}\nconst loadingChunks = new Set();\nconst chunkListeners = [];\nfunction trackChunkLoading(load) {\n    loadingChunks.add(load);\n    load.finally(()=>{\n        if (loadingChunks.has(load)) {\n            loadingChunks.delete(load);\n            if (loadingChunks.size === 0) {\n                // We are not currently loading any chunks. We can notify all listeners\n                for(let i = 0; i < chunkListeners.length; i++){\n                    chunkListeners[i]();\n                }\n                chunkListeners.length = 0;\n            }\n        }\n    });\n}\nexport async function warmFlightResponse(flightStream, clientReferenceManifest) {\n    const { createFromReadableStream } = // eslint-disable-next-line import/no-extraneous-dependencies\n    require('react-server-dom-webpack/client.edge');\n    try {\n        createFromReadableStream(flightStream, {\n            serverConsumerManifest: {\n                moduleLoading: clientReferenceManifest.moduleLoading,\n                moduleMap: clientReferenceManifest.ssrModuleMapping,\n                serverModuleMap: null\n            }\n        });\n    } catch  {\n    // We don't want to handle errors here but we don't want it to\n    // interrupt the outer flow. We simply ignore it here and expect\n    // it will bubble up during a render\n    }\n    // We'll wait at least one task and then if no chunks have started to load\n    // we'll we can infer that there are none to load from this flight response\n    trackChunkLoading(waitAtLeastOneReactRenderTask());\n    return new Promise((r)=>{\n        chunkListeners.push(r);\n    });\n}\nconst getGlobalErrorStyles = async (tree, ctx)=>{\n    const { modules: { 'global-error': globalErrorModule } } = parseLoaderTree(tree);\n    let globalErrorStyles;\n    if (globalErrorModule) {\n        const [, styles] = await createComponentStylesAndScripts({\n            ctx,\n            filePath: globalErrorModule[1],\n            getComponent: globalErrorModule[0],\n            injectedCSS: new Set(),\n            injectedJS: new Set()\n        });\n        globalErrorStyles = styles;\n    }\n    return globalErrorStyles;\n};\nasync function collectSegmentData(fullPageDataBuffer, prerenderStore, ComponentMod, renderOpts, fallbackRouteParams) {\n    // Per-segment prefetch data\n    //\n    // All of the segments for a page are generated simultaneously, including\n    // during revalidations. This is to ensure consistency, because it's\n    // possible for a mismatch between a layout and page segment can cause the\n    // client to error during rendering. We want to preserve the ability of the\n    // client to recover from such a mismatch by re-requesting all the segments\n    // to get a consistent view of the page.\n    //\n    // For performance, we reuse the Flight output that was created when\n    // generating the initial page HTML. The Flight stream for the whole page is\n    // decomposed into a separate stream per segment.\n    const clientReferenceManifest = renderOpts.clientReferenceManifest;\n    if (!clientReferenceManifest || // Do not generate per-segment data unless the experimental Segment Cache\n    // flag is enabled.\n    //\n    // We also skip generating segment data if flag is set to \"client-only\",\n    // rather than true. (The \"client-only\" option only affects the behavior of\n    // the client-side implementation; per-segment prefetches are intentionally\n    // disabled in that configuration).\n    renderOpts.experimental.clientSegmentCache !== true) {\n        return;\n    }\n    // Manifest passed to the Flight client for reading the full-page Flight\n    // stream. Based off similar code in use-cache-wrapper.ts.\n    const isEdgeRuntime = process.env.NEXT_RUNTIME === 'edge';\n    const serverConsumerManifest = {\n        // moduleLoading must be null because we don't want to trigger preloads of ClientReferences\n        // to be added to the consumer. Instead, we'll wait for any ClientReference to be emitted\n        // which themselves will handle the preloading.\n        moduleLoading: null,\n        moduleMap: isEdgeRuntime ? clientReferenceManifest.edgeRscModuleMapping : clientReferenceManifest.rscModuleMapping,\n        serverModuleMap: null\n    };\n    // When dynamicIO is enabled, missing data is encoded to an infinitely hanging\n    // promise, the absence of which we use to determine if a segment is fully\n    // static or partially static. However, when dynamicIO is not enabled, this\n    // trick doesn't work.\n    //\n    // So if PPR is enabled, and dynamicIO is not, we have to be conservative and\n    // assume all segments are partial.\n    //\n    // TODO: When PPR is on, we can at least optimize the case where the entire\n    // page is static. Either by passing that as an argument to this function, or\n    // by setting a header on the response like the we do for full page RSC\n    // prefetches today. The latter approach might be simpler since it requires\n    // less plumbing, and the client has to check the header regardless to see if\n    // PPR is enabled.\n    const shouldAssumePartialData = renderOpts.experimental.isRoutePPREnabled === true && // PPR is enabled\n    !renderOpts.experimental.dynamicIO // dynamicIO is disabled\n    ;\n    const staleTime = prerenderStore.stale;\n    return await ComponentMod.collectSegmentData(shouldAssumePartialData, fullPageDataBuffer, staleTime, clientReferenceManifest.clientModules, serverConsumerManifest, fallbackRouteParams);\n}\n\n//# sourceMappingURL=app-render.js.map"
        }
    ]
}