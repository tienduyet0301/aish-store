{
    "sourceFile": "node_modules/next/dist/esm/server/app-render/walk-tree-with-flight-router-state.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892825454,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import { matchSegment } from '../../client/components/match-segments';\nimport { getLinkAndScriptTags } from './get-css-inlined-link-tags';\nimport { getPreloadableFonts } from './get-preloadable-fonts';\nimport { createFlightRouterStateFromLoaderTree } from './create-flight-router-state-from-loader-tree';\nimport { hasLoadingComponentInTree } from './has-loading-component-in-tree';\nimport { DEFAULT_SEGMENT_KEY, addSearchParamsIfPageSegment } from '../../shared/lib/segment';\nimport { createComponentTree } from './create-component-tree';\nimport { getSegmentParam } from './get-segment-param';\n/**\n * Use router state to decide at what common layout to render the page.\n * This can either be the common layout between two pages or a specific place to start rendering from using the \"refetch\" marker in the tree.\n */ export async function walkTreeWithFlightRouterState({ loaderTreeToFilter, parentParams, flightRouterState, parentIsInsideSharedLayout, rscHead, injectedCSS, injectedJS, injectedFontPreloadTags, rootLayoutIncluded, getViewportReady, getMetadataReady, ctx, preloadCallbacks, StreamingMetadataOutlet }) {\n    const { renderOpts: { nextFontManifest, experimental }, query, isPrefetch, getDynamicParamFromSegment, parsedRequestHeaders } = ctx;\n    const [segment, parallelRoutes, modules] = loaderTreeToFilter;\n    const parallelRoutesKeys = Object.keys(parallelRoutes);\n    const { layout } = modules;\n    const isLayout = typeof layout !== 'undefined';\n    /**\n   * Checks if the current segment is a root layout.\n   */ const rootLayoutAtThisLevel = isLayout && !rootLayoutIncluded;\n    /**\n   * Checks if the current segment or any level above it has a root layout.\n   */ const rootLayoutIncludedAtThisLevelOrAbove = rootLayoutIncluded || rootLayoutAtThisLevel;\n    // Because this function walks to a deeper point in the tree to start rendering we have to track the dynamic parameters up to the point where rendering starts\n    const segmentParam = getDynamicParamFromSegment(segment);\n    const currentParams = // Handle null case where dynamic param is optional\n    segmentParam && segmentParam.value !== null ? {\n        ...parentParams,\n        [segmentParam.param]: segmentParam.value\n    } : parentParams;\n    const actualSegment = addSearchParamsIfPageSegment(segmentParam ? segmentParam.treeSegment : segment, query);\n    /**\n   * Decide if the current segment is where rendering has to start.\n   */ const renderComponentsOnThisLevel = // No further router state available\n    !flightRouterState || // Segment in router state does not match current segment\n    !matchSegment(actualSegment, flightRouterState[0]) || // Last item in the tree\n    parallelRoutesKeys.length === 0 || // Explicit refresh\n    flightRouterState[3] === 'refetch';\n    // Pre-PPR, the `loading` component signals to the router how deep to render the component tree\n    // to ensure prefetches are quick and inexpensive. If there's no `loading` component anywhere in the tree being rendered,\n    // the prefetch will be short-circuited to avoid requesting a potentially very expensive subtree. If there's a `loading`\n    // somewhere in the tree, we'll recursively render the component tree up until we encounter that loading component, and then stop.\n    // Check if we're inside the \"new\" part of the navigation â€” inside the\n    // shared layout. In the case of a prefetch, this can be true even if the\n    // segment matches, because the client might send a matching segment to\n    // indicate that it already has the data in its cache. But in order to find\n    // the correct loading boundary, we still need to track where the shared\n    // layout begins.\n    //\n    // TODO: We should rethink the protocol for dynamic requests. It might not\n    // make sense for the client to send a FlightRouterState, since that type is\n    // overloaded with other concerns.\n    const isInsideSharedLayout = renderComponentsOnThisLevel || parentIsInsideSharedLayout || flightRouterState[3] === 'inside-shared-layout';\n    if (isInsideSharedLayout && !experimental.isRoutePPREnabled && // If PPR is disabled, and this is a request for the route tree, then we\n    // never render any components. Only send the router state.\n    (parsedRequestHeaders.isRouteTreePrefetchRequest || // Otherwise, check for the presence of a `loading` component.\n    isPrefetch && !Boolean(modules.loading) && !hasLoadingComponentInTree(loaderTreeToFilter))) {\n        // Send only the router state.\n        // TODO: Even for a dynamic route, we should cache these responses,\n        // because they do not contain any render data (neither segment data nor\n        // the head). They can be made even more cacheable once we move the route\n        // params into a separate data structure.\n        const overriddenSegment = flightRouterState && // TODO: Why does canSegmentBeOverridden exist? Why don't we always just\n        // use `actualSegment`? Is it to avoid overwriting some state that's\n        // tracked by the client? Dig deeper to see if we can simplify this.\n        canSegmentBeOverridden(actualSegment, flightRouterState[0]) ? flightRouterState[0] : actualSegment;\n        const routerState = createFlightRouterStateFromLoaderTree(// Create router state using the slice of the loaderTree\n        loaderTreeToFilter, getDynamicParamFromSegment, query);\n        return [\n            [\n                overriddenSegment,\n                routerState,\n                null,\n                [\n                    null,\n                    null\n                ],\n                false\n            ]\n        ];\n    }\n    if (renderComponentsOnThisLevel) {\n        const overriddenSegment = flightRouterState && // TODO: Why does canSegmentBeOverridden exist? Why don't we always just\n        // use `actualSegment`? Is it to avoid overwriting some state that's\n        // tracked by the client? Dig deeper to see if we can simplify this.\n        canSegmentBeOverridden(actualSegment, flightRouterState[0]) ? flightRouterState[0] : actualSegment;\n        const routerState = createFlightRouterStateFromLoaderTree(// Create router state using the slice of the loaderTree\n        loaderTreeToFilter, getDynamicParamFromSegment, query);\n        // Create component tree using the slice of the loaderTree\n        const seedData = await createComponentTree(// This ensures flightRouterPath is valid and filters down the tree\n        {\n            ctx,\n            loaderTree: loaderTreeToFilter,\n            parentParams: currentParams,\n            injectedCSS,\n            injectedJS,\n            injectedFontPreloadTags,\n            // This is intentionally not \"rootLayoutIncludedAtThisLevelOrAbove\" as createComponentTree starts at the current level and does a check for \"rootLayoutAtThisLevel\" too.\n            rootLayoutIncluded,\n            getViewportReady,\n            getMetadataReady,\n            preloadCallbacks,\n            authInterrupts: experimental.authInterrupts,\n            StreamingMetadata: null,\n            StreamingMetadataOutlet\n        });\n        return [\n            [\n                overriddenSegment,\n                routerState,\n                seedData,\n                rscHead,\n                false\n            ]\n        ];\n    }\n    // If we are not rendering on this level we need to check if the current\n    // segment has a layout. If so, we need to track all the used CSS to make\n    // the result consistent.\n    const layoutPath = layout == null ? void 0 : layout[1];\n    const injectedCSSWithCurrentLayout = new Set(injectedCSS);\n    const injectedJSWithCurrentLayout = new Set(injectedJS);\n    const injectedFontPreloadTagsWithCurrentLayout = new Set(injectedFontPreloadTags);\n    if (layoutPath) {\n        getLinkAndScriptTags(ctx.clientReferenceManifest, layoutPath, injectedCSSWithCurrentLayout, injectedJSWithCurrentLayout, true);\n        getPreloadableFonts(nextFontManifest, layoutPath, injectedFontPreloadTagsWithCurrentLayout);\n    }\n    const paths = [];\n    // Walk through all parallel routes.\n    for (const parallelRouteKey of parallelRoutesKeys){\n        const parallelRoute = parallelRoutes[parallelRouteKey];\n        const subPaths = await walkTreeWithFlightRouterState({\n            ctx,\n            loaderTreeToFilter: parallelRoute,\n            parentParams: currentParams,\n            flightRouterState: flightRouterState && flightRouterState[1][parallelRouteKey],\n            parentIsInsideSharedLayout: isInsideSharedLayout,\n            rscHead,\n            injectedCSS: injectedCSSWithCurrentLayout,\n            injectedJS: injectedJSWithCurrentLayout,\n            injectedFontPreloadTags: injectedFontPreloadTagsWithCurrentLayout,\n            rootLayoutIncluded: rootLayoutIncludedAtThisLevelOrAbove,\n            getViewportReady,\n            getMetadataReady,\n            preloadCallbacks,\n            StreamingMetadataOutlet\n        });\n        for (const subPath of subPaths){\n            // we don't need to send over default routes in the flight data\n            // because they are always ignored by the client, unless it's a refetch\n            if (subPath[0] === DEFAULT_SEGMENT_KEY && flightRouterState && !!flightRouterState[1][parallelRouteKey][0] && flightRouterState[1][parallelRouteKey][3] !== 'refetch') {\n                continue;\n            }\n            paths.push([\n                actualSegment,\n                parallelRouteKey,\n                ...subPath\n            ]);\n        }\n    }\n    return paths;\n}\n/*\n * This function is used to determine if an existing segment can be overridden\n * by the incoming segment.\n */ const canSegmentBeOverridden = (existingSegment, segment)=>{\n    var _getSegmentParam;\n    if (Array.isArray(existingSegment) || !Array.isArray(segment)) {\n        return false;\n    }\n    return ((_getSegmentParam = getSegmentParam(existingSegment)) == null ? void 0 : _getSegmentParam.param) === segment[0];\n};\n\n//# sourceMappingURL=walk-tree-with-flight-router-state.js.map"
        }
    ]
}