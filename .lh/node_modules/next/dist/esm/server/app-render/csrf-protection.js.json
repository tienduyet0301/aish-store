{
    "sourceFile": "node_modules/next/dist/esm/server/app-render/csrf-protection.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892823112,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "// micromatch is only available at node runtime, so it cannot be used here since the code path that calls this function\n// can be run from edge. This is a simple implementation that safely achieves the required functionality.\n// the goal is to match the functionality for remotePatterns as defined here -\n// https://nextjs.org/docs/app/api-reference/components/image#remotepatterns\n// TODO - retrofit micromatch to work in edge and use that instead\nfunction matchWildcardDomain(domain, pattern) {\n    const domainParts = domain.split('.');\n    const patternParts = pattern.split('.');\n    if (patternParts.length < 1) {\n        // pattern is empty and therefore invalid to match against\n        return false;\n    }\n    if (domainParts.length < patternParts.length) {\n        // domain has too few segments and thus cannot match\n        return false;\n    }\n    // Prevent wildcards from matching entire domains (e.g. '**' or '*.com')\n    // This ensures wildcards can only match subdomains, not the main domain\n    if (patternParts.length === 1 && (patternParts[0] === '*' || patternParts[0] === '**')) {\n        return false;\n    }\n    while(patternParts.length){\n        const patternPart = patternParts.pop();\n        const domainPart = domainParts.pop();\n        switch(patternPart){\n            case '':\n                {\n                    // invalid pattern. pattern segments must be non empty\n                    return false;\n                }\n            case '*':\n                {\n                    // wildcard matches anything so we continue if the domain part is non-empty\n                    if (domainPart) {\n                        continue;\n                    } else {\n                        return false;\n                    }\n                }\n            case '**':\n                {\n                    // if this is not the last item in the pattern the pattern is invalid\n                    if (patternParts.length > 0) {\n                        return false;\n                    }\n                    // recursive wildcard matches anything so we terminate here if the domain part is non empty\n                    return domainPart !== undefined;\n                }\n            default:\n                {\n                    if (domainPart !== patternPart) {\n                        return false;\n                    }\n                }\n        }\n    }\n    // We exhausted the pattern. If we also exhausted the domain we have a match\n    return domainParts.length === 0;\n}\nexport const isCsrfOriginAllowed = (originDomain, allowedOrigins = [])=>{\n    return allowedOrigins.some((allowedOrigin)=>allowedOrigin && (allowedOrigin === originDomain || matchWildcardDomain(originDomain, allowedOrigin)));\n};\n\n//# sourceMappingURL=csrf-protection.js.map"
        }
    ]
}