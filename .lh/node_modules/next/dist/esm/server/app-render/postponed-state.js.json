{
    "sourceFile": "node_modules/next/dist/esm/server/app-render/postponed-state.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892824427,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import { createPrerenderResumeDataCache, createRenderResumeDataCache } from '../resume-data-cache/resume-data-cache';\nimport { stringifyResumeDataCache } from '../resume-data-cache/resume-data-cache';\nexport var DynamicState = /*#__PURE__*/ function(DynamicState) {\n    /**\n   * The dynamic access occurred during the RSC render phase.\n   */ DynamicState[DynamicState[\"DATA\"] = 1] = \"DATA\";\n    /**\n   * The dynamic access occurred during the HTML shell render phase.\n   */ DynamicState[DynamicState[\"HTML\"] = 2] = \"HTML\";\n    return DynamicState;\n}({});\nexport async function getDynamicHTMLPostponedState(data, fallbackRouteParams, prerenderResumeDataCache) {\n    if (!fallbackRouteParams || fallbackRouteParams.size === 0) {\n        const postponedString = JSON.stringify(data);\n        // Serialized as `<postponedString.length>:<postponedString><renderResumeDataCache>`\n        return `${postponedString.length}:${postponedString}${await stringifyResumeDataCache(createRenderResumeDataCache(prerenderResumeDataCache))}`;\n    }\n    const replacements = Array.from(fallbackRouteParams);\n    const replacementsString = JSON.stringify(replacements);\n    const dataString = JSON.stringify(data);\n    // Serialized as `<replacements.length><replacements><data>`\n    const postponedString = `${replacementsString.length}${replacementsString}${dataString}`;\n    // Serialized as `<postponedString.length>:<postponedString><renderResumeDataCache>`\n    return `${postponedString.length}:${postponedString}${await stringifyResumeDataCache(prerenderResumeDataCache)}`;\n}\nexport async function getDynamicDataPostponedState(prerenderResumeDataCache) {\n    return `4:null${await stringifyResumeDataCache(createRenderResumeDataCache(prerenderResumeDataCache))}`;\n}\nexport function parsePostponedState(state, params) {\n    try {\n        var _state_match;\n        const postponedStringLengthMatch = (_state_match = state.match(/^([0-9]*):/)) == null ? void 0 : _state_match[1];\n        if (!postponedStringLengthMatch) {\n            throw Object.defineProperty(new Error(`Invariant: invalid postponed state ${state}`), \"__NEXT_ERROR_CODE\", {\n                value: \"E314\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n        const postponedStringLength = parseInt(postponedStringLengthMatch);\n        // We add a `:` to the end of the length as the first character of the\n        // postponed string is the length of the replacement entries.\n        const postponedString = state.slice(postponedStringLengthMatch.length + 1, postponedStringLengthMatch.length + postponedStringLength + 1);\n        const renderResumeDataCache = createRenderResumeDataCache(state.slice(postponedStringLengthMatch.length + postponedStringLength + 1));\n        try {\n            if (postponedString === 'null') {\n                return {\n                    type: 1,\n                    renderResumeDataCache\n                };\n            }\n            if (/^[0-9]/.test(postponedString)) {\n                var _postponedString_match;\n                const match = (_postponedString_match = postponedString.match(/^([0-9]*)/)) == null ? void 0 : _postponedString_match[1];\n                if (!match) {\n                    throw Object.defineProperty(new Error(`Invariant: invalid postponed state ${JSON.stringify(postponedString)}`), \"__NEXT_ERROR_CODE\", {\n                        value: \"E314\",\n                        enumerable: false,\n                        configurable: true\n                    });\n                }\n                // This is the length of the replacements entries.\n                const length = parseInt(match);\n                const replacements = JSON.parse(postponedString.slice(match.length, // We then go to the end of the string.\n                match.length + length));\n                let postponed = postponedString.slice(match.length + length);\n                for (const [key, searchValue] of replacements){\n                    const value = (params == null ? void 0 : params[key]) ?? '';\n                    const replaceValue = Array.isArray(value) ? value.join('/') : value;\n                    postponed = postponed.replaceAll(searchValue, replaceValue);\n                }\n                return {\n                    type: 2,\n                    data: JSON.parse(postponed),\n                    renderResumeDataCache\n                };\n            }\n            return {\n                type: 2,\n                data: JSON.parse(postponedString),\n                renderResumeDataCache\n            };\n        } catch (err) {\n            console.error('Failed to parse postponed state', err);\n            return {\n                type: 1,\n                renderResumeDataCache\n            };\n        }\n    } catch (err) {\n        console.error('Failed to parse postponed state', err);\n        return {\n            type: 1,\n            renderResumeDataCache: createPrerenderResumeDataCache()\n        };\n    }\n}\nexport function getPostponedFromState(state) {\n    if (state.type === 1) {\n        return null;\n    }\n    return state.data;\n}\n\n//# sourceMappingURL=postponed-state.js.map"
        }
    ]
}