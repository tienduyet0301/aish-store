{
    "sourceFile": "node_modules/next/dist/esm/server/app-render/action-handler.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892820022,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import { RSC_HEADER, RSC_CONTENT_TYPE_HEADER, NEXT_ROUTER_STATE_TREE_HEADER, ACTION_HEADER } from '../../client/components/app-router-headers';\nimport { getAccessFallbackHTTPStatus, isHTTPAccessFallbackError } from '../../client/components/http-access-fallback/http-access-fallback';\nimport { getRedirectTypeFromError, getURLFromRedirectError } from '../../client/components/redirect';\nimport { isRedirectError } from '../../client/components/redirect-error';\nimport RenderResult from '../render-result';\nimport { FlightRenderResult } from './flight-render-result';\nimport { filterReqHeaders, actionsForbiddenHeaders } from '../lib/server-ipc/utils';\nimport { getModifiedCookieValues } from '../web/spec-extension/adapters/request-cookies';\nimport { NEXT_CACHE_REVALIDATED_TAGS_HEADER, NEXT_CACHE_REVALIDATE_TAG_TOKEN_HEADER } from '../../lib/constants';\nimport { getServerActionRequestMetadata } from '../lib/server-action-request-meta';\nimport { isCsrfOriginAllowed } from './csrf-protection';\nimport { warn } from '../../build/output/log';\nimport { RequestCookies, ResponseCookies } from '../web/spec-extension/cookies';\nimport { HeadersAdapter } from '../web/spec-extension/adapters/headers';\nimport { fromNodeOutgoingHttpHeaders } from '../web/utils';\nimport { selectWorkerForForwarding } from './action-utils';\nimport { isNodeNextRequest, isWebNextRequest } from '../base-http/helpers';\nimport { RedirectStatusCode } from '../../client/components/redirect-status-code';\nimport { synchronizeMutableCookies } from '../async-storage/request-store';\nimport { workUnitAsyncStorage } from '../app-render/work-unit-async-storage.external';\nimport { InvariantError } from '../../shared/lib/invariant-error';\nimport { executeRevalidates } from '../revalidation-utils';\nfunction formDataFromSearchQueryString(query) {\n    const searchParams = new URLSearchParams(query);\n    const formData = new FormData();\n    for (const [key, value] of searchParams){\n        formData.append(key, value);\n    }\n    return formData;\n}\nfunction nodeHeadersToRecord(headers) {\n    const record = {};\n    for (const [key, value] of Object.entries(headers)){\n        if (value !== undefined) {\n            record[key] = Array.isArray(value) ? value.join(', ') : `${value}`;\n        }\n    }\n    return record;\n}\nfunction getForwardedHeaders(req, res) {\n    // Get request headers and cookies\n    const requestHeaders = req.headers;\n    const requestCookies = new RequestCookies(HeadersAdapter.from(requestHeaders));\n    // Get response headers and cookies\n    const responseHeaders = res.getHeaders();\n    const responseCookies = new ResponseCookies(fromNodeOutgoingHttpHeaders(responseHeaders));\n    // Merge request and response headers\n    const mergedHeaders = filterReqHeaders({\n        ...nodeHeadersToRecord(requestHeaders),\n        ...nodeHeadersToRecord(responseHeaders)\n    }, actionsForbiddenHeaders);\n    // Merge cookies into requestCookies, so responseCookies always take precedence\n    // and overwrite/delete those from requestCookies.\n    responseCookies.getAll().forEach((cookie)=>{\n        if (typeof cookie.value === 'undefined') {\n            requestCookies.delete(cookie.name);\n        } else {\n            requestCookies.set(cookie);\n        }\n    });\n    // Update the 'cookie' header with the merged cookies\n    mergedHeaders['cookie'] = requestCookies.toString();\n    // Remove headers that should not be forwarded\n    delete mergedHeaders['transfer-encoding'];\n    return new Headers(mergedHeaders);\n}\nfunction addRevalidationHeader(res, { workStore, requestStore }) {\n    var _workStore_pendingRevalidatedTags;\n    // If a tag was revalidated, the client router needs to invalidate all the\n    // client router cache as they may be stale. And if a path was revalidated, the\n    // client needs to invalidate all subtrees below that path.\n    // To keep the header size small, we use a tuple of\n    // [[revalidatedPaths], isTagRevalidated ? 1 : 0, isCookieRevalidated ? 1 : 0]\n    // instead of a JSON object.\n    // TODO-APP: Currently the prefetch cache doesn't have subtree information,\n    // so we need to invalidate the entire cache if a path was revalidated.\n    // TODO-APP: Currently paths are treated as tags, so the second element of the tuple\n    // is always empty.\n    const isTagRevalidated = ((_workStore_pendingRevalidatedTags = workStore.pendingRevalidatedTags) == null ? void 0 : _workStore_pendingRevalidatedTags.length) ? 1 : 0;\n    const isCookieRevalidated = getModifiedCookieValues(requestStore.mutableCookies).length ? 1 : 0;\n    res.setHeader('x-action-revalidated', JSON.stringify([\n        [],\n        isTagRevalidated,\n        isCookieRevalidated\n    ]));\n}\n/**\n * Forwards a server action request to a separate worker. Used when the requested action is not available in the current worker.\n */ async function createForwardedActionResponse(req, res, host, workerPathname, basePath, workStore) {\n    var _workStore_incrementalCache;\n    if (!host) {\n        throw Object.defineProperty(new Error('Invariant: Missing `host` header from a forwarded Server Actions request.'), \"__NEXT_ERROR_CODE\", {\n            value: \"E226\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    const forwardedHeaders = getForwardedHeaders(req, res);\n    // indicate that this action request was forwarded from another worker\n    // we use this to skip rendering the flight tree so that we don't update the UI\n    // with the response from the forwarded worker\n    forwardedHeaders.set('x-action-forwarded', '1');\n    const proto = ((_workStore_incrementalCache = workStore.incrementalCache) == null ? void 0 : _workStore_incrementalCache.requestProtocol) || 'https';\n    // For standalone or the serverful mode, use the internal origin directly\n    // other than the host headers from the request.\n    const origin = process.env.__NEXT_PRIVATE_ORIGIN || `${proto}://${host.value}`;\n    const fetchUrl = new URL(`${origin}${basePath}${workerPathname}`);\n    try {\n        var _response_headers_get;\n        let body;\n        if (// The type check here ensures that `req` is correctly typed, and the\n        // environment variable check provides dead code elimination.\n        process.env.NEXT_RUNTIME === 'edge' && isWebNextRequest(req)) {\n            if (!req.body) {\n                throw Object.defineProperty(new Error('Invariant: missing request body.'), \"__NEXT_ERROR_CODE\", {\n                    value: \"E333\",\n                    enumerable: false,\n                    configurable: true\n                });\n            }\n            body = req.body;\n        } else if (// The type check here ensures that `req` is correctly typed, and the\n        // environment variable check provides dead code elimination.\n        process.env.NEXT_RUNTIME !== 'edge' && isNodeNextRequest(req)) {\n            body = req.stream();\n        } else {\n            throw Object.defineProperty(new Error('Invariant: Unknown request type.'), \"__NEXT_ERROR_CODE\", {\n                value: \"E114\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n        // Forward the request to the new worker\n        const response = await fetch(fetchUrl, {\n            method: 'POST',\n            body,\n            duplex: 'half',\n            headers: forwardedHeaders,\n            redirect: 'manual',\n            next: {\n                // @ts-ignore\n                internal: 1\n            }\n        });\n        if ((_response_headers_get = response.headers.get('content-type')) == null ? void 0 : _response_headers_get.startsWith(RSC_CONTENT_TYPE_HEADER)) {\n            // copy the headers from the redirect response to the response we're sending\n            for (const [key, value] of response.headers){\n                if (!actionsForbiddenHeaders.includes(key)) {\n                    res.setHeader(key, value);\n                }\n            }\n            return new FlightRenderResult(response.body);\n        } else {\n            var // Since we aren't consuming the response body, we cancel it to avoid memory leaks\n            _response_body;\n            (_response_body = response.body) == null ? void 0 : _response_body.cancel();\n        }\n    } catch (err) {\n        // we couldn't stream the forwarded response, so we'll just return an empty response\n        console.error(`failed to forward action response`, err);\n    }\n    return RenderResult.fromStatic('{}');\n}\n/**\n * Returns the parsed redirect URL if we deem that it is hosted by us.\n *\n * We handle both relative and absolute redirect URLs.\n *\n * In case the redirect URL is not relative to the application we return `null`.\n */ function getAppRelativeRedirectUrl(basePath, host, redirectUrl) {\n    if (redirectUrl.startsWith('/') || redirectUrl.startsWith('.')) {\n        // Make sure we are appending the basePath to relative URLS\n        return new URL(`${basePath}${redirectUrl}`, 'http://n');\n    }\n    const parsedRedirectUrl = new URL(redirectUrl);\n    if ((host == null ? void 0 : host.value) !== parsedRedirectUrl.host) {\n        return null;\n    }\n    // At this point the hosts are the same, just confirm we\n    // are routing to a path underneath the `basePath`\n    return parsedRedirectUrl.pathname.startsWith(basePath) ? parsedRedirectUrl : null;\n}\nasync function createRedirectRenderResult(req, res, originalHost, redirectUrl, redirectType, basePath, workStore) {\n    res.setHeader('x-action-redirect', `${redirectUrl};${redirectType}`);\n    // If we're redirecting to another route of this Next.js application, we'll\n    // try to stream the response from the other worker path. When that works,\n    // we can save an extra roundtrip and avoid a full page reload.\n    // When the redirect URL starts with a `/` or is to the same host, under the\n    // `basePath` we treat it as an app-relative redirect;\n    const appRelativeRedirectUrl = getAppRelativeRedirectUrl(basePath, originalHost, redirectUrl);\n    if (appRelativeRedirectUrl) {\n        var _workStore_incrementalCache;\n        if (!originalHost) {\n            throw Object.defineProperty(new Error('Invariant: Missing `host` header from a forwarded Server Actions request.'), \"__NEXT_ERROR_CODE\", {\n                value: \"E226\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n        const forwardedHeaders = getForwardedHeaders(req, res);\n        forwardedHeaders.set(RSC_HEADER, '1');\n        const proto = ((_workStore_incrementalCache = workStore.incrementalCache) == null ? void 0 : _workStore_incrementalCache.requestProtocol) || 'https';\n        // For standalone or the serverful mode, use the internal origin directly\n        // other than the host headers from the request.\n        const origin = process.env.__NEXT_PRIVATE_ORIGIN || `${proto}://${originalHost.value}`;\n        const fetchUrl = new URL(`${origin}${appRelativeRedirectUrl.pathname}${appRelativeRedirectUrl.search}`);\n        if (workStore.pendingRevalidatedTags) {\n            var _workStore_incrementalCache_prerenderManifest_preview, _workStore_incrementalCache_prerenderManifest, _workStore_incrementalCache1;\n            forwardedHeaders.set(NEXT_CACHE_REVALIDATED_TAGS_HEADER, workStore.pendingRevalidatedTags.join(','));\n            forwardedHeaders.set(NEXT_CACHE_REVALIDATE_TAG_TOKEN_HEADER, ((_workStore_incrementalCache1 = workStore.incrementalCache) == null ? void 0 : (_workStore_incrementalCache_prerenderManifest = _workStore_incrementalCache1.prerenderManifest) == null ? void 0 : (_workStore_incrementalCache_prerenderManifest_preview = _workStore_incrementalCache_prerenderManifest.preview) == null ? void 0 : _workStore_incrementalCache_prerenderManifest_preview.previewModeId) || '');\n        }\n        // Ensures that when the path was revalidated we don't return a partial response on redirects\n        forwardedHeaders.delete(NEXT_ROUTER_STATE_TREE_HEADER);\n        // When an action follows a redirect, it's no longer handling an action: it's just a normal RSC request\n        // to the requested URL. We should remove the `next-action` header so that it's not treated as an action\n        forwardedHeaders.delete(ACTION_HEADER);\n        try {\n            var _response_headers_get;\n            const response = await fetch(fetchUrl, {\n                method: 'GET',\n                headers: forwardedHeaders,\n                next: {\n                    // @ts-ignore\n                    internal: 1\n                }\n            });\n            if ((_response_headers_get = response.headers.get('content-type')) == null ? void 0 : _response_headers_get.startsWith(RSC_CONTENT_TYPE_HEADER)) {\n                // copy the headers from the redirect response to the response we're sending\n                for (const [key, value] of response.headers){\n                    if (!actionsForbiddenHeaders.includes(key)) {\n                        res.setHeader(key, value);\n                    }\n                }\n                return new FlightRenderResult(response.body);\n            } else {\n                var // Since we aren't consuming the response body, we cancel it to avoid memory leaks\n                _response_body;\n                (_response_body = response.body) == null ? void 0 : _response_body.cancel();\n            }\n        } catch (err) {\n            // we couldn't stream the redirect response, so we'll just do a normal redirect\n            console.error(`failed to get redirect response`, err);\n        }\n    }\n    return RenderResult.fromStatic('{}');\n}\n;\n/**\n * Ensures the value of the header can't create long logs.\n */ function limitUntrustedHeaderValueForLogs(value) {\n    return value.length > 100 ? value.slice(0, 100) + '...' : value;\n}\nexport function parseHostHeader(headers, originDomain) {\n    var _forwardedHostHeader_split_, _forwardedHostHeader_split;\n    const forwardedHostHeader = headers['x-forwarded-host'];\n    const forwardedHostHeaderValue = forwardedHostHeader && Array.isArray(forwardedHostHeader) ? forwardedHostHeader[0] : forwardedHostHeader == null ? void 0 : (_forwardedHostHeader_split = forwardedHostHeader.split(',')) == null ? void 0 : (_forwardedHostHeader_split_ = _forwardedHostHeader_split[0]) == null ? void 0 : _forwardedHostHeader_split_.trim();\n    const hostHeader = headers['host'];\n    if (originDomain) {\n        return forwardedHostHeaderValue === originDomain ? {\n            type: \"x-forwarded-host\",\n            value: forwardedHostHeaderValue\n        } : hostHeader === originDomain ? {\n            type: \"host\",\n            value: hostHeader\n        } : undefined;\n    }\n    return forwardedHostHeaderValue ? {\n        type: \"x-forwarded-host\",\n        value: forwardedHostHeaderValue\n    } : hostHeader ? {\n        type: \"host\",\n        value: hostHeader\n    } : undefined;\n}\nexport async function handleAction({ req, res, ComponentMod, serverModuleMap, generateFlight, workStore, requestStore, serverActions, ctx }) {\n    const contentType = req.headers['content-type'];\n    const { serverActionsManifest, page } = ctx.renderOpts;\n    const { actionId, isURLEncodedAction, isMultipartAction, isFetchAction, isPossibleServerAction } = getServerActionRequestMetadata(req);\n    // If it can't be a Server Action, skip handling.\n    // Note that this can be a false positive -- any multipart/urlencoded POST can get us here,\n    // But won't know if it's an MPA action or not until we call `decodeAction` below.\n    if (!isPossibleServerAction) {\n        return;\n    }\n    if (workStore.isStaticGeneration) {\n        throw Object.defineProperty(new Error(\"Invariant: server actions can't be handled during static rendering\"), \"__NEXT_ERROR_CODE\", {\n            value: \"E359\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    let temporaryReferences;\n    const finalizeAndGenerateFlight = (...args)=>{\n        // When we switch to the render phase, cookies() will return\n        // `workUnitStore.cookies` instead of `workUnitStore.userspaceMutableCookies`.\n        // We want the render to see any cookie writes that we performed during the action,\n        // so we need to update the immutable cookies to reflect the changes.\n        synchronizeMutableCookies(requestStore);\n        // The server action might have toggled draft mode, so we need to reflect\n        // that in the work store to be up-to-date for subsequent rendering.\n        workStore.isDraftMode = requestStore.draftMode.isEnabled;\n        return generateFlight(...args);\n    };\n    // When running actions the default is no-store, you can still `cache: 'force-cache'`\n    workStore.fetchCache = 'default-no-store';\n    const originDomain = typeof req.headers['origin'] === 'string' ? new URL(req.headers['origin']).host : undefined;\n    const host = parseHostHeader(req.headers);\n    let warning = undefined;\n    function warnBadServerActionRequest() {\n        if (warning) {\n            warn(warning);\n        }\n    }\n    // This is to prevent CSRF attacks. If `x-forwarded-host` is set, we need to\n    // ensure that the request is coming from the same host.\n    if (!originDomain) {\n        // This might be an old browser that doesn't send `host` header. We ignore\n        // this case.\n        warning = 'Missing `origin` header from a forwarded Server Actions request.';\n    } else if (!host || originDomain !== host.value) {\n        // If the customer sets a list of allowed origins, we'll allow the request.\n        // These are considered safe but might be different from forwarded host set\n        // by the infra (i.e. reverse proxies).\n        if (isCsrfOriginAllowed(originDomain, serverActions == null ? void 0 : serverActions.allowedOrigins)) {\n        // Ignore it\n        } else {\n            if (host) {\n                // This seems to be an CSRF attack. We should not proceed the action.\n                console.error(`\\`${host.type}\\` header with value \\`${limitUntrustedHeaderValueForLogs(host.value)}\\` does not match \\`origin\\` header with value \\`${limitUntrustedHeaderValueForLogs(originDomain)}\\` from a forwarded Server Actions request. Aborting the action.`);\n            } else {\n                // This is an attack. We should not proceed the action.\n                console.error(`\\`x-forwarded-host\\` or \\`host\\` headers are not provided. One of these is needed to compare the \\`origin\\` header from a forwarded Server Actions request. Aborting the action.`);\n            }\n            const error = Object.defineProperty(new Error('Invalid Server Actions request.'), \"__NEXT_ERROR_CODE\", {\n                value: \"E80\",\n                enumerable: false,\n                configurable: true\n            });\n            if (isFetchAction) {\n                res.statusCode = 500;\n                await executeRevalidates(workStore);\n                const promise = Promise.reject(error);\n                try {\n                    // we need to await the promise to trigger the rejection early\n                    // so that it's already handled by the time we call\n                    // the RSC runtime. Otherwise, it will throw an unhandled\n                    // promise rejection error in the renderer.\n                    await promise;\n                } catch  {\n                // swallow error, it's gonna be handled on the client\n                }\n                return {\n                    type: 'done',\n                    result: await finalizeAndGenerateFlight(req, ctx, requestStore, {\n                        actionResult: promise,\n                        // if the page was not revalidated, we can skip the rendering the flight tree\n                        skipFlight: !workStore.pathWasRevalidated,\n                        temporaryReferences\n                    })\n                };\n            }\n            throw error;\n        }\n    }\n    // ensure we avoid caching server actions unexpectedly\n    res.setHeader('Cache-Control', 'no-cache, no-store, max-age=0, must-revalidate');\n    let boundActionArguments = [];\n    const { actionAsyncStorage } = ComponentMod;\n    let actionResult;\n    let formState;\n    let actionModId;\n    const actionWasForwarded = Boolean(req.headers['x-action-forwarded']);\n    if (actionId) {\n        const forwardedWorker = selectWorkerForForwarding(actionId, page, serverActionsManifest);\n        // If forwardedWorker is truthy, it means there isn't a worker for the action\n        // in the current handler, so we forward the request to a worker that has the action.\n        if (forwardedWorker) {\n            return {\n                type: 'done',\n                result: await createForwardedActionResponse(req, res, host, forwardedWorker, ctx.renderOpts.basePath, workStore)\n            };\n        }\n    }\n    try {\n        await actionAsyncStorage.run({\n            isAction: true\n        }, async ()=>{\n            if (// The type check here ensures that `req` is correctly typed, and the\n            // environment variable check provides dead code elimination.\n            process.env.NEXT_RUNTIME === 'edge' && isWebNextRequest(req)) {\n                if (!req.body) {\n                    throw Object.defineProperty(new Error('invariant: Missing request body.'), \"__NEXT_ERROR_CODE\", {\n                        value: \"E364\",\n                        enumerable: false,\n                        configurable: true\n                    });\n                }\n                // TODO: add body limit\n                // Use react-server-dom-webpack/server.edge\n                const { createTemporaryReferenceSet, decodeReply, decodeAction, decodeFormState } = ComponentMod;\n                temporaryReferences = createTemporaryReferenceSet();\n                if (isMultipartAction) {\n                    // TODO-APP: Add streaming support\n                    const formData = await req.request.formData();\n                    if (isFetchAction) {\n                        boundActionArguments = await decodeReply(formData, serverModuleMap, {\n                            temporaryReferences\n                        });\n                    } else {\n                        const action = await decodeAction(formData, serverModuleMap);\n                        if (typeof action === 'function') {\n                            // Only warn if it's a server action, otherwise skip for other post requests\n                            warnBadServerActionRequest();\n                            let actionReturnedState;\n                            requestStore.phase = 'action';\n                            try {\n                                actionReturnedState = await workUnitAsyncStorage.run(requestStore, action);\n                            } finally{\n                                requestStore.phase = 'render';\n                            }\n                            formState = await decodeFormState(actionReturnedState, formData, serverModuleMap);\n                        }\n                        // Skip the fetch path\n                        return;\n                    }\n                } else {\n                    try {\n                        actionModId = getActionModIdOrError(actionId, serverModuleMap);\n                    } catch (err) {\n                        if (actionId !== null) {\n                            console.error(err);\n                        }\n                        return {\n                            type: 'not-found'\n                        };\n                    }\n                    const chunks = [];\n                    const reader = req.body.getReader();\n                    while(true){\n                        const { done, value } = await reader.read();\n                        if (done) {\n                            break;\n                        }\n                        chunks.push(value);\n                    }\n                    const actionData = Buffer.concat(chunks).toString('utf-8');\n                    if (isURLEncodedAction) {\n                        const formData = formDataFromSearchQueryString(actionData);\n                        boundActionArguments = await decodeReply(formData, serverModuleMap, {\n                            temporaryReferences\n                        });\n                    } else {\n                        boundActionArguments = await decodeReply(actionData, serverModuleMap, {\n                            temporaryReferences\n                        });\n                    }\n                }\n            } else if (// The type check here ensures that `req` is correctly typed, and the\n            // environment variable check provides dead code elimination.\n            process.env.NEXT_RUNTIME !== 'edge' && isNodeNextRequest(req)) {\n                // Use react-server-dom-webpack/server.node which supports streaming\n                const { createTemporaryReferenceSet, decodeReply, decodeReplyFromBusboy, decodeAction, decodeFormState } = require(`./react-server.node`);\n                temporaryReferences = createTemporaryReferenceSet();\n                const { Transform } = require('node:stream');\n                const defaultBodySizeLimit = '1 MB';\n                const bodySizeLimit = (serverActions == null ? void 0 : serverActions.bodySizeLimit) ?? defaultBodySizeLimit;\n                const bodySizeLimitBytes = bodySizeLimit !== defaultBodySizeLimit ? require('next/dist/compiled/bytes').parse(bodySizeLimit) : 1024 * 1024 // 1 MB\n                ;\n                let size = 0;\n                const body = req.body.pipe(new Transform({\n                    transform (chunk, encoding, callback) {\n                        size += Buffer.byteLength(chunk, encoding);\n                        if (size > bodySizeLimitBytes) {\n                            const { ApiError } = require('../api-utils');\n                            callback(Object.defineProperty(new ApiError(413, `Body exceeded ${bodySizeLimit} limit.\n                To configure the body size limit for Server Actions, see: https://nextjs.org/docs/app/api-reference/next-config-js/serverActions#bodysizelimit`), \"__NEXT_ERROR_CODE\", {\n                                value: \"E394\",\n                                enumerable: false,\n                                configurable: true\n                            }));\n                            return;\n                        }\n                        callback(null, chunk);\n                    }\n                }));\n                if (isMultipartAction) {\n                    if (isFetchAction) {\n                        const busboy = require('busboy')({\n                            defParamCharset: 'utf8',\n                            headers: req.headers,\n                            limits: {\n                                fieldSize: bodySizeLimitBytes\n                            }\n                        });\n                        body.pipe(busboy);\n                        boundActionArguments = await decodeReplyFromBusboy(busboy, serverModuleMap, {\n                            temporaryReferences\n                        });\n                    } else {\n                        // React doesn't yet publish a busboy version of decodeAction\n                        // so we polyfill the parsing of FormData.\n                        const fakeRequest = new Request('http://localhost', {\n                            method: 'POST',\n                            // @ts-expect-error\n                            headers: {\n                                'Content-Type': contentType\n                            },\n                            body: new ReadableStream({\n                                start: (controller)=>{\n                                    body.on('data', (chunk)=>{\n                                        controller.enqueue(new Uint8Array(chunk));\n                                    });\n                                    body.on('end', ()=>{\n                                        controller.close();\n                                    });\n                                    body.on('error', (err)=>{\n                                        controller.error(err);\n                                    });\n                                }\n                            }),\n                            duplex: 'half'\n                        });\n                        const formData = await fakeRequest.formData();\n                        const action = await decodeAction(formData, serverModuleMap);\n                        if (typeof action === 'function') {\n                            // Only warn if it's a server action, otherwise skip for other post requests\n                            warnBadServerActionRequest();\n                            let actionReturnedState;\n                            requestStore.phase = 'action';\n                            try {\n                                actionReturnedState = await workUnitAsyncStorage.run(requestStore, action);\n                            } finally{\n                                requestStore.phase = 'render';\n                            }\n                            formState = await decodeFormState(actionReturnedState, formData, serverModuleMap);\n                        }\n                        // Skip the fetch path\n                        return;\n                    }\n                } else {\n                    try {\n                        actionModId = getActionModIdOrError(actionId, serverModuleMap);\n                    } catch (err) {\n                        if (actionId !== null) {\n                            console.error(err);\n                        }\n                        return {\n                            type: 'not-found'\n                        };\n                    }\n                    const chunks = [];\n                    for await (const chunk of req.body){\n                        chunks.push(Buffer.from(chunk));\n                    }\n                    const actionData = Buffer.concat(chunks).toString('utf-8');\n                    if (isURLEncodedAction) {\n                        const formData = formDataFromSearchQueryString(actionData);\n                        boundActionArguments = await decodeReply(formData, serverModuleMap, {\n                            temporaryReferences\n                        });\n                    } else {\n                        boundActionArguments = await decodeReply(actionData, serverModuleMap, {\n                            temporaryReferences\n                        });\n                    }\n                }\n            } else {\n                throw Object.defineProperty(new Error('Invariant: Unknown request type.'), \"__NEXT_ERROR_CODE\", {\n                    value: \"E114\",\n                    enumerable: false,\n                    configurable: true\n                });\n            }\n            // actions.js\n            // app/page.js\n            //   action worker1\n            //     appRender1\n            // app/foo/page.js\n            //   action worker2\n            //     appRender\n            // / -> fire action -> POST / -> appRender1 -> modId for the action file\n            // /foo -> fire action -> POST /foo -> appRender2 -> modId for the action file\n            try {\n                actionModId = actionModId ?? getActionModIdOrError(actionId, serverModuleMap);\n            } catch (err) {\n                if (actionId !== null) {\n                    console.error(err);\n                }\n                return {\n                    type: 'not-found'\n                };\n            }\n            const actionMod = await ComponentMod.__next_app__.require(actionModId);\n            const actionHandler = actionMod[// `actionId` must exist if we got here, as otherwise we would have thrown an error above\n            actionId];\n            let returnVal;\n            requestStore.phase = 'action';\n            try {\n                returnVal = await workUnitAsyncStorage.run(requestStore, ()=>actionHandler.apply(null, boundActionArguments));\n            } finally{\n                requestStore.phase = 'render';\n            }\n            // For form actions, we need to continue rendering the page.\n            if (isFetchAction) {\n                await executeRevalidates(workStore);\n                addRevalidationHeader(res, {\n                    workStore,\n                    requestStore\n                });\n                actionResult = await finalizeAndGenerateFlight(req, ctx, requestStore, {\n                    actionResult: Promise.resolve(returnVal),\n                    // if the page was not revalidated, or if the action was forwarded from another worker, we can skip the rendering the flight tree\n                    skipFlight: !workStore.pathWasRevalidated || actionWasForwarded,\n                    temporaryReferences\n                });\n            }\n        });\n        return {\n            type: 'done',\n            result: actionResult,\n            formState\n        };\n    } catch (err) {\n        if (isRedirectError(err)) {\n            const redirectUrl = getURLFromRedirectError(err);\n            const redirectType = getRedirectTypeFromError(err);\n            await executeRevalidates(workStore);\n            addRevalidationHeader(res, {\n                workStore,\n                requestStore\n            });\n            // if it's a fetch action, we'll set the status code for logging/debugging purposes\n            // but we won't set a Location header, as the redirect will be handled by the client router\n            res.statusCode = RedirectStatusCode.SeeOther;\n            if (isFetchAction) {\n                return {\n                    type: 'done',\n                    result: await createRedirectRenderResult(req, res, host, redirectUrl, redirectType, ctx.renderOpts.basePath, workStore)\n                };\n            }\n            res.setHeader('Location', redirectUrl);\n            return {\n                type: 'done',\n                result: RenderResult.fromStatic('')\n            };\n        } else if (isHTTPAccessFallbackError(err)) {\n            res.statusCode = getAccessFallbackHTTPStatus(err);\n            await executeRevalidates(workStore);\n            addRevalidationHeader(res, {\n                workStore,\n                requestStore\n            });\n            if (isFetchAction) {\n                const promise = Promise.reject(err);\n                try {\n                    // we need to await the promise to trigger the rejection early\n                    // so that it's already handled by the time we call\n                    // the RSC runtime. Otherwise, it will throw an unhandled\n                    // promise rejection error in the renderer.\n                    await promise;\n                } catch  {\n                // swallow error, it's gonna be handled on the client\n                }\n                return {\n                    type: 'done',\n                    result: await finalizeAndGenerateFlight(req, ctx, requestStore, {\n                        skipFlight: false,\n                        actionResult: promise,\n                        temporaryReferences\n                    })\n                };\n            }\n            return {\n                type: 'not-found'\n            };\n        }\n        if (isFetchAction) {\n            res.statusCode = 500;\n            await executeRevalidates(workStore);\n            const promise = Promise.reject(err);\n            try {\n                // we need to await the promise to trigger the rejection early\n                // so that it's already handled by the time we call\n                // the RSC runtime. Otherwise, it will throw an unhandled\n                // promise rejection error in the renderer.\n                await promise;\n            } catch  {\n            // swallow error, it's gonna be handled on the client\n            }\n            return {\n                type: 'done',\n                result: await generateFlight(req, ctx, requestStore, {\n                    actionResult: promise,\n                    // if the page was not revalidated, or if the action was forwarded from another worker, we can skip the rendering the flight tree\n                    skipFlight: !workStore.pathWasRevalidated || actionWasForwarded,\n                    temporaryReferences\n                })\n            };\n        }\n        throw err;\n    }\n}\n/**\n * Attempts to find the module ID for the action from the module map. When this fails, it could be a deployment skew where\n * the action came from a different deployment. It could also simply be an invalid POST request that is not a server action.\n * In either case, we'll throw an error to be handled by the caller.\n */ function getActionModIdOrError(actionId, serverModuleMap) {\n    var _serverModuleMap_actionId;\n    // if we're missing the action ID header, we can't do any further processing\n    if (!actionId) {\n        throw Object.defineProperty(new InvariantError(\"Missing 'next-action' header.\"), \"__NEXT_ERROR_CODE\", {\n            value: \"E664\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    const actionModId = (_serverModuleMap_actionId = serverModuleMap[actionId]) == null ? void 0 : _serverModuleMap_actionId.id;\n    if (!actionModId) {\n        throw Object.defineProperty(new Error(`Failed to find Server Action \"${actionId}\". This request might be from an older or newer deployment.\\nRead more: https://nextjs.org/docs/messages/failed-to-find-server-action`), \"__NEXT_ERROR_CODE\", {\n            value: \"E665\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    return actionModId;\n}\n\n//# sourceMappingURL=action-handler.js.map"
        }
    ]
}