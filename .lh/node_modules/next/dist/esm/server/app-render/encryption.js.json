{
    "sourceFile": "node_modules/next/dist/esm/server/app-render/encryption.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892823393,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/* eslint-disable import/no-extraneous-dependencies */ import 'server-only';\n/* eslint-disable import/no-extraneous-dependencies */ import { renderToReadableStream } from 'react-server-dom-webpack/server.edge';\n/* eslint-disable import/no-extraneous-dependencies */ import { createFromReadableStream } from 'react-server-dom-webpack/client.edge';\nimport { streamToString } from '../stream-utils/node-web-streams-helper';\nimport { arrayBufferToString, decrypt, encrypt, getActionEncryptionKey, getClientReferenceManifestForRsc, getServerModuleMap, stringToUint8Array } from './encryption-utils';\nimport { getPrerenderResumeDataCache, getRenderResumeDataCache, workUnitAsyncStorage } from './work-unit-async-storage.external';\nimport { createHangingInputAbortSignal } from './dynamic-rendering';\nimport React from 'react';\nconst isEdgeRuntime = process.env.NEXT_RUNTIME === 'edge';\nconst textEncoder = new TextEncoder();\nconst textDecoder = new TextDecoder();\n/**\n * Decrypt the serialized string with the action id as the salt.\n */ async function decodeActionBoundArg(actionId, arg) {\n    const key = await getActionEncryptionKey();\n    if (typeof key === 'undefined') {\n        throw Object.defineProperty(new Error(`Missing encryption key for Server Action. This is a bug in Next.js`), \"__NEXT_ERROR_CODE\", {\n            value: \"E65\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    // Get the iv (16 bytes) and the payload from the arg.\n    const originalPayload = atob(arg);\n    const ivValue = originalPayload.slice(0, 16);\n    const payload = originalPayload.slice(16);\n    const decrypted = textDecoder.decode(await decrypt(key, stringToUint8Array(ivValue), stringToUint8Array(payload)));\n    if (!decrypted.startsWith(actionId)) {\n        throw Object.defineProperty(new Error('Invalid Server Action payload: failed to decrypt.'), \"__NEXT_ERROR_CODE\", {\n            value: \"E191\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    return decrypted.slice(actionId.length);\n}\n/**\n * Encrypt the serialized string with the action id as the salt. Add a prefix to\n * later ensure that the payload is correctly decrypted, similar to a checksum.\n */ async function encodeActionBoundArg(actionId, arg) {\n    const key = await getActionEncryptionKey();\n    if (key === undefined) {\n        throw Object.defineProperty(new Error(`Missing encryption key for Server Action. This is a bug in Next.js`), \"__NEXT_ERROR_CODE\", {\n            value: \"E65\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    // Get 16 random bytes as iv.\n    const randomBytes = new Uint8Array(16);\n    workUnitAsyncStorage.exit(()=>crypto.getRandomValues(randomBytes));\n    const ivValue = arrayBufferToString(randomBytes.buffer);\n    const encrypted = await encrypt(key, randomBytes, textEncoder.encode(actionId + arg));\n    return btoa(ivValue + arrayBufferToString(encrypted));\n}\n// Encrypts the action's bound args into a string. For the same combination of\n// actionId and args the same cached promise is returned. This ensures reference\n// equality for returned objects from \"use cache\" functions when they're invoked\n// multiple times within one render pass using the same bound args.\nexport const encryptActionBoundArgs = React.cache(async function encryptActionBoundArgs(actionId, ...args) {\n    const { clientModules } = getClientReferenceManifestForRsc();\n    // Create an error before any asynchronous calls, to capture the original\n    // call stack in case we need it when the serialization errors.\n    const error = new Error();\n    Error.captureStackTrace(error, encryptActionBoundArgs);\n    let didCatchError = false;\n    const workUnitStore = workUnitAsyncStorage.getStore();\n    const hangingInputAbortSignal = (workUnitStore == null ? void 0 : workUnitStore.type) === 'prerender' ? createHangingInputAbortSignal(workUnitStore) : undefined;\n    // Using Flight to serialize the args into a string.\n    const serialized = await streamToString(renderToReadableStream(args, clientModules, {\n        signal: hangingInputAbortSignal,\n        onError (err) {\n            if (hangingInputAbortSignal == null ? void 0 : hangingInputAbortSignal.aborted) {\n                return;\n            }\n            // We're only reporting one error at a time, starting with the first.\n            if (didCatchError) {\n                return;\n            }\n            didCatchError = true;\n            // Use the original error message together with the previously created\n            // stack, because err.stack is a useless Flight Server call stack.\n            error.message = err instanceof Error ? err.message : String(err);\n        }\n    }), // We pass the abort signal to `streamToString` so that no chunks are\n    // included that are emitted after the signal was already aborted. This\n    // ensures that we can encode hanging promises.\n    hangingInputAbortSignal);\n    if (didCatchError) {\n        if (process.env.NODE_ENV === 'development') {\n            // Logging the error is needed for server functions that are passed to the\n            // client where the decryption is not done during rendering. Console\n            // replaying allows us to still show the error dev overlay in this case.\n            console.error(error);\n        }\n        throw error;\n    }\n    if (!workUnitStore) {\n        return encodeActionBoundArg(actionId, serialized);\n    }\n    const prerenderResumeDataCache = getPrerenderResumeDataCache(workUnitStore);\n    const renderResumeDataCache = getRenderResumeDataCache(workUnitStore);\n    const cacheKey = actionId + serialized;\n    const cachedEncrypted = (prerenderResumeDataCache == null ? void 0 : prerenderResumeDataCache.encryptedBoundArgs.get(cacheKey)) ?? (renderResumeDataCache == null ? void 0 : renderResumeDataCache.encryptedBoundArgs.get(cacheKey));\n    if (cachedEncrypted) {\n        return cachedEncrypted;\n    }\n    const cacheSignal = workUnitStore.type === 'prerender' ? workUnitStore.cacheSignal : undefined;\n    cacheSignal == null ? void 0 : cacheSignal.beginRead();\n    const encrypted = await encodeActionBoundArg(actionId, serialized);\n    cacheSignal == null ? void 0 : cacheSignal.endRead();\n    prerenderResumeDataCache == null ? void 0 : prerenderResumeDataCache.encryptedBoundArgs.set(cacheKey, encrypted);\n    return encrypted;\n});\n// Decrypts the action's bound args from the encrypted string.\nexport async function decryptActionBoundArgs(actionId, encryptedPromise) {\n    const encrypted = await encryptedPromise;\n    const workUnitStore = workUnitAsyncStorage.getStore();\n    let decrypted;\n    if (workUnitStore) {\n        const cacheSignal = workUnitStore.type === 'prerender' ? workUnitStore.cacheSignal : undefined;\n        const prerenderResumeDataCache = getPrerenderResumeDataCache(workUnitStore);\n        const renderResumeDataCache = getRenderResumeDataCache(workUnitStore);\n        decrypted = (prerenderResumeDataCache == null ? void 0 : prerenderResumeDataCache.decryptedBoundArgs.get(encrypted)) ?? (renderResumeDataCache == null ? void 0 : renderResumeDataCache.decryptedBoundArgs.get(encrypted));\n        if (!decrypted) {\n            cacheSignal == null ? void 0 : cacheSignal.beginRead();\n            decrypted = await decodeActionBoundArg(actionId, encrypted);\n            cacheSignal == null ? void 0 : cacheSignal.endRead();\n            prerenderResumeDataCache == null ? void 0 : prerenderResumeDataCache.decryptedBoundArgs.set(encrypted, decrypted);\n        }\n    } else {\n        decrypted = await decodeActionBoundArg(actionId, encrypted);\n    }\n    const { edgeRscModuleMapping, rscModuleMapping } = getClientReferenceManifestForRsc();\n    // Using Flight to deserialize the args from the string.\n    const deserialized = await createFromReadableStream(new ReadableStream({\n        start (controller) {\n            controller.enqueue(textEncoder.encode(decrypted));\n            if ((workUnitStore == null ? void 0 : workUnitStore.type) === 'prerender') {\n                // Explicitly don't close the stream here (until prerendering is\n                // complete) so that hanging promises are not rejected.\n                if (workUnitStore.renderSignal.aborted) {\n                    controller.close();\n                } else {\n                    workUnitStore.renderSignal.addEventListener('abort', ()=>controller.close(), {\n                        once: true\n                    });\n                }\n            } else {\n                controller.close();\n            }\n        }\n    }), {\n        serverConsumerManifest: {\n            // moduleLoading must be null because we don't want to trigger preloads of ClientReferences\n            // to be added to the current execution. Instead, we'll wait for any ClientReference\n            // to be emitted which themselves will handle the preloading.\n            moduleLoading: null,\n            moduleMap: isEdgeRuntime ? edgeRscModuleMapping : rscModuleMapping,\n            serverModuleMap: getServerModuleMap()\n        }\n    });\n    return deserialized;\n}\n\n//# sourceMappingURL=encryption.js.map"
        }
    ]
}