{
    "sourceFile": "node_modules/next/dist/esm/server/app-render/cache-signal.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892822642,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * This class is used to detect when all cache reads for a given render are settled.\n * We do this to allow for cache warming the prerender without having to continue rendering\n * the remainder of the page. This feature is really only useful when the dynamicIO flag is on\n * and should only be used in codepaths gated with this feature.\n */ export class CacheSignal {\n    constructor(){\n        this.count = 0;\n        this.earlyListeners = [];\n        this.listeners = [];\n        this.tickPending = false;\n        this.taskPending = false;\n    }\n    noMorePendingCaches() {\n        if (!this.tickPending) {\n            this.tickPending = true;\n            process.nextTick(()=>{\n                this.tickPending = false;\n                if (this.count === 0) {\n                    for(let i = 0; i < this.earlyListeners.length; i++){\n                        this.earlyListeners[i]();\n                    }\n                    this.earlyListeners.length = 0;\n                }\n            });\n        }\n        if (!this.taskPending) {\n            this.taskPending = true;\n            setTimeout(()=>{\n                this.taskPending = false;\n                if (this.count === 0) {\n                    for(let i = 0; i < this.listeners.length; i++){\n                        this.listeners[i]();\n                    }\n                    this.listeners.length = 0;\n                }\n            }, 0);\n        }\n    }\n    /**\n   * This promise waits until there are no more in progress cache reads but no later.\n   * This allows for adding more cache reads after to delay cacheReady.\n   */ inputReady() {\n        return new Promise((resolve)=>{\n            this.earlyListeners.push(resolve);\n            if (this.count === 0) {\n                this.noMorePendingCaches();\n            }\n        });\n    }\n    /**\n   * If there are inflight cache reads this Promise can resolve in a microtask however\n   * if there are no inflight cache reads then we wait at least one task to allow initial\n   * cache reads to be initiated.\n   */ cacheReady() {\n        return new Promise((resolve)=>{\n            this.listeners.push(resolve);\n            if (this.count === 0) {\n                this.noMorePendingCaches();\n            }\n        });\n    }\n    beginRead() {\n        this.count++;\n    }\n    endRead() {\n        // If this is the last read we need to wait a task before we can claim the cache is settled.\n        // The cache read will likely ping a Server Component which can read from the cache again and this\n        // will play out in a microtask so we need to only resolve pending listeners if we're still at 0\n        // after at least one task.\n        // We only want one task scheduled at a time so when we hit count 1 we don't decrement the counter immediately.\n        // If intervening reads happen before the scheduled task runs they will never observe count 1 preventing reentrency\n        this.count--;\n        if (this.count === 0) {\n            this.noMorePendingCaches();\n        }\n    }\n}\n\n//# sourceMappingURL=cache-signal.js.map"
        }
    ]
}