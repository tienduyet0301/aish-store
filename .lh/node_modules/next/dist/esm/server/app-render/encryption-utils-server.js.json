{
    "sourceFile": "node_modules/next/dist/esm/server/app-render/encryption-utils-server.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892823278,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "// This file should never be bundled into application's runtime code and should\n// stay in the Next.js server.\nimport path from 'path';\nimport fs from 'fs';\nimport { getStorageDirectory } from '../cache-dir';\nimport { arrayBufferToString } from './encryption-utils';\n// Keep the key in memory as it should never change during the lifetime of the server in\n// both development and production.\nlet __next_encryption_key_generation_promise = null;\nconst CONFIG_FILE = '.rscinfo';\nconst ENCRYPTION_KEY = 'encryption.key';\nconst ENCRYPTION_EXPIRE_AT = 'encryption.expire_at';\nconst EXPIRATION = 1000 * 60 * 60 * 24 * 14 // 14 days\n;\nasync function writeCache(distDir, configValue) {\n    const cacheBaseDir = getStorageDirectory(distDir);\n    if (!cacheBaseDir) return;\n    const configPath = path.join(cacheBaseDir, CONFIG_FILE);\n    if (!fs.existsSync(cacheBaseDir)) {\n        await fs.promises.mkdir(cacheBaseDir, {\n            recursive: true\n        });\n    }\n    await fs.promises.writeFile(configPath, JSON.stringify({\n        [ENCRYPTION_KEY]: configValue,\n        [ENCRYPTION_EXPIRE_AT]: Date.now() + EXPIRATION\n    }));\n}\n// This utility is used to get a key for the cache directory. If the\n// key is not present, it will generate a new one and store it in the\n// cache directory inside dist.\n// The key will also expire after a certain amount of time. Once it\n// expires, a new one will be generated.\n// During the lifetime of the server, it will be reused and never refreshed.\nasync function loadOrGenerateKey(distDir, isBuild, generateKey) {\n    const cacheBaseDir = getStorageDirectory(distDir);\n    if (!cacheBaseDir) {\n        // There's no persistent storage available. We generate a new key.\n        // This also covers development time.\n        return await generateKey();\n    }\n    const configPath = path.join(cacheBaseDir, CONFIG_FILE);\n    async function hasCachedKey() {\n        if (!fs.existsSync(configPath)) return false;\n        try {\n            const config = JSON.parse(await fs.promises.readFile(configPath, 'utf8'));\n            if (!config) return false;\n            if (typeof config[ENCRYPTION_KEY] !== 'string' || typeof config[ENCRYPTION_EXPIRE_AT] !== 'number') {\n                return false;\n            }\n            // For build time, we need to rotate the key if it's expired. Otherwise\n            // (next start) we have to keep the key as it is so the runtime key matches\n            // the build time key.\n            if (isBuild && config[ENCRYPTION_EXPIRE_AT] < Date.now()) {\n                return false;\n            }\n            const cachedKey = config[ENCRYPTION_KEY];\n            // If encryption key is provided via env, and it's not same as valid cache,\n            //  we should not use the cached key and respect the env key.\n            if (cachedKey && process.env.NEXT_SERVER_ACTIONS_ENCRYPTION_KEY && cachedKey !== process.env.NEXT_SERVER_ACTIONS_ENCRYPTION_KEY) {\n                return false;\n            }\n            return cachedKey;\n        } catch  {\n            // Broken config file. We should generate a new key and overwrite it.\n            return false;\n        }\n    }\n    const maybeValidKey = await hasCachedKey();\n    if (typeof maybeValidKey === 'string') {\n        return maybeValidKey;\n    }\n    const key = await generateKey();\n    await writeCache(distDir, key);\n    return key;\n}\nexport async function generateEncryptionKeyBase64({ isBuild, distDir }) {\n    // This avoids it being generated multiple times in parallel.\n    if (!__next_encryption_key_generation_promise) {\n        __next_encryption_key_generation_promise = loadOrGenerateKey(distDir, isBuild, async ()=>{\n            const providedKey = process.env.NEXT_SERVER_ACTIONS_ENCRYPTION_KEY;\n            if (providedKey) {\n                return providedKey;\n            }\n            const key = await crypto.subtle.generateKey({\n                name: 'AES-GCM',\n                length: 256\n            }, true, [\n                'encrypt',\n                'decrypt'\n            ]);\n            const exported = await crypto.subtle.exportKey('raw', key);\n            return btoa(arrayBufferToString(exported));\n        });\n    }\n    return __next_encryption_key_generation_promise;\n}\n\n//# sourceMappingURL=encryption-utils-server.js.map"
        }
    ]
}