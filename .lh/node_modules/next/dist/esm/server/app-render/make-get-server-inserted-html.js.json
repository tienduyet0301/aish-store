{
    "sourceFile": "node_modules/next/dist/esm/server/app-render/make-get-server-inserted-html.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892824106,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from \"react/jsx-runtime\";\nimport React from 'react';\nimport { isHTTPAccessFallbackError } from '../../client/components/http-access-fallback/http-access-fallback';\nimport { getURLFromRedirectError, getRedirectStatusCodeFromError } from '../../client/components/redirect';\nimport { isRedirectError } from '../../client/components/redirect-error';\nimport { renderToReadableStream } from 'react-dom/server.edge';\nimport { streamToString } from '../stream-utils/node-web-streams-helper';\nimport { RedirectStatusCode } from '../../client/components/redirect-status-code';\nimport { addPathPrefix } from '../../shared/lib/router/utils/add-path-prefix';\nexport function makeGetServerInsertedHTML({ polyfills, renderServerInsertedHTML, serverCapturedErrors, tracingMetadata, basePath }) {\n    let flushedErrorMetaTagsUntilIndex = 0;\n    // flag for static content that only needs to be flushed once\n    let hasFlushedInitially = false;\n    const polyfillTags = polyfills.map((polyfill)=>{\n        return /*#__PURE__*/ _jsx(\"script\", {\n            ...polyfill\n        }, polyfill.src);\n    });\n    return async function getServerInsertedHTML() {\n        // Loop through all the errors that have been captured but not yet\n        // flushed.\n        const errorMetaTags = [];\n        while(flushedErrorMetaTagsUntilIndex < serverCapturedErrors.length){\n            const error = serverCapturedErrors[flushedErrorMetaTagsUntilIndex];\n            flushedErrorMetaTagsUntilIndex++;\n            if (isHTTPAccessFallbackError(error)) {\n                errorMetaTags.push(/*#__PURE__*/ _jsx(\"meta\", {\n                    name: \"robots\",\n                    content: \"noindex\"\n                }, error.digest), process.env.NODE_ENV === 'development' ? /*#__PURE__*/ _jsx(\"meta\", {\n                    name: \"next-error\",\n                    content: \"not-found\"\n                }, \"next-error\") : null);\n            } else if (isRedirectError(error)) {\n                const redirectUrl = addPathPrefix(getURLFromRedirectError(error), basePath);\n                const statusCode = getRedirectStatusCodeFromError(error);\n                const isPermanent = statusCode === RedirectStatusCode.PermanentRedirect ? true : false;\n                if (redirectUrl) {\n                    errorMetaTags.push(/*#__PURE__*/ _jsx(\"meta\", {\n                        id: \"__next-page-redirect\",\n                        httpEquiv: \"refresh\",\n                        content: `${isPermanent ? 0 : 1};url=${redirectUrl}`\n                    }, error.digest));\n                }\n            }\n        }\n        const traceMetaTags = (tracingMetadata || []).map(({ key, value }, index)=>/*#__PURE__*/ _jsx(\"meta\", {\n                name: key,\n                content: value\n            }, `next-trace-data-${index}`));\n        const serverInsertedHTML = renderServerInsertedHTML();\n        // Skip React rendering if we know the content is empty.\n        if (polyfillTags.length === 0 && traceMetaTags.length === 0 && errorMetaTags.length === 0 && Array.isArray(serverInsertedHTML) && serverInsertedHTML.length === 0) {\n            return '';\n        }\n        const stream = await renderToReadableStream(/*#__PURE__*/ _jsxs(_Fragment, {\n            children: [\n                /* Insert the polyfills if they haven't been flushed yet. */ hasFlushedInitially ? null : polyfillTags,\n                serverInsertedHTML,\n                hasFlushedInitially ? null : traceMetaTags,\n                errorMetaTags\n            ]\n        }), {\n            // Larger chunk because this isn't sent over the network.\n            // Let's set it to 1MB.\n            progressiveChunkSize: 1024 * 1024\n        });\n        hasFlushedInitially = true;\n        // There's no need to wait for the stream to be ready\n        // e.g. calling `await stream.allReady` because `streamToString` will\n        // wait and decode the stream progressively with better parallelism.\n        return streamToString(stream);\n    };\n}\n\n//# sourceMappingURL=make-get-server-inserted-html.js.map"
        }
    ]
}