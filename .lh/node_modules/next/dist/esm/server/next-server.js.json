{
    "sourceFile": "node_modules/next/dist/esm/server/next-server.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892834229,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import './node-environment';\nimport './require-hook';\nimport './node-polyfill-crypto';\nimport { DecodeError, PageNotFoundError, MiddlewareNotFoundError } from '../shared/lib/utils';\nimport fs from 'fs';\nimport { join, resolve } from 'path';\nimport { getRouteMatcher } from '../shared/lib/router/utils/route-matcher';\nimport { addRequestMeta, getRequestMeta } from './request-meta';\nimport { PAGES_MANIFEST, BUILD_ID_FILE, MIDDLEWARE_MANIFEST, PRERENDER_MANIFEST, ROUTES_MANIFEST, CLIENT_PUBLIC_FILES_PATH, APP_PATHS_MANIFEST, SERVER_DIRECTORY, NEXT_FONT_MANIFEST, PHASE_PRODUCTION_BUILD, UNDERSCORE_NOT_FOUND_ROUTE_ENTRY, FUNCTIONS_CONFIG_MANIFEST } from '../shared/lib/constants';\nimport { findDir } from '../lib/find-pages-dir';\nimport { NodeNextRequest, NodeNextResponse } from './base-http/node';\nimport { sendRenderResult } from './send-payload';\nimport { parseUrl } from '../shared/lib/router/utils/parse-url';\nimport * as Log from '../build/output/log';\nimport BaseServer, { NoFallbackError } from './base-server';\nimport { getMaybePagePath, getPagePath } from './require';\nimport { denormalizePagePath } from '../shared/lib/page-path/denormalize-page-path';\nimport { normalizePagePath } from '../shared/lib/page-path/normalize-page-path';\nimport { loadComponents } from './load-components';\nimport isError, { getProperError } from '../lib/is-error';\nimport { splitCookiesString, toNodeOutgoingHttpHeaders } from './web/utils';\nimport { getMiddlewareRouteMatcher } from '../shared/lib/router/utils/middleware-route-matcher';\nimport { loadEnvConfig } from '@next/env';\nimport { urlQueryToSearchParams } from '../shared/lib/router/utils/querystring';\nimport { removeTrailingSlash } from '../shared/lib/router/utils/remove-trailing-slash';\nimport { getNextPathnameInfo } from '../shared/lib/router/utils/get-next-pathname-info';\nimport { getCloneableBody } from './body-streams';\nimport { checkIsOnDemandRevalidate } from './api-utils';\nimport ResponseCache, { CachedRouteKind } from './response-cache';\nimport { IncrementalCache } from './lib/incremental-cache';\nimport { normalizeAppPath } from '../shared/lib/router/utils/app-paths';\nimport { setHttpClientAndAgentOptions } from './setup-http-agent-env';\nimport { isPagesAPIRouteMatch } from './route-matches/pages-api-route-match';\nimport { INSTRUMENTATION_HOOK_FILENAME } from '../lib/constants';\nimport { BubbledError, getTracer } from './lib/trace/tracer';\nimport { NextNodeServerSpan } from './lib/trace/constants';\nimport { nodeFs } from './lib/node-fs-methods';\nimport { getRouteRegex } from '../shared/lib/router/utils/route-regex';\nimport { pipeToNodeResponse } from './pipe-readable';\nimport { createRequestResponseMocks } from './lib/mock-request';\nimport { NEXT_RSC_UNION_QUERY } from '../client/components/app-router-headers';\nimport { signalFromNodeResponse } from './web/spec-extension/adapters/next-request';\nimport { RouteModuleLoader } from './lib/module-loader/route-module-loader';\nimport { loadManifest } from './load-manifest';\nimport { lazyRenderAppPage } from './route-modules/app-page/module.render';\nimport { lazyRenderPagesPage } from './route-modules/pages/module.render';\nimport { interopDefault } from '../lib/interop-default';\nimport { formatDynamicImportPath } from '../lib/format-dynamic-import-path';\nimport { isInterceptionRouteRewrite } from '../lib/generate-interception-routes-rewrites';\nimport { RouteKind } from './route-kind';\nimport { InvariantError } from '../shared/lib/invariant-error';\nimport { AwaiterOnce } from './after/awaiter';\nimport { AsyncCallbackSet } from './lib/async-callback-set';\nimport { initializeCacheHandlers, setCacheHandler } from './use-cache/handlers';\nimport { populateStaticEnv } from '../lib/static-env';\nexport * from './base-server';\n// For module that can be both CJS or ESM\nconst dynamicImportEsmDefault = process.env.NEXT_MINIMAL ? (id)=>import(/* webpackIgnore: true */ id).then((mod)=>mod.default || mod) : (id)=>import(id).then((mod)=>mod.default || mod);\n// For module that will be compiled to CJS, e.g. instrument\nconst dynamicRequire = process.env.NEXT_MINIMAL ? __non_webpack_require__ : require;\nconst MiddlewareMatcherCache = new WeakMap();\nfunction getMiddlewareMatcher(info) {\n    const stored = MiddlewareMatcherCache.get(info);\n    if (stored) {\n        return stored;\n    }\n    if (!Array.isArray(info.matchers)) {\n        throw Object.defineProperty(new Error(`Invariant: invalid matchers for middleware ${JSON.stringify(info)}`), \"__NEXT_ERROR_CODE\", {\n            value: \"E257\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    const matcher = getMiddlewareRouteMatcher(info.matchers);\n    MiddlewareMatcherCache.set(info, matcher);\n    return matcher;\n}\nexport default class NextNodeServer extends BaseServer {\n    constructor(options){\n        var _options_conf_experimental_sri, _options_conf_experimental;\n        // Initialize super class\n        super(options), this.registeredInstrumentation = false, this.cleanupListeners = new AsyncCallbackSet(), this.handleNextImageRequest = async (req, res, parsedUrl)=>{\n            if (!parsedUrl.pathname || !parsedUrl.pathname.startsWith('/_next/image')) {\n                return false;\n            }\n            // Ignore if its a middleware request\n            if (getRequestMeta(req, 'middlewareInvoke')) {\n                return false;\n            }\n            if (this.minimalMode || this.nextConfig.output === 'export' || process.env.NEXT_MINIMAL) {\n                res.statusCode = 400;\n                res.body('Bad Request').send();\n                return true;\n            // the `else` branch is needed for tree-shaking\n            } else {\n                const { ImageOptimizerCache } = require('./image-optimizer');\n                const imageOptimizerCache = new ImageOptimizerCache({\n                    distDir: this.distDir,\n                    nextConfig: this.nextConfig\n                });\n                const { sendResponse, ImageError } = require('./image-optimizer');\n                if (!this.imageResponseCache) {\n                    throw Object.defineProperty(new Error('invariant image optimizer cache was not initialized'), \"__NEXT_ERROR_CODE\", {\n                        value: \"E160\",\n                        enumerable: false,\n                        configurable: true\n                    });\n                }\n                const imagesConfig = this.nextConfig.images;\n                if (imagesConfig.loader !== 'default' || imagesConfig.unoptimized) {\n                    await this.render404(req, res);\n                    return true;\n                }\n                const paramsResult = ImageOptimizerCache.validateParams(req.originalRequest, parsedUrl.query, this.nextConfig, !!this.renderOpts.dev);\n                if ('errorMessage' in paramsResult) {\n                    res.statusCode = 400;\n                    res.body(paramsResult.errorMessage).send();\n                    return true;\n                }\n                const cacheKey = ImageOptimizerCache.getCacheKey(paramsResult);\n                try {\n                    var _cacheEntry_value, _cacheEntry_cacheControl;\n                    const { getExtension } = require('./serve-static');\n                    const cacheEntry = await this.imageResponseCache.get(cacheKey, async ({ previousCacheEntry })=>{\n                        const { buffer, contentType, maxAge, upstreamEtag, etag } = await this.imageOptimizer(req, res, paramsResult, previousCacheEntry);\n                        return {\n                            value: {\n                                kind: CachedRouteKind.IMAGE,\n                                buffer,\n                                etag,\n                                extension: getExtension(contentType),\n                                upstreamEtag\n                            },\n                            isFallback: false,\n                            cacheControl: {\n                                revalidate: maxAge,\n                                expire: undefined\n                            }\n                        };\n                    }, {\n                        routeKind: RouteKind.IMAGE,\n                        incrementalCache: imageOptimizerCache,\n                        isFallback: false\n                    });\n                    if ((cacheEntry == null ? void 0 : (_cacheEntry_value = cacheEntry.value) == null ? void 0 : _cacheEntry_value.kind) !== CachedRouteKind.IMAGE) {\n                        throw Object.defineProperty(new Error('invariant did not get entry from image response cache'), \"__NEXT_ERROR_CODE\", {\n                            value: \"E518\",\n                            enumerable: false,\n                            configurable: true\n                        });\n                    }\n                    sendResponse(req.originalRequest, res.originalResponse, paramsResult.href, cacheEntry.value.extension, cacheEntry.value.buffer, cacheEntry.value.etag, paramsResult.isStatic, cacheEntry.isMiss ? 'MISS' : cacheEntry.isStale ? 'STALE' : 'HIT', imagesConfig, ((_cacheEntry_cacheControl = cacheEntry.cacheControl) == null ? void 0 : _cacheEntry_cacheControl.revalidate) || 0, Boolean(this.renderOpts.dev));\n                    return true;\n                } catch (err) {\n                    if (err instanceof ImageError) {\n                        res.statusCode = err.statusCode;\n                        res.body(err.message).send();\n                        return true;\n                    }\n                    throw err;\n                }\n            }\n        }, this.handleCatchallRenderRequest = async (req, res, parsedUrl)=>{\n            let { pathname, query } = parsedUrl;\n            if (!pathname) {\n                throw Object.defineProperty(new Error('Invariant: pathname is undefined'), \"__NEXT_ERROR_CODE\", {\n                    value: \"E409\",\n                    enumerable: false,\n                    configurable: true\n                });\n            }\n            // This is a catch-all route, there should be no fallbacks so mark it as\n            // such.\n            addRequestMeta(req, 'bubbleNoFallback', true);\n            try {\n                var _this_i18nProvider;\n                // next.js core assumes page path without trailing slash\n                pathname = removeTrailingSlash(pathname);\n                const options = {\n                    i18n: (_this_i18nProvider = this.i18nProvider) == null ? void 0 : _this_i18nProvider.fromRequest(req, pathname)\n                };\n                const match = await this.matchers.match(pathname, options);\n                // If we don't have a match, try to render it anyways.\n                if (!match) {\n                    await this.render(req, res, pathname, query, parsedUrl, true);\n                    return true;\n                }\n                // Add the match to the request so we don't have to re-run the matcher\n                // for the same request.\n                addRequestMeta(req, 'match', match);\n                // TODO-APP: move this to a route handler\n                const edgeFunctionsPages = this.getEdgeFunctionsPages();\n                for (const edgeFunctionsPage of edgeFunctionsPages){\n                    // If the page doesn't match the edge function page, skip it.\n                    if (edgeFunctionsPage !== match.definition.page) continue;\n                    if (this.nextConfig.output === 'export') {\n                        await this.render404(req, res, parsedUrl);\n                        return true;\n                    }\n                    delete query[NEXT_RSC_UNION_QUERY];\n                    // If we handled the request, we can return early.\n                    // For api routes edge runtime\n                    try {\n                        const handled = await this.runEdgeFunction({\n                            req,\n                            res,\n                            query,\n                            params: match.params,\n                            page: match.definition.page,\n                            match,\n                            appPaths: null\n                        });\n                        if (handled) return true;\n                    } catch (apiError) {\n                        await this.instrumentationOnRequestError(apiError, req, {\n                            routePath: match.definition.page,\n                            routerKind: 'Pages Router',\n                            routeType: 'route',\n                            // Edge runtime does not support ISR\n                            revalidateReason: undefined\n                        });\n                        throw apiError;\n                    }\n                }\n                // If the route was detected as being a Pages API route, then handle\n                // it.\n                // TODO: move this behavior into a route handler.\n                if (isPagesAPIRouteMatch(match)) {\n                    if (this.nextConfig.output === 'export') {\n                        await this.render404(req, res, parsedUrl);\n                        return true;\n                    }\n                    const handled = await this.handleApiRequest(req, res, query, match);\n                    if (handled) return true;\n                }\n                await this.render(req, res, pathname, query, parsedUrl, true);\n                return true;\n            } catch (err) {\n                if (err instanceof NoFallbackError) {\n                    throw err;\n                }\n                try {\n                    if (this.renderOpts.dev) {\n                        const { formatServerError } = require('../lib/format-server-error');\n                        formatServerError(err);\n                        this.logErrorWithOriginalStack(err);\n                    } else {\n                        this.logError(err);\n                    }\n                    res.statusCode = 500;\n                    await this.renderError(err, req, res, pathname, query);\n                    return true;\n                } catch  {}\n                throw err;\n            }\n        }, this.handleCatchallMiddlewareRequest = async (req, res, parsed)=>{\n            const isMiddlewareInvoke = getRequestMeta(req, 'middlewareInvoke');\n            if (!isMiddlewareInvoke) {\n                return false;\n            }\n            const handleFinished = ()=>{\n                addRequestMeta(req, 'middlewareInvoke', true);\n                res.body('').send();\n                return true;\n            };\n            const middleware = await this.getMiddleware();\n            if (!middleware) {\n                return handleFinished();\n            }\n            const initUrl = getRequestMeta(req, 'initURL');\n            const parsedUrl = parseUrl(initUrl);\n            const pathnameInfo = getNextPathnameInfo(parsedUrl.pathname, {\n                nextConfig: this.nextConfig,\n                i18nProvider: this.i18nProvider\n            });\n            parsedUrl.pathname = pathnameInfo.pathname;\n            const normalizedPathname = removeTrailingSlash(parsed.pathname || '');\n            if (!middleware.match(normalizedPathname, req, parsedUrl.query)) {\n                return handleFinished();\n            }\n            let result;\n            let bubblingResult = false;\n            try {\n                await this.ensureMiddleware(req.url);\n                result = await this.runMiddleware({\n                    request: req,\n                    response: res,\n                    parsedUrl: parsedUrl,\n                    parsed: parsed\n                });\n                if ('response' in result) {\n                    if (isMiddlewareInvoke) {\n                        bubblingResult = true;\n                        throw Object.defineProperty(new BubbledError(true, result), \"__NEXT_ERROR_CODE\", {\n                            value: \"E394\",\n                            enumerable: false,\n                            configurable: true\n                        });\n                    }\n                    for (const [key, value] of Object.entries(toNodeOutgoingHttpHeaders(result.response.headers))){\n                        if (key !== 'content-encoding' && value !== undefined) {\n                            res.setHeader(key, value);\n                        }\n                    }\n                    res.statusCode = result.response.status;\n                    const { originalResponse } = res;\n                    if (result.response.body) {\n                        await pipeToNodeResponse(result.response.body, originalResponse);\n                    } else {\n                        originalResponse.end();\n                    }\n                    return true;\n                }\n            } catch (err) {\n                if (bubblingResult) {\n                    throw err;\n                }\n                if (isError(err) && err.code === 'ENOENT') {\n                    await this.render404(req, res, parsed);\n                    return true;\n                }\n                if (err instanceof DecodeError) {\n                    res.statusCode = 400;\n                    await this.renderError(err, req, res, parsed.pathname || '');\n                    return true;\n                }\n                const error = getProperError(err);\n                console.error(error);\n                res.statusCode = 500;\n                await this.renderError(error, req, res, parsed.pathname || '');\n                return true;\n            }\n            return result.finished;\n        };\n        const isDev = options.dev ?? false;\n        this.isDev = isDev;\n        this.sriEnabled = Boolean((_options_conf_experimental = options.conf.experimental) == null ? void 0 : (_options_conf_experimental_sri = _options_conf_experimental.sri) == null ? void 0 : _options_conf_experimental_sri.algorithm);\n        /**\n     * This sets environment variable to be used at the time of SSR by head.tsx.\n     * Using this from process.env allows targeting SSR by calling\n     * `process.env.__NEXT_OPTIMIZE_CSS`.\n     */ if (this.renderOpts.optimizeCss) {\n            process.env.__NEXT_OPTIMIZE_CSS = JSON.stringify(true);\n        }\n        if (this.renderOpts.nextScriptWorkers) {\n            process.env.__NEXT_SCRIPT_WORKERS = JSON.stringify(true);\n        }\n        process.env.NEXT_DEPLOYMENT_ID = this.nextConfig.deploymentId || '';\n        if (!this.minimalMode) {\n            this.imageResponseCache = new ResponseCache(this.minimalMode);\n        }\n        const { appDocumentPreloading } = this.nextConfig.experimental;\n        const isDefaultEnabled = typeof appDocumentPreloading === 'undefined';\n        if (!options.dev && (appDocumentPreloading === true || !(this.minimalMode && isDefaultEnabled))) {\n            // pre-warm _document and _app as these will be\n            // needed for most requests\n            loadComponents({\n                distDir: this.distDir,\n                page: '/_document',\n                isAppPath: false,\n                isDev: this.isDev,\n                sriEnabled: this.sriEnabled\n            }).catch(()=>{});\n            loadComponents({\n                distDir: this.distDir,\n                page: '/_app',\n                isAppPath: false,\n                isDev: this.isDev,\n                sriEnabled: this.sriEnabled\n            }).catch(()=>{});\n        }\n        if (!options.dev && !this.minimalMode && this.nextConfig.experimental.preloadEntriesOnStart) {\n            this.unstable_preloadEntries();\n        }\n        if (!options.dev) {\n            const { dynamicRoutes = [] } = this.getRoutesManifest() ?? {};\n            this.dynamicRoutes = dynamicRoutes.map((r)=>{\n                // TODO: can we just re-use the regex from the manifest?\n                const regex = getRouteRegex(r.page);\n                const match = getRouteMatcher(regex);\n                return {\n                    match,\n                    page: r.page,\n                    re: regex.re\n                };\n            });\n        }\n        // ensure options are set when loadConfig isn't called\n        setHttpClientAndAgentOptions(this.nextConfig);\n        // Intercept fetch and other testmode apis.\n        if (this.serverOptions.experimentalTestProxy) {\n            process.env.NEXT_PRIVATE_TEST_PROXY = 'true';\n            const { interceptTestApis } = require('next/dist/experimental/testmode/server');\n            interceptTestApis();\n        }\n        this.middlewareManifestPath = join(this.serverDistDir, MIDDLEWARE_MANIFEST);\n        // This is just optimization to fire prepare as soon as possible. It will be\n        // properly awaited later. We add the catch here to ensure that it does not\n        // cause a unhandled promise rejection. The promise rejection will be\n        // handled later on via the `await` when the request handler is called.\n        if (!options.dev) {\n            this.prepare().catch((err)=>{\n                console.error('Failed to prepare server', err);\n            });\n        }\n        // when using compile mode static env isn't inlined so we\n        // need to populate in normal runtime env\n        if (this.renderOpts.isExperimentalCompile) {\n            populateStaticEnv(this.nextConfig);\n        }\n    }\n    async unstable_preloadEntries() {\n        const appPathsManifest = this.getAppPathsManifest();\n        const pagesManifest = this.getPagesManifest();\n        await this.loadCustomCacheHandlers();\n        for (const page of Object.keys(pagesManifest || {})){\n            await loadComponents({\n                distDir: this.distDir,\n                page,\n                isAppPath: false,\n                isDev: this.isDev,\n                sriEnabled: this.sriEnabled\n            }).catch(()=>{});\n        }\n        for (const page of Object.keys(appPathsManifest || {})){\n            await loadComponents({\n                distDir: this.distDir,\n                page,\n                isAppPath: true,\n                isDev: this.isDev,\n                sriEnabled: this.sriEnabled\n            }).then(async ({ ComponentMod })=>{\n                // we need to ensure fetch is patched before we require the page,\n                // otherwise if the fetch is patched by user code, we will be patching it\n                // too late and there won't be any caching behaviors\n                ComponentMod.patchFetch();\n                const webpackRequire = ComponentMod.__next_app__.require;\n                if (webpackRequire == null ? void 0 : webpackRequire.m) {\n                    for (const id of Object.keys(webpackRequire.m)){\n                        await webpackRequire(id);\n                    }\n                }\n            }).catch(()=>{});\n        }\n    }\n    async handleUpgrade() {\n    // The web server does not support web sockets, it's only used for HMR in\n    // development.\n    }\n    async loadInstrumentationModule() {\n        if (!this.serverOptions.dev) {\n            try {\n                this.instrumentation = await dynamicRequire(resolve(this.serverOptions.dir || '.', this.serverOptions.conf.distDir, 'server', INSTRUMENTATION_HOOK_FILENAME));\n            } catch (err) {\n                if (err.code !== 'MODULE_NOT_FOUND') {\n                    throw Object.defineProperty(new Error('An error occurred while loading the instrumentation hook', {\n                        cause: err\n                    }), \"__NEXT_ERROR_CODE\", {\n                        value: \"E92\",\n                        enumerable: false,\n                        configurable: true\n                    });\n                }\n            }\n        }\n        return this.instrumentation;\n    }\n    async prepareImpl() {\n        await super.prepareImpl();\n        await this.runInstrumentationHookIfAvailable();\n    }\n    async runInstrumentationHookIfAvailable() {\n        var _this_instrumentation_register, _this_instrumentation;\n        if (this.registeredInstrumentation) return;\n        this.registeredInstrumentation = true;\n        await ((_this_instrumentation = this.instrumentation) == null ? void 0 : (_this_instrumentation_register = _this_instrumentation.register) == null ? void 0 : _this_instrumentation_register.call(_this_instrumentation));\n    }\n    loadEnvConfig({ dev, forceReload, silent }) {\n        loadEnvConfig(this.dir, dev, silent ? {\n            info: ()=>{},\n            error: ()=>{}\n        } : Log, forceReload);\n    }\n    async loadCustomCacheHandlers() {\n        const { cacheHandlers } = this.nextConfig.experimental;\n        if (!cacheHandlers) return;\n        // If we've already initialized the cache handlers interface, don't do it\n        // again.\n        if (!initializeCacheHandlers()) return;\n        for (const [kind, handler] of Object.entries(cacheHandlers)){\n            if (!handler) continue;\n            setCacheHandler(kind, interopDefault(await dynamicImportEsmDefault(formatDynamicImportPath(this.distDir, handler))));\n        }\n    }\n    async getIncrementalCache({ requestHeaders, requestProtocol }) {\n        const dev = !!this.renderOpts.dev;\n        let CacheHandler;\n        const { cacheHandler } = this.nextConfig;\n        if (cacheHandler) {\n            CacheHandler = interopDefault(await dynamicImportEsmDefault(formatDynamicImportPath(this.distDir, cacheHandler)));\n        }\n        await this.loadCustomCacheHandlers();\n        // incremental-cache is request specific\n        // although can have shared caches in module scope\n        // per-cache handler\n        return new IncrementalCache({\n            fs: this.getCacheFilesystem(),\n            dev,\n            requestHeaders,\n            requestProtocol,\n            allowedRevalidateHeaderKeys: this.nextConfig.experimental.allowedRevalidateHeaderKeys,\n            minimalMode: this.minimalMode,\n            serverDistDir: this.serverDistDir,\n            fetchCacheKeyPrefix: this.nextConfig.experimental.fetchCacheKeyPrefix,\n            maxMemoryCacheSize: this.nextConfig.cacheMaxMemorySize,\n            flushToDisk: !this.minimalMode && this.nextConfig.experimental.isrFlushToDisk,\n            getPrerenderManifest: ()=>this.getPrerenderManifest(),\n            CurCacheHandler: CacheHandler\n        });\n    }\n    getResponseCache() {\n        return new ResponseCache(this.minimalMode);\n    }\n    getPublicDir() {\n        return join(this.dir, CLIENT_PUBLIC_FILES_PATH);\n    }\n    getHasStaticDir() {\n        return fs.existsSync(join(this.dir, 'static'));\n    }\n    getPagesManifest() {\n        return loadManifest(join(this.serverDistDir, PAGES_MANIFEST));\n    }\n    getAppPathsManifest() {\n        if (!this.enabledDirectories.app) return undefined;\n        return loadManifest(join(this.serverDistDir, APP_PATHS_MANIFEST));\n    }\n    getinterceptionRoutePatterns() {\n        if (!this.enabledDirectories.app) return [];\n        const routesManifest = this.getRoutesManifest();\n        return (routesManifest == null ? void 0 : routesManifest.rewrites.beforeFiles.filter(isInterceptionRouteRewrite).map((rewrite)=>new RegExp(rewrite.regex))) ?? [];\n    }\n    async hasPage(pathname) {\n        var _this_nextConfig_i18n;\n        return !!getMaybePagePath(pathname, this.distDir, (_this_nextConfig_i18n = this.nextConfig.i18n) == null ? void 0 : _this_nextConfig_i18n.locales, this.enabledDirectories.app);\n    }\n    getBuildId() {\n        const buildIdFile = join(this.distDir, BUILD_ID_FILE);\n        try {\n            return fs.readFileSync(buildIdFile, 'utf8').trim();\n        } catch (err) {\n            if (err.code === 'ENOENT') {\n                throw Object.defineProperty(new Error(`Could not find a production build in the '${this.distDir}' directory. Try building your app with 'next build' before starting the production server. https://nextjs.org/docs/messages/production-start-no-build-id`), \"__NEXT_ERROR_CODE\", {\n                    value: \"E427\",\n                    enumerable: false,\n                    configurable: true\n                });\n            }\n            throw err;\n        }\n    }\n    getEnabledDirectories(dev) {\n        const dir = dev ? this.dir : this.serverDistDir;\n        return {\n            app: findDir(dir, 'app') ? true : false,\n            pages: findDir(dir, 'pages') ? true : false\n        };\n    }\n    sendRenderResult(req, res, options) {\n        return sendRenderResult({\n            req: req.originalRequest,\n            res: res.originalResponse,\n            result: options.result,\n            type: options.type,\n            generateEtags: options.generateEtags,\n            poweredByHeader: options.poweredByHeader,\n            cacheControl: options.cacheControl\n        });\n    }\n    async runApi(req, res, query, match) {\n        const edgeFunctionsPages = this.getEdgeFunctionsPages();\n        for (const edgeFunctionsPage of edgeFunctionsPages){\n            if (edgeFunctionsPage === match.definition.pathname) {\n                const handledAsEdgeFunction = await this.runEdgeFunction({\n                    req,\n                    res,\n                    query,\n                    params: match.params,\n                    page: match.definition.pathname,\n                    appPaths: null\n                });\n                if (handledAsEdgeFunction) {\n                    return true;\n                }\n            }\n        }\n        // The module supports minimal mode, load the minimal module.\n        const module = await RouteModuleLoader.load(match.definition.filename);\n        query = {\n            ...query,\n            ...match.params\n        };\n        await module.render(req.originalRequest, res.originalResponse, {\n            previewProps: this.renderOpts.previewProps,\n            revalidate: this.revalidate.bind(this),\n            trustHostHeader: this.nextConfig.experimental.trustHostHeader,\n            allowedRevalidateHeaderKeys: this.nextConfig.experimental.allowedRevalidateHeaderKeys,\n            hostname: this.fetchHostname,\n            minimalMode: this.minimalMode,\n            dev: this.renderOpts.dev === true,\n            query,\n            params: match.params,\n            page: match.definition.pathname,\n            onError: this.instrumentationOnRequestError.bind(this),\n            multiZoneDraftMode: this.nextConfig.experimental.multiZoneDraftMode\n        });\n        return true;\n    }\n    async renderHTML(req, res, pathname, query, renderOpts) {\n        return getTracer().trace(NextNodeServerSpan.renderHTML, async ()=>this.renderHTMLImpl(req, res, pathname, query, renderOpts));\n    }\n    async renderHTMLImpl(req, res, pathname, query, renderOpts) {\n        if (process.env.NEXT_MINIMAL) {\n            throw Object.defineProperty(new Error('Invariant: renderHTML should not be called in minimal mode'), \"__NEXT_ERROR_CODE\", {\n                value: \"E472\",\n                enumerable: false,\n                configurable: true\n            });\n        // the `else` branch is needed for tree-shaking\n        } else {\n            // Due to the way we pass data by mutating `renderOpts`, we can't extend the\n            // object here but only updating its `nextFontManifest` field.\n            // https://github.com/vercel/next.js/blob/df7cbd904c3bd85f399d1ce90680c0ecf92d2752/packages/next/server/render.tsx#L947-L952\n            renderOpts.nextFontManifest = this.nextFontManifest;\n            if (this.enabledDirectories.app && renderOpts.isAppPath) {\n                return lazyRenderAppPage(req, res, pathname, query, // This code path does not service revalidations for unknown param\n                // shells. As a result, we don't need to pass in the unknown params.\n                null, renderOpts, this.getServerComponentsHmrCache(), false, {\n                    buildId: this.buildId\n                });\n            }\n            // TODO: re-enable this once we've refactored to use implicit matches\n            // throw new Error('Invariant: render should have used routeModule')\n            return lazyRenderPagesPage(req.originalRequest, res.originalResponse, pathname, query, renderOpts, {\n                buildId: this.buildId,\n                deploymentId: this.nextConfig.deploymentId,\n                customServer: this.serverOptions.customServer || undefined\n            }, {\n                isFallback: false,\n                isDraftMode: renderOpts.isDraftMode,\n                developmentNotFoundSourcePage: getRequestMeta(req, 'developmentNotFoundSourcePage')\n            });\n        }\n    }\n    async imageOptimizer(req, res, paramsResult, previousCacheEntry) {\n        if (process.env.NEXT_MINIMAL) {\n            throw Object.defineProperty(new Error('invariant: imageOptimizer should not be called in minimal mode'), \"__NEXT_ERROR_CODE\", {\n                value: \"E506\",\n                enumerable: false,\n                configurable: true\n            });\n        } else {\n            const { imageOptimizer, fetchExternalImage, fetchInternalImage } = require('./image-optimizer');\n            const handleInternalReq = async (newReq, newRes)=>{\n                if (newReq.url === req.url) {\n                    throw Object.defineProperty(new Error(`Invariant attempted to optimize _next/image itself`), \"__NEXT_ERROR_CODE\", {\n                        value: \"E496\",\n                        enumerable: false,\n                        configurable: true\n                    });\n                }\n                if (!this.routerServerHandler) {\n                    throw Object.defineProperty(new Error(`Invariant missing routerServerHandler`), \"__NEXT_ERROR_CODE\", {\n                        value: \"E317\",\n                        enumerable: false,\n                        configurable: true\n                    });\n                }\n                await this.routerServerHandler(newReq, newRes);\n                return;\n            };\n            const { isAbsolute, href } = paramsResult;\n            const imageUpstream = isAbsolute ? await fetchExternalImage(href) : await fetchInternalImage(href, req.originalRequest, res.originalResponse, handleInternalReq);\n            return imageOptimizer(imageUpstream, paramsResult, this.nextConfig, {\n                isDev: this.renderOpts.dev,\n                previousCacheEntry\n            });\n        }\n    }\n    getPagePath(pathname, locales) {\n        return getPagePath(pathname, this.distDir, locales, this.enabledDirectories.app);\n    }\n    async renderPageComponent(ctx, bubbleNoFallback) {\n        const edgeFunctionsPages = this.getEdgeFunctionsPages() || [];\n        if (edgeFunctionsPages.length) {\n            const appPaths = this.getOriginalAppPaths(ctx.pathname);\n            const isAppPath = Array.isArray(appPaths);\n            let page = ctx.pathname;\n            if (isAppPath) {\n                // When it's an array, we need to pass all parallel routes to the loader.\n                page = appPaths[0];\n            }\n            for (const edgeFunctionsPage of edgeFunctionsPages){\n                if (edgeFunctionsPage === page) {\n                    await this.runEdgeFunction({\n                        req: ctx.req,\n                        res: ctx.res,\n                        query: ctx.query,\n                        params: ctx.renderOpts.params,\n                        page,\n                        appPaths\n                    });\n                    return null;\n                }\n            }\n        }\n        return super.renderPageComponent(ctx, bubbleNoFallback);\n    }\n    async findPageComponents({ locale, page, query, params, isAppPath, url }) {\n        return getTracer().trace(NextNodeServerSpan.findPageComponents, {\n            spanName: 'resolve page components',\n            attributes: {\n                'next.route': isAppPath ? normalizeAppPath(page) : page\n            }\n        }, ()=>this.findPageComponentsImpl({\n                locale,\n                page,\n                query,\n                params,\n                isAppPath,\n                url\n            }));\n    }\n    async findPageComponentsImpl({ locale, page, query, params, isAppPath, url: _url }) {\n        const pagePaths = [\n            page\n        ];\n        if (query.amp) {\n            // try serving a static AMP version first\n            pagePaths.unshift((isAppPath ? normalizeAppPath(page) : normalizePagePath(page)) + '.amp');\n        }\n        if (locale) {\n            pagePaths.unshift(...pagePaths.map((path)=>`/${locale}${path === '/' ? '' : path}`));\n        }\n        for (const pagePath of pagePaths){\n            try {\n                const components = await loadComponents({\n                    distDir: this.distDir,\n                    page: pagePath,\n                    isAppPath,\n                    isDev: this.isDev,\n                    sriEnabled: this.sriEnabled\n                });\n                if (locale && typeof components.Component === 'string' && !pagePath.startsWith(`/${locale}/`) && pagePath !== `/${locale}`) {\n                    continue;\n                }\n                return {\n                    components,\n                    query: {\n                        ...!this.renderOpts.isExperimentalCompile && components.getStaticProps ? {\n                            amp: query.amp\n                        } : query,\n                        // For appDir params is excluded.\n                        ...(isAppPath ? {} : params) || {}\n                    }\n                };\n            } catch (err) {\n                // we should only not throw if we failed to find the page\n                // in the pages-manifest\n                if (!(err instanceof PageNotFoundError)) {\n                    throw err;\n                }\n            }\n        }\n        return null;\n    }\n    getNextFontManifest() {\n        return loadManifest(join(this.distDir, 'server', NEXT_FONT_MANIFEST + '.json'));\n    }\n    // Used in development only, overloaded in next-dev-server\n    logErrorWithOriginalStack(_err, _type) {\n        throw Object.defineProperty(new Error('Invariant: logErrorWithOriginalStack can only be called on the development server'), \"__NEXT_ERROR_CODE\", {\n            value: \"E6\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    // Used in development only, overloaded in next-dev-server\n    async ensurePage(_opts) {\n        throw Object.defineProperty(new Error('Invariant: ensurePage can only be called on the development server'), \"__NEXT_ERROR_CODE\", {\n            value: \"E291\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    /**\n   * Resolves `API` request, in development builds on demand\n   * @param req http request\n   * @param res http response\n   * @param pathname path of request\n   */ async handleApiRequest(req, res, query, match) {\n        return this.runApi(req, res, query, match);\n    }\n    getCacheFilesystem() {\n        return nodeFs;\n    }\n    normalizeReq(req) {\n        return !(req instanceof NodeNextRequest) ? new NodeNextRequest(req) : req;\n    }\n    normalizeRes(res) {\n        return !(res instanceof NodeNextResponse) ? new NodeNextResponse(res) : res;\n    }\n    getRequestHandler() {\n        const handler = this.makeRequestHandler();\n        if (this.serverOptions.experimentalTestProxy) {\n            const { wrapRequestHandlerNode } = require('next/dist/experimental/testmode/server');\n            return wrapRequestHandlerNode(handler);\n        }\n        return handler;\n    }\n    makeRequestHandler() {\n        // This is just optimization to fire prepare as soon as possible. It will be\n        // properly awaited later. We add the catch here to ensure that it does not\n        // cause an unhandled promise rejection. The promise rejection will be\n        // handled later on via the `await` when the request handler is called.\n        this.prepare().catch((err)=>{\n            console.error('Failed to prepare server', err);\n        });\n        const handler = super.getRequestHandler();\n        return (req, res, parsedUrl)=>handler(this.normalizeReq(req), this.normalizeRes(res), parsedUrl);\n    }\n    async revalidate({ urlPath, revalidateHeaders, opts }) {\n        const mocked = createRequestResponseMocks({\n            url: urlPath,\n            headers: revalidateHeaders\n        });\n        const handler = this.getRequestHandler();\n        await handler(new NodeNextRequest(mocked.req), new NodeNextResponse(mocked.res));\n        await mocked.res.hasStreamed;\n        if (mocked.res.getHeader('x-nextjs-cache') !== 'REVALIDATED' && mocked.res.statusCode !== 200 && !(mocked.res.statusCode === 404 && opts.unstable_onlyGenerated)) {\n            throw Object.defineProperty(new Error(`Invalid response ${mocked.res.statusCode}`), \"__NEXT_ERROR_CODE\", {\n                value: \"E175\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n    }\n    async render(req, res, pathname, query, parsedUrl, internal = false) {\n        return super.render(this.normalizeReq(req), this.normalizeRes(res), pathname, query, parsedUrl, internal);\n    }\n    async renderToHTML(req, res, pathname, query) {\n        return super.renderToHTML(this.normalizeReq(req), this.normalizeRes(res), pathname, query);\n    }\n    async renderErrorToResponseImpl(ctx, err) {\n        const { req, res, query } = ctx;\n        const is404 = res.statusCode === 404;\n        if (is404 && this.enabledDirectories.app) {\n            if (this.renderOpts.dev) {\n                await this.ensurePage({\n                    page: UNDERSCORE_NOT_FOUND_ROUTE_ENTRY,\n                    clientOnly: false,\n                    url: req.url\n                }).catch(()=>{});\n            }\n            if (this.getEdgeFunctionsPages().includes(UNDERSCORE_NOT_FOUND_ROUTE_ENTRY)) {\n                await this.runEdgeFunction({\n                    req,\n                    res,\n                    query: query || {},\n                    params: {},\n                    page: UNDERSCORE_NOT_FOUND_ROUTE_ENTRY,\n                    appPaths: null\n                });\n                return null;\n            }\n        }\n        return super.renderErrorToResponseImpl(ctx, err);\n    }\n    async renderError(err, req, res, pathname, query, setHeaders) {\n        return super.renderError(err, this.normalizeReq(req), this.normalizeRes(res), pathname, query, setHeaders);\n    }\n    async renderErrorToHTML(err, req, res, pathname, query) {\n        return super.renderErrorToHTML(err, this.normalizeReq(req), this.normalizeRes(res), pathname, query);\n    }\n    async render404(req, res, parsedUrl, setHeaders) {\n        return super.render404(this.normalizeReq(req), this.normalizeRes(res), parsedUrl, setHeaders);\n    }\n    getMiddlewareManifest() {\n        if (this.minimalMode) {\n            return null;\n        } else {\n            const manifest = require(this.middlewareManifestPath);\n            return manifest;\n        }\n    }\n    /** Returns the middleware routing item if there is one. */ async getMiddleware() {\n        var _manifest_middleware;\n        const manifest = this.getMiddlewareManifest();\n        const middleware = manifest == null ? void 0 : (_manifest_middleware = manifest.middleware) == null ? void 0 : _manifest_middleware['/'];\n        if (!middleware) {\n            const middlewareModule = await this.loadNodeMiddleware();\n            if (middlewareModule) {\n                var _middlewareModule_config;\n                return {\n                    match: getMiddlewareRouteMatcher(((_middlewareModule_config = middlewareModule.config) == null ? void 0 : _middlewareModule_config.matchers) || [\n                        {\n                            regexp: '.*',\n                            originalSource: '/:path*'\n                        }\n                    ]),\n                    page: '/'\n                };\n            }\n            return;\n        }\n        return {\n            match: getMiddlewareMatcher(middleware),\n            page: '/'\n        };\n    }\n    getEdgeFunctionsPages() {\n        const manifest = this.getMiddlewareManifest();\n        if (!manifest) {\n            return [];\n        }\n        return Object.keys(manifest.functions);\n    }\n    /**\n   * Get information for the edge function located in the provided page\n   * folder. If the edge function info can't be found it will throw\n   * an error.\n   */ getEdgeFunctionInfo(params) {\n        const manifest = this.getMiddlewareManifest();\n        if (!manifest) {\n            return null;\n        }\n        let foundPage;\n        try {\n            foundPage = denormalizePagePath(normalizePagePath(params.page));\n        } catch (err) {\n            return null;\n        }\n        let pageInfo = params.middleware ? manifest.middleware[foundPage] : manifest.functions[foundPage];\n        if (!pageInfo) {\n            if (!params.middleware) {\n                throw new PageNotFoundError(foundPage);\n            }\n            return null;\n        }\n        return {\n            name: pageInfo.name,\n            paths: pageInfo.files.map((file)=>join(this.distDir, file)),\n            wasm: (pageInfo.wasm ?? []).map((binding)=>({\n                    ...binding,\n                    filePath: join(this.distDir, binding.filePath)\n                })),\n            assets: pageInfo.assets && pageInfo.assets.map((binding)=>{\n                return {\n                    ...binding,\n                    filePath: join(this.distDir, binding.filePath)\n                };\n            }),\n            env: pageInfo.env\n        };\n    }\n    async loadNodeMiddleware() {\n        if (!this.nextConfig.experimental.nodeMiddleware) {\n            return;\n        }\n        try {\n            var _functionsConfig_functions;\n            const functionsConfig = this.renderOpts.dev ? {} : require(join(this.distDir, 'server', FUNCTIONS_CONFIG_MANIFEST));\n            if (this.renderOpts.dev || (functionsConfig == null ? void 0 : (_functionsConfig_functions = functionsConfig.functions) == null ? void 0 : _functionsConfig_functions['/_middleware'])) {\n                // if used with top level await, this will be a promise\n                return require(join(this.distDir, 'server', 'middleware.js'));\n            }\n        } catch (err) {\n            if (isError(err) && err.code !== 'ENOENT' && err.code !== 'MODULE_NOT_FOUND') {\n                throw err;\n            }\n        }\n    }\n    /**\n   * Checks if a middleware exists. This method is useful for the development\n   * server where we need to check the filesystem. Here we just check the\n   * middleware manifest.\n   */ async hasMiddleware(pathname) {\n        const info = this.getEdgeFunctionInfo({\n            page: pathname,\n            middleware: true\n        });\n        const nodeMiddleware = await this.loadNodeMiddleware();\n        if (!info && nodeMiddleware) {\n            return true;\n        }\n        return Boolean(info && info.paths.length > 0);\n    }\n    /**\n   * A placeholder for a function to be defined in the development server.\n   * It will make sure that the root middleware or an edge function has been compiled\n   * so that we can run it.\n   */ async ensureMiddleware(_url) {}\n    async ensureEdgeFunction(_params) {}\n    /**\n   * This method gets all middleware matchers and execute them when the request\n   * matches. It will make sure that each middleware exists and is compiled and\n   * ready to be invoked. The development server will decorate it to add warns\n   * and errors with rich traces.\n   */ async runMiddleware(params) {\n        if (process.env.NEXT_MINIMAL) {\n            throw Object.defineProperty(new Error('invariant: runMiddleware should not be called in minimal mode'), \"__NEXT_ERROR_CODE\", {\n                value: \"E276\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n        // Middleware is skipped for on-demand revalidate requests\n        if (checkIsOnDemandRevalidate(params.request, this.renderOpts.previewProps).isOnDemandRevalidate) {\n            return {\n                response: new Response(null, {\n                    headers: {\n                        'x-middleware-next': '1'\n                    }\n                })\n            };\n        }\n        let url;\n        if (this.nextConfig.skipMiddlewareUrlNormalize) {\n            url = getRequestMeta(params.request, 'initURL');\n        } else {\n            // For middleware to \"fetch\" we must always provide an absolute URL\n            const query = urlQueryToSearchParams(params.parsed.query).toString();\n            const locale = getRequestMeta(params.request, 'locale');\n            url = `${getRequestMeta(params.request, 'initProtocol')}://${this.fetchHostname || 'localhost'}:${this.port}${locale ? `/${locale}` : ''}${params.parsed.pathname}${query ? `?${query}` : ''}`;\n        }\n        if (!url.startsWith('http')) {\n            throw Object.defineProperty(new Error('To use middleware you must provide a `hostname` and `port` to the Next.js Server'), \"__NEXT_ERROR_CODE\", {\n                value: \"E35\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n        const page = {};\n        const middleware = await this.getMiddleware();\n        if (!middleware) {\n            return {\n                finished: false\n            };\n        }\n        if (!await this.hasMiddleware(middleware.page)) {\n            return {\n                finished: false\n            };\n        }\n        await this.ensureMiddleware(params.request.url);\n        const middlewareInfo = this.getEdgeFunctionInfo({\n            page: middleware.page,\n            middleware: true\n        });\n        const method = (params.request.method || 'GET').toUpperCase();\n        const requestData = {\n            headers: params.request.headers,\n            method,\n            nextConfig: {\n                basePath: this.nextConfig.basePath,\n                i18n: this.nextConfig.i18n,\n                trailingSlash: this.nextConfig.trailingSlash,\n                experimental: this.nextConfig.experimental\n            },\n            url: url,\n            page,\n            body: method !== 'GET' && method !== 'HEAD' ? getRequestMeta(params.request, 'clonableBody') : undefined,\n            signal: signalFromNodeResponse(params.response.originalResponse),\n            waitUntil: this.getWaitUntil()\n        };\n        let result;\n        // if no middleware info check for Node.js middleware\n        // this is not in the middleware-manifest as that historically\n        // has only included edge-functions, we need to do a breaking\n        // version bump for that manifest to write this info there if\n        // we decide we want to\n        if (!middlewareInfo) {\n            let middlewareModule;\n            middlewareModule = await this.loadNodeMiddleware();\n            if (!middlewareModule) {\n                throw new MiddlewareNotFoundError();\n            }\n            const adapterFn = middlewareModule.default || middlewareModule;\n            result = await adapterFn({\n                handler: middlewareModule.middleware || middlewareModule,\n                request: requestData,\n                page: 'middleware'\n            });\n        } else {\n            const { run } = require('./web/sandbox');\n            result = await run({\n                distDir: this.distDir,\n                name: middlewareInfo.name,\n                paths: middlewareInfo.paths,\n                edgeFunctionEntry: middlewareInfo,\n                request: requestData,\n                useCache: true,\n                onWarning: params.onWarning\n            });\n        }\n        if (!this.renderOpts.dev) {\n            result.waitUntil.catch((error)=>{\n                console.error(`Uncaught: middleware waitUntil errored`, error);\n            });\n        }\n        if (!result) {\n            this.render404(params.request, params.response, params.parsed);\n            return {\n                finished: true\n            };\n        }\n        // Split compound (comma-separated) set-cookie headers\n        if (result.response.headers.has('set-cookie')) {\n            const cookies = result.response.headers.getSetCookie().flatMap((maybeCompoundCookie)=>splitCookiesString(maybeCompoundCookie));\n            // Clear existing header(s)\n            result.response.headers.delete('set-cookie');\n            // Append each cookie individually.\n            for (const cookie of cookies){\n                result.response.headers.append('set-cookie', cookie);\n            }\n            // Add cookies to request meta.\n            addRequestMeta(params.request, 'middlewareCookie', cookies);\n        }\n        return result;\n    }\n    getPrerenderManifest() {\n        var _this_renderOpts, _this_serverOptions;\n        if (this._cachedPreviewManifest) {\n            return this._cachedPreviewManifest;\n        }\n        if (((_this_renderOpts = this.renderOpts) == null ? void 0 : _this_renderOpts.dev) || ((_this_serverOptions = this.serverOptions) == null ? void 0 : _this_serverOptions.dev) || process.env.NODE_ENV === 'development' || process.env.NEXT_PHASE === PHASE_PRODUCTION_BUILD) {\n            this._cachedPreviewManifest = {\n                version: 4,\n                routes: {},\n                dynamicRoutes: {},\n                notFoundRoutes: [],\n                preview: {\n                    previewModeId: require('crypto').randomBytes(16).toString('hex'),\n                    previewModeSigningKey: require('crypto').randomBytes(32).toString('hex'),\n                    previewModeEncryptionKey: require('crypto').randomBytes(32).toString('hex')\n                }\n            };\n            return this._cachedPreviewManifest;\n        }\n        this._cachedPreviewManifest = loadManifest(join(this.distDir, PRERENDER_MANIFEST));\n        return this._cachedPreviewManifest;\n    }\n    getRoutesManifest() {\n        return getTracer().trace(NextNodeServerSpan.getRoutesManifest, ()=>{\n            const manifest = loadManifest(join(this.distDir, ROUTES_MANIFEST));\n            let rewrites = manifest.rewrites ?? {\n                beforeFiles: [],\n                afterFiles: [],\n                fallback: []\n            };\n            if (Array.isArray(rewrites)) {\n                rewrites = {\n                    beforeFiles: [],\n                    afterFiles: rewrites,\n                    fallback: []\n                };\n            }\n            return {\n                ...manifest,\n                rewrites\n            };\n        });\n    }\n    attachRequestMeta(req, parsedUrl, isUpgradeReq) {\n        var _req_headers_xforwardedproto;\n        // Injected in base-server.ts\n        const protocol = ((_req_headers_xforwardedproto = req.headers['x-forwarded-proto']) == null ? void 0 : _req_headers_xforwardedproto.includes('https')) ? 'https' : 'http';\n        // When there are hostname and port we build an absolute URL\n        const initUrl = this.fetchHostname && this.port ? `${protocol}://${this.fetchHostname}:${this.port}${req.url}` : this.nextConfig.experimental.trustHostHeader ? `https://${req.headers.host || 'localhost'}${req.url}` : req.url;\n        addRequestMeta(req, 'initURL', initUrl);\n        addRequestMeta(req, 'initQuery', {\n            ...parsedUrl.query\n        });\n        addRequestMeta(req, 'initProtocol', protocol);\n        if (!isUpgradeReq) {\n            addRequestMeta(req, 'clonableBody', getCloneableBody(req.originalRequest));\n        }\n    }\n    async runEdgeFunction(params) {\n        if (process.env.NEXT_MINIMAL) {\n            throw Object.defineProperty(new Error('Middleware is not supported in minimal mode. Please remove the `NEXT_MINIMAL` environment variable.'), \"__NEXT_ERROR_CODE\", {\n                value: \"E58\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n        let edgeInfo;\n        const { query, page, match } = params;\n        if (!match) await this.ensureEdgeFunction({\n            page,\n            appPaths: params.appPaths,\n            url: params.req.url\n        });\n        edgeInfo = this.getEdgeFunctionInfo({\n            page,\n            middleware: false\n        });\n        if (!edgeInfo) {\n            return null;\n        }\n        // For edge to \"fetch\" we must always provide an absolute URL\n        const isNextDataRequest = getRequestMeta(params.req, 'isNextDataReq');\n        const initialUrl = new URL(getRequestMeta(params.req, 'initURL') || '/', 'http://n');\n        const queryString = urlQueryToSearchParams({\n            ...Object.fromEntries(initialUrl.searchParams),\n            ...query,\n            ...params.params\n        }).toString();\n        if (isNextDataRequest) {\n            params.req.headers['x-nextjs-data'] = '1';\n        }\n        initialUrl.search = queryString;\n        const url = initialUrl.toString();\n        if (!url.startsWith('http')) {\n            throw Object.defineProperty(new Error('To use middleware you must provide a `hostname` and `port` to the Next.js Server'), \"__NEXT_ERROR_CODE\", {\n                value: \"E35\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n        const { run } = require('./web/sandbox');\n        const result = await run({\n            distDir: this.distDir,\n            name: edgeInfo.name,\n            paths: edgeInfo.paths,\n            edgeFunctionEntry: edgeInfo,\n            request: {\n                headers: params.req.headers,\n                method: params.req.method,\n                nextConfig: {\n                    basePath: this.nextConfig.basePath,\n                    i18n: this.nextConfig.i18n,\n                    trailingSlash: this.nextConfig.trailingSlash\n                },\n                url,\n                page: {\n                    name: params.page,\n                    ...params.params && {\n                        params: params.params\n                    }\n                },\n                body: getRequestMeta(params.req, 'clonableBody'),\n                signal: signalFromNodeResponse(params.res.originalResponse),\n                waitUntil: this.getWaitUntil()\n            },\n            useCache: true,\n            onError: params.onError,\n            onWarning: params.onWarning,\n            incrementalCache: globalThis.__incrementalCache || getRequestMeta(params.req, 'incrementalCache'),\n            serverComponentsHmrCache: getRequestMeta(params.req, 'serverComponentsHmrCache')\n        });\n        if (result.fetchMetrics) {\n            params.req.fetchMetrics = result.fetchMetrics;\n        }\n        if (!params.res.statusCode || params.res.statusCode < 400) {\n            params.res.statusCode = result.response.status;\n            params.res.statusMessage = result.response.statusText;\n        }\n        // TODO: (wyattjoh) investigate improving this\n        result.response.headers.forEach((value, key)=>{\n            // The append handling is special cased for `set-cookie`.\n            if (key.toLowerCase() === 'set-cookie') {\n                // TODO: (wyattjoh) replace with native response iteration when we can upgrade undici\n                for (const cookie of splitCookiesString(value)){\n                    params.res.appendHeader(key, cookie);\n                }\n            } else {\n                params.res.appendHeader(key, value);\n            }\n        });\n        const { originalResponse } = params.res;\n        if (result.response.body) {\n            await pipeToNodeResponse(result.response.body, originalResponse);\n        } else {\n            originalResponse.end();\n        }\n        return result;\n    }\n    get serverDistDir() {\n        if (this._serverDistDir) {\n            return this._serverDistDir;\n        }\n        const serverDistDir = join(this.distDir, SERVER_DIRECTORY);\n        this._serverDistDir = serverDistDir;\n        return serverDistDir;\n    }\n    async getFallbackErrorComponents(_url) {\n        // Not implemented for production use cases, this is implemented on the\n        // development server.\n        return null;\n    }\n    async instrumentationOnRequestError(...args) {\n        await super.instrumentationOnRequestError(...args);\n        // For Node.js runtime production logs, in dev it will be overridden by next-dev-server\n        if (!this.renderOpts.dev) {\n            this.logError(args[0]);\n        }\n    }\n    onServerClose(listener) {\n        this.cleanupListeners.add(listener);\n    }\n    async close() {\n        await this.cleanupListeners.runAll();\n    }\n    getInternalWaitUntil() {\n        this.internalWaitUntil ??= this.createInternalWaitUntil();\n        return this.internalWaitUntil;\n    }\n    createInternalWaitUntil() {\n        if (this.minimalMode) {\n            throw Object.defineProperty(new InvariantError('createInternalWaitUntil should never be called in minimal mode'), \"__NEXT_ERROR_CODE\", {\n                value: \"E540\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n        const awaiter = new AwaiterOnce({\n            onError: console.error\n        });\n        // TODO(after): warn if the process exits before these are awaited\n        this.onServerClose(()=>awaiter.awaiting());\n        return awaiter.waitUntil;\n    }\n}\n\n//# sourceMappingURL=next-server.js.map"
        }
    ]
}