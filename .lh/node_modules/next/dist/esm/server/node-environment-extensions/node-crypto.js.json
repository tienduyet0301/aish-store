{
    "sourceFile": "node_modules/next/dist/esm/server/node-environment-extensions/node-crypto.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892834591,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * We extend node:crypto APIs during builds and revalidates to ensure that prerenders don't observe random bytes\n * When dynamicIO is enabled. Random bytes are a form of IO even if they resolve synchronously. When dyanmicIO is\n * enabled we need to ensure that random bytes are excluded from prerenders unless they are cached.\n *\n *\n * The extensions here never error nor alter the underlying return values and thus should be transparent to callers.\n */ import { io } from './utils';\nif (process.env.NEXT_RUNTIME === 'edge') {\n// nothing to patch\n} else {\n    const nodeCrypto = require('node:crypto');\n    // require('node:crypto').getRandomValues is an alias for\n    // crypto.getRandomValues which is extended in web-crypto.tsx\n    // require('node:crypto').randomUUID is not an alias for crypto.randomUUID\n    const randomUUIDExpression = \"`require('node:crypto').randomUUID()`\";\n    try {\n        const _randomUUID = nodeCrypto.randomUUID;\n        nodeCrypto.randomUUID = function randomUUID() {\n            io(randomUUIDExpression, 'random');\n            return _randomUUID.apply(this, arguments);\n        };\n    } catch  {\n        console.error(`Failed to install ${randomUUIDExpression} extension. When using \\`experimental.dynamicIO\\` calling this function will not correctly trigger dynamic behavior.`);\n    }\n    const randomBytesExpression = \"`require('node:crypto').randomBytes(size)`\";\n    try {\n        const _randomBytes = nodeCrypto.randomBytes;\n        nodeCrypto.randomBytes = function randomBytes() {\n            if (typeof arguments[1] !== 'function') {\n                // randomBytes is sync if the second arg is undefined\n                io(randomBytesExpression, 'random');\n            }\n            return _randomBytes.apply(this, arguments);\n        };\n    } catch  {\n        console.error(`Failed to install ${randomBytesExpression} extension. When using \\`experimental.dynamicIO\\` calling this function without a callback argument will not correctly trigger dynamic behavior.`);\n    }\n    const randomFillSyncExpression = \"`require('node:crypto').randomFillSync(...)`\";\n    try {\n        const _randomFillSync = nodeCrypto.randomFillSync;\n        nodeCrypto.randomFillSync = function randomFillSync() {\n            io(randomFillSyncExpression, 'random');\n            return _randomFillSync.apply(this, arguments);\n        };\n    } catch  {\n        console.error(`Failed to install ${randomFillSyncExpression} extension. When using \\`experimental.dynamicIO\\` calling this function will not correctly trigger dynamic behavior.`);\n    }\n    const randomIntExpression = \"`require('node:crypto').randomInt(min, max)`\";\n    try {\n        const _randomInt = nodeCrypto.randomInt;\n        nodeCrypto.randomInt = function randomInt() {\n            if (typeof arguments[2] !== 'function') {\n                // randomInt is sync if the third arg is undefined\n                io(randomIntExpression, 'random');\n            }\n            return _randomInt.apply(this, arguments);\n        };\n    } catch  {\n        console.error(`Failed to install ${randomBytesExpression} extension. When using \\`experimental.dynamicIO\\` calling this function without a callback argument will not correctly trigger dynamic behavior.`);\n    }\n    const generatePrimeSyncExpression = \"`require('node:crypto').generatePrimeSync(...)`\";\n    try {\n        const _generatePrimeSync = nodeCrypto.generatePrimeSync;\n        nodeCrypto.generatePrimeSync = function generatePrimeSync() {\n            io(generatePrimeSyncExpression, 'random');\n            return _generatePrimeSync.apply(this, arguments);\n        };\n    } catch  {\n        console.error(`Failed to install ${generatePrimeSyncExpression} extension. When using \\`experimental.dynamicIO\\` calling this function will not correctly trigger dynamic behavior.`);\n    }\n    const generateKeyPairSyncExpression = \"`require('node:crypto').generateKeyPairSync(...)`\";\n    try {\n        const _generateKeyPairSync = nodeCrypto.generateKeyPairSync;\n        nodeCrypto.generateKeyPairSync = function generateKeyPairSync() {\n            io(generateKeyPairSyncExpression, 'random');\n            return _generateKeyPairSync.apply(this, arguments);\n        };\n    } catch  {\n        console.error(`Failed to install ${generateKeyPairSyncExpression} extension. When using \\`experimental.dynamicIO\\` calling this function will not correctly trigger dynamic behavior.`);\n    }\n    const generateKeySyncExpression = \"`require('node:crypto').generateKeySync(...)`\";\n    try {\n        const _generateKeySync = nodeCrypto.generateKeySync;\n        nodeCrypto.generateKeySync = function generateKeySync() {\n            io(generateKeySyncExpression, 'random');\n            return _generateKeySync.apply(this, arguments);\n        };\n    } catch  {\n        console.error(`Failed to install ${generateKeySyncExpression} extension. When using \\`experimental.dynamicIO\\` calling this function will not correctly trigger dynamic behavior.`);\n    }\n}\n\n//# sourceMappingURL=node-crypto.js.map"
        }
    ]
}