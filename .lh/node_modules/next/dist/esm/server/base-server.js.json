{
    "sourceFile": "node_modules/next/dist/esm/server/base-server.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892826374,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import { getFallbackRouteParams } from './request/fallback-params';\nimport { CachedRouteKind } from './response-cache';\nimport { NormalizeError, DecodeError, normalizeRepeatedSlashes, MissingStaticPage } from '../shared/lib/utils';\nimport { format as formatUrl, parse as parseUrl } from 'url';\nimport { formatHostname } from './lib/format-hostname';\nimport { getRedirectStatus } from '../lib/redirect-status';\nimport { isEdgeRuntime } from '../lib/is-edge-runtime';\nimport { APP_PATHS_MANIFEST, NEXT_BUILTIN_DOCUMENT, PAGES_MANIFEST, STATIC_STATUS_PAGES, UNDERSCORE_NOT_FOUND_ROUTE, UNDERSCORE_NOT_FOUND_ROUTE_ENTRY } from '../shared/lib/constants';\nimport { isDynamicRoute } from '../shared/lib/router/utils';\nimport { checkIsOnDemandRevalidate } from './api-utils';\nimport { setConfig } from '../shared/lib/runtime-config.external';\nimport { getCacheControlHeader } from './lib/cache-control';\nimport { execOnce } from '../shared/lib/utils';\nimport { isBlockedPage } from './utils';\nimport { getBotType, isBot } from '../shared/lib/router/utils/is-bot';\nimport RenderResult from './render-result';\nimport { removeTrailingSlash } from '../shared/lib/router/utils/remove-trailing-slash';\nimport { denormalizePagePath } from '../shared/lib/page-path/denormalize-page-path';\nimport * as Log from '../build/output/log';\nimport { getPreviouslyRevalidatedTags, getUtils } from './server-utils';\nimport isError, { getProperError } from '../lib/is-error';\nimport { addRequestMeta, getRequestMeta, removeRequestMeta, setRequestMeta } from './request-meta';\nimport { removePathPrefix } from '../shared/lib/router/utils/remove-path-prefix';\nimport { normalizeAppPath } from '../shared/lib/router/utils/app-paths';\nimport { getHostname } from '../shared/lib/get-hostname';\nimport { parseUrl as parseUrlUtil } from '../shared/lib/router/utils/parse-url';\nimport { getNextPathnameInfo } from '../shared/lib/router/utils/get-next-pathname-info';\nimport { RSC_HEADER, NEXT_RSC_UNION_QUERY, NEXT_ROUTER_PREFETCH_HEADER, NEXT_ROUTER_SEGMENT_PREFETCH_HEADER, NEXT_DID_POSTPONE_HEADER, NEXT_URL, NEXT_IS_PRERENDER_HEADER } from '../client/components/app-router-headers';\nimport { LocaleRouteNormalizer } from './normalizers/locale-route-normalizer';\nimport { DefaultRouteMatcherManager } from './route-matcher-managers/default-route-matcher-manager';\nimport { AppPageRouteMatcherProvider } from './route-matcher-providers/app-page-route-matcher-provider';\nimport { AppRouteRouteMatcherProvider } from './route-matcher-providers/app-route-route-matcher-provider';\nimport { PagesAPIRouteMatcherProvider } from './route-matcher-providers/pages-api-route-matcher-provider';\nimport { PagesRouteMatcherProvider } from './route-matcher-providers/pages-route-matcher-provider';\nimport { ServerManifestLoader } from './route-matcher-providers/helpers/manifest-loaders/server-manifest-loader';\nimport { getTracer, isBubbledError, SpanKind } from './lib/trace/tracer';\nimport { BaseServerSpan } from './lib/trace/constants';\nimport { I18NProvider } from './lib/i18n-provider';\nimport { sendResponse } from './send-response';\nimport { fromNodeOutgoingHttpHeaders, normalizeNextQueryParam, toNodeOutgoingHttpHeaders } from './web/utils';\nimport { CACHE_ONE_YEAR, INFINITE_CACHE, MATCHED_PATH_HEADER, NEXT_CACHE_TAGS_HEADER, NEXT_RESUME_HEADER } from '../lib/constants';\nimport { normalizeLocalePath } from '../shared/lib/i18n/normalize-locale-path';\nimport { NextRequestAdapter, signalFromNodeResponse } from './web/spec-extension/adapters/next-request';\nimport { matchNextDataPathname } from './lib/match-next-data-pathname';\nimport getRouteFromAssetPath from '../shared/lib/router/utils/get-route-from-asset-path';\nimport { decodePathParams } from './lib/router-utils/decode-path-params';\nimport { RSCPathnameNormalizer } from './normalizers/request/rsc';\nimport { stripFlightHeaders } from './app-render/strip-flight-headers';\nimport { isAppPageRouteModule, isAppRouteRouteModule, isPagesRouteModule } from './route-modules/checks';\nimport { PrefetchRSCPathnameNormalizer } from './normalizers/request/prefetch-rsc';\nimport { NextDataPathnameNormalizer } from './normalizers/request/next-data';\nimport { getIsPossibleServerAction } from './lib/server-action-request-meta';\nimport { isInterceptionRouteAppPath } from '../shared/lib/router/utils/interception-routes';\nimport { toRoute } from './lib/to-route';\nimport { isNodeNextRequest, isNodeNextResponse } from './base-http/helpers';\nimport { patchSetHeaderWithCookieSupport } from './lib/patch-set-header';\nimport { checkIsAppPPREnabled } from './lib/experimental/ppr';\nimport { getBuiltinRequestContext } from './after/builtin-request-context';\nimport { ENCODED_TAGS } from './stream-utils/encodedTags';\nimport { NextRequestHint } from './web/adapter';\nimport { getRevalidateReason } from './instrumentation/utils';\nimport { RouteKind } from './route-kind';\nimport { FallbackMode, parseFallbackField } from '../lib/fallback';\nimport { toResponseCacheEntry } from './response-cache/utils';\nimport { scheduleOnNextTick } from '../lib/scheduler';\nimport { SegmentPrefixRSCPathnameNormalizer } from './normalizers/request/segment-prefix-rsc';\nimport { shouldServeStreamingMetadata, isHtmlBotRequest } from './lib/streaming-metadata';\nimport { InvariantError } from '../shared/lib/invariant-error';\nimport { decodeQueryPathParameter } from './lib/decode-query-path-parameter';\nimport { getCacheHandlers } from './use-cache/handlers';\nexport class NoFallbackError extends Error {\n}\n// Internal wrapper around build errors at development\n// time, to prevent us from propagating or logging them\nexport class WrappedBuildError extends Error {\n    constructor(innerError){\n        super();\n        this.innerError = innerError;\n    }\n}\nexport default class Server {\n    getServerComponentsHmrCache() {\n        return this.nextConfig.experimental.serverComponentsHmrCache ? globalThis.__serverComponentsHmrCache : undefined;\n    }\n    /**\n   * This is used to persist cache scopes across\n   * prefetch -> full route requests for dynamic IO\n   * it's only fully used in dev\n   */ constructor(options){\n        var _this_nextConfig_i18n, _this_nextConfig_experimental_amp, _this_nextConfig_i18n1;\n        this.handleRSCRequest = (req, _res, parsedUrl)=>{\n            var _this_normalizers_segmentPrefetchRSC, _this_normalizers_prefetchRSC, _this_normalizers_rsc;\n            if (!parsedUrl.pathname) return false;\n            if ((_this_normalizers_segmentPrefetchRSC = this.normalizers.segmentPrefetchRSC) == null ? void 0 : _this_normalizers_segmentPrefetchRSC.match(parsedUrl.pathname)) {\n                const result = this.normalizers.segmentPrefetchRSC.extract(parsedUrl.pathname);\n                if (!result) return false;\n                const { originalPathname, segmentPath } = result;\n                parsedUrl.pathname = originalPathname;\n                // Mark the request as a router prefetch request.\n                req.headers[RSC_HEADER.toLowerCase()] = '1';\n                req.headers[NEXT_ROUTER_PREFETCH_HEADER.toLowerCase()] = '1';\n                req.headers[NEXT_ROUTER_SEGMENT_PREFETCH_HEADER.toLowerCase()] = segmentPath;\n                addRequestMeta(req, 'isRSCRequest', true);\n                addRequestMeta(req, 'isPrefetchRSCRequest', true);\n                addRequestMeta(req, 'segmentPrefetchRSCRequest', segmentPath);\n            } else if ((_this_normalizers_prefetchRSC = this.normalizers.prefetchRSC) == null ? void 0 : _this_normalizers_prefetchRSC.match(parsedUrl.pathname)) {\n                parsedUrl.pathname = this.normalizers.prefetchRSC.normalize(parsedUrl.pathname, true);\n                // Mark the request as a router prefetch request.\n                req.headers[RSC_HEADER.toLowerCase()] = '1';\n                req.headers[NEXT_ROUTER_PREFETCH_HEADER.toLowerCase()] = '1';\n                addRequestMeta(req, 'isRSCRequest', true);\n                addRequestMeta(req, 'isPrefetchRSCRequest', true);\n            } else if ((_this_normalizers_rsc = this.normalizers.rsc) == null ? void 0 : _this_normalizers_rsc.match(parsedUrl.pathname)) {\n                parsedUrl.pathname = this.normalizers.rsc.normalize(parsedUrl.pathname, true);\n                // Mark the request as a RSC request.\n                req.headers[RSC_HEADER.toLowerCase()] = '1';\n                addRequestMeta(req, 'isRSCRequest', true);\n            } else if (req.headers['x-now-route-matches']) {\n                // If we didn't match, return with the flight headers stripped. If in\n                // minimal mode we didn't match based on the path, this can't be a RSC\n                // request. This is because Vercel only sends this header during\n                // revalidation requests and we want the cache to instead depend on the\n                // request path for flight information.\n                stripFlightHeaders(req.headers);\n                return false;\n            } else if (req.headers[RSC_HEADER.toLowerCase()] === '1') {\n                addRequestMeta(req, 'isRSCRequest', true);\n                if (req.headers[NEXT_ROUTER_PREFETCH_HEADER.toLowerCase()] === '1') {\n                    addRequestMeta(req, 'isPrefetchRSCRequest', true);\n                    const segmentPrefetchRSCRequest = req.headers[NEXT_ROUTER_SEGMENT_PREFETCH_HEADER.toLowerCase()];\n                    if (typeof segmentPrefetchRSCRequest === 'string') {\n                        addRequestMeta(req, 'segmentPrefetchRSCRequest', segmentPrefetchRSCRequest);\n                    }\n                }\n            } else {\n                // Otherwise just return without doing anything.\n                return false;\n            }\n            if (req.url) {\n                const parsed = parseUrl(req.url);\n                parsed.pathname = parsedUrl.pathname;\n                req.url = formatUrl(parsed);\n            }\n            return false;\n        };\n        this.handleNextDataRequest = async (req, res, parsedUrl)=>{\n            const middleware = await this.getMiddleware();\n            const params = matchNextDataPathname(parsedUrl.pathname);\n            // ignore for non-next data URLs\n            if (!params || !params.path) {\n                return false;\n            }\n            if (params.path[0] !== this.buildId) {\n                // Ignore if its a middleware request when we aren't on edge.\n                if (process.env.NEXT_RUNTIME !== 'edge' && getRequestMeta(req, 'middlewareInvoke')) {\n                    return false;\n                }\n                // Make sure to 404 if the buildId isn't correct\n                await this.render404(req, res, parsedUrl);\n                return true;\n            }\n            // remove buildId from URL\n            params.path.shift();\n            const lastParam = params.path[params.path.length - 1];\n            // show 404 if it doesn't end with .json\n            if (typeof lastParam !== 'string' || !lastParam.endsWith('.json')) {\n                await this.render404(req, res, parsedUrl);\n                return true;\n            }\n            // re-create page's pathname\n            let pathname = `/${params.path.join('/')}`;\n            pathname = getRouteFromAssetPath(pathname, '.json');\n            // ensure trailing slash is normalized per config\n            if (middleware) {\n                if (this.nextConfig.trailingSlash && !pathname.endsWith('/')) {\n                    pathname += '/';\n                }\n                if (!this.nextConfig.trailingSlash && pathname.length > 1 && pathname.endsWith('/')) {\n                    pathname = pathname.substring(0, pathname.length - 1);\n                }\n            }\n            if (this.i18nProvider) {\n                var _req_headers_host;\n                // Remove the port from the hostname if present.\n                const hostname = req == null ? void 0 : (_req_headers_host = req.headers.host) == null ? void 0 : _req_headers_host.split(':', 1)[0].toLowerCase();\n                const domainLocale = this.i18nProvider.detectDomainLocale(hostname);\n                const defaultLocale = (domainLocale == null ? void 0 : domainLocale.defaultLocale) ?? this.i18nProvider.config.defaultLocale;\n                const localePathResult = this.i18nProvider.analyze(pathname);\n                // If the locale is detected from the path, we need to remove it\n                // from the pathname.\n                if (localePathResult.detectedLocale) {\n                    pathname = localePathResult.pathname;\n                }\n                // Update the query with the detected locale and default locale.\n                addRequestMeta(req, 'locale', localePathResult.detectedLocale);\n                addRequestMeta(req, 'defaultLocale', defaultLocale);\n                // If the locale is not detected from the path, we need to mark that\n                // it was not inferred from default.\n                if (!localePathResult.detectedLocale) {\n                    removeRequestMeta(req, 'localeInferredFromDefault');\n                }\n                // If no locale was detected and we don't have middleware, we need\n                // to render a 404 page.\n                if (!localePathResult.detectedLocale && !middleware) {\n                    addRequestMeta(req, 'locale', defaultLocale);\n                    await this.render404(req, res, parsedUrl);\n                    return true;\n                }\n            }\n            parsedUrl.pathname = pathname;\n            addRequestMeta(req, 'isNextDataReq', true);\n            return false;\n        };\n        this.handleNextImageRequest = ()=>false;\n        this.handleCatchallRenderRequest = ()=>false;\n        this.handleCatchallMiddlewareRequest = ()=>false;\n        /**\n   * Normalizes a pathname without attaching any metadata from any matched\n   * normalizer.\n   *\n   * @param pathname the pathname to normalize\n   * @returns the normalized pathname\n   */ this.normalize = (pathname)=>{\n            const normalizers = [];\n            if (this.normalizers.data) {\n                normalizers.push(this.normalizers.data);\n            }\n            // We have to put the segment prefetch normalizer before the RSC normalizer\n            // because the RSC normalizer will match the prefetch RSC routes too.\n            if (this.normalizers.segmentPrefetchRSC) {\n                normalizers.push(this.normalizers.segmentPrefetchRSC);\n            }\n            // We have to put the prefetch normalizer before the RSC normalizer\n            // because the RSC normalizer will match the prefetch RSC routes too.\n            if (this.normalizers.prefetchRSC) {\n                normalizers.push(this.normalizers.prefetchRSC);\n            }\n            if (this.normalizers.rsc) {\n                normalizers.push(this.normalizers.rsc);\n            }\n            for (const normalizer of normalizers){\n                if (!normalizer.match(pathname)) continue;\n                return normalizer.normalize(pathname, true);\n            }\n            return pathname;\n        };\n        this.normalizeAndAttachMetadata = async (req, res, url)=>{\n            let finished = await this.handleNextImageRequest(req, res, url);\n            if (finished) return true;\n            if (this.enabledDirectories.pages) {\n                finished = await this.handleNextDataRequest(req, res, url);\n                if (finished) return true;\n            }\n            return false;\n        };\n        this.prepared = false;\n        this.preparedPromise = null;\n        this.customErrorNo404Warn = execOnce(()=>{\n            Log.warn(`You have added a custom /_error page without a custom /404 page. This prevents the 404 page from being auto statically optimized.\\nSee here for info: https://nextjs.org/docs/messages/custom-error-no-custom-404`);\n        });\n        const { dir = '.', quiet = false, conf, dev = false, minimalMode = false, hostname, port, experimentalTestProxy } = options;\n        this.experimentalTestProxy = experimentalTestProxy;\n        this.serverOptions = options;\n        this.dir = process.env.NEXT_RUNTIME === 'edge' ? dir : require('path').resolve(dir);\n        this.quiet = quiet;\n        this.loadEnvConfig({\n            dev\n        });\n        // TODO: should conf be normalized to prevent missing\n        // values from causing issues as this can be user provided\n        this.nextConfig = conf;\n        this.hostname = hostname;\n        if (this.hostname) {\n            // we format the hostname so that it can be fetched\n            this.fetchHostname = formatHostname(this.hostname);\n        }\n        this.port = port;\n        this.distDir = process.env.NEXT_RUNTIME === 'edge' ? this.nextConfig.distDir : require('path').join(this.dir, this.nextConfig.distDir);\n        this.publicDir = this.getPublicDir();\n        this.hasStaticDir = !minimalMode && this.getHasStaticDir();\n        this.i18nProvider = ((_this_nextConfig_i18n = this.nextConfig.i18n) == null ? void 0 : _this_nextConfig_i18n.locales) ? new I18NProvider(this.nextConfig.i18n) : undefined;\n        // Configure the locale normalizer, it's used for routes inside `pages/`.\n        this.localeNormalizer = this.i18nProvider ? new LocaleRouteNormalizer(this.i18nProvider) : undefined;\n        // Only serverRuntimeConfig needs the default\n        // publicRuntimeConfig gets it's default in client/index.js\n        const { serverRuntimeConfig = {}, publicRuntimeConfig, assetPrefix, generateEtags } = this.nextConfig;\n        this.buildId = this.getBuildId();\n        // this is a hack to avoid Webpack knowing this is equal to this.minimalMode\n        // because we replace this.minimalMode to true in production bundles.\n        const minimalModeKey = 'minimalMode';\n        this[minimalModeKey] = minimalMode || !!process.env.NEXT_PRIVATE_MINIMAL_MODE;\n        this.enabledDirectories = this.getEnabledDirectories(dev);\n        this.isAppPPREnabled = this.enabledDirectories.app && checkIsAppPPREnabled(this.nextConfig.experimental.ppr);\n        this.isAppSegmentPrefetchEnabled = this.enabledDirectories.app && this.nextConfig.experimental.clientSegmentCache === true;\n        this.normalizers = {\n            // We should normalize the pathname from the RSC prefix only in minimal\n            // mode as otherwise that route is not exposed external to the server as\n            // we instead only rely on the headers.\n            rsc: this.enabledDirectories.app && this.minimalMode ? new RSCPathnameNormalizer() : undefined,\n            prefetchRSC: this.isAppPPREnabled && this.minimalMode ? new PrefetchRSCPathnameNormalizer() : undefined,\n            segmentPrefetchRSC: this.isAppSegmentPrefetchEnabled && this.minimalMode ? new SegmentPrefixRSCPathnameNormalizer() : undefined,\n            data: this.enabledDirectories.pages ? new NextDataPathnameNormalizer(this.buildId) : undefined\n        };\n        this.nextFontManifest = this.getNextFontManifest();\n        if (process.env.NEXT_RUNTIME !== 'edge') {\n            process.env.NEXT_DEPLOYMENT_ID = this.nextConfig.deploymentId || '';\n        }\n        this.renderOpts = {\n            supportsDynamicResponse: true,\n            trailingSlash: this.nextConfig.trailingSlash,\n            deploymentId: this.nextConfig.deploymentId,\n            strictNextHead: this.nextConfig.experimental.strictNextHead ?? true,\n            poweredByHeader: this.nextConfig.poweredByHeader,\n            canonicalBase: this.nextConfig.amp.canonicalBase || '',\n            generateEtags,\n            previewProps: this.getPrerenderManifest().preview,\n            ampOptimizerConfig: (_this_nextConfig_experimental_amp = this.nextConfig.experimental.amp) == null ? void 0 : _this_nextConfig_experimental_amp.optimizer,\n            basePath: this.nextConfig.basePath,\n            images: this.nextConfig.images,\n            optimizeCss: this.nextConfig.experimental.optimizeCss,\n            nextConfigOutput: this.nextConfig.output,\n            nextScriptWorkers: this.nextConfig.experimental.nextScriptWorkers,\n            disableOptimizedLoading: this.nextConfig.experimental.disableOptimizedLoading,\n            domainLocales: (_this_nextConfig_i18n1 = this.nextConfig.i18n) == null ? void 0 : _this_nextConfig_i18n1.domains,\n            distDir: this.distDir,\n            serverComponents: this.enabledDirectories.app,\n            cacheLifeProfiles: this.nextConfig.experimental.cacheLife,\n            enableTainting: this.nextConfig.experimental.taint,\n            crossOrigin: this.nextConfig.crossOrigin ? this.nextConfig.crossOrigin : undefined,\n            largePageDataBytes: this.nextConfig.experimental.largePageDataBytes,\n            // Only the `publicRuntimeConfig` key is exposed to the client side\n            // It'll be rendered as part of __NEXT_DATA__ on the client side\n            runtimeConfig: Object.keys(publicRuntimeConfig).length > 0 ? publicRuntimeConfig : undefined,\n            // @ts-expect-error internal field not publicly exposed\n            isExperimentalCompile: this.nextConfig.experimental.isExperimentalCompile,\n            // `htmlLimitedBots` is passed to server as serialized config in string format\n            htmlLimitedBots: this.nextConfig.htmlLimitedBots,\n            experimental: {\n                expireTime: this.nextConfig.expireTime,\n                clientTraceMetadata: this.nextConfig.experimental.clientTraceMetadata,\n                dynamicIO: this.nextConfig.experimental.dynamicIO ?? false,\n                clientSegmentCache: this.nextConfig.experimental.clientSegmentCache === 'client-only' ? 'client-only' : Boolean(this.nextConfig.experimental.clientSegmentCache),\n                dynamicOnHover: this.nextConfig.experimental.dynamicOnHover ?? false,\n                inlineCss: this.nextConfig.experimental.inlineCss ?? false,\n                authInterrupts: !!this.nextConfig.experimental.authInterrupts\n            },\n            onInstrumentationRequestError: this.instrumentationOnRequestError.bind(this),\n            reactMaxHeadersLength: this.nextConfig.reactMaxHeadersLength\n        };\n        // Initialize next/config with the environment configuration\n        setConfig({\n            serverRuntimeConfig,\n            publicRuntimeConfig\n        });\n        this.pagesManifest = this.getPagesManifest();\n        this.appPathsManifest = this.getAppPathsManifest();\n        this.appPathRoutes = this.getAppPathRoutes();\n        this.interceptionRoutePatterns = this.getinterceptionRoutePatterns();\n        // Configure the routes.\n        this.matchers = this.getRouteMatchers();\n        // Start route compilation. We don't wait for the routes to finish loading\n        // because we use the `waitTillReady` promise below in `handleRequest` to\n        // wait. Also we can't `await` in the constructor.\n        void this.matchers.reload();\n        this.setAssetPrefix(assetPrefix);\n        this.responseCache = this.getResponseCache({\n            dev\n        });\n    }\n    reloadMatchers() {\n        return this.matchers.reload();\n    }\n    getRouteMatchers() {\n        // Create a new manifest loader that get's the manifests from the server.\n        const manifestLoader = new ServerManifestLoader((name)=>{\n            switch(name){\n                case PAGES_MANIFEST:\n                    return this.getPagesManifest() ?? null;\n                case APP_PATHS_MANIFEST:\n                    return this.getAppPathsManifest() ?? null;\n                default:\n                    return null;\n            }\n        });\n        // Configure the matchers and handlers.\n        const matchers = new DefaultRouteMatcherManager();\n        // Match pages under `pages/`.\n        matchers.push(new PagesRouteMatcherProvider(this.distDir, manifestLoader, this.i18nProvider));\n        // Match api routes under `pages/api/`.\n        matchers.push(new PagesAPIRouteMatcherProvider(this.distDir, manifestLoader, this.i18nProvider));\n        // If the app directory is enabled, then add the app matchers and handlers.\n        if (this.enabledDirectories.app) {\n            // Match app pages under `app/`.\n            matchers.push(new AppPageRouteMatcherProvider(this.distDir, manifestLoader));\n            matchers.push(new AppRouteRouteMatcherProvider(this.distDir, manifestLoader));\n        }\n        return matchers;\n    }\n    async instrumentationOnRequestError(...args) {\n        const [err, req, ctx] = args;\n        if (this.instrumentation) {\n            try {\n                await (this.instrumentation.onRequestError == null ? void 0 : this.instrumentation.onRequestError.call(this.instrumentation, err, {\n                    path: req.url || '',\n                    method: req.method || 'GET',\n                    // Normalize middleware headers and other server request headers\n                    headers: req instanceof NextRequestHint ? Object.fromEntries(req.headers.entries()) : req.headers\n                }, ctx));\n            } catch (handlerErr) {\n                // Log the soft error and continue, since errors can thrown from react stream handler\n                console.error('Error in instrumentation.onRequestError:', handlerErr);\n            }\n        }\n    }\n    logError(err) {\n        if (this.quiet) return;\n        Log.error(err);\n    }\n    async handleRequest(req, res, parsedUrl) {\n        await this.prepare();\n        const method = req.method.toUpperCase();\n        const tracer = getTracer();\n        return tracer.withPropagatedContext(req.headers, ()=>{\n            return tracer.trace(BaseServerSpan.handleRequest, {\n                spanName: `${method} ${req.url}`,\n                kind: SpanKind.SERVER,\n                attributes: {\n                    'http.method': method,\n                    'http.target': req.url\n                }\n            }, async (span)=>this.handleRequestImpl(req, res, parsedUrl).finally(()=>{\n                    if (!span) return;\n                    const isRSCRequest = getRequestMeta(req, 'isRSCRequest') ?? false;\n                    span.setAttributes({\n                        'http.status_code': res.statusCode,\n                        'next.rsc': isRSCRequest\n                    });\n                    const rootSpanAttributes = tracer.getRootSpanAttributes();\n                    // We were unable to get attributes, probably OTEL is not enabled\n                    if (!rootSpanAttributes) return;\n                    if (rootSpanAttributes.get('next.span_type') !== BaseServerSpan.handleRequest) {\n                        console.warn(`Unexpected root span type '${rootSpanAttributes.get('next.span_type')}'. Please report this Next.js issue https://github.com/vercel/next.js`);\n                        return;\n                    }\n                    const route = rootSpanAttributes.get('next.route');\n                    if (route) {\n                        const name = isRSCRequest ? `RSC ${method} ${route}` : `${method} ${route}`;\n                        span.setAttributes({\n                            'next.route': route,\n                            'http.route': route,\n                            'next.span_name': name\n                        });\n                        span.updateName(name);\n                    } else {\n                        span.updateName(isRSCRequest ? `RSC ${method} ${req.url}` : `${method} ${req.url}`);\n                    }\n                }));\n        });\n    }\n    async handleRequestImpl(req, res, parsedUrl) {\n        try {\n            var _originalRequest_socket, _originalRequest_socket1, _this_i18nProvider, _this_nextConfig_i18n;\n            // Wait for the matchers to be ready.\n            await this.matchers.waitTillReady();\n            // ensure cookies set in middleware are merged and\n            // not overridden by API routes/getServerSideProps\n            patchSetHeaderWithCookieSupport(req, isNodeNextResponse(res) ? res.originalResponse : res);\n            const urlParts = (req.url || '').split('?', 1);\n            const urlNoQuery = urlParts[0];\n            // this normalizes repeated slashes in the path e.g. hello//world ->\n            // hello/world or backslashes to forward slashes, this does not\n            // handle trailing slash as that is handled the same as a next.config.js\n            // redirect\n            if (urlNoQuery == null ? void 0 : urlNoQuery.match(/(\\\\|\\/\\/)/)) {\n                const cleanUrl = normalizeRepeatedSlashes(req.url);\n                res.redirect(cleanUrl, 308).body(cleanUrl).send();\n                return;\n            }\n            // Parse url if parsedUrl not provided\n            if (!parsedUrl || typeof parsedUrl !== 'object') {\n                if (!req.url) {\n                    throw Object.defineProperty(new Error('Invariant: url can not be undefined'), \"__NEXT_ERROR_CODE\", {\n                        value: \"E123\",\n                        enumerable: false,\n                        configurable: true\n                    });\n                }\n                parsedUrl = parseUrl(req.url, true);\n            }\n            if (!parsedUrl.pathname) {\n                throw Object.defineProperty(new Error(\"Invariant: pathname can't be empty\"), \"__NEXT_ERROR_CODE\", {\n                    value: \"E412\",\n                    enumerable: false,\n                    configurable: true\n                });\n            }\n            // Parse the querystring ourselves if the user doesn't handle querystring parsing\n            if (typeof parsedUrl.query === 'string') {\n                parsedUrl.query = Object.fromEntries(new URLSearchParams(parsedUrl.query));\n            }\n            // Update the `x-forwarded-*` headers.\n            const { originalRequest = null } = isNodeNextRequest(req) ? req : {};\n            const xForwardedProto = originalRequest == null ? void 0 : originalRequest.headers['x-forwarded-proto'];\n            const isHttps = xForwardedProto ? xForwardedProto === 'https' : !!(originalRequest == null ? void 0 : (_originalRequest_socket = originalRequest.socket) == null ? void 0 : _originalRequest_socket.encrypted);\n            req.headers['x-forwarded-host'] ??= req.headers['host'] ?? this.hostname;\n            req.headers['x-forwarded-port'] ??= this.port ? this.port.toString() : isHttps ? '443' : '80';\n            req.headers['x-forwarded-proto'] ??= isHttps ? 'https' : 'http';\n            req.headers['x-forwarded-for'] ??= originalRequest == null ? void 0 : (_originalRequest_socket1 = originalRequest.socket) == null ? void 0 : _originalRequest_socket1.remoteAddress;\n            // This should be done before any normalization of the pathname happens as\n            // it captures the initial URL.\n            this.attachRequestMeta(req, parsedUrl);\n            let finished = await this.handleRSCRequest(req, res, parsedUrl);\n            if (finished) return;\n            const domainLocale = (_this_i18nProvider = this.i18nProvider) == null ? void 0 : _this_i18nProvider.detectDomainLocale(getHostname(parsedUrl, req.headers));\n            const defaultLocale = (domainLocale == null ? void 0 : domainLocale.defaultLocale) || ((_this_nextConfig_i18n = this.nextConfig.i18n) == null ? void 0 : _this_nextConfig_i18n.defaultLocale);\n            addRequestMeta(req, 'defaultLocale', defaultLocale);\n            const url = parseUrlUtil(req.url.replace(/^\\/+/, '/'));\n            const pathnameInfo = getNextPathnameInfo(url.pathname, {\n                nextConfig: this.nextConfig,\n                i18nProvider: this.i18nProvider\n            });\n            url.pathname = pathnameInfo.pathname;\n            if (pathnameInfo.basePath) {\n                req.url = removePathPrefix(req.url, this.nextConfig.basePath);\n            }\n            const useMatchedPathHeader = this.minimalMode && typeof req.headers[MATCHED_PATH_HEADER] === 'string';\n            // TODO: merge handling with invokePath\n            if (useMatchedPathHeader) {\n                try {\n                    var _this_normalizers_data, _this_i18nProvider1, _this_getRoutesManifest;\n                    if (this.enabledDirectories.app) {\n                        // ensure /index path is normalized for prerender\n                        // in minimal mode\n                        if (req.url.match(/^\\/index($|\\?)/)) {\n                            req.url = req.url.replace(/^\\/index/, '/');\n                        }\n                        parsedUrl.pathname = parsedUrl.pathname === '/index' ? '/' : parsedUrl.pathname;\n                    }\n                    // x-matched-path is the source of truth, it tells what page\n                    // should be rendered because we don't process rewrites in minimalMode\n                    let { pathname: matchedPath } = new URL(req.headers[MATCHED_PATH_HEADER], 'http://localhost');\n                    let { pathname: urlPathname } = new URL(req.url, 'http://localhost');\n                    // For ISR the URL is normalized to the prerenderPath so if\n                    // it's a data request the URL path will be the data URL,\n                    // basePath is already stripped by this point\n                    if ((_this_normalizers_data = this.normalizers.data) == null ? void 0 : _this_normalizers_data.match(urlPathname)) {\n                        addRequestMeta(req, 'isNextDataReq', true);\n                    } else if (this.isAppPPREnabled && this.minimalMode && req.headers[NEXT_RESUME_HEADER] === '1' && req.method === 'POST') {\n                        // Decode the postponed state from the request body, it will come as\n                        // an array of buffers, so collect them and then concat them to form\n                        // the string.\n                        const body = [];\n                        for await (const chunk of req.body){\n                            body.push(chunk);\n                        }\n                        const postponed = Buffer.concat(body).toString('utf8');\n                        addRequestMeta(req, 'postponed', postponed);\n                    }\n                    matchedPath = this.normalize(matchedPath);\n                    const normalizedUrlPath = this.stripNextDataPath(urlPathname);\n                    // Perform locale detection and normalization.\n                    const localeAnalysisResult = (_this_i18nProvider1 = this.i18nProvider) == null ? void 0 : _this_i18nProvider1.analyze(matchedPath, {\n                        defaultLocale\n                    });\n                    // The locale result will be defined even if the locale was not\n                    // detected for the request because it will be inferred from the\n                    // default locale.\n                    if (localeAnalysisResult) {\n                        addRequestMeta(req, 'locale', localeAnalysisResult.detectedLocale);\n                        // If the detected locale was inferred from the default locale, we\n                        // need to modify the metadata on the request to indicate that.\n                        if (localeAnalysisResult.inferredFromDefault) {\n                            addRequestMeta(req, 'localeInferredFromDefault', true);\n                        } else {\n                            removeRequestMeta(req, 'localeInferredFromDefault');\n                        }\n                    }\n                    // TODO: check if this is needed any more?\n                    matchedPath = denormalizePagePath(matchedPath);\n                    let srcPathname = matchedPath;\n                    let pageIsDynamic = isDynamicRoute(srcPathname);\n                    if (!pageIsDynamic) {\n                        const match = await this.matchers.match(srcPathname, {\n                            i18n: localeAnalysisResult\n                        });\n                        // Update the source pathname to the matched page's pathname.\n                        if (match) {\n                            srcPathname = match.definition.pathname;\n                            // The page is dynamic if the params are defined.\n                            pageIsDynamic = typeof match.params !== 'undefined';\n                        }\n                    }\n                    // The rest of this function can't handle i18n properly, so ensure we\n                    // restore the pathname with the locale information stripped from it\n                    // now that we're done matching if we're using i18n.\n                    if (localeAnalysisResult) {\n                        matchedPath = localeAnalysisResult.pathname;\n                    }\n                    const utils = getUtils({\n                        pageIsDynamic,\n                        page: srcPathname,\n                        i18n: this.nextConfig.i18n,\n                        basePath: this.nextConfig.basePath,\n                        rewrites: ((_this_getRoutesManifest = this.getRoutesManifest()) == null ? void 0 : _this_getRoutesManifest.rewrites) || {\n                            beforeFiles: [],\n                            afterFiles: [],\n                            fallback: []\n                        },\n                        caseSensitive: !!this.nextConfig.experimental.caseSensitiveRoutes\n                    });\n                    // Ensure parsedUrl.pathname includes locale before processing\n                    // rewrites or they won't match correctly.\n                    if (defaultLocale && !pathnameInfo.locale) {\n                        parsedUrl.pathname = `/${defaultLocale}${parsedUrl.pathname}`;\n                    }\n                    const pathnameBeforeRewrite = parsedUrl.pathname;\n                    const rewriteParamKeys = Object.keys(utils.handleRewrites(req, parsedUrl));\n                    const didRewrite = pathnameBeforeRewrite !== parsedUrl.pathname;\n                    if (didRewrite && parsedUrl.pathname) {\n                        addRequestMeta(req, 'rewroteURL', parsedUrl.pathname);\n                    }\n                    // Create a copy of the query params to avoid mutating the original\n                    // object. This prevents any overlapping query params that have the\n                    // same normalized key from causing issues.\n                    const queryParams = {\n                        ...parsedUrl.query\n                    };\n                    for (const [key, value] of Object.entries(parsedUrl.query)){\n                        const normalizedKey = normalizeNextQueryParam(key);\n                        if (!normalizedKey) continue;\n                        // Remove the prefixed key from the query params because we want\n                        // to consume it for the dynamic route matcher.\n                        delete parsedUrl.query[key];\n                        if (typeof value === 'undefined') continue;\n                        queryParams[normalizedKey] = Array.isArray(value) ? value.map((v)=>decodeQueryPathParameter(v)) : decodeQueryPathParameter(value);\n                    }\n                    // interpolate dynamic params and normalize URL if needed\n                    if (pageIsDynamic) {\n                        let params = {};\n                        let paramsResult = utils.normalizeDynamicRouteParams(queryParams, false);\n                        // for prerendered ISR paths we attempt parsing the route\n                        // params from the URL directly as route-matches may not\n                        // contain the correct values due to the filesystem path\n                        // matching before the dynamic route has been matched\n                        if (!paramsResult.hasValidParams && !isDynamicRoute(normalizedUrlPath)) {\n                            let matcherParams = utils.dynamicRouteMatcher == null ? void 0 : utils.dynamicRouteMatcher.call(utils, normalizedUrlPath);\n                            if (matcherParams) {\n                                utils.normalizeDynamicRouteParams(matcherParams, false);\n                                Object.assign(paramsResult.params, matcherParams);\n                                paramsResult.hasValidParams = true;\n                            }\n                        }\n                        // if an action request is bypassing a prerender and we\n                        // don't have the params in the URL since it was prerendered\n                        // and matched during handle: 'filesystem' rather than dynamic route\n                        // resolving we need to parse the params from the matched-path.\n                        // Note: this is similar to above case but from match-path instead\n                        // of from the request URL since a rewrite could cause that to not\n                        // match the src pathname\n                        if (// we can have a collision with /index and a top-level /[slug]\n                        matchedPath !== '/index' && !paramsResult.hasValidParams && !isDynamicRoute(matchedPath)) {\n                            let matcherParams = utils.dynamicRouteMatcher == null ? void 0 : utils.dynamicRouteMatcher.call(utils, matchedPath);\n                            if (matcherParams) {\n                                const curParamsResult = utils.normalizeDynamicRouteParams(matcherParams, false);\n                                if (curParamsResult.hasValidParams) {\n                                    Object.assign(params, matcherParams);\n                                    paramsResult = curParamsResult;\n                                }\n                            }\n                        }\n                        if (paramsResult.hasValidParams) {\n                            params = paramsResult.params;\n                        }\n                        const routeMatchesHeader = req.headers['x-now-route-matches'];\n                        if (typeof routeMatchesHeader === 'string' && routeMatchesHeader && isDynamicRoute(matchedPath) && !paramsResult.hasValidParams) {\n                            const routeMatches = utils.getParamsFromRouteMatches(routeMatchesHeader);\n                            if (routeMatches) {\n                                paramsResult = utils.normalizeDynamicRouteParams(routeMatches, true);\n                                if (paramsResult.hasValidParams) {\n                                    params = paramsResult.params;\n                                }\n                            }\n                        }\n                        // Try to parse the params from the query if we couldn't parse them\n                        // from the route matches but ignore missing optional params.\n                        if (!paramsResult.hasValidParams) {\n                            paramsResult = utils.normalizeDynamicRouteParams(queryParams, true);\n                            if (paramsResult.hasValidParams) {\n                                params = paramsResult.params;\n                            }\n                        }\n                        // handle the actual dynamic route name being requested\n                        if (utils.defaultRouteMatches && normalizedUrlPath === srcPathname && !paramsResult.hasValidParams && !utils.normalizeDynamicRouteParams({\n                            ...params\n                        }, true).hasValidParams) {\n                            params = utils.defaultRouteMatches;\n                            // Mark that the default route matches were set on the request\n                            // during routing.\n                            addRequestMeta(req, 'didSetDefaultRouteMatches', true);\n                        }\n                        if (params) {\n                            matchedPath = utils.interpolateDynamicPath(srcPathname, params);\n                            req.url = utils.interpolateDynamicPath(req.url, params);\n                            // If the request is for a segment prefetch, we need to update the\n                            // segment prefetch request path to include the interpolated\n                            // params.\n                            let segmentPrefetchRSCRequest = getRequestMeta(req, 'segmentPrefetchRSCRequest');\n                            if (segmentPrefetchRSCRequest && isDynamicRoute(segmentPrefetchRSCRequest, false)) {\n                                segmentPrefetchRSCRequest = utils.interpolateDynamicPath(segmentPrefetchRSCRequest, params);\n                                req.headers[NEXT_ROUTER_SEGMENT_PREFETCH_HEADER.toLowerCase()] = segmentPrefetchRSCRequest;\n                                addRequestMeta(req, 'segmentPrefetchRSCRequest', segmentPrefetchRSCRequest);\n                            }\n                        }\n                    }\n                    if (pageIsDynamic || didRewrite) {\n                        var _utils_defaultRouteRegex;\n                        utils.normalizeVercelUrl(req, [\n                            ...rewriteParamKeys,\n                            ...Object.keys(((_utils_defaultRouteRegex = utils.defaultRouteRegex) == null ? void 0 : _utils_defaultRouteRegex.groups) || {})\n                        ]);\n                    }\n                    parsedUrl.pathname = matchedPath;\n                    url.pathname = parsedUrl.pathname;\n                    finished = await this.normalizeAndAttachMetadata(req, res, parsedUrl);\n                    if (finished) return;\n                } catch (err) {\n                    if (err instanceof DecodeError || err instanceof NormalizeError) {\n                        res.statusCode = 400;\n                        return this.renderError(null, req, res, '/_error', {});\n                    }\n                    throw err;\n                }\n            }\n            addRequestMeta(req, 'isLocaleDomain', Boolean(domainLocale));\n            if (pathnameInfo.locale) {\n                req.url = formatUrl(url);\n                addRequestMeta(req, 'didStripLocale', true);\n            }\n            // If we aren't in minimal mode or there is no locale in the query\n            // string, add the locale to the query string.\n            if (!this.minimalMode || !getRequestMeta(req, 'locale')) {\n                // If the locale is in the pathname, add it to the query string.\n                if (pathnameInfo.locale) {\n                    addRequestMeta(req, 'locale', pathnameInfo.locale);\n                } else if (defaultLocale) {\n                    addRequestMeta(req, 'locale', defaultLocale);\n                    addRequestMeta(req, 'localeInferredFromDefault', true);\n                }\n            }\n            // set incremental cache to request meta so it can\n            // be passed down for edge functions and the fetch disk\n            // cache can be leveraged locally\n            if (!this.serverOptions.webServerConfig && !getRequestMeta(req, 'incrementalCache')) {\n                let protocol = 'https:';\n                try {\n                    const parsedFullUrl = new URL(getRequestMeta(req, 'initURL') || '/', 'http://n');\n                    protocol = parsedFullUrl.protocol;\n                } catch  {}\n                const incrementalCache = await this.getIncrementalCache({\n                    requestHeaders: Object.assign({}, req.headers),\n                    requestProtocol: protocol.substring(0, protocol.length - 1)\n                });\n                incrementalCache.resetRequestCache();\n                addRequestMeta(req, 'incrementalCache', incrementalCache);\n                globalThis.__incrementalCache = incrementalCache;\n            }\n            const cacheHandlers = getCacheHandlers();\n            if (cacheHandlers) {\n                await Promise.all([\n                    ...cacheHandlers\n                ].map(async (cacheHandler)=>{\n                    if ('refreshTags' in cacheHandler) {\n                    // Note: cacheHandler.refreshTags() is called lazily before the\n                    // first cache entry is retrieved. It allows us to skip the\n                    // refresh request if no caches are read at all.\n                    } else {\n                        const previouslyRevalidatedTags = getPreviouslyRevalidatedTags(req.headers, this.getPrerenderManifest().preview.previewModeId);\n                        await cacheHandler.receiveExpiredTags(...previouslyRevalidatedTags);\n                    }\n                }));\n            }\n            // set server components HMR cache to request meta so it can be passed\n            // down for edge functions\n            if (!getRequestMeta(req, 'serverComponentsHmrCache')) {\n                addRequestMeta(req, 'serverComponentsHmrCache', this.getServerComponentsHmrCache());\n            }\n            // when invokePath is specified we can short short circuit resolving\n            // we only honor this header if we are inside of a render worker to\n            // prevent external users coercing the routing path\n            const invokePath = getRequestMeta(req, 'invokePath');\n            const useInvokePath = !useMatchedPathHeader && process.env.NEXT_RUNTIME !== 'edge' && invokePath;\n            if (useInvokePath) {\n                var _this_nextConfig_i18n1;\n                const invokeStatus = getRequestMeta(req, 'invokeStatus');\n                if (invokeStatus) {\n                    const invokeQuery = getRequestMeta(req, 'invokeQuery');\n                    if (invokeQuery) {\n                        Object.assign(parsedUrl.query, invokeQuery);\n                    }\n                    res.statusCode = invokeStatus;\n                    let err = getRequestMeta(req, 'invokeError') || null;\n                    return this.renderError(err, req, res, '/_error', parsedUrl.query);\n                }\n                const parsedMatchedPath = new URL(invokePath || '/', 'http://n');\n                const invokePathnameInfo = getNextPathnameInfo(parsedMatchedPath.pathname, {\n                    nextConfig: this.nextConfig,\n                    parseData: false\n                });\n                if (invokePathnameInfo.locale) {\n                    addRequestMeta(req, 'locale', invokePathnameInfo.locale);\n                }\n                if (parsedUrl.pathname !== parsedMatchedPath.pathname) {\n                    parsedUrl.pathname = parsedMatchedPath.pathname;\n                    addRequestMeta(req, 'rewroteURL', invokePathnameInfo.pathname);\n                }\n                const normalizeResult = normalizeLocalePath(removePathPrefix(parsedUrl.pathname, this.nextConfig.basePath || ''), (_this_nextConfig_i18n1 = this.nextConfig.i18n) == null ? void 0 : _this_nextConfig_i18n1.locales);\n                if (normalizeResult.detectedLocale) {\n                    addRequestMeta(req, 'locale', normalizeResult.detectedLocale);\n                }\n                parsedUrl.pathname = normalizeResult.pathname;\n                for (const key of Object.keys(parsedUrl.query)){\n                    delete parsedUrl.query[key];\n                }\n                const invokeQuery = getRequestMeta(req, 'invokeQuery');\n                if (invokeQuery) {\n                    Object.assign(parsedUrl.query, invokeQuery);\n                }\n                finished = await this.normalizeAndAttachMetadata(req, res, parsedUrl);\n                if (finished) return;\n                await this.handleCatchallRenderRequest(req, res, parsedUrl);\n                return;\n            }\n            if (process.env.NEXT_RUNTIME !== 'edge' && getRequestMeta(req, 'middlewareInvoke')) {\n                finished = await this.normalizeAndAttachMetadata(req, res, parsedUrl);\n                if (finished) return;\n                finished = await this.handleCatchallMiddlewareRequest(req, res, parsedUrl);\n                if (finished) return;\n                const err = new Error();\n                err.result = {\n                    response: new Response(null, {\n                        headers: {\n                            'x-middleware-next': '1'\n                        }\n                    })\n                };\n                err.bubble = true;\n                throw err;\n            }\n            // This wasn't a request via the matched path or the invoke path, so\n            // prepare for a legacy run by removing the base path.\n            // ensure we strip the basePath when not using an invoke header\n            if (!useMatchedPathHeader && pathnameInfo.basePath) {\n                parsedUrl.pathname = removePathPrefix(parsedUrl.pathname, pathnameInfo.basePath);\n            }\n            res.statusCode = 200;\n            return await this.run(req, res, parsedUrl);\n        } catch (err) {\n            if (err instanceof NoFallbackError) {\n                throw err;\n            }\n            if (err && typeof err === 'object' && err.code === 'ERR_INVALID_URL' || err instanceof DecodeError || err instanceof NormalizeError) {\n                res.statusCode = 400;\n                return this.renderError(null, req, res, '/_error', {});\n            }\n            if (this.minimalMode || this.renderOpts.dev || isBubbledError(err) && err.bubble) {\n                throw err;\n            }\n            this.logError(getProperError(err));\n            res.statusCode = 500;\n            res.body('Internal Server Error').send();\n        }\n    }\n    /**\n   * @internal - this method is internal to Next.js and should not be used directly by end-users\n   */ getRequestHandlerWithMetadata(meta) {\n        const handler = this.getRequestHandler();\n        return (req, res, parsedUrl)=>{\n            setRequestMeta(req, meta);\n            return handler(req, res, parsedUrl);\n        };\n    }\n    getRequestHandler() {\n        return this.handleRequest.bind(this);\n    }\n    setAssetPrefix(prefix) {\n        this.renderOpts.assetPrefix = prefix ? prefix.replace(/\\/$/, '') : '';\n    }\n    /**\n   * Runs async initialization of server.\n   * It is idempotent, won't fire underlying initialization more than once.\n   */ async prepare() {\n        if (this.prepared) return;\n        if (this.preparedPromise === null) {\n            // Get instrumentation module\n            this.instrumentation = await this.loadInstrumentationModule();\n            this.preparedPromise = this.prepareImpl().then(()=>{\n                this.prepared = true;\n                this.preparedPromise = null;\n            });\n        }\n        return this.preparedPromise;\n    }\n    async prepareImpl() {}\n    async loadInstrumentationModule() {}\n    async close() {}\n    getAppPathRoutes() {\n        const appPathRoutes = {};\n        Object.keys(this.appPathsManifest || {}).forEach((entry)=>{\n            const normalizedPath = normalizeAppPath(entry);\n            if (!appPathRoutes[normalizedPath]) {\n                appPathRoutes[normalizedPath] = [];\n            }\n            appPathRoutes[normalizedPath].push(entry);\n        });\n        return appPathRoutes;\n    }\n    async run(req, res, parsedUrl) {\n        return getTracer().trace(BaseServerSpan.run, async ()=>this.runImpl(req, res, parsedUrl));\n    }\n    async runImpl(req, res, parsedUrl) {\n        await this.handleCatchallRenderRequest(req, res, parsedUrl);\n    }\n    async pipe(fn, partialContext) {\n        return getTracer().trace(BaseServerSpan.pipe, async ()=>this.pipeImpl(fn, partialContext));\n    }\n    async pipeImpl(fn, partialContext) {\n        const ua = partialContext.req.headers['user-agent'] || '';\n        const isBotRequest = isBot(ua);\n        const ctx = {\n            ...partialContext,\n            renderOpts: {\n                ...this.renderOpts,\n                supportsDynamicResponse: !isBotRequest,\n                botType: getBotType(ua),\n                serveStreamingMetadata: shouldServeStreamingMetadata(ua, this.nextConfig.htmlLimitedBots)\n            }\n        };\n        const payload = await fn(ctx);\n        if (payload === null) {\n            return;\n        }\n        const { req, res } = ctx;\n        const originalStatus = res.statusCode;\n        const { body, type } = payload;\n        let { cacheControl } = payload;\n        if (!res.sent) {\n            const { generateEtags, poweredByHeader, dev } = this.renderOpts;\n            // In dev, we should not cache pages for any reason.\n            if (dev) {\n                res.setHeader('Cache-Control', 'no-store, must-revalidate');\n                cacheControl = undefined;\n            }\n            if (cacheControl && cacheControl.expire === undefined) {\n                cacheControl.expire = this.nextConfig.expireTime;\n            }\n            await this.sendRenderResult(req, res, {\n                result: body,\n                type,\n                generateEtags,\n                poweredByHeader,\n                cacheControl\n            });\n            res.statusCode = originalStatus;\n        }\n    }\n    async getStaticHTML(fn, partialContext) {\n        const ctx = {\n            ...partialContext,\n            renderOpts: {\n                ...this.renderOpts,\n                supportsDynamicResponse: false\n            }\n        };\n        const payload = await fn(ctx);\n        if (payload === null) {\n            return null;\n        }\n        return payload.body.toUnchunkedString();\n    }\n    async render(req, res, pathname, query = {}, parsedUrl, internalRender = false) {\n        return getTracer().trace(BaseServerSpan.render, async ()=>this.renderImpl(req, res, pathname, query, parsedUrl, internalRender));\n    }\n    getWaitUntil() {\n        const builtinRequestContext = getBuiltinRequestContext();\n        if (builtinRequestContext) {\n            // the platform provided a request context.\n            // use the `waitUntil` from there, whether actually present or not --\n            // if not present, `after` will error.\n            // NOTE: if we're in an edge runtime sandbox, this context will be used to forward the outer waitUntil.\n            return builtinRequestContext.waitUntil;\n        }\n        if (this.minimalMode) {\n            // we're built for a serverless environment, and `waitUntil` is not available,\n            // but using a noop would likely lead to incorrect behavior,\n            // because we have no way of keeping the invocation alive.\n            // return nothing, and `after` will error if used.\n            //\n            // NOTE: for edge functions, `NextWebServer` always runs in minimal mode.\n            //\n            // NOTE: if we're in an edge runtime sandbox, waitUntil will be passed in using \"@next/request-context\",\n            // so we won't get here.\n            return undefined;\n        }\n        return this.getInternalWaitUntil();\n    }\n    getInternalWaitUntil() {\n        return undefined;\n    }\n    async renderImpl(req, res, pathname, query = {}, parsedUrl, internalRender = false) {\n        var _req_url;\n        if (!pathname.startsWith('/')) {\n            console.warn(`Cannot render page with path \"${pathname}\", did you mean \"/${pathname}\"?. See more info here: https://nextjs.org/docs/messages/render-no-starting-slash`);\n        }\n        if (this.serverOptions.customServer && pathname === '/index' && !await this.hasPage('/index')) {\n            // maintain backwards compatibility for custom server\n            // (see custom-server integration tests)\n            pathname = '/';\n        }\n        // we allow custom servers to call render for all URLs\n        // so check if we need to serve a static _next file or not.\n        // we don't modify the URL for _next/data request but still\n        // call render so we special case this to prevent an infinite loop\n        if (!internalRender && !this.minimalMode && !getRequestMeta(req, 'isNextDataReq') && (((_req_url = req.url) == null ? void 0 : _req_url.match(/^\\/_next\\//)) || this.hasStaticDir && req.url.match(/^\\/static\\//))) {\n            return this.handleRequest(req, res, parsedUrl);\n        }\n        if (isBlockedPage(pathname)) {\n            return this.render404(req, res, parsedUrl);\n        }\n        return this.pipe((ctx)=>this.renderToResponse(ctx), {\n            req,\n            res,\n            pathname,\n            query\n        });\n    }\n    async getStaticPaths({ pathname }) {\n        var _this_getPrerenderManifest_dynamicRoutes_pathname;\n        // Read whether or not fallback should exist from the manifest.\n        const fallbackField = (_this_getPrerenderManifest_dynamicRoutes_pathname = this.getPrerenderManifest().dynamicRoutes[pathname]) == null ? void 0 : _this_getPrerenderManifest_dynamicRoutes_pathname.fallback;\n        return {\n            // `staticPaths` is intentionally set to `undefined` as it should've\n            // been caught when checking disk data.\n            staticPaths: undefined,\n            fallbackMode: parseFallbackField(fallbackField)\n        };\n    }\n    async renderToResponseWithComponents(requestContext, findComponentsResult) {\n        return getTracer().trace(BaseServerSpan.renderToResponseWithComponents, async ()=>this.renderToResponseWithComponentsImpl(requestContext, findComponentsResult));\n    }\n    pathCouldBeIntercepted(resolvedPathname) {\n        return isInterceptionRouteAppPath(resolvedPathname) || this.interceptionRoutePatterns.some((regexp)=>{\n            return regexp.test(resolvedPathname);\n        });\n    }\n    setVaryHeader(req, res, isAppPath, resolvedPathname) {\n        let addedNextUrlToVary = false;\n        if (isAppPath && this.pathCouldBeIntercepted(resolvedPathname)) {\n            // Interception route responses can vary based on the `Next-URL` header.\n            // We use the Vary header to signal this behavior to the client to properly cache the response.\n            res.appendHeader('vary', `${NEXT_URL}`);\n            addedNextUrlToVary = true;\n        }\n        // For other cases such as App Router requests or RSC requests we don't need to set vary header since we already\n        // have the _rsc query with the unique hash value.\n        if (!addedNextUrlToVary) {\n            // Remove `Next-URL` from the request headers we determined it wasn't necessary to include in the Vary header.\n            // This is to avoid any dependency on the `Next-URL` header being present when preparing the response.\n            delete req.headers[NEXT_URL];\n        }\n    }\n    async renderToResponseWithComponentsImpl({ req, res, pathname, renderOpts: opts }, { components, query }) {\n        var _components_Component, _this_nextConfig_i18n, _this, _this_nextConfig_i18n1, _cacheEntry_value, _cacheEntry_value1;\n        if (pathname === UNDERSCORE_NOT_FOUND_ROUTE) {\n            pathname = '/404';\n        }\n        const isErrorPathname = pathname === '/_error';\n        const is404Page = pathname === '/404' || isErrorPathname && res.statusCode === 404;\n        const is500Page = pathname === '/500' || isErrorPathname && res.statusCode === 500;\n        const isAppPath = components.isAppPath === true;\n        const hasServerProps = !!components.getServerSideProps;\n        let hasGetStaticPaths = !!components.getStaticPaths;\n        const isPossibleServerAction = getIsPossibleServerAction(req);\n        const hasGetInitialProps = !!((_components_Component = components.Component) == null ? void 0 : _components_Component.getInitialProps);\n        let isSSG = !!components.getStaticProps;\n        // Compute the iSSG cache key. We use the rewroteUrl since\n        // pages with fallback: false are allowed to be rewritten to\n        // and we need to look up the path by the rewritten path\n        let urlPathname = parseUrl(req.url || '').pathname || '/';\n        let resolvedUrlPathname = getRequestMeta(req, 'rewroteURL') || urlPathname;\n        this.setVaryHeader(req, res, isAppPath, resolvedUrlPathname);\n        let staticPaths;\n        let fallbackMode;\n        let hasFallback = false;\n        const isDynamic = isDynamicRoute(components.page);\n        const prerenderManifest = this.getPrerenderManifest();\n        if (isAppPath && isDynamic) {\n            const pathsResult = await this.getStaticPaths({\n                pathname,\n                page: components.page,\n                isAppPath,\n                requestHeaders: req.headers\n            });\n            staticPaths = pathsResult.staticPaths;\n            fallbackMode = pathsResult.fallbackMode;\n            hasFallback = typeof fallbackMode !== 'undefined';\n            if (this.nextConfig.output === 'export') {\n                const page = components.page;\n                if (!staticPaths) {\n                    throw Object.defineProperty(new Error(`Page \"${page}\" is missing exported function \"generateStaticParams()\", which is required with \"output: export\" config.`), \"__NEXT_ERROR_CODE\", {\n                        value: \"E353\",\n                        enumerable: false,\n                        configurable: true\n                    });\n                }\n                const resolvedWithoutSlash = removeTrailingSlash(resolvedUrlPathname);\n                if (!staticPaths.includes(resolvedWithoutSlash)) {\n                    throw Object.defineProperty(new Error(`Page \"${page}\" is missing param \"${resolvedWithoutSlash}\" in \"generateStaticParams()\", which is required with \"output: export\" config.`), \"__NEXT_ERROR_CODE\", {\n                        value: \"E443\",\n                        enumerable: false,\n                        configurable: true\n                    });\n                }\n            }\n            if (hasFallback) {\n                hasGetStaticPaths = true;\n            }\n        }\n        if (hasFallback || (staticPaths == null ? void 0 : staticPaths.includes(resolvedUrlPathname)) || // this signals revalidation in deploy environments\n        // TODO: make this more generic\n        req.headers['x-now-route-matches']) {\n            isSSG = true;\n        } else if (!this.renderOpts.dev) {\n            isSSG ||= !!prerenderManifest.routes[toRoute(pathname)];\n        }\n        // Toggle whether or not this is a Data request\n        const isNextDataRequest = !!(getRequestMeta(req, 'isNextDataReq') || req.headers['x-nextjs-data'] && this.serverOptions.webServerConfig) && (isSSG || hasServerProps);\n        /**\n     * If true, this indicates that the request being made is for an app\n     * prefetch request.\n     */ const isPrefetchRSCRequest = getRequestMeta(req, 'isPrefetchRSCRequest') ?? false;\n        // NOTE: Don't delete headers[RSC] yet, it still needs to be used in renderToHTML later\n        const isRSCRequest = getRequestMeta(req, 'isRSCRequest') ?? false;\n        // when we are handling a middleware prefetch and it doesn't\n        // resolve to a static data route we bail early to avoid\n        // unexpected SSR invocations\n        if (!isSSG && req.headers['x-middleware-prefetch'] && !(is404Page || pathname === '/_error')) {\n            res.setHeader(MATCHED_PATH_HEADER, pathname);\n            res.setHeader('x-middleware-skip', '1');\n            res.setHeader('cache-control', 'private, no-cache, no-store, max-age=0, must-revalidate');\n            res.body('{}').send();\n            return null;\n        }\n        // normalize req.url for SSG paths as it is not exposed\n        // to getStaticProps and the asPath should not expose /_next/data\n        if (isSSG && this.minimalMode && req.headers[MATCHED_PATH_HEADER] && req.url.startsWith('/_next/data')) {\n            req.url = this.stripNextDataPath(req.url);\n        }\n        const locale = getRequestMeta(req, 'locale');\n        const defaultLocale = isSSG ? (_this_nextConfig_i18n = this.nextConfig.i18n) == null ? void 0 : _this_nextConfig_i18n.defaultLocale : getRequestMeta(req, 'defaultLocale');\n        if (!!req.headers['x-nextjs-data'] && (!res.statusCode || res.statusCode === 200)) {\n            res.setHeader('x-nextjs-matched-path', `${locale ? `/${locale}` : ''}${pathname}`);\n        }\n        let routeModule;\n        if (components.routeModule) {\n            routeModule = components.routeModule;\n        }\n        /**\n     * If the route being rendered is an app page, and the ppr feature has been\n     * enabled, then the given route _could_ support PPR.\n     */ const couldSupportPPR = this.isAppPPREnabled && typeof routeModule !== 'undefined' && isAppPageRouteModule(routeModule);\n        // When enabled, this will allow the use of the `?__nextppronly` query to\n        // enable debugging of the static shell.\n        const hasDebugStaticShellQuery = process.env.__NEXT_EXPERIMENTAL_STATIC_SHELL_DEBUGGING === '1' && typeof query.__nextppronly !== 'undefined' && couldSupportPPR;\n        // When enabled, this will allow the use of the `?__nextppronly` query\n        // to enable debugging of the fallback shell.\n        const hasDebugFallbackShellQuery = hasDebugStaticShellQuery && query.__nextppronly === 'fallback';\n        // This page supports PPR if it is marked as being `PARTIALLY_STATIC` in the\n        // prerender manifest and this is an app page.\n        const isRoutePPREnabled = couldSupportPPR && (((_this = prerenderManifest.routes[pathname] ?? prerenderManifest.dynamicRoutes[pathname]) == null ? void 0 : _this.renderingMode) === 'PARTIALLY_STATIC' || // Ideally we'd want to check the appConfig to see if this page has PPR\n        // enabled or not, but that would require plumbing the appConfig through\n        // to the server during development. We assume that the page supports it\n        // but only during development.\n        hasDebugStaticShellQuery && (this.renderOpts.dev === true || this.experimentalTestProxy === true));\n        const isDebugStaticShell = hasDebugStaticShellQuery && isRoutePPREnabled;\n        // We should enable debugging dynamic accesses when the static shell\n        // debugging has been enabled and we're also in development mode.\n        const isDebugDynamicAccesses = isDebugStaticShell && this.renderOpts.dev === true;\n        const isDebugFallbackShell = hasDebugFallbackShellQuery && isRoutePPREnabled;\n        // If we're in minimal mode, then try to get the postponed information from\n        // the request metadata. If available, use it for resuming the postponed\n        // render.\n        const minimalPostponed = isRoutePPREnabled ? getRequestMeta(req, 'postponed') : undefined;\n        // If PPR is enabled, and this is a RSC request (but not a prefetch), then\n        // we can use this fact to only generate the flight data for the request\n        // because we can't cache the HTML (as it's also dynamic).\n        const isDynamicRSCRequest = isRoutePPREnabled && isRSCRequest && !isPrefetchRSCRequest;\n        // Need to read this before it's stripped by stripFlightHeaders. We don't\n        // need to transfer it to the request meta because it's only read\n        // within this function; the static segment data should have already been\n        // generated, so we will always either return a static response or a 404.\n        const segmentPrefetchHeader = getRequestMeta(req, 'segmentPrefetchRSCRequest');\n        const isHtmlBot = isHtmlBotRequest(req);\n        if (isHtmlBot && isRoutePPREnabled) {\n            isSSG = false;\n            this.renderOpts.serveStreamingMetadata = false;\n        }\n        // we need to ensure the status code if /404 is visited directly\n        if (is404Page && !isNextDataRequest && !isRSCRequest) {\n            res.statusCode = 404;\n        }\n        // ensure correct status is set when visiting a status page\n        // directly e.g. /500\n        if (STATIC_STATUS_PAGES.includes(pathname)) {\n            res.statusCode = parseInt(pathname.slice(1), 10);\n        }\n        if (// Server actions can use non-GET/HEAD methods.\n        !isPossibleServerAction && // Resume can use non-GET/HEAD methods.\n        !minimalPostponed && !is404Page && !is500Page && pathname !== '/_error' && req.method !== 'HEAD' && req.method !== 'GET' && (typeof components.Component === 'string' || isSSG)) {\n            res.statusCode = 405;\n            res.setHeader('Allow', [\n                'GET',\n                'HEAD'\n            ]);\n            res.body('Method Not Allowed').send();\n            return null;\n        }\n        // handle static page\n        if (typeof components.Component === 'string') {\n            return {\n                type: 'html',\n                // TODO: Static pages should be serialized as RenderResult\n                body: RenderResult.fromStatic(components.Component)\n            };\n        }\n        // Ensure that if the `amp` query parameter is falsy that we remove it from\n        // the query object. This ensures it won't be found by the `in` operator.\n        if ('amp' in query && !query.amp) delete query.amp;\n        if (opts.supportsDynamicResponse === true) {\n            var _components_Document;\n            const ua = req.headers['user-agent'] || '';\n            const isBotRequest = isBot(ua);\n            const isSupportedDocument = typeof ((_components_Document = components.Document) == null ? void 0 : _components_Document.getInitialProps) !== 'function' || // The built-in `Document` component also supports dynamic HTML for concurrent mode.\n            NEXT_BUILTIN_DOCUMENT in components.Document;\n            // Disable dynamic HTML in cases that we know it won't be generated,\n            // so that we can continue generating a cache key when possible.\n            // TODO-APP: should the first render for a dynamic app path\n            // be static so we can collect revalidate and populate the\n            // cache if there are no dynamic data requirements\n            opts.supportsDynamicResponse = !isSSG && !isBotRequest && !query.amp && isSupportedDocument;\n        }\n        // In development, we always want to generate dynamic HTML.\n        if (!isNextDataRequest && isAppPath && opts.dev) {\n            opts.supportsDynamicResponse = true;\n        }\n        const locales = (_this_nextConfig_i18n1 = this.nextConfig.i18n) == null ? void 0 : _this_nextConfig_i18n1.locales;\n        let previewData;\n        let isPreviewMode = false;\n        if (hasServerProps || isSSG || isAppPath) {\n            // For the edge runtime, we don't support preview mode in SSG.\n            if (process.env.NEXT_RUNTIME !== 'edge') {\n                const { tryGetPreviewData } = require('./api-utils/node/try-get-preview-data');\n                previewData = tryGetPreviewData(req, res, this.renderOpts.previewProps, !!this.nextConfig.experimental.multiZoneDraftMode);\n                isPreviewMode = previewData !== false;\n            }\n        }\n        // If this is a request for an app path that should be statically generated\n        // and we aren't in the edge runtime, strip the flight headers so it will\n        // generate the static response.\n        if (isAppPath && !opts.dev && !isPreviewMode && isSSG && isRSCRequest && !isDynamicRSCRequest && (!isEdgeRuntime(opts.runtime) || this.serverOptions.webServerConfig)) {\n            stripFlightHeaders(req.headers);\n        }\n        let { isOnDemandRevalidate, revalidateOnlyGenerated } = checkIsOnDemandRevalidate(req, this.renderOpts.previewProps);\n        if (isSSG && this.minimalMode && req.headers[MATCHED_PATH_HEADER]) {\n            // the url value is already correct when the matched-path header is set\n            resolvedUrlPathname = urlPathname;\n        }\n        urlPathname = removeTrailingSlash(urlPathname);\n        resolvedUrlPathname = removeTrailingSlash(resolvedUrlPathname);\n        if (this.localeNormalizer) {\n            resolvedUrlPathname = this.localeNormalizer.normalize(resolvedUrlPathname);\n        }\n        const handleRedirect = (pageData)=>{\n            const redirect = {\n                destination: pageData.pageProps.__N_REDIRECT,\n                statusCode: pageData.pageProps.__N_REDIRECT_STATUS,\n                basePath: pageData.pageProps.__N_REDIRECT_BASE_PATH\n            };\n            const statusCode = getRedirectStatus(redirect);\n            const { basePath } = this.nextConfig;\n            if (basePath && redirect.basePath !== false && redirect.destination.startsWith('/')) {\n                redirect.destination = `${basePath}${redirect.destination}`;\n            }\n            if (redirect.destination.startsWith('/')) {\n                redirect.destination = normalizeRepeatedSlashes(redirect.destination);\n            }\n            res.redirect(redirect.destination, statusCode).body(redirect.destination).send();\n        };\n        // remove /_next/data prefix from urlPathname so it matches\n        // for direct page visit and /_next/data visit\n        if (isNextDataRequest) {\n            resolvedUrlPathname = this.stripNextDataPath(resolvedUrlPathname);\n            urlPathname = this.stripNextDataPath(urlPathname);\n        }\n        let ssgCacheKey = null;\n        if (!isPreviewMode && isSSG && !opts.supportsDynamicResponse && !isPossibleServerAction && !minimalPostponed && !isDynamicRSCRequest) {\n            ssgCacheKey = `${locale ? `/${locale}` : ''}${(pathname === '/' || resolvedUrlPathname === '/') && locale ? '' : resolvedUrlPathname}${query.amp ? '.amp' : ''}`;\n        }\n        if ((is404Page || is500Page) && isSSG) {\n            ssgCacheKey = `${locale ? `/${locale}` : ''}${pathname}${query.amp ? '.amp' : ''}`;\n        }\n        if (ssgCacheKey) {\n            ssgCacheKey = decodePathParams(ssgCacheKey);\n            // ensure /index and / is normalized to one key\n            ssgCacheKey = ssgCacheKey === '/index' && pathname === '/' ? '/' : ssgCacheKey;\n        }\n        let protocol = 'https:';\n        try {\n            const parsedFullUrl = new URL(getRequestMeta(req, 'initURL') || '/', 'http://n');\n            protocol = parsedFullUrl.protocol;\n        } catch  {}\n        // use existing incrementalCache instance if available\n        const incrementalCache = globalThis.__incrementalCache || await this.getIncrementalCache({\n            requestHeaders: Object.assign({}, req.headers),\n            requestProtocol: protocol.substring(0, protocol.length - 1)\n        });\n        // TODO: investigate, this is not safe across multiple concurrent requests\n        incrementalCache.resetRequestCache();\n        const doRender = async ({ postponed, pagesFallback = false, fallbackRouteParams })=>{\n            // In development, we always want to generate dynamic HTML.\n            let supportsDynamicResponse = // If we're in development, we always support dynamic HTML, unless it's\n            // a data request, in which case we only produce static HTML.\n            !isNextDataRequest && opts.dev === true || // If this is not SSG or does not have static paths, then it supports\n            // dynamic HTML.\n            !isSSG && !hasGetStaticPaths || // If this request has provided postponed data, it supports dynamic\n            // HTML.\n            typeof postponed === 'string' || // If this is a dynamic RSC request, then this render supports dynamic\n            // HTML (it's dynamic).\n            isDynamicRSCRequest;\n            const origQuery = parseUrl(req.url || '', true).query;\n            // clear any dynamic route params so they aren't in\n            // the resolvedUrl\n            if (opts.params) {\n                Object.keys(opts.params).forEach((key)=>{\n                    delete origQuery[key];\n                });\n            }\n            const hadTrailingSlash = urlPathname !== '/' && this.nextConfig.trailingSlash;\n            const resolvedUrl = formatUrl({\n                pathname: `${resolvedUrlPathname}${hadTrailingSlash ? '/' : ''}`,\n                // make sure to only add query values from original URL\n                query: origQuery\n            });\n            // When html bots request PPR page, perform the full dynamic rendering.\n            const shouldWaitOnAllReady = isHtmlBot && isRoutePPREnabled;\n            const renderOpts = {\n                ...components,\n                ...opts,\n                ...isAppPath ? {\n                    incrementalCache,\n                    // This is a revalidation request if the request is for a static\n                    // page and it is not being resumed from a postponed render and\n                    // it is not a dynamic RSC request then it is a revalidation\n                    // request.\n                    isRevalidate: isSSG && !postponed && !isDynamicRSCRequest,\n                    serverActions: this.nextConfig.experimental.serverActions\n                } : {},\n                isNextDataRequest,\n                resolvedUrl,\n                locale,\n                locales,\n                defaultLocale,\n                multiZoneDraftMode: this.nextConfig.experimental.multiZoneDraftMode,\n                // For getServerSideProps and getInitialProps we need to ensure we use the original URL\n                // and not the resolved URL to prevent a hydration mismatch on\n                // asPath\n                resolvedAsPath: hasServerProps || hasGetInitialProps ? formatUrl({\n                    // we use the original URL pathname less the _next/data prefix if\n                    // present\n                    pathname: `${urlPathname}${hadTrailingSlash ? '/' : ''}`,\n                    query: origQuery\n                }) : resolvedUrl,\n                experimental: {\n                    ...opts.experimental,\n                    isRoutePPREnabled\n                },\n                supportsDynamicResponse,\n                shouldWaitOnAllReady,\n                isOnDemandRevalidate,\n                isDraftMode: isPreviewMode,\n                isPossibleServerAction,\n                postponed,\n                waitUntil: this.getWaitUntil(),\n                onClose: res.onClose.bind(res),\n                onAfterTaskError: undefined,\n                // only available in dev\n                setIsrStatus: this.setIsrStatus\n            };\n            if (isDebugStaticShell || isDebugDynamicAccesses) {\n                supportsDynamicResponse = false;\n                renderOpts.nextExport = true;\n                renderOpts.supportsDynamicResponse = false;\n                renderOpts.isStaticGeneration = true;\n                renderOpts.isRevalidate = true;\n                renderOpts.isDebugDynamicAccesses = isDebugDynamicAccesses;\n            }\n            // Legacy render methods will return a render result that needs to be\n            // served by the server.\n            let result;\n            if (routeModule) {\n                if (isAppRouteRouteModule(routeModule)) {\n                    var _this_nextConfig_experimental;\n                    if (// The type check here ensures that `req` is correctly typed, and the\n                    // environment variable check provides dead code elimination.\n                    process.env.NEXT_RUNTIME === 'edge' || !isNodeNextRequest(req) || !isNodeNextResponse(res)) {\n                        throw Object.defineProperty(new Error('Invariant: App Route Route Modules cannot be used in the edge runtime'), \"__NEXT_ERROR_CODE\", {\n                            value: \"E130\",\n                            enumerable: false,\n                            configurable: true\n                        });\n                    }\n                    const context = {\n                        params: opts.params,\n                        prerenderManifest,\n                        renderOpts: {\n                            experimental: {\n                                dynamicIO: renderOpts.experimental.dynamicIO,\n                                authInterrupts: renderOpts.experimental.authInterrupts\n                            },\n                            supportsDynamicResponse,\n                            incrementalCache,\n                            cacheLifeProfiles: (_this_nextConfig_experimental = this.nextConfig.experimental) == null ? void 0 : _this_nextConfig_experimental.cacheLife,\n                            isRevalidate: isSSG,\n                            waitUntil: this.getWaitUntil(),\n                            onClose: res.onClose.bind(res),\n                            onAfterTaskError: undefined,\n                            onInstrumentationRequestError: this.renderOpts.onInstrumentationRequestError\n                        },\n                        sharedContext: {\n                            buildId: this.buildId\n                        }\n                    };\n                    try {\n                        const request = NextRequestAdapter.fromNodeNextRequest(req, signalFromNodeResponse(res.originalResponse));\n                        const response = await routeModule.handle(request, context);\n                        req.fetchMetrics = context.renderOpts.fetchMetrics;\n                        const cacheTags = context.renderOpts.collectedTags;\n                        // If the request is for a static response, we can cache it so long\n                        // as it's not edge.\n                        if (isSSG) {\n                            const blob = await response.blob();\n                            // Copy the headers from the response.\n                            const headers = toNodeOutgoingHttpHeaders(response.headers);\n                            if (cacheTags) {\n                                headers[NEXT_CACHE_TAGS_HEADER] = cacheTags;\n                            }\n                            if (!headers['content-type'] && blob.type) {\n                                headers['content-type'] = blob.type;\n                            }\n                            const revalidate = typeof context.renderOpts.collectedRevalidate === 'undefined' || context.renderOpts.collectedRevalidate >= INFINITE_CACHE ? false : context.renderOpts.collectedRevalidate;\n                            const expire = typeof context.renderOpts.collectedExpire === 'undefined' || context.renderOpts.collectedExpire >= INFINITE_CACHE ? undefined : context.renderOpts.collectedExpire;\n                            // Create the cache entry for the response.\n                            const cacheEntry = {\n                                value: {\n                                    kind: CachedRouteKind.APP_ROUTE,\n                                    status: response.status,\n                                    body: Buffer.from(await blob.arrayBuffer()),\n                                    headers\n                                },\n                                cacheControl: {\n                                    revalidate,\n                                    expire\n                                },\n                                isFallback: false\n                            };\n                            return cacheEntry;\n                        }\n                        let pendingWaitUntil = context.renderOpts.pendingWaitUntil;\n                        // Attempt using provided waitUntil if available\n                        // if it's not we fallback to sendResponse's handling\n                        if (pendingWaitUntil) {\n                            if (context.renderOpts.waitUntil) {\n                                context.renderOpts.waitUntil(pendingWaitUntil);\n                                pendingWaitUntil = undefined;\n                            }\n                        }\n                        // Send the response now that we have copied it into the cache.\n                        await sendResponse(req, res, response, context.renderOpts.pendingWaitUntil);\n                        return null;\n                    } catch (err) {\n                        await this.instrumentationOnRequestError(err, req, {\n                            routerKind: 'App Router',\n                            routePath: pathname,\n                            routeType: 'route',\n                            revalidateReason: getRevalidateReason(renderOpts)\n                        });\n                        // If this is during static generation, throw the error again.\n                        if (isSSG) throw err;\n                        Log.error(err);\n                        // Otherwise, send a 500 response.\n                        await sendResponse(req, res, new Response(null, {\n                            status: 500\n                        }));\n                        return null;\n                    }\n                } else if (isPagesRouteModule(routeModule) || isAppPageRouteModule(routeModule)) {\n                    // An OPTIONS request to a page handler is invalid.\n                    if (req.method === 'OPTIONS' && !is404Page) {\n                        await sendResponse(req, res, new Response(null, {\n                            status: 400\n                        }));\n                        return null;\n                    }\n                    if (isPagesRouteModule(routeModule)) {\n                        // Due to the way we pass data by mutating `renderOpts`, we can't extend\n                        // the object here but only updating its `clientReferenceManifest` and\n                        // `nextFontManifest` properties.\n                        // https://github.com/vercel/next.js/blob/df7cbd904c3bd85f399d1ce90680c0ecf92d2752/packages/next/server/render.tsx#L947-L952\n                        renderOpts.nextFontManifest = this.nextFontManifest;\n                        renderOpts.clientReferenceManifest = components.clientReferenceManifest;\n                        const request = isNodeNextRequest(req) ? req.originalRequest : req;\n                        const response = isNodeNextResponse(res) ? res.originalResponse : res;\n                        // Call the built-in render method on the module.\n                        try {\n                            result = await routeModule.render(request, response, {\n                                page: pathname,\n                                params: opts.params,\n                                query,\n                                renderOpts,\n                                sharedContext: {\n                                    buildId: this.buildId,\n                                    deploymentId: this.nextConfig.deploymentId,\n                                    customServer: this.serverOptions.customServer || undefined\n                                },\n                                renderContext: {\n                                    isFallback: pagesFallback,\n                                    isDraftMode: renderOpts.isDraftMode,\n                                    developmentNotFoundSourcePage: getRequestMeta(req, 'developmentNotFoundSourcePage')\n                                }\n                            });\n                        } catch (err) {\n                            await this.instrumentationOnRequestError(err, req, {\n                                routerKind: 'Pages Router',\n                                routePath: pathname,\n                                routeType: 'render',\n                                revalidateReason: getRevalidateReason({\n                                    isRevalidate: isSSG,\n                                    isOnDemandRevalidate: renderOpts.isOnDemandRevalidate\n                                })\n                            });\n                            throw err;\n                        }\n                    } else {\n                        const module = components.routeModule;\n                        // Due to the way we pass data by mutating `renderOpts`, we can't extend the\n                        // object here but only updating its `nextFontManifest` field.\n                        // https://github.com/vercel/next.js/blob/df7cbd904c3bd85f399d1ce90680c0ecf92d2752/packages/next/server/render.tsx#L947-L952\n                        renderOpts.nextFontManifest = this.nextFontManifest;\n                        const context = {\n                            page: is404Page ? '/404' : pathname,\n                            params: opts.params,\n                            query,\n                            fallbackRouteParams,\n                            renderOpts,\n                            serverComponentsHmrCache: this.getServerComponentsHmrCache(),\n                            sharedContext: {\n                                buildId: this.buildId\n                            }\n                        };\n                        // TODO: adapt for putting the RDC inside the postponed data\n                        // If we're in dev, and this isn't a prefetch or a server action,\n                        // we should seed the resume data cache.\n                        if (this.nextConfig.experimental.dynamicIO && this.renderOpts.dev && !isPrefetchRSCRequest && !isPossibleServerAction) {\n                            const warmup = await module.warmup(req, res, context);\n                            // If the warmup is successful, we should use the resume data\n                            // cache from the warmup.\n                            if (warmup.metadata.devRenderResumeDataCache) {\n                                renderOpts.devRenderResumeDataCache = warmup.metadata.devRenderResumeDataCache;\n                            }\n                        }\n                        // Call the built-in render method on the module.\n                        result = await module.render(req, res, context);\n                    }\n                } else {\n                    throw Object.defineProperty(new Error('Invariant: Unknown route module type'), \"__NEXT_ERROR_CODE\", {\n                        value: \"E450\",\n                        enumerable: false,\n                        configurable: true\n                    });\n                }\n            } else {\n                // If we didn't match a page, we should fallback to using the legacy\n                // render method.\n                result = await this.renderHTML(req, res, pathname, query, renderOpts);\n            }\n            const { metadata } = result;\n            const { cacheControl, headers = {}, // Add any fetch tags that were on the page to the response headers.\n            fetchTags: cacheTags } = metadata;\n            if (cacheTags) {\n                headers[NEXT_CACHE_TAGS_HEADER] = cacheTags;\n            }\n            // Pull any fetch metrics from the render onto the request.\n            ;\n            req.fetchMetrics = metadata.fetchMetrics;\n            // we don't throw static to dynamic errors in dev as isSSG\n            // is a best guess in dev since we don't have the prerender pass\n            // to know whether the path is actually static or not\n            if (isAppPath && isSSG && (cacheControl == null ? void 0 : cacheControl.revalidate) === 0 && !this.renderOpts.dev && !isRoutePPREnabled) {\n                const staticBailoutInfo = metadata.staticBailoutInfo;\n                const err = Object.defineProperty(new Error(`Page changed from static to dynamic at runtime ${urlPathname}${(staticBailoutInfo == null ? void 0 : staticBailoutInfo.description) ? `, reason: ${staticBailoutInfo.description}` : ``}` + `\\nsee more here https://nextjs.org/docs/messages/app-static-to-dynamic-error`), \"__NEXT_ERROR_CODE\", {\n                    value: \"E132\",\n                    enumerable: false,\n                    configurable: true\n                });\n                if (staticBailoutInfo == null ? void 0 : staticBailoutInfo.stack) {\n                    const stack = staticBailoutInfo.stack;\n                    err.stack = err.message + stack.substring(stack.indexOf('\\n'));\n                }\n                throw err;\n            }\n            // Based on the metadata, we can determine what kind of cache result we\n            // should return.\n            // Handle `isNotFound`.\n            if ('isNotFound' in metadata && metadata.isNotFound) {\n                return {\n                    value: null,\n                    cacheControl,\n                    isFallback: false\n                };\n            }\n            // Handle `isRedirect`.\n            if (metadata.isRedirect) {\n                return {\n                    value: {\n                        kind: CachedRouteKind.REDIRECT,\n                        props: metadata.pageData ?? metadata.flightData\n                    },\n                    cacheControl,\n                    isFallback: false\n                };\n            }\n            // Handle `isNull`.\n            if (result.isNull) {\n                return null;\n            }\n            // We now have a valid HTML result that we can return to the user.\n            if (isAppPath) {\n                return {\n                    value: {\n                        kind: CachedRouteKind.APP_PAGE,\n                        html: result,\n                        headers,\n                        rscData: metadata.flightData,\n                        postponed: metadata.postponed,\n                        status: res.statusCode,\n                        segmentData: metadata.segmentData\n                    },\n                    cacheControl,\n                    isFallback: !!fallbackRouteParams\n                };\n            }\n            return {\n                value: {\n                    kind: CachedRouteKind.PAGES,\n                    html: result,\n                    pageData: metadata.pageData ?? metadata.flightData,\n                    headers,\n                    status: isAppPath ? res.statusCode : undefined\n                },\n                cacheControl,\n                isFallback: pagesFallback\n            };\n        };\n        let responseGenerator = async ({ hasResolved, previousCacheEntry, isRevalidating })=>{\n            const isProduction = !this.renderOpts.dev;\n            const didRespond = hasResolved || res.sent;\n            // If we haven't found the static paths for the route, then do it now.\n            if (!staticPaths && isDynamic) {\n                if (hasGetStaticPaths) {\n                    const pathsResult = await this.getStaticPaths({\n                        pathname,\n                        requestHeaders: req.headers,\n                        isAppPath,\n                        page: components.page\n                    });\n                    staticPaths = pathsResult.staticPaths;\n                    fallbackMode = pathsResult.fallbackMode;\n                } else {\n                    staticPaths = undefined;\n                    fallbackMode = FallbackMode.NOT_FOUND;\n                }\n            }\n            // When serving a bot request, we want to serve a blocking render and not\n            // the prerendered page. This ensures that the correct content is served\n            // to the bot in the head.\n            if (fallbackMode === FallbackMode.PRERENDER && isBot(req.headers['user-agent'] || '')) {\n                fallbackMode = FallbackMode.BLOCKING_STATIC_RENDER;\n            }\n            // skip on-demand revalidate if cache is not present and\n            // revalidate-if-generated is set\n            if (isOnDemandRevalidate && revalidateOnlyGenerated && !previousCacheEntry && !this.minimalMode) {\n                await this.render404(req, res);\n                return null;\n            }\n            if ((previousCacheEntry == null ? void 0 : previousCacheEntry.isStale) === -1) {\n                isOnDemandRevalidate = true;\n            }\n            // TODO: adapt for PPR\n            // only allow on-demand revalidate for fallback: true/blocking\n            // or for prerendered fallback: false paths\n            if (isOnDemandRevalidate && (fallbackMode !== FallbackMode.NOT_FOUND || previousCacheEntry)) {\n                fallbackMode = FallbackMode.BLOCKING_STATIC_RENDER;\n            }\n            // We use `ssgCacheKey` here as it is normalized to match the encoding\n            // from getStaticPaths along with including the locale.\n            //\n            // We use the `resolvedUrlPathname` for the development case when this\n            // is an app path since it doesn't include locale information.\n            //\n            // We decode the `resolvedUrlPathname` to correctly match the app path\n            // with prerendered paths.\n            let staticPathKey = ssgCacheKey;\n            if (!staticPathKey && opts.dev && isAppPath) {\n                staticPathKey = decodePathParams(resolvedUrlPathname);\n            }\n            if (staticPathKey && query.amp) {\n                staticPathKey = staticPathKey.replace(/\\.amp$/, '');\n            }\n            const isPageIncludedInStaticPaths = staticPathKey && (staticPaths == null ? void 0 : staticPaths.includes(staticPathKey));\n            // When experimental compile is used, no pages have been prerendered,\n            // so they should all be blocking.\n            // @ts-expect-error internal field\n            if (this.nextConfig.experimental.isExperimentalCompile) {\n                fallbackMode = FallbackMode.BLOCKING_STATIC_RENDER;\n            }\n            // When we did not respond from cache, we need to choose to block on\n            // rendering or return a skeleton.\n            //\n            // - Data requests always block.\n            // - Blocking mode fallback always blocks.\n            // - Preview mode toggles all pages to be resolved in a blocking manner.\n            // - Non-dynamic pages should block (though this is an impossible\n            //   case in production).\n            // - Dynamic pages should return their skeleton if not defined in\n            //   getStaticPaths, then finish the data request on the client-side.\n            //\n            if (process.env.NEXT_RUNTIME !== 'edge' && !this.minimalMode && fallbackMode !== FallbackMode.BLOCKING_STATIC_RENDER && staticPathKey && !didRespond && !isPreviewMode && isDynamic && (isProduction || !staticPaths || !isPageIncludedInStaticPaths)) {\n                if (// In development, fall through to render to handle missing\n                // getStaticPaths.\n                (isProduction || staticPaths && (staticPaths == null ? void 0 : staticPaths.length) > 0) && // When fallback isn't present, abort this render so we 404\n                fallbackMode === FallbackMode.NOT_FOUND) {\n                    throw new NoFallbackError();\n                }\n                let fallbackResponse;\n                // If this is a pages router page.\n                if (isPagesRouteModule(components.routeModule) && !isNextDataRequest) {\n                    // We use the response cache here to handle the revalidation and\n                    // management of the fallback shell.\n                    fallbackResponse = await this.responseCache.get(isProduction ? locale ? `/${locale}${pathname}` : pathname : null, // This is the response generator for the fallback shell.\n                    async ({ previousCacheEntry: previousFallbackCacheEntry = null })=>{\n                        // For the pages router, fallbacks cannot be revalidated or\n                        // generated in production. In the case of a missing fallback,\n                        // we return null, but if it's being revalidated, we just return\n                        // the previous fallback cache entry. This preserves the previous\n                        // behavior.\n                        if (isProduction) {\n                            return toResponseCacheEntry(previousFallbackCacheEntry);\n                        }\n                        // We pass `undefined` and `null` as it doesn't apply to the pages\n                        // router.\n                        return doRender({\n                            postponed: undefined,\n                            // For the pages router, fallbacks can only be generated on\n                            // demand in development, so if we're not in production, and we\n                            // aren't a app path.\n                            pagesFallback: true,\n                            fallbackRouteParams: null\n                        });\n                    }, {\n                        routeKind: RouteKind.PAGES,\n                        incrementalCache,\n                        isRoutePPREnabled,\n                        isFallback: true\n                    });\n                } else if (isRoutePPREnabled && isAppPageRouteModule(components.routeModule) && !isRSCRequest) {\n                    // We use the response cache here to handle the revalidation and\n                    // management of the fallback shell.\n                    fallbackResponse = await this.responseCache.get(isProduction ? pathname : null, // This is the response generator for the fallback shell.\n                    async ()=>doRender({\n                            // We pass `undefined` as rendering a fallback isn't resumed\n                            // here.\n                            postponed: undefined,\n                            pagesFallback: undefined,\n                            fallbackRouteParams: // If we're in production of we're debugging the fallback\n                            // shell then we should postpone when dynamic params are\n                            // accessed.\n                            isProduction || isDebugFallbackShell ? getFallbackRouteParams(pathname) : null\n                        }), {\n                        routeKind: RouteKind.APP_PAGE,\n                        incrementalCache,\n                        isRoutePPREnabled,\n                        isFallback: true\n                    });\n                }\n                // If the fallback response was set to null, then we should return null.\n                if (fallbackResponse === null) return null;\n                // Otherwise, if we did get a fallback response, we should return it.\n                if (fallbackResponse) {\n                    // Remove the cache control from the response to prevent it from being\n                    // used in the surrounding cache.\n                    delete fallbackResponse.cacheControl;\n                    return fallbackResponse;\n                }\n            }\n            // Only requests that aren't revalidating can be resumed. If we have the\n            // minimal postponed data, then we should resume the render with it.\n            const postponed = !isOnDemandRevalidate && !isRevalidating && minimalPostponed ? minimalPostponed : undefined;\n            // When we're in minimal mode, if we're trying to debug the static shell,\n            // we should just return nothing instead of resuming the dynamic render.\n            if ((isDebugStaticShell || isDebugDynamicAccesses) && typeof postponed !== 'undefined') {\n                return {\n                    cacheControl: {\n                        revalidate: 1,\n                        expire: undefined\n                    },\n                    isFallback: false,\n                    value: {\n                        kind: CachedRouteKind.PAGES,\n                        html: RenderResult.fromStatic(''),\n                        pageData: {},\n                        headers: undefined,\n                        status: undefined\n                    }\n                };\n            }\n            // If this is a dynamic route with PPR enabled and the default route\n            // matches were set, then we should pass the fallback route params to\n            // the renderer as this is a fallback revalidation request.\n            const fallbackRouteParams = isDynamic && isRoutePPREnabled && (getRequestMeta(req, 'didSetDefaultRouteMatches') || isDebugFallbackShell) ? getFallbackRouteParams(pathname) : null;\n            // Perform the render.\n            return doRender({\n                postponed,\n                pagesFallback: undefined,\n                fallbackRouteParams\n            });\n        };\n        const cacheEntry = await this.responseCache.get(ssgCacheKey, responseGenerator, {\n            routeKind: // If the route module is not defined, we can assume it's a page being\n            // rendered and thus check isAppPath.\n            (routeModule == null ? void 0 : routeModule.definition.kind) ?? (isAppPath ? RouteKind.APP_PAGE : RouteKind.PAGES),\n            incrementalCache,\n            isOnDemandRevalidate,\n            isPrefetch: req.headers.purpose === 'prefetch',\n            isRoutePPREnabled\n        });\n        if (isPreviewMode) {\n            res.setHeader('Cache-Control', 'private, no-cache, no-store, max-age=0, must-revalidate');\n        }\n        if (!cacheEntry) {\n            if (ssgCacheKey && !(isOnDemandRevalidate && revalidateOnlyGenerated)) {\n                // A cache entry might not be generated if a response is written\n                // in `getInitialProps` or `getServerSideProps`, but those shouldn't\n                // have a cache key. If we do have a cache key but we don't end up\n                // with a cache entry, then either Next.js or the application has a\n                // bug that needs fixing.\n                throw Object.defineProperty(new Error('invariant: cache entry required but not generated'), \"__NEXT_ERROR_CODE\", {\n                    value: \"E62\",\n                    enumerable: false,\n                    configurable: true\n                });\n            }\n            return null;\n        }\n        // If we're not in minimal mode and the cache entry that was returned was a\n        // app page fallback, then we need to kick off the dynamic shell generation.\n        if (ssgCacheKey && !this.minimalMode && isRoutePPREnabled && ((_cacheEntry_value = cacheEntry.value) == null ? void 0 : _cacheEntry_value.kind) === CachedRouteKind.APP_PAGE && cacheEntry.isFallback && !isOnDemandRevalidate && // When we're debugging the fallback shell, we don't want to regenerate\n        // the route shell.\n        !isDebugFallbackShell && process.env.DISABLE_ROUTE_SHELL_GENERATION !== 'true') {\n            scheduleOnNextTick(async ()=>{\n                try {\n                    await this.responseCache.get(ssgCacheKey, ()=>doRender({\n                            // We're an on-demand request, so we don't need to pass in the\n                            // fallbackRouteParams.\n                            fallbackRouteParams: null,\n                            pagesFallback: undefined,\n                            postponed: undefined\n                        }), {\n                        routeKind: RouteKind.APP_PAGE,\n                        incrementalCache,\n                        isOnDemandRevalidate: true,\n                        isPrefetch: false,\n                        isRoutePPREnabled: true\n                    });\n                } catch (err) {\n                    console.error('Error occurred while rendering dynamic shell', err);\n                }\n            });\n        }\n        const didPostpone = ((_cacheEntry_value1 = cacheEntry.value) == null ? void 0 : _cacheEntry_value1.kind) === CachedRouteKind.APP_PAGE && typeof cacheEntry.value.postponed === 'string';\n        if (isSSG && // We don't want to send a cache header for requests that contain dynamic\n        // data. If this is a Dynamic RSC request or wasn't a Prefetch RSC\n        // request, then we should set the cache header.\n        !isDynamicRSCRequest && (!didPostpone || isPrefetchRSCRequest)) {\n            if (!this.minimalMode) {\n                // set x-nextjs-cache header to match the header\n                // we set for the image-optimizer\n                res.setHeader('x-nextjs-cache', isOnDemandRevalidate ? 'REVALIDATED' : cacheEntry.isMiss ? 'MISS' : cacheEntry.isStale ? 'STALE' : 'HIT');\n            }\n            // Set a header used by the client router to signal the response is static\n            // and should respect the `static` cache staleTime value.\n            res.setHeader(NEXT_IS_PRERENDER_HEADER, '1');\n        }\n        const { value: cachedData } = cacheEntry;\n        // If the cache value is an image, we should error early.\n        if ((cachedData == null ? void 0 : cachedData.kind) === CachedRouteKind.IMAGE) {\n            throw Object.defineProperty(new InvariantError('SSG should not return an image cache value'), \"__NEXT_ERROR_CODE\", {\n                value: \"E659\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n        // Coerce the cache control parameter from the render.\n        let cacheControl;\n        // If this is a resume request in minimal mode it is streamed with dynamic\n        // content and should not be cached.\n        if (minimalPostponed) {\n            cacheControl = {\n                revalidate: 0,\n                expire: undefined\n            };\n        } else if (this.minimalMode && isRSCRequest && !isPrefetchRSCRequest && isRoutePPREnabled) {\n            cacheControl = {\n                revalidate: 0,\n                expire: undefined\n            };\n        } else if (!this.renderOpts.dev || hasServerProps && !isNextDataRequest) {\n            // If this is a preview mode request, we shouldn't cache it\n            if (isPreviewMode) {\n                cacheControl = {\n                    revalidate: 0,\n                    expire: undefined\n                };\n            } else if (!isSSG) {\n                if (!res.getHeader('Cache-Control')) {\n                    cacheControl = {\n                        revalidate: 0,\n                        expire: undefined\n                    };\n                }\n            } else if (is404Page) {\n                const notFoundRevalidate = getRequestMeta(req, 'notFoundRevalidate');\n                cacheControl = {\n                    revalidate: typeof notFoundRevalidate === 'undefined' ? 0 : notFoundRevalidate,\n                    expire: undefined\n                };\n            } else if (is500Page) {\n                cacheControl = {\n                    revalidate: 0,\n                    expire: undefined\n                };\n            } else if (cacheEntry.cacheControl) {\n                // If the cache entry has a cache control with a revalidate value that's\n                // a number, use it.\n                if (typeof cacheEntry.cacheControl.revalidate === 'number') {\n                    var _cacheEntry_cacheControl;\n                    if (cacheEntry.cacheControl.revalidate < 1) {\n                        throw Object.defineProperty(new Error(`Invalid revalidate configuration provided: ${cacheEntry.cacheControl.revalidate} < 1`), \"__NEXT_ERROR_CODE\", {\n                            value: \"E22\",\n                            enumerable: false,\n                            configurable: true\n                        });\n                    }\n                    cacheControl = {\n                        revalidate: cacheEntry.cacheControl.revalidate,\n                        expire: ((_cacheEntry_cacheControl = cacheEntry.cacheControl) == null ? void 0 : _cacheEntry_cacheControl.expire) ?? this.nextConfig.expireTime\n                    };\n                } else {\n                    cacheControl = {\n                        revalidate: CACHE_ONE_YEAR,\n                        expire: undefined\n                    };\n                }\n            }\n        }\n        cacheEntry.cacheControl = cacheControl;\n        if (typeof segmentPrefetchHeader === 'string' && (cachedData == null ? void 0 : cachedData.kind) === CachedRouteKind.APP_PAGE && cachedData.segmentData) {\n            var _cachedData_headers;\n            // This is a prefetch request issued by the client Segment Cache. These\n            // should never reach the application layer (lambda). We should either\n            // respond from the cache (HIT) or respond with 204 No Content (MISS).\n            // Set a header to indicate that PPR is enabled for this route. This\n            // lets the client distinguish between a regular cache miss and a cache\n            // miss due to PPR being disabled. In other contexts this header is used\n            // to indicate that the response contains dynamic data, but here we're\n            // only using it to indicate that the feature is enabled — the segment\n            // response itself contains whether the data is dynamic.\n            res.setHeader(NEXT_DID_POSTPONE_HEADER, '2');\n            // Add the cache tags header to the response if it exists and we're in\n            // minimal mode while rendering a static page.\n            const tags = (_cachedData_headers = cachedData.headers) == null ? void 0 : _cachedData_headers[NEXT_CACHE_TAGS_HEADER];\n            if (this.minimalMode && isSSG && tags && typeof tags === 'string') {\n                res.setHeader(NEXT_CACHE_TAGS_HEADER, tags);\n            }\n            const matchedSegment = cachedData.segmentData.get(segmentPrefetchHeader);\n            if (matchedSegment !== undefined) {\n                // Cache hit\n                return {\n                    type: 'rsc',\n                    body: RenderResult.fromStatic(matchedSegment),\n                    // TODO: Eventually this should use cache control of the individual\n                    // segment, not the whole page.\n                    cacheControl: cacheEntry.cacheControl\n                };\n            }\n            // Cache miss. Either a cache entry for this route has not been generated\n            // (which technically should not be possible when PPR is enabled, because\n            // at a minimum there should always be a fallback entry) or there's no\n            // match for the requested segment. Respond with a 204 No Content. We\n            // don't bother to respond with 404, because these requests are only\n            // issued as part of a prefetch.\n            res.statusCode = 204;\n            return {\n                type: 'rsc',\n                body: RenderResult.fromStatic(''),\n                cacheControl: cacheEntry == null ? void 0 : cacheEntry.cacheControl\n            };\n        }\n        // If there's a callback for `onCacheEntry`, call it with the cache entry\n        // and the revalidate options.\n        const onCacheEntry = getRequestMeta(req, 'onCacheEntry');\n        if (onCacheEntry) {\n            var _cacheEntry_value2, _cacheEntry_value3;\n            const finished = await onCacheEntry({\n                ...cacheEntry,\n                // TODO: remove this when upstream doesn't\n                // always expect this value to be \"PAGE\"\n                value: {\n                    ...cacheEntry.value,\n                    kind: ((_cacheEntry_value2 = cacheEntry.value) == null ? void 0 : _cacheEntry_value2.kind) === CachedRouteKind.APP_PAGE ? 'PAGE' : (_cacheEntry_value3 = cacheEntry.value) == null ? void 0 : _cacheEntry_value3.kind\n                }\n            }, {\n                url: getRequestMeta(req, 'initURL')\n            });\n            if (finished) {\n                // TODO: maybe we have to end the request?\n                return null;\n            }\n        }\n        if (!cachedData) {\n            var _cacheEntry_cacheControl1;\n            // add revalidate metadata before rendering 404 page\n            // so that we can use this as source of truth for the\n            // cache-control header instead of what the 404 page returns\n            // for the revalidate value\n            addRequestMeta(req, 'notFoundRevalidate', (_cacheEntry_cacheControl1 = cacheEntry.cacheControl) == null ? void 0 : _cacheEntry_cacheControl1.revalidate);\n            // If cache control is already set on the response we don't\n            // override it to allow users to customize it via next.config\n            if (cacheEntry.cacheControl && !res.getHeader('Cache-Control')) {\n                res.setHeader('Cache-Control', getCacheControlHeader(cacheEntry.cacheControl));\n            }\n            if (isNextDataRequest) {\n                res.statusCode = 404;\n                res.body('{\"notFound\":true}').send();\n                return null;\n            }\n            if (this.renderOpts.dev) {\n                addRequestMeta(req, 'developmentNotFoundSourcePage', pathname);\n            }\n            await this.render404(req, res, {\n                pathname,\n                query\n            }, false);\n            return null;\n        } else if (cachedData.kind === CachedRouteKind.REDIRECT) {\n            // If cache control is already set on the response we don't\n            // override it to allow users to customize it via next.config\n            if (cacheEntry.cacheControl && !res.getHeader('Cache-Control')) {\n                res.setHeader('Cache-Control', getCacheControlHeader(cacheEntry.cacheControl));\n            }\n            if (isNextDataRequest) {\n                return {\n                    type: 'json',\n                    body: RenderResult.fromStatic(// @TODO: Handle flight data.\n                    JSON.stringify(cachedData.props)),\n                    cacheControl: cacheEntry.cacheControl\n                };\n            } else {\n                await handleRedirect(cachedData.props);\n                return null;\n            }\n        } else if (cachedData.kind === CachedRouteKind.APP_ROUTE) {\n            const headers = fromNodeOutgoingHttpHeaders(cachedData.headers);\n            if (!(this.minimalMode && isSSG)) {\n                headers.delete(NEXT_CACHE_TAGS_HEADER);\n            }\n            // If cache control is already set on the response we don't\n            // override it to allow users to customize it via next.config\n            if (cacheEntry.cacheControl && !res.getHeader('Cache-Control') && !headers.get('Cache-Control')) {\n                headers.set('Cache-Control', getCacheControlHeader(cacheEntry.cacheControl));\n            }\n            await sendResponse(req, res, new Response(cachedData.body, {\n                headers,\n                status: cachedData.status || 200\n            }));\n            return null;\n        } else if (cachedData.kind === CachedRouteKind.APP_PAGE) {\n            var _cachedData_headers1;\n            // If the request has a postponed state and it's a resume request we\n            // should error.\n            if (didPostpone && minimalPostponed) {\n                throw Object.defineProperty(new Error('Invariant: postponed state should not be present on a resume request'), \"__NEXT_ERROR_CODE\", {\n                    value: \"E396\",\n                    enumerable: false,\n                    configurable: true\n                });\n            }\n            if (cachedData.headers) {\n                const headers = {\n                    ...cachedData.headers\n                };\n                if (!this.minimalMode || !isSSG) {\n                    delete headers[NEXT_CACHE_TAGS_HEADER];\n                }\n                for (let [key, value] of Object.entries(headers)){\n                    if (typeof value === 'undefined') continue;\n                    if (Array.isArray(value)) {\n                        for (const v of value){\n                            res.appendHeader(key, v);\n                        }\n                    } else if (typeof value === 'number') {\n                        value = value.toString();\n                        res.appendHeader(key, value);\n                    } else {\n                        res.appendHeader(key, value);\n                    }\n                }\n            }\n            // Add the cache tags header to the response if it exists and we're in\n            // minimal mode while rendering a static page.\n            const tags = (_cachedData_headers1 = cachedData.headers) == null ? void 0 : _cachedData_headers1[NEXT_CACHE_TAGS_HEADER];\n            if (this.minimalMode && isSSG && tags && typeof tags === 'string') {\n                res.setHeader(NEXT_CACHE_TAGS_HEADER, tags);\n            }\n            // If the request is a data request, then we shouldn't set the status code\n            // from the response because it should always be 200. This should be gated\n            // behind the experimental PPR flag.\n            if (cachedData.status && (!isRSCRequest || !isRoutePPREnabled)) {\n                res.statusCode = cachedData.status;\n            }\n            // Mark that the request did postpone.\n            if (didPostpone) {\n                res.setHeader(NEXT_DID_POSTPONE_HEADER, '1');\n            }\n            // we don't go through this block when preview mode is true\n            // as preview mode is a dynamic request (bypasses cache) and doesn't\n            // generate both HTML and payloads in the same request so continue to just\n            // return the generated payload\n            if (isRSCRequest && !isPreviewMode) {\n                // If this is a dynamic RSC request, then stream the response.\n                if (typeof cachedData.rscData === 'undefined') {\n                    if (cachedData.postponed) {\n                        throw Object.defineProperty(new Error('Invariant: Expected postponed to be undefined'), \"__NEXT_ERROR_CODE\", {\n                            value: \"E372\",\n                            enumerable: false,\n                            configurable: true\n                        });\n                    }\n                    return {\n                        type: 'rsc',\n                        body: cachedData.html,\n                        // Dynamic RSC responses cannot be cached, even if they're\n                        // configured with `force-static` because we have no way of\n                        // distinguishing between `force-static` and pages that have no\n                        // postponed state.\n                        // TODO: distinguish `force-static` from pages with no postponed state (static)\n                        cacheControl: isDynamicRSCRequest ? {\n                            revalidate: 0,\n                            expire: undefined\n                        } : cacheEntry.cacheControl\n                    };\n                }\n                // As this isn't a prefetch request, we should serve the static flight\n                // data.\n                return {\n                    type: 'rsc',\n                    body: RenderResult.fromStatic(cachedData.rscData),\n                    cacheControl: cacheEntry.cacheControl\n                };\n            }\n            // This is a request for HTML data.\n            let body = cachedData.html;\n            // If there's no postponed state, we should just serve the HTML. This\n            // should also be the case for a resume request because it's completed\n            // as a server render (rather than a static render).\n            if (!didPostpone || this.minimalMode) {\n                return {\n                    type: 'html',\n                    body,\n                    cacheControl: cacheEntry.cacheControl\n                };\n            }\n            // If we're debugging the static shell or the dynamic API accesses, we\n            // should just serve the HTML without resuming the render. The returned\n            // HTML will be the static shell so all the Dynamic API's will be used\n            // during static generation.\n            if (isDebugStaticShell || isDebugDynamicAccesses) {\n                // Since we're not resuming the render, we need to at least add the\n                // closing body and html tags to create valid HTML.\n                body.chain(new ReadableStream({\n                    start (controller) {\n                        controller.enqueue(ENCODED_TAGS.CLOSED.BODY_AND_HTML);\n                        controller.close();\n                    }\n                }));\n                return {\n                    type: 'html',\n                    body,\n                    cacheControl: {\n                        revalidate: 0,\n                        expire: undefined\n                    }\n                };\n            }\n            // This request has postponed, so let's create a new transformer that the\n            // dynamic data can pipe to that will attach the dynamic data to the end\n            // of the response.\n            const transformer = new TransformStream();\n            body.chain(transformer.readable);\n            // Perform the render again, but this time, provide the postponed state.\n            // We don't await because we want the result to start streaming now, and\n            // we've already chained the transformer's readable to the render result.\n            doRender({\n                postponed: cachedData.postponed,\n                pagesFallback: undefined,\n                // This is a resume render, not a fallback render, so we don't need to\n                // set this.\n                fallbackRouteParams: null\n            }).then(async (result)=>{\n                var _result_value;\n                if (!result) {\n                    throw Object.defineProperty(new Error('Invariant: expected a result to be returned'), \"__NEXT_ERROR_CODE\", {\n                        value: \"E463\",\n                        enumerable: false,\n                        configurable: true\n                    });\n                }\n                if (((_result_value = result.value) == null ? void 0 : _result_value.kind) !== CachedRouteKind.APP_PAGE) {\n                    var _result_value1;\n                    throw Object.defineProperty(new Error(`Invariant: expected a page response, got ${(_result_value1 = result.value) == null ? void 0 : _result_value1.kind}`), \"__NEXT_ERROR_CODE\", {\n                        value: \"E305\",\n                        enumerable: false,\n                        configurable: true\n                    });\n                }\n                // Pipe the resume result to the transformer.\n                await result.value.html.pipeTo(transformer.writable);\n            }).catch((err)=>{\n                // An error occurred during piping or preparing the render, abort\n                // the transformers writer so we can terminate the stream.\n                transformer.writable.abort(err).catch((e)=>{\n                    console.error(\"couldn't abort transformer\", e);\n                });\n            });\n            return {\n                type: 'html',\n                body,\n                // We don't want to cache the response if it has postponed data because\n                // the response being sent to the client it's dynamic parts are streamed\n                // to the client on the same request.\n                cacheControl: {\n                    revalidate: 0,\n                    expire: undefined\n                }\n            };\n        } else if (isNextDataRequest) {\n            return {\n                type: 'json',\n                body: RenderResult.fromStatic(JSON.stringify(cachedData.pageData)),\n                cacheControl: cacheEntry.cacheControl\n            };\n        } else {\n            return {\n                type: 'html',\n                body: cachedData.html,\n                cacheControl: cacheEntry.cacheControl\n            };\n        }\n    }\n    stripNextDataPath(path, stripLocale = true) {\n        if (path.includes(this.buildId)) {\n            const splitPath = path.substring(path.indexOf(this.buildId) + this.buildId.length);\n            path = denormalizePagePath(splitPath.replace(/\\.json$/, ''));\n        }\n        if (this.localeNormalizer && stripLocale) {\n            return this.localeNormalizer.normalize(path);\n        }\n        return path;\n    }\n    // map the route to the actual bundle name\n    getOriginalAppPaths(route) {\n        if (this.enabledDirectories.app) {\n            var _this_appPathRoutes;\n            const originalAppPath = (_this_appPathRoutes = this.appPathRoutes) == null ? void 0 : _this_appPathRoutes[route];\n            if (!originalAppPath) {\n                return null;\n            }\n            return originalAppPath;\n        }\n        return null;\n    }\n    async renderPageComponent(ctx, bubbleNoFallback) {\n        var _this_nextConfig_experimental_sri;\n        const { query, pathname } = ctx;\n        const appPaths = this.getOriginalAppPaths(pathname);\n        const isAppPath = Array.isArray(appPaths);\n        let page = pathname;\n        if (isAppPath) {\n            // the last item in the array is the root page, if there are parallel routes\n            page = appPaths[appPaths.length - 1];\n        }\n        const result = await this.findPageComponents({\n            locale: getRequestMeta(ctx.req, 'locale'),\n            page,\n            query,\n            params: ctx.renderOpts.params || {},\n            isAppPath,\n            sriEnabled: !!((_this_nextConfig_experimental_sri = this.nextConfig.experimental.sri) == null ? void 0 : _this_nextConfig_experimental_sri.algorithm),\n            appPaths,\n            // Ensuring for loading page component routes is done via the matcher.\n            shouldEnsure: false\n        });\n        if (result) {\n            getTracer().setRootSpanAttribute('next.route', pathname);\n            try {\n                return await this.renderToResponseWithComponents(ctx, result);\n            } catch (err) {\n                const isNoFallbackError = err instanceof NoFallbackError;\n                if (!isNoFallbackError || isNoFallbackError && bubbleNoFallback) {\n                    throw err;\n                }\n            }\n        }\n        return false;\n    }\n    async renderToResponse(ctx) {\n        return getTracer().trace(BaseServerSpan.renderToResponse, {\n            spanName: `rendering page`,\n            attributes: {\n                'next.route': ctx.pathname\n            }\n        }, async ()=>{\n            return this.renderToResponseImpl(ctx);\n        });\n    }\n    async renderToResponseImpl(ctx) {\n        var _this_i18nProvider;\n        const { req, res, query, pathname } = ctx;\n        let page = pathname;\n        const bubbleNoFallback = getRequestMeta(ctx.req, 'bubbleNoFallback') ?? false;\n        delete query[NEXT_RSC_UNION_QUERY];\n        const options = {\n            i18n: (_this_i18nProvider = this.i18nProvider) == null ? void 0 : _this_i18nProvider.fromRequest(req, pathname)\n        };\n        try {\n            for await (const match of this.matchers.matchAll(pathname, options)){\n                // when a specific invoke-output is meant to be matched\n                // ensure a prior dynamic route/page doesn't take priority\n                const invokeOutput = getRequestMeta(ctx.req, 'invokeOutput');\n                if (!this.minimalMode && typeof invokeOutput === 'string' && isDynamicRoute(invokeOutput || '') && invokeOutput !== match.definition.pathname) {\n                    continue;\n                }\n                const result = await this.renderPageComponent({\n                    ...ctx,\n                    pathname: match.definition.pathname,\n                    renderOpts: {\n                        ...ctx.renderOpts,\n                        params: match.params\n                    }\n                }, bubbleNoFallback);\n                if (result !== false) return result;\n            }\n            // currently edge functions aren't receiving the x-matched-path\n            // header so we need to fallback to matching the current page\n            // when we weren't able to match via dynamic route to handle\n            // the rewrite case\n            // @ts-expect-error extended in child class web-server\n            if (this.serverOptions.webServerConfig) {\n                // @ts-expect-error extended in child class web-server\n                ctx.pathname = this.serverOptions.webServerConfig.page;\n                const result = await this.renderPageComponent(ctx, bubbleNoFallback);\n                if (result !== false) return result;\n            }\n        } catch (error) {\n            const err = getProperError(error);\n            if (error instanceof MissingStaticPage) {\n                console.error('Invariant: failed to load static page', JSON.stringify({\n                    page,\n                    url: ctx.req.url,\n                    matchedPath: ctx.req.headers[MATCHED_PATH_HEADER],\n                    initUrl: getRequestMeta(ctx.req, 'initURL'),\n                    didRewrite: !!getRequestMeta(ctx.req, 'rewroteURL'),\n                    rewroteUrl: getRequestMeta(ctx.req, 'rewroteURL')\n                }, null, 2));\n                throw err;\n            }\n            if (err instanceof NoFallbackError && bubbleNoFallback) {\n                throw err;\n            }\n            if (err instanceof DecodeError || err instanceof NormalizeError) {\n                res.statusCode = 400;\n                return await this.renderErrorToResponse(ctx, err);\n            }\n            res.statusCode = 500;\n            // if pages/500 is present we still need to trigger\n            // /_error `getInitialProps` to allow reporting error\n            if (await this.hasPage('/500')) {\n                addRequestMeta(ctx.req, 'customErrorRender', true);\n                await this.renderErrorToResponse(ctx, err);\n                removeRequestMeta(ctx.req, 'customErrorRender');\n            }\n            const isWrappedError = err instanceof WrappedBuildError;\n            if (!isWrappedError) {\n                if (this.minimalMode && process.env.NEXT_RUNTIME !== 'edge' || this.renderOpts.dev) {\n                    if (isError(err)) err.page = page;\n                    throw err;\n                }\n                this.logError(getProperError(err));\n            }\n            const response = await this.renderErrorToResponse(ctx, isWrappedError ? err.innerError : err);\n            return response;\n        }\n        const middleware = await this.getMiddleware();\n        if (middleware && !!ctx.req.headers['x-nextjs-data'] && (!res.statusCode || res.statusCode === 200 || res.statusCode === 404)) {\n            const locale = getRequestMeta(req, 'locale');\n            res.setHeader('x-nextjs-matched-path', `${locale ? `/${locale}` : ''}${pathname}`);\n            res.statusCode = 200;\n            res.setHeader('content-type', 'application/json');\n            res.body('{}');\n            res.send();\n            return null;\n        }\n        res.statusCode = 404;\n        return this.renderErrorToResponse(ctx, null);\n    }\n    async renderToHTML(req, res, pathname, query = {}) {\n        return getTracer().trace(BaseServerSpan.renderToHTML, async ()=>{\n            return this.renderToHTMLImpl(req, res, pathname, query);\n        });\n    }\n    async renderToHTMLImpl(req, res, pathname, query = {}) {\n        return this.getStaticHTML((ctx)=>this.renderToResponse(ctx), {\n            req,\n            res,\n            pathname,\n            query\n        });\n    }\n    async renderError(err, req, res, pathname, query = {}, setHeaders = true) {\n        return getTracer().trace(BaseServerSpan.renderError, async ()=>{\n            return this.renderErrorImpl(err, req, res, pathname, query, setHeaders);\n        });\n    }\n    async renderErrorImpl(err, req, res, pathname, query = {}, setHeaders = true) {\n        if (setHeaders) {\n            res.setHeader('Cache-Control', 'private, no-cache, no-store, max-age=0, must-revalidate');\n        }\n        return this.pipe(async (ctx)=>{\n            const response = await this.renderErrorToResponse(ctx, err);\n            if (this.minimalMode && res.statusCode === 500) {\n                throw err;\n            }\n            return response;\n        }, {\n            req,\n            res,\n            pathname,\n            query\n        });\n    }\n    async renderErrorToResponse(ctx, err) {\n        return getTracer().trace(BaseServerSpan.renderErrorToResponse, async ()=>{\n            return this.renderErrorToResponseImpl(ctx, err);\n        });\n    }\n    async renderErrorToResponseImpl(ctx, err) {\n        // Short-circuit favicon.ico in development to avoid compiling 404 page when the app has no favicon.ico.\n        // Since favicon.ico is automatically requested by the browser.\n        if (this.renderOpts.dev && ctx.pathname === '/favicon.ico') {\n            return {\n                type: 'html',\n                body: RenderResult.fromStatic('')\n            };\n        }\n        const { res, query } = ctx;\n        try {\n            let result = null;\n            const is404 = res.statusCode === 404;\n            let using404Page = false;\n            if (is404) {\n                if (this.enabledDirectories.app) {\n                    // Use the not-found entry in app directory\n                    result = await this.findPageComponents({\n                        locale: getRequestMeta(ctx.req, 'locale'),\n                        page: UNDERSCORE_NOT_FOUND_ROUTE_ENTRY,\n                        query,\n                        params: {},\n                        isAppPath: true,\n                        shouldEnsure: true,\n                        url: ctx.req.url\n                    });\n                    using404Page = result !== null;\n                }\n                if (!result && await this.hasPage('/404')) {\n                    result = await this.findPageComponents({\n                        locale: getRequestMeta(ctx.req, 'locale'),\n                        page: '/404',\n                        query,\n                        params: {},\n                        isAppPath: false,\n                        // Ensuring can't be done here because you never \"match\" a 404 route.\n                        shouldEnsure: true,\n                        url: ctx.req.url\n                    });\n                    using404Page = result !== null;\n                }\n            }\n            let statusPage = `/${res.statusCode}`;\n            if (!getRequestMeta(ctx.req, 'customErrorRender') && !result && STATIC_STATUS_PAGES.includes(statusPage)) {\n                // skip ensuring /500 in dev mode as it isn't used and the\n                // dev overlay is used instead\n                if (statusPage !== '/500' || !this.renderOpts.dev) {\n                    result = await this.findPageComponents({\n                        locale: getRequestMeta(ctx.req, 'locale'),\n                        page: statusPage,\n                        query,\n                        params: {},\n                        isAppPath: false,\n                        // Ensuring can't be done here because you never \"match\" a 500\n                        // route.\n                        shouldEnsure: true,\n                        url: ctx.req.url\n                    });\n                }\n            }\n            if (!result) {\n                result = await this.findPageComponents({\n                    locale: getRequestMeta(ctx.req, 'locale'),\n                    page: '/_error',\n                    query,\n                    params: {},\n                    isAppPath: false,\n                    // Ensuring can't be done here because you never \"match\" an error\n                    // route.\n                    shouldEnsure: true,\n                    url: ctx.req.url\n                });\n                statusPage = '/_error';\n            }\n            if (process.env.NODE_ENV !== 'production' && !using404Page && await this.hasPage('/_error') && !await this.hasPage('/404')) {\n                this.customErrorNo404Warn();\n            }\n            if (!result) {\n                // this can occur when a project directory has been moved/deleted\n                // which is handled in the parent process in development\n                if (this.renderOpts.dev) {\n                    return {\n                        type: 'html',\n                        // wait for dev-server to restart before refreshing\n                        body: RenderResult.fromStatic(`\n              <pre>missing required error components, refreshing...</pre>\n              <script>\n                async function check() {\n                  const res = await fetch(location.href).catch(() => ({}))\n\n                  if (res.status === 200) {\n                    location.reload()\n                  } else {\n                    setTimeout(check, 1000)\n                  }\n                }\n                check()\n              </script>`)\n                    };\n                }\n                throw new WrappedBuildError(Object.defineProperty(new Error('missing required error components'), \"__NEXT_ERROR_CODE\", {\n                    value: \"E60\",\n                    enumerable: false,\n                    configurable: true\n                }));\n            }\n            // If the page has a route module, use it for the new match. If it doesn't\n            // have a route module, remove the match.\n            if (result.components.routeModule) {\n                addRequestMeta(ctx.req, 'match', {\n                    definition: result.components.routeModule.definition,\n                    params: undefined\n                });\n            } else {\n                removeRequestMeta(ctx.req, 'match');\n            }\n            try {\n                return await this.renderToResponseWithComponents({\n                    ...ctx,\n                    pathname: statusPage,\n                    renderOpts: {\n                        ...ctx.renderOpts,\n                        err\n                    }\n                }, result);\n            } catch (maybeFallbackError) {\n                if (maybeFallbackError instanceof NoFallbackError) {\n                    throw Object.defineProperty(new Error('invariant: failed to render error page'), \"__NEXT_ERROR_CODE\", {\n                        value: \"E55\",\n                        enumerable: false,\n                        configurable: true\n                    });\n                }\n                throw maybeFallbackError;\n            }\n        } catch (error) {\n            const renderToHtmlError = getProperError(error);\n            const isWrappedError = renderToHtmlError instanceof WrappedBuildError;\n            if (!isWrappedError) {\n                this.logError(renderToHtmlError);\n            }\n            res.statusCode = 500;\n            const fallbackComponents = await this.getFallbackErrorComponents(ctx.req.url);\n            if (fallbackComponents) {\n                // There was an error, so use it's definition from the route module\n                // to add the match to the request.\n                addRequestMeta(ctx.req, 'match', {\n                    definition: fallbackComponents.routeModule.definition,\n                    params: undefined\n                });\n                return this.renderToResponseWithComponents({\n                    ...ctx,\n                    pathname: '/_error',\n                    renderOpts: {\n                        ...ctx.renderOpts,\n                        // We render `renderToHtmlError` here because `err` is\n                        // already captured in the stacktrace.\n                        err: isWrappedError ? renderToHtmlError.innerError : renderToHtmlError\n                    }\n                }, {\n                    query,\n                    components: fallbackComponents\n                });\n            }\n            return {\n                type: 'html',\n                body: RenderResult.fromStatic('Internal Server Error')\n            };\n        }\n    }\n    async renderErrorToHTML(err, req, res, pathname, query = {}) {\n        return this.getStaticHTML((ctx)=>this.renderErrorToResponse(ctx, err), {\n            req,\n            res,\n            pathname,\n            query\n        });\n    }\n    async render404(req, res, parsedUrl, setHeaders = true) {\n        const { pathname, query } = parsedUrl ? parsedUrl : parseUrl(req.url, true);\n        // Ensure the locales are provided on the request meta.\n        if (this.nextConfig.i18n) {\n            if (!getRequestMeta(req, 'locale')) {\n                addRequestMeta(req, 'locale', this.nextConfig.i18n.defaultLocale);\n            }\n            addRequestMeta(req, 'defaultLocale', this.nextConfig.i18n.defaultLocale);\n        }\n        res.statusCode = 404;\n        return this.renderError(null, req, res, pathname, query, setHeaders);\n    }\n}\n\n//# sourceMappingURL=base-server.js.map"
        }
    ]
}