{
    "sourceFile": "node_modules/next/dist/esm/server/body-streams.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892826468,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import { PassThrough } from 'stream';\nexport function requestToBodyStream(context, KUint8Array, stream) {\n    return new context.ReadableStream({\n        start: async (controller)=>{\n            for await (const chunk of stream){\n                controller.enqueue(new KUint8Array(chunk));\n            }\n            controller.close();\n        }\n    });\n}\nfunction replaceRequestBody(base, stream) {\n    for(const key in stream){\n        let v = stream[key];\n        if (typeof v === 'function') {\n            v = v.bind(base);\n        }\n        base[key] = v;\n    }\n    return base;\n}\nexport function getCloneableBody(readable) {\n    let buffered = null;\n    const endPromise = new Promise((resolve, reject)=>{\n        readable.on('end', resolve);\n        readable.on('error', reject);\n    }).catch((error)=>{\n        return {\n            error\n        };\n    });\n    return {\n        /**\n     * Replaces the original request body if necessary.\n     * This is done because once we read the body from the original request,\n     * we can't read it again.\n     */ async finalize () {\n            if (buffered) {\n                const res = await endPromise;\n                if (res && typeof res === 'object' && res.error) {\n                    throw res.error;\n                }\n                replaceRequestBody(readable, buffered);\n                buffered = readable;\n            }\n        },\n        /**\n     * Clones the body stream\n     * to pass into a middleware\n     */ cloneBodyStream () {\n            const input = buffered ?? readable;\n            const p1 = new PassThrough();\n            const p2 = new PassThrough();\n            input.on('data', (chunk)=>{\n                p1.push(chunk);\n                p2.push(chunk);\n            });\n            input.on('end', ()=>{\n                p1.push(null);\n                p2.push(null);\n            });\n            buffered = p2;\n            return p1;\n        }\n    };\n}\n\n//# sourceMappingURL=body-streams.js.map"
        }
    ]
}