{
    "sourceFile": "node_modules/next/dist/esm/server/web-server.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892847669,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import { byteLength } from './api-utils/web';\nimport BaseServer, { NoFallbackError } from './base-server';\nimport { generateETag } from './lib/etag';\nimport { addRequestMeta, getRequestMeta } from './request-meta';\nimport WebResponseCache from './response-cache/web';\nimport { removeTrailingSlash } from '../shared/lib/router/utils/remove-trailing-slash';\nimport { isDynamicRoute } from '../shared/lib/router/utils';\nimport { interpolateDynamicPath, normalizeVercelUrl, normalizeDynamicRouteParams } from './server-utils';\nimport { getNamedRouteRegex } from '../shared/lib/router/utils/route-regex';\nimport { getRouteMatcher } from '../shared/lib/router/utils/route-matcher';\nimport { IncrementalCache } from './lib/incremental-cache';\nimport { buildCustomRoute } from '../lib/build-custom-route';\nimport { UNDERSCORE_NOT_FOUND_ROUTE } from '../api/constants';\nimport { getEdgeInstrumentationModule } from './web/globals';\nimport { getEdgePreviewProps } from './web/get-edge-preview-props';\nexport default class NextWebServer extends BaseServer {\n    constructor(options){\n        super(options), this.handleCatchallRenderRequest = async (req, res, parsedUrl)=>{\n            let { pathname, query } = parsedUrl;\n            if (!pathname) {\n                throw Object.defineProperty(new Error('pathname is undefined'), \"__NEXT_ERROR_CODE\", {\n                    value: \"E408\",\n                    enumerable: false,\n                    configurable: true\n                });\n            }\n            // interpolate query information into page for dynamic route\n            // so that rewritten paths are handled properly\n            const normalizedPage = this.serverOptions.webServerConfig.pathname;\n            if (pathname !== normalizedPage) {\n                pathname = normalizedPage;\n                if (isDynamicRoute(pathname)) {\n                    const routeRegex = getNamedRouteRegex(pathname, {\n                        prefixRouteKeys: false\n                    });\n                    const dynamicRouteMatcher = getRouteMatcher(routeRegex);\n                    const defaultRouteMatches = dynamicRouteMatcher(pathname);\n                    const paramsResult = normalizeDynamicRouteParams(query, routeRegex, defaultRouteMatches, false);\n                    const normalizedParams = paramsResult.hasValidParams ? paramsResult.params : query;\n                    pathname = interpolateDynamicPath(pathname, normalizedParams, routeRegex);\n                    normalizeVercelUrl(req, Object.keys(routeRegex.routeKeys), routeRegex);\n                }\n            }\n            // next.js core assumes page path without trailing slash\n            pathname = removeTrailingSlash(pathname);\n            if (this.i18nProvider) {\n                const { detectedLocale } = await this.i18nProvider.analyze(pathname);\n                if (detectedLocale) {\n                    addRequestMeta(req, 'locale', detectedLocale);\n                }\n            }\n            const bubbleNoFallback = getRequestMeta(req, 'bubbleNoFallback');\n            try {\n                await this.render(req, res, pathname, query, parsedUrl, true);\n                return true;\n            } catch (err) {\n                if (err instanceof NoFallbackError && bubbleNoFallback) {\n                    return false;\n                }\n                throw err;\n            }\n        };\n        // Extend `renderOpts`.\n        Object.assign(this.renderOpts, options.webServerConfig.extendRenderOpts);\n    }\n    async getIncrementalCache({ requestHeaders }) {\n        const dev = !!this.renderOpts.dev;\n        // incremental-cache is request specific\n        // although can have shared caches in module scope\n        // per-cache handler\n        return new IncrementalCache({\n            dev,\n            requestHeaders,\n            requestProtocol: 'https',\n            allowedRevalidateHeaderKeys: this.nextConfig.experimental.allowedRevalidateHeaderKeys,\n            minimalMode: this.minimalMode,\n            fetchCacheKeyPrefix: this.nextConfig.experimental.fetchCacheKeyPrefix,\n            maxMemoryCacheSize: this.nextConfig.cacheMaxMemorySize,\n            flushToDisk: false,\n            CurCacheHandler: this.serverOptions.webServerConfig.incrementalCacheHandler,\n            getPrerenderManifest: ()=>this.getPrerenderManifest()\n        });\n    }\n    getResponseCache() {\n        return new WebResponseCache(this.minimalMode);\n    }\n    async hasPage(page) {\n        return page === this.serverOptions.webServerConfig.page;\n    }\n    getBuildId() {\n        return this.serverOptions.buildId;\n    }\n    getEnabledDirectories() {\n        return {\n            app: this.serverOptions.webServerConfig.pagesType === 'app',\n            pages: this.serverOptions.webServerConfig.pagesType === 'pages'\n        };\n    }\n    getPagesManifest() {\n        return {\n            // keep same theme but server path doesn't need to be accurate\n            [this.serverOptions.webServerConfig.pathname]: `server${this.serverOptions.webServerConfig.page}.js`\n        };\n    }\n    getAppPathsManifest() {\n        const page = this.serverOptions.webServerConfig.page;\n        return {\n            [this.serverOptions.webServerConfig.page]: `app${page}.js`\n        };\n    }\n    attachRequestMeta(req, parsedUrl) {\n        addRequestMeta(req, 'initQuery', {\n            ...parsedUrl.query\n        });\n    }\n    getPrerenderManifest() {\n        return {\n            version: -1,\n            routes: {},\n            dynamicRoutes: {},\n            notFoundRoutes: [],\n            preview: getEdgePreviewProps()\n        };\n    }\n    getNextFontManifest() {\n        return this.serverOptions.webServerConfig.extendRenderOpts.nextFontManifest;\n    }\n    renderHTML(req, res, pathname, query, renderOpts) {\n        const { renderToHTML } = this.serverOptions.webServerConfig;\n        if (!renderToHTML) {\n            throw Object.defineProperty(new Error('Invariant: routeModule should be configured when rendering pages'), \"__NEXT_ERROR_CODE\", {\n                value: \"E4\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n        // For edge runtime if the pathname hit as /_not-found entrypoint,\n        // override the pathname to /404 for rendering\n        if (pathname === UNDERSCORE_NOT_FOUND_ROUTE) {\n            pathname = '/404';\n        }\n        return renderToHTML(req, res, pathname, query, // Edge runtime does not support ISR/PPR, so we don't need to pass in\n        // the unknown params.\n        null, Object.assign(renderOpts, {\n            disableOptimizedLoading: true,\n            runtime: 'experimental-edge'\n        }), undefined, false, {\n            buildId: this.serverOptions.buildId\n        });\n    }\n    async sendRenderResult(_req, res, options) {\n        res.setHeader('X-Edge-Runtime', '1');\n        // Add necessary headers.\n        // @TODO: Share the isomorphic logic with server/send-payload.ts.\n        if (options.poweredByHeader && options.type === 'html') {\n            res.setHeader('X-Powered-By', 'Next.js');\n        }\n        if (!res.getHeader('Content-Type')) {\n            res.setHeader('Content-Type', options.result.contentType ? options.result.contentType : options.type === 'json' ? 'application/json' : 'text/html; charset=utf-8');\n        }\n        let promise;\n        if (options.result.isDynamic) {\n            promise = options.result.pipeTo(res.transformStream.writable);\n        } else {\n            const payload = options.result.toUnchunkedString();\n            res.setHeader('Content-Length', String(byteLength(payload)));\n            if (options.generateEtags) {\n                res.setHeader('ETag', generateETag(payload));\n            }\n            res.body(payload);\n        }\n        res.send();\n        // If we have a promise, wait for it to resolve.\n        if (promise) await promise;\n    }\n    async findPageComponents({ page, query, params, url: _url }) {\n        const result = await this.serverOptions.webServerConfig.loadComponent(page);\n        if (!result) return null;\n        return {\n            query: {\n                ...query || {},\n                ...params || {}\n            },\n            components: result\n        };\n    }\n    // Below are methods that are not implemented by the web server as they are\n    // handled by the upstream proxy (edge runtime or node server).\n    async runApi() {\n        // This web server does not need to handle API requests.\n        return true;\n    }\n    async handleApiRequest() {\n        // Edge API requests are handled separately in minimal mode.\n        return false;\n    }\n    loadEnvConfig() {\n    // The web server does not need to load the env config. This is done by the\n    // runtime already.\n    }\n    getPublicDir() {\n        // Public files are not handled by the web server.\n        return '';\n    }\n    getHasStaticDir() {\n        return false;\n    }\n    getFontManifest() {\n        return undefined;\n    }\n    handleCompression() {\n    // For the web server layer, compression is automatically handled by the\n    // upstream proxy (edge runtime or node server) and we can simply skip here.\n    }\n    async handleUpgrade() {\n    // The web server does not support web sockets.\n    }\n    async getFallbackErrorComponents(_url) {\n        // The web server does not need to handle fallback errors in production.\n        return null;\n    }\n    getRoutesManifest() {\n        // The web server does not need to handle rewrite rules. This is done by the\n        // upstream proxy (edge runtime or node server).\n        return undefined;\n    }\n    getMiddleware() {\n        // The web server does not need to handle middleware. This is done by the\n        // upstream proxy (edge runtime or node server).\n        return Promise.resolve(undefined);\n    }\n    getFilesystemPaths() {\n        return new Set();\n    }\n    getinterceptionRoutePatterns() {\n        var _this_serverOptions_webServerConfig_interceptionRouteRewrites;\n        return ((_this_serverOptions_webServerConfig_interceptionRouteRewrites = this.serverOptions.webServerConfig.interceptionRouteRewrites) == null ? void 0 : _this_serverOptions_webServerConfig_interceptionRouteRewrites.map((rewrite)=>new RegExp(buildCustomRoute('rewrite', rewrite).regex))) ?? [];\n    }\n    async loadInstrumentationModule() {\n        return await getEdgeInstrumentationModule();\n    }\n    async instrumentationOnRequestError(...args) {\n        await super.instrumentationOnRequestError(...args);\n        const err = args[0];\n        if (process.env.NODE_ENV !== 'production' && typeof __next_log_error__ === 'function') {\n            __next_log_error__(err);\n        } else {\n            console.error(err);\n        }\n    }\n}\n\n//# sourceMappingURL=web-server.js.map"
        }
    ]
}