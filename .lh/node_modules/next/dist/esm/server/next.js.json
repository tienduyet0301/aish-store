{
    "sourceFile": "node_modules/next/dist/esm/server/next.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892834373,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import './require-hook';\nimport './node-polyfill-crypto';\nimport * as log from '../build/output/log';\nimport loadConfig from './config';\nimport path, { resolve } from 'path';\nimport { NON_STANDARD_NODE_ENV } from '../lib/constants';\nimport { PHASE_DEVELOPMENT_SERVER, SERVER_FILES_MANIFEST } from '../shared/lib/constants';\nimport { PHASE_PRODUCTION_SERVER } from '../shared/lib/constants';\nimport { getTracer } from './lib/trace/tracer';\nimport { NextServerSpan } from './lib/trace/constants';\nimport { formatUrl } from '../shared/lib/router/utils/format-url';\nimport { AsyncCallbackSet } from './lib/async-callback-set';\nlet ServerImpl;\nconst getServerImpl = async ()=>{\n    if (ServerImpl === undefined) {\n        ServerImpl = (await Promise.resolve(require('./next-server'))).default;\n    }\n    return ServerImpl;\n};\nconst SYMBOL_LOAD_CONFIG = Symbol('next.load_config');\n/** The wrapper server used by `next start` */ export class NextServer {\n    constructor(options){\n        this.options = options;\n    }\n    get hostname() {\n        return this.options.hostname;\n    }\n    get port() {\n        return this.options.port;\n    }\n    getRequestHandler() {\n        return async (req, res, parsedUrl)=>{\n            return getTracer().trace(NextServerSpan.getRequestHandler, async ()=>{\n                const requestHandler = await this.getServerRequestHandler();\n                return requestHandler(req, res, parsedUrl);\n            });\n        };\n    }\n    getUpgradeHandler() {\n        return async (req, socket, head)=>{\n            const server = await this.getServer();\n            // @ts-expect-error we mark this as protected so it\n            // causes an error here\n            return server.handleUpgrade.apply(server, [\n                req,\n                socket,\n                head\n            ]);\n        };\n    }\n    setAssetPrefix(assetPrefix) {\n        if (this.server) {\n            this.server.setAssetPrefix(assetPrefix);\n        } else {\n            this.preparedAssetPrefix = assetPrefix;\n        }\n    }\n    logError(...args) {\n        if (this.server) {\n            this.server.logError(...args);\n        }\n    }\n    async render(...args) {\n        const server = await this.getServer();\n        return server.render(...args);\n    }\n    async renderToHTML(...args) {\n        const server = await this.getServer();\n        return server.renderToHTML(...args);\n    }\n    async renderError(...args) {\n        const server = await this.getServer();\n        return server.renderError(...args);\n    }\n    async renderErrorToHTML(...args) {\n        const server = await this.getServer();\n        return server.renderErrorToHTML(...args);\n    }\n    async render404(...args) {\n        const server = await this.getServer();\n        return server.render404(...args);\n    }\n    async prepare(serverFields) {\n        const server = await this.getServer();\n        if (serverFields) {\n            Object.assign(server, serverFields);\n        }\n        // We shouldn't prepare the server in production,\n        // because this code won't be executed when deployed\n        if (this.options.dev) {\n            await server.prepare();\n        }\n    }\n    async close() {\n        if (this.server) {\n            await this.server.close();\n        }\n    }\n    async createServer(options) {\n        let ServerImplementation;\n        if (options.dev) {\n            ServerImplementation = require('./dev/next-dev-server').default;\n        } else {\n            ServerImplementation = await getServerImpl();\n        }\n        const server = new ServerImplementation(options);\n        return server;\n    }\n    async [SYMBOL_LOAD_CONFIG]() {\n        const dir = resolve(this.options.dir || '.');\n        const config = await loadConfig(this.options.dev ? PHASE_DEVELOPMENT_SERVER : PHASE_PRODUCTION_SERVER, dir, {\n            customConfig: this.options.conf,\n            silent: true\n        });\n        // check serialized build config when available\n        if (!this.options.dev) {\n            try {\n                const serializedConfig = require(path.join(dir, config.distDir, SERVER_FILES_MANIFEST)).config;\n                // @ts-expect-error internal field\n                config.experimental.isExperimentalCompile = serializedConfig.experimental.isExperimentalCompile;\n            } catch (_) {\n            // if distDir is customized we don't know until we\n            // load the config so fallback to loading the config\n            // from next.config.js\n            }\n        }\n        return config;\n    }\n    async getServer() {\n        if (!this.serverPromise) {\n            this.serverPromise = this[SYMBOL_LOAD_CONFIG]().then(async (conf)=>{\n                if (!this.options.dev) {\n                    if (conf.output === 'standalone') {\n                        if (!process.env.__NEXT_PRIVATE_STANDALONE_CONFIG) {\n                            log.warn(`\"next start\" does not work with \"output: standalone\" configuration. Use \"node .next/standalone/server.js\" instead.`);\n                        }\n                    } else if (conf.output === 'export') {\n                        throw Object.defineProperty(new Error(`\"next start\" does not work with \"output: export\" configuration. Use \"npx serve@latest out\" instead.`), \"__NEXT_ERROR_CODE\", {\n                            value: \"E375\",\n                            enumerable: false,\n                            configurable: true\n                        });\n                    }\n                }\n                this.server = await this.createServer({\n                    ...this.options,\n                    conf\n                });\n                if (this.preparedAssetPrefix) {\n                    this.server.setAssetPrefix(this.preparedAssetPrefix);\n                }\n                return this.server;\n            });\n        }\n        return this.serverPromise;\n    }\n    async getServerRequestHandler() {\n        if (this.reqHandler) return this.reqHandler;\n        // Memoize request handler creation\n        if (!this.reqHandlerPromise) {\n            this.reqHandlerPromise = this.getServer().then((server)=>{\n                this.reqHandler = getTracer().wrap(NextServerSpan.getServerRequestHandler, server.getRequestHandler().bind(server));\n                delete this.reqHandlerPromise;\n                return this.reqHandler;\n            });\n        }\n        return this.reqHandlerPromise;\n    }\n}\n/** The wrapper server used for `import next from \"next\" (in a custom server)` */ class NextCustomServer {\n    constructor(options){\n        this.didWebSocketSetup = false;\n        this.options = options;\n    }\n    getInit() {\n        if (!this.init) {\n            throw Object.defineProperty(new Error('prepare() must be called before performing this operation'), \"__NEXT_ERROR_CODE\", {\n                value: \"E355\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n        return this.init;\n    }\n    get requestHandler() {\n        return this.getInit().requestHandler;\n    }\n    get upgradeHandler() {\n        return this.getInit().upgradeHandler;\n    }\n    get server() {\n        return this.getInit().server;\n    }\n    get hostname() {\n        return this.options.hostname;\n    }\n    get port() {\n        return this.options.port;\n    }\n    async prepare() {\n        const { getRequestHandlers } = require('./lib/start-server');\n        let onDevServerCleanup;\n        if (this.options.dev) {\n            this.cleanupListeners = new AsyncCallbackSet();\n            onDevServerCleanup = this.cleanupListeners.add.bind(this.cleanupListeners);\n        }\n        const initResult = await getRequestHandlers({\n            dir: this.options.dir,\n            port: this.options.port || 3000,\n            isDev: !!this.options.dev,\n            onDevServerCleanup,\n            hostname: this.options.hostname || 'localhost',\n            minimalMode: this.options.minimalMode,\n            quiet: this.options.quiet\n        });\n        this.init = initResult;\n    }\n    setupWebSocketHandler(customServer, _req) {\n        if (!this.didWebSocketSetup) {\n            var _req_socket;\n            this.didWebSocketSetup = true;\n            customServer = customServer || (_req == null ? void 0 : (_req_socket = _req.socket) == null ? void 0 : _req_socket.server);\n            if (customServer) {\n                customServer.on('upgrade', async (req, socket, head)=>{\n                    this.upgradeHandler(req, socket, head);\n                });\n            }\n        }\n    }\n    getRequestHandler() {\n        return async (req, res, parsedUrl)=>{\n            this.setupWebSocketHandler(this.options.httpServer, req);\n            if (parsedUrl) {\n                req.url = formatUrl(parsedUrl);\n            }\n            return this.requestHandler(req, res);\n        };\n    }\n    async render(...args) {\n        let [req, res, pathname, query, parsedUrl] = args;\n        this.setupWebSocketHandler(this.options.httpServer, req);\n        if (!pathname.startsWith('/')) {\n            console.error(`Cannot render page with path \"${pathname}\"`);\n            pathname = `/${pathname}`;\n        }\n        pathname = pathname === '/index' ? '/' : pathname;\n        req.url = formatUrl({\n            ...parsedUrl,\n            pathname,\n            query\n        });\n        await this.requestHandler(req, res);\n        return;\n    }\n    setAssetPrefix(assetPrefix) {\n        this.server.setAssetPrefix(assetPrefix);\n    }\n    getUpgradeHandler() {\n        return this.server.getUpgradeHandler();\n    }\n    logError(...args) {\n        this.server.logError(...args);\n    }\n    async renderToHTML(...args) {\n        return this.server.renderToHTML(...args);\n    }\n    async renderError(...args) {\n        return this.server.renderError(...args);\n    }\n    async renderErrorToHTML(...args) {\n        return this.server.renderErrorToHTML(...args);\n    }\n    async render404(...args) {\n        return this.server.render404(...args);\n    }\n    async close() {\n        var _this_init, _this_cleanupListeners;\n        await Promise.allSettled([\n            (_this_init = this.init) == null ? void 0 : _this_init.server.close(),\n            (_this_cleanupListeners = this.cleanupListeners) == null ? void 0 : _this_cleanupListeners.runAll()\n        ]);\n    }\n}\n// This file is used for when users run `require('next')`\nfunction createServer(options) {\n    if (options && (options.turbo || options.turbopack || process.env.IS_TURBOPACK_TEST)) {\n        process.env.TURBOPACK = '1';\n    }\n    // The package is used as a TypeScript plugin.\n    if (options && 'typescript' in options && 'version' in options.typescript) {\n        const pluginMod = require('./next-typescript');\n        return pluginMod.createTSPlugin(options);\n    }\n    if (options == null) {\n        throw Object.defineProperty(new Error('The server has not been instantiated properly. https://nextjs.org/docs/messages/invalid-server-options'), \"__NEXT_ERROR_CODE\", {\n            value: \"E75\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    if (!('isNextDevCommand' in options) && process.env.NODE_ENV && ![\n        'production',\n        'development',\n        'test'\n    ].includes(process.env.NODE_ENV)) {\n        log.warn(NON_STANDARD_NODE_ENV);\n    }\n    if (options.dev && typeof options.dev !== 'boolean') {\n        console.warn(\"Warning: 'dev' is not a boolean which could introduce unexpected behavior. https://nextjs.org/docs/messages/invalid-server-options\");\n    }\n    // When the caller is a custom server (using next()).\n    if (options.customServer !== false) {\n        const dir = resolve(options.dir || '.');\n        return new NextCustomServer({\n            ...options,\n            dir\n        });\n    }\n    // When the caller is Next.js internals (i.e. render worker, start server, etc)\n    return new NextServer(options);\n}\n// Support commonjs `require('next')`\nmodule.exports = createServer;\n// exports = module.exports\n// Support `import next from 'next'`\nexport default createServer;\n\n//# sourceMappingURL=next.js.map"
        }
    ]
}