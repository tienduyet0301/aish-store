{
    "sourceFile": "node_modules/next/dist/esm/server/patch-error-inspect.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892836554,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import { findSourceMap as nativeFindSourceMap } from 'module';\nimport * as path from 'path';\nimport * as url from 'url';\nimport { SourceMapConsumer as SyncSourceMapConsumer } from 'next/dist/compiled/source-map';\nimport { parseStack } from '../client/components/react-dev-overlay/server/middleware-webpack';\nimport { getOriginalCodeFrame } from '../client/components/react-dev-overlay/server/shared';\nimport { workUnitAsyncStorage } from './app-render/work-unit-async-storage.external';\nimport { dim } from '../lib/picocolors';\n// Find a source map using the bundler's API.\n// This is only a fallback for when Node.js fails to due to bugs e.g. https://github.com/nodejs/node/issues/52102\n// TODO: Remove once all supported Node.js versions are fixed.\n// TODO(veil): Set from Webpack as well\nlet bundlerFindSourceMapPayload = ()=>undefined;\nexport function setBundlerFindSourceMapImplementation(findSourceMapImplementation) {\n    bundlerFindSourceMapPayload = findSourceMapImplementation;\n}\nfunction frameToString(frame) {\n    let sourceLocation = frame.lineNumber !== null ? `:${frame.lineNumber}` : '';\n    if (frame.column !== null && sourceLocation !== '') {\n        sourceLocation += `:${frame.column}`;\n    }\n    let fileLocation;\n    if (frame.file !== null && frame.file.startsWith('file://') && URL.canParse(frame.file)) {\n        // If not relative to CWD, the path is ambiguous to IDEs and clicking will prompt to select the file first.\n        // In a multi-app repo, this leads to potentially larger file names but will make clicking snappy.\n        // There's no tradeoff for the cases where `dir` in `next dev [dir]` is omitted\n        // since relative to cwd is both the shortest and snappiest.\n        fileLocation = path.relative(process.cwd(), url.fileURLToPath(frame.file));\n    } else if (frame.file !== null && frame.file.startsWith('/')) {\n        fileLocation = path.relative(process.cwd(), frame.file);\n    } else {\n        fileLocation = frame.file;\n    }\n    return frame.methodName ? `    at ${frame.methodName} (${fileLocation}${sourceLocation})` : `    at ${fileLocation}${sourceLocation}`;\n}\nfunction computeErrorName(error) {\n    // TODO: Node.js seems to use a different algorithm\n    // class ReadonlyRequestCookiesError extends Error {}` would read `ReadonlyRequestCookiesError: [...]`\n    // in the stack i.e. seems like under certain conditions it favors the constructor name.\n    return error.name || 'Error';\n}\nfunction prepareUnsourcemappedStackTrace(error, structuredStackTrace) {\n    const name = computeErrorName(error);\n    const message = error.message || '';\n    let stack = name + ': ' + message;\n    for(let i = 0; i < structuredStackTrace.length; i++){\n        stack += '\\n    at ' + structuredStackTrace[i].toString();\n    }\n    return stack;\n}\nfunction shouldIgnoreListGeneratedFrame(file) {\n    return file.startsWith('node:') || file.includes('node_modules');\n}\nfunction shouldIgnoreListOriginalFrame(file) {\n    return file.includes('node_modules');\n}\n/**\n * Finds the sourcemap payload applicable to a given frame.\n * Equal to the input unless an Index Source Map is used.\n */ function findApplicableSourceMapPayload(frame, payload) {\n    if ('sections' in payload) {\n        const frameLine = frame.lineNumber ?? 0;\n        const frameColumn = frame.column ?? 0;\n        // Sections must not overlap and must be sorted: https://tc39.es/source-map/#section-object\n        // Therefore the last section that has an offset less than or equal to the frame is the applicable one.\n        // TODO(veil): Binary search\n        let section = payload.sections[0];\n        for(let i = 0; i < payload.sections.length && payload.sections[i].offset.line <= frameLine && payload.sections[i].offset.column <= frameColumn; i++){\n            section = payload.sections[i];\n        }\n        return section === undefined ? undefined : section.map;\n    } else {\n        return payload;\n    }\n}\nfunction createUnsourcemappedFrame(frame) {\n    return {\n        stack: {\n            arguments: frame.arguments,\n            column: frame.column,\n            file: frame.file,\n            lineNumber: frame.lineNumber,\n            methodName: frame.methodName,\n            ignored: shouldIgnoreListGeneratedFrame(frame.file)\n        },\n        code: null\n    };\n}\n/**\n * @param frame\n * @param sourceMapCache\n * @returns The original frame if not sourcemapped.\n */ function getSourcemappedFrameIfPossible(frame, sourceMapCache, inspectOptions) {\n    var _frame_methodName_replace, _frame_methodName;\n    const sourceMapCacheEntry = sourceMapCache.get(frame.file);\n    let sourceMapConsumer;\n    let sourceMapPayload;\n    if (sourceMapCacheEntry === undefined) {\n        let sourceURL = frame.file;\n        // e.g. \"/APP/.next/server/chunks/ssr/[root-of-the-server]__2934a0._.js\"\n        // will be keyed by Node.js as \"file:///APP/.next/server/chunks/ssr/[root-of-the-server]__2934a0._.js\".\n        // This is likely caused by `callsite.toString()` in `Error.prepareStackTrace converting file URLs to paths.\n        if (sourceURL.startsWith('/')) {\n            sourceURL = url.pathToFileURL(frame.file).toString();\n        }\n        let maybeSourceMapPayload;\n        try {\n            const sourceMap = nativeFindSourceMap(sourceURL);\n            maybeSourceMapPayload = sourceMap == null ? void 0 : sourceMap.payload;\n        } catch (cause) {\n            // We should not log an actual error instance here because that will re-enter\n            // this codepath during error inspection and could lead to infinite recursion.\n            console.error(`${sourceURL}: Invalid source map. Only conformant source maps can be used to find the original code. Cause: ${cause}`);\n            // If loading fails once, it'll fail every time.\n            // So set the cache to avoid duplicate errors.\n            sourceMapCache.set(frame.file, null);\n            // Don't even fall back to the bundler because it might be not as strict\n            // with regards to parsing and then we fail later once we consume the\n            // source map payload.\n            // This essentially avoids a redundant error where we fail here and then\n            // later on consumption because the bundler just handed back an invalid\n            // source map.\n            return createUnsourcemappedFrame(frame);\n        }\n        if (maybeSourceMapPayload === undefined) {\n            maybeSourceMapPayload = bundlerFindSourceMapPayload(sourceURL);\n        }\n        if (maybeSourceMapPayload === undefined) {\n            return createUnsourcemappedFrame(frame);\n        }\n        sourceMapPayload = maybeSourceMapPayload;\n        try {\n            sourceMapConsumer = new SyncSourceMapConsumer(// @ts-expect-error -- Module.SourceMap['version'] is number but SyncSourceMapConsumer wants a string\n            sourceMapPayload);\n        } catch (cause) {\n            // We should not log an actual error instance here because that will re-enter\n            // this codepath during error inspection and could lead to infinite recursion.\n            console.error(`${sourceURL}: Invalid source map. Only conformant source maps can be used to find the original code. Cause: ${cause}`);\n            // If creating the consumer fails once, it'll fail every time.\n            // So set the cache to avoid duplicate errors.\n            sourceMapCache.set(frame.file, null);\n            return createUnsourcemappedFrame(frame);\n        }\n        sourceMapCache.set(frame.file, {\n            map: sourceMapConsumer,\n            payload: sourceMapPayload\n        });\n    } else if (sourceMapCacheEntry === null) {\n        // We failed earlier getting the payload or consumer.\n        // Just return an unsourcemapped frame.\n        // Errors will already be logged.\n        return createUnsourcemappedFrame(frame);\n    } else {\n        sourceMapConsumer = sourceMapCacheEntry.map;\n        sourceMapPayload = sourceMapCacheEntry.payload;\n    }\n    const sourcePosition = sourceMapConsumer.originalPositionFor({\n        column: frame.column ?? 0,\n        line: frame.lineNumber ?? 1\n    });\n    if (sourcePosition.source === null) {\n        return {\n            stack: {\n                arguments: frame.arguments,\n                column: frame.column,\n                file: frame.file,\n                lineNumber: frame.lineNumber,\n                methodName: frame.methodName,\n                ignored: shouldIgnoreListGeneratedFrame(frame.file)\n            },\n            code: null\n        };\n    }\n    const sourceContent = sourceMapConsumer.sourceContentFor(sourcePosition.source, /* returnNullOnMissing */ true) ?? null;\n    const applicableSourceMap = findApplicableSourceMapPayload(frame, sourceMapPayload);\n    // TODO(veil): Upstream a method to sourcemap consumer that immediately says if a frame is ignored or not.\n    let ignored = false;\n    if (applicableSourceMap === undefined) {\n        console.error('No applicable source map found in sections for frame', frame);\n    } else if (shouldIgnoreListOriginalFrame(sourcePosition.source)) {\n        // Externals may be libraries that don't ship ignoreLists.\n        // This is really taking control away from libraries.\n        // They should still ship `ignoreList` so that attached debuggers ignore-list their frames.\n        // TODO: Maybe only ignore library sourcemaps if `ignoreList` is absent?\n        // Though keep in mind that Turbopack omits empty `ignoreList`.\n        // So if we establish this convention, we should communicate it to the ecosystem.\n        ignored = true;\n    } else {\n        var _applicableSourceMap_ignoreList;\n        // TODO: O(n^2). Consider moving `ignoreList` into a Set\n        const sourceIndex = applicableSourceMap.sources.indexOf(sourcePosition.source);\n        ignored = ((_applicableSourceMap_ignoreList = applicableSourceMap.ignoreList) == null ? void 0 : _applicableSourceMap_ignoreList.includes(sourceIndex)) ?? false;\n    }\n    const originalFrame = {\n        // We ignore the sourcemapped name since it won't be the correct name.\n        // The callsite will point to the column of the variable name instead of the\n        // name of the enclosing function.\n        // TODO(NDX-531): Spy on prepareStackTrace to get the enclosing line number for method name mapping.\n        methodName: (_frame_methodName = frame.methodName) == null ? void 0 : (_frame_methodName_replace = _frame_methodName.replace('__WEBPACK_DEFAULT_EXPORT__', 'default')) == null ? void 0 : _frame_methodName_replace.replace('__webpack_exports__.', ''),\n        column: sourcePosition.column,\n        file: sourcePosition.source,\n        lineNumber: sourcePosition.line,\n        // TODO: c&p from async createOriginalStackFrame but why not frame.arguments?\n        arguments: [],\n        ignored\n    };\n    const codeFrame = process.env.NODE_ENV !== 'production' ? getOriginalCodeFrame(originalFrame, sourceContent, inspectOptions.colors) : null;\n    return {\n        stack: originalFrame,\n        code: codeFrame\n    };\n}\nfunction parseAndSourceMap(error, inspectOptions) {\n    // TODO(veil): Expose as CLI arg or config option. Useful for local debugging.\n    const showIgnoreListed = false;\n    // We overwrote Error.prepareStackTrace earlier so error.stack is not sourcemapped.\n    let unparsedStack = String(error.stack);\n    // We could just read it from `error.stack`.\n    // This works around cases where a 3rd party `Error.prepareStackTrace` implementation\n    // doesn't implement the name computation correctly.\n    const errorName = computeErrorName(error);\n    let idx = unparsedStack.indexOf('react-stack-bottom-frame');\n    if (idx !== -1) {\n        idx = unparsedStack.lastIndexOf('\\n', idx);\n    }\n    if (idx !== -1 && !showIgnoreListed) {\n        // Cut off everything after the bottom frame since it'll be React internals.\n        unparsedStack = unparsedStack.slice(0, idx);\n    }\n    const unsourcemappedStack = parseStack(unparsedStack);\n    const sourceMapCache = new Map();\n    let sourceMappedStack = '';\n    let sourceFrameDEV = null;\n    for (const frame of unsourcemappedStack){\n        if (frame.file === null) {\n            sourceMappedStack += '\\n' + frameToString(frame);\n        } else {\n            const sourcemappedFrame = getSourcemappedFrameIfPossible(// We narrowed this earlier by bailing if `frame.file` is null.\n            frame, sourceMapCache, inspectOptions);\n            if (process.env.NODE_ENV !== 'production' && sourcemappedFrame.code !== null && sourceFrameDEV === null && // TODO: Is this the right choice?\n            !sourcemappedFrame.stack.ignored) {\n                sourceFrameDEV = sourcemappedFrame.code;\n            }\n            if (!sourcemappedFrame.stack.ignored) {\n                // TODO: Consider what happens if every frame is ignore listed.\n                sourceMappedStack += '\\n' + frameToString(sourcemappedFrame.stack);\n            } else if (showIgnoreListed && !inspectOptions.colors) {\n                sourceMappedStack += '\\n' + frameToString(sourcemappedFrame.stack);\n            } else if (showIgnoreListed) {\n                sourceMappedStack += '\\n' + dim(frameToString(sourcemappedFrame.stack));\n            }\n        }\n    }\n    return errorName + ': ' + error.message + sourceMappedStack + (sourceFrameDEV !== null ? '\\n' + sourceFrameDEV : '');\n}\nfunction sourceMapError(error, inspectOptions) {\n    // Create a new Error object with the source mapping applied and then use native\n    // Node.js formatting on the result.\n    const newError = error.cause !== undefined ? Object.defineProperty(new Error(error.message, {\n        cause: error.cause\n    }), \"__NEXT_ERROR_CODE\", {\n        value: \"E394\",\n        enumerable: false,\n        configurable: true\n    }) : Object.defineProperty(new Error(error.message), \"__NEXT_ERROR_CODE\", {\n        value: \"E394\",\n        enumerable: false,\n        configurable: true\n    });\n    // TODO: Ensure `class MyError extends Error {}` prints `MyError` as the name\n    newError.stack = parseAndSourceMap(error, inspectOptions);\n    for(const key in error){\n        if (!Object.prototype.hasOwnProperty.call(newError, key)) {\n            // @ts-expect-error -- We're copying all enumerable properties.\n            // So they definitely exist on `this` and obviously have no type on `newError` (yet)\n            newError[key] = error[key];\n        }\n    }\n    return newError;\n}\nexport function patchErrorInspectNodeJS(errorConstructor) {\n    const inspectSymbol = Symbol.for('nodejs.util.inspect.custom');\n    errorConstructor.prepareStackTrace = prepareUnsourcemappedStackTrace;\n    // @ts-expect-error -- TODO upstream types\n    // eslint-disable-next-line no-extend-native -- We're not extending but overriding.\n    errorConstructor.prototype[inspectSymbol] = function(depth, inspectOptions, inspect) {\n        // avoid false-positive dynamic i/o warnings e.g. due to usage of `Math.random` in `source-map`.\n        return workUnitAsyncStorage.exit(()=>{\n            const newError = sourceMapError(this, inspectOptions);\n            const originalCustomInspect = newError[inspectSymbol];\n            // Prevent infinite recursion.\n            // { customInspect: false } would result in `error.cause` not using our inspect.\n            Object.defineProperty(newError, inspectSymbol, {\n                value: undefined,\n                enumerable: false,\n                writable: true\n            });\n            try {\n                return inspect(newError, {\n                    ...inspectOptions,\n                    depth: (inspectOptions.depth ?? // Default in Node.js\n                    2) - depth\n                });\n            } finally{\n                ;\n                newError[inspectSymbol] = originalCustomInspect;\n            }\n        });\n    };\n}\nexport function patchErrorInspectEdgeLite(errorConstructor) {\n    const inspectSymbol = Symbol.for('edge-runtime.inspect.custom');\n    errorConstructor.prepareStackTrace = prepareUnsourcemappedStackTrace;\n    // @ts-expect-error -- TODO upstream types\n    // eslint-disable-next-line no-extend-native -- We're not extending but overriding.\n    errorConstructor.prototype[inspectSymbol] = function({ format }) {\n        // avoid false-positive dynamic i/o warnings e.g. due to usage of `Math.random` in `source-map`.\n        return workUnitAsyncStorage.exit(()=>{\n            const newError = sourceMapError(this, {});\n            const originalCustomInspect = newError[inspectSymbol];\n            // Prevent infinite recursion.\n            Object.defineProperty(newError, inspectSymbol, {\n                value: undefined,\n                enumerable: false,\n                writable: true\n            });\n            try {\n                return format(newError);\n            } finally{\n                ;\n                newError[inspectSymbol] = originalCustomInspect;\n            }\n        });\n    };\n}\n\n//# sourceMappingURL=patch-error-inspect.js.map"
        }
    ]
}