{
    "sourceFile": "node_modules/next/dist/esm/server/dev/next-dev-server.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892828462,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import { getRequestMeta } from '../request-meta';\nimport fs from 'fs';\nimport { Worker } from 'next/dist/compiled/jest-worker';\nimport { join as pathJoin } from 'path';\nimport { ampValidation } from '../../build/output';\nimport { INSTRUMENTATION_HOOK_FILENAME, PUBLIC_DIR_MIDDLEWARE_CONFLICT } from '../../lib/constants';\nimport { findPagesDir } from '../../lib/find-pages-dir';\nimport { PHASE_DEVELOPMENT_SERVER, PAGES_MANIFEST, APP_PATHS_MANIFEST, COMPILER_NAMES } from '../../shared/lib/constants';\nimport Server, { WrappedBuildError } from '../next-server';\nimport { normalizePagePath } from '../../shared/lib/page-path/normalize-page-path';\nimport { pathHasPrefix } from '../../shared/lib/router/utils/path-has-prefix';\nimport { removePathPrefix } from '../../shared/lib/router/utils/remove-path-prefix';\nimport { Telemetry } from '../../telemetry/storage';\nimport { setGlobal, trace } from '../../trace';\nimport { findPageFile } from '../lib/find-page-file';\nimport { getFormattedNodeOptionsWithoutInspect } from '../lib/utils';\nimport { withCoalescedInvoke } from '../../lib/coalesced-function';\nimport { loadDefaultErrorComponents } from '../load-default-error-components';\nimport { DecodeError, MiddlewareNotFoundError } from '../../shared/lib/utils';\nimport * as Log from '../../build/output/log';\nimport isError, { getProperError } from '../../lib/is-error';\nimport { isMiddlewareFile } from '../../build/utils';\nimport { formatServerError } from '../../lib/format-server-error';\nimport { DevRouteMatcherManager } from '../route-matcher-managers/dev-route-matcher-manager';\nimport { DevPagesRouteMatcherProvider } from '../route-matcher-providers/dev/dev-pages-route-matcher-provider';\nimport { DevPagesAPIRouteMatcherProvider } from '../route-matcher-providers/dev/dev-pages-api-route-matcher-provider';\nimport { DevAppPageRouteMatcherProvider } from '../route-matcher-providers/dev/dev-app-page-route-matcher-provider';\nimport { DevAppRouteRouteMatcherProvider } from '../route-matcher-providers/dev/dev-app-route-route-matcher-provider';\nimport { NodeManifestLoader } from '../route-matcher-providers/helpers/manifest-loaders/node-manifest-loader';\nimport { BatchedFileReader } from '../route-matcher-providers/dev/helpers/file-reader/batched-file-reader';\nimport { DefaultFileReader } from '../route-matcher-providers/dev/helpers/file-reader/default-file-reader';\nimport { LRUCache } from '../lib/lru-cache';\nimport { getMiddlewareRouteMatcher } from '../../shared/lib/router/utils/middleware-route-matcher';\nimport { DetachedPromise } from '../../lib/detached-promise';\nimport { isPostpone } from '../lib/router-utils/is-postpone';\nimport { generateInterceptionRoutesRewrites } from '../../lib/generate-interception-routes-rewrites';\nimport { buildCustomRoute } from '../../lib/build-custom-route';\nimport { decorateServerError } from '../../shared/lib/error-source';\nimport { logRequests } from './log-requests';\nimport { FallbackMode } from '../../lib/fallback';\n// Load ReactDevOverlay only when needed\nlet ReactDevOverlayImpl;\nconst ReactDevOverlay = (props)=>{\n    if (ReactDevOverlayImpl === undefined) {\n        ReactDevOverlayImpl = require('../../client/components/react-dev-overlay/pages/pages-dev-overlay').PagesDevOverlay;\n    }\n    return ReactDevOverlayImpl(props);\n};\nexport default class DevServer extends Server {\n    getStaticPathsWorker() {\n        const worker = new Worker(require.resolve('./static-paths-worker'), {\n            maxRetries: 1,\n            // For dev server, it's not necessary to spin up too many workers as long as you are not doing a load test.\n            // This helps reusing the memory a lot.\n            numWorkers: 1,\n            enableWorkerThreads: this.nextConfig.experimental.workerThreads,\n            forkOptions: {\n                env: {\n                    ...process.env,\n                    // discard --inspect/--inspect-brk flags from process.env.NODE_OPTIONS. Otherwise multiple Node.js debuggers\n                    // would be started if user launch Next.js in debugging mode. The number of debuggers is linked to\n                    // the number of workers Next.js tries to launch. The only worker users are interested in debugging\n                    // is the main Next.js one\n                    NODE_OPTIONS: getFormattedNodeOptionsWithoutInspect()\n                }\n            }\n        });\n        worker.getStdout().pipe(process.stdout);\n        worker.getStderr().pipe(process.stderr);\n        return worker;\n    }\n    constructor(options){\n        var _this_nextConfig_experimental_amp, _this_nextConfig_experimental;\n        try {\n            // Increase the number of stack frames on the server\n            Error.stackTraceLimit = 50;\n        } catch  {}\n        super({\n            ...options,\n            dev: true\n        }), /**\n   * The promise that resolves when the server is ready. When this is unset\n   * the server is ready.\n   */ this.ready = new DetachedPromise();\n        this.bundlerService = options.bundlerService;\n        this.startServerSpan = options.startServerSpan ?? trace('start-next-dev-server');\n        this.renderOpts.dev = true;\n        this.renderOpts.ErrorDebug = ReactDevOverlay;\n        this.staticPathsCache = new LRUCache(// 5MB\n        5 * 1024 * 1024, function length(value) {\n            var _JSON_stringify;\n            return ((_JSON_stringify = JSON.stringify(value.staticPaths)) == null ? void 0 : _JSON_stringify.length) ?? 0;\n        });\n        this.renderOpts.ampSkipValidation = ((_this_nextConfig_experimental = this.nextConfig.experimental) == null ? void 0 : (_this_nextConfig_experimental_amp = _this_nextConfig_experimental.amp) == null ? void 0 : _this_nextConfig_experimental_amp.skipValidation) ?? false;\n        this.renderOpts.ampValidator = (html, pathname)=>{\n            const validatorPath = this.nextConfig.experimental && this.nextConfig.experimental.amp && this.nextConfig.experimental.amp.validator || require.resolve('next/dist/compiled/amphtml-validator/validator_wasm.js');\n            const AmpHtmlValidator = require('next/dist/compiled/amphtml-validator');\n            return AmpHtmlValidator.getInstance(validatorPath).then((validator)=>{\n                const result = validator.validateString(html);\n                ampValidation(pathname, result.errors.filter((e)=>e.severity === 'ERROR').filter((e)=>this._filterAmpDevelopmentScript(html, e)), result.errors.filter((e)=>e.severity !== 'ERROR'));\n            });\n        };\n        const { pagesDir, appDir } = findPagesDir(this.dir);\n        this.pagesDir = pagesDir;\n        this.appDir = appDir;\n        if (this.nextConfig.experimental.serverComponentsHmrCache) {\n            this.serverComponentsHmrCache = new LRUCache(this.nextConfig.cacheMaxMemorySize, function length(value) {\n                return JSON.stringify(value).length;\n            });\n        }\n    }\n    getServerComponentsHmrCache() {\n        return this.serverComponentsHmrCache;\n    }\n    getRouteMatchers() {\n        const { pagesDir, appDir } = findPagesDir(this.dir);\n        const ensurer = {\n            ensure: async (match, pathname)=>{\n                await this.ensurePage({\n                    definition: match.definition,\n                    page: match.definition.page,\n                    clientOnly: false,\n                    url: pathname\n                });\n            }\n        };\n        const matchers = new DevRouteMatcherManager(super.getRouteMatchers(), ensurer, this.dir);\n        const extensions = this.nextConfig.pageExtensions;\n        const extensionsExpression = new RegExp(`\\\\.(?:${extensions.join('|')})$`);\n        // If the pages directory is available, then configure those matchers.\n        if (pagesDir) {\n            const fileReader = new BatchedFileReader(new DefaultFileReader({\n                // Only allow files that have the correct extensions.\n                pathnameFilter: (pathname)=>extensionsExpression.test(pathname)\n            }));\n            matchers.push(new DevPagesRouteMatcherProvider(pagesDir, extensions, fileReader, this.localeNormalizer));\n            matchers.push(new DevPagesAPIRouteMatcherProvider(pagesDir, extensions, fileReader, this.localeNormalizer));\n        }\n        if (appDir) {\n            // We create a new file reader for the app directory because we don't want\n            // to include any folders or files starting with an underscore. This will\n            // prevent the reader from wasting time reading files that we know we\n            // don't care about.\n            const fileReader = new BatchedFileReader(new DefaultFileReader({\n                // Ignore any directory prefixed with an underscore.\n                ignorePartFilter: (part)=>part.startsWith('_')\n            }));\n            matchers.push(new DevAppPageRouteMatcherProvider(appDir, extensions, fileReader));\n            matchers.push(new DevAppRouteRouteMatcherProvider(appDir, extensions, fileReader));\n        }\n        return matchers;\n    }\n    getBuildId() {\n        return 'development';\n    }\n    async prepareImpl() {\n        var _this_ready;\n        setGlobal('distDir', this.distDir);\n        setGlobal('phase', PHASE_DEVELOPMENT_SERVER);\n        const telemetry = new Telemetry({\n            distDir: this.distDir\n        });\n        await super.prepareImpl();\n        await this.matchers.reload();\n        (_this_ready = this.ready) == null ? void 0 : _this_ready.resolve();\n        this.ready = undefined;\n        // In dev, this needs to be called after prepare because the build entries won't be known in the constructor\n        this.interceptionRoutePatterns = this.getinterceptionRoutePatterns();\n        // This is required by the tracing subsystem.\n        setGlobal('appDir', this.appDir);\n        setGlobal('pagesDir', this.pagesDir);\n        setGlobal('telemetry', telemetry);\n        process.on('unhandledRejection', (reason)=>{\n            if (isPostpone(reason)) {\n                // React postpones that are unhandled might end up logged here but they're\n                // not really errors. They're just part of rendering.\n                return;\n            }\n            this.logErrorWithOriginalStack(reason, 'unhandledRejection');\n        });\n        process.on('uncaughtException', (err)=>{\n            this.logErrorWithOriginalStack(err, 'uncaughtException');\n        });\n    }\n    async hasPage(pathname) {\n        let normalizedPath;\n        try {\n            normalizedPath = normalizePagePath(pathname);\n        } catch (err) {\n            console.error(err);\n            // if normalizing the page fails it means it isn't valid\n            // so it doesn't exist so don't throw and return false\n            // to ensure we return 404 instead of 500\n            return false;\n        }\n        if (isMiddlewareFile(normalizedPath)) {\n            return findPageFile(this.dir, normalizedPath, this.nextConfig.pageExtensions, false).then(Boolean);\n        }\n        let appFile = null;\n        let pagesFile = null;\n        if (this.appDir) {\n            appFile = await findPageFile(this.appDir, normalizedPath + '/page', this.nextConfig.pageExtensions, true);\n        }\n        if (this.pagesDir) {\n            pagesFile = await findPageFile(this.pagesDir, normalizedPath, this.nextConfig.pageExtensions, false);\n        }\n        if (appFile && pagesFile) {\n            return false;\n        }\n        return Boolean(appFile || pagesFile);\n    }\n    async runMiddleware(params) {\n        try {\n            const result = await super.runMiddleware({\n                ...params,\n                onWarning: (warn)=>{\n                    this.logErrorWithOriginalStack(warn, 'warning');\n                }\n            });\n            if ('finished' in result) {\n                return result;\n            }\n            result.waitUntil.catch((error)=>{\n                this.logErrorWithOriginalStack(error, 'unhandledRejection');\n            });\n            return result;\n        } catch (error) {\n            if (error instanceof DecodeError) {\n                throw error;\n            }\n            /**\n       * We only log the error when it is not a MiddlewareNotFound error as\n       * in that case we should be already displaying a compilation error\n       * which is what makes the module not found.\n       */ if (!(error instanceof MiddlewareNotFoundError)) {\n                this.logErrorWithOriginalStack(error);\n            }\n            const err = getProperError(error);\n            decorateServerError(err, COMPILER_NAMES.edgeServer);\n            const { request, response, parsedUrl } = params;\n            /**\n       * When there is a failure for an internal Next.js request from\n       * middleware we bypass the error without finishing the request\n       * so we can serve the required chunks to render the error.\n       */ if (request.url.includes('/_next/static') || request.url.includes('/__nextjs_original-stack-frame') || request.url.includes('/__nextjs_source-map') || request.url.includes('/__nextjs_error_feedback')) {\n                return {\n                    finished: false\n                };\n            }\n            response.statusCode = 500;\n            await this.renderError(err, request, response, parsedUrl.pathname);\n            return {\n                finished: true\n            };\n        }\n    }\n    async runEdgeFunction(params) {\n        try {\n            return super.runEdgeFunction({\n                ...params,\n                onError: (err)=>this.logErrorWithOriginalStack(err, 'app-dir'),\n                onWarning: (warn)=>{\n                    this.logErrorWithOriginalStack(warn, 'warning');\n                }\n            });\n        } catch (error) {\n            if (error instanceof DecodeError) {\n                throw error;\n            }\n            this.logErrorWithOriginalStack(error, 'warning');\n            const err = getProperError(error);\n            const { req, res, page } = params;\n            res.statusCode = 500;\n            await this.renderError(err, req, res, page);\n            return null;\n        }\n    }\n    getRequestHandler() {\n        const handler = super.getRequestHandler();\n        return (req, res, parsedUrl)=>{\n            const request = this.normalizeReq(req);\n            const response = this.normalizeRes(res);\n            const loggingConfig = this.nextConfig.logging;\n            if (loggingConfig !== false) {\n                const start = Date.now();\n                const isMiddlewareRequest = getRequestMeta(req, 'middlewareInvoke');\n                if (!isMiddlewareRequest) {\n                    response.originalResponse.once('close', ()=>{\n                        // NOTE: The route match is only attached to the request's meta data\n                        // after the request handler is created, so we need to check it in the\n                        // close handler and not before.\n                        const routeMatch = getRequestMeta(req).match;\n                        if (!routeMatch) {\n                            return;\n                        }\n                        logRequests({\n                            request,\n                            response,\n                            loggingConfig,\n                            requestDurationInMs: Date.now() - start\n                        });\n                    });\n                }\n            }\n            return handler(request, response, parsedUrl);\n        };\n    }\n    async handleRequest(req, res, parsedUrl) {\n        const span = trace('handle-request', undefined, {\n            url: req.url\n        });\n        const result = await span.traceAsyncFn(async ()=>{\n            var _this_ready;\n            await ((_this_ready = this.ready) == null ? void 0 : _this_ready.promise);\n            return await super.handleRequest(req, res, parsedUrl);\n        });\n        const memoryUsage = process.memoryUsage();\n        span.traceChild('memory-usage', {\n            url: req.url,\n            'memory.rss': String(memoryUsage.rss),\n            'memory.heapUsed': String(memoryUsage.heapUsed),\n            'memory.heapTotal': String(memoryUsage.heapTotal)\n        }).stop();\n        return result;\n    }\n    async run(req, res, parsedUrl) {\n        var _this_ready;\n        await ((_this_ready = this.ready) == null ? void 0 : _this_ready.promise);\n        const { basePath } = this.nextConfig;\n        let originalPathname = null;\n        // TODO: see if we can remove this in the future\n        if (basePath && pathHasPrefix(parsedUrl.pathname || '/', basePath)) {\n            // strip basePath before handling dev bundles\n            // If replace ends up replacing the full url it'll be `undefined`, meaning we have to default it to `/`\n            originalPathname = parsedUrl.pathname;\n            parsedUrl.pathname = removePathPrefix(parsedUrl.pathname || '/', basePath);\n        }\n        const { pathname } = parsedUrl;\n        if (pathname.startsWith('/_next')) {\n            if (fs.existsSync(pathJoin(this.publicDir, '_next'))) {\n                throw Object.defineProperty(new Error(PUBLIC_DIR_MIDDLEWARE_CONFLICT), \"__NEXT_ERROR_CODE\", {\n                    value: \"E394\",\n                    enumerable: false,\n                    configurable: true\n                });\n            }\n        }\n        if (originalPathname) {\n            // restore the path before continuing so that custom-routes can accurately determine\n            // if they should match against the basePath or not\n            parsedUrl.pathname = originalPathname;\n        }\n        try {\n            return await super.run(req, res, parsedUrl);\n        } catch (error) {\n            const err = getProperError(error);\n            formatServerError(err);\n            this.logErrorWithOriginalStack(err);\n            if (!res.sent) {\n                res.statusCode = 500;\n                try {\n                    return await this.renderError(err, req, res, pathname, {\n                        __NEXT_PAGE: isError(err) && err.page || pathname || ''\n                    });\n                } catch (internalErr) {\n                    console.error(internalErr);\n                    res.body('Internal Server Error').send();\n                }\n            }\n        }\n    }\n    logErrorWithOriginalStack(err, type) {\n        this.bundlerService.logErrorWithOriginalStack(err, type);\n    }\n    getPagesManifest() {\n        return NodeManifestLoader.require(pathJoin(this.serverDistDir, PAGES_MANIFEST)) ?? undefined;\n    }\n    getAppPathsManifest() {\n        if (!this.enabledDirectories.app) return undefined;\n        return NodeManifestLoader.require(pathJoin(this.serverDistDir, APP_PATHS_MANIFEST)) ?? undefined;\n    }\n    getinterceptionRoutePatterns() {\n        const rewrites = generateInterceptionRoutesRewrites(Object.keys(this.appPathRoutes ?? {}), this.nextConfig.basePath).map((route)=>new RegExp(buildCustomRoute('rewrite', route).regex));\n        if (this.nextConfig.output === 'export' && rewrites.length > 0) {\n            Log.error('Intercepting routes are not supported with static export.\\nRead more: https://nextjs.org/docs/app/building-your-application/deploying/static-exports#unsupported-features');\n            process.exit(1);\n        }\n        return rewrites ?? [];\n    }\n    async getMiddleware() {\n        var _this_middleware;\n        // We need to populate the match\n        // field as it isn't serializable\n        if (((_this_middleware = this.middleware) == null ? void 0 : _this_middleware.match) === null) {\n            this.middleware.match = getMiddlewareRouteMatcher(this.middleware.matchers || []);\n        }\n        return this.middleware;\n    }\n    getNextFontManifest() {\n        return undefined;\n    }\n    async hasMiddleware() {\n        return this.hasPage(this.actualMiddlewareFile);\n    }\n    async ensureMiddleware(url) {\n        return this.ensurePage({\n            page: this.actualMiddlewareFile,\n            clientOnly: false,\n            definition: undefined,\n            url\n        });\n    }\n    async loadInstrumentationModule() {\n        let instrumentationModule;\n        if (this.actualInstrumentationHookFile && await this.ensurePage({\n            page: this.actualInstrumentationHookFile,\n            clientOnly: false,\n            definition: undefined\n        }).then(()=>true).catch(()=>false)) {\n            try {\n                instrumentationModule = await require(pathJoin(this.distDir, 'server', INSTRUMENTATION_HOOK_FILENAME));\n            } catch (err) {\n                err.message = `An error occurred while loading instrumentation hook: ${err.message}`;\n                throw err;\n            }\n        }\n        return instrumentationModule;\n    }\n    async runInstrumentationHookIfAvailable() {\n        await this.startServerSpan.traceChild('run-instrumentation-hook').traceAsyncFn(()=>{\n            var _this_instrumentation_register, _this_instrumentation;\n            return (_this_instrumentation = this.instrumentation) == null ? void 0 : (_this_instrumentation_register = _this_instrumentation.register) == null ? void 0 : _this_instrumentation_register.call(_this_instrumentation);\n        });\n    }\n    async ensureEdgeFunction({ page, appPaths, url }) {\n        return this.ensurePage({\n            page,\n            appPaths,\n            clientOnly: false,\n            definition: undefined,\n            url\n        });\n    }\n    generateRoutes(_dev) {\n    // In development we expose all compiled files for react-error-overlay's line show feature\n    // We use unshift so that we're sure the routes is defined before Next's default routes\n    // routes.unshift({\n    //   match: getPathMatch('/_next/development/:path*'),\n    //   type: 'route',\n    //   name: '_next/development catchall',\n    //   fn: async (req, res, params) => {\n    //     const p = pathJoin(this.distDir, ...(params.path || []))\n    //     await this.serveStatic(req, res, p)\n    //     return {\n    //       finished: true,\n    //     }\n    //   },\n    // })\n    }\n    _filterAmpDevelopmentScript(html, event) {\n        if (event.code !== 'DISALLOWED_SCRIPT_TAG') {\n            return true;\n        }\n        const snippetChunks = html.split('\\n');\n        let snippet;\n        if (!(snippet = html.split('\\n')[event.line - 1]) || !(snippet = snippet.substring(event.col))) {\n            return true;\n        }\n        snippet = snippet + snippetChunks.slice(event.line).join('\\n');\n        snippet = snippet.substring(0, snippet.indexOf('</script>'));\n        return !snippet.includes('data-amp-development-mode-only');\n    }\n    async getStaticPaths({ pathname, requestHeaders, page, isAppPath }) {\n        // we lazy load the staticPaths to prevent the user\n        // from waiting on them for the page to load in dev mode\n        const __getStaticPaths = async ()=>{\n            const { configFileName, publicRuntimeConfig, serverRuntimeConfig, httpAgentOptions } = this.nextConfig;\n            const { locales, defaultLocale } = this.nextConfig.i18n || {};\n            const staticPathsWorker = this.getStaticPathsWorker();\n            try {\n                var _this_nextConfig_experimental_sri;\n                const pathsResult = await staticPathsWorker.loadStaticPaths({\n                    dir: this.dir,\n                    distDir: this.distDir,\n                    pathname,\n                    config: {\n                        pprConfig: this.nextConfig.experimental.ppr,\n                        configFileName,\n                        publicRuntimeConfig,\n                        serverRuntimeConfig,\n                        dynamicIO: Boolean(this.nextConfig.experimental.dynamicIO)\n                    },\n                    httpAgentOptions,\n                    locales,\n                    defaultLocale,\n                    page,\n                    isAppPath,\n                    requestHeaders,\n                    cacheHandler: this.nextConfig.cacheHandler,\n                    cacheHandlers: this.nextConfig.experimental.cacheHandlers,\n                    cacheLifeProfiles: this.nextConfig.experimental.cacheLife,\n                    fetchCacheKeyPrefix: this.nextConfig.experimental.fetchCacheKeyPrefix,\n                    isrFlushToDisk: this.nextConfig.experimental.isrFlushToDisk,\n                    maxMemoryCacheSize: this.nextConfig.cacheMaxMemorySize,\n                    nextConfigOutput: this.nextConfig.output,\n                    buildId: this.buildId,\n                    authInterrupts: Boolean(this.nextConfig.experimental.authInterrupts),\n                    sriEnabled: Boolean((_this_nextConfig_experimental_sri = this.nextConfig.experimental.sri) == null ? void 0 : _this_nextConfig_experimental_sri.algorithm)\n                });\n                return pathsResult;\n            } finally{\n                // we don't re-use workers so destroy the used one\n                staticPathsWorker.end();\n            }\n        };\n        const result = this.staticPathsCache.get(pathname);\n        const nextInvoke = withCoalescedInvoke(__getStaticPaths)(`staticPaths-${pathname}`, []).then((res)=>{\n            const { prerenderedRoutes: staticPaths, fallbackMode: fallback } = res.value;\n            if (!isAppPath && this.nextConfig.output === 'export') {\n                if (fallback === FallbackMode.BLOCKING_STATIC_RENDER) {\n                    throw Object.defineProperty(new Error('getStaticPaths with \"fallback: blocking\" cannot be used with \"output: export\". See more info here: https://nextjs.org/docs/advanced-features/static-html-export'), \"__NEXT_ERROR_CODE\", {\n                        value: \"E11\",\n                        enumerable: false,\n                        configurable: true\n                    });\n                } else if (fallback === FallbackMode.PRERENDER) {\n                    throw Object.defineProperty(new Error('getStaticPaths with \"fallback: true\" cannot be used with \"output: export\". See more info here: https://nextjs.org/docs/advanced-features/static-html-export'), \"__NEXT_ERROR_CODE\", {\n                        value: \"E210\",\n                        enumerable: false,\n                        configurable: true\n                    });\n                }\n            }\n            const value = {\n                staticPaths: staticPaths == null ? void 0 : staticPaths.map((route)=>route.pathname),\n                fallbackMode: fallback\n            };\n            this.staticPathsCache.set(pathname, value);\n            return value;\n        }).catch((err)=>{\n            this.staticPathsCache.remove(pathname);\n            if (!result) throw err;\n            Log.error(`Failed to generate static paths for ${pathname}:`);\n            console.error(err);\n        });\n        if (result) {\n            return result;\n        }\n        return nextInvoke;\n    }\n    async ensurePage(opts) {\n        await this.bundlerService.ensurePage(opts);\n    }\n    async findPageComponents({ locale, page, query, params, isAppPath, appPaths = null, shouldEnsure, url }) {\n        var _this_ready;\n        await ((_this_ready = this.ready) == null ? void 0 : _this_ready.promise);\n        const compilationErr = await this.getCompilationError(page);\n        if (compilationErr) {\n            // Wrap build errors so that they don't get logged again\n            throw new WrappedBuildError(compilationErr);\n        }\n        if (shouldEnsure || this.serverOptions.customServer) {\n            await this.ensurePage({\n                page,\n                appPaths,\n                clientOnly: false,\n                definition: undefined,\n                url\n            });\n        }\n        this.nextFontManifest = super.getNextFontManifest();\n        return await super.findPageComponents({\n            page,\n            query,\n            params,\n            locale,\n            isAppPath,\n            shouldEnsure,\n            url\n        });\n    }\n    async getFallbackErrorComponents(url) {\n        await this.bundlerService.getFallbackErrorComponents(url);\n        return await loadDefaultErrorComponents(this.distDir);\n    }\n    async getCompilationError(page) {\n        return await this.bundlerService.getCompilationError(page);\n    }\n    async instrumentationOnRequestError(...args) {\n        await super.instrumentationOnRequestError(...args);\n        const err = args[0];\n        this.logErrorWithOriginalStack(err, 'app-dir');\n    }\n}\n\n//# sourceMappingURL=next-dev-server.js.map"
        }
    ]
}