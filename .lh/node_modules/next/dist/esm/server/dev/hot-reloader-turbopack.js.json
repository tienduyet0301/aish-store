{
    "sourceFile": "node_modules/next/dist/esm/server/dev/hot-reloader-turbopack.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892827928,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import { mkdir, writeFile } from 'fs/promises';\nimport { join, extname } from 'path';\nimport { pathToFileURL } from 'url';\nimport ws from 'next/dist/compiled/ws';\nimport { store as consoleStore } from '../../build/output/store';\nimport { HMR_ACTIONS_SENT_TO_BROWSER } from './hot-reloader-types';\nimport { createDefineEnv } from '../../build/swc';\nimport * as Log from '../../build/output/log';\nimport { getVersionInfo, matchNextPageBundleRequest } from './hot-reloader-webpack';\nimport { BLOCKED_PAGES } from '../../shared/lib/constants';\nimport { getOverlayMiddleware, getSourceMapMiddleware } from '../../client/components/react-dev-overlay/server/middleware-turbopack';\nimport { PageNotFoundError } from '../../shared/lib/utils';\nimport { debounce } from '../utils';\nimport { deleteCache, deleteFromRequireCache } from './require-cache';\nimport { clearAllModuleContexts, clearModuleContext } from '../lib/render-server';\nimport { denormalizePagePath } from '../../shared/lib/page-path/denormalize-page-path';\nimport { trace } from '../../trace';\nimport { AssetMapper, handleEntrypoints, handlePagesErrorRoute, handleRouteType, hasEntrypointForKey, msToNs, processTopLevelIssues, printNonFatalIssue, normalizedPageToTurbopackStructureRoute } from './turbopack-utils';\nimport { propagateServerField } from '../lib/router-utils/setup-dev-bundler';\nimport { TurbopackManifestLoader } from '../../shared/lib/turbopack/manifest-loader';\nimport { findPagePathData } from './on-demand-entry-handler';\nimport { getEntryKey, splitEntryKey } from '../../shared/lib/turbopack/entry-key';\nimport { FAST_REFRESH_RUNTIME_RELOAD } from './messages';\nimport { generateEncryptionKeyBase64 } from '../app-render/encryption-utils-server';\nimport { isAppPageRouteDefinition } from '../route-definitions/app-page-route-definition';\nimport { normalizeAppPath } from '../../shared/lib/router/utils/app-paths';\nimport { getNodeDebugType } from '../lib/utils';\nimport { isMetadataRouteFile } from '../../lib/metadata/is-metadata-route';\nimport { setBundlerFindSourceMapImplementation } from '../patch-error-inspect';\nimport { getNextErrorFeedbackMiddleware } from '../../client/components/react-dev-overlay/server/get-next-error-feedback-middleware';\nimport { formatIssue, getTurbopackJsConfig, isPersistentCachingEnabled, isWellKnownError, processIssues, renderStyledStringToErrorAnsi } from '../../shared/lib/turbopack/utils';\nimport { getDevOverlayFontMiddleware } from '../../client/components/react-dev-overlay/font/get-dev-overlay-font-middleware';\nimport { devIndicatorServerState } from './dev-indicator-server-state';\nimport { getDisableDevIndicatorMiddleware } from './dev-indicator-middleware';\n// import { getSupportedBrowsers } from '../../build/utils'\nconst wsServer = new ws.Server({\n    noServer: true\n});\nconst isTestMode = !!(process.env.NEXT_TEST_MODE || process.env.__NEXT_TEST_MODE || process.env.DEBUG);\nconst sessionId = Math.floor(Number.MAX_SAFE_INTEGER * Math.random());\n/**\n * Replaces turbopack:///[project] with the specified project in the `source` field.\n */ function rewriteTurbopackSources(projectRoot, sourceMap) {\n    if ('sections' in sourceMap) {\n        for (const section of sourceMap.sections){\n            rewriteTurbopackSources(projectRoot, section.map);\n        }\n    } else {\n        for(let i = 0; i < sourceMap.sources.length; i++){\n            sourceMap.sources[i] = pathToFileURL(join(projectRoot, sourceMap.sources[i].replace(/turbopack:\\/\\/\\/\\[project\\]/, ''))).toString();\n        }\n    }\n}\nfunction getSourceMapFromTurbopack(project, projectRoot, sourceURL) {\n    let sourceMapJson = null;\n    try {\n        sourceMapJson = project.getSourceMapSync(sourceURL);\n    } catch (err) {}\n    if (sourceMapJson === null) {\n        return undefined;\n    } else {\n        const payload = JSON.parse(sourceMapJson);\n        // The sourcemap from Turbopack is not yet written to disk so its `sources`\n        // are not absolute paths yet. We need to rewrite them to be absolute paths.\n        rewriteTurbopackSources(projectRoot, payload);\n        return payload;\n    }\n}\nexport async function createHotReloaderTurbopack(opts, serverFields, distDir, resetFetch) {\n    var _opts_nextConfig_turbopack, _nextConfig_watchOptions, _opts_nextConfig_experimental;\n    const dev = true;\n    const buildId = 'development';\n    const { nextConfig, dir: projectPath } = opts;\n    const { loadBindings } = require('../../build/swc');\n    let bindings = await loadBindings();\n    // For the debugging purpose, check if createNext or equivalent next instance setup in test cases\n    // works correctly. Normally `run-test` hides output so only will be visible when `--debug` flag is used.\n    if (isTestMode) {\n        require('console').log('Creating turbopack project', {\n            dir: projectPath,\n            testMode: isTestMode\n        });\n    }\n    const hasRewrites = opts.fsChecker.rewrites.afterFiles.length > 0 || opts.fsChecker.rewrites.beforeFiles.length > 0 || opts.fsChecker.rewrites.fallback.length > 0;\n    const hotReloaderSpan = trace('hot-reloader', undefined, {\n        version: \"15.3.1\"\n    });\n    // Ensure the hotReloaderSpan is flushed immediately as it's the parentSpan for all processing\n    // of the current `next dev` invocation.\n    hotReloaderSpan.stop();\n    const encryptionKey = await generateEncryptionKeyBase64({\n        isBuild: false,\n        distDir\n    });\n    // TODO: Implement\n    let clientRouterFilters;\n    if (nextConfig.experimental.clientRouterFilter) {\n    // TODO this need to be set correctly for persistent caching to work\n    }\n    // const supportedBrowsers = await getSupportedBrowsers(dir, dev)\n    const supportedBrowsers = [\n        'last 1 Chrome versions, last 1 Firefox versions, last 1 Safari versions, last 1 Edge versions'\n    ];\n    const project = await bindings.turbo.createProject({\n        projectPath: projectPath,\n        rootPath: ((_opts_nextConfig_turbopack = opts.nextConfig.turbopack) == null ? void 0 : _opts_nextConfig_turbopack.root) || opts.nextConfig.outputFileTracingRoot || projectPath,\n        distDir,\n        nextConfig: opts.nextConfig,\n        jsConfig: await getTurbopackJsConfig(projectPath, nextConfig),\n        watch: {\n            enable: dev,\n            pollIntervalMs: (_nextConfig_watchOptions = nextConfig.watchOptions) == null ? void 0 : _nextConfig_watchOptions.pollIntervalMs\n        },\n        dev,\n        env: process.env,\n        defineEnv: createDefineEnv({\n            isTurbopack: true,\n            clientRouterFilters,\n            config: nextConfig,\n            dev,\n            distDir,\n            fetchCacheKeyPrefix: opts.nextConfig.experimental.fetchCacheKeyPrefix,\n            hasRewrites,\n            // TODO: Implement\n            middlewareMatchers: undefined\n        }),\n        buildId,\n        encryptionKey,\n        previewProps: opts.fsChecker.prerenderManifest.preview,\n        browserslistQuery: supportedBrowsers.join(', '),\n        noMangling: false\n    }, {\n        persistentCaching: isPersistentCachingEnabled(opts.nextConfig),\n        memoryLimit: (_opts_nextConfig_experimental = opts.nextConfig.experimental) == null ? void 0 : _opts_nextConfig_experimental.turbopackMemoryLimit\n    });\n    setBundlerFindSourceMapImplementation(getSourceMapFromTurbopack.bind(null, project, projectPath));\n    opts.onDevServerCleanup == null ? void 0 : opts.onDevServerCleanup.call(opts, async ()=>{\n        setBundlerFindSourceMapImplementation(()=>undefined);\n        await project.onExit();\n    });\n    const entrypointsSubscription = project.entrypointsSubscribe();\n    const currentWrittenEntrypoints = new Map();\n    const currentEntrypoints = {\n        global: {\n            app: undefined,\n            document: undefined,\n            error: undefined,\n            middleware: undefined,\n            instrumentation: undefined\n        },\n        page: new Map(),\n        app: new Map()\n    };\n    const currentTopLevelIssues = new Map();\n    const currentEntryIssues = new Map();\n    const manifestLoader = new TurbopackManifestLoader({\n        buildId,\n        distDir,\n        encryptionKey\n    });\n    // Dev specific\n    const changeSubscriptions = new Map();\n    const serverPathState = new Map();\n    const readyIds = new Set();\n    let currentEntriesHandlingResolve;\n    let currentEntriesHandling = new Promise((resolve)=>currentEntriesHandlingResolve = resolve);\n    const assetMapper = new AssetMapper();\n    function clearRequireCache(key, writtenEndpoint, { force } = {}) {\n        if (force) {\n            for (const { path, contentHash } of writtenEndpoint.serverPaths){\n                serverPathState.set(path, contentHash);\n            }\n        } else {\n            // Figure out if the server files have changed\n            let hasChange = false;\n            for (const { path, contentHash } of writtenEndpoint.serverPaths){\n                // We ignore source maps\n                if (path.endsWith('.map')) continue;\n                const localKey = `${key}:${path}`;\n                const localHash = serverPathState.get(localKey);\n                const globalHash = serverPathState.get(path);\n                if (localHash && localHash !== contentHash || globalHash && globalHash !== contentHash) {\n                    hasChange = true;\n                    serverPathState.set(key, contentHash);\n                    serverPathState.set(path, contentHash);\n                } else {\n                    if (!localHash) {\n                        serverPathState.set(key, contentHash);\n                    }\n                    if (!globalHash) {\n                        serverPathState.set(path, contentHash);\n                    }\n                }\n            }\n            if (!hasChange) {\n                return false;\n            }\n        }\n        resetFetch();\n        const hasAppPaths = writtenEndpoint.serverPaths.some(({ path: p })=>p.startsWith('server/app'));\n        if (hasAppPaths) {\n            deleteFromRequireCache(require.resolve('next/dist/compiled/next-server/app-page-turbo.runtime.dev.js'));\n            deleteFromRequireCache(require.resolve('next/dist/compiled/next-server/app-page-turbo-experimental.runtime.dev.js'));\n        }\n        const serverPaths = writtenEndpoint.serverPaths.map(({ path: p })=>join(distDir, p));\n        for (const file of serverPaths){\n            clearModuleContext(file);\n            deleteCache(file);\n        }\n        return true;\n    }\n    const buildingIds = new Set();\n    const startBuilding = (id, requestUrl, forceRebuild)=>{\n        if (!forceRebuild && readyIds.has(id)) {\n            return ()=>{};\n        }\n        if (buildingIds.size === 0) {\n            consoleStore.setState({\n                loading: true,\n                trigger: id,\n                url: requestUrl\n            }, true);\n        }\n        buildingIds.add(id);\n        return function finishBuilding() {\n            if (buildingIds.size === 0) {\n                return;\n            }\n            readyIds.add(id);\n            buildingIds.delete(id);\n            if (buildingIds.size === 0) {\n                hmrEventHappened = false;\n                consoleStore.setState({\n                    loading: false\n                }, true);\n            }\n        };\n    };\n    let hmrEventHappened = false;\n    let hmrHash = 0;\n    const clients = new Set();\n    const clientStates = new WeakMap();\n    function sendToClient(client, payload) {\n        client.send(JSON.stringify(payload));\n    }\n    function sendEnqueuedMessages() {\n        for (const [, issueMap] of currentEntryIssues){\n            if ([\n                ...issueMap.values()\n            ].filter((i)=>i.severity !== 'warning').length > 0) {\n                // During compilation errors we want to delay the HMR events until errors are fixed\n                return;\n            }\n        }\n        for (const client of clients){\n            const state = clientStates.get(client);\n            if (!state) {\n                continue;\n            }\n            for (const [, issueMap] of state.clientIssues){\n                if ([\n                    ...issueMap.values()\n                ].filter((i)=>i.severity !== 'warning').length > 0) {\n                    // During compilation errors we want to delay the HMR events until errors are fixed\n                    return;\n                }\n            }\n            for (const payload of state.hmrPayloads.values()){\n                sendToClient(client, payload);\n            }\n            state.hmrPayloads.clear();\n            if (state.turbopackUpdates.length > 0) {\n                sendToClient(client, {\n                    action: HMR_ACTIONS_SENT_TO_BROWSER.TURBOPACK_MESSAGE,\n                    data: state.turbopackUpdates\n                });\n                state.turbopackUpdates.length = 0;\n            }\n        }\n    }\n    const sendEnqueuedMessagesDebounce = debounce(sendEnqueuedMessages, 2);\n    const sendHmr = (id, payload)=>{\n        for (const client of clients){\n            var _clientStates_get;\n            (_clientStates_get = clientStates.get(client)) == null ? void 0 : _clientStates_get.hmrPayloads.set(id, payload);\n        }\n        hmrEventHappened = true;\n        sendEnqueuedMessagesDebounce();\n    };\n    function sendTurbopackMessage(payload) {\n        // TODO(PACK-2049): For some reason we end up emitting hundreds of issues messages on bigger apps,\n        //   a lot of which are duplicates.\n        //   They are currently not handled on the client at all, so might as well not send them for now.\n        payload.diagnostics = [];\n        payload.issues = [];\n        for (const client of clients){\n            var _clientStates_get;\n            (_clientStates_get = clientStates.get(client)) == null ? void 0 : _clientStates_get.turbopackUpdates.push(payload);\n        }\n        hmrEventHappened = true;\n        sendEnqueuedMessagesDebounce();\n    }\n    async function subscribeToChanges(key, includeIssues, endpoint, makePayload, onError) {\n        if (changeSubscriptions.has(key)) {\n            return;\n        }\n        const { side } = splitEntryKey(key);\n        const changedPromise = endpoint[`${side}Changed`](includeIssues);\n        changeSubscriptions.set(key, changedPromise);\n        try {\n            const changed = await changedPromise;\n            for await (const change of changed){\n                processIssues(currentEntryIssues, key, change, false, true);\n                // TODO: Get an actual content hash from Turbopack.\n                const payload = await makePayload(change, String(++hmrHash));\n                if (payload) {\n                    sendHmr(key, payload);\n                }\n            }\n        } catch (e) {\n            changeSubscriptions.delete(key);\n            const payload = await (onError == null ? void 0 : onError(e));\n            if (payload) {\n                sendHmr(key, payload);\n            }\n            return;\n        }\n        changeSubscriptions.delete(key);\n    }\n    async function unsubscribeFromChanges(key) {\n        const subscription = await changeSubscriptions.get(key);\n        if (subscription) {\n            await (subscription.return == null ? void 0 : subscription.return.call(subscription));\n            changeSubscriptions.delete(key);\n        }\n        currentEntryIssues.delete(key);\n    }\n    async function subscribeToHmrEvents(client, id) {\n        const key = getEntryKey('assets', 'client', id);\n        if (!hasEntrypointForKey(currentEntrypoints, key, assetMapper)) {\n            // maybe throw an error / force the client to reload?\n            return;\n        }\n        const state = clientStates.get(client);\n        if (!state || state.subscriptions.has(id)) {\n            return;\n        }\n        const subscription = project.hmrEvents(id);\n        state.subscriptions.set(id, subscription);\n        // The subscription will always emit once, which is the initial\n        // computation. This is not a change, so swallow it.\n        try {\n            await subscription.next();\n            for await (const data of subscription){\n                processIssues(state.clientIssues, key, data, false, true);\n                if (data.type !== 'issues') {\n                    sendTurbopackMessage(data);\n                }\n            }\n        } catch (e) {\n            // The client might be using an HMR session from a previous server, tell them\n            // to fully reload the page to resolve the issue. We can't use\n            // `hotReloader.send` since that would force every connected client to\n            // reload, only this client is out of date.\n            const reloadAction = {\n                action: HMR_ACTIONS_SENT_TO_BROWSER.RELOAD_PAGE,\n                data: `error in HMR event subscription for ${id}: ${e}`\n            };\n            sendToClient(client, reloadAction);\n            client.close();\n            return;\n        }\n    }\n    function unsubscribeFromHmrEvents(client, id) {\n        const state = clientStates.get(client);\n        if (!state) {\n            return;\n        }\n        const subscription = state.subscriptions.get(id);\n        subscription == null ? void 0 : subscription.return();\n        const key = getEntryKey('assets', 'client', id);\n        state.clientIssues.delete(key);\n    }\n    async function handleEntrypointsSubscription() {\n        for await (const entrypoints of entrypointsSubscription){\n            if (!currentEntriesHandlingResolve) {\n                currentEntriesHandling = new Promise(// eslint-disable-next-line no-loop-func\n                (resolve)=>currentEntriesHandlingResolve = resolve);\n            }\n            processTopLevelIssues(currentTopLevelIssues, entrypoints);\n            await handleEntrypoints({\n                entrypoints,\n                currentEntrypoints,\n                currentEntryIssues,\n                manifestLoader,\n                devRewrites: opts.fsChecker.rewrites,\n                productionRewrites: undefined,\n                logErrors: true,\n                dev: {\n                    assetMapper,\n                    changeSubscriptions,\n                    clients,\n                    clientStates,\n                    serverFields,\n                    hooks: {\n                        handleWrittenEndpoint: (id, result, forceDeleteCache)=>{\n                            currentWrittenEntrypoints.set(id, result);\n                            return clearRequireCache(id, result, {\n                                force: forceDeleteCache\n                            });\n                        },\n                        propagateServerField: propagateServerField.bind(null, opts),\n                        sendHmr,\n                        startBuilding,\n                        subscribeToChanges,\n                        unsubscribeFromChanges,\n                        unsubscribeFromHmrEvents\n                    }\n                }\n            });\n            currentEntriesHandlingResolve();\n            currentEntriesHandlingResolve = undefined;\n        }\n    }\n    await mkdir(join(distDir, 'server'), {\n        recursive: true\n    });\n    await mkdir(join(distDir, 'static', buildId), {\n        recursive: true\n    });\n    await writeFile(join(distDir, 'package.json'), JSON.stringify({\n        type: 'commonjs'\n    }, null, 2));\n    const middlewares = [\n        getOverlayMiddleware(project, projectPath),\n        getSourceMapMiddleware(project),\n        getNextErrorFeedbackMiddleware(opts.telemetry),\n        getDevOverlayFontMiddleware(),\n        getDisableDevIndicatorMiddleware()\n    ];\n    const versionInfoPromise = getVersionInfo();\n    let devtoolsFrontendUrl;\n    const nodeDebugType = getNodeDebugType();\n    if (nodeDebugType) {\n        const debugPort = process.debugPort;\n        let debugInfo;\n        try {\n            // It requires to use 127.0.0.1 instead of localhost for server-side fetching.\n            const debugInfoList = await fetch(`http://127.0.0.1:${debugPort}/json/list`).then((res)=>res.json());\n            debugInfo = debugInfoList[0];\n        } catch  {}\n        if (debugInfo) {\n            devtoolsFrontendUrl = debugInfo.devtoolsFrontendUrl;\n        }\n    }\n    const hotReloader = {\n        turbopackProject: project,\n        activeWebpackConfigs: undefined,\n        serverStats: null,\n        edgeServerStats: null,\n        async run (req, res, _parsedUrl) {\n            var _req_url;\n            // intercept page chunks request and ensure them with turbopack\n            if ((_req_url = req.url) == null ? void 0 : _req_url.startsWith('/_next/static/chunks/pages/')) {\n                const params = matchNextPageBundleRequest(req.url);\n                if (params) {\n                    const decodedPagePath = `/${params.path.map((param)=>decodeURIComponent(param)).join('/')}`;\n                    const denormalizedPagePath = denormalizePagePath(decodedPagePath);\n                    await hotReloader.ensurePage({\n                        page: denormalizedPagePath,\n                        clientOnly: false,\n                        definition: undefined,\n                        url: req.url\n                    }).catch(console.error);\n                }\n            }\n            for (const middleware of middlewares){\n                let calledNext = false;\n                await middleware(req, res, ()=>{\n                    calledNext = true;\n                });\n                if (!calledNext) {\n                    return {\n                        finished: true\n                    };\n                }\n            }\n            // Request was not finished.\n            return {\n                finished: undefined\n            };\n        },\n        // TODO: Figure out if socket type can match the NextJsHotReloaderInterface\n        onHMR (req, socket, head, onUpgrade) {\n            wsServer.handleUpgrade(req, socket, head, (client)=>{\n                onUpgrade(client);\n                const clientIssues = new Map();\n                const subscriptions = new Map();\n                clients.add(client);\n                clientStates.set(client, {\n                    clientIssues,\n                    hmrPayloads: new Map(),\n                    turbopackUpdates: [],\n                    subscriptions\n                });\n                client.on('close', ()=>{\n                    // Remove active subscriptions\n                    for (const subscription of subscriptions.values()){\n                        subscription.return == null ? void 0 : subscription.return.call(subscription);\n                    }\n                    clientStates.delete(client);\n                    clients.delete(client);\n                });\n                client.addEventListener('message', ({ data })=>{\n                    const parsedData = JSON.parse(typeof data !== 'string' ? data.toString() : data);\n                    // Next.js messages\n                    switch(parsedData.event){\n                        case 'span-end':\n                            {\n                                hotReloaderSpan.manualTraceChild(parsedData.spanName, msToNs(parsedData.startTime), msToNs(parsedData.endTime), parsedData.attributes);\n                                break;\n                            }\n                        case 'client-hmr-latency':\n                            hotReloaderSpan.manualTraceChild(parsedData.event, msToNs(parsedData.startTime), msToNs(parsedData.endTime), {\n                                updatedModules: parsedData.updatedModules,\n                                page: parsedData.page,\n                                isPageHidden: parsedData.isPageHidden\n                            });\n                            break;\n                        case 'client-error':\n                        case 'client-warning':\n                        case 'client-success':\n                        case 'server-component-reload-page':\n                        case 'client-reload-page':\n                        case 'client-removed-page':\n                        case 'client-full-reload':\n                            const { hadRuntimeError, dependencyChain } = parsedData;\n                            if (hadRuntimeError) {\n                                Log.warn(FAST_REFRESH_RUNTIME_RELOAD);\n                            }\n                            if (Array.isArray(dependencyChain) && typeof dependencyChain[0] === 'string') {\n                                const cleanedModulePath = dependencyChain[0].replace(/^\\[project\\]/, '.').replace(/ \\[.*\\] \\(.*\\)$/, '');\n                                Log.warn(`Fast Refresh had to perform a full reload when ${cleanedModulePath} changed. Read more: https://nextjs.org/docs/messages/fast-refresh-reload`);\n                            }\n                            break;\n                        case 'client-added-page':\n                            break;\n                        default:\n                            // Might be a Turbopack message...\n                            if (!parsedData.type) {\n                                throw Object.defineProperty(new Error(`unrecognized HMR message \"${data}\"`), \"__NEXT_ERROR_CODE\", {\n                                    value: \"E155\",\n                                    enumerable: false,\n                                    configurable: true\n                                });\n                            }\n                    }\n                    // Turbopack messages\n                    switch(parsedData.type){\n                        case 'turbopack-subscribe':\n                            subscribeToHmrEvents(client, parsedData.path);\n                            break;\n                        case 'turbopack-unsubscribe':\n                            unsubscribeFromHmrEvents(client, parsedData.path);\n                            break;\n                        default:\n                            if (!parsedData.event) {\n                                throw Object.defineProperty(new Error(`unrecognized Turbopack HMR message \"${data}\"`), \"__NEXT_ERROR_CODE\", {\n                                    value: \"E492\",\n                                    enumerable: false,\n                                    configurable: true\n                                });\n                            }\n                    }\n                });\n                const turbopackConnected = {\n                    action: HMR_ACTIONS_SENT_TO_BROWSER.TURBOPACK_CONNECTED,\n                    data: {\n                        sessionId\n                    }\n                };\n                sendToClient(client, turbopackConnected);\n                const errors = [];\n                for (const entryIssues of currentEntryIssues.values()){\n                    for (const issue of entryIssues.values()){\n                        if (issue.severity !== 'warning') {\n                            errors.push({\n                                message: formatIssue(issue)\n                            });\n                        } else {\n                            printNonFatalIssue(issue);\n                        }\n                    }\n                }\n                if (devIndicatorServerState.disabledUntil < Date.now()) {\n                    devIndicatorServerState.disabledUntil = 0;\n                }\n                ;\n                (async function() {\n                    const versionInfo = await versionInfoPromise;\n                    const sync = {\n                        action: HMR_ACTIONS_SENT_TO_BROWSER.SYNC,\n                        errors,\n                        warnings: [],\n                        hash: '',\n                        versionInfo,\n                        debug: {\n                            devtoolsFrontendUrl\n                        },\n                        devIndicator: devIndicatorServerState\n                    };\n                    sendToClient(client, sync);\n                })();\n            });\n        },\n        send (action) {\n            const payload = JSON.stringify(action);\n            for (const client of clients){\n                client.send(payload);\n            }\n        },\n        setHmrServerError (_error) {\n        // Not implemented yet.\n        },\n        clearHmrServerError () {\n        // Not implemented yet.\n        },\n        async start () {},\n        async getCompilationErrors (page) {\n            const appEntryKey = getEntryKey('app', 'server', page);\n            const pagesEntryKey = getEntryKey('pages', 'server', page);\n            const topLevelIssues = currentTopLevelIssues.values();\n            const thisEntryIssues = currentEntryIssues.get(appEntryKey) ?? currentEntryIssues.get(pagesEntryKey);\n            if (thisEntryIssues !== undefined && thisEntryIssues.size > 0) {\n                // If there is an error related to the requesting page we display it instead of the first error\n                return [\n                    ...topLevelIssues,\n                    ...thisEntryIssues.values()\n                ].map((issue)=>{\n                    const formattedIssue = formatIssue(issue);\n                    if (issue.severity === 'warning') {\n                        printNonFatalIssue(issue);\n                        return null;\n                    } else if (isWellKnownError(issue)) {\n                        Log.error(formattedIssue);\n                    }\n                    return Object.defineProperty(new Error(formattedIssue), \"__NEXT_ERROR_CODE\", {\n                        value: \"E394\",\n                        enumerable: false,\n                        configurable: true\n                    });\n                }).filter((error)=>error !== null);\n            }\n            // Otherwise, return all errors across pages\n            const errors = [];\n            for (const issue of topLevelIssues){\n                if (issue.severity !== 'warning') {\n                    errors.push(Object.defineProperty(new Error(formatIssue(issue)), \"__NEXT_ERROR_CODE\", {\n                        value: \"E394\",\n                        enumerable: false,\n                        configurable: true\n                    }));\n                }\n            }\n            for (const entryIssues of currentEntryIssues.values()){\n                for (const issue of entryIssues.values()){\n                    if (issue.severity !== 'warning') {\n                        const message = formatIssue(issue);\n                        errors.push(Object.defineProperty(new Error(message), \"__NEXT_ERROR_CODE\", {\n                            value: \"E394\",\n                            enumerable: false,\n                            configurable: true\n                        }));\n                    } else {\n                        printNonFatalIssue(issue);\n                    }\n                }\n            }\n            return errors;\n        },\n        async invalidate ({ // .env files or tsconfig/jsconfig change\n        reloadAfterInvalidation }) {\n            if (reloadAfterInvalidation) {\n                for (const [key, entrypoint] of currentWrittenEntrypoints){\n                    clearRequireCache(key, entrypoint, {\n                        force: true\n                    });\n                }\n                await clearAllModuleContexts();\n                this.send({\n                    action: HMR_ACTIONS_SENT_TO_BROWSER.SERVER_COMPONENT_CHANGES,\n                    hash: String(++hmrHash)\n                });\n            }\n        },\n        async buildFallbackError () {\n        // Not implemented yet.\n        },\n        async ensurePage ({ page: inputPage, // Unused parameters\n        // clientOnly,\n        appPaths, definition, isApp, url: requestUrl }) {\n            // When there is no route definition this is an internal file not a route the user added.\n            // Middleware and instrumentation are handled in turbpack-utils.ts handleEntrypoints instead.\n            if (!definition) {\n                if (inputPage === '/middleware') return;\n                if (inputPage === '/src/middleware') return;\n                if (inputPage === '/instrumentation') return;\n                if (inputPage === '/src/instrumentation') return;\n            }\n            return hotReloaderSpan.traceChild('ensure-page', {\n                inputPage\n            }).traceAsyncFn(async ()=>{\n                if (BLOCKED_PAGES.includes(inputPage) && inputPage !== '/_error') {\n                    return;\n                }\n                await currentEntriesHandling;\n                // TODO We shouldn't look into the filesystem again. This should use the information from entrypoints\n                let routeDef = definition ?? await findPagePathData(projectPath, inputPage, nextConfig.pageExtensions, opts.pagesDir, opts.appDir);\n                // If the route is actually an app page route, then we should have access\n                // to the app route definition, and therefore, the appPaths from it.\n                if (!appPaths && definition && isAppPageRouteDefinition(definition)) {\n                    appPaths = definition.appPaths;\n                }\n                let page = routeDef.page;\n                if (appPaths) {\n                    const normalizedPage = normalizeAppPath(page);\n                    // filter out paths that are not exact matches (e.g. catchall)\n                    const matchingAppPaths = appPaths.filter((path)=>normalizeAppPath(path) === normalizedPage);\n                    // the last item in the array is the root page, if there are parallel routes\n                    page = matchingAppPaths[matchingAppPaths.length - 1];\n                }\n                const pathname = (definition == null ? void 0 : definition.pathname) ?? inputPage;\n                if (page === '/_error') {\n                    let finishBuilding = startBuilding(pathname, requestUrl, false);\n                    try {\n                        await handlePagesErrorRoute({\n                            currentEntryIssues,\n                            entrypoints: currentEntrypoints,\n                            manifestLoader,\n                            devRewrites: opts.fsChecker.rewrites,\n                            productionRewrites: undefined,\n                            logErrors: true,\n                            hooks: {\n                                subscribeToChanges,\n                                handleWrittenEndpoint: (id, result, forceDeleteCache)=>{\n                                    currentWrittenEntrypoints.set(id, result);\n                                    assetMapper.setPathsForKey(id, result.clientPaths);\n                                    return clearRequireCache(id, result, {\n                                        force: forceDeleteCache\n                                    });\n                                }\n                            }\n                        });\n                    } finally{\n                        finishBuilding();\n                    }\n                    return;\n                }\n                const isInsideAppDir = routeDef.bundlePath.startsWith('app/');\n                const isEntryMetadataRouteFile = isMetadataRouteFile(routeDef.filename.replace(opts.appDir || '', ''), nextConfig.pageExtensions, true);\n                const normalizedAppPage = isEntryMetadataRouteFile ? normalizedPageToTurbopackStructureRoute(page, extname(routeDef.filename)) : page;\n                const route = isInsideAppDir ? currentEntrypoints.app.get(normalizedAppPage) : currentEntrypoints.page.get(page);\n                if (!route) {\n                    // TODO: why is this entry missing in turbopack?\n                    if (page === '/middleware') return;\n                    if (page === '/src/middleware') return;\n                    if (page === '/instrumentation') return;\n                    if (page === '/src/instrumentation') return;\n                    throw new PageNotFoundError(`route not found ${page}`);\n                }\n                // We don't throw on ensureOpts.isApp === true for page-api\n                // since this can happen when app pages make\n                // api requests to page API routes.\n                if (isApp && route.type === 'page') {\n                    throw Object.defineProperty(new Error(`mis-matched route type: isApp && page for ${page}`), \"__NEXT_ERROR_CODE\", {\n                        value: \"E373\",\n                        enumerable: false,\n                        configurable: true\n                    });\n                }\n                const finishBuilding = startBuilding(pathname, requestUrl, false);\n                try {\n                    await handleRouteType({\n                        dev,\n                        page,\n                        pathname,\n                        route,\n                        currentEntryIssues,\n                        entrypoints: currentEntrypoints,\n                        manifestLoader,\n                        readyIds,\n                        devRewrites: opts.fsChecker.rewrites,\n                        productionRewrites: undefined,\n                        logErrors: true,\n                        hooks: {\n                            subscribeToChanges,\n                            handleWrittenEndpoint: (id, result, forceDeleteCache)=>{\n                                currentWrittenEntrypoints.set(id, result);\n                                assetMapper.setPathsForKey(id, result.clientPaths);\n                                return clearRequireCache(id, result, {\n                                    force: forceDeleteCache\n                                });\n                            }\n                        }\n                    });\n                } finally{\n                    finishBuilding();\n                }\n            });\n        },\n        close () {\n            for (const wsClient of clients){\n                // it's okay to not cleanly close these websocket connections, this is dev\n                wsClient.terminate();\n            }\n            clients.clear();\n        }\n    };\n    handleEntrypointsSubscription().catch((err)=>{\n        console.error(err);\n        process.exit(1);\n    });\n    // Write empty manifests\n    await currentEntriesHandling;\n    await manifestLoader.writeManifests({\n        devRewrites: opts.fsChecker.rewrites,\n        productionRewrites: undefined,\n        entrypoints: currentEntrypoints\n    });\n    async function handleProjectUpdates() {\n        for await (const updateMessage of project.updateInfoSubscribe(30)){\n            switch(updateMessage.updateType){\n                case 'start':\n                    {\n                        hotReloader.send({\n                            action: HMR_ACTIONS_SENT_TO_BROWSER.BUILDING\n                        });\n                        break;\n                    }\n                case 'end':\n                    {\n                        sendEnqueuedMessages();\n                        function addErrors(errorsMap, issues) {\n                            for (const issueMap of issues.values()){\n                                for (const [key, issue] of issueMap){\n                                    if (issue.severity === 'warning') continue;\n                                    if (errorsMap.has(key)) continue;\n                                    const message = formatIssue(issue);\n                                    errorsMap.set(key, {\n                                        message,\n                                        details: issue.detail ? renderStyledStringToErrorAnsi(issue.detail) : undefined\n                                    });\n                                }\n                            }\n                        }\n                        const errors = new Map();\n                        addErrors(errors, currentEntryIssues);\n                        for (const client of clients){\n                            const state = clientStates.get(client);\n                            if (!state) {\n                                continue;\n                            }\n                            const clientErrors = new Map(errors);\n                            addErrors(clientErrors, state.clientIssues);\n                            sendToClient(client, {\n                                action: HMR_ACTIONS_SENT_TO_BROWSER.BUILT,\n                                hash: String(++hmrHash),\n                                errors: [\n                                    ...clientErrors.values()\n                                ],\n                                warnings: []\n                            });\n                        }\n                        if (hmrEventHappened) {\n                            const time = updateMessage.value.duration;\n                            const timeMessage = time > 2000 ? `${Math.round(time / 100) / 10}s` : `${time}ms`;\n                            Log.event(`Compiled in ${timeMessage}`);\n                            hmrEventHappened = false;\n                        }\n                        break;\n                    }\n                default:\n            }\n        }\n    }\n    handleProjectUpdates().catch((err)=>{\n        console.error(err);\n        process.exit(1);\n    });\n    return hotReloader;\n}\n\n//# sourceMappingURL=hot-reloader-turbopack.js.map"
        }
    ]
}