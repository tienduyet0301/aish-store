{
    "sourceFile": "node_modules/next/dist/esm/server/route-matcher-providers/dev/helpers/file-reader/batched-file-reader.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892839782,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * CachedFileReader will deduplicate requests made to the same folder structure\n * to scan for files.\n */ export class BatchedFileReader {\n    constructor(reader){\n        this.reader = reader;\n    }\n    schedule(callback) {\n        if (!this.schedulePromise) {\n            this.schedulePromise = Promise.resolve();\n        }\n        this.schedulePromise.then(()=>{\n            process.nextTick(callback);\n        });\n    }\n    getOrCreateBatch() {\n        // If there is an existing batch and it's not completed, then reuse it.\n        if (this.batch && !this.batch.completed) {\n            return this.batch;\n        }\n        const batch = {\n            completed: false,\n            directories: [],\n            callbacks: []\n        };\n        this.batch = batch;\n        this.schedule(async ()=>{\n            batch.completed = true;\n            if (batch.directories.length === 0) return;\n            // Collect all the results for each of the directories. If any error\n            // occurs, send the results back to the loaders.\n            let values;\n            try {\n                values = await this.load(batch.directories);\n            } catch (err) {\n                // Reject all the callbacks.\n                for (const { reject } of batch.callbacks){\n                    reject(err);\n                }\n                return;\n            }\n            // Loop over all the callbacks and send them their results.\n            for(let i = 0; i < batch.callbacks.length; i++){\n                const value = values[i];\n                if (value instanceof Error) {\n                    batch.callbacks[i].reject(value);\n                } else {\n                    batch.callbacks[i].resolve(value);\n                }\n            }\n        });\n        return batch;\n    }\n    async load(directories) {\n        // Make a unique array of directories. This is what lets us de-duplicate\n        // loads for the same directory.\n        const unique = [\n            ...new Set(directories)\n        ];\n        const results = await Promise.all(unique.map(async (directory)=>{\n            let files;\n            let error;\n            try {\n                files = await this.reader.read(directory);\n            } catch (err) {\n                if (err instanceof Error) error = err;\n            }\n            return {\n                directory,\n                files,\n                error\n            };\n        }));\n        return directories.map((directory)=>{\n            const found = results.find((result)=>result.directory === directory);\n            if (!found) return [];\n            if (found.files) return found.files;\n            if (found.error) return found.error;\n            return [];\n        });\n    }\n    async read(dir) {\n        // Get or create a new file reading batch.\n        const batch = this.getOrCreateBatch();\n        // Push this directory into the batch to resolve.\n        batch.directories.push(dir);\n        // Push the promise handles into the batch (under the same index) so it can\n        // be resolved later when it's scheduled.\n        const promise = new Promise((resolve, reject)=>{\n            batch.callbacks.push({\n                resolve,\n                reject\n            });\n        });\n        return promise;\n    }\n}\n\n//# sourceMappingURL=batched-file-reader.js.map"
        }
    ]
}