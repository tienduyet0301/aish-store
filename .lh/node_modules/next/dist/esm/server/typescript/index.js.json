{
    "sourceFile": "node_modules/next/dist/esm/server/typescript/index.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892845193,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * This is a TypeScript language service plugin for Next.js app directory,\n * it provides the following features:\n *\n * - Warns about disallowed React APIs in server components.\n * - Warns about disallowed layout and page exports.\n * - Autocompletion for entry configurations.\n * - Hover hint and docs for entry configurations.\n */ import { init, getEntryInfo, isAppEntryFile, isDefaultFunctionExport, isPositionInsideNode, getSource, isInsideApp } from './utils';\nimport { NEXT_TS_ERRORS } from './constant';\nimport entryConfig from './rules/config';\nimport serverLayer from './rules/server';\nimport entryDefault from './rules/entry';\nimport clientBoundary from './rules/client-boundary';\nimport serverBoundary from './rules/server-boundary';\nimport metadata from './rules/metadata';\nimport errorEntry from './rules/error';\nexport const createTSPlugin = ({ typescript: ts })=>{\n    function create(info) {\n        // Get plugin options\n        // config is the plugin options from the user's tsconfig.json\n        // e.g. { \"plugins\": [{ \"name\": \"next\", \"enabled\": true }] }\n        // config will be { \"name\": \"next\", \"enabled\": true }\n        // The default user config is { \"name\": \"next\" }\n        const isPluginEnabled = info.config.enabled ?? true;\n        const isPluginInitialized = init({\n            ts,\n            info\n        });\n        if (!isPluginEnabled || !isPluginInitialized) {\n            return info.languageService;\n        }\n        // Set up decorator object\n        const proxy = Object.create(null);\n        for (let k of Object.keys(info.languageService)){\n            const x = info.languageService[k];\n            // @ts-expect-error - JS runtime trickery which is tricky to type tersely\n            proxy[k] = (...args)=>x.apply(info.languageService, args);\n        }\n        // Auto completion\n        proxy.getCompletionsAtPosition = (fileName, position, options)=>{\n            let prior = info.languageService.getCompletionsAtPosition(fileName, position, options) || {\n                isGlobalCompletion: false,\n                isMemberCompletion: false,\n                isNewIdentifierLocation: false,\n                entries: []\n            };\n            if (!isAppEntryFile(fileName)) return prior;\n            // If it's a server entry.\n            const entryInfo = getEntryInfo(fileName);\n            if (!entryInfo.client) {\n                // Remove specified entries from completion list\n                prior.entries = serverLayer.filterCompletionsAtPosition(prior.entries);\n                // Provide autocompletion for metadata fields\n                prior = metadata.filterCompletionsAtPosition(fileName, position, options, prior);\n            }\n            // Add auto completions for export configs.\n            entryConfig.addCompletionsAtPosition(fileName, position, prior);\n            const source = getSource(fileName);\n            if (!source) return prior;\n            ts.forEachChild(source, (node)=>{\n                // Auto completion for default export function's props.\n                if (isPositionInsideNode(position, node) && isDefaultFunctionExport(node)) {\n                    prior.entries.push(...entryDefault.getCompletionsAtPosition(fileName, node, position));\n                }\n            });\n            return prior;\n        };\n        // Show auto completion details\n        proxy.getCompletionEntryDetails = (fileName, position, entryName, formatOptions, source, preferences, data)=>{\n            const entryCompletionEntryDetails = entryConfig.getCompletionEntryDetails(entryName, data);\n            if (entryCompletionEntryDetails) return entryCompletionEntryDetails;\n            const metadataCompletionEntryDetails = metadata.getCompletionEntryDetails(fileName, position, entryName, formatOptions, source, preferences, data);\n            if (metadataCompletionEntryDetails) return metadataCompletionEntryDetails;\n            return info.languageService.getCompletionEntryDetails(fileName, position, entryName, formatOptions, source, preferences, data);\n        };\n        // Quick info\n        proxy.getQuickInfoAtPosition = (fileName, position)=>{\n            const prior = info.languageService.getQuickInfoAtPosition(fileName, position);\n            if (!isAppEntryFile(fileName)) return prior;\n            // Remove type suggestions for disallowed APIs in server components.\n            const entryInfo = getEntryInfo(fileName);\n            if (!entryInfo.client) {\n                const definitions = info.languageService.getDefinitionAtPosition(fileName, position);\n                if (definitions && serverLayer.hasDisallowedReactAPIDefinition(definitions)) {\n                    return;\n                }\n                const metadataInfo = metadata.getQuickInfoAtPosition(fileName, position);\n                if (metadataInfo) return metadataInfo;\n            }\n            const overridden = entryConfig.getQuickInfoAtPosition(fileName, position);\n            if (overridden) return overridden;\n            return prior;\n        };\n        // Show errors for disallowed imports\n        proxy.getSemanticDiagnostics = (fileName)=>{\n            const prior = info.languageService.getSemanticDiagnostics(fileName);\n            const source = getSource(fileName);\n            if (!source) return prior;\n            let isClientEntry = false;\n            let isServerEntry = false;\n            const isAppEntry = isAppEntryFile(fileName);\n            try {\n                const entryInfo = getEntryInfo(fileName, true);\n                isClientEntry = entryInfo.client;\n                isServerEntry = entryInfo.server;\n            } catch (e) {\n                prior.push({\n                    file: source,\n                    category: ts.DiagnosticCategory.Error,\n                    code: NEXT_TS_ERRORS.MISPLACED_ENTRY_DIRECTIVE,\n                    ...e\n                });\n                isClientEntry = false;\n                isServerEntry = false;\n            }\n            if (isInsideApp(fileName)) {\n                const errorDiagnostic = errorEntry.getSemanticDiagnostics(source, isClientEntry);\n                prior.push(...errorDiagnostic);\n            }\n            ts.forEachChild(source, (node)=>{\n                var _node_modifiers, _node_modifiers1;\n                if (ts.isImportDeclaration(node)) {\n                    // import ...\n                    if (isAppEntry) {\n                        if (!isClientEntry || isServerEntry) {\n                            // Check if it has valid imports in the server layer\n                            const diagnostics = serverLayer.getSemanticDiagnosticsForImportDeclaration(source, node);\n                            prior.push(...diagnostics);\n                        }\n                    }\n                } else if (ts.isVariableStatement(node) && ((_node_modifiers = node.modifiers) == null ? void 0 : _node_modifiers.some((m)=>m.kind === ts.SyntaxKind.ExportKeyword))) {\n                    // export const ...\n                    if (isAppEntry) {\n                        // Check if it has correct option exports\n                        const diagnostics = entryConfig.getSemanticDiagnosticsForExportVariableStatement(source, node);\n                        const metadataDiagnostics = isClientEntry ? metadata.getSemanticDiagnosticsForExportVariableStatementInClientEntry(fileName, node) : metadata.getSemanticDiagnosticsForExportVariableStatement(fileName, node);\n                        prior.push(...diagnostics, ...metadataDiagnostics);\n                    }\n                    if (isClientEntry) {\n                        prior.push(...clientBoundary.getSemanticDiagnosticsForExportVariableStatement(source, node));\n                    }\n                    if (isServerEntry) {\n                        prior.push(...serverBoundary.getSemanticDiagnosticsForExportVariableStatement(source, node));\n                    }\n                } else if (isDefaultFunctionExport(node)) {\n                    // export default function ...\n                    if (isAppEntry) {\n                        const diagnostics = entryDefault.getSemanticDiagnostics(fileName, source, node);\n                        prior.push(...diagnostics);\n                    }\n                    if (isClientEntry) {\n                        prior.push(...clientBoundary.getSemanticDiagnosticsForFunctionExport(source, node));\n                    }\n                    if (isServerEntry) {\n                        prior.push(...serverBoundary.getSemanticDiagnosticsForFunctionExport(source, node));\n                    }\n                } else if (ts.isFunctionDeclaration(node) && ((_node_modifiers1 = node.modifiers) == null ? void 0 : _node_modifiers1.some((m)=>m.kind === ts.SyntaxKind.ExportKeyword))) {\n                    // export function ...\n                    if (isAppEntry) {\n                        const metadataDiagnostics = isClientEntry ? metadata.getSemanticDiagnosticsForExportVariableStatementInClientEntry(fileName, node) : metadata.getSemanticDiagnosticsForExportVariableStatement(fileName, node);\n                        prior.push(...metadataDiagnostics);\n                    }\n                    if (isClientEntry) {\n                        prior.push(...clientBoundary.getSemanticDiagnosticsForFunctionExport(source, node));\n                    }\n                    if (isServerEntry) {\n                        prior.push(...serverBoundary.getSemanticDiagnosticsForFunctionExport(source, node));\n                    }\n                } else if (ts.isExportDeclaration(node)) {\n                    // export { ... }\n                    if (isAppEntry) {\n                        const metadataDiagnostics = isClientEntry ? metadata.getSemanticDiagnosticsForExportDeclarationInClientEntry(fileName, node) : metadata.getSemanticDiagnosticsForExportDeclaration(fileName, node);\n                        prior.push(...metadataDiagnostics);\n                    }\n                    if (isServerEntry) {\n                        prior.push(...serverBoundary.getSemanticDiagnosticsForExportDeclaration(source, node));\n                    }\n                }\n            });\n            return prior;\n        };\n        // Get definition and link for specific node\n        proxy.getDefinitionAndBoundSpan = (fileName, position)=>{\n            const entryInfo = getEntryInfo(fileName);\n            if (isAppEntryFile(fileName) && !entryInfo.client) {\n                const metadataDefinition = metadata.getDefinitionAndBoundSpan(fileName, position);\n                if (metadataDefinition) return metadataDefinition;\n            }\n            return info.languageService.getDefinitionAndBoundSpan(fileName, position);\n        };\n        return proxy;\n    }\n    return {\n        create\n    };\n};\n\n//# sourceMappingURL=index.js.map"
        }
    ]
}