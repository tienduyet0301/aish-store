{
    "sourceFile": "node_modules/next/dist/esm/server/typescript/utils.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892845630,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import { createFSBackedSystem, createDefaultMapFromNodeModules, createVirtualTypeScriptEnvironment } from 'next/dist/compiled/@typescript/vfs';\nimport path, { join } from 'path';\nlet ts;\nlet info;\nlet appDirRegExp;\nexport let virtualTsEnv;\nexport function log(message) {\n    info.project.projectService.logger.info('[next] ' + message);\n}\n// This function has to be called initially.\nexport function init(opts) {\n    const projectDir = opts.info.project.getCurrentDirectory();\n    ts = opts.ts;\n    info = opts.info;\n    appDirRegExp = new RegExp('^' + (projectDir + '(/src)?/app').replace(/[\\\\/]/g, '[\\\\/]'));\n    log('Initializing Next.js TypeScript plugin: ' + projectDir);\n    const compilerOptions = info.project.getCompilerOptions();\n    const fsMap = createDefaultMapFromNodeModules(compilerOptions, ts, join(projectDir, 'node_modules/typescript/lib'));\n    const system = createFSBackedSystem(fsMap, projectDir, ts);\n    virtualTsEnv = createVirtualTypeScriptEnvironment(system, [], ts, compilerOptions);\n    if (!virtualTsEnv) {\n        log('Failed to create virtual TypeScript environment. This is a bug in Next.js TypeScript plugin. Please report it by opening an issue at https://github.com/vercel/next.js/issues.');\n        return false;\n    }\n    log('Successfully initialized Next.js TypeScript plugin!');\n    return true;\n}\nexport function getTs() {\n    return ts;\n}\nexport function getInfo() {\n    return info;\n}\nexport function getTypeChecker() {\n    var _info_languageService_getProgram;\n    return (_info_languageService_getProgram = info.languageService.getProgram()) == null ? void 0 : _info_languageService_getProgram.getTypeChecker();\n}\nexport function getSource(fileName) {\n    var _info_languageService_getProgram;\n    return (_info_languageService_getProgram = info.languageService.getProgram()) == null ? void 0 : _info_languageService_getProgram.getSourceFile(fileName);\n}\nexport function getSourceFromVirtualTsEnv(fileName) {\n    if (virtualTsEnv.sys.fileExists(fileName)) {\n        return virtualTsEnv.getSourceFile(fileName);\n    }\n    return getSource(fileName);\n}\nexport function removeStringQuotes(str) {\n    return str.replace(/^['\"`]|['\"`]$/g, '');\n}\nexport const isPositionInsideNode = (position, node)=>{\n    const start = node.getFullStart();\n    return start <= position && position <= node.getFullWidth() + start;\n};\nexport const isDefaultFunctionExport = (node)=>{\n    if (ts.isFunctionDeclaration(node)) {\n        let hasExportKeyword = false;\n        let hasDefaultKeyword = false;\n        if (node.modifiers) {\n            for (const modifier of node.modifiers){\n                if (modifier.kind === ts.SyntaxKind.ExportKeyword) {\n                    hasExportKeyword = true;\n                } else if (modifier.kind === ts.SyntaxKind.DefaultKeyword) {\n                    hasDefaultKeyword = true;\n                }\n            }\n        }\n        // `export default function`\n        if (hasExportKeyword && hasDefaultKeyword) {\n            return true;\n        }\n    }\n    return false;\n};\nexport const isInsideApp = (filePath)=>{\n    return appDirRegExp.test(filePath);\n};\nexport const isAppEntryFile = (filePath)=>{\n    return appDirRegExp.test(filePath) && /^(page|layout)\\.(mjs|js|jsx|ts|tsx)$/.test(path.basename(filePath));\n};\nexport const isPageFile = (filePath)=>{\n    return appDirRegExp.test(filePath) && /^page\\.(mjs|js|jsx|ts|tsx)$/.test(path.basename(filePath));\n};\n// Check if a module is a client entry.\nexport function getEntryInfo(fileName, throwOnInvalidDirective) {\n    const source = getSource(fileName);\n    if (source) {\n        let isDirective = true;\n        let isClientEntry = false;\n        let isServerEntry = false;\n        ts.forEachChild(source, (node)=>{\n            if (ts.isExpressionStatement(node) && ts.isStringLiteral(node.expression)) {\n                if (node.expression.text === 'use client') {\n                    if (isDirective) {\n                        isClientEntry = true;\n                    } else {\n                        if (throwOnInvalidDirective) {\n                            const e = {\n                                messageText: 'The `\"use client\"` directive must be put at the top of the file.',\n                                start: node.expression.getStart(),\n                                length: node.expression.getWidth()\n                            };\n                            throw e;\n                        }\n                    }\n                } else if (node.expression.text === 'use server') {\n                    if (isDirective) {\n                        isServerEntry = true;\n                    } else {\n                        if (throwOnInvalidDirective) {\n                            const e = {\n                                messageText: 'The `\"use server\"` directive must be put at the top of the file.',\n                                start: node.expression.getStart(),\n                                length: node.expression.getWidth()\n                            };\n                            throw e;\n                        }\n                    }\n                }\n                if (isClientEntry && isServerEntry) {\n                    const e = {\n                        messageText: 'Cannot use both \"use client\" and \"use server\" directives in the same file.',\n                        start: node.expression.getStart(),\n                        length: node.expression.getWidth()\n                    };\n                    throw e;\n                }\n            } else {\n                isDirective = false;\n            }\n        });\n        return {\n            client: isClientEntry,\n            server: isServerEntry\n        };\n    }\n    return {\n        client: false,\n        server: false\n    };\n}\n\n//# sourceMappingURL=utils.js.map"
        }
    ]
}