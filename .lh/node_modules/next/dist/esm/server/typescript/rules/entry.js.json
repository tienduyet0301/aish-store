{
    "sourceFile": "node_modules/next/dist/esm/server/typescript/rules/entry.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892845353,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import path from 'path';\nimport fs from 'fs';\nimport { ALLOWED_LAYOUT_PROPS, ALLOWED_PAGE_PROPS, NEXT_TS_ERRORS } from '../constant';\nimport { getTs, isPageFile, isPositionInsideNode } from '../utils';\nconst entry = {\n    // Give auto completion for the component's props\n    getCompletionsAtPosition (fileName, node, position) {\n        var _node_parameters;\n        const ts = getTs();\n        const entries = [];\n        // Default export function might not accept parameters\n        const paramNode = (_node_parameters = node.parameters) == null ? void 0 : _node_parameters[0];\n        if (paramNode && isPositionInsideNode(position, paramNode)) {\n            const props = paramNode == null ? void 0 : paramNode.name;\n            if (props && ts.isObjectBindingPattern(props)) {\n                let validProps = [];\n                let validPropsWithType = [];\n                let type;\n                if (isPageFile(fileName)) {\n                    // For page entries (page.js), it can only have `params` and `searchParams`\n                    // as the prop names.\n                    validProps = ALLOWED_PAGE_PROPS;\n                    validPropsWithType = ALLOWED_PAGE_PROPS;\n                    type = 'page';\n                } else {\n                    // For layout entires, check if it has any named slots.\n                    const currentDir = path.dirname(fileName);\n                    const items = fs.readdirSync(currentDir, {\n                        withFileTypes: true\n                    });\n                    const slots = [];\n                    for (const item of items){\n                        if (item.isDirectory() && item.name.startsWith('@')) {\n                            slots.push(item.name.slice(1));\n                        }\n                    }\n                    validProps = ALLOWED_LAYOUT_PROPS.concat(slots);\n                    validPropsWithType = ALLOWED_LAYOUT_PROPS.concat(slots.map((s)=>`${s}: React.ReactNode`));\n                    type = 'layout';\n                }\n                // Auto completion for props\n                for (const element of props.elements){\n                    if (isPositionInsideNode(position, element)) {\n                        const nameNode = element.propertyName || element.name;\n                        if (isPositionInsideNode(position, nameNode)) {\n                            for (const name of validProps){\n                                entries.push({\n                                    name,\n                                    insertText: name,\n                                    sortText: '_' + name,\n                                    kind: ts.ScriptElementKind.memberVariableElement,\n                                    kindModifiers: ts.ScriptElementKindModifier.none,\n                                    labelDetails: {\n                                        description: `Next.js ${type} prop`\n                                    }\n                                });\n                            }\n                        }\n                        break;\n                    }\n                }\n                // Auto completion for types\n                if (paramNode.type && ts.isTypeLiteralNode(paramNode.type)) {\n                    for (const member of paramNode.type.members){\n                        if (isPositionInsideNode(position, member)) {\n                            for (const name of validPropsWithType){\n                                entries.push({\n                                    name,\n                                    insertText: name,\n                                    sortText: '_' + name,\n                                    kind: ts.ScriptElementKind.memberVariableElement,\n                                    kindModifiers: ts.ScriptElementKindModifier.none,\n                                    labelDetails: {\n                                        description: `Next.js ${type} prop type`\n                                    }\n                                });\n                            }\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        return entries;\n    },\n    // Give error diagnostics for the component\n    getSemanticDiagnostics (fileName, source, node) {\n        var _node_parameters_, _node_parameters;\n        const ts = getTs();\n        let validProps = [];\n        let type;\n        if (isPageFile(fileName)) {\n            // For page entries (page.js), it can only have `params` and `searchParams`\n            // as the prop names.\n            validProps = ALLOWED_PAGE_PROPS;\n            type = 'page';\n        } else {\n            // For layout entires, check if it has any named slots.\n            const currentDir = path.dirname(fileName);\n            const items = fs.readdirSync(currentDir, {\n                withFileTypes: true\n            });\n            const slots = [];\n            for (const item of items){\n                if (item.isDirectory() && item.name.startsWith('@')) {\n                    slots.push(item.name.slice(1));\n                }\n            }\n            validProps = ALLOWED_LAYOUT_PROPS.concat(slots);\n            type = 'layout';\n        }\n        const diagnostics = [];\n        const props = (_node_parameters = node.parameters) == null ? void 0 : (_node_parameters_ = _node_parameters[0]) == null ? void 0 : _node_parameters_.name;\n        if (props && ts.isObjectBindingPattern(props)) {\n            for (const prop of props.elements){\n                const propName = (prop.propertyName || prop.name).getText();\n                if (!validProps.includes(propName)) {\n                    diagnostics.push({\n                        file: source,\n                        category: ts.DiagnosticCategory.Error,\n                        code: NEXT_TS_ERRORS.INVALID_PAGE_PROP,\n                        messageText: `\"${propName}\" is not a valid ${type} prop.`,\n                        start: prop.getStart(),\n                        length: prop.getWidth()\n                    });\n                }\n            }\n        }\n        return diagnostics;\n    }\n};\nexport default entry;\n\n//# sourceMappingURL=entry.js.map"
        }
    ]
}