{
    "sourceFile": "node_modules/next/dist/esm/server/typescript/rules/server-boundary.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892845523,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "// This module provides intellisense for all exports from `\"use server\"` directive.\nimport { NEXT_TS_ERRORS } from '../constant';\nimport { getTs, getTypeChecker } from '../utils';\n// Check if the type is `Promise<T>`.\nfunction isPromiseType(type, typeChecker) {\n    const typeReferenceType = type;\n    if (!typeReferenceType.target) return false;\n    // target should be Promise or Promise<...>\n    if (!/^Promise(<.+>)?$/.test(typeChecker.typeToString(typeReferenceType.target))) {\n        return false;\n    }\n    return true;\n}\nfunction isFunctionReturningPromise(node, typeChecker, ts) {\n    const type = typeChecker.getTypeAtLocation(node);\n    const signatures = typeChecker.getSignaturesOfType(type, ts.SignatureKind.Call);\n    let isPromise = true;\n    if (signatures.length) {\n        for (const signature of signatures){\n            const returnType = signature.getReturnType();\n            if (returnType.isUnion()) {\n                for (const t of returnType.types){\n                    if (!isPromiseType(t, typeChecker)) {\n                        isPromise = false;\n                        break;\n                    }\n                }\n            } else {\n                isPromise = isPromiseType(returnType, typeChecker);\n            }\n        }\n    } else {\n        isPromise = false;\n    }\n    return isPromise;\n}\nconst serverBoundary = {\n    getSemanticDiagnosticsForExportDeclaration (source, node) {\n        const ts = getTs();\n        const typeChecker = getTypeChecker();\n        if (!typeChecker) return [];\n        const diagnostics = [];\n        const exportClause = node.exportClause;\n        if (!node.isTypeOnly && exportClause && ts.isNamedExports(exportClause)) {\n            for (const e of exportClause.elements){\n                if (e.isTypeOnly) {\n                    continue;\n                }\n                if (!isFunctionReturningPromise(e, typeChecker, ts)) {\n                    diagnostics.push({\n                        file: source,\n                        category: ts.DiagnosticCategory.Error,\n                        code: NEXT_TS_ERRORS.INVALID_SERVER_ENTRY_RETURN,\n                        messageText: `The \"use server\" file can only export async functions.`,\n                        start: e.getStart(),\n                        length: e.getWidth()\n                    });\n                }\n            }\n        }\n        return diagnostics;\n    },\n    getSemanticDiagnosticsForExportVariableStatement (source, node) {\n        const ts = getTs();\n        const diagnostics = [];\n        if (ts.isVariableDeclarationList(node.declarationList)) {\n            for (const declaration of node.declarationList.declarations){\n                const initializer = declaration.initializer;\n                if (initializer && (ts.isArrowFunction(initializer) || ts.isFunctionDeclaration(initializer) || ts.isFunctionExpression(initializer) || ts.isCallExpression(initializer) || ts.isIdentifier(initializer))) {\n                    diagnostics.push(...serverBoundary.getSemanticDiagnosticsForFunctionExport(source, initializer));\n                } else {\n                    diagnostics.push({\n                        file: source,\n                        category: ts.DiagnosticCategory.Error,\n                        code: NEXT_TS_ERRORS.INVALID_SERVER_ENTRY_RETURN,\n                        messageText: `The \"use server\" file can only export async functions.`,\n                        start: declaration.getStart(),\n                        length: declaration.getWidth()\n                    });\n                }\n            }\n        }\n        return diagnostics;\n    },\n    getSemanticDiagnosticsForFunctionExport (source, node) {\n        const ts = getTs();\n        const typeChecker = getTypeChecker();\n        if (!typeChecker) return [];\n        const diagnostics = [];\n        if (!isFunctionReturningPromise(node, typeChecker, ts)) {\n            diagnostics.push({\n                file: source,\n                category: ts.DiagnosticCategory.Error,\n                code: NEXT_TS_ERRORS.INVALID_SERVER_ENTRY_RETURN,\n                messageText: `The \"use server\" file can only export async functions. Add \"async\" to the function declaration or return a Promise.`,\n                start: node.getStart(),\n                length: node.getWidth()\n            });\n        }\n        return diagnostics;\n    }\n};\nexport default serverBoundary;\n\n//# sourceMappingURL=server-boundary.js.map"
        }
    ]
}