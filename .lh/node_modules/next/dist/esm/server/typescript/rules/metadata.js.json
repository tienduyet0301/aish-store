{
    "sourceFile": "node_modules/next/dist/esm/server/typescript/rules/metadata.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892845457,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import { NEXT_TS_ERRORS } from '../constant';\nimport { getSource, getSourceFromVirtualTsEnv, getTs, getTypeChecker, isPositionInsideNode, log, virtualTsEnv } from '../utils';\nconst TYPE_ANNOTATION = ': Metadata | null';\nconst TYPE_ANNOTATION_ASYNC = ': Promise<Metadata | null>';\nconst TYPE_IMPORT = `\\n\\nimport type { Metadata } from 'next'`;\n// Find the `export const metadata = ...` node.\nfunction getMetadataExport(fileName, position) {\n    const source = getSource(fileName);\n    let metadataExport;\n    if (source) {\n        const ts = getTs();\n        ts.forEachChild(source, function visit(node) {\n            if (metadataExport) return;\n            // Covered by this node\n            if (isPositionInsideNode(position, node)) {\n                var _node_modifiers;\n                // Export variable\n                if (ts.isVariableStatement(node) && ((_node_modifiers = node.modifiers) == null ? void 0 : _node_modifiers.some((m)=>m.kind === ts.SyntaxKind.ExportKeyword))) {\n                    if (ts.isVariableDeclarationList(node.declarationList)) {\n                        for (const declaration of node.declarationList.declarations){\n                            if (isPositionInsideNode(position, declaration) && declaration.name.getText() === 'metadata') {\n                                // `export const metadata = ...`\n                                metadataExport = declaration;\n                                return;\n                            }\n                        }\n                    }\n                }\n            }\n        });\n    }\n    return metadataExport;\n}\nfunction updateVirtualFileWithType(fileName, node, isGenerateMetadata) {\n    const source = getSource(fileName);\n    if (!source) return;\n    // We annotate with the type in a virtual language service\n    const sourceText = source.getFullText();\n    let nodeEnd;\n    let annotation;\n    const ts = getTs();\n    if (ts.isFunctionDeclaration(node)) {\n        if (isGenerateMetadata) {\n            var _node_modifiers;\n            nodeEnd = node.body.getFullStart();\n            const isAsync = (_node_modifiers = node.modifiers) == null ? void 0 : _node_modifiers.some((m)=>m.kind === ts.SyntaxKind.AsyncKeyword);\n            annotation = isAsync ? TYPE_ANNOTATION_ASYNC : TYPE_ANNOTATION;\n        } else {\n            return;\n        }\n    } else {\n        nodeEnd = node.name.getFullStart() + node.name.getFullWidth();\n        annotation = TYPE_ANNOTATION;\n    }\n    const newSource = sourceText.slice(0, nodeEnd) + annotation + sourceText.slice(nodeEnd) + TYPE_IMPORT;\n    if (virtualTsEnv.getSourceFile(fileName)) {\n        log('Updating file: ' + fileName);\n        virtualTsEnv.updateFile(fileName, newSource);\n    } else {\n        log('Creating file: ' + fileName);\n        virtualTsEnv.createFile(fileName, newSource);\n    }\n    return [\n        nodeEnd,\n        annotation.length\n    ];\n}\nfunction isTyped(node) {\n    return node.type !== undefined;\n}\nfunction proxyDiagnostics(fileName, pos, n) {\n    // Get diagnostics\n    const diagnostics = virtualTsEnv.languageService.getSemanticDiagnostics(fileName);\n    const source = getSourceFromVirtualTsEnv(fileName);\n    // Filter and map the results\n    return diagnostics.filter((d)=>{\n        if (d.start === undefined || d.length === undefined) return false;\n        if (d.start < n.getFullStart()) return false;\n        if (d.start + d.length >= n.getFullStart() + n.getFullWidth() + pos[1]) return false;\n        return true;\n    }).map((d)=>{\n        return {\n            file: source,\n            category: d.category,\n            code: d.code,\n            messageText: d.messageText,\n            start: d.start < pos[0] ? d.start : d.start - pos[1],\n            length: d.length\n        };\n    });\n}\nconst metadata = {\n    filterCompletionsAtPosition (fileName, position, _options, prior) {\n        const node = getMetadataExport(fileName, position);\n        if (!node) return prior;\n        if (isTyped(node)) return prior;\n        // We annotate with the type in a virtual language service\n        const pos = updateVirtualFileWithType(fileName, node);\n        if (pos === undefined) return prior;\n        // Get completions\n        const newPos = position <= pos[0] ? position : position + pos[1];\n        const completions = virtualTsEnv.languageService.getCompletionsAtPosition(fileName, newPos, undefined);\n        if (completions) {\n            const ts = getTs();\n            completions.isIncomplete = true;\n            // https://github.com/microsoft/TypeScript/blob/4dc677b292354f4b9162452b2e00f4d7dd118221/src/services/types.ts#L1428-L1433\n            if (completions.optionalReplacementSpan) {\n                // Adjust the start position of the text span to original source.\n                completions.optionalReplacementSpan.start -= newPos - position;\n            }\n            completions.entries = completions.entries.filter((e)=>{\n                return [\n                    ts.ScriptElementKind.memberVariableElement,\n                    ts.ScriptElementKind.typeElement,\n                    ts.ScriptElementKind.string\n                ].includes(e.kind);\n            }).map((e)=>{\n                const insertText = e.kind === ts.ScriptElementKind.memberVariableElement && /^[a-zA-Z0-9_]+$/.test(e.name) ? e.name + ': ' : e.name;\n                return {\n                    name: e.name,\n                    insertText,\n                    kind: e.kind,\n                    kindModifiers: e.kindModifiers,\n                    sortText: '!' + e.name,\n                    labelDetails: {\n                        description: `Next.js metadata`\n                    },\n                    data: e.data\n                };\n            });\n            return completions;\n        }\n        return prior;\n    },\n    getSemanticDiagnosticsForExportVariableStatementInClientEntry (fileName, node) {\n        const source = getSource(fileName);\n        const ts = getTs();\n        // It is not allowed to export `metadata` or `generateMetadata` in client entry\n        if (ts.isFunctionDeclaration(node)) {\n            var _node_name;\n            if (((_node_name = node.name) == null ? void 0 : _node_name.getText()) === 'generateMetadata') {\n                return [\n                    {\n                        file: source,\n                        category: ts.DiagnosticCategory.Error,\n                        code: NEXT_TS_ERRORS.INVALID_METADATA_EXPORT,\n                        messageText: `The Next.js 'generateMetadata' API is not allowed in a client component.`,\n                        start: node.name.getStart(),\n                        length: node.name.getWidth()\n                    }\n                ];\n            }\n        } else {\n            for (const declaration of node.declarationList.declarations){\n                const name = declaration.name.getText();\n                if (name === 'metadata') {\n                    return [\n                        {\n                            file: source,\n                            category: ts.DiagnosticCategory.Error,\n                            code: NEXT_TS_ERRORS.INVALID_METADATA_EXPORT,\n                            messageText: `The Next.js 'metadata' API is not allowed in a client component.`,\n                            start: declaration.name.getStart(),\n                            length: declaration.name.getWidth()\n                        }\n                    ];\n                }\n            }\n        }\n        return [];\n    },\n    getSemanticDiagnosticsForExportVariableStatement (fileName, node) {\n        const ts = getTs();\n        if (ts.isFunctionDeclaration(node)) {\n            var _node_name;\n            if (((_node_name = node.name) == null ? void 0 : _node_name.getText()) === 'generateMetadata') {\n                if (isTyped(node)) return [];\n                // We annotate with the type in a virtual language service\n                const pos = updateVirtualFileWithType(fileName, node, true);\n                if (!pos) return [];\n                return proxyDiagnostics(fileName, pos, node);\n            }\n        } else {\n            for (const declaration of node.declarationList.declarations){\n                if (declaration.name.getText() === 'metadata') {\n                    if (isTyped(declaration)) break;\n                    // We annotate with the type in a virtual language service\n                    const pos = updateVirtualFileWithType(fileName, declaration);\n                    if (!pos) break;\n                    return proxyDiagnostics(fileName, pos, declaration);\n                }\n            }\n        }\n        return [];\n    },\n    getSemanticDiagnosticsForExportDeclarationInClientEntry (fileName, node) {\n        const ts = getTs();\n        const source = getSource(fileName);\n        const diagnostics = [];\n        const exportClause = node.exportClause;\n        if (exportClause && ts.isNamedExports(exportClause)) {\n            for (const e of exportClause.elements){\n                if ([\n                    'generateMetadata',\n                    'metadata'\n                ].includes(e.name.getText())) {\n                    diagnostics.push({\n                        file: source,\n                        category: ts.DiagnosticCategory.Error,\n                        code: NEXT_TS_ERRORS.INVALID_METADATA_EXPORT,\n                        messageText: `The Next.js '${e.name.getText()}' API is not allowed in a client component.`,\n                        start: e.name.getStart(),\n                        length: e.name.getWidth()\n                    });\n                }\n            }\n        }\n        return diagnostics;\n    },\n    getSemanticDiagnosticsForExportDeclaration (fileName, node) {\n        const ts = getTs();\n        const exportClause = node.exportClause;\n        if (exportClause && ts.isNamedExports(exportClause)) {\n            for (const e of exportClause.elements){\n                if (e.name.getText() === 'metadata') {\n                    // Get the original declaration node of element\n                    const typeChecker = getTypeChecker();\n                    if (typeChecker) {\n                        const symbol = typeChecker.getSymbolAtLocation(e.name);\n                        if (symbol) {\n                            const metadataSymbol = typeChecker.getAliasedSymbol(symbol);\n                            if (metadataSymbol && metadataSymbol.declarations) {\n                                const declaration = metadataSymbol.declarations[0];\n                                if (declaration && ts.isVariableDeclaration(declaration)) {\n                                    if (isTyped(declaration)) break;\n                                    const declarationFileName = declaration.getSourceFile().fileName;\n                                    const isSameFile = declarationFileName === fileName;\n                                    // We annotate with the type in a virtual language service\n                                    const pos = updateVirtualFileWithType(declarationFileName, declaration);\n                                    if (!pos) break;\n                                    const diagnostics = proxyDiagnostics(declarationFileName, pos, declaration);\n                                    if (diagnostics.length) {\n                                        if (isSameFile) {\n                                            return diagnostics;\n                                        } else {\n                                            return [\n                                                {\n                                                    file: getSource(fileName),\n                                                    category: ts.DiagnosticCategory.Error,\n                                                    code: NEXT_TS_ERRORS.INVALID_METADATA_EXPORT,\n                                                    messageText: `The 'metadata' export value is not typed correctly, please make sure it is typed as 'Metadata':\\nhttps://nextjs.org/docs/app/building-your-application/optimizing/metadata#static-metadata`,\n                                                    start: e.name.getStart(),\n                                                    length: e.name.getWidth()\n                                                }\n                                            ];\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return [];\n    },\n    getCompletionEntryDetails (fileName, position, entryName, formatOptions, source, preferences, data) {\n        const node = getMetadataExport(fileName, position);\n        if (!node) return;\n        if (isTyped(node)) return;\n        // We annotate with the type in a virtual language service\n        const pos = updateVirtualFileWithType(fileName, node);\n        if (pos === undefined) return;\n        const newPos = position <= pos[0] ? position : position + pos[1];\n        const details = virtualTsEnv.languageService.getCompletionEntryDetails(fileName, newPos, entryName, formatOptions, source, preferences, data);\n        return details;\n    },\n    getQuickInfoAtPosition (fileName, position) {\n        const node = getMetadataExport(fileName, position);\n        if (!node) return;\n        if (isTyped(node)) return;\n        // We annotate with the type in a virtual language service\n        const pos = updateVirtualFileWithType(fileName, node);\n        if (pos === undefined) return;\n        const newPos = position <= pos[0] ? position : position + pos[1];\n        const insight = virtualTsEnv.languageService.getQuickInfoAtPosition(fileName, newPos);\n        return insight;\n    },\n    getDefinitionAndBoundSpan (fileName, position) {\n        const node = getMetadataExport(fileName, position);\n        if (!node) return;\n        if (isTyped(node)) return;\n        if (!isPositionInsideNode(position, node)) return;\n        // We annotate with the type in a virtual language service\n        const pos = updateVirtualFileWithType(fileName, node);\n        if (pos === undefined) return;\n        const newPos = position <= pos[0] ? position : position + pos[1];\n        const definitionInfoAndBoundSpan = virtualTsEnv.languageService.getDefinitionAndBoundSpan(fileName, newPos);\n        if (definitionInfoAndBoundSpan) {\n            // Adjust the start position of the text span\n            if (definitionInfoAndBoundSpan.textSpan.start > pos[0]) {\n                definitionInfoAndBoundSpan.textSpan.start -= pos[1];\n            }\n        }\n        return definitionInfoAndBoundSpan;\n    }\n};\nexport default metadata;\n\n//# sourceMappingURL=metadata.js.map"
        }
    ]
}