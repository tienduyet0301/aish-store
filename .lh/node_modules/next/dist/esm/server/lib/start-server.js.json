{
    "sourceFile": "node_modules/next/dist/esm/server/lib/start-server.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892833283,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import { getNetworkHost } from '../../lib/get-network-host';\nif (performance.getEntriesByName('next-start').length === 0) {\n    performance.mark('next-start');\n}\nimport '../next';\nimport '../require-hook';\nimport fs from 'fs';\nimport v8 from 'v8';\nimport path from 'path';\nimport http from 'http';\nimport https from 'https';\nimport os from 'os';\nimport Watchpack from 'next/dist/compiled/watchpack';\nimport * as Log from '../../build/output/log';\nimport setupDebug from 'next/dist/compiled/debug';\nimport { RESTART_EXIT_CODE, getFormattedDebugAddress, getNodeDebugType } from './utils';\nimport { formatHostname } from './format-hostname';\nimport { initialize } from './router-server';\nimport { CONFIG_FILES } from '../../shared/lib/constants';\nimport { getStartServerInfo, logStartInfo } from './app-info-log';\nimport { validateTurboNextConfig } from '../../lib/turbopack-warning';\nimport { trace, flushAllTraces } from '../../trace';\nimport { isPostpone } from './router-utils/is-postpone';\nimport { isIPv6 } from './is-ipv6';\nimport { AsyncCallbackSet } from './async-callback-set';\nconst debug = setupDebug('next:start-server');\nlet startServerSpan;\nexport async function getRequestHandlers({ dir, port, isDev, onDevServerCleanup, server, hostname, minimalMode, keepAliveTimeout, experimentalHttpsServer, quiet }) {\n    return initialize({\n        dir,\n        port,\n        hostname,\n        onDevServerCleanup,\n        dev: isDev,\n        minimalMode,\n        server,\n        keepAliveTimeout,\n        experimentalHttpsServer,\n        startServerSpan,\n        quiet\n    });\n}\nexport async function startServer(serverOptions) {\n    const { dir, isDev, hostname, minimalMode, allowRetry, keepAliveTimeout, selfSignedCertificate } = serverOptions;\n    let { port } = serverOptions;\n    process.title = `next-server (v${\"15.3.1\"})`;\n    let handlersReady = ()=>{};\n    let handlersError = ()=>{};\n    let handlersPromise = new Promise((resolve, reject)=>{\n        handlersReady = resolve;\n        handlersError = reject;\n    });\n    let requestHandler = async (req, res)=>{\n        if (handlersPromise) {\n            await handlersPromise;\n            return requestHandler(req, res);\n        }\n        throw Object.defineProperty(new Error('Invariant request handler was not setup'), \"__NEXT_ERROR_CODE\", {\n            value: \"E287\",\n            enumerable: false,\n            configurable: true\n        });\n    };\n    let upgradeHandler = async (req, socket, head)=>{\n        if (handlersPromise) {\n            await handlersPromise;\n            return upgradeHandler(req, socket, head);\n        }\n        throw Object.defineProperty(new Error('Invariant upgrade handler was not setup'), \"__NEXT_ERROR_CODE\", {\n            value: \"E290\",\n            enumerable: false,\n            configurable: true\n        });\n    };\n    let nextServer;\n    // setup server listener as fast as possible\n    if (selfSignedCertificate && !isDev) {\n        throw Object.defineProperty(new Error('Using a self signed certificate is only supported with `next dev`.'), \"__NEXT_ERROR_CODE\", {\n            value: \"E128\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    async function requestListener(req, res) {\n        try {\n            if (handlersPromise) {\n                await handlersPromise;\n                handlersPromise = undefined;\n            }\n            await requestHandler(req, res);\n        } catch (err) {\n            res.statusCode = 500;\n            res.end('Internal Server Error');\n            Log.error(`Failed to handle request for ${req.url}`);\n            console.error(err);\n        } finally{\n            if (isDev) {\n                if (v8.getHeapStatistics().used_heap_size > 0.8 * v8.getHeapStatistics().heap_size_limit) {\n                    Log.warn(`Server is approaching the used memory threshold, restarting...`);\n                    trace('server-restart-close-to-memory-threshold', undefined, {\n                        'memory.heapSizeLimit': String(v8.getHeapStatistics().heap_size_limit),\n                        'memory.heapUsed': String(v8.getHeapStatistics().used_heap_size)\n                    }).stop();\n                    await flushAllTraces();\n                    process.exit(RESTART_EXIT_CODE);\n                }\n            }\n        }\n    }\n    const server = selfSignedCertificate ? https.createServer({\n        key: fs.readFileSync(selfSignedCertificate.key),\n        cert: fs.readFileSync(selfSignedCertificate.cert)\n    }, requestListener) : http.createServer(requestListener);\n    if (keepAliveTimeout) {\n        server.keepAliveTimeout = keepAliveTimeout;\n    }\n    server.on('upgrade', async (req, socket, head)=>{\n        try {\n            await upgradeHandler(req, socket, head);\n        } catch (err) {\n            socket.destroy();\n            Log.error(`Failed to handle request for ${req.url}`);\n            console.error(err);\n        }\n    });\n    let portRetryCount = 0;\n    const originalPort = port;\n    server.on('error', (err)=>{\n        if (allowRetry && port && isDev && err.code === 'EADDRINUSE' && portRetryCount < 10) {\n            port += 1;\n            portRetryCount += 1;\n            server.listen(port, hostname);\n        } else {\n            Log.error(`Failed to start server`);\n            console.error(err);\n            process.exit(1);\n        }\n    });\n    let cleanupListeners = isDev ? new AsyncCallbackSet() : undefined;\n    await new Promise((resolve)=>{\n        server.on('listening', async ()=>{\n            const nodeDebugType = getNodeDebugType();\n            const addr = server.address();\n            const actualHostname = formatHostname(typeof addr === 'object' ? (addr == null ? void 0 : addr.address) || hostname || 'localhost' : addr);\n            const formattedHostname = !hostname || actualHostname === '0.0.0.0' ? 'localhost' : actualHostname === '[::]' ? '[::1]' : formatHostname(hostname);\n            port = typeof addr === 'object' ? (addr == null ? void 0 : addr.port) || port : port;\n            if (portRetryCount) {\n                Log.warn(`Port ${originalPort} is in use, using available port ${port} instead.`);\n            }\n            const networkHostname = hostname ?? getNetworkHost(isIPv6(actualHostname) ? 'IPv6' : 'IPv4');\n            const protocol = selfSignedCertificate ? 'https' : 'http';\n            const networkUrl = networkHostname ? `${protocol}://${formatHostname(networkHostname)}:${port}` : null;\n            const appUrl = `${protocol}://${formattedHostname}:${port}`;\n            if (nodeDebugType) {\n                const formattedDebugAddress = getFormattedDebugAddress();\n                Log.info(`the --${nodeDebugType} option was detected, the Next.js router server should be inspected at ${formattedDebugAddress}.`);\n            }\n            // Store the selected port to:\n            // - expose it to render workers\n            // - re-use it for automatic dev server restarts with a randomly selected port\n            process.env.PORT = port + '';\n            process.env.__NEXT_PRIVATE_ORIGIN = appUrl;\n            // Only load env and config in dev to for logging purposes\n            let envInfo;\n            let experimentalFeatures;\n            if (isDev) {\n                const startServerInfo = await getStartServerInfo(dir, isDev);\n                envInfo = startServerInfo.envInfo;\n                experimentalFeatures = startServerInfo.experimentalFeatures;\n            }\n            logStartInfo({\n                networkUrl,\n                appUrl,\n                envInfo,\n                experimentalFeatures,\n                maxExperimentalFeatures: 3\n            });\n            Log.event(`Starting...`);\n            try {\n                let cleanupStarted = false;\n                let closeUpgraded = null;\n                const cleanup = ()=>{\n                    if (cleanupStarted) {\n                        // We can get duplicate signals, e.g. when `ctrl+c` is used in an\n                        // interactive shell (i.e. bash, zsh), the shell will recursively\n                        // send SIGINT to children. The parent `next-dev` process will also\n                        // send us SIGINT.\n                        return;\n                    }\n                    cleanupStarted = true;\n                    (async ()=>{\n                        debug('start-server process cleanup');\n                        // first, stop accepting new connections and finish pending requests,\n                        // because they might affect `nextServer.close()` (e.g. by scheduling an `after`)\n                        await new Promise((res)=>{\n                            server.close((err)=>{\n                                if (err) console.error(err);\n                                res();\n                            });\n                            if (isDev) {\n                                server.closeAllConnections();\n                                closeUpgraded == null ? void 0 : closeUpgraded();\n                            }\n                        });\n                        // now that no new requests can come in, clean up the rest\n                        await Promise.all([\n                            nextServer == null ? void 0 : nextServer.close().catch(console.error),\n                            cleanupListeners == null ? void 0 : cleanupListeners.runAll().catch(console.error)\n                        ]);\n                        debug('start-server process cleanup finished');\n                        process.exit(0);\n                    })();\n                };\n                const exception = (err)=>{\n                    if (isPostpone(err)) {\n                        // React postpones that are unhandled might end up logged here but they're\n                        // not really errors. They're just part of rendering.\n                        return;\n                    }\n                    // This is the render worker, we keep the process alive\n                    console.error(err);\n                };\n                // Make sure commands gracefully respect termination signals (e.g. from Docker)\n                // Allow the graceful termination to be manually configurable\n                if (!process.env.NEXT_MANUAL_SIG_HANDLE) {\n                    process.on('SIGINT', cleanup);\n                    process.on('SIGTERM', cleanup);\n                }\n                process.on('rejectionHandled', ()=>{\n                // It is ok to await a Promise late in Next.js as it allows for better\n                // prefetching patterns to avoid waterfalls. We ignore loggining these.\n                // We should've already errored in anyway unhandledRejection.\n                });\n                process.on('uncaughtException', exception);\n                process.on('unhandledRejection', exception);\n                const initResult = await getRequestHandlers({\n                    dir,\n                    port,\n                    isDev,\n                    onDevServerCleanup: cleanupListeners ? cleanupListeners.add.bind(cleanupListeners) : undefined,\n                    server,\n                    hostname,\n                    minimalMode,\n                    keepAliveTimeout,\n                    experimentalHttpsServer: !!selfSignedCertificate\n                });\n                requestHandler = initResult.requestHandler;\n                upgradeHandler = initResult.upgradeHandler;\n                nextServer = initResult.server;\n                closeUpgraded = initResult.closeUpgraded;\n                const startServerProcessDuration = performance.mark('next-start-end') && performance.measure('next-start-duration', 'next-start', 'next-start-end').duration;\n                handlersReady();\n                const formatDurationText = startServerProcessDuration > 2000 ? `${Math.round(startServerProcessDuration / 100) / 10}s` : `${Math.round(startServerProcessDuration)}ms`;\n                Log.event(`Ready in ${formatDurationText}`);\n                if (process.env.TURBOPACK) {\n                    await validateTurboNextConfig({\n                        dir: serverOptions.dir,\n                        isDev: true\n                    });\n                }\n            } catch (err) {\n                // fatal error if we can't setup\n                handlersError();\n                console.error(err);\n                process.exit(1);\n            }\n            resolve();\n        });\n        server.listen(port, hostname);\n    });\n    if (isDev) {\n        function watchConfigFiles(dirToWatch, onChange) {\n            const wp = new Watchpack();\n            wp.watch({\n                files: CONFIG_FILES.map((file)=>path.join(dirToWatch, file))\n            });\n            wp.on('change', onChange);\n        }\n        watchConfigFiles(dir, async (filename)=>{\n            if (process.env.__NEXT_DISABLE_MEMORY_WATCHER) {\n                Log.info(`Detected change, manual restart required due to '__NEXT_DISABLE_MEMORY_WATCHER' usage`);\n                return;\n            }\n            Log.warn(`Found a change in ${path.basename(filename)}. Restarting the server to apply the changes...`);\n            process.exit(RESTART_EXIT_CODE);\n        });\n    }\n}\nif (process.env.NEXT_PRIVATE_WORKER && process.send) {\n    process.addListener('message', async (msg)=>{\n        if (msg && typeof msg === 'object' && msg.nextWorkerOptions && process.send) {\n            startServerSpan = trace('start-dev-server', undefined, {\n                cpus: String(os.cpus().length),\n                platform: os.platform(),\n                'memory.freeMem': String(os.freemem()),\n                'memory.totalMem': String(os.totalmem()),\n                'memory.heapSizeLimit': String(v8.getHeapStatistics().heap_size_limit)\n            });\n            await startServerSpan.traceAsyncFn(()=>startServer(msg.nextWorkerOptions));\n            const memoryUsage = process.memoryUsage();\n            startServerSpan.setAttribute('memory.rss', String(memoryUsage.rss));\n            startServerSpan.setAttribute('memory.heapTotal', String(memoryUsage.heapTotal));\n            startServerSpan.setAttribute('memory.heapUsed', String(memoryUsage.heapUsed));\n            process.send({\n                nextServerReady: true,\n                port: process.env.PORT\n            });\n        }\n    });\n    process.send({\n        nextWorkerReady: true\n    });\n}\n\n//# sourceMappingURL=start-server.js.map"
        }
    ]
}