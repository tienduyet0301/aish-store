{
    "sourceFile": "node_modules/next/dist/esm/server/lib/utils.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892833779,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import { parseArgs } from 'node:util';\nimport { InvalidArgumentError } from 'next/dist/compiled/commander';\nexport function printAndExit(message, code = 1) {\n    if (code === 0) {\n        console.log(message);\n    } else {\n        console.error(message);\n    }\n    return process.exit(code);\n}\nconst parseNodeArgs = (args)=>{\n    const { values, tokens } = parseArgs({\n        args,\n        strict: false,\n        tokens: true\n    });\n    // For the `NODE_OPTIONS`, we support arguments with values without the `=`\n    // sign. We need to parse them manually.\n    let orphan = null;\n    for(let i = 0; i < tokens.length; i++){\n        const token = tokens[i];\n        if (token.kind === 'option-terminator') {\n            break;\n        }\n        // When we encounter an option, if it's value is undefined, we should check\n        // to see if the following tokens are positional parameters. If they are,\n        // then the option is orphaned, and we can assign it.\n        if (token.kind === 'option') {\n            orphan = typeof token.value === 'undefined' ? token : null;\n            continue;\n        }\n        // If the token isn't a positional one, then we can't assign it to the found\n        // orphaned option.\n        if (token.kind !== 'positional') {\n            orphan = null;\n            continue;\n        }\n        // If we don't have an orphan, then we can skip this token.\n        if (!orphan) {\n            continue;\n        }\n        // If the token is a positional one, and it has a value, so add it to the\n        // values object. If it already exists, append it with a space.\n        if (orphan.name in values && typeof values[orphan.name] === 'string') {\n            values[orphan.name] += ` ${token.value}`;\n        } else {\n            values[orphan.name] = token.value;\n        }\n    }\n    return values;\n};\n/**\n * Tokenizes the arguments string into an array of strings, supporting quoted\n * values and escaped characters.\n * Converted from: https://github.com/nodejs/node/blob/c29d53c5cfc63c5a876084e788d70c9e87bed880/src/node_options.cc#L1401\n *\n * @param input The arguments string to be tokenized.\n * @returns An array of strings with the tokenized arguments.\n */ export const tokenizeArgs = (input)=>{\n    let args = [];\n    let isInString = false;\n    let willStartNewArg = true;\n    for(let i = 0; i < input.length; i++){\n        let char = input[i];\n        // Skip any escaped characters in strings.\n        if (char === '\\\\' && isInString) {\n            // Ensure we don't have an escape character at the end.\n            if (input.length === i + 1) {\n                throw Object.defineProperty(new Error('Invalid escape character at the end.'), \"__NEXT_ERROR_CODE\", {\n                    value: \"E168\",\n                    enumerable: false,\n                    configurable: true\n                });\n            }\n            // Skip the next character.\n            char = input[++i];\n        } else if (char === ' ' && !isInString) {\n            willStartNewArg = true;\n            continue;\n        } else if (char === '\"') {\n            isInString = !isInString;\n            continue;\n        }\n        // If we're starting a new argument, we should add it to the array.\n        if (willStartNewArg) {\n            args.push(char);\n            willStartNewArg = false;\n        } else {\n            args[args.length - 1] += char;\n        }\n    }\n    if (isInString) {\n        throw Object.defineProperty(new Error('Unterminated string'), \"__NEXT_ERROR_CODE\", {\n            value: \"E208\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    return args;\n};\n/**\n * Get the node options from the environment variable `NODE_OPTIONS` and returns\n * them as an array of strings.\n *\n * @returns An array of strings with the node options.\n */ const getNodeOptionsArgs = ()=>{\n    if (!process.env.NODE_OPTIONS) return [];\n    return tokenizeArgs(process.env.NODE_OPTIONS);\n};\n/**\n * Formats the debug address into a string.\n */ export const formatDebugAddress = ({ host, port })=>{\n    if (host) return `${host}:${port}`;\n    return `${port}`;\n};\n/**\n * Get's the debug address from the `NODE_OPTIONS` environment variable. If the\n * address is not found, it returns the default host (`undefined`) and port\n * (`9229`).\n *\n * @returns An object with the host and port of the debug address.\n */ export const getParsedDebugAddress = ()=>{\n    const args = getNodeOptionsArgs();\n    if (args.length === 0) return {\n        host: undefined,\n        port: 9229\n    };\n    const parsed = parseNodeArgs(args);\n    // We expect to find the debug port in one of these options. The first one\n    // found will be used.\n    const address = parsed.inspect ?? parsed['inspect-brk'] ?? parsed['inspect_brk'];\n    if (!address || typeof address !== 'string') {\n        return {\n            host: undefined,\n            port: 9229\n        };\n    }\n    // The address is in the form of `[host:]port`. Let's parse the address.\n    if (address.includes(':')) {\n        const [host, port] = address.split(':');\n        return {\n            host,\n            port: parseInt(port, 10)\n        };\n    }\n    return {\n        host: undefined,\n        port: parseInt(address, 10)\n    };\n};\n/**\n * Get the debug address from the `NODE_OPTIONS` environment variable and format\n * it into a string.\n *\n * @returns A string with the formatted debug address.\n */ export const getFormattedDebugAddress = ()=>formatDebugAddress(getParsedDebugAddress());\n/**\n * Stringify the arguments to be used in a command line. It will ignore any\n * argument that has a value of `undefined`.\n *\n * @param args The arguments to be stringified.\n * @returns A string with the arguments.\n */ export function formatNodeOptions(args) {\n    return Object.entries(args).map(([key, value])=>{\n        if (value === true) {\n            return `--${key}`;\n        }\n        if (value) {\n            return `--${key}=${// Values with spaces need to be quoted. We use JSON.stringify to\n            // also escape any nested quotes.\n            value.includes(' ') && !value.startsWith('\"') ? JSON.stringify(value) : value}`;\n        }\n        return null;\n    }).filter((arg)=>arg !== null).join(' ');\n}\n/**\n * Get the node options from the `NODE_OPTIONS` environment variable and parse\n * them into an object without the inspect options.\n *\n * @returns An object with the parsed node options.\n */ export function getParsedNodeOptionsWithoutInspect() {\n    const args = getNodeOptionsArgs();\n    if (args.length === 0) return {};\n    const parsed = parseNodeArgs(args);\n    // Remove inspect options.\n    delete parsed.inspect;\n    delete parsed['inspect-brk'];\n    delete parsed['inspect_brk'];\n    return parsed;\n}\n/**\n * Get the node options from the `NODE_OPTIONS` environment variable and format\n * them into a string without the inspect options.\n *\n * @returns A string with the formatted node options.\n */ export function getFormattedNodeOptionsWithoutInspect() {\n    const args = getParsedNodeOptionsWithoutInspect();\n    if (Object.keys(args).length === 0) return '';\n    return formatNodeOptions(args);\n}\n/**\n * Check if the value is a valid positive integer and parse it. If it's not, it will throw an error.\n *\n * @param value The value to be parsed.\n */ export function parseValidPositiveInteger(value) {\n    const parsedValue = parseInt(value, 10);\n    if (isNaN(parsedValue) || !isFinite(parsedValue) || parsedValue < 0) {\n        throw new InvalidArgumentError(`'${value}' is not a non-negative number.`);\n    }\n    return parsedValue;\n}\nexport const RESTART_EXIT_CODE = 77;\n/**\n * Get the debug type from the `NODE_OPTIONS` environment variable.\n */ export function getNodeDebugType() {\n    const args = [\n        ...process.execArgv,\n        ...getNodeOptionsArgs()\n    ];\n    if (args.length === 0) return;\n    const parsed = parseNodeArgs(args);\n    if (parsed.inspect) return 'inspect';\n    if (parsed['inspect-brk'] || parsed['inspect_brk']) return 'inspect-brk';\n}\n/**\n * Get the `max-old-space-size` value from the `NODE_OPTIONS` environment\n * variable.\n *\n * @returns The value of the `max-old-space-size` option as a number.\n */ export function getMaxOldSpaceSize() {\n    const args = getNodeOptionsArgs();\n    if (args.length === 0) return;\n    const parsed = parseNodeArgs(args);\n    const size = parsed['max-old-space-size'] || parsed['max_old_space_size'];\n    if (!size || typeof size !== 'string') return;\n    return parseInt(size, 10);\n}\n\n//# sourceMappingURL=utils.js.map"
        }
    ]
}