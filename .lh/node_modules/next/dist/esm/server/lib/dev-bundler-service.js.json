{
    "sourceFile": "node_modules/next/dist/esm/server/lib/dev-bundler-service.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892830356,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import { LRUCache } from './lru-cache';\nimport { createRequestResponseMocks } from './mock-request';\nimport { HMR_ACTIONS_SENT_TO_BROWSER } from '../dev/hot-reloader-types';\n/**\n * The DevBundlerService provides an interface to perform tasks with the\n * bundler while in development.\n */ export class DevBundlerService {\n    constructor(bundler, handler){\n        this.bundler = bundler;\n        this.handler = handler;\n        this.ensurePage = async (definition)=>{\n            // TODO: remove after ensure is pulled out of server\n            return await this.bundler.hotReloader.ensurePage(definition);\n        };\n        this.logErrorWithOriginalStack = this.bundler.logErrorWithOriginalStack.bind(this.bundler);\n        this.appIsrManifestInner = new LRUCache(8000, function length() {\n            return 16;\n        });\n    }\n    async getFallbackErrorComponents(url) {\n        await this.bundler.hotReloader.buildFallbackError();\n        // Build the error page to ensure the fallback is built too.\n        // TODO: See if this can be moved into hotReloader or removed.\n        await this.bundler.hotReloader.ensurePage({\n            page: '/_error',\n            clientOnly: false,\n            definition: undefined,\n            url\n        });\n    }\n    async getCompilationError(page) {\n        const errors = await this.bundler.hotReloader.getCompilationErrors(page);\n        if (!errors) return;\n        // Return the very first error we found.\n        return errors[0];\n    }\n    async revalidate({ urlPath, revalidateHeaders, opts: revalidateOpts }) {\n        const mocked = createRequestResponseMocks({\n            url: urlPath,\n            headers: revalidateHeaders\n        });\n        await this.handler(mocked.req, mocked.res);\n        await mocked.res.hasStreamed;\n        if (mocked.res.getHeader('x-nextjs-cache') !== 'REVALIDATED' && mocked.res.statusCode !== 200 && !(mocked.res.statusCode === 404 && revalidateOpts.unstable_onlyGenerated)) {\n            throw Object.defineProperty(new Error(`Invalid response ${mocked.res.statusCode}`), \"__NEXT_ERROR_CODE\", {\n                value: \"E175\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n        return {};\n    }\n    get appIsrManifest() {\n        const serializableManifest = {};\n        for (const key of this.appIsrManifestInner.keys()){\n            serializableManifest[key] = this.appIsrManifestInner.get(key);\n        }\n        return serializableManifest;\n    }\n    setIsrStatus(key, value) {\n        var _this_bundler_hotReloader, _this_bundler;\n        if (value === null) {\n            this.appIsrManifestInner.remove(key);\n        } else {\n            this.appIsrManifestInner.set(key, value);\n        }\n        (_this_bundler = this.bundler) == null ? void 0 : (_this_bundler_hotReloader = _this_bundler.hotReloader) == null ? void 0 : _this_bundler_hotReloader.send({\n            action: HMR_ACTIONS_SENT_TO_BROWSER.ISR_MANIFEST,\n            data: this.appIsrManifest\n        });\n    }\n    close() {\n        this.bundler.hotReloader.close();\n    }\n}\n\n//# sourceMappingURL=dev-bundler-service.js.map"
        }
    ]
}