{
    "sourceFile": "node_modules/next/dist/esm/server/lib/router-utils/resolve-routes.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892832684,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import url from 'url';\nimport path from 'node:path';\nimport setupDebug from 'next/dist/compiled/debug';\nimport { getCloneableBody } from '../../body-streams';\nimport { filterReqHeaders, ipcForbiddenHeaders } from '../server-ipc/utils';\nimport { stringifyQuery } from '../../server-route-utils';\nimport { formatHostname } from '../format-hostname';\nimport { toNodeOutgoingHttpHeaders } from '../../web/utils';\nimport { isAbortError } from '../../pipe-readable';\nimport { getHostname } from '../../../shared/lib/get-hostname';\nimport { getRedirectStatus } from '../../../lib/redirect-status';\nimport { normalizeRepeatedSlashes } from '../../../shared/lib/utils';\nimport { getRelativeURL } from '../../../shared/lib/router/utils/relativize-url';\nimport { addPathPrefix } from '../../../shared/lib/router/utils/add-path-prefix';\nimport { pathHasPrefix } from '../../../shared/lib/router/utils/path-has-prefix';\nimport { detectDomainLocale } from '../../../shared/lib/i18n/detect-domain-locale';\nimport { normalizeLocalePath } from '../../../shared/lib/i18n/normalize-locale-path';\nimport { removePathPrefix } from '../../../shared/lib/router/utils/remove-path-prefix';\nimport { NextDataPathnameNormalizer } from '../../normalizers/request/next-data';\nimport { BasePathPathnameNormalizer } from '../../normalizers/request/base-path';\nimport { addRequestMeta } from '../../request-meta';\nimport { compileNonPath, matchHas, parseDestination, prepareDestination } from '../../../shared/lib/router/utils/prepare-destination';\nimport { NEXT_REWRITTEN_PATH_HEADER, NEXT_REWRITTEN_QUERY_HEADER, NEXT_ROUTER_STATE_TREE_HEADER, RSC_HEADER } from '../../../client/components/app-router-headers';\nimport { getSelectedParams } from '../../../client/components/router-reducer/compute-changed-path';\nimport { isInterceptionRouteRewrite } from '../../../lib/generate-interception-routes-rewrites';\nimport { parseAndValidateFlightRouterState } from '../../app-render/parse-and-validate-flight-router-state';\nconst debug = setupDebug('next:router-server:resolve-routes');\nexport function getResolveRoutes(fsChecker, config, opts, renderServer, renderServerOpts, ensureMiddleware) {\n    const routes = [\n        // _next/data with middleware handling\n        {\n            match: ()=>({}),\n            name: 'middleware_next_data'\n        },\n        ...opts.minimalMode ? [] : fsChecker.headers,\n        ...opts.minimalMode ? [] : fsChecker.redirects,\n        // check middleware (using matchers)\n        {\n            match: ()=>({}),\n            name: 'middleware'\n        },\n        ...opts.minimalMode ? [] : fsChecker.rewrites.beforeFiles,\n        // check middleware (using matchers)\n        {\n            match: ()=>({}),\n            name: 'before_files_end'\n        },\n        // we check exact matches on fs before continuing to\n        // after files rewrites\n        {\n            match: ()=>({}),\n            name: 'check_fs'\n        },\n        ...opts.minimalMode ? [] : fsChecker.rewrites.afterFiles,\n        // we always do the check: true handling before continuing to\n        // fallback rewrites\n        {\n            check: true,\n            match: ()=>({}),\n            name: 'after files check: true'\n        },\n        ...opts.minimalMode ? [] : fsChecker.rewrites.fallback\n    ];\n    async function resolveRoutes({ req, res, isUpgradeReq, invokedOutputs }) {\n        var _req_socket, _req_headers_xforwardedproto;\n        let finished = false;\n        let resHeaders = {};\n        let matchedOutput = null;\n        let parsedUrl = url.parse(req.url || '', true);\n        let didRewrite = false;\n        const urlParts = (req.url || '').split('?', 1);\n        const urlNoQuery = urlParts[0];\n        // this normalizes repeated slashes in the path e.g. hello//world ->\n        // hello/world or backslashes to forward slashes, this does not\n        // handle trailing slash as that is handled the same as a next.config.js\n        // redirect\n        if (urlNoQuery == null ? void 0 : urlNoQuery.match(/(\\\\|\\/\\/)/)) {\n            parsedUrl = url.parse(normalizeRepeatedSlashes(req.url), true);\n            return {\n                parsedUrl,\n                resHeaders,\n                finished: true,\n                statusCode: 308\n            };\n        }\n        // TODO: inherit this from higher up\n        const protocol = (req == null ? void 0 : (_req_socket = req.socket) == null ? void 0 : _req_socket.encrypted) || ((_req_headers_xforwardedproto = req.headers['x-forwarded-proto']) == null ? void 0 : _req_headers_xforwardedproto.includes('https')) ? 'https' : 'http';\n        // When there are hostname and port we build an absolute URL\n        const initUrl = config.experimental.trustHostHeader ? `https://${req.headers.host || 'localhost'}${req.url}` : opts.port ? `${protocol}://${formatHostname(opts.hostname || 'localhost')}:${opts.port}${req.url}` : req.url || '';\n        addRequestMeta(req, 'initURL', initUrl);\n        addRequestMeta(req, 'initQuery', {\n            ...parsedUrl.query\n        });\n        addRequestMeta(req, 'initProtocol', protocol);\n        if (!isUpgradeReq) {\n            addRequestMeta(req, 'clonableBody', getCloneableBody(req));\n        }\n        const maybeAddTrailingSlash = (pathname)=>{\n            if (config.trailingSlash && !config.skipMiddlewareUrlNormalize && !pathname.endsWith('/')) {\n                return `${pathname}/`;\n            }\n            return pathname;\n        };\n        let domainLocale;\n        let defaultLocale;\n        let initialLocaleResult = undefined;\n        if (config.i18n) {\n            var _parsedUrl_pathname;\n            const hadTrailingSlash = (_parsedUrl_pathname = parsedUrl.pathname) == null ? void 0 : _parsedUrl_pathname.endsWith('/');\n            const hadBasePath = pathHasPrefix(parsedUrl.pathname || '', config.basePath);\n            initialLocaleResult = normalizeLocalePath(removePathPrefix(parsedUrl.pathname || '/', config.basePath), config.i18n.locales);\n            domainLocale = detectDomainLocale(config.i18n.domains, getHostname(parsedUrl, req.headers));\n            defaultLocale = (domainLocale == null ? void 0 : domainLocale.defaultLocale) || config.i18n.defaultLocale;\n            addRequestMeta(req, 'defaultLocale', defaultLocale);\n            addRequestMeta(req, 'locale', initialLocaleResult.detectedLocale || defaultLocale);\n            // ensure locale is present for resolving routes\n            if (!initialLocaleResult.detectedLocale && !initialLocaleResult.pathname.startsWith('/_next/')) {\n                parsedUrl.pathname = addPathPrefix(initialLocaleResult.pathname === '/' ? `/${defaultLocale}` : addPathPrefix(initialLocaleResult.pathname || '', `/${defaultLocale}`), hadBasePath ? config.basePath : '');\n                if (hadTrailingSlash) {\n                    parsedUrl.pathname = maybeAddTrailingSlash(parsedUrl.pathname);\n                }\n            }\n        }\n        const checkLocaleApi = (pathname)=>{\n            if (config.i18n && pathname === urlNoQuery && (initialLocaleResult == null ? void 0 : initialLocaleResult.detectedLocale) && pathHasPrefix(initialLocaleResult.pathname, '/api')) {\n                return true;\n            }\n        };\n        async function checkTrue() {\n            const pathname = parsedUrl.pathname || '';\n            if (checkLocaleApi(pathname)) {\n                return;\n            }\n            if (!(invokedOutputs == null ? void 0 : invokedOutputs.has(pathname))) {\n                const output = await fsChecker.getItem(pathname);\n                if (output) {\n                    if (config.useFileSystemPublicRoutes || didRewrite || output.type !== 'appFile' && output.type !== 'pageFile') {\n                        return output;\n                    }\n                }\n            }\n            const dynamicRoutes = fsChecker.getDynamicRoutes();\n            let curPathname = parsedUrl.pathname;\n            if (config.basePath) {\n                if (!pathHasPrefix(curPathname || '', config.basePath)) {\n                    return;\n                }\n                curPathname = (curPathname == null ? void 0 : curPathname.substring(config.basePath.length)) || '/';\n            }\n            const localeResult = fsChecker.handleLocale(curPathname || '');\n            for (const route of dynamicRoutes){\n                // when resolving fallback: false the\n                // render worker may return a no-fallback response\n                // which signals we need to continue resolving.\n                // TODO: optimize this to collect static paths\n                // to use at the routing layer\n                if (invokedOutputs == null ? void 0 : invokedOutputs.has(route.page)) {\n                    continue;\n                }\n                const params = route.match(localeResult.pathname);\n                if (params) {\n                    const pageOutput = await fsChecker.getItem(addPathPrefix(route.page, config.basePath || ''));\n                    // i18n locales aren't matched for app dir\n                    if ((pageOutput == null ? void 0 : pageOutput.type) === 'appFile' && (initialLocaleResult == null ? void 0 : initialLocaleResult.detectedLocale)) {\n                        continue;\n                    }\n                    if (pageOutput && (curPathname == null ? void 0 : curPathname.startsWith('/_next/data'))) {\n                        addRequestMeta(req, 'isNextDataReq', true);\n                    }\n                    if (config.useFileSystemPublicRoutes || didRewrite) {\n                        return pageOutput;\n                    }\n                }\n            }\n        }\n        const normalizers = {\n            basePath: config.basePath && config.basePath !== '/' ? new BasePathPathnameNormalizer(config.basePath) : undefined,\n            data: new NextDataPathnameNormalizer(fsChecker.buildId)\n        };\n        async function handleRoute(route) {\n            let curPathname = parsedUrl.pathname || '/';\n            if (config.i18n && route.internal) {\n                const hadTrailingSlash = curPathname.endsWith('/');\n                if (config.basePath) {\n                    curPathname = removePathPrefix(curPathname, config.basePath);\n                }\n                const hadBasePath = curPathname !== parsedUrl.pathname;\n                const localeResult = normalizeLocalePath(curPathname, config.i18n.locales);\n                const isDefaultLocale = localeResult.detectedLocale === defaultLocale;\n                if (isDefaultLocale) {\n                    curPathname = localeResult.pathname === '/' && hadBasePath ? config.basePath : addPathPrefix(localeResult.pathname, hadBasePath ? config.basePath : '');\n                } else if (hadBasePath) {\n                    curPathname = curPathname === '/' ? config.basePath : addPathPrefix(curPathname, config.basePath);\n                }\n                if ((isDefaultLocale || hadBasePath) && hadTrailingSlash) {\n                    curPathname = maybeAddTrailingSlash(curPathname);\n                }\n            }\n            let params = route.match(curPathname);\n            if ((route.has || route.missing) && params) {\n                const hasParams = matchHas(req, parsedUrl.query, route.has, route.missing);\n                if (hasParams) {\n                    Object.assign(params, hasParams);\n                } else {\n                    params = false;\n                }\n            }\n            if (params) {\n                if (fsChecker.exportPathMapRoutes && route.name === 'before_files_end') {\n                    for (const exportPathMapRoute of fsChecker.exportPathMapRoutes){\n                        const result = await handleRoute(exportPathMapRoute);\n                        if (result) {\n                            return result;\n                        }\n                    }\n                }\n                if (route.name === 'middleware_next_data' && parsedUrl.pathname) {\n                    var _fsChecker_getMiddlewareMatchers;\n                    if ((_fsChecker_getMiddlewareMatchers = fsChecker.getMiddlewareMatchers()) == null ? void 0 : _fsChecker_getMiddlewareMatchers.length) {\n                        var _normalizers_basePath;\n                        let normalized = parsedUrl.pathname;\n                        // Remove the base path if it exists.\n                        const hadBasePath = (_normalizers_basePath = normalizers.basePath) == null ? void 0 : _normalizers_basePath.match(parsedUrl.pathname);\n                        if (hadBasePath && normalizers.basePath) {\n                            normalized = normalizers.basePath.normalize(normalized, true);\n                        }\n                        let updated = false;\n                        if (normalizers.data.match(normalized)) {\n                            updated = true;\n                            addRequestMeta(req, 'isNextDataReq', true);\n                            normalized = normalizers.data.normalize(normalized, true);\n                        }\n                        if (config.i18n) {\n                            const curLocaleResult = normalizeLocalePath(normalized, config.i18n.locales);\n                            if (curLocaleResult.detectedLocale) {\n                                addRequestMeta(req, 'locale', curLocaleResult.detectedLocale);\n                            }\n                        }\n                        // If we updated the pathname, and it had a base path, re-add the\n                        // base path.\n                        if (updated) {\n                            if (hadBasePath) {\n                                normalized = path.posix.join(config.basePath, normalized);\n                            }\n                            // Re-add the trailing slash (if required).\n                            normalized = maybeAddTrailingSlash(normalized);\n                            parsedUrl.pathname = normalized;\n                        }\n                    }\n                }\n                if (route.name === 'check_fs') {\n                    const pathname = parsedUrl.pathname || '';\n                    if ((invokedOutputs == null ? void 0 : invokedOutputs.has(pathname)) || checkLocaleApi(pathname)) {\n                        return;\n                    }\n                    const output = await fsChecker.getItem(pathname);\n                    if (output && !(config.i18n && (initialLocaleResult == null ? void 0 : initialLocaleResult.detectedLocale) && pathHasPrefix(pathname, '/api'))) {\n                        if (config.useFileSystemPublicRoutes || didRewrite || output.type !== 'appFile' && output.type !== 'pageFile') {\n                            matchedOutput = output;\n                            if (output.locale) {\n                                addRequestMeta(req, 'locale', output.locale);\n                            }\n                            return {\n                                parsedUrl,\n                                resHeaders,\n                                finished: true,\n                                matchedOutput\n                            };\n                        }\n                    }\n                }\n                if (!opts.minimalMode && route.name === 'middleware') {\n                    const match = fsChecker.getMiddlewareMatchers();\n                    if (// @ts-expect-error BaseNextRequest stuff\n                    match == null ? void 0 : match(parsedUrl.pathname, req, parsedUrl.query)) {\n                        if (ensureMiddleware) {\n                            await ensureMiddleware(req.url);\n                        }\n                        const serverResult = await (renderServer == null ? void 0 : renderServer.initialize(renderServerOpts));\n                        if (!serverResult) {\n                            throw Object.defineProperty(new Error(`Failed to initialize render server \"middleware\"`), \"__NEXT_ERROR_CODE\", {\n                                value: \"E222\",\n                                enumerable: false,\n                                configurable: true\n                            });\n                        }\n                        addRequestMeta(req, 'invokePath', '');\n                        addRequestMeta(req, 'invokeOutput', '');\n                        addRequestMeta(req, 'invokeQuery', {});\n                        addRequestMeta(req, 'middlewareInvoke', true);\n                        debug('invoking middleware', req.url, req.headers);\n                        let middlewareRes = undefined;\n                        let bodyStream = undefined;\n                        try {\n                            try {\n                                await serverResult.requestHandler(req, res, parsedUrl);\n                            } catch (err) {\n                                if (!('result' in err) || !('response' in err.result)) {\n                                    throw err;\n                                }\n                                middlewareRes = err.result.response;\n                                res.statusCode = middlewareRes.status;\n                                if (middlewareRes.body) {\n                                    bodyStream = middlewareRes.body;\n                                } else if (middlewareRes.status) {\n                                    bodyStream = new ReadableStream({\n                                        start (controller) {\n                                            controller.enqueue('');\n                                            controller.close();\n                                        }\n                                    });\n                                }\n                            }\n                        } catch (e) {\n                            // If the client aborts before we can receive a response object\n                            // (when the headers are flushed), then we can early exit without\n                            // further processing.\n                            if (isAbortError(e)) {\n                                return {\n                                    parsedUrl,\n                                    resHeaders,\n                                    finished: true\n                                };\n                            }\n                            throw e;\n                        }\n                        if (res.closed || res.finished || !middlewareRes) {\n                            return {\n                                parsedUrl,\n                                resHeaders,\n                                finished: true\n                            };\n                        }\n                        const middlewareHeaders = toNodeOutgoingHttpHeaders(middlewareRes.headers);\n                        debug('middleware res', middlewareRes.status, middlewareHeaders);\n                        if (middlewareHeaders['x-middleware-override-headers']) {\n                            const overriddenHeaders = new Set();\n                            let overrideHeaders = middlewareHeaders['x-middleware-override-headers'];\n                            if (typeof overrideHeaders === 'string') {\n                                overrideHeaders = overrideHeaders.split(',');\n                            }\n                            for (const key of overrideHeaders){\n                                overriddenHeaders.add(key.trim());\n                            }\n                            delete middlewareHeaders['x-middleware-override-headers'];\n                            // Delete headers.\n                            for (const key of Object.keys(req.headers)){\n                                if (!overriddenHeaders.has(key)) {\n                                    delete req.headers[key];\n                                }\n                            }\n                            // Update or add headers.\n                            for (const key of overriddenHeaders.keys()){\n                                const valueKey = 'x-middleware-request-' + key;\n                                const newValue = middlewareHeaders[valueKey];\n                                const oldValue = req.headers[key];\n                                if (oldValue !== newValue) {\n                                    req.headers[key] = newValue === null ? undefined : newValue;\n                                }\n                                delete middlewareHeaders[valueKey];\n                            }\n                        }\n                        if (!middlewareHeaders['x-middleware-rewrite'] && !middlewareHeaders['x-middleware-next'] && !middlewareHeaders['location']) {\n                            middlewareHeaders['x-middleware-refresh'] = '1';\n                        }\n                        delete middlewareHeaders['x-middleware-next'];\n                        for (const [key, value] of Object.entries({\n                            ...filterReqHeaders(middlewareHeaders, ipcForbiddenHeaders)\n                        })){\n                            if ([\n                                'content-length',\n                                'x-middleware-rewrite',\n                                'x-middleware-redirect',\n                                'x-middleware-refresh'\n                            ].includes(key)) {\n                                continue;\n                            }\n                            // for set-cookie, the header shouldn't be added to the response\n                            // as it's only needed for the request to the middleware function.\n                            if (key === 'x-middleware-set-cookie') {\n                                req.headers[key] = value;\n                                continue;\n                            }\n                            if (value) {\n                                resHeaders[key] = value;\n                                req.headers[key] = value;\n                            }\n                        }\n                        if (middlewareHeaders['x-middleware-rewrite']) {\n                            const value = middlewareHeaders['x-middleware-rewrite'];\n                            const destination = getRelativeURL(value, initUrl);\n                            resHeaders['x-middleware-rewrite'] = destination;\n                            parsedUrl = url.parse(destination, true);\n                            if (parsedUrl.protocol) {\n                                return {\n                                    parsedUrl,\n                                    resHeaders,\n                                    finished: true\n                                };\n                            }\n                            if (config.i18n) {\n                                const curLocaleResult = normalizeLocalePath(parsedUrl.pathname || '', config.i18n.locales);\n                                if (curLocaleResult.detectedLocale) {\n                                    addRequestMeta(req, 'locale', curLocaleResult.detectedLocale);\n                                }\n                            }\n                        }\n                        if (middlewareHeaders['location']) {\n                            const value = middlewareHeaders['location'];\n                            const rel = getRelativeURL(value, initUrl);\n                            resHeaders['location'] = rel;\n                            parsedUrl = url.parse(rel, true);\n                            return {\n                                parsedUrl,\n                                resHeaders,\n                                finished: true,\n                                statusCode: middlewareRes.status\n                            };\n                        }\n                        if (middlewareHeaders['x-middleware-refresh']) {\n                            return {\n                                parsedUrl,\n                                resHeaders,\n                                finished: true,\n                                bodyStream,\n                                statusCode: middlewareRes.status\n                            };\n                        }\n                    }\n                }\n                // handle redirect\n                if (('statusCode' in route || 'permanent' in route) && route.destination) {\n                    const { parsedDestination } = prepareDestination({\n                        appendParamsToQuery: false,\n                        destination: route.destination,\n                        params: params,\n                        query: parsedUrl.query\n                    });\n                    const { query } = parsedDestination;\n                    delete parsedDestination.query;\n                    parsedDestination.search = stringifyQuery(req, query);\n                    parsedDestination.pathname = normalizeRepeatedSlashes(parsedDestination.pathname);\n                    return {\n                        finished: true,\n                        // @ts-expect-error custom ParsedUrl\n                        parsedUrl: parsedDestination,\n                        statusCode: getRedirectStatus(route)\n                    };\n                }\n                // handle headers\n                if (route.headers) {\n                    const hasParams = Object.keys(params).length > 0;\n                    for (const header of route.headers){\n                        let { key, value } = header;\n                        if (hasParams) {\n                            key = compileNonPath(key, params);\n                            value = compileNonPath(value, params);\n                        }\n                        if (key.toLowerCase() === 'set-cookie') {\n                            if (!Array.isArray(resHeaders[key])) {\n                                const val = resHeaders[key];\n                                resHeaders[key] = typeof val === 'string' ? [\n                                    val\n                                ] : [];\n                            }\n                            ;\n                            resHeaders[key].push(value);\n                        } else {\n                            resHeaders[key] = value;\n                        }\n                    }\n                }\n                // handle rewrite\n                if (route.destination) {\n                    let rewriteParams = params;\n                    try {\n                        // An interception rewrite might reference a dynamic param for a route the user\n                        // is currently on, which wouldn't be extractable from the matched route params.\n                        // This attempts to extract the dynamic params from the provided router state.\n                        if (isInterceptionRouteRewrite(route)) {\n                            const stateHeader = req.headers[NEXT_ROUTER_STATE_TREE_HEADER.toLowerCase()];\n                            if (stateHeader) {\n                                rewriteParams = {\n                                    ...getSelectedParams(parseAndValidateFlightRouterState(stateHeader)),\n                                    ...params\n                                };\n                            }\n                        }\n                    } catch (err) {\n                    // this is a no-op -- we couldn't extract dynamic params from the provided router state,\n                    // so we'll just use the params from the route matcher\n                    }\n                    // We extract the search params of the destination so we can set it on\n                    // the response headers. We don't want to use the following\n                    // `parsedDestination` as the query object is mutated.\n                    const { search: destinationSearch, pathname: destinationPathname } = parseDestination({\n                        destination: route.destination,\n                        params: rewriteParams,\n                        query: parsedUrl.query\n                    });\n                    const { parsedDestination } = prepareDestination({\n                        appendParamsToQuery: true,\n                        destination: route.destination,\n                        params: rewriteParams,\n                        query: parsedUrl.query\n                    });\n                    if (parsedDestination.protocol) {\n                        return {\n                            // @ts-expect-error custom ParsedUrl\n                            parsedUrl: parsedDestination,\n                            finished: true\n                        };\n                    }\n                    // Set the rewrite headers only if this is a RSC request.\n                    if (req.headers[RSC_HEADER.toLowerCase()] === '1') {\n                        // We set the rewritten path and query headers on the response now\n                        // that we know that the it's not an external rewrite.\n                        if (parsedUrl.pathname !== destinationPathname) {\n                            res.setHeader(NEXT_REWRITTEN_PATH_HEADER, destinationPathname);\n                        }\n                        if (destinationSearch) {\n                            res.setHeader(NEXT_REWRITTEN_QUERY_HEADER, // remove the leading ? from the search\n                            destinationSearch.slice(1));\n                        }\n                    }\n                    if (config.i18n) {\n                        const curLocaleResult = normalizeLocalePath(removePathPrefix(parsedDestination.pathname, config.basePath), config.i18n.locales);\n                        if (curLocaleResult.detectedLocale) {\n                            addRequestMeta(req, 'locale', curLocaleResult.detectedLocale);\n                        }\n                    }\n                    didRewrite = true;\n                    parsedUrl.pathname = parsedDestination.pathname;\n                    Object.assign(parsedUrl.query, parsedDestination.query);\n                }\n                // handle check: true\n                if (route.check) {\n                    const output = await checkTrue();\n                    if (output) {\n                        return {\n                            parsedUrl,\n                            resHeaders,\n                            finished: true,\n                            matchedOutput: output\n                        };\n                    }\n                }\n            }\n        }\n        for (const route of routes){\n            const result = await handleRoute(route);\n            if (result) {\n                return result;\n            }\n        }\n        return {\n            finished,\n            parsedUrl,\n            resHeaders,\n            matchedOutput\n        };\n    }\n    return resolveRoutes;\n}\n\n//# sourceMappingURL=resolve-routes.js.map"
        }
    ]
}