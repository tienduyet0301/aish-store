{
    "sourceFile": "node_modules/next/dist/esm/server/lib/router-utils/block-cross-site.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892832243,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import { parseUrl } from '../../../lib/url';\nimport { warnOnce } from '../../../build/output/log';\nimport { isCsrfOriginAllowed } from '../../app-render/csrf-protection';\nfunction warnOrBlockRequest(res, origin, mode) {\n    const originString = origin ? `from ${origin}` : '';\n    if (mode === 'warn') {\n        warnOnce(`Cross origin request detected ${originString} to /_next/* resource. In a future major version of Next.js, you will need to explicitly configure \"allowedDevOrigins\" in next.config to allow this.\\nRead more: https://nextjs.org/docs/app/api-reference/config/next-config-js/allowedDevOrigins`);\n        return false;\n    }\n    warnOnce(`Blocked cross-origin request ${originString} to /_next/* resource. To allow this, configure \"allowedDevOrigins\" in next.config\\nRead more: https://nextjs.org/docs/app/api-reference/config/next-config-js/allowedDevOrigins`);\n    if ('statusCode' in res) {\n        res.statusCode = 403;\n    }\n    res.end('Unauthorized');\n    return true;\n}\nfunction isInternalDevEndpoint(req) {\n    if (!req.url) return false;\n    try {\n        // TODO: We should standardize on a single prefix for this\n        const isMiddlewareRequest = req.url.includes('/__nextjs');\n        const isInternalAsset = req.url.includes('/_next');\n        // Static media requests are excluded, as they might be loaded via CSS and would fail\n        // CORS checks.\n        const isIgnoredRequest = req.url.includes('/_next/image') || req.url.includes('/_next/static/media');\n        return !isIgnoredRequest && (isInternalAsset || isMiddlewareRequest);\n    } catch (err) {\n        return false;\n    }\n}\nexport const blockCrossSite = (req, res, allowedDevOrigins, hostname)=>{\n    // in the future, these will be blocked by default when allowed origins aren't configured.\n    // for now, we warn when allowed origins aren't configured\n    const mode = typeof allowedDevOrigins === 'undefined' ? 'warn' : 'block';\n    const allowedOrigins = [\n        '*.localhost',\n        'localhost',\n        ...allowedDevOrigins || []\n    ];\n    if (hostname) {\n        allowedOrigins.push(hostname);\n    }\n    // only process internal URLs/middleware\n    if (!isInternalDevEndpoint(req)) {\n        return false;\n    }\n    // block non-cors request from cross-site e.g. script tag on\n    // different host\n    if (req.headers['sec-fetch-mode'] === 'no-cors' && req.headers['sec-fetch-site'] === 'cross-site') {\n        return warnOrBlockRequest(res, undefined, mode);\n    }\n    // ensure websocket requests from allowed origin\n    const rawOrigin = req.headers['origin'];\n    if (rawOrigin) {\n        const parsedOrigin = parseUrl(rawOrigin);\n        if (parsedOrigin) {\n            const originLowerCase = parsedOrigin.hostname.toLowerCase();\n            if (!isCsrfOriginAllowed(originLowerCase, allowedOrigins)) {\n                return warnOrBlockRequest(res, originLowerCase, mode);\n            }\n        }\n    }\n    return false;\n};\n\n//# sourceMappingURL=block-cross-site.js.map"
        }
    ]
}