{
    "sourceFile": "node_modules/next/dist/esm/server/lib/router-utils/setup-dev-bundler.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892832800,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import { getPageStaticInfo } from '../../../build/analysis/get-page-static-info';\nimport { createDefineEnv } from '../../../build/swc';\nimport fs from 'fs';\nimport { mkdir } from 'fs/promises';\nimport url from 'url';\nimport path from 'path';\nimport qs from 'querystring';\nimport Watchpack from 'next/dist/compiled/watchpack';\nimport { loadEnvConfig } from '@next/env';\nimport findUp from 'next/dist/compiled/find-up';\nimport { buildCustomRoute } from './filesystem';\nimport * as Log from '../../../build/output/log';\nimport HotReloaderWebpack from '../../dev/hot-reloader-webpack';\nimport { setGlobal } from '../../../trace/shared';\nimport loadJsConfig from '../../../build/load-jsconfig';\nimport { createValidFileMatcher } from '../find-page-file';\nimport { EVENT_BUILD_FEATURE_USAGE, eventCliSession } from '../../../telemetry/events';\nimport { getDefineEnv } from '../../../build/webpack/plugins/define-env-plugin';\nimport { getSortedRoutes } from '../../../shared/lib/router/utils';\nimport { getStaticInfoIncludingLayouts, sortByPageExts } from '../../../build/entries';\nimport { verifyTypeScriptSetup } from '../../../lib/verify-typescript-setup';\nimport { verifyPartytownSetup } from '../../../lib/verify-partytown-setup';\nimport { getRouteRegex } from '../../../shared/lib/router/utils/route-regex';\nimport { normalizeAppPath } from '../../../shared/lib/router/utils/app-paths';\nimport { buildDataRoute } from './build-data-route';\nimport { getRouteMatcher } from '../../../shared/lib/router/utils/route-matcher';\nimport { normalizePathSep } from '../../../shared/lib/page-path/normalize-path-sep';\nimport { createClientRouterFilter } from '../../../lib/create-client-router-filter';\nimport { absolutePathToPage } from '../../../shared/lib/page-path/absolute-path-to-page';\nimport { generateInterceptionRoutesRewrites } from '../../../lib/generate-interception-routes-rewrites';\nimport { CLIENT_STATIC_FILES_PATH, DEV_CLIENT_PAGES_MANIFEST, DEV_CLIENT_MIDDLEWARE_MANIFEST, PHASE_DEVELOPMENT_SERVER, TURBOPACK_CLIENT_MIDDLEWARE_MANIFEST } from '../../../shared/lib/constants';\nimport { getMiddlewareRouteMatcher } from '../../../shared/lib/router/utils/middleware-route-matcher';\nimport { isMiddlewareFile, NestedMiddlewareError, isInstrumentationHookFile, getPossibleMiddlewareFilenames, getPossibleInstrumentationHookFilenames } from '../../../build/utils';\nimport { devPageFiles } from '../../../build/webpack/plugins/next-types-plugin/shared';\nimport { HMR_ACTIONS_SENT_TO_BROWSER } from '../../dev/hot-reloader-types';\nimport { PAGE_TYPES } from '../../../lib/page-types';\nimport { createHotReloaderTurbopack } from '../../dev/hot-reloader-turbopack';\nimport { generateEncryptionKeyBase64 } from '../../app-render/encryption-utils-server';\nimport { isMetadataRouteFile } from '../../../lib/metadata/is-metadata-route';\nimport { normalizeMetadataPageToRoute } from '../../../lib/metadata/get-metadata-route';\nimport { createEnvDefinitions } from '../experimental/create-env-definitions';\nimport { JsConfigPathsPlugin } from '../../../build/webpack/plugins/jsconfig-paths-plugin';\nimport { store as consoleStore } from '../../../build/output/store';\nimport { isPersistentCachingEnabled, ModuleBuildError, TurbopackInternalError } from '../../../shared/lib/turbopack/utils';\nasync function verifyTypeScript(opts) {\n    let usingTypeScript = false;\n    const verifyResult = await verifyTypeScriptSetup({\n        dir: opts.dir,\n        distDir: opts.nextConfig.distDir,\n        intentDirs: [\n            opts.pagesDir,\n            opts.appDir\n        ].filter(Boolean),\n        typeCheckPreflight: false,\n        tsconfigPath: opts.nextConfig.typescript.tsconfigPath,\n        disableStaticImages: opts.nextConfig.images.disableStaticImages,\n        hasAppDir: !!opts.appDir,\n        hasPagesDir: !!opts.pagesDir\n    });\n    if (verifyResult.version) {\n        usingTypeScript = true;\n    }\n    return usingTypeScript;\n}\nexport async function propagateServerField(opts, field, args) {\n    var _opts_renderServer_instance, _opts_renderServer;\n    await ((_opts_renderServer = opts.renderServer) == null ? void 0 : (_opts_renderServer_instance = _opts_renderServer.instance) == null ? void 0 : _opts_renderServer_instance.propagateServerField(opts.dir, field, args));\n}\nasync function startWatcher(opts) {\n    const { nextConfig, appDir, pagesDir, dir, resetFetch } = opts;\n    const { useFileSystemPublicRoutes } = nextConfig;\n    const usingTypeScript = await verifyTypeScript(opts);\n    const distDir = path.join(opts.dir, opts.nextConfig.distDir);\n    // we ensure the types directory exists here\n    if (usingTypeScript) {\n        const distTypesDir = path.join(distDir, 'types');\n        if (!fs.existsSync(distTypesDir)) {\n            await mkdir(distTypesDir, {\n                recursive: true\n            });\n        }\n    }\n    setGlobal('distDir', distDir);\n    setGlobal('phase', PHASE_DEVELOPMENT_SERVER);\n    const validFileMatcher = createValidFileMatcher(nextConfig.pageExtensions, appDir);\n    const serverFields = {};\n    // Update logging state once based on next.config.js when initializing\n    consoleStore.setState({\n        logging: nextConfig.logging !== false\n    });\n    const hotReloader = opts.turbo ? await createHotReloaderTurbopack(opts, serverFields, distDir, resetFetch) : new HotReloaderWebpack(opts.dir, {\n        appDir,\n        pagesDir,\n        distDir,\n        config: opts.nextConfig,\n        buildId: 'development',\n        encryptionKey: await generateEncryptionKeyBase64({\n            isBuild: false,\n            distDir\n        }),\n        telemetry: opts.telemetry,\n        rewrites: opts.fsChecker.rewrites,\n        previewProps: opts.fsChecker.prerenderManifest.preview,\n        resetFetch\n    });\n    await hotReloader.start();\n    if (opts.nextConfig.experimental.nextScriptWorkers) {\n        await verifyPartytownSetup(opts.dir, path.join(distDir, CLIENT_STATIC_FILES_PATH));\n    }\n    opts.fsChecker.ensureCallback(async function ensure(item) {\n        if (item.type === 'appFile' || item.type === 'pageFile') {\n            await hotReloader.ensurePage({\n                clientOnly: false,\n                page: item.itemPath,\n                isApp: item.type === 'appFile',\n                definition: undefined\n            });\n        }\n    });\n    let resolved = false;\n    let prevSortedRoutes = [];\n    await new Promise(async (resolve, reject)=>{\n        if (pagesDir) {\n            // Watchpack doesn't emit an event for an empty directory\n            fs.readdir(pagesDir, (_, files)=>{\n                if (files == null ? void 0 : files.length) {\n                    return;\n                }\n                if (!resolved) {\n                    resolve();\n                    resolved = true;\n                }\n            });\n        }\n        const pages = pagesDir ? [\n            pagesDir\n        ] : [];\n        const app = appDir ? [\n            appDir\n        ] : [];\n        const directories = [\n            ...pages,\n            ...app\n        ];\n        const rootDir = pagesDir || appDir;\n        const files = [\n            ...getPossibleMiddlewareFilenames(path.join(rootDir, '..'), nextConfig.pageExtensions),\n            ...getPossibleInstrumentationHookFilenames(path.join(rootDir, '..'), nextConfig.pageExtensions)\n        ];\n        let nestedMiddleware = [];\n        const envFiles = [\n            '.env.development.local',\n            '.env.local',\n            '.env.development',\n            '.env'\n        ].map((file)=>path.join(dir, file));\n        files.push(...envFiles);\n        // tsconfig/jsconfig paths hot-reloading\n        const tsconfigPaths = [\n            path.join(dir, 'tsconfig.json'),\n            path.join(dir, 'jsconfig.json')\n        ];\n        files.push(...tsconfigPaths);\n        const wp = new Watchpack({\n            ignored: (pathname)=>{\n                return !files.some((file)=>file.startsWith(pathname)) && !directories.some((d)=>pathname.startsWith(d) || d.startsWith(pathname));\n            }\n        });\n        const fileWatchTimes = new Map();\n        let enabledTypeScript = usingTypeScript;\n        let previousClientRouterFilters;\n        let previousConflictingPagePaths = new Set();\n        wp.on('aggregated', async ()=>{\n            var _serverFields_middleware, _serverFields_middleware1;\n            let middlewareMatchers;\n            const routedPages = [];\n            const knownFiles = wp.getTimeInfoEntries();\n            const appPaths = {};\n            const pageNameSet = new Set();\n            const conflictingAppPagePaths = new Set();\n            const appPageFilePaths = new Map();\n            const pagesPageFilePaths = new Map();\n            let envChange = false;\n            let tsconfigChange = false;\n            let conflictingPageChange = 0;\n            let hasRootAppNotFound = false;\n            const { appFiles, pageFiles } = opts.fsChecker;\n            appFiles.clear();\n            pageFiles.clear();\n            devPageFiles.clear();\n            const sortedKnownFiles = [\n                ...knownFiles.keys()\n            ].sort(sortByPageExts(nextConfig.pageExtensions));\n            for (const fileName of sortedKnownFiles){\n                if (!files.includes(fileName) && !directories.some((d)=>fileName.startsWith(d))) {\n                    continue;\n                }\n                const meta = knownFiles.get(fileName);\n                const watchTime = fileWatchTimes.get(fileName);\n                // If the file is showing up for the first time or the meta.timestamp is changed since last time\n                const watchTimeChange = watchTime === undefined || watchTime && watchTime !== (meta == null ? void 0 : meta.timestamp);\n                fileWatchTimes.set(fileName, meta == null ? void 0 : meta.timestamp);\n                if (envFiles.includes(fileName)) {\n                    if (watchTimeChange) {\n                        envChange = true;\n                    }\n                    continue;\n                }\n                if (tsconfigPaths.includes(fileName)) {\n                    if (fileName.endsWith('tsconfig.json')) {\n                        enabledTypeScript = true;\n                    }\n                    if (watchTimeChange) {\n                        tsconfigChange = true;\n                    }\n                    continue;\n                }\n                if ((meta == null ? void 0 : meta.accuracy) === undefined || !validFileMatcher.isPageFile(fileName)) {\n                    continue;\n                }\n                const isAppPath = Boolean(appDir && normalizePathSep(fileName).startsWith(normalizePathSep(appDir) + '/'));\n                const isPagePath = Boolean(pagesDir && normalizePathSep(fileName).startsWith(normalizePathSep(pagesDir) + '/'));\n                const rootFile = absolutePathToPage(fileName, {\n                    dir: dir,\n                    extensions: nextConfig.pageExtensions,\n                    keepIndex: false,\n                    pagesType: PAGE_TYPES.ROOT\n                });\n                if (isMiddlewareFile(rootFile)) {\n                    var _staticInfo_middleware;\n                    const staticInfo = await getStaticInfoIncludingLayouts({\n                        pageFilePath: fileName,\n                        config: nextConfig,\n                        appDir: appDir,\n                        page: rootFile,\n                        isDev: true,\n                        isInsideAppDir: isAppPath,\n                        pageExtensions: nextConfig.pageExtensions\n                    });\n                    if (nextConfig.output === 'export') {\n                        Log.error('Middleware cannot be used with \"output: export\". See more info here: https://nextjs.org/docs/advanced-features/static-html-export');\n                        continue;\n                    }\n                    serverFields.actualMiddlewareFile = rootFile;\n                    await propagateServerField(opts, 'actualMiddlewareFile', serverFields.actualMiddlewareFile);\n                    middlewareMatchers = ((_staticInfo_middleware = staticInfo.middleware) == null ? void 0 : _staticInfo_middleware.matchers) || [\n                        {\n                            regexp: '.*',\n                            originalSource: '/:path*'\n                        }\n                    ];\n                    continue;\n                }\n                if (isInstrumentationHookFile(rootFile)) {\n                    serverFields.actualInstrumentationHookFile = rootFile;\n                    await propagateServerField(opts, 'actualInstrumentationHookFile', serverFields.actualInstrumentationHookFile);\n                    continue;\n                }\n                if (fileName.endsWith('.ts') || fileName.endsWith('.tsx')) {\n                    enabledTypeScript = true;\n                }\n                if (!(isAppPath || isPagePath)) {\n                    continue;\n                }\n                // Collect all current filenames for the TS plugin to use\n                devPageFiles.add(fileName);\n                let pageName = absolutePathToPage(fileName, {\n                    dir: isAppPath ? appDir : pagesDir,\n                    extensions: nextConfig.pageExtensions,\n                    keepIndex: isAppPath,\n                    pagesType: isAppPath ? PAGE_TYPES.APP : PAGE_TYPES.PAGES\n                });\n                if (isAppPath && appDir && isMetadataRouteFile(fileName.replace(appDir, ''), nextConfig.pageExtensions, true)) {\n                    const staticInfo = await getPageStaticInfo({\n                        pageFilePath: fileName,\n                        nextConfig: {},\n                        page: pageName,\n                        isDev: true,\n                        pageType: PAGE_TYPES.APP\n                    });\n                    pageName = normalizeMetadataPageToRoute(pageName, !!(staticInfo.generateSitemaps || staticInfo.generateImageMetadata));\n                }\n                if (!isAppPath && pageName.startsWith('/api/') && nextConfig.output === 'export') {\n                    Log.error('API Routes cannot be used with \"output: export\". See more info here: https://nextjs.org/docs/advanced-features/static-html-export');\n                    continue;\n                }\n                if (isAppPath) {\n                    const isRootNotFound = validFileMatcher.isRootNotFound(fileName);\n                    hasRootAppNotFound = true;\n                    if (isRootNotFound) {\n                        continue;\n                    }\n                    if (!isRootNotFound && !validFileMatcher.isAppRouterPage(fileName)) {\n                        continue;\n                    }\n                    // Ignore files/directories starting with `_` in the app directory\n                    if (normalizePathSep(pageName).includes('/_')) {\n                        continue;\n                    }\n                    const originalPageName = pageName;\n                    pageName = normalizeAppPath(pageName).replace(/%5F/g, '_');\n                    if (!appPaths[pageName]) {\n                        appPaths[pageName] = [];\n                    }\n                    appPaths[pageName].push(originalPageName);\n                    if (useFileSystemPublicRoutes) {\n                        appFiles.add(pageName);\n                    }\n                    if (routedPages.includes(pageName)) {\n                        continue;\n                    }\n                } else {\n                    if (useFileSystemPublicRoutes) {\n                        pageFiles.add(pageName);\n                        // always add to nextDataRoutes for now but in future only add\n                        // entries that actually use getStaticProps/getServerSideProps\n                        opts.fsChecker.nextDataRoutes.add(pageName);\n                    }\n                }\n                ;\n                (isAppPath ? appPageFilePaths : pagesPageFilePaths).set(pageName, fileName);\n                if (appDir && pageNameSet.has(pageName)) {\n                    conflictingAppPagePaths.add(pageName);\n                } else {\n                    pageNameSet.add(pageName);\n                }\n                /**\n         * If there is a middleware that is not declared in the root we will\n         * warn without adding it so it doesn't make its way into the system.\n         */ if (/[\\\\\\\\/]_middleware$/.test(pageName)) {\n                    nestedMiddleware.push(pageName);\n                    continue;\n                }\n                routedPages.push(pageName);\n            }\n            const numConflicting = conflictingAppPagePaths.size;\n            conflictingPageChange = numConflicting - previousConflictingPagePaths.size;\n            if (conflictingPageChange !== 0) {\n                if (numConflicting > 0) {\n                    let errorMessage = `Conflicting app and page file${numConflicting === 1 ? ' was' : 's were'} found, please remove the conflicting files to continue:\\n`;\n                    for (const p of conflictingAppPagePaths){\n                        const appPath = path.relative(dir, appPageFilePaths.get(p));\n                        const pagesPath = path.relative(dir, pagesPageFilePaths.get(p));\n                        errorMessage += `  \"${pagesPath}\" - \"${appPath}\"\\n`;\n                    }\n                    hotReloader.setHmrServerError(Object.defineProperty(new Error(errorMessage), \"__NEXT_ERROR_CODE\", {\n                        value: \"E394\",\n                        enumerable: false,\n                        configurable: true\n                    }));\n                } else if (numConflicting === 0) {\n                    hotReloader.clearHmrServerError();\n                    await propagateServerField(opts, 'reloadMatchers', undefined);\n                }\n            }\n            previousConflictingPagePaths = conflictingAppPagePaths;\n            let clientRouterFilters;\n            if (nextConfig.experimental.clientRouterFilter) {\n                clientRouterFilters = createClientRouterFilter(Object.keys(appPaths), nextConfig.experimental.clientRouterFilterRedirects ? (nextConfig._originalRedirects || []).filter((r)=>!r.internal) : [], nextConfig.experimental.clientRouterFilterAllowedRate);\n                if (!previousClientRouterFilters || JSON.stringify(previousClientRouterFilters) !== JSON.stringify(clientRouterFilters)) {\n                    envChange = true;\n                    previousClientRouterFilters = clientRouterFilters;\n                }\n            }\n            if (!usingTypeScript && enabledTypeScript) {\n                // we tolerate the error here as this is best effort\n                // and the manual install command will be shown\n                await verifyTypeScript(opts).then(()=>{\n                    tsconfigChange = true;\n                }).catch(()=>{});\n            }\n            if (envChange || tsconfigChange) {\n                var _hotReloader_activeWebpackConfigs;\n                if (envChange) {\n                    var _nextConfig_experimental;\n                    const { loadedEnvFiles } = loadEnvConfig(dir, process.env.NODE_ENV === 'development', Log, true, (envFilePath)=>{\n                        Log.info(`Reload env: ${envFilePath}`);\n                    });\n                    if (usingTypeScript && ((_nextConfig_experimental = nextConfig.experimental) == null ? void 0 : _nextConfig_experimental.typedEnv)) {\n                        // do not await, this is not essential for further process\n                        createEnvDefinitions({\n                            distDir,\n                            loadedEnvFiles: [\n                                ...loadedEnvFiles,\n                                {\n                                    path: nextConfig.configFileName,\n                                    env: nextConfig.env,\n                                    contents: ''\n                                }\n                            ]\n                        });\n                    }\n                    await propagateServerField(opts, 'loadEnvConfig', [\n                        {\n                            dev: true,\n                            forceReload: true,\n                            silent: true\n                        }\n                    ]);\n                }\n                let tsconfigResult;\n                if (tsconfigChange) {\n                    try {\n                        tsconfigResult = await loadJsConfig(dir, nextConfig);\n                    } catch (_) {\n                    /* do we want to log if there are syntax errors in tsconfig while editing? */ }\n                }\n                if (hotReloader.turbopackProject) {\n                    const hasRewrites = opts.fsChecker.rewrites.afterFiles.length > 0 || opts.fsChecker.rewrites.beforeFiles.length > 0 || opts.fsChecker.rewrites.fallback.length > 0;\n                    await hotReloader.turbopackProject.update({\n                        defineEnv: createDefineEnv({\n                            isTurbopack: true,\n                            clientRouterFilters,\n                            config: nextConfig,\n                            dev: true,\n                            distDir,\n                            fetchCacheKeyPrefix: opts.nextConfig.experimental.fetchCacheKeyPrefix,\n                            hasRewrites,\n                            // TODO: Implement\n                            middlewareMatchers: undefined\n                        })\n                    });\n                }\n                (_hotReloader_activeWebpackConfigs = hotReloader.activeWebpackConfigs) == null ? void 0 : _hotReloader_activeWebpackConfigs.forEach((config, idx)=>{\n                    const isClient = idx === 0;\n                    const isNodeServer = idx === 1;\n                    const isEdgeServer = idx === 2;\n                    const hasRewrites = opts.fsChecker.rewrites.afterFiles.length > 0 || opts.fsChecker.rewrites.beforeFiles.length > 0 || opts.fsChecker.rewrites.fallback.length > 0;\n                    if (tsconfigChange) {\n                        var _config_resolve_plugins, _config_resolve;\n                        (_config_resolve = config.resolve) == null ? void 0 : (_config_resolve_plugins = _config_resolve.plugins) == null ? void 0 : _config_resolve_plugins.forEach((plugin)=>{\n                            // look for the JsConfigPathsPlugin and update with\n                            // the latest paths/baseUrl config\n                            if (plugin instanceof JsConfigPathsPlugin && tsconfigResult) {\n                                var _config_resolve_modules, _config_resolve, _jsConfig_compilerOptions;\n                                const { resolvedBaseUrl, jsConfig } = tsconfigResult;\n                                const currentResolvedBaseUrl = plugin.resolvedBaseUrl;\n                                const resolvedUrlIndex = (_config_resolve = config.resolve) == null ? void 0 : (_config_resolve_modules = _config_resolve.modules) == null ? void 0 : _config_resolve_modules.findIndex((item)=>item === (currentResolvedBaseUrl == null ? void 0 : currentResolvedBaseUrl.baseUrl));\n                                if (resolvedBaseUrl) {\n                                    if (resolvedBaseUrl.baseUrl !== (currentResolvedBaseUrl == null ? void 0 : currentResolvedBaseUrl.baseUrl)) {\n                                        // remove old baseUrl and add new one\n                                        if (resolvedUrlIndex && resolvedUrlIndex > -1) {\n                                            var _config_resolve_modules1, _config_resolve1;\n                                            (_config_resolve1 = config.resolve) == null ? void 0 : (_config_resolve_modules1 = _config_resolve1.modules) == null ? void 0 : _config_resolve_modules1.splice(resolvedUrlIndex, 1);\n                                        }\n                                        // If the resolvedBaseUrl is implicit we only remove the previous value.\n                                        // Only add the baseUrl if it's explicitly set in tsconfig/jsconfig\n                                        if (!resolvedBaseUrl.isImplicit) {\n                                            var _config_resolve_modules2, _config_resolve2;\n                                            (_config_resolve2 = config.resolve) == null ? void 0 : (_config_resolve_modules2 = _config_resolve2.modules) == null ? void 0 : _config_resolve_modules2.push(resolvedBaseUrl.baseUrl);\n                                        }\n                                    }\n                                }\n                                if ((jsConfig == null ? void 0 : (_jsConfig_compilerOptions = jsConfig.compilerOptions) == null ? void 0 : _jsConfig_compilerOptions.paths) && resolvedBaseUrl) {\n                                    Object.keys(plugin.paths).forEach((key)=>{\n                                        delete plugin.paths[key];\n                                    });\n                                    Object.assign(plugin.paths, jsConfig.compilerOptions.paths);\n                                    plugin.resolvedBaseUrl = resolvedBaseUrl;\n                                }\n                            }\n                        });\n                    }\n                    if (envChange) {\n                        var _config_plugins;\n                        (_config_plugins = config.plugins) == null ? void 0 : _config_plugins.forEach((plugin)=>{\n                            // we look for the DefinePlugin definitions so we can\n                            // update them on the active compilers\n                            if (plugin && typeof plugin.definitions === 'object' && plugin.definitions.__NEXT_DEFINE_ENV) {\n                                const newDefine = getDefineEnv({\n                                    isTurbopack: false,\n                                    clientRouterFilters,\n                                    config: nextConfig,\n                                    dev: true,\n                                    distDir,\n                                    fetchCacheKeyPrefix: opts.nextConfig.experimental.fetchCacheKeyPrefix,\n                                    hasRewrites,\n                                    isClient,\n                                    isEdgeServer,\n                                    isNodeOrEdgeCompilation: isNodeServer || isEdgeServer,\n                                    isNodeServer,\n                                    middlewareMatchers: undefined\n                                });\n                                Object.keys(plugin.definitions).forEach((key)=>{\n                                    if (!(key in newDefine)) {\n                                        delete plugin.definitions[key];\n                                    }\n                                });\n                                Object.assign(plugin.definitions, newDefine);\n                            }\n                        });\n                    }\n                });\n                await hotReloader.invalidate({\n                    reloadAfterInvalidation: envChange\n                });\n            }\n            if (nestedMiddleware.length > 0) {\n                Log.error(Object.defineProperty(new NestedMiddlewareError(nestedMiddleware, dir, pagesDir || appDir), \"__NEXT_ERROR_CODE\", {\n                    value: \"E394\",\n                    enumerable: false,\n                    configurable: true\n                }).message);\n                nestedMiddleware = [];\n            }\n            // Make sure to sort parallel routes to make the result deterministic.\n            serverFields.appPathRoutes = Object.fromEntries(Object.entries(appPaths).map(([k, v])=>[\n                    k,\n                    v.sort()\n                ]));\n            await propagateServerField(opts, 'appPathRoutes', serverFields.appPathRoutes);\n            // TODO: pass this to fsChecker/next-dev-server?\n            serverFields.middleware = middlewareMatchers ? {\n                match: null,\n                page: '/',\n                matchers: middlewareMatchers\n            } : undefined;\n            await propagateServerField(opts, 'middleware', serverFields.middleware);\n            serverFields.hasAppNotFound = hasRootAppNotFound;\n            opts.fsChecker.middlewareMatcher = ((_serverFields_middleware = serverFields.middleware) == null ? void 0 : _serverFields_middleware.matchers) ? getMiddlewareRouteMatcher((_serverFields_middleware1 = serverFields.middleware) == null ? void 0 : _serverFields_middleware1.matchers) : undefined;\n            const interceptionRoutes = generateInterceptionRoutesRewrites(Object.keys(appPaths), opts.nextConfig.basePath).map((item)=>buildCustomRoute('before_files_rewrite', item, opts.nextConfig.basePath, opts.nextConfig.experimental.caseSensitiveRoutes));\n            opts.fsChecker.rewrites.beforeFiles.push(...interceptionRoutes);\n            const exportPathMap = typeof nextConfig.exportPathMap === 'function' && await (nextConfig.exportPathMap == null ? void 0 : nextConfig.exportPathMap.call(nextConfig, {}, {\n                dev: true,\n                dir: opts.dir,\n                outDir: null,\n                distDir: distDir,\n                buildId: 'development'\n            })) || {};\n            const exportPathMapEntries = Object.entries(exportPathMap || {});\n            if (exportPathMapEntries.length > 0) {\n                opts.fsChecker.exportPathMapRoutes = exportPathMapEntries.map(([key, value])=>buildCustomRoute('before_files_rewrite', {\n                        source: key,\n                        destination: `${value.page}${value.query ? '?' : ''}${qs.stringify(value.query)}`\n                    }, opts.nextConfig.basePath, opts.nextConfig.experimental.caseSensitiveRoutes));\n            }\n            try {\n                // we serve a separate manifest with all pages for the client in\n                // dev mode so that we can match a page after a rewrite on the client\n                // before it has been built and is populated in the _buildManifest\n                const sortedRoutes = getSortedRoutes(routedPages);\n                opts.fsChecker.dynamicRoutes = sortedRoutes.map((page)=>{\n                    const regex = getRouteRegex(page);\n                    return {\n                        regex: regex.re.toString(),\n                        match: getRouteMatcher(regex),\n                        page\n                    };\n                });\n                const dataRoutes = [];\n                for (const page of sortedRoutes){\n                    const route = buildDataRoute(page, 'development');\n                    const routeRegex = getRouteRegex(route.page);\n                    dataRoutes.push({\n                        ...route,\n                        regex: routeRegex.re.toString(),\n                        match: getRouteMatcher({\n                            // TODO: fix this in the manifest itself, must also be fixed in\n                            // upstream builder that relies on this\n                            re: opts.nextConfig.i18n ? new RegExp(route.dataRouteRegex.replace(`/development/`, `/development/(?<nextLocale>[^/]+?)/`)) : new RegExp(route.dataRouteRegex),\n                            groups: routeRegex.groups\n                        })\n                    });\n                }\n                opts.fsChecker.dynamicRoutes.unshift(...dataRoutes);\n                if (!(prevSortedRoutes == null ? void 0 : prevSortedRoutes.every((val, idx)=>val === sortedRoutes[idx]))) {\n                    const addedRoutes = sortedRoutes.filter((route)=>!prevSortedRoutes.includes(route));\n                    const removedRoutes = prevSortedRoutes.filter((route)=>!sortedRoutes.includes(route));\n                    // emit the change so clients fetch the update\n                    hotReloader.send({\n                        action: HMR_ACTIONS_SENT_TO_BROWSER.DEV_PAGES_MANIFEST_UPDATE,\n                        data: [\n                            {\n                                devPagesManifest: true\n                            }\n                        ]\n                    });\n                    addedRoutes.forEach((route)=>{\n                        hotReloader.send({\n                            action: HMR_ACTIONS_SENT_TO_BROWSER.ADDED_PAGE,\n                            data: [\n                                route\n                            ]\n                        });\n                    });\n                    removedRoutes.forEach((route)=>{\n                        hotReloader.send({\n                            action: HMR_ACTIONS_SENT_TO_BROWSER.REMOVED_PAGE,\n                            data: [\n                                route\n                            ]\n                        });\n                    });\n                }\n                prevSortedRoutes = sortedRoutes;\n                if (!resolved) {\n                    resolve();\n                    resolved = true;\n                }\n            } catch (e) {\n                if (!resolved) {\n                    reject(e);\n                    resolved = true;\n                } else {\n                    Log.warn('Failed to reload dynamic routes:', e);\n                }\n            } finally{\n                // Reload the matchers. The filesystem would have been written to,\n                // and the matchers need to re-scan it to update the router.\n                await propagateServerField(opts, 'reloadMatchers', undefined);\n            }\n        });\n        wp.watch({\n            directories: [\n                dir\n            ],\n            startTime: 0\n        });\n    });\n    const clientPagesManifestPath = `/_next/${CLIENT_STATIC_FILES_PATH}/development/${DEV_CLIENT_PAGES_MANIFEST}`;\n    opts.fsChecker.devVirtualFsItems.add(clientPagesManifestPath);\n    const devMiddlewareManifestPath = `/_next/${CLIENT_STATIC_FILES_PATH}/development/${DEV_CLIENT_MIDDLEWARE_MANIFEST}`;\n    opts.fsChecker.devVirtualFsItems.add(devMiddlewareManifestPath);\n    const devTurbopackMiddlewareManifestPath = `/_next/${CLIENT_STATIC_FILES_PATH}/development/${TURBOPACK_CLIENT_MIDDLEWARE_MANIFEST}`;\n    opts.fsChecker.devVirtualFsItems.add(devTurbopackMiddlewareManifestPath);\n    async function requestHandler(req, res) {\n        var _parsedUrl_pathname, _parsedUrl_pathname1, _parsedUrl_pathname2;\n        const parsedUrl = url.parse(req.url || '/');\n        if ((_parsedUrl_pathname = parsedUrl.pathname) == null ? void 0 : _parsedUrl_pathname.includes(clientPagesManifestPath)) {\n            res.statusCode = 200;\n            res.setHeader('Content-Type', 'application/json; charset=utf-8');\n            res.end(JSON.stringify({\n                pages: prevSortedRoutes.filter((route)=>!opts.fsChecker.appFiles.has(route))\n            }));\n            return {\n                finished: true\n            };\n        }\n        if (((_parsedUrl_pathname1 = parsedUrl.pathname) == null ? void 0 : _parsedUrl_pathname1.includes(devMiddlewareManifestPath)) || ((_parsedUrl_pathname2 = parsedUrl.pathname) == null ? void 0 : _parsedUrl_pathname2.includes(devTurbopackMiddlewareManifestPath))) {\n            var _serverFields_middleware;\n            res.statusCode = 200;\n            res.setHeader('Content-Type', 'application/json; charset=utf-8');\n            res.end(JSON.stringify(((_serverFields_middleware = serverFields.middleware) == null ? void 0 : _serverFields_middleware.matchers) || []));\n            return {\n                finished: true\n            };\n        }\n        return {\n            finished: false\n        };\n    }\n    function logErrorWithOriginalStack(err, type) {\n        if (err instanceof ModuleBuildError) {\n            // Errors that may come from issues from the user's code\n            Log.error(err.message);\n        } else if (err instanceof TurbopackInternalError) {\n        // An internal Turbopack error that has been handled by next-swc, written\n        // to disk and a simplified message shown to user on the Rust side.\n        } else if (type === 'warning') {\n            Log.warn(err);\n        } else if (type === 'app-dir') {\n            Log.error(err);\n        } else if (type) {\n            Log.error(`${type}:`, err);\n        } else {\n            Log.error(err);\n        }\n    }\n    return {\n        serverFields,\n        hotReloader,\n        requestHandler,\n        logErrorWithOriginalStack,\n        async ensureMiddleware (requestUrl) {\n            if (!serverFields.actualMiddlewareFile) return;\n            return hotReloader.ensurePage({\n                page: serverFields.actualMiddlewareFile,\n                clientOnly: false,\n                definition: undefined,\n                url: requestUrl\n            });\n        }\n    };\n}\nexport async function setupDevBundler(opts) {\n    const isSrcDir = path.relative(opts.dir, opts.pagesDir || opts.appDir || '').startsWith('src');\n    const result = await startWatcher(opts);\n    opts.telemetry.record(eventCliSession(path.join(opts.dir, opts.nextConfig.distDir), opts.nextConfig, {\n        webpackVersion: 5,\n        isSrcDir,\n        turboFlag: !!opts.turbo,\n        cliCommand: 'dev',\n        appDir: !!opts.appDir,\n        pagesDir: !!opts.pagesDir,\n        isCustomServer: !!opts.isCustomServer,\n        hasNowJson: !!await findUp('now.json', {\n            cwd: opts.dir\n        })\n    }));\n    // Track build features for dev server here:\n    opts.telemetry.record({\n        eventName: EVENT_BUILD_FEATURE_USAGE,\n        payload: {\n            featureName: 'turbopackPersistentCaching',\n            invocationCount: isPersistentCachingEnabled(opts.nextConfig) ? 1 : 0\n        }\n    });\n    return result;\n}\n // Returns a trace rewritten through Turbopack's sourcemaps\n\n//# sourceMappingURL=setup-dev-bundler.js.map"
        }
    ]
}