{
    "sourceFile": "node_modules/next/dist/esm/server/lib/router-utils/filesystem.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892832480,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import path from 'path';\nimport fs from 'fs/promises';\nimport * as Log from '../../../build/output/log';\nimport setupDebug from 'next/dist/compiled/debug';\nimport { LRUCache } from '../lru-cache';\nimport loadCustomRoutes from '../../../lib/load-custom-routes';\nimport { modifyRouteRegex } from '../../../lib/redirect-status';\nimport { FileType, fileExists } from '../../../lib/file-exists';\nimport { recursiveReadDir } from '../../../lib/recursive-readdir';\nimport { isDynamicRoute } from '../../../shared/lib/router/utils';\nimport { escapeStringRegexp } from '../../../shared/lib/escape-regexp';\nimport { getPathMatch } from '../../../shared/lib/router/utils/path-match';\nimport { getRouteRegex } from '../../../shared/lib/router/utils/route-regex';\nimport { getRouteMatcher } from '../../../shared/lib/router/utils/route-matcher';\nimport { pathHasPrefix } from '../../../shared/lib/router/utils/path-has-prefix';\nimport { normalizeLocalePath } from '../../../shared/lib/i18n/normalize-locale-path';\nimport { removePathPrefix } from '../../../shared/lib/router/utils/remove-path-prefix';\nimport { getMiddlewareRouteMatcher } from '../../../shared/lib/router/utils/middleware-route-matcher';\nimport { APP_PATH_ROUTES_MANIFEST, BUILD_ID_FILE, FUNCTIONS_CONFIG_MANIFEST, MIDDLEWARE_MANIFEST, PAGES_MANIFEST, PRERENDER_MANIFEST, ROUTES_MANIFEST } from '../../../shared/lib/constants';\nimport { normalizePathSep } from '../../../shared/lib/page-path/normalize-path-sep';\nimport { normalizeMetadataRoute } from '../../../lib/metadata/get-metadata-route';\nimport { RSCPathnameNormalizer } from '../../normalizers/request/rsc';\nimport { PrefetchRSCPathnameNormalizer } from '../../normalizers/request/prefetch-rsc';\nimport { encodeURIPath } from '../../../shared/lib/encode-uri-path';\nconst debug = setupDebug('next:router-server:filesystem');\nexport const buildCustomRoute = (type, item, basePath, caseSensitive)=>{\n    const restrictedRedirectPaths = [\n        '/_next'\n    ].map((p)=>basePath ? `${basePath}${p}` : p);\n    const match = getPathMatch(item.source, {\n        strict: true,\n        removeUnnamedParams: true,\n        regexModifier: !item.internal ? (regex)=>modifyRouteRegex(regex, type === 'redirect' ? restrictedRedirectPaths : undefined) : undefined,\n        sensitive: caseSensitive\n    });\n    return {\n        ...item,\n        ...type === 'rewrite' ? {\n            check: true\n        } : {},\n        match\n    };\n};\nexport async function setupFsCheck(opts) {\n    const getItemsLru = !opts.dev ? new LRUCache(1024 * 1024, function length(value) {\n        if (!value) return 0;\n        return (value.fsPath || '').length + value.itemPath.length + value.type.length;\n    }) : undefined;\n    // routes that have _next/data endpoints (SSG/SSP)\n    const nextDataRoutes = new Set();\n    const publicFolderItems = new Set();\n    const nextStaticFolderItems = new Set();\n    const legacyStaticFolderItems = new Set();\n    const appFiles = new Set();\n    const pageFiles = new Set();\n    let dynamicRoutes = [];\n    let middlewareMatcher = ()=>false;\n    const distDir = path.join(opts.dir, opts.config.distDir);\n    const publicFolderPath = path.join(opts.dir, 'public');\n    const nextStaticFolderPath = path.join(distDir, 'static');\n    const legacyStaticFolderPath = path.join(opts.dir, 'static');\n    let customRoutes = {\n        redirects: [],\n        rewrites: {\n            beforeFiles: [],\n            afterFiles: [],\n            fallback: []\n        },\n        headers: []\n    };\n    let buildId = 'development';\n    let prerenderManifest;\n    if (!opts.dev) {\n        var _middlewareManifest_middleware_, _middlewareManifest_middleware;\n        const buildIdPath = path.join(opts.dir, opts.config.distDir, BUILD_ID_FILE);\n        try {\n            buildId = await fs.readFile(buildIdPath, 'utf8');\n        } catch (err) {\n            if (err.code !== 'ENOENT') throw err;\n            throw Object.defineProperty(new Error(`Could not find a production build in the '${opts.config.distDir}' directory. Try building your app with 'next build' before starting the production server. https://nextjs.org/docs/messages/production-start-no-build-id`), \"__NEXT_ERROR_CODE\", {\n                value: \"E427\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n        try {\n            for (const file of (await recursiveReadDir(publicFolderPath))){\n                // Ensure filename is encoded and normalized.\n                publicFolderItems.add(encodeURIPath(normalizePathSep(file)));\n            }\n        } catch (err) {\n            if (err.code !== 'ENOENT') {\n                throw err;\n            }\n        }\n        try {\n            for (const file of (await recursiveReadDir(legacyStaticFolderPath))){\n                // Ensure filename is encoded and normalized.\n                legacyStaticFolderItems.add(encodeURIPath(normalizePathSep(file)));\n            }\n            Log.warn(`The static directory has been deprecated in favor of the public directory. https://nextjs.org/docs/messages/static-dir-deprecated`);\n        } catch (err) {\n            if (err.code !== 'ENOENT') {\n                throw err;\n            }\n        }\n        try {\n            for (const file of (await recursiveReadDir(nextStaticFolderPath))){\n                // Ensure filename is encoded and normalized.\n                nextStaticFolderItems.add(path.posix.join('/_next/static', encodeURIPath(normalizePathSep(file))));\n            }\n        } catch (err) {\n            if (opts.config.output !== 'standalone') throw err;\n        }\n        const routesManifestPath = path.join(distDir, ROUTES_MANIFEST);\n        const prerenderManifestPath = path.join(distDir, PRERENDER_MANIFEST);\n        const middlewareManifestPath = path.join(distDir, 'server', MIDDLEWARE_MANIFEST);\n        const functionsConfigManifestPath = path.join(distDir, 'server', FUNCTIONS_CONFIG_MANIFEST);\n        const pagesManifestPath = path.join(distDir, 'server', PAGES_MANIFEST);\n        const appRoutesManifestPath = path.join(distDir, APP_PATH_ROUTES_MANIFEST);\n        const routesManifest = JSON.parse(await fs.readFile(routesManifestPath, 'utf8'));\n        prerenderManifest = JSON.parse(await fs.readFile(prerenderManifestPath, 'utf8'));\n        const middlewareManifest = JSON.parse(await fs.readFile(middlewareManifestPath, 'utf8').catch(()=>'{}'));\n        const functionsConfigManifest = JSON.parse(await fs.readFile(functionsConfigManifestPath, 'utf8').catch(()=>'{}'));\n        const pagesManifest = JSON.parse(await fs.readFile(pagesManifestPath, 'utf8'));\n        const appRoutesManifest = JSON.parse(await fs.readFile(appRoutesManifestPath, 'utf8').catch(()=>'{}'));\n        for (const key of Object.keys(pagesManifest)){\n            // ensure the non-locale version is in the set\n            if (opts.config.i18n) {\n                pageFiles.add(normalizeLocalePath(key, opts.config.i18n.locales).pathname);\n            } else {\n                pageFiles.add(key);\n            }\n        }\n        for (const key of Object.keys(appRoutesManifest)){\n            appFiles.add(appRoutesManifest[key]);\n        }\n        const escapedBuildId = escapeStringRegexp(buildId);\n        for (const route of routesManifest.dataRoutes){\n            if (isDynamicRoute(route.page)) {\n                const routeRegex = getRouteRegex(route.page);\n                dynamicRoutes.push({\n                    ...route,\n                    regex: routeRegex.re.toString(),\n                    match: getRouteMatcher({\n                        // TODO: fix this in the manifest itself, must also be fixed in\n                        // upstream builder that relies on this\n                        re: opts.config.i18n ? new RegExp(route.dataRouteRegex.replace(`/${escapedBuildId}/`, `/${escapedBuildId}/(?<nextLocale>[^/]+?)/`)) : new RegExp(route.dataRouteRegex),\n                        groups: routeRegex.groups\n                    })\n                });\n            }\n            nextDataRoutes.add(route.page);\n        }\n        for (const route of routesManifest.dynamicRoutes){\n            dynamicRoutes.push({\n                ...route,\n                match: getRouteMatcher(getRouteRegex(route.page))\n            });\n        }\n        if ((_middlewareManifest_middleware = middlewareManifest.middleware) == null ? void 0 : (_middlewareManifest_middleware_ = _middlewareManifest_middleware['/']) == null ? void 0 : _middlewareManifest_middleware_.matchers) {\n            var _middlewareManifest_middleware_1, _middlewareManifest_middleware1;\n            middlewareMatcher = getMiddlewareRouteMatcher((_middlewareManifest_middleware1 = middlewareManifest.middleware) == null ? void 0 : (_middlewareManifest_middleware_1 = _middlewareManifest_middleware1['/']) == null ? void 0 : _middlewareManifest_middleware_1.matchers);\n        } else if (functionsConfigManifest == null ? void 0 : functionsConfigManifest.functions['/_middleware']) {\n            middlewareMatcher = getMiddlewareRouteMatcher(functionsConfigManifest.functions['/_middleware'].matchers ?? [\n                {\n                    regexp: '.*',\n                    originalSource: '/:path*'\n                }\n            ]);\n        }\n        customRoutes = {\n            redirects: routesManifest.redirects,\n            rewrites: routesManifest.rewrites ? Array.isArray(routesManifest.rewrites) ? {\n                beforeFiles: [],\n                afterFiles: routesManifest.rewrites,\n                fallback: []\n            } : routesManifest.rewrites : {\n                beforeFiles: [],\n                afterFiles: [],\n                fallback: []\n            },\n            headers: routesManifest.headers\n        };\n    } else {\n        // dev handling\n        customRoutes = await loadCustomRoutes(opts.config);\n        prerenderManifest = {\n            version: 4,\n            routes: {},\n            dynamicRoutes: {},\n            notFoundRoutes: [],\n            preview: {\n                previewModeId: require('crypto').randomBytes(16).toString('hex'),\n                previewModeSigningKey: require('crypto').randomBytes(32).toString('hex'),\n                previewModeEncryptionKey: require('crypto').randomBytes(32).toString('hex')\n            }\n        };\n    }\n    const headers = customRoutes.headers.map((item)=>buildCustomRoute('header', item, opts.config.basePath, opts.config.experimental.caseSensitiveRoutes));\n    const redirects = customRoutes.redirects.map((item)=>buildCustomRoute('redirect', item, opts.config.basePath, opts.config.experimental.caseSensitiveRoutes));\n    const rewrites = {\n        beforeFiles: customRoutes.rewrites.beforeFiles.map((item)=>buildCustomRoute('before_files_rewrite', item)),\n        afterFiles: customRoutes.rewrites.afterFiles.map((item)=>buildCustomRoute('rewrite', item, opts.config.basePath, opts.config.experimental.caseSensitiveRoutes)),\n        fallback: customRoutes.rewrites.fallback.map((item)=>buildCustomRoute('rewrite', item, opts.config.basePath, opts.config.experimental.caseSensitiveRoutes))\n    };\n    const { i18n } = opts.config;\n    const handleLocale = (pathname, locales)=>{\n        let locale;\n        if (i18n) {\n            const i18nResult = normalizeLocalePath(pathname, locales || i18n.locales);\n            pathname = i18nResult.pathname;\n            locale = i18nResult.detectedLocale;\n        }\n        return {\n            locale,\n            pathname\n        };\n    };\n    debug('nextDataRoutes', nextDataRoutes);\n    debug('dynamicRoutes', dynamicRoutes);\n    debug('customRoutes', customRoutes);\n    debug('publicFolderItems', publicFolderItems);\n    debug('nextStaticFolderItems', nextStaticFolderItems);\n    debug('pageFiles', pageFiles);\n    debug('appFiles', appFiles);\n    let ensureFn;\n    const normalizers = {\n        // Because we can't know if the app directory is enabled or not at this\n        // stage, we assume that it is.\n        rsc: new RSCPathnameNormalizer(),\n        prefetchRSC: opts.config.experimental.ppr ? new PrefetchRSCPathnameNormalizer() : undefined\n    };\n    return {\n        headers,\n        rewrites,\n        redirects,\n        buildId,\n        handleLocale,\n        appFiles,\n        pageFiles,\n        dynamicRoutes,\n        nextDataRoutes,\n        exportPathMapRoutes: undefined,\n        devVirtualFsItems: new Set(),\n        prerenderManifest,\n        middlewareMatcher: middlewareMatcher,\n        ensureCallback (fn) {\n            ensureFn = fn;\n        },\n        async getItem (itemPath) {\n            const originalItemPath = itemPath;\n            const itemKey = originalItemPath;\n            const lruResult = getItemsLru == null ? void 0 : getItemsLru.get(itemKey);\n            if (lruResult) {\n                return lruResult;\n            }\n            const { basePath } = opts.config;\n            const hasBasePath = pathHasPrefix(itemPath, basePath);\n            // Return null if path doesn't start with basePath\n            if (basePath && !hasBasePath) {\n                return null;\n            }\n            // Remove basePath if it exists.\n            if (basePath && hasBasePath) {\n                itemPath = removePathPrefix(itemPath, basePath) || '/';\n            }\n            // Simulate minimal mode requests by normalizing RSC and postponed\n            // requests.\n            if (opts.minimalMode) {\n                var _normalizers_prefetchRSC;\n                if ((_normalizers_prefetchRSC = normalizers.prefetchRSC) == null ? void 0 : _normalizers_prefetchRSC.match(itemPath)) {\n                    itemPath = normalizers.prefetchRSC.normalize(itemPath, true);\n                } else if (normalizers.rsc.match(itemPath)) {\n                    itemPath = normalizers.rsc.normalize(itemPath, true);\n                }\n            }\n            if (itemPath !== '/' && itemPath.endsWith('/')) {\n                itemPath = itemPath.substring(0, itemPath.length - 1);\n            }\n            let decodedItemPath = itemPath;\n            try {\n                decodedItemPath = decodeURIComponent(itemPath);\n            } catch  {}\n            if (itemPath === '/_next/image') {\n                return {\n                    itemPath,\n                    type: 'nextImage'\n                };\n            }\n            const itemsToCheck = [\n                [\n                    this.devVirtualFsItems,\n                    'devVirtualFsItem'\n                ],\n                [\n                    nextStaticFolderItems,\n                    'nextStaticFolder'\n                ],\n                [\n                    legacyStaticFolderItems,\n                    'legacyStaticFolder'\n                ],\n                [\n                    publicFolderItems,\n                    'publicFolder'\n                ],\n                [\n                    appFiles,\n                    'appFile'\n                ],\n                [\n                    pageFiles,\n                    'pageFile'\n                ]\n            ];\n            for (let [items, type] of itemsToCheck){\n                let locale;\n                let curItemPath = itemPath;\n                let curDecodedItemPath = decodedItemPath;\n                const isDynamicOutput = type === 'pageFile' || type === 'appFile';\n                if (i18n) {\n                    var _i18n_domains;\n                    const localeResult = handleLocale(itemPath, // legacy behavior allows visiting static assets under\n                    // default locale but no other locale\n                    isDynamicOutput ? undefined : [\n                        i18n == null ? void 0 : i18n.defaultLocale,\n                        // default locales from domains need to be matched too\n                        ...((_i18n_domains = i18n.domains) == null ? void 0 : _i18n_domains.map((item)=>item.defaultLocale)) || []\n                    ]);\n                    if (localeResult.pathname !== curItemPath) {\n                        curItemPath = localeResult.pathname;\n                        locale = localeResult.locale;\n                        try {\n                            curDecodedItemPath = decodeURIComponent(curItemPath);\n                        } catch  {}\n                    }\n                }\n                if (type === 'legacyStaticFolder') {\n                    if (!pathHasPrefix(curItemPath, '/static')) {\n                        continue;\n                    }\n                    curItemPath = curItemPath.substring('/static'.length);\n                    try {\n                        curDecodedItemPath = decodeURIComponent(curItemPath);\n                    } catch  {}\n                }\n                if (type === 'nextStaticFolder' && !pathHasPrefix(curItemPath, '/_next/static')) {\n                    continue;\n                }\n                const nextDataPrefix = `/_next/data/${buildId}/`;\n                if (type === 'pageFile' && curItemPath.startsWith(nextDataPrefix) && curItemPath.endsWith('.json')) {\n                    items = nextDataRoutes;\n                    // remove _next/data/<build-id> prefix\n                    curItemPath = curItemPath.substring(nextDataPrefix.length - 1);\n                    // remove .json postfix\n                    curItemPath = curItemPath.substring(0, curItemPath.length - '.json'.length);\n                    const curLocaleResult = handleLocale(curItemPath);\n                    curItemPath = curLocaleResult.pathname === '/index' ? '/' : curLocaleResult.pathname;\n                    locale = curLocaleResult.locale;\n                    try {\n                        curDecodedItemPath = decodeURIComponent(curItemPath);\n                    } catch  {}\n                }\n                let matchedItem = items.has(curItemPath);\n                // check decoded variant as well\n                if (!matchedItem && !opts.dev) {\n                    matchedItem = items.has(curDecodedItemPath);\n                    if (matchedItem) curItemPath = curDecodedItemPath;\n                    else {\n                        // x-ref: https://github.com/vercel/next.js/issues/54008\n                        // There're cases that urls get decoded before requests, we should support both encoded and decoded ones.\n                        // e.g. nginx could decode the proxy urls, the below ones should be treated as the same:\n                        // decoded version: `/_next/static/chunks/pages/blog/[slug]-d4858831b91b69f6.js`\n                        // encoded version: `/_next/static/chunks/pages/blog/%5Bslug%5D-d4858831b91b69f6.js`\n                        try {\n                            // encode the special characters in the path and retrieve again to determine if path exists.\n                            const encodedCurItemPath = encodeURIPath(curItemPath);\n                            matchedItem = items.has(encodedCurItemPath);\n                        } catch  {}\n                    }\n                }\n                if (matchedItem || opts.dev) {\n                    let fsPath;\n                    let itemsRoot;\n                    switch(type){\n                        case 'nextStaticFolder':\n                            {\n                                itemsRoot = nextStaticFolderPath;\n                                curItemPath = curItemPath.substring('/_next/static'.length);\n                                break;\n                            }\n                        case 'legacyStaticFolder':\n                            {\n                                itemsRoot = legacyStaticFolderPath;\n                                break;\n                            }\n                        case 'publicFolder':\n                            {\n                                itemsRoot = publicFolderPath;\n                                break;\n                            }\n                        default:\n                            {\n                                break;\n                            }\n                    }\n                    if (itemsRoot && curItemPath) {\n                        fsPath = path.posix.join(itemsRoot, curItemPath);\n                    }\n                    // dynamically check fs in development so we don't\n                    // have to wait on the watcher\n                    if (!matchedItem && opts.dev) {\n                        const isStaticAsset = [\n                            'nextStaticFolder',\n                            'publicFolder',\n                            'legacyStaticFolder'\n                        ].includes(type);\n                        if (isStaticAsset && itemsRoot) {\n                            let found = fsPath && await fileExists(fsPath, FileType.File);\n                            if (!found) {\n                                try {\n                                    // In dev, we ensure encoded paths match\n                                    // decoded paths on the filesystem so check\n                                    // that variation as well\n                                    const tempItemPath = decodeURIComponent(curItemPath);\n                                    fsPath = path.posix.join(itemsRoot, tempItemPath);\n                                    found = await fileExists(fsPath, FileType.File);\n                                } catch  {}\n                                if (!found) {\n                                    continue;\n                                }\n                            }\n                        } else if (type === 'pageFile' || type === 'appFile') {\n                            var _ensureFn;\n                            const isAppFile = type === 'appFile';\n                            if (ensureFn && await ((_ensureFn = ensureFn({\n                                type,\n                                itemPath: isAppFile ? normalizeMetadataRoute(curItemPath) : curItemPath\n                            })) == null ? void 0 : _ensureFn.catch(()=>'ENSURE_FAILED')) === 'ENSURE_FAILED') {\n                                continue;\n                            }\n                        } else {\n                            continue;\n                        }\n                    }\n                    // i18n locales aren't matched for app dir\n                    if (type === 'appFile' && locale && locale !== (i18n == null ? void 0 : i18n.defaultLocale)) {\n                        continue;\n                    }\n                    const itemResult = {\n                        type,\n                        fsPath,\n                        locale,\n                        itemsRoot,\n                        itemPath: curItemPath\n                    };\n                    getItemsLru == null ? void 0 : getItemsLru.set(itemKey, itemResult);\n                    return itemResult;\n                }\n            }\n            getItemsLru == null ? void 0 : getItemsLru.set(itemKey, null);\n            return null;\n        },\n        getDynamicRoutes () {\n            // this should include data routes\n            return this.dynamicRoutes;\n        },\n        getMiddlewareMatchers () {\n            return this.middlewareMatcher;\n        }\n    };\n}\n\n//# sourceMappingURL=filesystem.js.map"
        }
    ]
}