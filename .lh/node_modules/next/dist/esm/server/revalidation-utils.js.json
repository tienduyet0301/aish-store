{
    "sourceFile": "node_modules/next/dist/esm/server/revalidation-utils.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892838445,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import { getCacheHandlers } from './use-cache/handlers';\n/** Run a callback, and execute any *new* revalidations added during its runtime. */ export async function withExecuteRevalidates(store, callback) {\n    if (!store) {\n        return callback();\n    }\n    // If we executed any revalidates during the request, then we don't want to execute them again.\n    // save the state so we can check if anything changed after we're done running callbacks.\n    const savedRevalidationState = cloneRevalidationState(store);\n    try {\n        return await callback();\n    } finally{\n        // Check if we have any new revalidates, and if so, wait until they are all resolved.\n        const newRevalidates = diffRevalidationState(savedRevalidationState, cloneRevalidationState(store));\n        await executeRevalidates(store, newRevalidates);\n    }\n}\nfunction cloneRevalidationState(store) {\n    return {\n        pendingRevalidatedTags: store.pendingRevalidatedTags ? [\n            ...store.pendingRevalidatedTags\n        ] : [],\n        pendingRevalidates: {\n            ...store.pendingRevalidates\n        },\n        pendingRevalidateWrites: store.pendingRevalidateWrites ? [\n            ...store.pendingRevalidateWrites\n        ] : []\n    };\n}\nfunction diffRevalidationState(prev, curr) {\n    const prevTags = new Set(prev.pendingRevalidatedTags);\n    const prevRevalidateWrites = new Set(prev.pendingRevalidateWrites);\n    return {\n        pendingRevalidatedTags: curr.pendingRevalidatedTags.filter((tag)=>!prevTags.has(tag)),\n        pendingRevalidates: Object.fromEntries(Object.entries(curr.pendingRevalidates).filter(([key])=>!(key in prev.pendingRevalidates))),\n        pendingRevalidateWrites: curr.pendingRevalidateWrites.filter((promise)=>!prevRevalidateWrites.has(promise))\n    };\n}\nasync function revalidateTags(tags, incrementalCache) {\n    if (tags.length === 0) {\n        return;\n    }\n    const promises = [];\n    if (incrementalCache) {\n        promises.push(incrementalCache.revalidateTag(tags));\n    }\n    const handlers = getCacheHandlers();\n    if (handlers) {\n        for (const handler of handlers){\n            promises.push(handler.expireTags(...tags));\n        }\n    }\n    await Promise.all(promises);\n}\nexport async function executeRevalidates(workStore, state) {\n    const pendingRevalidatedTags = (state == null ? void 0 : state.pendingRevalidatedTags) ?? workStore.pendingRevalidatedTags ?? [];\n    const pendingRevalidates = (state == null ? void 0 : state.pendingRevalidates) ?? workStore.pendingRevalidates ?? {};\n    const pendingRevalidateWrites = (state == null ? void 0 : state.pendingRevalidateWrites) ?? workStore.pendingRevalidateWrites ?? [];\n    return Promise.all([\n        revalidateTags(pendingRevalidatedTags, workStore.incrementalCache),\n        ...Object.values(pendingRevalidates),\n        ...pendingRevalidateWrites\n    ]);\n}\n\n//# sourceMappingURL=revalidation-utils.js.map"
        }
    ]
}