{
    "sourceFile": "node_modules/next/dist/esm/server/resume-data-cache/resume-data-cache.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892838342,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import { InvariantError } from '../../shared/lib/invariant-error';\nimport { serializeUseCacheCacheStore, parseUseCacheCacheStore } from './cache-store';\n/**\n * Serializes a resume data cache into a JSON string for storage or\n * transmission. Handles 'use cache' values, fetch responses, and encrypted\n * bound args for inline server functions.\n *\n * @param resumeDataCache - The immutable cache to serialize\n * @returns A Promise that resolves to the serialized cache as a JSON string, or\n * 'null' if empty\n */ export async function stringifyResumeDataCache(resumeDataCache) {\n    if (process.env.NEXT_RUNTIME === 'edge') {\n        throw Object.defineProperty(new InvariantError('`stringifyResumeDataCache` should not be called in edge runtime.'), \"__NEXT_ERROR_CODE\", {\n            value: \"E602\",\n            enumerable: false,\n            configurable: true\n        });\n    } else {\n        if (resumeDataCache.fetch.size === 0 && resumeDataCache.cache.size === 0) {\n            return 'null';\n        }\n        const json = {\n            store: {\n                fetch: Object.fromEntries(Array.from(resumeDataCache.fetch.entries())),\n                cache: Object.fromEntries((await serializeUseCacheCacheStore(resumeDataCache.cache.entries())).filter((entry)=>entry !== null)),\n                encryptedBoundArgs: Object.fromEntries(Array.from(resumeDataCache.encryptedBoundArgs.entries()))\n            }\n        };\n        // Compress the JSON string using zlib. As the data we already want to\n        // decompress is in memory, we use the synchronous deflateSync function.\n        const { deflateSync } = require('node:zlib');\n        return deflateSync(JSON.stringify(json)).toString('base64');\n    }\n}\n/**\n * Creates a new empty mutable resume data cache for pre-rendering.\n * Initializes fresh Map instances for both the 'use cache' and fetch caches.\n * Used at the start of pre-rendering to begin collecting cached values.\n *\n * @returns A new empty PrerenderResumeDataCache instance\n */ export function createPrerenderResumeDataCache() {\n    return {\n        cache: new Map(),\n        fetch: new Map(),\n        encryptedBoundArgs: new Map(),\n        decryptedBoundArgs: new Map()\n    };\n}\nexport function createRenderResumeDataCache(prerenderResumeDataCacheOrPersistedCache) {\n    if (process.env.NEXT_RUNTIME === 'edge') {\n        throw Object.defineProperty(new InvariantError('`createRenderResumeDataCache` should not be called in edge runtime.'), \"__NEXT_ERROR_CODE\", {\n            value: \"E556\",\n            enumerable: false,\n            configurable: true\n        });\n    } else {\n        if (typeof prerenderResumeDataCacheOrPersistedCache !== 'string') {\n            // If the cache is already a prerender cache, we can return it directly,\n            // we're just performing a type change.\n            return prerenderResumeDataCacheOrPersistedCache;\n        }\n        if (prerenderResumeDataCacheOrPersistedCache === 'null') {\n            return {\n                cache: new Map(),\n                fetch: new Map(),\n                encryptedBoundArgs: new Map(),\n                decryptedBoundArgs: new Map()\n            };\n        }\n        // This should be a compressed string. Let's decompress it using zlib.\n        // As the data we already want to decompress is in memory, we use the\n        // synchronous inflateSync function.\n        const { inflateSync } = require('node:zlib');\n        const json = JSON.parse(inflateSync(Buffer.from(prerenderResumeDataCacheOrPersistedCache, 'base64')).toString('utf-8'));\n        return {\n            cache: parseUseCacheCacheStore(Object.entries(json.store.cache)),\n            fetch: new Map(Object.entries(json.store.fetch)),\n            encryptedBoundArgs: new Map(Object.entries(json.store.encryptedBoundArgs)),\n            decryptedBoundArgs: new Map()\n        };\n    }\n}\n\n//# sourceMappingURL=resume-data-cache.js.map"
        }
    ]
}