{
    "sourceFile": "node_modules/next/dist/esm/server/load-components.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892833918,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import { BUILD_MANIFEST, REACT_LOADABLE_MANIFEST, CLIENT_REFERENCE_MANIFEST, SERVER_REFERENCE_MANIFEST, DYNAMIC_CSS_MANIFEST, SUBRESOURCE_INTEGRITY_MANIFEST } from '../shared/lib/constants';\nimport { join } from 'path';\nimport { requirePage } from './require';\nimport { interopDefault } from '../lib/interop-default';\nimport { getTracer } from './lib/trace/tracer';\nimport { LoadComponentsSpan } from './lib/trace/constants';\nimport { evalManifest, loadManifest } from './load-manifest';\nimport { wait } from '../lib/wait';\nimport { setReferenceManifestsSingleton } from './app-render/encryption-utils';\nimport { createServerModuleMap } from './app-render/action-utils';\nimport { normalizePagePath } from '../shared/lib/page-path/normalize-page-path';\nimport { isStaticMetadataRoute } from '../lib/metadata/is-metadata-route';\n/**\n * Load manifest file with retries, defaults to 3 attempts.\n */ export async function loadManifestWithRetries(manifestPath, attempts = 3) {\n    while(true){\n        try {\n            return loadManifest(manifestPath);\n        } catch (err) {\n            attempts--;\n            if (attempts <= 0) throw err;\n            await wait(100);\n        }\n    }\n}\n/**\n * Load manifest file with retries, defaults to 3 attempts, or return undefined.\n */ export async function tryLoadManifestWithRetries(manifestPath, attempts = 3) {\n    try {\n        return await loadManifestWithRetries(manifestPath, attempts);\n    } catch (err) {\n        return undefined;\n    }\n}\n/**\n * Load manifest file with retries, defaults to 3 attempts.\n */ export async function evalManifestWithRetries(manifestPath, attempts = 3) {\n    while(true){\n        try {\n            return evalManifest(manifestPath);\n        } catch (err) {\n            attempts--;\n            if (attempts <= 0) throw err;\n            await wait(100);\n        }\n    }\n}\nasync function tryLoadClientReferenceManifest(manifestPath, entryName, attempts) {\n    try {\n        const context = await evalManifestWithRetries(manifestPath, attempts);\n        return context.__RSC_MANIFEST[entryName];\n    } catch (err) {\n        return undefined;\n    }\n}\nasync function loadComponentsImpl({ distDir, page, isAppPath, isDev, sriEnabled }) {\n    let DocumentMod = {};\n    let AppMod = {};\n    if (!isAppPath) {\n        ;\n        [DocumentMod, AppMod] = await Promise.all([\n            requirePage('/_document', distDir, false),\n            requirePage('/_app', distDir, false)\n        ]);\n    }\n    // In dev mode we retry loading a manifest file to handle a race condition\n    // that can occur while app and pages are compiling at the same time, and the\n    // build-manifest is still being written to disk while an app path is\n    // attempting to load.\n    const manifestLoadAttempts = isDev ? 3 : 1;\n    let reactLoadableManifestPath;\n    if (!process.env.TURBOPACK) {\n        reactLoadableManifestPath = join(distDir, REACT_LOADABLE_MANIFEST);\n    } else if (isAppPath) {\n        reactLoadableManifestPath = join(distDir, 'server', 'app', page, REACT_LOADABLE_MANIFEST);\n    } else {\n        reactLoadableManifestPath = join(distDir, 'server', 'pages', normalizePagePath(page), REACT_LOADABLE_MANIFEST);\n    }\n    // Make sure to avoid loading the manifest for static metadata routes for better performance.\n    const hasClientManifest = !isStaticMetadataRoute(page);\n    // Load the manifest files first\n    //\n    // Loading page-specific manifests shouldn't throw an error if the manifest couldn't be found, so\n    // that the `requirePage` call below will throw the correct error in that case\n    // (a `PageNotFoundError`).\n    const [buildManifest, reactLoadableManifest, dynamicCssManifest, clientReferenceManifest, serverActionsManifest, subresourceIntegrityManifest] = await Promise.all([\n        loadManifestWithRetries(join(distDir, BUILD_MANIFEST), manifestLoadAttempts),\n        tryLoadManifestWithRetries(reactLoadableManifestPath, manifestLoadAttempts),\n        // This manifest will only exist in Pages dir && Production && Webpack.\n        isAppPath || process.env.TURBOPACK ? undefined : loadManifestWithRetries(join(distDir, `${DYNAMIC_CSS_MANIFEST}.json`), manifestLoadAttempts).catch(()=>undefined),\n        isAppPath && hasClientManifest ? tryLoadClientReferenceManifest(join(distDir, 'server', 'app', page.replace(/%5F/g, '_') + '_' + CLIENT_REFERENCE_MANIFEST + '.js'), page.replace(/%5F/g, '_'), manifestLoadAttempts) : undefined,\n        isAppPath ? loadManifestWithRetries(join(distDir, 'server', SERVER_REFERENCE_MANIFEST + '.json'), manifestLoadAttempts).catch(()=>null) : null,\n        sriEnabled ? loadManifestWithRetries(join(distDir, 'server', SUBRESOURCE_INTEGRITY_MANIFEST + '.json')).catch(()=>undefined) : undefined\n    ]);\n    // Before requiring the actual page module, we have to set the reference\n    // manifests to our global store so Server Action's encryption util can access\n    // to them at the top level of the page module.\n    if (serverActionsManifest && clientReferenceManifest) {\n        setReferenceManifestsSingleton({\n            page,\n            clientReferenceManifest,\n            serverActionsManifest,\n            serverModuleMap: createServerModuleMap({\n                serverActionsManifest\n            })\n        });\n    }\n    const ComponentMod = await requirePage(page, distDir, isAppPath);\n    const Component = interopDefault(ComponentMod);\n    const Document = interopDefault(DocumentMod);\n    const App = interopDefault(AppMod);\n    const { getServerSideProps, getStaticProps, getStaticPaths, routeModule } = ComponentMod;\n    return {\n        App,\n        Document,\n        Component,\n        buildManifest,\n        subresourceIntegrityManifest,\n        reactLoadableManifest: reactLoadableManifest || {},\n        dynamicCssManifest,\n        pageConfig: ComponentMod.config || {},\n        ComponentMod,\n        getServerSideProps,\n        getStaticProps,\n        getStaticPaths,\n        clientReferenceManifest,\n        serverActionsManifest,\n        isAppPath,\n        page,\n        routeModule\n    };\n}\nexport const loadComponents = getTracer().wrap(LoadComponentsSpan.loadComponents, loadComponentsImpl);\n\n//# sourceMappingURL=load-components.js.map"
        }
    ]
}