{
    "sourceFile": "node_modules/next/dist/esm/server/image-optimizer.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892829385,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import { createHash } from 'crypto';\nimport { promises } from 'fs';\nimport { mediaType } from 'next/dist/compiled/@hapi/accept';\nimport contentDisposition from 'next/dist/compiled/content-disposition';\nimport imageSizeOf from 'next/dist/compiled/image-size';\nimport isAnimated from 'next/dist/compiled/is-animated';\nimport { join } from 'path';\nimport nodeUrl from 'url';\nimport { getImageBlurSvg } from '../shared/lib/image-blur-svg';\nimport { hasLocalMatch } from '../shared/lib/match-local-pattern';\nimport { hasRemoteMatch } from '../shared/lib/match-remote-pattern';\nimport { createRequestResponseMocks } from './lib/mock-request';\nimport { CachedRouteKind } from './response-cache';\nimport { sendEtagResponse } from './send-payload';\nimport { getContentType, getExtension } from './serve-static';\nimport * as Log from '../build/output/log';\nimport isError from '../lib/is-error';\nimport { parseUrl } from '../lib/url';\nimport { InvariantError } from '../shared/lib/invariant-error';\nconst AVIF = 'image/avif';\nconst WEBP = 'image/webp';\nconst PNG = 'image/png';\nconst JPEG = 'image/jpeg';\nconst GIF = 'image/gif';\nconst SVG = 'image/svg+xml';\nconst ICO = 'image/x-icon';\nconst ICNS = 'image/x-icns';\nconst TIFF = 'image/tiff';\nconst BMP = 'image/bmp';\nconst CACHE_VERSION = 4;\nconst ANIMATABLE_TYPES = [\n    WEBP,\n    PNG,\n    GIF\n];\nconst BYPASS_TYPES = [\n    SVG,\n    ICO,\n    ICNS,\n    BMP\n];\nconst BLUR_IMG_SIZE = 8 // should match `next-image-loader`\n;\nconst BLUR_QUALITY = 70 // should match `next-image-loader`\n;\nlet _sharp;\nexport function getSharp(concurrency) {\n    if (_sharp) {\n        return _sharp;\n    }\n    try {\n        _sharp = require('sharp');\n        if (_sharp && _sharp.concurrency() > 1) {\n            // Reducing concurrency should reduce the memory usage too.\n            // We more aggressively reduce in dev but also reduce in prod.\n            // https://sharp.pixelplumbing.com/api-utility#concurrency\n            const divisor = process.env.NODE_ENV === 'development' ? 4 : 2;\n            _sharp.concurrency(concurrency ?? Math.floor(Math.max(_sharp.concurrency() / divisor, 1)));\n        }\n    } catch (e) {\n        if (isError(e) && e.code === 'MODULE_NOT_FOUND') {\n            throw Object.defineProperty(new Error('Module `sharp` not found. Please run `npm install --cpu=wasm32 sharp` to install it.'), \"__NEXT_ERROR_CODE\", {\n                value: \"E47\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n        throw e;\n    }\n    return _sharp;\n}\nfunction getSupportedMimeType(options, accept = '') {\n    const mimeType = mediaType(accept, options);\n    return accept.includes(mimeType) ? mimeType : '';\n}\nexport function getHash(items) {\n    const hash = createHash('sha256');\n    for (let item of items){\n        if (typeof item === 'number') hash.update(String(item));\n        else {\n            hash.update(item);\n        }\n    }\n    // See https://en.wikipedia.org/wiki/Base64#URL_applications\n    return hash.digest('base64url');\n}\nexport function extractEtag(etag, imageBuffer) {\n    if (etag) {\n        // upstream etag needs to be base64url encoded due to weak etag signature\n        // as we store this in the cache-entry file name.\n        return Buffer.from(etag).toString('base64url');\n    }\n    return getImageEtag(imageBuffer);\n}\nexport function getImageEtag(image) {\n    return getHash([\n        image\n    ]);\n}\nasync function writeToCacheDir(dir, extension, maxAge, expireAt, buffer, etag, upstreamEtag) {\n    const filename = join(dir, `${maxAge}.${expireAt}.${etag}.${upstreamEtag}.${extension}`);\n    await promises.rm(dir, {\n        recursive: true,\n        force: true\n    }).catch(()=>{});\n    await promises.mkdir(dir, {\n        recursive: true\n    });\n    await promises.writeFile(filename, buffer);\n}\n/**\n * Inspects the first few bytes of a buffer to determine if\n * it matches the \"magic number\" of known file signatures.\n * https://en.wikipedia.org/wiki/List_of_file_signatures\n */ export function detectContentType(buffer) {\n    if ([\n        0xff,\n        0xd8,\n        0xff\n    ].every((b, i)=>buffer[i] === b)) {\n        return JPEG;\n    }\n    if ([\n        0x89,\n        0x50,\n        0x4e,\n        0x47,\n        0x0d,\n        0x0a,\n        0x1a,\n        0x0a\n    ].every((b, i)=>buffer[i] === b)) {\n        return PNG;\n    }\n    if ([\n        0x47,\n        0x49,\n        0x46,\n        0x38\n    ].every((b, i)=>buffer[i] === b)) {\n        return GIF;\n    }\n    if ([\n        0x52,\n        0x49,\n        0x46,\n        0x46,\n        0,\n        0,\n        0,\n        0,\n        0x57,\n        0x45,\n        0x42,\n        0x50\n    ].every((b, i)=>!b || buffer[i] === b)) {\n        return WEBP;\n    }\n    if ([\n        0x3c,\n        0x3f,\n        0x78,\n        0x6d,\n        0x6c\n    ].every((b, i)=>buffer[i] === b)) {\n        return SVG;\n    }\n    if ([\n        0x3c,\n        0x73,\n        0x76,\n        0x67\n    ].every((b, i)=>buffer[i] === b)) {\n        return SVG;\n    }\n    if ([\n        0,\n        0,\n        0,\n        0,\n        0x66,\n        0x74,\n        0x79,\n        0x70,\n        0x61,\n        0x76,\n        0x69,\n        0x66\n    ].every((b, i)=>!b || buffer[i] === b)) {\n        return AVIF;\n    }\n    if ([\n        0x00,\n        0x00,\n        0x01,\n        0x00\n    ].every((b, i)=>buffer[i] === b)) {\n        return ICO;\n    }\n    if ([\n        0x69,\n        0x63,\n        0x6e,\n        0x73\n    ].every((b, i)=>buffer[i] === b)) {\n        return ICNS;\n    }\n    if ([\n        0x49,\n        0x49,\n        0x2a,\n        0x00\n    ].every((b, i)=>buffer[i] === b)) {\n        return TIFF;\n    }\n    if ([\n        0x42,\n        0x4d\n    ].every((b, i)=>buffer[i] === b)) {\n        return BMP;\n    }\n    return null;\n}\nexport class ImageOptimizerCache {\n    static validateParams(req, query, nextConfig, isDev) {\n        var _nextConfig_images, _nextConfig_images1, _nextConfig_images2;\n        const imageData = nextConfig.images;\n        const { deviceSizes = [], imageSizes = [], domains = [], minimumCacheTTL = 60, formats = [\n            'image/webp'\n        ] } = imageData;\n        const remotePatterns = ((_nextConfig_images = nextConfig.images) == null ? void 0 : _nextConfig_images.remotePatterns) || [];\n        const localPatterns = (_nextConfig_images1 = nextConfig.images) == null ? void 0 : _nextConfig_images1.localPatterns;\n        const qualities = (_nextConfig_images2 = nextConfig.images) == null ? void 0 : _nextConfig_images2.qualities;\n        const { url, w, q } = query;\n        let href;\n        if (domains.length > 0) {\n            Log.warnOnce('The \"images.domains\" configuration is deprecated. Please use \"images.remotePatterns\" configuration instead.');\n        }\n        if (!url) {\n            return {\n                errorMessage: '\"url\" parameter is required'\n            };\n        } else if (Array.isArray(url)) {\n            return {\n                errorMessage: '\"url\" parameter cannot be an array'\n            };\n        }\n        if (url.length > 3072) {\n            return {\n                errorMessage: '\"url\" parameter is too long'\n            };\n        }\n        if (url.startsWith('//')) {\n            return {\n                errorMessage: '\"url\" parameter cannot be a protocol-relative URL (//)'\n            };\n        }\n        let isAbsolute;\n        if (url.startsWith('/')) {\n            var _parseUrl;\n            href = url;\n            isAbsolute = false;\n            if (/\\/_next\\/image($|\\/)/.test(decodeURIComponent(((_parseUrl = parseUrl(url)) == null ? void 0 : _parseUrl.pathname) ?? ''))) {\n                return {\n                    errorMessage: '\"url\" parameter cannot be recursive'\n                };\n            }\n            if (!hasLocalMatch(localPatterns, url)) {\n                return {\n                    errorMessage: '\"url\" parameter is not allowed'\n                };\n            }\n        } else {\n            let hrefParsed;\n            try {\n                hrefParsed = new URL(url);\n                href = hrefParsed.toString();\n                isAbsolute = true;\n            } catch (_error) {\n                return {\n                    errorMessage: '\"url\" parameter is invalid'\n                };\n            }\n            if (![\n                'http:',\n                'https:'\n            ].includes(hrefParsed.protocol)) {\n                return {\n                    errorMessage: '\"url\" parameter is invalid'\n                };\n            }\n            if (!hasRemoteMatch(domains, remotePatterns, hrefParsed)) {\n                return {\n                    errorMessage: '\"url\" parameter is not allowed'\n                };\n            }\n        }\n        if (!w) {\n            return {\n                errorMessage: '\"w\" parameter (width) is required'\n            };\n        } else if (Array.isArray(w)) {\n            return {\n                errorMessage: '\"w\" parameter (width) cannot be an array'\n            };\n        } else if (!/^[0-9]+$/.test(w)) {\n            return {\n                errorMessage: '\"w\" parameter (width) must be an integer greater than 0'\n            };\n        }\n        if (!q) {\n            return {\n                errorMessage: '\"q\" parameter (quality) is required'\n            };\n        } else if (Array.isArray(q)) {\n            return {\n                errorMessage: '\"q\" parameter (quality) cannot be an array'\n            };\n        } else if (!/^[0-9]+$/.test(q)) {\n            return {\n                errorMessage: '\"q\" parameter (quality) must be an integer between 1 and 100'\n            };\n        }\n        const width = parseInt(w, 10);\n        if (width <= 0 || isNaN(width)) {\n            return {\n                errorMessage: '\"w\" parameter (width) must be an integer greater than 0'\n            };\n        }\n        const sizes = [\n            ...deviceSizes || [],\n            ...imageSizes || []\n        ];\n        if (isDev) {\n            sizes.push(BLUR_IMG_SIZE);\n        }\n        const isValidSize = sizes.includes(width) || isDev && width <= BLUR_IMG_SIZE;\n        if (!isValidSize) {\n            return {\n                errorMessage: `\"w\" parameter (width) of ${width} is not allowed`\n            };\n        }\n        const quality = parseInt(q, 10);\n        if (isNaN(quality) || quality < 1 || quality > 100) {\n            return {\n                errorMessage: '\"q\" parameter (quality) must be an integer between 1 and 100'\n            };\n        }\n        if (qualities) {\n            if (isDev) {\n                qualities.push(BLUR_QUALITY);\n            }\n            if (!qualities.includes(quality)) {\n                return {\n                    errorMessage: `\"q\" parameter (quality) of ${q} is not allowed`\n                };\n            }\n        }\n        const mimeType = getSupportedMimeType(formats || [], req.headers['accept']);\n        const isStatic = url.startsWith(`${nextConfig.basePath || ''}/_next/static/media`);\n        return {\n            href,\n            sizes,\n            isAbsolute,\n            isStatic,\n            width,\n            quality,\n            mimeType,\n            minimumCacheTTL\n        };\n    }\n    static getCacheKey({ href, width, quality, mimeType }) {\n        return getHash([\n            CACHE_VERSION,\n            href,\n            width,\n            quality,\n            mimeType\n        ]);\n    }\n    constructor({ distDir, nextConfig }){\n        this.cacheDir = join(distDir, 'cache', 'images');\n        this.nextConfig = nextConfig;\n    }\n    async get(cacheKey) {\n        try {\n            const cacheDir = join(this.cacheDir, cacheKey);\n            const files = await promises.readdir(cacheDir);\n            const now = Date.now();\n            for (const file of files){\n                const [maxAgeSt, expireAtSt, etag, upstreamEtag, extension] = file.split('.', 5);\n                const buffer = await promises.readFile(join(cacheDir, file));\n                const expireAt = Number(expireAtSt);\n                const maxAge = Number(maxAgeSt);\n                return {\n                    value: {\n                        kind: CachedRouteKind.IMAGE,\n                        etag,\n                        buffer,\n                        extension,\n                        upstreamEtag\n                    },\n                    revalidateAfter: Math.max(maxAge, this.nextConfig.images.minimumCacheTTL) * 1000 + Date.now(),\n                    cacheControl: {\n                        revalidate: maxAge,\n                        expire: undefined\n                    },\n                    isStale: now > expireAt,\n                    isFallback: false\n                };\n            }\n        } catch (_) {\n        // failed to read from cache dir, treat as cache miss\n        }\n        return null;\n    }\n    async set(cacheKey, value, { cacheControl }) {\n        if (!this.nextConfig.experimental.isrFlushToDisk) {\n            return;\n        }\n        if ((value == null ? void 0 : value.kind) !== CachedRouteKind.IMAGE) {\n            throw Object.defineProperty(new Error('invariant attempted to set non-image to image-cache'), \"__NEXT_ERROR_CODE\", {\n                value: \"E366\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n        const revalidate = cacheControl == null ? void 0 : cacheControl.revalidate;\n        if (typeof revalidate !== 'number') {\n            throw Object.defineProperty(new InvariantError('revalidate must be a number for image-cache'), \"__NEXT_ERROR_CODE\", {\n                value: \"E657\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n        const expireAt = Math.max(revalidate, this.nextConfig.images.minimumCacheTTL) * 1000 + Date.now();\n        try {\n            await writeToCacheDir(join(this.cacheDir, cacheKey), value.extension, revalidate, expireAt, value.buffer, value.etag, value.upstreamEtag);\n        } catch (err) {\n            Log.error(`Failed to write image to cache ${cacheKey}`, err);\n        }\n    }\n}\nexport class ImageError extends Error {\n    constructor(statusCode, message){\n        super(message);\n        // ensure an error status is used > 400\n        if (statusCode >= 400) {\n            this.statusCode = statusCode;\n        } else {\n            this.statusCode = 500;\n        }\n    }\n}\nfunction parseCacheControl(str) {\n    const map = new Map();\n    if (!str) {\n        return map;\n    }\n    for (let directive of str.split(',')){\n        let [key, value] = directive.trim().split('=', 2);\n        key = key.toLowerCase();\n        if (value) {\n            value = value.toLowerCase();\n        }\n        map.set(key, value);\n    }\n    return map;\n}\nexport function getMaxAge(str) {\n    const map = parseCacheControl(str);\n    if (map) {\n        let age = map.get('s-maxage') || map.get('max-age') || '';\n        if (age.startsWith('\"') && age.endsWith('\"')) {\n            age = age.slice(1, -1);\n        }\n        const n = parseInt(age, 10);\n        if (!isNaN(n)) {\n            return n;\n        }\n    }\n    return 0;\n}\nexport function getPreviouslyCachedImageOrNull(upstreamImage, previousCacheEntry) {\n    var _previousCacheEntry_value;\n    if ((previousCacheEntry == null ? void 0 : (_previousCacheEntry_value = previousCacheEntry.value) == null ? void 0 : _previousCacheEntry_value.kind) === 'IMAGE' && // Images that are SVGs, animated or failed the optimization previously end up using upstreamEtag as their etag as well,\n    // in these cases we want to trigger a new \"optimization\" attempt.\n    previousCacheEntry.value.upstreamEtag !== previousCacheEntry.value.etag && // and the upstream etag is the same as the previous cache entry's\n    upstreamImage.etag === previousCacheEntry.value.upstreamEtag) {\n        return previousCacheEntry.value;\n    }\n    return null;\n}\nexport async function optimizeImage({ buffer, contentType, quality, width, height, concurrency, limitInputPixels, sequentialRead, timeoutInSeconds }) {\n    const sharp = getSharp(concurrency);\n    const transformer = sharp(buffer, {\n        limitInputPixels,\n        sequentialRead: sequentialRead ?? undefined\n    }).timeout({\n        seconds: timeoutInSeconds ?? 7\n    }).rotate();\n    if (height) {\n        transformer.resize(width, height);\n    } else {\n        transformer.resize(width, undefined, {\n            withoutEnlargement: true\n        });\n    }\n    if (contentType === AVIF) {\n        transformer.avif({\n            quality: Math.max(quality - 20, 1),\n            effort: 3\n        });\n    } else if (contentType === WEBP) {\n        transformer.webp({\n            quality\n        });\n    } else if (contentType === PNG) {\n        transformer.png({\n            quality\n        });\n    } else if (contentType === JPEG) {\n        transformer.jpeg({\n            quality,\n            mozjpeg: true\n        });\n    }\n    const optimizedBuffer = await transformer.toBuffer();\n    return optimizedBuffer;\n}\nexport async function fetchExternalImage(href) {\n    const res = await fetch(href, {\n        signal: AbortSignal.timeout(7000)\n    }).catch((err)=>err);\n    if (res instanceof Error) {\n        const err = res;\n        if (err.name === 'TimeoutError') {\n            Log.error('upstream image response timed out for', href);\n            throw Object.defineProperty(new ImageError(504, '\"url\" parameter is valid but upstream response timed out'), \"__NEXT_ERROR_CODE\", {\n                value: \"E394\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n        throw err;\n    }\n    if (!res.ok) {\n        Log.error('upstream image response failed for', href, res.status);\n        throw Object.defineProperty(new ImageError(res.status, '\"url\" parameter is valid but upstream response is invalid'), \"__NEXT_ERROR_CODE\", {\n            value: \"E394\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    const buffer = Buffer.from(await res.arrayBuffer());\n    const contentType = res.headers.get('Content-Type');\n    const cacheControl = res.headers.get('Cache-Control');\n    const etag = extractEtag(res.headers.get('ETag'), buffer);\n    return {\n        buffer,\n        contentType,\n        cacheControl,\n        etag\n    };\n}\nexport async function fetchInternalImage(href, _req, _res, handleRequest) {\n    try {\n        const mocked = createRequestResponseMocks({\n            url: href,\n            method: _req.method || 'GET',\n            headers: _req.headers,\n            socket: _req.socket\n        });\n        await handleRequest(mocked.req, mocked.res, nodeUrl.parse(href, true));\n        await mocked.res.hasStreamed;\n        if (!mocked.res.statusCode) {\n            Log.error('image response failed for', href, mocked.res.statusCode);\n            throw Object.defineProperty(new ImageError(mocked.res.statusCode, '\"url\" parameter is valid but internal response is invalid'), \"__NEXT_ERROR_CODE\", {\n                value: \"E394\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n        const buffer = Buffer.concat(mocked.res.buffers);\n        const contentType = mocked.res.getHeader('Content-Type');\n        const cacheControl = mocked.res.getHeader('Cache-Control');\n        const etag = extractEtag(mocked.res.getHeader('ETag'), buffer);\n        return {\n            buffer,\n            contentType,\n            cacheControl,\n            etag\n        };\n    } catch (err) {\n        Log.error('upstream image response failed for', href, err);\n        throw Object.defineProperty(new ImageError(500, '\"url\" parameter is valid but upstream response is invalid'), \"__NEXT_ERROR_CODE\", {\n            value: \"E394\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n}\nexport async function imageOptimizer(imageUpstream, paramsResult, nextConfig, opts) {\n    var _imageUpstream_contentType;\n    const { href, quality, width, mimeType } = paramsResult;\n    const { buffer: upstreamBuffer, etag: upstreamEtag } = imageUpstream;\n    const maxAge = Math.max(nextConfig.images.minimumCacheTTL, getMaxAge(imageUpstream.cacheControl));\n    const upstreamType = detectContentType(upstreamBuffer) || ((_imageUpstream_contentType = imageUpstream.contentType) == null ? void 0 : _imageUpstream_contentType.toLowerCase().trim());\n    if (upstreamType) {\n        if (upstreamType.startsWith('image/svg') && !nextConfig.images.dangerouslyAllowSVG) {\n            if (!opts.silent) {\n                Log.error(`The requested resource \"${href}\" has type \"${upstreamType}\" but dangerouslyAllowSVG is disabled`);\n            }\n            throw Object.defineProperty(new ImageError(400, '\"url\" parameter is valid but image type is not allowed'), \"__NEXT_ERROR_CODE\", {\n                value: \"E394\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n        if (ANIMATABLE_TYPES.includes(upstreamType) && isAnimated(upstreamBuffer)) {\n            if (!opts.silent) {\n                Log.warnOnce(`The requested resource \"${href}\" is an animated image so it will not be optimized. Consider adding the \"unoptimized\" property to the <Image>.`);\n            }\n            return {\n                buffer: upstreamBuffer,\n                contentType: upstreamType,\n                maxAge,\n                etag: upstreamEtag,\n                upstreamEtag\n            };\n        }\n        if (BYPASS_TYPES.includes(upstreamType)) {\n            return {\n                buffer: upstreamBuffer,\n                contentType: upstreamType,\n                maxAge,\n                etag: upstreamEtag,\n                upstreamEtag\n            };\n        }\n        if (!upstreamType.startsWith('image/') || upstreamType.includes(',')) {\n            if (!opts.silent) {\n                Log.error(\"The requested resource isn't a valid image for\", href, 'received', upstreamType);\n            }\n            throw Object.defineProperty(new ImageError(400, \"The requested resource isn't a valid image.\"), \"__NEXT_ERROR_CODE\", {\n                value: \"E394\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n    }\n    let contentType;\n    if (mimeType) {\n        contentType = mimeType;\n    } else if ((upstreamType == null ? void 0 : upstreamType.startsWith('image/')) && getExtension(upstreamType) && upstreamType !== WEBP && upstreamType !== AVIF) {\n        contentType = upstreamType;\n    } else {\n        contentType = JPEG;\n    }\n    const previouslyCachedImage = getPreviouslyCachedImageOrNull(imageUpstream, opts.previousCacheEntry);\n    if (previouslyCachedImage) {\n        var _opts_previousCacheEntry_cacheControl, _opts_previousCacheEntry;\n        return {\n            buffer: previouslyCachedImage.buffer,\n            contentType,\n            maxAge: (opts == null ? void 0 : (_opts_previousCacheEntry = opts.previousCacheEntry) == null ? void 0 : (_opts_previousCacheEntry_cacheControl = _opts_previousCacheEntry.cacheControl) == null ? void 0 : _opts_previousCacheEntry_cacheControl.revalidate) || maxAge,\n            etag: previouslyCachedImage.etag,\n            upstreamEtag: previouslyCachedImage.upstreamEtag\n        };\n    }\n    try {\n        let optimizedBuffer = await optimizeImage({\n            buffer: upstreamBuffer,\n            contentType,\n            quality,\n            width,\n            concurrency: nextConfig.experimental.imgOptConcurrency,\n            limitInputPixels: nextConfig.experimental.imgOptMaxInputPixels,\n            sequentialRead: nextConfig.experimental.imgOptSequentialRead,\n            timeoutInSeconds: nextConfig.experimental.imgOptTimeoutInSeconds\n        });\n        if (opts.isDev && width <= BLUR_IMG_SIZE && quality === BLUR_QUALITY) {\n            // During `next dev`, we don't want to generate blur placeholders with webpack\n            // because it can delay starting the dev server. Instead, `next-image-loader.js`\n            // will inline a special url to lazily generate the blur placeholder at request time.\n            const meta = await getImageSize(optimizedBuffer);\n            const blurOpts = {\n                blurWidth: meta.width,\n                blurHeight: meta.height,\n                blurDataURL: `data:${contentType};base64,${optimizedBuffer.toString('base64')}`\n            };\n            optimizedBuffer = Buffer.from(unescape(getImageBlurSvg(blurOpts)));\n            contentType = 'image/svg+xml';\n        }\n        return {\n            buffer: optimizedBuffer,\n            contentType,\n            maxAge,\n            etag: getImageEtag(optimizedBuffer),\n            upstreamEtag\n        };\n    } catch (error) {\n        if (upstreamType) {\n            // If we fail to optimize, fallback to the original image\n            return {\n                buffer: upstreamBuffer,\n                contentType: upstreamType,\n                maxAge: nextConfig.images.minimumCacheTTL,\n                etag: upstreamEtag,\n                upstreamEtag,\n                error\n            };\n        } else {\n            throw Object.defineProperty(new ImageError(400, 'Unable to optimize image and unable to fallback to upstream image'), \"__NEXT_ERROR_CODE\", {\n                value: \"E394\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n    }\n}\nfunction getFileNameWithExtension(url, contentType) {\n    const [urlWithoutQueryParams] = url.split('?', 1);\n    const fileNameWithExtension = urlWithoutQueryParams.split('/').pop();\n    if (!contentType || !fileNameWithExtension) {\n        return 'image.bin';\n    }\n    const [fileName] = fileNameWithExtension.split('.', 1);\n    const extension = getExtension(contentType);\n    return `${fileName}.${extension}`;\n}\nfunction setResponseHeaders(req, res, url, etag, contentType, isStatic, xCache, imagesConfig, maxAge, isDev) {\n    res.setHeader('Vary', 'Accept');\n    res.setHeader('Cache-Control', isStatic ? 'public, max-age=315360000, immutable' : `public, max-age=${isDev ? 0 : maxAge}, must-revalidate`);\n    if (sendEtagResponse(req, res, etag)) {\n        // already called res.end() so we're finished\n        return {\n            finished: true\n        };\n    }\n    if (contentType) {\n        res.setHeader('Content-Type', contentType);\n    }\n    const fileName = getFileNameWithExtension(url, contentType);\n    res.setHeader('Content-Disposition', contentDisposition(fileName, {\n        type: imagesConfig.contentDispositionType\n    }));\n    res.setHeader('Content-Security-Policy', imagesConfig.contentSecurityPolicy);\n    res.setHeader('X-Nextjs-Cache', xCache);\n    return {\n        finished: false\n    };\n}\nexport function sendResponse(req, res, url, extension, buffer, etag, isStatic, xCache, imagesConfig, maxAge, isDev) {\n    const contentType = getContentType(extension);\n    const result = setResponseHeaders(req, res, url, etag, contentType, isStatic, xCache, imagesConfig, maxAge, isDev);\n    if (!result.finished) {\n        res.setHeader('Content-Length', Buffer.byteLength(buffer));\n        res.end(buffer);\n    }\n}\nexport async function getImageSize(buffer) {\n    const { width, height } = imageSizeOf(buffer);\n    return {\n        width,\n        height\n    };\n}\n\n//# sourceMappingURL=image-optimizer.js.map"
        }
    ]
}