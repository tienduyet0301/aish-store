{
    "sourceFile": "node_modules/next/dist/compiled/@next/font/dist/google/validate-google-font-function-call.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892707880,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.validateGoogleFontFunctionCall = validateGoogleFontFunctionCall;\nconst constants_1 = require(\"../constants\");\nconst format_available_values_1 = require(\"../format-available-values\");\nconst next_font_error_1 = require(\"../next-font-error\");\nconst google_fonts_metadata_1 = require(\"./google-fonts-metadata\");\n/**\n * Validate the data recieved from next-swc next-transform-font on next/font/google calls\n */\nfunction validateGoogleFontFunctionCall(functionName, fontFunctionArgument) {\n    let { weight, style, preload = true, display = 'swap', axes, fallback, adjustFontFallback = true, variable, subsets, } = fontFunctionArgument || {};\n    if (functionName === '') {\n        (0, next_font_error_1.nextFontError)(`next/font/google has no default export`);\n    }\n    const fontFamily = functionName.replace(/_/g, ' ');\n    // Get the Google font metadata, we'll use this to validate the font arguments and to print better error messages\n    const fontFamilyData = google_fonts_metadata_1.googleFontsMetadata[fontFamily];\n    if (!fontFamilyData) {\n        (0, next_font_error_1.nextFontError)(`Unknown font \\`${fontFamily}\\``);\n    }\n    const availableSubsets = fontFamilyData.subsets;\n    if (availableSubsets.length === 0) {\n        // If the font doesn't have any preloadeable subsets, disable preload\n        preload = false;\n    }\n    else if (preload) {\n        if (!subsets) {\n            (0, next_font_error_1.nextFontError)(`Preload is enabled but no subsets were specified for font \\`${fontFamily}\\`. Please specify subsets or disable preloading if your intended subset can't be preloaded.\\nAvailable subsets: ${(0, format_available_values_1.formatAvailableValues)(availableSubsets)}\\n\\nRead more: https://nextjs.org/docs/messages/google-fonts-missing-subsets`);\n        }\n        subsets.forEach((subset) => {\n            if (!availableSubsets.includes(subset)) {\n                (0, next_font_error_1.nextFontError)(`Unknown subset \\`${subset}\\` for font \\`${fontFamily}\\`.\\nAvailable subsets: ${(0, format_available_values_1.formatAvailableValues)(availableSubsets)}`);\n            }\n        });\n    }\n    const fontWeights = fontFamilyData.weights;\n    const fontStyles = fontFamilyData.styles;\n    // Get the unique weights and styles from the function call\n    const weights = !weight\n        ? []\n        : [...new Set(Array.isArray(weight) ? weight : [weight])];\n    const styles = !style\n        ? []\n        : [...new Set(Array.isArray(style) ? style : [style])];\n    if (weights.length === 0) {\n        // Set variable as default, throw if not available\n        if (fontWeights.includes('variable')) {\n            weights.push('variable');\n        }\n        else {\n            (0, next_font_error_1.nextFontError)(`Missing weight for font \\`${fontFamily}\\`.\\nAvailable weights: ${(0, format_available_values_1.formatAvailableValues)(fontWeights)}`);\n        }\n    }\n    if (weights.length > 1 && weights.includes('variable')) {\n        (0, next_font_error_1.nextFontError)(`Unexpected \\`variable\\` in weight array for font \\`${fontFamily}\\`. You only need \\`variable\\`, it includes all available weights.`);\n    }\n    weights.forEach((selectedWeight) => {\n        if (!fontWeights.includes(selectedWeight)) {\n            (0, next_font_error_1.nextFontError)(`Unknown weight \\`${selectedWeight}\\` for font \\`${fontFamily}\\`.\\nAvailable weights: ${(0, format_available_values_1.formatAvailableValues)(fontWeights)}`);\n        }\n    });\n    if (styles.length === 0) {\n        if (fontStyles.length === 1) {\n            // Handle default style for fonts that only have italic\n            styles.push(fontStyles[0]);\n        }\n        else {\n            // Otherwise set default style to normal\n            styles.push('normal');\n        }\n    }\n    styles.forEach((selectedStyle) => {\n        if (!fontStyles.includes(selectedStyle)) {\n            (0, next_font_error_1.nextFontError)(`Unknown style \\`${selectedStyle}\\` for font \\`${fontFamily}\\`.\\nAvailable styles: ${(0, format_available_values_1.formatAvailableValues)(fontStyles)}`);\n        }\n    });\n    if (!constants_1.allowedDisplayValues.includes(display)) {\n        (0, next_font_error_1.nextFontError)(`Invalid display value \\`${display}\\` for font \\`${fontFamily}\\`.\\nAvailable display values: ${(0, format_available_values_1.formatAvailableValues)(constants_1.allowedDisplayValues)}`);\n    }\n    if (axes) {\n        if (!fontWeights.includes('variable')) {\n            (0, next_font_error_1.nextFontError)('Axes can only be defined for variable fonts.');\n        }\n        if (weights[0] !== 'variable') {\n            (0, next_font_error_1.nextFontError)('Axes can only be defined for variable fonts when the weight property is nonexistent or set to `variable`.');\n        }\n    }\n    return {\n        fontFamily,\n        weights,\n        styles,\n        display,\n        preload,\n        selectedVariableAxes: axes,\n        fallback,\n        adjustFontFallback,\n        variable,\n        subsets,\n    };\n}\n"
        }
    ]
}