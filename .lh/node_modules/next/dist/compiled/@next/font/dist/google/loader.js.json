{
    "sourceFile": "node_modules/next/dist/compiled/@next/font/dist/google/loader.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892707734,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// @ts-ignore\nconst Log = __importStar(require(\"next/dist/build/output/log\"));\nconst validate_google_font_function_call_1 = require(\"./validate-google-font-function-call\");\nconst get_font_axes_1 = require(\"./get-font-axes\");\nconst get_google_fonts_url_1 = require(\"./get-google-fonts-url\");\nconst next_font_error_1 = require(\"../next-font-error\");\nconst find_font_files_in_css_1 = require(\"./find-font-files-in-css\");\nconst get_fallback_font_override_metrics_1 = require(\"./get-fallback-font-override-metrics\");\nconst fetch_css_from_google_fonts_1 = require(\"./fetch-css-from-google-fonts\");\nconst fetch_font_file_1 = require(\"./fetch-font-file\");\nconst cssCache = new Map();\nconst fontCache = new Map();\n// regexp is based on https://github.com/sindresorhus/escape-string-regexp\nconst reHasRegExp = /[|\\\\{}()[\\]^$+*?.-]/;\nconst reReplaceRegExp = /[|\\\\{}()[\\]^$+*?.-]/g;\nfunction escapeStringRegexp(str) {\n    // see also: https://github.com/lodash/lodash/blob/2da024c3b4f9947a48517639de7560457cd4ec6c/escapeRegExp.js#L23\n    if (reHasRegExp.test(str)) {\n        return str.replace(reReplaceRegExp, '\\\\$&');\n    }\n    return str;\n}\nconst nextFontGoogleFontLoader = async ({ functionName, data, emitFontFile, isDev, isServer, }) => {\n    var _a;\n    const { fontFamily, weights, styles, display, preload, selectedVariableAxes, fallback, adjustFontFallback, variable, subsets, } = (0, validate_google_font_function_call_1.validateGoogleFontFunctionCall)(functionName, data[0]);\n    // Validate and get the font axes required to generated the URL\n    const fontAxes = (0, get_font_axes_1.getFontAxes)(fontFamily, weights, styles, selectedVariableAxes);\n    // Generate the Google Fonts URL from the font family, axes and display value\n    const url = (0, get_google_fonts_url_1.getGoogleFontsUrl)(fontFamily, fontAxes, display);\n    // Get precalculated fallback font metrics, used to generate the fallback font CSS\n    const adjustFontFallbackMetrics = adjustFontFallback ? (0, get_fallback_font_override_metrics_1.getFallbackFontOverrideMetrics)(fontFamily) : undefined;\n    const result = {\n        fallbackFonts: fallback,\n        weight: weights.length === 1 && weights[0] !== 'variable'\n            ? weights[0]\n            : undefined,\n        style: styles.length === 1 ? styles[0] : undefined,\n        variable,\n        adjustFontFallback: adjustFontFallbackMetrics,\n    };\n    try {\n        /**\n         * Hacky way to make sure the fetch is only done once.\n         * Otherwise both the client and server compiler would fetch the CSS.\n         * The reason we need to return the actual CSS from both the server and client is because a hash is generated based on the CSS content.\n         */\n        const hasCachedCSS = cssCache.has(url);\n        // Fetch CSS from Google Fonts or get it from the cache\n        let fontFaceDeclarations = hasCachedCSS\n            ? cssCache.get(url)\n            : await (0, fetch_css_from_google_fonts_1.fetchCSSFromGoogleFonts)(url, fontFamily, isDev).catch((err) => {\n                console.error(err);\n                return null;\n            });\n        if (!hasCachedCSS) {\n            cssCache.set(url, fontFaceDeclarations !== null && fontFaceDeclarations !== void 0 ? fontFaceDeclarations : null);\n        }\n        else {\n            cssCache.delete(url);\n        }\n        if (fontFaceDeclarations == null) {\n            (0, next_font_error_1.nextFontError)(`Failed to fetch \\`${fontFamily}\\` from Google Fonts.`);\n        }\n        // CSS Variables may be set on a body tag, ignore them to keep the CSS module pure\n        fontFaceDeclarations = fontFaceDeclarations.split('body {', 1)[0];\n        // Find font files to download, provide the array of subsets we want to preload if preloading is enabled\n        const fontFiles = (0, find_font_files_in_css_1.findFontFilesInCss)(fontFaceDeclarations, preload ? subsets : undefined);\n        // Download the font files extracted from the CSS\n        const downloadedFiles = await Promise.all(fontFiles.map(async ({ googleFontFileUrl, preloadFontFile }) => {\n            const hasCachedFont = fontCache.has(googleFontFileUrl);\n            // Download the font file or get it from cache\n            const fontFileBuffer = hasCachedFont\n                ? fontCache.get(googleFontFileUrl)\n                : await (0, fetch_font_file_1.fetchFontFile)(googleFontFileUrl, isDev).catch((err) => {\n                    console.error(err);\n                    return null;\n                });\n            if (!hasCachedFont) {\n                fontCache.set(googleFontFileUrl, fontFileBuffer !== null && fontFileBuffer !== void 0 ? fontFileBuffer : null);\n            }\n            else {\n                fontCache.delete(googleFontFileUrl);\n            }\n            if (fontFileBuffer == null) {\n                (0, next_font_error_1.nextFontError)(`Failed to fetch \\`${fontFamily}\\` from Google Fonts.`);\n            }\n            const ext = /\\.(woff|woff2|eot|ttf|otf)$/.exec(googleFontFileUrl)[1];\n            // Emit font file to .next/static/media\n            const selfHostedFileUrl = emitFontFile(fontFileBuffer, ext, preloadFontFile, !!adjustFontFallbackMetrics);\n            return {\n                googleFontFileUrl,\n                selfHostedFileUrl,\n            };\n        }));\n        /**\n         * Replace the @font-face sources with the self-hosted files we just downloaded to .next/static/media\n         *\n         * E.g.\n         * @font-face {\n         *   font-family: 'Inter';\n         *   src: url(https://fonts.gstatic.com/...) -> url(/_next/static/media/_.woff2)\n         * }\n         */\n        let updatedCssResponse = fontFaceDeclarations;\n        for (const { googleFontFileUrl, selfHostedFileUrl } of downloadedFiles) {\n            updatedCssResponse = updatedCssResponse.replace(new RegExp(escapeStringRegexp(googleFontFileUrl), 'g'), selfHostedFileUrl);\n        }\n        return {\n            ...result,\n            css: updatedCssResponse,\n        };\n    }\n    catch (err) {\n        if (isDev) {\n            if (isServer) {\n                Log.error(`Failed to download \\`${fontFamily}\\` from Google Fonts. Using fallback font instead.\\n\\n${err.message}}`);\n            }\n            // In dev we should return the fallback font instead of throwing an error\n            let css = `@font-face {\n  font-family: '${fontFamily} Fallback';\n  src: local(\"${(_a = adjustFontFallbackMetrics === null || adjustFontFallbackMetrics === void 0 ? void 0 : adjustFontFallbackMetrics.fallbackFont) !== null && _a !== void 0 ? _a : 'Arial'}\");`;\n            if (adjustFontFallbackMetrics) {\n                css += `\n  ascent-override:${adjustFontFallbackMetrics.ascentOverride};\n  descent-override:${adjustFontFallbackMetrics.descentOverride};\n  line-gap-override:${adjustFontFallbackMetrics.lineGapOverride};\n  size-adjust:${adjustFontFallbackMetrics.sizeAdjust};`;\n            }\n            css += '\\n}';\n            return {\n                ...result,\n                css,\n            };\n        }\n        else {\n            throw err;\n        }\n    }\n};\nexports.default = nextFontGoogleFontLoader;\n"
        }
    ]
}