{
    "sourceFile": "node_modules/next/dist/compiled/@next/react-refresh-utils/dist/ReactRefreshWebpackPlugin.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892708672,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// Shared between webpack 4 and 5:\nfunction injectRefreshFunctions(compilation, Template) {\n    const hookVars = compilation.mainTemplate.hooks.localVars;\n    hookVars.tap('ReactFreshWebpackPlugin', (source) => Template.asString([\n        source,\n        '',\n        '// noop fns to prevent runtime errors during initialization',\n        'if (typeof self !== \"undefined\") {',\n        Template.indent('self.$RefreshReg$ = function () {};'),\n        Template.indent('self.$RefreshSig$ = function () {'),\n        Template.indent(Template.indent('return function (type) {')),\n        Template.indent(Template.indent(Template.indent('return type;'))),\n        Template.indent(Template.indent('};')),\n        Template.indent('};'),\n        '}',\n    ]));\n}\nfunction webpack4(compiler) {\n    const { Template } = this;\n    // Webpack 4 does not have a method to handle interception of module\n    // execution.\n    // The closest thing we have to emulating this is mimicking the behavior of\n    // `strictModuleExceptionHandling` in `MainTemplate`:\n    // https://github.com/webpack/webpack/blob/4c644bf1f7cb067c748a52614500e0e2182b2700/lib/MainTemplate.js#L200\n    compiler.hooks.compilation.tap('ReactFreshWebpackPlugin', (compilation) => {\n        injectRefreshFunctions(compilation, Template);\n        const hookRequire = compilation.mainTemplate.hooks.require;\n        // @ts-ignore webpack 5 types compat\n        hookRequire.tap('ReactFreshWebpackPlugin', (source) => {\n            // Webpack 4 evaluates module code on the following line:\n            // ```\n            // modules[moduleId].call(module.exports, module, module.exports, hotCreateRequire(moduleId));\n            // ```\n            // https://github.com/webpack/webpack/blob/4c644bf1f7cb067c748a52614500e0e2182b2700/lib/MainTemplate.js#L200\n            const lines = source.split('\\n');\n            // @ts-ignore webpack 5 types compat\n            const evalIndex = lines.findIndex((l) => l.includes('modules[moduleId].call('));\n            // Unable to find the module execution, that's OK:\n            if (evalIndex === -1) {\n                return source;\n            }\n            // Legacy CSS implementations will `eval` browser code in a Node.js\n            // context to extract CSS. For backwards compatibility, we need to check\n            // we're in a browser context before continuing.\n            return Template.asString([\n                ...lines.slice(0, evalIndex),\n                `\n        var hasRefresh = typeof self !== \"undefined\" && !!self.$RefreshInterceptModuleExecution$;\n        var cleanup = hasRefresh\n          ? self.$RefreshInterceptModuleExecution$(moduleId)\n          : function() {};\n        try {\n        `,\n                lines[evalIndex],\n                `\n        } finally {\n          cleanup();\n        }\n        `,\n                ...lines.slice(evalIndex + 1),\n            ]);\n        });\n    });\n}\nfunction webpack5(compiler) {\n    const { RuntimeGlobals, RuntimeModule, Template } = this;\n    class ReactRefreshRuntimeModule extends RuntimeModule {\n        constructor() {\n            super('react refresh', 5);\n        }\n        generate() {\n            const { runtimeTemplate } = this.compilation;\n            return Template.asString([\n                `if (${RuntimeGlobals.interceptModuleExecution}) {`,\n                `${RuntimeGlobals.interceptModuleExecution}.push(${runtimeTemplate.basicFunction('options', [\n                    `${runtimeTemplate.supportsConst() ? 'const' : 'var'} originalFactory = options.factory;`,\n                    `options.factory = ${runtimeTemplate.basicFunction('moduleObject, moduleExports, webpackRequire', [\n                        // Legacy CSS implementations will `eval` browser code in a Node.js\n                        // context to extract CSS. For backwards compatibility, we need to check\n                        // we're in a browser context before continuing.\n                        `${runtimeTemplate.supportsConst() ? 'const' : 'var'} hasRefresh = typeof self !== \"undefined\" && !!self.$RefreshInterceptModuleExecution$;`,\n                        `${runtimeTemplate.supportsConst() ? 'const' : 'var'} cleanup = hasRefresh ? self.$RefreshInterceptModuleExecution$(moduleObject.id) : ${runtimeTemplate.supportsArrowFunction()\n                            ? '() => {}'\n                            : 'function() {}'};`,\n                        'try {',\n                        Template.indent('originalFactory.call(this, moduleObject, moduleExports, webpackRequire);'),\n                        '} finally {',\n                        Template.indent(`cleanup();`),\n                        '}',\n                    ])}`,\n                ])})`,\n                '}',\n            ]);\n        }\n    }\n    // @ts-ignore webpack 5 types compat\n    compiler.hooks.compilation.tap('ReactFreshWebpackPlugin', (compilation) => {\n        injectRefreshFunctions(compilation, Template);\n        compilation.hooks.additionalTreeRuntimeRequirements.tap('ReactFreshWebpackPlugin', (chunk) => {\n            compilation.addRuntimeModule(chunk, new ReactRefreshRuntimeModule());\n        });\n    });\n}\nclass ReactFreshWebpackPlugin {\n    constructor({ version, RuntimeGlobals, RuntimeModule, Template } = require('webpack')) {\n        this.webpackMajorVersion = parseInt(version !== null && version !== void 0 ? version : '', 10);\n        this.RuntimeGlobals = RuntimeGlobals;\n        this.RuntimeModule = RuntimeModule;\n        this.Template = Template;\n    }\n    apply(compiler) {\n        switch (this.webpackMajorVersion) {\n            case 4: {\n                webpack4.call(this, compiler);\n                break;\n            }\n            case 5: {\n                webpack5.call(this, compiler);\n                break;\n            }\n            default: {\n                throw new Error(`ReactFreshWebpackPlugin does not support webpack v${this.webpackMajorVersion}.`);\n            }\n        }\n    }\n}\nexports.default = ReactFreshWebpackPlugin;\n//# sourceMappingURL=ReactRefreshWebpackPlugin.js.map"
        }
    ]
}