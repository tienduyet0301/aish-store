{
    "sourceFile": "node_modules/next/dist/compiled/react-refresh/cjs/react-refresh-babel.development.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892729075,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @license React\n * react-refresh-babel.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nif (process.env.NODE_ENV !== \"production\") {\n  (function() {\n'use strict';\n\nfunction ReactFreshBabelPlugin (babel) {\n  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  if (typeof babel.env === 'function') {\n    // Only available in Babel 7.\n    var env = babel.env();\n\n    if (env !== 'development' && !opts.skipEnvCheck) {\n      throw new Error('React Refresh Babel transform should only be enabled in development environment. ' + 'Instead, the environment is: \"' + env + '\". If you want to override this check, pass {skipEnvCheck: true} as plugin options.');\n    }\n  }\n\n  var t = babel.types;\n  var refreshReg = t.identifier(opts.refreshReg || '$RefreshReg$');\n  var refreshSig = t.identifier(opts.refreshSig || '$RefreshSig$');\n  var registrationsByProgramPath = new Map();\n\n  function createRegistration(programPath, persistentID) {\n    var handle = programPath.scope.generateUidIdentifier('c');\n\n    if (!registrationsByProgramPath.has(programPath)) {\n      registrationsByProgramPath.set(programPath, []);\n    }\n\n    var registrations = registrationsByProgramPath.get(programPath);\n    registrations.push({\n      handle: handle,\n      persistentID: persistentID\n    });\n    return handle;\n  }\n\n  function isComponentishName(name) {\n    return typeof name === 'string' && name[0] >= 'A' && name[0] <= 'Z';\n  }\n\n  function findInnerComponents(inferredName, path, callback) {\n    var node = path.node;\n\n    switch (node.type) {\n      case 'Identifier':\n        {\n          if (!isComponentishName(node.name)) {\n            return false;\n          } // export default hoc(Foo)\n          // const X = hoc(Foo)\n\n\n          callback(inferredName, node, null);\n          return true;\n        }\n\n      case 'FunctionDeclaration':\n        {\n          // function Foo() {}\n          // export function Foo() {}\n          // export default function Foo() {}\n          callback(inferredName, node.id, null);\n          return true;\n        }\n\n      case 'ArrowFunctionExpression':\n        {\n          if (node.body.type === 'ArrowFunctionExpression') {\n            return false;\n          } // let Foo = () => {}\n          // export default hoc1(hoc2(() => {}))\n\n\n          callback(inferredName, node, path);\n          return true;\n        }\n\n      case 'FunctionExpression':\n        {\n          // let Foo = function() {}\n          // const Foo = hoc1(forwardRef(function renderFoo() {}))\n          // export default memo(function() {})\n          callback(inferredName, node, path);\n          return true;\n        }\n\n      case 'CallExpression':\n        {\n          var argsPath = path.get('arguments');\n\n          if (argsPath === undefined || argsPath.length === 0) {\n            return false;\n          }\n\n          var calleePath = path.get('callee');\n\n          switch (calleePath.node.type) {\n            case 'MemberExpression':\n            case 'Identifier':\n              {\n                var calleeSource = calleePath.getSource();\n                var firstArgPath = argsPath[0];\n                var innerName = inferredName + '$' + calleeSource;\n                var foundInside = findInnerComponents(innerName, firstArgPath, callback);\n\n                if (!foundInside) {\n                  return false;\n                } // const Foo = hoc1(hoc2(() => {}))\n                // export default memo(React.forwardRef(function() {}))\n\n\n                callback(inferredName, node, path);\n                return true;\n              }\n\n            default:\n              {\n                return false;\n              }\n          }\n        }\n\n      case 'VariableDeclarator':\n        {\n          var init = node.init;\n\n          if (init === null) {\n            return false;\n          }\n\n          var name = node.id.name;\n\n          if (!isComponentishName(name)) {\n            return false;\n          }\n\n          switch (init.type) {\n            case 'ArrowFunctionExpression':\n            case 'FunctionExpression':\n              // Likely component definitions.\n              break;\n\n            case 'CallExpression':\n              {\n                // Maybe a HOC.\n                // Try to determine if this is some form of import.\n                var callee = init.callee;\n                var calleeType = callee.type;\n\n                if (calleeType === 'Import') {\n                  return false;\n                } else if (calleeType === 'Identifier') {\n                  if (callee.name.indexOf('require') === 0) {\n                    return false;\n                  } else if (callee.name.indexOf('import') === 0) {\n                    return false;\n                  } // Neither require nor import. Might be a HOC.\n                  // Pass through.\n\n                }\n\n                break;\n              }\n\n            case 'TaggedTemplateExpression':\n              // Maybe something like styled.div`...`\n              break;\n\n            default:\n              return false;\n          }\n\n          var initPath = path.get('init');\n\n          var _foundInside = findInnerComponents(inferredName, initPath, callback);\n\n          if (_foundInside) {\n            return true;\n          } // See if this identifier is used in JSX. Then it's a component.\n\n\n          var binding = path.scope.getBinding(name);\n\n          if (binding === undefined) {\n            return;\n          }\n\n          var isLikelyUsedAsType = false;\n          var referencePaths = binding.referencePaths;\n\n          for (var i = 0; i < referencePaths.length; i++) {\n            var ref = referencePaths[i];\n\n            if (ref.node && ref.node.type !== 'JSXIdentifier' && ref.node.type !== 'Identifier') {\n              continue;\n            }\n\n            var refParent = ref.parent;\n\n            if (refParent.type === 'JSXOpeningElement') {\n              isLikelyUsedAsType = true;\n            } else if (refParent.type === 'CallExpression') {\n              var _callee = refParent.callee;\n              var fnName = void 0;\n\n              switch (_callee.type) {\n                case 'Identifier':\n                  fnName = _callee.name;\n                  break;\n\n                case 'MemberExpression':\n                  fnName = _callee.property.name;\n                  break;\n              }\n\n              switch (fnName) {\n                case 'createElement':\n                case 'jsx':\n                case 'jsxDEV':\n                case 'jsxs':\n                  isLikelyUsedAsType = true;\n                  break;\n              }\n            }\n\n            if (isLikelyUsedAsType) {\n              // const X = ... + later <X />\n              callback(inferredName, init, initPath);\n              return true;\n            }\n          }\n        }\n    }\n\n    return false;\n  }\n\n  function isBuiltinHook(hookName) {\n    switch (hookName) {\n      case 'useState':\n      case 'React.useState':\n      case 'useReducer':\n      case 'React.useReducer':\n      case 'useEffect':\n      case 'React.useEffect':\n      case 'useLayoutEffect':\n      case 'React.useLayoutEffect':\n      case 'useMemo':\n      case 'React.useMemo':\n      case 'useCallback':\n      case 'React.useCallback':\n      case 'useRef':\n      case 'React.useRef':\n      case 'useContext':\n      case 'React.useContext':\n      case 'useImperativeHandle':\n      case 'React.useImperativeHandle':\n      case 'useDebugValue':\n      case 'React.useDebugValue':\n        return true;\n\n      default:\n        return false;\n    }\n  }\n\n  function getHookCallsSignature(functionNode) {\n    var fnHookCalls = hookCalls.get(functionNode);\n\n    if (fnHookCalls === undefined) {\n      return null;\n    }\n\n    return {\n      key: fnHookCalls.map(function (call) {\n        return call.name + '{' + call.key + '}';\n      }).join('\\n'),\n      customHooks: fnHookCalls.filter(function (call) {\n        return !isBuiltinHook(call.name);\n      }).map(function (call) {\n        return t.cloneDeep(call.callee);\n      })\n    };\n  }\n\n  var hasForceResetCommentByFile = new WeakMap(); // We let user do /* @refresh reset */ to reset state in the whole file.\n\n  function hasForceResetComment(path) {\n    var file = path.hub.file;\n    var hasForceReset = hasForceResetCommentByFile.get(file);\n\n    if (hasForceReset !== undefined) {\n      return hasForceReset;\n    }\n\n    hasForceReset = false;\n    var comments = file.ast.comments;\n\n    for (var i = 0; i < comments.length; i++) {\n      var cmt = comments[i];\n\n      if (cmt.value.indexOf('@refresh reset') !== -1) {\n        hasForceReset = true;\n        break;\n      }\n    }\n\n    hasForceResetCommentByFile.set(file, hasForceReset);\n    return hasForceReset;\n  }\n\n  function createArgumentsForSignature(node, signature, scope) {\n    var key = signature.key,\n        customHooks = signature.customHooks;\n    var forceReset = hasForceResetComment(scope.path);\n    var customHooksInScope = [];\n    customHooks.forEach(function (callee) {\n      // Check if a corresponding binding exists where we emit the signature.\n      var bindingName;\n\n      switch (callee.type) {\n        case 'MemberExpression':\n          if (callee.object.type === 'Identifier') {\n            bindingName = callee.object.name;\n          }\n\n          break;\n\n        case 'Identifier':\n          bindingName = callee.name;\n          break;\n      }\n\n      if (scope.hasBinding(bindingName)) {\n        customHooksInScope.push(callee);\n      } else {\n        // We don't have anything to put in the array because Hook is out of scope.\n        // Since it could potentially have been edited, remount the component.\n        forceReset = true;\n      }\n    });\n    var finalKey = key;\n\n    if (typeof require === 'function' && !opts.emitFullSignatures) {\n      // Prefer to hash when we can (e.g. outside of ASTExplorer).\n      // This makes it deterministically compact, even if there's\n      // e.g. a useState initializer with some code inside.\n      // We also need it for www that has transforms like cx()\n      // that don't understand if something is part of a string.\n      finalKey = require('crypto').createHash('sha1').update(key).digest('base64');\n    }\n\n    var args = [node, t.stringLiteral(finalKey)];\n\n    if (forceReset || customHooksInScope.length > 0) {\n      args.push(t.booleanLiteral(forceReset));\n    }\n\n    if (customHooksInScope.length > 0) {\n      args.push( // TODO: We could use an arrow here to be more compact.\n      // However, don't do it until AMA can run them natively.\n      t.functionExpression(null, [], t.blockStatement([t.returnStatement(t.arrayExpression(customHooksInScope))])));\n    }\n\n    return args;\n  }\n\n  function findHOCCallPathsAbove(path) {\n    var calls = [];\n\n    while (true) {\n      if (!path) {\n        return calls;\n      }\n\n      var parentPath = path.parentPath;\n\n      if (!parentPath) {\n        return calls;\n      }\n\n      if ( // hoc(_c = function() { })\n      parentPath.node.type === 'AssignmentExpression' && path.node === parentPath.node.right) {\n        // Ignore registrations.\n        path = parentPath;\n        continue;\n      }\n\n      if ( // hoc1(hoc2(...))\n      parentPath.node.type === 'CallExpression' && path.node !== parentPath.node.callee) {\n        calls.push(parentPath);\n        path = parentPath;\n        continue;\n      }\n\n      return calls; // Stop at other types.\n    }\n  }\n\n  var seenForRegistration = new WeakSet();\n  var seenForSignature = new WeakSet();\n  var seenForOutro = new WeakSet();\n  var hookCalls = new WeakMap();\n  var HookCallsVisitor = {\n    CallExpression: function (path) {\n      var node = path.node;\n      var callee = node.callee; // Note: this visitor MUST NOT mutate the tree in any way.\n      // It runs early in a separate traversal and should be very fast.\n\n      var name = null;\n\n      switch (callee.type) {\n        case 'Identifier':\n          name = callee.name;\n          break;\n\n        case 'MemberExpression':\n          name = callee.property.name;\n          break;\n      }\n\n      if (name === null || !/^use[A-Z]/.test(name)) {\n        return;\n      }\n\n      var fnScope = path.scope.getFunctionParent();\n\n      if (fnScope === null) {\n        return;\n      } // This is a Hook call. Record it.\n\n\n      var fnNode = fnScope.block;\n\n      if (!hookCalls.has(fnNode)) {\n        hookCalls.set(fnNode, []);\n      }\n\n      var hookCallsForFn = hookCalls.get(fnNode);\n      var key = '';\n\n      if (path.parent.type === 'VariableDeclarator') {\n        // TODO: if there is no LHS, consider some other heuristic.\n        key = path.parentPath.get('id').getSource();\n      } // Some built-in Hooks reset on edits to arguments.\n\n\n      var args = path.get('arguments');\n\n      if (name === 'useState' && args.length > 0) {\n        // useState second argument is initial state.\n        key += '(' + args[0].getSource() + ')';\n      } else if (name === 'useReducer' && args.length > 1) {\n        // useReducer second argument is initial state.\n        key += '(' + args[1].getSource() + ')';\n      }\n\n      hookCallsForFn.push({\n        callee: path.node.callee,\n        name: name,\n        key: key\n      });\n    }\n  };\n  return {\n    visitor: {\n      ExportDefaultDeclaration: function (path) {\n        var node = path.node;\n        var decl = node.declaration;\n        var declPath = path.get('declaration');\n\n        if (decl.type !== 'CallExpression') {\n          // For now, we only support possible HOC calls here.\n          // Named function declarations are handled in FunctionDeclaration.\n          // Anonymous direct exports like export default function() {}\n          // are currently ignored.\n          return;\n        } // Make sure we're not mutating the same tree twice.\n        // This can happen if another Babel plugin replaces parents.\n\n\n        if (seenForRegistration.has(node)) {\n          return;\n        }\n\n        seenForRegistration.add(node); // Don't mutate the tree above this point.\n        // This code path handles nested cases like:\n        // export default memo(() => {})\n        // In those cases it is more plausible people will omit names\n        // so they're worth handling despite possible false positives.\n        // More importantly, it handles the named case:\n        // export default memo(function Named() {})\n\n        var inferredName = '%default%';\n        var programPath = path.parentPath;\n        findInnerComponents(inferredName, declPath, function (persistentID, targetExpr, targetPath) {\n          if (targetPath === null) {\n            // For case like:\n            // export default hoc(Foo)\n            // we don't want to wrap Foo inside the call.\n            // Instead we assume it's registered at definition.\n            return;\n          }\n\n          var handle = createRegistration(programPath, persistentID);\n          targetPath.replaceWith(t.assignmentExpression('=', handle, targetExpr));\n        });\n      },\n      FunctionDeclaration: {\n        enter: function (path) {\n          var node = path.node;\n          var programPath;\n          var insertAfterPath;\n          var modulePrefix = '';\n\n          switch (path.parent.type) {\n            case 'Program':\n              insertAfterPath = path;\n              programPath = path.parentPath;\n              break;\n\n            case 'TSModuleBlock':\n              insertAfterPath = path;\n              programPath = insertAfterPath.parentPath.parentPath;\n              break;\n\n            case 'ExportNamedDeclaration':\n              insertAfterPath = path.parentPath;\n              programPath = insertAfterPath.parentPath;\n              break;\n\n            case 'ExportDefaultDeclaration':\n              insertAfterPath = path.parentPath;\n              programPath = insertAfterPath.parentPath;\n              break;\n\n            default:\n              return;\n          } // These types can be nested in typescript namespace\n          // We need to find the export chain\n          // Or return if it stays local\n\n\n          if (path.parent.type === 'TSModuleBlock' || path.parent.type === 'ExportNamedDeclaration') {\n            while (programPath.type !== 'Program') {\n              if (programPath.type === 'TSModuleDeclaration') {\n                if (programPath.parentPath.type !== 'Program' && programPath.parentPath.type !== 'ExportNamedDeclaration') {\n                  return;\n                }\n\n                modulePrefix = programPath.node.id.name + '$' + modulePrefix;\n              }\n\n              programPath = programPath.parentPath;\n            }\n          }\n\n          var id = node.id;\n\n          if (id === null) {\n            // We don't currently handle anonymous default exports.\n            return;\n          }\n\n          var inferredName = id.name;\n\n          if (!isComponentishName(inferredName)) {\n            return;\n          } // Make sure we're not mutating the same tree twice.\n          // This can happen if another Babel plugin replaces parents.\n\n\n          if (seenForRegistration.has(node)) {\n            return;\n          }\n\n          seenForRegistration.add(node); // Don't mutate the tree above this point.\n\n          var innerName = modulePrefix + inferredName; // export function Named() {}\n          // function Named() {}\n\n          findInnerComponents(innerName, path, function (persistentID, targetExpr) {\n            var handle = createRegistration(programPath, persistentID);\n            insertAfterPath.insertAfter(t.expressionStatement(t.assignmentExpression('=', handle, targetExpr)));\n          });\n        },\n        exit: function (path) {\n          var node = path.node;\n          var id = node.id;\n\n          if (id === null) {\n            return;\n          }\n\n          var signature = getHookCallsSignature(node);\n\n          if (signature === null) {\n            return;\n          } // Make sure we're not mutating the same tree twice.\n          // This can happen if another Babel plugin replaces parents.\n\n\n          if (seenForSignature.has(node)) {\n            return;\n          }\n\n          seenForSignature.add(node); // Don't mutate the tree above this point.\n\n          var sigCallID = path.scope.generateUidIdentifier('_s');\n          path.scope.parent.push({\n            id: sigCallID,\n            init: t.callExpression(refreshSig, [])\n          }); // The signature call is split in two parts. One part is called inside the function.\n          // This is used to signal when first render happens.\n\n          path.get('body').unshiftContainer('body', t.expressionStatement(t.callExpression(sigCallID, []))); // The second call is around the function itself.\n          // This is used to associate a type with a signature.\n          // Unlike with $RefreshReg$, this needs to work for nested\n          // declarations too. So we need to search for a path where\n          // we can insert a statement rather than hard coding it.\n\n          var insertAfterPath = null;\n          path.find(function (p) {\n            if (p.parentPath.isBlock()) {\n              insertAfterPath = p;\n              return true;\n            }\n          });\n\n          if (insertAfterPath === null) {\n            return;\n          }\n\n          insertAfterPath.insertAfter(t.expressionStatement(t.callExpression(sigCallID, createArgumentsForSignature(id, signature, insertAfterPath.scope))));\n        }\n      },\n      'ArrowFunctionExpression|FunctionExpression': {\n        exit: function (path) {\n          var node = path.node;\n          var signature = getHookCallsSignature(node);\n\n          if (signature === null) {\n            return;\n          } // Make sure we're not mutating the same tree twice.\n          // This can happen if another Babel plugin replaces parents.\n\n\n          if (seenForSignature.has(node)) {\n            return;\n          }\n\n          seenForSignature.add(node); // Don't mutate the tree above this point.\n\n          var sigCallID = path.scope.generateUidIdentifier('_s');\n          path.scope.parent.push({\n            id: sigCallID,\n            init: t.callExpression(refreshSig, [])\n          }); // The signature call is split in two parts. One part is called inside the function.\n          // This is used to signal when first render happens.\n\n          if (path.node.body.type !== 'BlockStatement') {\n            path.node.body = t.blockStatement([t.returnStatement(path.node.body)]);\n          }\n\n          path.get('body').unshiftContainer('body', t.expressionStatement(t.callExpression(sigCallID, []))); // The second call is around the function itself.\n          // This is used to associate a type with a signature.\n\n          if (path.parent.type === 'VariableDeclarator') {\n            var insertAfterPath = null;\n            path.find(function (p) {\n              if (p.parentPath.isBlock()) {\n                insertAfterPath = p;\n                return true;\n              }\n            });\n\n            if (insertAfterPath === null) {\n              return;\n            } // Special case when a function would get an inferred name:\n            // let Foo = () => {}\n            // let Foo = function() {}\n            // We'll add signature it on next line so that\n            // we don't mess up the inferred 'Foo' function name.\n\n\n            insertAfterPath.insertAfter(t.expressionStatement(t.callExpression(sigCallID, createArgumentsForSignature(path.parent.id, signature, insertAfterPath.scope)))); // Result: let Foo = () => {}; __signature(Foo, ...);\n          } else {\n            // let Foo = hoc(() => {})\n            var paths = [path].concat(findHOCCallPathsAbove(path));\n            paths.forEach(function (p) {\n              p.replaceWith(t.callExpression(sigCallID, createArgumentsForSignature(p.node, signature, p.scope)));\n            }); // Result: let Foo = __signature(hoc(__signature(() => {}, ...)), ...)\n          }\n        }\n      },\n      VariableDeclaration: function (path) {\n        var node = path.node;\n        var programPath;\n        var insertAfterPath;\n        var modulePrefix = '';\n\n        switch (path.parent.type) {\n          case 'Program':\n            insertAfterPath = path;\n            programPath = path.parentPath;\n            break;\n\n          case 'TSModuleBlock':\n            insertAfterPath = path;\n            programPath = insertAfterPath.parentPath.parentPath;\n            break;\n\n          case 'ExportNamedDeclaration':\n            insertAfterPath = path.parentPath;\n            programPath = insertAfterPath.parentPath;\n            break;\n\n          case 'ExportDefaultDeclaration':\n            insertAfterPath = path.parentPath;\n            programPath = insertAfterPath.parentPath;\n            break;\n\n          default:\n            return;\n        } // These types can be nested in typescript namespace\n        // We need to find the export chain\n        // Or return if it stays local\n\n\n        if (path.parent.type === 'TSModuleBlock' || path.parent.type === 'ExportNamedDeclaration') {\n          while (programPath.type !== 'Program') {\n            if (programPath.type === 'TSModuleDeclaration') {\n              if (programPath.parentPath.type !== 'Program' && programPath.parentPath.type !== 'ExportNamedDeclaration') {\n                return;\n              }\n\n              modulePrefix = programPath.node.id.name + '$' + modulePrefix;\n            }\n\n            programPath = programPath.parentPath;\n          }\n        } // Make sure we're not mutating the same tree twice.\n        // This can happen if another Babel plugin replaces parents.\n\n\n        if (seenForRegistration.has(node)) {\n          return;\n        }\n\n        seenForRegistration.add(node); // Don't mutate the tree above this point.\n\n        var declPaths = path.get('declarations');\n\n        if (declPaths.length !== 1) {\n          return;\n        }\n\n        var declPath = declPaths[0];\n        var inferredName = declPath.node.id.name;\n        var innerName = modulePrefix + inferredName;\n        findInnerComponents(innerName, declPath, function (persistentID, targetExpr, targetPath) {\n          if (targetPath === null) {\n            // For case like:\n            // export const Something = hoc(Foo)\n            // we don't want to wrap Foo inside the call.\n            // Instead we assume it's registered at definition.\n            return;\n          }\n\n          var handle = createRegistration(programPath, persistentID);\n\n          if (targetPath.parent.type === 'VariableDeclarator') {\n            // Special case when a variable would get an inferred name:\n            // let Foo = () => {}\n            // let Foo = function() {}\n            // let Foo = styled.div``;\n            // We'll register it on next line so that\n            // we don't mess up the inferred 'Foo' function name.\n            // (eg: with @babel/plugin-transform-react-display-name or\n            // babel-plugin-styled-components)\n            insertAfterPath.insertAfter(t.expressionStatement(t.assignmentExpression('=', handle, declPath.node.id))); // Result: let Foo = () => {}; _c1 = Foo;\n          } else {\n            // let Foo = hoc(() => {})\n            targetPath.replaceWith(t.assignmentExpression('=', handle, targetExpr)); // Result: let Foo = hoc(_c1 = () => {})\n          }\n        });\n      },\n      Program: {\n        enter: function (path) {\n          // This is a separate early visitor because we need to collect Hook calls\n          // and \"const [foo, setFoo] = ...\" signatures before the destructuring\n          // transform mangles them. This extra traversal is not ideal for perf,\n          // but it's the best we can do until we stop transpiling destructuring.\n          path.traverse(HookCallsVisitor);\n        },\n        exit: function (path) {\n          var registrations = registrationsByProgramPath.get(path);\n\n          if (registrations === undefined) {\n            return;\n          } // Make sure we're not mutating the same tree twice.\n          // This can happen if another Babel plugin replaces parents.\n\n\n          var node = path.node;\n\n          if (seenForOutro.has(node)) {\n            return;\n          }\n\n          seenForOutro.add(node); // Don't mutate the tree above this point.\n\n          registrationsByProgramPath.delete(path);\n          var declarators = [];\n          path.pushContainer('body', t.variableDeclaration('var', declarators));\n          registrations.forEach(function (_ref) {\n            var handle = _ref.handle,\n                persistentID = _ref.persistentID;\n            path.pushContainer('body', t.expressionStatement(t.callExpression(refreshReg, [handle, t.stringLiteral(persistentID)])));\n            declarators.push(t.variableDeclarator(handle));\n          });\n        }\n      }\n    }\n  };\n}\n\nmodule.exports = ReactFreshBabelPlugin;\n  })();\n}\n"
        }
    ]
}