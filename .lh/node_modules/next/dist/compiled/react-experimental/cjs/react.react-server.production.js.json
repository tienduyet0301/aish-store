{
    "sourceFile": "node_modules/next/dist/compiled/react-experimental/cjs/react.react-server.production.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892728701,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @license React\n * react.react-server.production.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\"use strict\";\nvar TaintRegistryObjects$1 = new WeakMap(),\n  TaintRegistryValues$1 = new Map(),\n  TaintRegistryByteLengths$1 = new Set(),\n  TaintRegistryPendingRequests$1 = new Set(),\n  ReactSharedInternals = {\n    H: null,\n    A: null,\n    TaintRegistryObjects: TaintRegistryObjects$1,\n    TaintRegistryValues: TaintRegistryValues$1,\n    TaintRegistryByteLengths: TaintRegistryByteLengths$1,\n    TaintRegistryPendingRequests: TaintRegistryPendingRequests$1\n  };\nfunction formatProdErrorMessage(code) {\n  var url = \"https://react.dev/errors/\" + code;\n  if (1 < arguments.length) {\n    url += \"?args[]=\" + encodeURIComponent(arguments[1]);\n    for (var i = 2; i < arguments.length; i++)\n      url += \"&args[]=\" + encodeURIComponent(arguments[i]);\n  }\n  return (\n    \"Minified React error #\" +\n    code +\n    \"; visit \" +\n    url +\n    \" for the full message or use the non-minified dev environment for full errors and additional helpful warnings.\"\n  );\n}\nvar isArrayImpl = Array.isArray,\n  REACT_ELEMENT_TYPE = Symbol.for(\"react.transitional.element\"),\n  REACT_PORTAL_TYPE = Symbol.for(\"react.portal\"),\n  REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\"),\n  REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\"),\n  REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\"),\n  REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\"),\n  REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\"),\n  REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\"),\n  REACT_MEMO_TYPE = Symbol.for(\"react.memo\"),\n  REACT_LAZY_TYPE = Symbol.for(\"react.lazy\"),\n  REACT_ACTIVITY_TYPE = Symbol.for(\"react.activity\"),\n  REACT_POSTPONE_TYPE = Symbol.for(\"react.postpone\"),\n  REACT_VIEW_TRANSITION_TYPE = Symbol.for(\"react.view_transition\"),\n  MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\nfunction getIteratorFn(maybeIterable) {\n  if (null === maybeIterable || \"object\" !== typeof maybeIterable) return null;\n  maybeIterable =\n    (MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL]) ||\n    maybeIterable[\"@@iterator\"];\n  return \"function\" === typeof maybeIterable ? maybeIterable : null;\n}\nvar hasOwnProperty = Object.prototype.hasOwnProperty,\n  assign = Object.assign;\nfunction ReactElement(type, key, self, source, owner, props) {\n  self = props.ref;\n  return {\n    $$typeof: REACT_ELEMENT_TYPE,\n    type: type,\n    key: key,\n    ref: void 0 !== self ? self : null,\n    props: props\n  };\n}\nfunction cloneAndReplaceKey(oldElement, newKey) {\n  return ReactElement(\n    oldElement.type,\n    newKey,\n    void 0,\n    void 0,\n    void 0,\n    oldElement.props\n  );\n}\nfunction isValidElement(object) {\n  return (\n    \"object\" === typeof object &&\n    null !== object &&\n    object.$$typeof === REACT_ELEMENT_TYPE\n  );\n}\nfunction escape(key) {\n  var escaperLookup = { \"=\": \"=0\", \":\": \"=2\" };\n  return (\n    \"$\" +\n    key.replace(/[=:]/g, function (match) {\n      return escaperLookup[match];\n    })\n  );\n}\nvar userProvidedKeyEscapeRegex = /\\/+/g;\nfunction getElementKey(element, index) {\n  return \"object\" === typeof element && null !== element && null != element.key\n    ? escape(\"\" + element.key)\n    : index.toString(36);\n}\nfunction noop$1() {}\nfunction resolveThenable(thenable) {\n  switch (thenable.status) {\n    case \"fulfilled\":\n      return thenable.value;\n    case \"rejected\":\n      throw thenable.reason;\n    default:\n      switch (\n        (\"string\" === typeof thenable.status\n          ? thenable.then(noop$1, noop$1)\n          : ((thenable.status = \"pending\"),\n            thenable.then(\n              function (fulfilledValue) {\n                \"pending\" === thenable.status &&\n                  ((thenable.status = \"fulfilled\"),\n                  (thenable.value = fulfilledValue));\n              },\n              function (error) {\n                \"pending\" === thenable.status &&\n                  ((thenable.status = \"rejected\"), (thenable.reason = error));\n              }\n            )),\n        thenable.status)\n      ) {\n        case \"fulfilled\":\n          return thenable.value;\n        case \"rejected\":\n          throw thenable.reason;\n      }\n  }\n  throw thenable;\n}\nfunction mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {\n  var type = typeof children;\n  if (\"undefined\" === type || \"boolean\" === type) children = null;\n  var invokeCallback = !1;\n  if (null === children) invokeCallback = !0;\n  else\n    switch (type) {\n      case \"bigint\":\n      case \"string\":\n      case \"number\":\n        invokeCallback = !0;\n        break;\n      case \"object\":\n        switch (children.$$typeof) {\n          case REACT_ELEMENT_TYPE:\n          case REACT_PORTAL_TYPE:\n            invokeCallback = !0;\n            break;\n          case REACT_LAZY_TYPE:\n            return (\n              (invokeCallback = children._init),\n              mapIntoArray(\n                invokeCallback(children._payload),\n                array,\n                escapedPrefix,\n                nameSoFar,\n                callback\n              )\n            );\n        }\n    }\n  if (invokeCallback)\n    return (\n      (callback = callback(children)),\n      (invokeCallback =\n        \"\" === nameSoFar ? \".\" + getElementKey(children, 0) : nameSoFar),\n      isArrayImpl(callback)\n        ? ((escapedPrefix = \"\"),\n          null != invokeCallback &&\n            (escapedPrefix =\n              invokeCallback.replace(userProvidedKeyEscapeRegex, \"$&/\") + \"/\"),\n          mapIntoArray(callback, array, escapedPrefix, \"\", function (c) {\n            return c;\n          }))\n        : null != callback &&\n          (isValidElement(callback) &&\n            (callback = cloneAndReplaceKey(\n              callback,\n              escapedPrefix +\n                (null == callback.key ||\n                (children && children.key === callback.key)\n                  ? \"\"\n                  : (\"\" + callback.key).replace(\n                      userProvidedKeyEscapeRegex,\n                      \"$&/\"\n                    ) + \"/\") +\n                invokeCallback\n            )),\n          array.push(callback)),\n      1\n    );\n  invokeCallback = 0;\n  var nextNamePrefix = \"\" === nameSoFar ? \".\" : nameSoFar + \":\";\n  if (isArrayImpl(children))\n    for (var i = 0; i < children.length; i++)\n      (nameSoFar = children[i]),\n        (type = nextNamePrefix + getElementKey(nameSoFar, i)),\n        (invokeCallback += mapIntoArray(\n          nameSoFar,\n          array,\n          escapedPrefix,\n          type,\n          callback\n        ));\n  else if (((i = getIteratorFn(children)), \"function\" === typeof i))\n    for (\n      children = i.call(children), i = 0;\n      !(nameSoFar = children.next()).done;\n\n    )\n      (nameSoFar = nameSoFar.value),\n        (type = nextNamePrefix + getElementKey(nameSoFar, i++)),\n        (invokeCallback += mapIntoArray(\n          nameSoFar,\n          array,\n          escapedPrefix,\n          type,\n          callback\n        ));\n  else if (\"object\" === type) {\n    if (\"function\" === typeof children.then)\n      return mapIntoArray(\n        resolveThenable(children),\n        array,\n        escapedPrefix,\n        nameSoFar,\n        callback\n      );\n    array = String(children);\n    throw Error(\n      formatProdErrorMessage(\n        31,\n        \"[object Object]\" === array\n          ? \"object with keys {\" + Object.keys(children).join(\", \") + \"}\"\n          : array\n      )\n    );\n  }\n  return invokeCallback;\n}\nfunction mapChildren(children, func, context) {\n  if (null == children) return children;\n  var result = [],\n    count = 0;\n  mapIntoArray(children, result, \"\", \"\", function (child) {\n    return func.call(context, child, count++);\n  });\n  return result;\n}\nfunction lazyInitializer(payload) {\n  if (-1 === payload._status) {\n    var ctor = payload._result;\n    ctor = ctor();\n    ctor.then(\n      function (moduleObject) {\n        if (0 === payload._status || -1 === payload._status)\n          (payload._status = 1), (payload._result = moduleObject);\n      },\n      function (error) {\n        if (0 === payload._status || -1 === payload._status)\n          (payload._status = 2), (payload._result = error);\n      }\n    );\n    -1 === payload._status && ((payload._status = 0), (payload._result = ctor));\n  }\n  if (1 === payload._status) return payload._result.default;\n  throw payload._result;\n}\nfunction createCacheRoot() {\n  return new WeakMap();\n}\nfunction createCacheNode() {\n  return { s: 0, v: void 0, o: null, p: null };\n}\nvar reportGlobalError =\n  \"function\" === typeof reportError\n    ? reportError\n    : function (error) {\n        if (\n          \"object\" === typeof window &&\n          \"function\" === typeof window.ErrorEvent\n        ) {\n          var event = new window.ErrorEvent(\"error\", {\n            bubbles: !0,\n            cancelable: !0,\n            message:\n              \"object\" === typeof error &&\n              null !== error &&\n              \"string\" === typeof error.message\n                ? String(error.message)\n                : String(error),\n            error: error\n          });\n          if (!window.dispatchEvent(event)) return;\n        } else if (\n          \"object\" === typeof process &&\n          \"function\" === typeof process.emit\n        ) {\n          process.emit(\"uncaughtException\", error);\n          return;\n        }\n        console.error(error);\n      };\nfunction noop() {}\nvar getPrototypeOf = Object.getPrototypeOf,\n  TaintRegistryObjects = ReactSharedInternals.TaintRegistryObjects,\n  TaintRegistryValues = ReactSharedInternals.TaintRegistryValues,\n  TaintRegistryByteLengths = ReactSharedInternals.TaintRegistryByteLengths,\n  TaintRegistryPendingRequests =\n    ReactSharedInternals.TaintRegistryPendingRequests,\n  TypedArrayConstructor = getPrototypeOf(Uint32Array.prototype).constructor;\nfunction cleanup(entryValue) {\n  var entry = TaintRegistryValues.get(entryValue);\n  void 0 !== entry &&\n    (TaintRegistryPendingRequests.forEach(function (requestQueue) {\n      requestQueue.push(entryValue);\n      entry.count++;\n    }),\n    1 === entry.count ? TaintRegistryValues.delete(entryValue) : entry.count--);\n}\nvar finalizationRegistry =\n  \"function\" === typeof FinalizationRegistry\n    ? new FinalizationRegistry(cleanup)\n    : null;\nexports.Children = {\n  map: mapChildren,\n  forEach: function (children, forEachFunc, forEachContext) {\n    mapChildren(\n      children,\n      function () {\n        forEachFunc.apply(this, arguments);\n      },\n      forEachContext\n    );\n  },\n  count: function (children) {\n    var n = 0;\n    mapChildren(children, function () {\n      n++;\n    });\n    return n;\n  },\n  toArray: function (children) {\n    return (\n      mapChildren(children, function (child) {\n        return child;\n      }) || []\n    );\n  },\n  only: function (children) {\n    if (!isValidElement(children)) throw Error(formatProdErrorMessage(143));\n    return children;\n  }\n};\nexports.Fragment = REACT_FRAGMENT_TYPE;\nexports.Profiler = REACT_PROFILER_TYPE;\nexports.StrictMode = REACT_STRICT_MODE_TYPE;\nexports.Suspense = REACT_SUSPENSE_TYPE;\nexports.__SERVER_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE =\n  ReactSharedInternals;\nexports.cache = function (fn) {\n  return function () {\n    var dispatcher = ReactSharedInternals.A;\n    if (!dispatcher) return fn.apply(null, arguments);\n    var fnMap = dispatcher.getCacheForType(createCacheRoot);\n    dispatcher = fnMap.get(fn);\n    void 0 === dispatcher &&\n      ((dispatcher = createCacheNode()), fnMap.set(fn, dispatcher));\n    fnMap = 0;\n    for (var l = arguments.length; fnMap < l; fnMap++) {\n      var arg = arguments[fnMap];\n      if (\n        \"function\" === typeof arg ||\n        (\"object\" === typeof arg && null !== arg)\n      ) {\n        var objectCache = dispatcher.o;\n        null === objectCache && (dispatcher.o = objectCache = new WeakMap());\n        dispatcher = objectCache.get(arg);\n        void 0 === dispatcher &&\n          ((dispatcher = createCacheNode()), objectCache.set(arg, dispatcher));\n      } else\n        (objectCache = dispatcher.p),\n          null === objectCache && (dispatcher.p = objectCache = new Map()),\n          (dispatcher = objectCache.get(arg)),\n          void 0 === dispatcher &&\n            ((dispatcher = createCacheNode()),\n            objectCache.set(arg, dispatcher));\n    }\n    if (1 === dispatcher.s) return dispatcher.v;\n    if (2 === dispatcher.s) throw dispatcher.v;\n    try {\n      var result = fn.apply(null, arguments);\n      fnMap = dispatcher;\n      fnMap.s = 1;\n      return (fnMap.v = result);\n    } catch (error) {\n      throw ((result = dispatcher), (result.s = 2), (result.v = error), error);\n    }\n  };\n};\nexports.cloneElement = function (element, config, children) {\n  if (null === element || void 0 === element)\n    throw Error(formatProdErrorMessage(267, element));\n  var props = assign({}, element.props),\n    key = element.key,\n    owner = void 0;\n  if (null != config)\n    for (propName in (void 0 !== config.ref && (owner = void 0),\n    void 0 !== config.key && (key = \"\" + config.key),\n    config))\n      !hasOwnProperty.call(config, propName) ||\n        \"key\" === propName ||\n        \"__self\" === propName ||\n        \"__source\" === propName ||\n        (\"ref\" === propName && void 0 === config.ref) ||\n        (props[propName] = config[propName]);\n  var propName = arguments.length - 2;\n  if (1 === propName) props.children = children;\n  else if (1 < propName) {\n    for (var childArray = Array(propName), i = 0; i < propName; i++)\n      childArray[i] = arguments[i + 2];\n    props.children = childArray;\n  }\n  return ReactElement(element.type, key, void 0, void 0, owner, props);\n};\nexports.createElement = function (type, config, children) {\n  var propName,\n    props = {},\n    key = null;\n  if (null != config)\n    for (propName in (void 0 !== config.key && (key = \"\" + config.key), config))\n      hasOwnProperty.call(config, propName) &&\n        \"key\" !== propName &&\n        \"__self\" !== propName &&\n        \"__source\" !== propName &&\n        (props[propName] = config[propName]);\n  var childrenLength = arguments.length - 2;\n  if (1 === childrenLength) props.children = children;\n  else if (1 < childrenLength) {\n    for (var childArray = Array(childrenLength), i = 0; i < childrenLength; i++)\n      childArray[i] = arguments[i + 2];\n    props.children = childArray;\n  }\n  if (type && type.defaultProps)\n    for (propName in ((childrenLength = type.defaultProps), childrenLength))\n      void 0 === props[propName] &&\n        (props[propName] = childrenLength[propName]);\n  return ReactElement(type, key, void 0, void 0, null, props);\n};\nexports.createRef = function () {\n  return { current: null };\n};\nexports.experimental_taintObjectReference = function (message, object) {\n  message =\n    \"\" +\n    (message ||\n      \"A tainted value was attempted to be serialized to a Client Component or Action closure. This would leak it to the client.\");\n  if (\"string\" === typeof object || \"bigint\" === typeof object)\n    throw Error(formatProdErrorMessage(496));\n  if (\n    null === object ||\n    (\"object\" !== typeof object && \"function\" !== typeof object)\n  )\n    throw Error(formatProdErrorMessage(497));\n  TaintRegistryObjects.set(object, message);\n};\nexports.experimental_taintUniqueValue = function (message, lifetime, value) {\n  message =\n    \"\" +\n    (message ||\n      \"A tainted value was attempted to be serialized to a Client Component or Action closure. This would leak it to the client.\");\n  if (\n    null === lifetime ||\n    (\"object\" !== typeof lifetime && \"function\" !== typeof lifetime)\n  )\n    throw Error(formatProdErrorMessage(493));\n  if (\"string\" !== typeof value && \"bigint\" !== typeof value)\n    if (value instanceof TypedArrayConstructor || value instanceof DataView)\n      TaintRegistryByteLengths.add(value.byteLength),\n        (value = String.fromCharCode.apply(\n          String,\n          new Uint8Array(value.buffer, value.byteOffset, value.byteLength)\n        ));\n    else {\n      message = null === value ? \"null\" : typeof value;\n      if (\"object\" === message || \"function\" === message)\n        throw Error(formatProdErrorMessage(494));\n      throw Error(formatProdErrorMessage(495, message));\n    }\n  var existingEntry = TaintRegistryValues.get(value);\n  void 0 === existingEntry\n    ? TaintRegistryValues.set(value, { message: message, count: 1 })\n    : existingEntry.count++;\n  null !== finalizationRegistry &&\n    finalizationRegistry.register(lifetime, value);\n};\nexports.forwardRef = function (render) {\n  return { $$typeof: REACT_FORWARD_REF_TYPE, render: render };\n};\nexports.isValidElement = isValidElement;\nexports.lazy = function (ctor) {\n  return {\n    $$typeof: REACT_LAZY_TYPE,\n    _payload: { _status: -1, _result: ctor },\n    _init: lazyInitializer\n  };\n};\nexports.memo = function (type, compare) {\n  return {\n    $$typeof: REACT_MEMO_TYPE,\n    type: type,\n    compare: void 0 === compare ? null : compare\n  };\n};\nexports.startTransition = function (scope) {\n  var prevTransition = ReactSharedInternals.T,\n    currentTransition = {};\n  currentTransition.types =\n    null !== prevTransition ? prevTransition.types : null;\n  currentTransition.gesture = null;\n  ReactSharedInternals.T = currentTransition;\n  try {\n    var returnValue = scope(),\n      onStartTransitionFinish = ReactSharedInternals.S;\n    null !== onStartTransitionFinish &&\n      onStartTransitionFinish(currentTransition, returnValue);\n    \"object\" === typeof returnValue &&\n      null !== returnValue &&\n      \"function\" === typeof returnValue.then &&\n      returnValue.then(noop, reportGlobalError);\n  } catch (error) {\n    reportGlobalError(error);\n  } finally {\n    null !== prevTransition &&\n      null !== currentTransition.types &&\n      (prevTransition.types = currentTransition.types),\n      (ReactSharedInternals.T = prevTransition);\n  }\n};\nexports.unstable_Activity = REACT_ACTIVITY_TYPE;\nexports.unstable_SuspenseList = REACT_SUSPENSE_LIST_TYPE;\nexports.unstable_ViewTransition = REACT_VIEW_TRANSITION_TYPE;\nexports.unstable_getCacheForType = function (resourceType) {\n  var dispatcher = ReactSharedInternals.A;\n  return dispatcher ? dispatcher.getCacheForType(resourceType) : resourceType();\n};\nexports.unstable_postpone = function (reason) {\n  reason = Error(reason);\n  reason.$$typeof = REACT_POSTPONE_TYPE;\n  throw reason;\n};\nexports.use = function (usable) {\n  return ReactSharedInternals.H.use(usable);\n};\nexports.useCallback = function (callback, deps) {\n  return ReactSharedInternals.H.useCallback(callback, deps);\n};\nexports.useDebugValue = function () {};\nexports.useId = function () {\n  return ReactSharedInternals.H.useId();\n};\nexports.useMemo = function (create, deps) {\n  return ReactSharedInternals.H.useMemo(create, deps);\n};\nexports.version = \"19.2.0-experimental-3fbfb9ba-20250409\";\n"
        }
    ]
}