{
    "sourceFile": "node_modules/next/dist/compiled/scheduler-experimental/cjs/scheduler-unstable_mock.development.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892738526,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @license React\n * scheduler-unstable_mock.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\"use strict\";\n\"production\" !== process.env.NODE_ENV &&\n  (function () {\n    function push(heap, node) {\n      var index = heap.length;\n      heap.push(node);\n      a: for (; 0 < index; ) {\n        var parentIndex = (index - 1) >>> 1,\n          parent = heap[parentIndex];\n        if (0 < compare(parent, node))\n          (heap[parentIndex] = node),\n            (heap[index] = parent),\n            (index = parentIndex);\n        else break a;\n      }\n    }\n    function peek(heap) {\n      return 0 === heap.length ? null : heap[0];\n    }\n    function pop(heap) {\n      if (0 === heap.length) return null;\n      var first = heap[0],\n        last = heap.pop();\n      if (last !== first) {\n        heap[0] = last;\n        a: for (\n          var index = 0, length = heap.length, halfLength = length >>> 1;\n          index < halfLength;\n\n        ) {\n          var leftIndex = 2 * (index + 1) - 1,\n            left = heap[leftIndex],\n            rightIndex = leftIndex + 1,\n            right = heap[rightIndex];\n          if (0 > compare(left, last))\n            rightIndex < length && 0 > compare(right, left)\n              ? ((heap[index] = right),\n                (heap[rightIndex] = last),\n                (index = rightIndex))\n              : ((heap[index] = left),\n                (heap[leftIndex] = last),\n                (index = leftIndex));\n          else if (rightIndex < length && 0 > compare(right, last))\n            (heap[index] = right),\n              (heap[rightIndex] = last),\n              (index = rightIndex);\n          else break a;\n        }\n      }\n      return first;\n    }\n    function compare(a, b) {\n      var diff = a.sortIndex - b.sortIndex;\n      return 0 !== diff ? diff : a.id - b.id;\n    }\n    function advanceTimers(currentTime) {\n      for (var timer = peek(timerQueue); null !== timer; ) {\n        if (null === timer.callback) pop(timerQueue);\n        else if (timer.startTime <= currentTime)\n          pop(timerQueue),\n            (timer.sortIndex = timer.expirationTime),\n            push(taskQueue, timer);\n        else break;\n        timer = peek(timerQueue);\n      }\n    }\n    function handleTimeout(currentTime) {\n      isHostTimeoutScheduled = !1;\n      advanceTimers(currentTime);\n      if (!isHostCallbackScheduled)\n        if (null !== peek(taskQueue))\n          (isHostCallbackScheduled = !0), (scheduledCallback = flushWork);\n        else {\n          var firstTimer = peek(timerQueue);\n          null !== firstTimer &&\n            ((currentTime = firstTimer.startTime - currentTime),\n            (scheduledTimeout = handleTimeout),\n            (timeoutTime = currentMockTime + currentTime));\n        }\n    }\n    function flushWork(hasTimeRemaining, initialTime) {\n      isHostCallbackScheduled = !1;\n      isHostTimeoutScheduled &&\n        ((isHostTimeoutScheduled = !1),\n        (scheduledTimeout = null),\n        (timeoutTime = -1));\n      isPerformingWork = !0;\n      var previousPriorityLevel = currentPriorityLevel;\n      try {\n        a: {\n          advanceTimers(initialTime);\n          for (\n            currentTask = peek(taskQueue);\n            null !== currentTask &&\n            (!(currentTask.expirationTime > initialTime) ||\n              (hasTimeRemaining && !shouldYieldToHost()));\n\n          ) {\n            var callback = currentTask.callback;\n            if (\"function\" === typeof callback) {\n              currentTask.callback = null;\n              currentPriorityLevel = currentTask.priorityLevel;\n              var continuationCallback = callback(\n                currentTask.expirationTime <= initialTime\n              );\n              initialTime = currentMockTime;\n              if (\"function\" === typeof continuationCallback) {\n                if (\n                  ((currentTask.callback = continuationCallback),\n                  advanceTimers(initialTime),\n                  shouldYieldForPaint)\n                ) {\n                  var JSCompiler_inline_result = (needsPaint = !0);\n                  break a;\n                }\n              } else\n                currentTask === peek(taskQueue) && pop(taskQueue),\n                  advanceTimers(initialTime);\n            } else pop(taskQueue);\n            currentTask = peek(taskQueue);\n          }\n          if (null !== currentTask) JSCompiler_inline_result = !0;\n          else {\n            var firstTimer = peek(timerQueue);\n            if (null !== firstTimer) {\n              var ms = firstTimer.startTime - initialTime;\n              scheduledTimeout = handleTimeout;\n              timeoutTime = currentMockTime + ms;\n            }\n            JSCompiler_inline_result = !1;\n          }\n        }\n        return JSCompiler_inline_result;\n      } finally {\n        (currentTask = null),\n          (currentPriorityLevel = previousPriorityLevel),\n          (isPerformingWork = !1);\n      }\n    }\n    function shouldYieldToHost() {\n      return (0 === expectedNumberOfYields && null === yieldedValues) ||\n        (-1 !== expectedNumberOfYields &&\n          null !== yieldedValues &&\n          yieldedValues.length >= expectedNumberOfYields) ||\n        (shouldYieldForPaint && needsPaint)\n        ? (didStop = !0)\n        : !1;\n    }\n    function unstable_flushAllWithoutAsserting() {\n      if (isFlushing) throw Error(\"Already flushing work.\");\n      if (null !== scheduledCallback) {\n        var cb = scheduledCallback;\n        isFlushing = !0;\n        try {\n          var hasMoreWork = !0;\n          do hasMoreWork = cb(!0, currentMockTime);\n          while (hasMoreWork);\n          hasMoreWork || (scheduledCallback = null);\n          return !0;\n        } finally {\n          isFlushing = !1;\n        }\n      } else return !1;\n    }\n    var taskQueue = [],\n      timerQueue = [],\n      taskIdCounter = 1,\n      currentTask = null,\n      currentPriorityLevel = 3,\n      isPerformingWork = !1,\n      isHostCallbackScheduled = !1,\n      isHostTimeoutScheduled = !1,\n      currentMockTime = 0,\n      scheduledCallback = null,\n      scheduledTimeout = null,\n      timeoutTime = -1,\n      yieldedValues = null,\n      expectedNumberOfYields = -1,\n      didStop = !1,\n      isFlushing = !1,\n      needsPaint = !1,\n      shouldYieldForPaint = !1,\n      disableYieldValue = !1;\n    exports.log = function (value) {\n      \"disabledLog\" === console.log.name ||\n        disableYieldValue ||\n        (null === yieldedValues\n          ? (yieldedValues = [value])\n          : yieldedValues.push(value));\n    };\n    exports.reset = function () {\n      if (isFlushing) throw Error(\"Cannot reset while already flushing work.\");\n      currentMockTime = 0;\n      scheduledTimeout = scheduledCallback = null;\n      timeoutTime = -1;\n      yieldedValues = null;\n      expectedNumberOfYields = -1;\n      needsPaint = isFlushing = didStop = !1;\n    };\n    exports.unstable_IdlePriority = 5;\n    exports.unstable_ImmediatePriority = 1;\n    exports.unstable_LowPriority = 4;\n    exports.unstable_NormalPriority = 3;\n    exports.unstable_Profiling = null;\n    exports.unstable_UserBlockingPriority = 2;\n    exports.unstable_advanceTime = function (ms) {\n      \"disabledLog\" === console.log.name ||\n        disableYieldValue ||\n        ((currentMockTime += ms),\n        null !== scheduledTimeout &&\n          timeoutTime <= currentMockTime &&\n          (scheduledTimeout(currentMockTime),\n          (timeoutTime = -1),\n          (scheduledTimeout = null)));\n    };\n    exports.unstable_cancelCallback = function (task) {\n      task.callback = null;\n    };\n    exports.unstable_clearLog = function () {\n      if (null === yieldedValues) return [];\n      var values = yieldedValues;\n      yieldedValues = null;\n      return values;\n    };\n    exports.unstable_flushAll = function () {\n      if (null !== yieldedValues)\n        throw Error(\n          \"Log is not empty. Assert on the log of yielded values before flushing additional work.\"\n        );\n      unstable_flushAllWithoutAsserting();\n      if (null !== yieldedValues)\n        throw Error(\n          \"While flushing work, something yielded a value. Use an assertion helper to assert on the log of yielded values, e.g. expect(Scheduler).toFlushAndYield([...])\"\n        );\n    };\n    exports.unstable_flushAllWithoutAsserting =\n      unstable_flushAllWithoutAsserting;\n    exports.unstable_flushExpired = function () {\n      if (isFlushing) throw Error(\"Already flushing work.\");\n      if (null !== scheduledCallback) {\n        isFlushing = !0;\n        try {\n          scheduledCallback(!1, currentMockTime) || (scheduledCallback = null);\n        } finally {\n          isFlushing = !1;\n        }\n      }\n    };\n    exports.unstable_flushNumberOfYields = function (count) {\n      if (isFlushing) throw Error(\"Already flushing work.\");\n      if (null !== scheduledCallback) {\n        var cb = scheduledCallback;\n        expectedNumberOfYields = count;\n        isFlushing = !0;\n        try {\n          count = !0;\n          do count = cb(!0, currentMockTime);\n          while (count && !didStop);\n          count || (scheduledCallback = null);\n        } finally {\n          (expectedNumberOfYields = -1), (isFlushing = didStop = !1);\n        }\n      }\n    };\n    exports.unstable_flushUntilNextPaint = function () {\n      if (isFlushing) throw Error(\"Already flushing work.\");\n      if (null !== scheduledCallback) {\n        var cb = scheduledCallback;\n        shouldYieldForPaint = !0;\n        needsPaint = !1;\n        isFlushing = !0;\n        try {\n          var hasMoreWork = !0;\n          do hasMoreWork = cb(!0, currentMockTime);\n          while (hasMoreWork && !didStop);\n          hasMoreWork || (scheduledCallback = null);\n        } finally {\n          isFlushing = didStop = shouldYieldForPaint = !1;\n        }\n      }\n      return !1;\n    };\n    exports.unstable_forceFrameRate = function () {};\n    exports.unstable_getCurrentPriorityLevel = function () {\n      return currentPriorityLevel;\n    };\n    exports.unstable_hasPendingWork = function () {\n      return null !== scheduledCallback;\n    };\n    exports.unstable_next = function (eventHandler) {\n      switch (currentPriorityLevel) {\n        case 1:\n        case 2:\n        case 3:\n          var priorityLevel = 3;\n          break;\n        default:\n          priorityLevel = currentPriorityLevel;\n      }\n      var previousPriorityLevel = currentPriorityLevel;\n      currentPriorityLevel = priorityLevel;\n      try {\n        return eventHandler();\n      } finally {\n        currentPriorityLevel = previousPriorityLevel;\n      }\n    };\n    exports.unstable_now = function () {\n      return currentMockTime;\n    };\n    exports.unstable_requestPaint = function () {\n      needsPaint = !0;\n    };\n    exports.unstable_runWithPriority = function (priorityLevel, eventHandler) {\n      switch (priorityLevel) {\n        case 1:\n        case 2:\n        case 3:\n        case 4:\n        case 5:\n          break;\n        default:\n          priorityLevel = 3;\n      }\n      var previousPriorityLevel = currentPriorityLevel;\n      currentPriorityLevel = priorityLevel;\n      try {\n        return eventHandler();\n      } finally {\n        currentPriorityLevel = previousPriorityLevel;\n      }\n    };\n    exports.unstable_scheduleCallback = function (\n      priorityLevel,\n      callback,\n      options\n    ) {\n      var currentTime = currentMockTime;\n      \"object\" === typeof options && null !== options\n        ? ((options = options.delay),\n          (options =\n            \"number\" === typeof options && 0 < options\n              ? currentTime + options\n              : currentTime))\n        : (options = currentTime);\n      switch (priorityLevel) {\n        case 1:\n          var timeout = -1;\n          break;\n        case 2:\n          timeout = 250;\n          break;\n        case 5:\n          timeout = 1073741823;\n          break;\n        case 4:\n          timeout = 1e4;\n          break;\n        default:\n          timeout = 5e3;\n      }\n      timeout = options + timeout;\n      priorityLevel = {\n        id: taskIdCounter++,\n        callback: callback,\n        priorityLevel: priorityLevel,\n        startTime: options,\n        expirationTime: timeout,\n        sortIndex: -1\n      };\n      options > currentTime\n        ? ((priorityLevel.sortIndex = options),\n          push(timerQueue, priorityLevel),\n          null === peek(taskQueue) &&\n            priorityLevel === peek(timerQueue) &&\n            (isHostTimeoutScheduled\n              ? ((scheduledTimeout = null), (timeoutTime = -1))\n              : (isHostTimeoutScheduled = !0),\n            (scheduledTimeout = handleTimeout),\n            (timeoutTime = currentMockTime + (options - currentTime))))\n        : ((priorityLevel.sortIndex = timeout),\n          push(taskQueue, priorityLevel),\n          isHostCallbackScheduled ||\n            isPerformingWork ||\n            ((isHostCallbackScheduled = !0), (scheduledCallback = flushWork)));\n      return priorityLevel;\n    };\n    exports.unstable_setDisableYieldValue = function (newValue) {\n      disableYieldValue = newValue;\n    };\n    exports.unstable_shouldYield = shouldYieldToHost;\n    exports.unstable_wrapCallback = function (callback) {\n      var parentPriorityLevel = currentPriorityLevel;\n      return function () {\n        var previousPriorityLevel = currentPriorityLevel;\n        currentPriorityLevel = parentPriorityLevel;\n        try {\n          return callback.apply(this, arguments);\n        } finally {\n          currentPriorityLevel = previousPriorityLevel;\n        }\n      };\n    };\n  })();\n"
        }
    ]
}