{
    "sourceFile": "node_modules/next/dist/compiled/scheduler-experimental/cjs/scheduler.native.production.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892738782,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @license React\n * scheduler.native.production.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\"use strict\";\nfunction push(heap, node) {\n  var index = heap.length;\n  heap.push(node);\n  a: for (; 0 < index; ) {\n    var parentIndex = (index - 1) >>> 1,\n      parent = heap[parentIndex];\n    if (0 < compare(parent, node))\n      (heap[parentIndex] = node), (heap[index] = parent), (index = parentIndex);\n    else break a;\n  }\n}\nfunction peek(heap) {\n  return 0 === heap.length ? null : heap[0];\n}\nfunction pop(heap) {\n  if (0 === heap.length) return null;\n  var first = heap[0],\n    last = heap.pop();\n  if (last !== first) {\n    heap[0] = last;\n    a: for (\n      var index = 0, length = heap.length, halfLength = length >>> 1;\n      index < halfLength;\n\n    ) {\n      var leftIndex = 2 * (index + 1) - 1,\n        left = heap[leftIndex],\n        rightIndex = leftIndex + 1,\n        right = heap[rightIndex];\n      if (0 > compare(left, last))\n        rightIndex < length && 0 > compare(right, left)\n          ? ((heap[index] = right),\n            (heap[rightIndex] = last),\n            (index = rightIndex))\n          : ((heap[index] = left),\n            (heap[leftIndex] = last),\n            (index = leftIndex));\n      else if (rightIndex < length && 0 > compare(right, last))\n        (heap[index] = right), (heap[rightIndex] = last), (index = rightIndex);\n      else break a;\n    }\n  }\n  return first;\n}\nfunction compare(a, b) {\n  var diff = a.sortIndex - b.sortIndex;\n  return 0 !== diff ? diff : a.id - b.id;\n}\nvar getCurrentTime;\nif (\"object\" === typeof performance && \"function\" === typeof performance.now) {\n  var localPerformance = performance;\n  getCurrentTime = function () {\n    return localPerformance.now();\n  };\n} else {\n  var localDate = Date,\n    initialTime = localDate.now();\n  getCurrentTime = function () {\n    return localDate.now() - initialTime;\n  };\n}\nvar taskQueue = [],\n  timerQueue = [],\n  taskIdCounter = 1,\n  currentTask = null,\n  currentPriorityLevel = 3,\n  isPerformingWork = !1,\n  isHostCallbackScheduled = !1,\n  isHostTimeoutScheduled = !1,\n  localSetTimeout = \"function\" === typeof setTimeout ? setTimeout : null,\n  localClearTimeout = \"function\" === typeof clearTimeout ? clearTimeout : null,\n  localSetImmediate = \"undefined\" !== typeof setImmediate ? setImmediate : null;\nfunction advanceTimers(currentTime) {\n  for (var timer = peek(timerQueue); null !== timer; ) {\n    if (null === timer.callback) pop(timerQueue);\n    else if (timer.startTime <= currentTime)\n      pop(timerQueue),\n        (timer.sortIndex = timer.expirationTime),\n        push(taskQueue, timer);\n    else break;\n    timer = peek(timerQueue);\n  }\n}\nfunction handleTimeout(currentTime) {\n  isHostTimeoutScheduled = !1;\n  advanceTimers(currentTime);\n  if (!isHostCallbackScheduled)\n    if (null !== peek(taskQueue))\n      (isHostCallbackScheduled = !0),\n        isMessageLoopRunning ||\n          ((isMessageLoopRunning = !0), schedulePerformWorkUntilDeadline());\n    else {\n      var firstTimer = peek(timerQueue);\n      null !== firstTimer &&\n        requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);\n    }\n}\nfunction unstable_scheduleCallback$1(priorityLevel, callback, options) {\n  var currentTime = getCurrentTime();\n  \"object\" === typeof options && null !== options\n    ? ((options = options.delay),\n      (options =\n        \"number\" === typeof options && 0 < options\n          ? currentTime + options\n          : currentTime))\n    : (options = currentTime);\n  switch (priorityLevel) {\n    case 1:\n      var timeout = -1;\n      break;\n    case 2:\n      timeout = 250;\n      break;\n    case 5:\n      timeout = 1073741823;\n      break;\n    case 4:\n      timeout = 1e4;\n      break;\n    default:\n      timeout = 5e3;\n  }\n  timeout = options + timeout;\n  priorityLevel = {\n    id: taskIdCounter++,\n    callback: callback,\n    priorityLevel: priorityLevel,\n    startTime: options,\n    expirationTime: timeout,\n    sortIndex: -1\n  };\n  options > currentTime\n    ? ((priorityLevel.sortIndex = options),\n      push(timerQueue, priorityLevel),\n      null === peek(taskQueue) &&\n        priorityLevel === peek(timerQueue) &&\n        (isHostTimeoutScheduled\n          ? (localClearTimeout(taskTimeoutID), (taskTimeoutID = -1))\n          : (isHostTimeoutScheduled = !0),\n        requestHostTimeout(handleTimeout, options - currentTime)))\n    : ((priorityLevel.sortIndex = timeout),\n      push(taskQueue, priorityLevel),\n      isHostCallbackScheduled ||\n        isPerformingWork ||\n        ((isHostCallbackScheduled = !0),\n        isMessageLoopRunning ||\n          ((isMessageLoopRunning = !0), schedulePerformWorkUntilDeadline())));\n  return priorityLevel;\n}\nfunction unstable_cancelCallback$1(task) {\n  task.callback = null;\n}\nfunction unstable_getCurrentPriorityLevel$1() {\n  return currentPriorityLevel;\n}\nvar isMessageLoopRunning = !1,\n  taskTimeoutID = -1,\n  startTime = -1;\nfunction shouldYieldToHost() {\n  return 5 > getCurrentTime() - startTime ? !1 : !0;\n}\nfunction requestPaint() {}\nfunction performWorkUntilDeadline() {\n  if (isMessageLoopRunning) {\n    var currentTime = getCurrentTime();\n    startTime = currentTime;\n    var hasMoreWork = !0;\n    try {\n      a: {\n        isHostCallbackScheduled = !1;\n        isHostTimeoutScheduled &&\n          ((isHostTimeoutScheduled = !1),\n          localClearTimeout(taskTimeoutID),\n          (taskTimeoutID = -1));\n        isPerformingWork = !0;\n        var previousPriorityLevel = currentPriorityLevel;\n        try {\n          b: {\n            advanceTimers(currentTime);\n            for (currentTask = peek(taskQueue); null !== currentTask; ) {\n              var callback = currentTask.callback;\n              if (\"function\" === typeof callback) {\n                currentTask.callback = null;\n                currentPriorityLevel = currentTask.priorityLevel;\n                var continuationCallback = callback(\n                  currentTask.expirationTime <= currentTime\n                );\n                currentTime = getCurrentTime();\n                if (\"function\" === typeof continuationCallback) {\n                  currentTask.callback = continuationCallback;\n                  advanceTimers(currentTime);\n                  hasMoreWork = !0;\n                  break b;\n                }\n                currentTask === peek(taskQueue) && pop(taskQueue);\n                advanceTimers(currentTime);\n              } else pop(taskQueue);\n              currentTask = peek(taskQueue);\n              if (\n                null === currentTask ||\n                currentTask.expirationTime > currentTime\n              )\n                break;\n            }\n            if (null !== currentTask) hasMoreWork = !0;\n            else {\n              var firstTimer = peek(timerQueue);\n              null !== firstTimer &&\n                requestHostTimeout(\n                  handleTimeout,\n                  firstTimer.startTime - currentTime\n                );\n              hasMoreWork = !1;\n            }\n          }\n          break a;\n        } finally {\n          (currentTask = null),\n            (currentPriorityLevel = previousPriorityLevel),\n            (isPerformingWork = !1);\n        }\n        hasMoreWork = void 0;\n      }\n    } finally {\n      hasMoreWork\n        ? schedulePerformWorkUntilDeadline()\n        : (isMessageLoopRunning = !1);\n    }\n  }\n}\nvar schedulePerformWorkUntilDeadline;\nif (\"function\" === typeof localSetImmediate)\n  schedulePerformWorkUntilDeadline = function () {\n    localSetImmediate(performWorkUntilDeadline);\n  };\nelse if (\"undefined\" !== typeof MessageChannel) {\n  var channel = new MessageChannel(),\n    port = channel.port2;\n  channel.port1.onmessage = performWorkUntilDeadline;\n  schedulePerformWorkUntilDeadline = function () {\n    port.postMessage(null);\n  };\n} else\n  schedulePerformWorkUntilDeadline = function () {\n    localSetTimeout(performWorkUntilDeadline, 0);\n  };\nfunction requestHostTimeout(callback, ms) {\n  taskTimeoutID = localSetTimeout(function () {\n    callback(getCurrentTime());\n  }, ms);\n}\nvar unstable_UserBlockingPriority =\n    \"undefined\" !== typeof nativeRuntimeScheduler\n      ? nativeRuntimeScheduler.unstable_UserBlockingPriority\n      : 2,\n  unstable_NormalPriority =\n    \"undefined\" !== typeof nativeRuntimeScheduler\n      ? nativeRuntimeScheduler.unstable_NormalPriority\n      : 3,\n  unstable_LowPriority =\n    \"undefined\" !== typeof nativeRuntimeScheduler\n      ? nativeRuntimeScheduler.unstable_LowPriority\n      : 4,\n  unstable_ImmediatePriority =\n    \"undefined\" !== typeof nativeRuntimeScheduler\n      ? nativeRuntimeScheduler.unstable_ImmediatePriority\n      : 1,\n  unstable_scheduleCallback =\n    \"undefined\" !== typeof nativeRuntimeScheduler\n      ? nativeRuntimeScheduler.unstable_scheduleCallback\n      : unstable_scheduleCallback$1,\n  unstable_cancelCallback =\n    \"undefined\" !== typeof nativeRuntimeScheduler\n      ? nativeRuntimeScheduler.unstable_cancelCallback\n      : unstable_cancelCallback$1,\n  unstable_getCurrentPriorityLevel =\n    \"undefined\" !== typeof nativeRuntimeScheduler\n      ? nativeRuntimeScheduler.unstable_getCurrentPriorityLevel\n      : unstable_getCurrentPriorityLevel$1,\n  unstable_shouldYield =\n    \"undefined\" !== typeof nativeRuntimeScheduler\n      ? nativeRuntimeScheduler.unstable_shouldYield\n      : shouldYieldToHost,\n  unstable_requestPaint =\n    \"undefined\" !== typeof nativeRuntimeScheduler\n      ? nativeRuntimeScheduler.unstable_requestPaint\n      : requestPaint,\n  unstable_now =\n    \"undefined\" !== typeof nativeRuntimeScheduler\n      ? nativeRuntimeScheduler.unstable_now\n      : getCurrentTime;\nfunction throwNotImplemented() {\n  throw Error(\"Not implemented.\");\n}\nexports.unstable_IdlePriority =\n  \"undefined\" !== typeof nativeRuntimeScheduler\n    ? nativeRuntimeScheduler.unstable_IdlePriority\n    : 5;\nexports.unstable_ImmediatePriority = unstable_ImmediatePriority;\nexports.unstable_LowPriority = unstable_LowPriority;\nexports.unstable_NormalPriority = unstable_NormalPriority;\nexports.unstable_Profiling = null;\nexports.unstable_UserBlockingPriority = unstable_UserBlockingPriority;\nexports.unstable_cancelCallback = unstable_cancelCallback;\nexports.unstable_forceFrameRate = throwNotImplemented;\nexports.unstable_getCurrentPriorityLevel = unstable_getCurrentPriorityLevel;\nexports.unstable_next = throwNotImplemented;\nexports.unstable_now = unstable_now;\nexports.unstable_requestPaint = unstable_requestPaint;\nexports.unstable_runWithPriority = throwNotImplemented;\nexports.unstable_scheduleCallback = unstable_scheduleCallback;\nexports.unstable_shouldYield = unstable_shouldYield;\nexports.unstable_wrapCallback = throwNotImplemented;\n"
        }
    ]
}