{
    "sourceFile": "node_modules/next/dist/compiled/scheduler-experimental/cjs/scheduler.native.development.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892738740,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @license React\n * scheduler.native.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\"use strict\";\n\"production\" !== process.env.NODE_ENV &&\n  (function () {\n    function performWorkUntilDeadline() {\n      if (isMessageLoopRunning) {\n        var currentTime = getCurrentTime();\n        startTime = currentTime;\n        var hasMoreWork = !0;\n        try {\n          a: {\n            isHostCallbackScheduled = !1;\n            isHostTimeoutScheduled &&\n              ((isHostTimeoutScheduled = !1),\n              localClearTimeout(taskTimeoutID),\n              (taskTimeoutID = -1));\n            isPerformingWork = !0;\n            var previousPriorityLevel = currentPriorityLevel;\n            try {\n              b: {\n                advanceTimers(currentTime);\n                for (currentTask = peek(taskQueue); null !== currentTask; ) {\n                  var callback = currentTask.callback;\n                  if (\"function\" === typeof callback) {\n                    currentTask.callback = null;\n                    currentPriorityLevel = currentTask.priorityLevel;\n                    var continuationCallback = callback(\n                      currentTask.expirationTime <= currentTime\n                    );\n                    currentTime = getCurrentTime();\n                    if (\"function\" === typeof continuationCallback) {\n                      currentTask.callback = continuationCallback;\n                      advanceTimers(currentTime);\n                      hasMoreWork = !0;\n                      break b;\n                    }\n                    currentTask === peek(taskQueue) && pop(taskQueue);\n                    advanceTimers(currentTime);\n                  } else pop(taskQueue);\n                  currentTask = peek(taskQueue);\n                  if (\n                    null === currentTask ||\n                    currentTask.expirationTime > currentTime\n                  )\n                    break;\n                }\n                if (null !== currentTask) hasMoreWork = !0;\n                else {\n                  var firstTimer = peek(timerQueue);\n                  null !== firstTimer &&\n                    requestHostTimeout(\n                      handleTimeout,\n                      firstTimer.startTime - currentTime\n                    );\n                  hasMoreWork = !1;\n                }\n              }\n              break a;\n            } finally {\n              (currentTask = null),\n                (currentPriorityLevel = previousPriorityLevel),\n                (isPerformingWork = !1);\n            }\n            hasMoreWork = void 0;\n          }\n        } finally {\n          hasMoreWork\n            ? schedulePerformWorkUntilDeadline()\n            : (isMessageLoopRunning = !1);\n        }\n      }\n    }\n    function push(heap, node) {\n      var index = heap.length;\n      heap.push(node);\n      a: for (; 0 < index; ) {\n        var parentIndex = (index - 1) >>> 1,\n          parent = heap[parentIndex];\n        if (0 < compare(parent, node))\n          (heap[parentIndex] = node),\n            (heap[index] = parent),\n            (index = parentIndex);\n        else break a;\n      }\n    }\n    function peek(heap) {\n      return 0 === heap.length ? null : heap[0];\n    }\n    function pop(heap) {\n      if (0 === heap.length) return null;\n      var first = heap[0],\n        last = heap.pop();\n      if (last !== first) {\n        heap[0] = last;\n        a: for (\n          var index = 0, length = heap.length, halfLength = length >>> 1;\n          index < halfLength;\n\n        ) {\n          var leftIndex = 2 * (index + 1) - 1,\n            left = heap[leftIndex],\n            rightIndex = leftIndex + 1,\n            right = heap[rightIndex];\n          if (0 > compare(left, last))\n            rightIndex < length && 0 > compare(right, left)\n              ? ((heap[index] = right),\n                (heap[rightIndex] = last),\n                (index = rightIndex))\n              : ((heap[index] = left),\n                (heap[leftIndex] = last),\n                (index = leftIndex));\n          else if (rightIndex < length && 0 > compare(right, last))\n            (heap[index] = right),\n              (heap[rightIndex] = last),\n              (index = rightIndex);\n          else break a;\n        }\n      }\n      return first;\n    }\n    function compare(a, b) {\n      var diff = a.sortIndex - b.sortIndex;\n      return 0 !== diff ? diff : a.id - b.id;\n    }\n    function advanceTimers(currentTime) {\n      for (var timer = peek(timerQueue); null !== timer; ) {\n        if (null === timer.callback) pop(timerQueue);\n        else if (timer.startTime <= currentTime)\n          pop(timerQueue),\n            (timer.sortIndex = timer.expirationTime),\n            push(taskQueue, timer);\n        else break;\n        timer = peek(timerQueue);\n      }\n    }\n    function handleTimeout(currentTime) {\n      isHostTimeoutScheduled = !1;\n      advanceTimers(currentTime);\n      if (!isHostCallbackScheduled)\n        if (null !== peek(taskQueue))\n          (isHostCallbackScheduled = !0),\n            isMessageLoopRunning ||\n              ((isMessageLoopRunning = !0), schedulePerformWorkUntilDeadline());\n        else {\n          var firstTimer = peek(timerQueue);\n          null !== firstTimer &&\n            requestHostTimeout(\n              handleTimeout,\n              firstTimer.startTime - currentTime\n            );\n        }\n    }\n    function unstable_scheduleCallback$1(priorityLevel, callback, options) {\n      var currentTime = getCurrentTime();\n      \"object\" === typeof options && null !== options\n        ? ((options = options.delay),\n          (options =\n            \"number\" === typeof options && 0 < options\n              ? currentTime + options\n              : currentTime))\n        : (options = currentTime);\n      switch (priorityLevel) {\n        case 1:\n          var timeout = -1;\n          break;\n        case 2:\n          timeout = 250;\n          break;\n        case 5:\n          timeout = 1073741823;\n          break;\n        case 4:\n          timeout = 1e4;\n          break;\n        default:\n          timeout = 5e3;\n      }\n      timeout = options + timeout;\n      priorityLevel = {\n        id: taskIdCounter++,\n        callback: callback,\n        priorityLevel: priorityLevel,\n        startTime: options,\n        expirationTime: timeout,\n        sortIndex: -1\n      };\n      options > currentTime\n        ? ((priorityLevel.sortIndex = options),\n          push(timerQueue, priorityLevel),\n          null === peek(taskQueue) &&\n            priorityLevel === peek(timerQueue) &&\n            (isHostTimeoutScheduled\n              ? (localClearTimeout(taskTimeoutID), (taskTimeoutID = -1))\n              : (isHostTimeoutScheduled = !0),\n            requestHostTimeout(handleTimeout, options - currentTime)))\n        : ((priorityLevel.sortIndex = timeout),\n          push(taskQueue, priorityLevel),\n          isHostCallbackScheduled ||\n            isPerformingWork ||\n            ((isHostCallbackScheduled = !0),\n            isMessageLoopRunning ||\n              ((isMessageLoopRunning = !0),\n              schedulePerformWorkUntilDeadline())));\n      return priorityLevel;\n    }\n    function unstable_cancelCallback$1(task) {\n      task.callback = null;\n    }\n    function unstable_getCurrentPriorityLevel$1() {\n      return currentPriorityLevel;\n    }\n    function shouldYieldToHost() {\n      return 5 > getCurrentTime() - startTime ? !1 : !0;\n    }\n    function requestPaint() {}\n    function requestHostTimeout(callback, ms) {\n      taskTimeoutID = localSetTimeout(function () {\n        callback(getCurrentTime());\n      }, ms);\n    }\n    function throwNotImplemented() {\n      throw Error(\"Not implemented.\");\n    }\n    if (\n      \"object\" === typeof performance &&\n      \"function\" === typeof performance.now\n    ) {\n      var localPerformance = performance;\n      var getCurrentTime = function () {\n        return localPerformance.now();\n      };\n    } else {\n      var localDate = Date,\n        initialTime = localDate.now();\n      getCurrentTime = function () {\n        return localDate.now() - initialTime;\n      };\n    }\n    var taskQueue = [],\n      timerQueue = [],\n      taskIdCounter = 1,\n      currentTask = null,\n      currentPriorityLevel = 3,\n      isPerformingWork = !1,\n      isHostCallbackScheduled = !1,\n      isHostTimeoutScheduled = !1,\n      localSetTimeout = \"function\" === typeof setTimeout ? setTimeout : null,\n      localClearTimeout =\n        \"function\" === typeof clearTimeout ? clearTimeout : null,\n      localSetImmediate =\n        \"undefined\" !== typeof setImmediate ? setImmediate : null,\n      isMessageLoopRunning = !1,\n      taskTimeoutID = -1,\n      startTime = -1;\n    if (\"function\" === typeof localSetImmediate)\n      var schedulePerformWorkUntilDeadline = function () {\n        localSetImmediate(performWorkUntilDeadline);\n      };\n    else if (\"undefined\" !== typeof MessageChannel) {\n      var channel = new MessageChannel(),\n        port = channel.port2;\n      channel.port1.onmessage = performWorkUntilDeadline;\n      schedulePerformWorkUntilDeadline = function () {\n        port.postMessage(null);\n      };\n    } else\n      schedulePerformWorkUntilDeadline = function () {\n        localSetTimeout(performWorkUntilDeadline, 0);\n      };\n    channel =\n      \"undefined\" !== typeof nativeRuntimeScheduler\n        ? nativeRuntimeScheduler.unstable_UserBlockingPriority\n        : 2;\n    var unstable_NormalPriority =\n        \"undefined\" !== typeof nativeRuntimeScheduler\n          ? nativeRuntimeScheduler.unstable_NormalPriority\n          : 3,\n      unstable_LowPriority =\n        \"undefined\" !== typeof nativeRuntimeScheduler\n          ? nativeRuntimeScheduler.unstable_LowPriority\n          : 4,\n      unstable_ImmediatePriority =\n        \"undefined\" !== typeof nativeRuntimeScheduler\n          ? nativeRuntimeScheduler.unstable_ImmediatePriority\n          : 1,\n      unstable_scheduleCallback =\n        \"undefined\" !== typeof nativeRuntimeScheduler\n          ? nativeRuntimeScheduler.unstable_scheduleCallback\n          : unstable_scheduleCallback$1,\n      unstable_cancelCallback =\n        \"undefined\" !== typeof nativeRuntimeScheduler\n          ? nativeRuntimeScheduler.unstable_cancelCallback\n          : unstable_cancelCallback$1,\n      unstable_getCurrentPriorityLevel =\n        \"undefined\" !== typeof nativeRuntimeScheduler\n          ? nativeRuntimeScheduler.unstable_getCurrentPriorityLevel\n          : unstable_getCurrentPriorityLevel$1,\n      unstable_shouldYield =\n        \"undefined\" !== typeof nativeRuntimeScheduler\n          ? nativeRuntimeScheduler.unstable_shouldYield\n          : shouldYieldToHost,\n      unstable_requestPaint =\n        \"undefined\" !== typeof nativeRuntimeScheduler\n          ? nativeRuntimeScheduler.unstable_requestPaint\n          : requestPaint,\n      unstable_now =\n        \"undefined\" !== typeof nativeRuntimeScheduler\n          ? nativeRuntimeScheduler.unstable_now\n          : getCurrentTime;\n    exports.unstable_IdlePriority =\n      \"undefined\" !== typeof nativeRuntimeScheduler\n        ? nativeRuntimeScheduler.unstable_IdlePriority\n        : 5;\n    exports.unstable_ImmediatePriority = unstable_ImmediatePriority;\n    exports.unstable_LowPriority = unstable_LowPriority;\n    exports.unstable_NormalPriority = unstable_NormalPriority;\n    exports.unstable_Profiling = null;\n    exports.unstable_UserBlockingPriority = channel;\n    exports.unstable_cancelCallback = unstable_cancelCallback;\n    exports.unstable_forceFrameRate = throwNotImplemented;\n    exports.unstable_getCurrentPriorityLevel = unstable_getCurrentPriorityLevel;\n    exports.unstable_next = throwNotImplemented;\n    exports.unstable_now = unstable_now;\n    exports.unstable_requestPaint = unstable_requestPaint;\n    exports.unstable_runWithPriority = throwNotImplemented;\n    exports.unstable_scheduleCallback = unstable_scheduleCallback;\n    exports.unstable_shouldYield = unstable_shouldYield;\n    exports.unstable_wrapCallback = throwNotImplemented;\n  })();\n"
        }
    ]
}