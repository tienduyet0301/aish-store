{
    "sourceFile": "node_modules/next/dist/compiled/webpack/JavascriptHotModuleReplacement.runtime.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892742763,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "// @ts-nocheck\n/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nvar $installedChunks$ = undefined;\nvar $loadUpdateChunk$ = undefined;\nvar $moduleCache$ = undefined;\nvar $moduleFactories$ = undefined;\nvar $ensureChunkHandlers$ = undefined;\nvar $hasOwnProperty$ = undefined;\nvar $hmrModuleData$ = undefined;\nvar $hmrDownloadUpdateHandlers$ = undefined;\nvar $hmrInvalidateModuleHandlers$ = undefined;\nvar __webpack_require__ = undefined;\n\nmodule.exports = function () {\n\tvar currentUpdateChunks;\n\tvar currentUpdate;\n\tvar currentUpdateRemovedChunks;\n\tvar currentUpdateRuntime;\n\tfunction applyHandler(options) {\n\t\tif ($ensureChunkHandlers$) delete $ensureChunkHandlers$.$key$Hmr;\n\t\tcurrentUpdateChunks = undefined;\n\t\tfunction getAffectedModuleEffects(updateModuleId) {\n\t\t\tvar outdatedModules = [updateModuleId];\n\t\t\tvar outdatedDependencies = {};\n\n\t\t\tvar queue = outdatedModules.map(function (id) {\n\t\t\t\treturn {\n\t\t\t\t\tchain: [id],\n\t\t\t\t\tid: id\n\t\t\t\t};\n\t\t\t});\n\t\t\twhile (queue.length > 0) {\n\t\t\t\tvar queueItem = queue.pop();\n\t\t\t\tvar moduleId = queueItem.id;\n\t\t\t\tvar chain = queueItem.chain;\n\t\t\t\tvar module = $moduleCache$[moduleId];\n\t\t\t\tif (\n\t\t\t\t\t!module ||\n\t\t\t\t\t(module.hot._selfAccepted && !module.hot._selfInvalidated)\n\t\t\t\t)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (module.hot._selfDeclined) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\ttype: \"self-declined\",\n\t\t\t\t\t\tchain: chain,\n\t\t\t\t\t\tmoduleId: moduleId\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tif (module.hot._main) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\ttype: \"unaccepted\",\n\t\t\t\t\t\tchain: chain,\n\t\t\t\t\t\tmoduleId: moduleId\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tfor (var i = 0; i < module.parents.length; i++) {\n\t\t\t\t\tvar parentId = module.parents[i];\n\t\t\t\t\tvar parent = $moduleCache$[parentId];\n\t\t\t\t\tif (!parent) continue;\n\t\t\t\t\tif (parent.hot._declinedDependencies[moduleId]) {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\ttype: \"declined\",\n\t\t\t\t\t\t\tchain: chain.concat([parentId]),\n\t\t\t\t\t\t\tmoduleId: moduleId,\n\t\t\t\t\t\t\tparentId: parentId\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t\tif (outdatedModules.indexOf(parentId) !== -1) continue;\n\t\t\t\t\tif (parent.hot._acceptedDependencies[moduleId]) {\n\t\t\t\t\t\tif (!outdatedDependencies[parentId])\n\t\t\t\t\t\t\toutdatedDependencies[parentId] = [];\n\t\t\t\t\t\taddAllToSet(outdatedDependencies[parentId], [moduleId]);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tdelete outdatedDependencies[parentId];\n\t\t\t\t\toutdatedModules.push(parentId);\n\t\t\t\t\tqueue.push({\n\t\t\t\t\t\tchain: chain.concat([parentId]),\n\t\t\t\t\t\tid: parentId\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\ttype: \"accepted\",\n\t\t\t\tmoduleId: updateModuleId,\n\t\t\t\toutdatedModules: outdatedModules,\n\t\t\t\toutdatedDependencies: outdatedDependencies\n\t\t\t};\n\t\t}\n\n\t\tfunction addAllToSet(a, b) {\n\t\t\tfor (var i = 0; i < b.length; i++) {\n\t\t\t\tvar item = b[i];\n\t\t\t\tif (a.indexOf(item) === -1) a.push(item);\n\t\t\t}\n\t\t}\n\n\t\t// at begin all updates modules are outdated\n\t\t// the \"outdated\" status can propagate to parents if they don't accept the children\n\t\tvar outdatedDependencies = {};\n\t\tvar outdatedModules = [];\n\t\tvar appliedUpdate = {};\n\n\t\tvar warnUnexpectedRequire = function warnUnexpectedRequire(module) {\n\t\t\tconsole.warn(\n\t\t\t\t\"[HMR] unexpected require(\" + module.id + \") to disposed module\"\n\t\t\t);\n\t\t};\n\n\t\tfor (var moduleId in currentUpdate) {\n\t\t\tif ($hasOwnProperty$(currentUpdate, moduleId)) {\n\t\t\t\tvar newModuleFactory = currentUpdate[moduleId];\n\t\t\t\t/** @type {TODO} */\n\t\t\t\tvar result = newModuleFactory\n\t\t\t\t\t? getAffectedModuleEffects(moduleId)\n\t\t\t\t\t: {\n\t\t\t\t\t\t\ttype: \"disposed\",\n\t\t\t\t\t\t\tmoduleId: moduleId\n\t\t\t\t\t\t};\n\t\t\t\t/** @type {Error|false} */\n\t\t\t\tvar abortError = false;\n\t\t\t\tvar doApply = false;\n\t\t\t\tvar doDispose = false;\n\t\t\t\tvar chainInfo = \"\";\n\t\t\t\tif (result.chain) {\n\t\t\t\t\tchainInfo = \"\\nUpdate propagation: \" + result.chain.join(\" -> \");\n\t\t\t\t}\n\t\t\t\tswitch (result.type) {\n\t\t\t\t\tcase \"self-declined\":\n\t\t\t\t\t\tif (options.onDeclined) options.onDeclined(result);\n\t\t\t\t\t\tif (!options.ignoreDeclined)\n\t\t\t\t\t\t\tabortError = new Error(\n\t\t\t\t\t\t\t\t\"Aborted because of self decline: \" +\n\t\t\t\t\t\t\t\t\tresult.moduleId +\n\t\t\t\t\t\t\t\t\tchainInfo\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"declined\":\n\t\t\t\t\t\tif (options.onDeclined) options.onDeclined(result);\n\t\t\t\t\t\tif (!options.ignoreDeclined)\n\t\t\t\t\t\t\tabortError = new Error(\n\t\t\t\t\t\t\t\t\"Aborted because of declined dependency: \" +\n\t\t\t\t\t\t\t\t\tresult.moduleId +\n\t\t\t\t\t\t\t\t\t\" in \" +\n\t\t\t\t\t\t\t\t\tresult.parentId +\n\t\t\t\t\t\t\t\t\tchainInfo\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"unaccepted\":\n\t\t\t\t\t\tif (options.onUnaccepted) options.onUnaccepted(result);\n\t\t\t\t\t\tif (!options.ignoreUnaccepted)\n\t\t\t\t\t\t\tabortError = new Error(\n\t\t\t\t\t\t\t\t\"Aborted because \" + moduleId + \" is not accepted\" + chainInfo\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"accepted\":\n\t\t\t\t\t\tif (options.onAccepted) options.onAccepted(result);\n\t\t\t\t\t\tdoApply = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"disposed\":\n\t\t\t\t\t\tif (options.onDisposed) options.onDisposed(result);\n\t\t\t\t\t\tdoDispose = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new Error(\"Unexception type \" + result.type);\n\t\t\t\t}\n\t\t\t\tif (abortError) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\terror: abortError\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tif (doApply) {\n\t\t\t\t\tappliedUpdate[moduleId] = newModuleFactory;\n\t\t\t\t\taddAllToSet(outdatedModules, result.outdatedModules);\n\t\t\t\t\tfor (moduleId in result.outdatedDependencies) {\n\t\t\t\t\t\tif ($hasOwnProperty$(result.outdatedDependencies, moduleId)) {\n\t\t\t\t\t\t\tif (!outdatedDependencies[moduleId])\n\t\t\t\t\t\t\t\toutdatedDependencies[moduleId] = [];\n\t\t\t\t\t\t\taddAllToSet(\n\t\t\t\t\t\t\t\toutdatedDependencies[moduleId],\n\t\t\t\t\t\t\t\tresult.outdatedDependencies[moduleId]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (doDispose) {\n\t\t\t\t\taddAllToSet(outdatedModules, [result.moduleId]);\n\t\t\t\t\tappliedUpdate[moduleId] = warnUnexpectedRequire;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcurrentUpdate = undefined;\n\n\t\t// Store self accepted outdated modules to require them later by the module system\n\t\tvar outdatedSelfAcceptedModules = [];\n\t\tfor (var j = 0; j < outdatedModules.length; j++) {\n\t\t\tvar outdatedModuleId = outdatedModules[j];\n\t\t\tvar module = $moduleCache$[outdatedModuleId];\n\t\t\tif (\n\t\t\t\tmodule &&\n\t\t\t\t(module.hot._selfAccepted || module.hot._main) &&\n\t\t\t\t// removed self-accepted modules should not be required\n\t\t\t\tappliedUpdate[outdatedModuleId] !== warnUnexpectedRequire &&\n\t\t\t\t// when called invalidate self-accepting is not possible\n\t\t\t\t!module.hot._selfInvalidated\n\t\t\t) {\n\t\t\t\toutdatedSelfAcceptedModules.push({\n\t\t\t\t\tmodule: outdatedModuleId,\n\t\t\t\t\trequire: module.hot._requireSelf,\n\t\t\t\t\terrorHandler: module.hot._selfAccepted\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tvar moduleOutdatedDependencies;\n\n\t\treturn {\n\t\t\tdispose: function () {\n\t\t\t\tcurrentUpdateRemovedChunks.forEach(function (chunkId) {\n\t\t\t\t\tdelete $installedChunks$[chunkId];\n\t\t\t\t});\n\t\t\t\tcurrentUpdateRemovedChunks = undefined;\n\n\t\t\t\tvar idx;\n\t\t\t\tvar queue = outdatedModules.slice();\n\t\t\t\twhile (queue.length > 0) {\n\t\t\t\t\tvar moduleId = queue.pop();\n\t\t\t\t\tvar module = $moduleCache$[moduleId];\n\t\t\t\t\tif (!module) continue;\n\n\t\t\t\t\tvar data = {};\n\n\t\t\t\t\t// Call dispose handlers\n\t\t\t\t\tvar disposeHandlers = module.hot._disposeHandlers;\n\t\t\t\t\tfor (j = 0; j < disposeHandlers.length; j++) {\n\t\t\t\t\t\tdisposeHandlers[j].call(null, data);\n\t\t\t\t\t}\n\t\t\t\t\t$hmrModuleData$[moduleId] = data;\n\n\t\t\t\t\t// disable module (this disables requires from this module)\n\t\t\t\t\tmodule.hot.active = false;\n\n\t\t\t\t\t// remove module from cache\n\t\t\t\t\tdelete $moduleCache$[moduleId];\n\n\t\t\t\t\t// when disposing there is no need to call dispose handler\n\t\t\t\t\tdelete outdatedDependencies[moduleId];\n\n\t\t\t\t\t// remove \"parents\" references from all children\n\t\t\t\t\tfor (j = 0; j < module.children.length; j++) {\n\t\t\t\t\t\tvar child = $moduleCache$[module.children[j]];\n\t\t\t\t\t\tif (!child) continue;\n\t\t\t\t\t\tidx = child.parents.indexOf(moduleId);\n\t\t\t\t\t\tif (idx >= 0) {\n\t\t\t\t\t\t\tchild.parents.splice(idx, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// remove outdated dependency from module children\n\t\t\t\tvar dependency;\n\t\t\t\tfor (var outdatedModuleId in outdatedDependencies) {\n\t\t\t\t\tif ($hasOwnProperty$(outdatedDependencies, outdatedModuleId)) {\n\t\t\t\t\t\tmodule = $moduleCache$[outdatedModuleId];\n\t\t\t\t\t\tif (module) {\n\t\t\t\t\t\t\tmoduleOutdatedDependencies =\n\t\t\t\t\t\t\t\toutdatedDependencies[outdatedModuleId];\n\t\t\t\t\t\t\tfor (j = 0; j < moduleOutdatedDependencies.length; j++) {\n\t\t\t\t\t\t\t\tdependency = moduleOutdatedDependencies[j];\n\t\t\t\t\t\t\t\tidx = module.children.indexOf(dependency);\n\t\t\t\t\t\t\t\tif (idx >= 0) module.children.splice(idx, 1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\tapply: function (reportError) {\n\t\t\t\t// insert new code\n\t\t\t\tfor (var updateModuleId in appliedUpdate) {\n\t\t\t\t\tif ($hasOwnProperty$(appliedUpdate, updateModuleId)) {\n\t\t\t\t\t\t$moduleFactories$[updateModuleId] = appliedUpdate[updateModuleId];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// run new runtime modules\n\t\t\t\tfor (var i = 0; i < currentUpdateRuntime.length; i++) {\n\t\t\t\t\tcurrentUpdateRuntime[i](__webpack_require__);\n\t\t\t\t}\n\n\t\t\t\t// call accept handlers\n\t\t\t\tfor (var outdatedModuleId in outdatedDependencies) {\n\t\t\t\t\tif ($hasOwnProperty$(outdatedDependencies, outdatedModuleId)) {\n\t\t\t\t\t\tvar module = $moduleCache$[outdatedModuleId];\n\t\t\t\t\t\tif (module) {\n\t\t\t\t\t\t\tmoduleOutdatedDependencies =\n\t\t\t\t\t\t\t\toutdatedDependencies[outdatedModuleId];\n\t\t\t\t\t\t\tvar callbacks = [];\n\t\t\t\t\t\t\tvar errorHandlers = [];\n\t\t\t\t\t\t\tvar dependenciesForCallbacks = [];\n\t\t\t\t\t\t\tfor (var j = 0; j < moduleOutdatedDependencies.length; j++) {\n\t\t\t\t\t\t\t\tvar dependency = moduleOutdatedDependencies[j];\n\t\t\t\t\t\t\t\tvar acceptCallback =\n\t\t\t\t\t\t\t\t\tmodule.hot._acceptedDependencies[dependency];\n\t\t\t\t\t\t\t\tvar errorHandler =\n\t\t\t\t\t\t\t\t\tmodule.hot._acceptedErrorHandlers[dependency];\n\t\t\t\t\t\t\t\tif (acceptCallback) {\n\t\t\t\t\t\t\t\t\tif (callbacks.indexOf(acceptCallback) !== -1) continue;\n\t\t\t\t\t\t\t\t\tcallbacks.push(acceptCallback);\n\t\t\t\t\t\t\t\t\terrorHandlers.push(errorHandler);\n\t\t\t\t\t\t\t\t\tdependenciesForCallbacks.push(dependency);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor (var k = 0; k < callbacks.length; k++) {\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tcallbacks[k].call(null, moduleOutdatedDependencies);\n\t\t\t\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\t\t\t\tif (typeof errorHandlers[k] === \"function\") {\n\t\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\t\terrorHandlers[k](err, {\n\t\t\t\t\t\t\t\t\t\t\t\tmoduleId: outdatedModuleId,\n\t\t\t\t\t\t\t\t\t\t\t\tdependencyId: dependenciesForCallbacks[k]\n\t\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t\t} catch (err2) {\n\t\t\t\t\t\t\t\t\t\t\tif (options.onErrored) {\n\t\t\t\t\t\t\t\t\t\t\t\toptions.onErrored({\n\t\t\t\t\t\t\t\t\t\t\t\t\ttype: \"accept-error-handler-errored\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tmoduleId: outdatedModuleId,\n\t\t\t\t\t\t\t\t\t\t\t\t\tdependencyId: dependenciesForCallbacks[k],\n\t\t\t\t\t\t\t\t\t\t\t\t\terror: err2,\n\t\t\t\t\t\t\t\t\t\t\t\t\toriginalError: err\n\t\t\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tif (!options.ignoreErrored) {\n\t\t\t\t\t\t\t\t\t\t\t\treportError(err2);\n\t\t\t\t\t\t\t\t\t\t\t\treportError(err);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tif (options.onErrored) {\n\t\t\t\t\t\t\t\t\t\t\toptions.onErrored({\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"accept-errored\",\n\t\t\t\t\t\t\t\t\t\t\t\tmoduleId: outdatedModuleId,\n\t\t\t\t\t\t\t\t\t\t\t\tdependencyId: dependenciesForCallbacks[k],\n\t\t\t\t\t\t\t\t\t\t\t\terror: err\n\t\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif (!options.ignoreErrored) {\n\t\t\t\t\t\t\t\t\t\t\treportError(err);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Load self accepted modules\n\t\t\t\tfor (var o = 0; o < outdatedSelfAcceptedModules.length; o++) {\n\t\t\t\t\tvar item = outdatedSelfAcceptedModules[o];\n\t\t\t\t\tvar moduleId = item.module;\n\t\t\t\t\ttry {\n\t\t\t\t\t\titem.require(moduleId);\n\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\tif (typeof item.errorHandler === \"function\") {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\titem.errorHandler(err, {\n\t\t\t\t\t\t\t\t\tmoduleId: moduleId,\n\t\t\t\t\t\t\t\t\tmodule: $moduleCache$[moduleId]\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t} catch (err1) {\n\t\t\t\t\t\t\t\tif (options.onErrored) {\n\t\t\t\t\t\t\t\t\toptions.onErrored({\n\t\t\t\t\t\t\t\t\t\ttype: \"self-accept-error-handler-errored\",\n\t\t\t\t\t\t\t\t\t\tmoduleId: moduleId,\n\t\t\t\t\t\t\t\t\t\terror: err1,\n\t\t\t\t\t\t\t\t\t\toriginalError: err\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (!options.ignoreErrored) {\n\t\t\t\t\t\t\t\t\treportError(err1);\n\t\t\t\t\t\t\t\t\treportError(err);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (options.onErrored) {\n\t\t\t\t\t\t\t\toptions.onErrored({\n\t\t\t\t\t\t\t\t\ttype: \"self-accept-errored\",\n\t\t\t\t\t\t\t\t\tmoduleId: moduleId,\n\t\t\t\t\t\t\t\t\terror: err\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (!options.ignoreErrored) {\n\t\t\t\t\t\t\t\treportError(err);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn outdatedModules;\n\t\t\t}\n\t\t};\n\t}\n\t$hmrInvalidateModuleHandlers$.$key$ = function (moduleId, applyHandlers) {\n\t\tif (!currentUpdate) {\n\t\t\tcurrentUpdate = {};\n\t\t\tcurrentUpdateRuntime = [];\n\t\t\tcurrentUpdateRemovedChunks = [];\n\t\t\tapplyHandlers.push(applyHandler);\n\t\t}\n\t\tif (!$hasOwnProperty$(currentUpdate, moduleId)) {\n\t\t\tcurrentUpdate[moduleId] = $moduleFactories$[moduleId];\n\t\t}\n\t};\n\t$hmrDownloadUpdateHandlers$.$key$ = function (\n\t\tchunkIds,\n\t\tremovedChunks,\n\t\tremovedModules,\n\t\tpromises,\n\t\tapplyHandlers,\n\t\tupdatedModulesList\n\t) {\n\t\tapplyHandlers.push(applyHandler);\n\t\tcurrentUpdateChunks = {};\n\t\tcurrentUpdateRemovedChunks = removedChunks;\n\t\tcurrentUpdate = removedModules.reduce(function (obj, key) {\n\t\t\tobj[key] = false;\n\t\t\treturn obj;\n\t\t}, {});\n\t\tcurrentUpdateRuntime = [];\n\t\tchunkIds.forEach(function (chunkId) {\n\t\t\tif (\n\t\t\t\t$hasOwnProperty$($installedChunks$, chunkId) &&\n\t\t\t\t$installedChunks$[chunkId] !== undefined\n\t\t\t) {\n\t\t\t\tpromises.push($loadUpdateChunk$(chunkId, updatedModulesList));\n\t\t\t\tcurrentUpdateChunks[chunkId] = true;\n\t\t\t} else {\n\t\t\t\tcurrentUpdateChunks[chunkId] = false;\n\t\t\t}\n\t\t});\n\t\tif ($ensureChunkHandlers$) {\n\t\t\t$ensureChunkHandlers$.$key$Hmr = function (chunkId, promises) {\n\t\t\t\tif (\n\t\t\t\t\tcurrentUpdateChunks &&\n\t\t\t\t\t$hasOwnProperty$(currentUpdateChunks, chunkId) &&\n\t\t\t\t\t!currentUpdateChunks[chunkId]\n\t\t\t\t) {\n\t\t\t\t\tpromises.push($loadUpdateChunk$(chunkId));\n\t\t\t\t\tcurrentUpdateChunks[chunkId] = true;\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t};\n};\n"
        }
    ]
}