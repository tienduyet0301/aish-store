{
    "sourceFile": "node_modules/next/dist/compiled/webpack/HotModuleReplacement.runtime.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892742724,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "// @ts-nocheck\n/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nvar $interceptModuleExecution$ = undefined;\nvar $moduleCache$ = undefined;\n// eslint-disable-next-line no-unused-vars\nvar $hmrModuleData$ = undefined;\n/** @type {() => Promise}  */\nvar $hmrDownloadManifest$ = undefined;\nvar $hmrDownloadUpdateHandlers$ = undefined;\nvar $hmrInvalidateModuleHandlers$ = undefined;\nvar __webpack_require__ = undefined;\n\nmodule.exports = function () {\n\tvar currentModuleData = {};\n\tvar installedModules = $moduleCache$;\n\n\t// module and require creation\n\tvar currentChildModule;\n\tvar currentParents = [];\n\n\t// status\n\tvar registeredStatusHandlers = [];\n\tvar currentStatus = \"idle\";\n\n\t// while downloading\n\tvar blockingPromises = 0;\n\tvar blockingPromisesWaiting = [];\n\n\t// The update info\n\tvar currentUpdateApplyHandlers;\n\tvar queuedInvalidatedModules;\n\n\t$hmrModuleData$ = currentModuleData;\n\n\t$interceptModuleExecution$.push(function (options) {\n\t\tvar module = options.module;\n\t\tvar require = createRequire(options.require, options.id);\n\t\tmodule.hot = createModuleHotObject(options.id, module);\n\t\tmodule.parents = currentParents;\n\t\tmodule.children = [];\n\t\tcurrentParents = [];\n\t\toptions.require = require;\n\t});\n\n\t$hmrDownloadUpdateHandlers$ = {};\n\t$hmrInvalidateModuleHandlers$ = {};\n\n\tfunction createRequire(require, moduleId) {\n\t\tvar me = installedModules[moduleId];\n\t\tif (!me) return require;\n\t\tvar fn = function (request) {\n\t\t\tif (me.hot.active) {\n\t\t\t\tif (installedModules[request]) {\n\t\t\t\t\tvar parents = installedModules[request].parents;\n\t\t\t\t\tif (parents.indexOf(moduleId) === -1) {\n\t\t\t\t\t\tparents.push(moduleId);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tcurrentParents = [moduleId];\n\t\t\t\t\tcurrentChildModule = request;\n\t\t\t\t}\n\t\t\t\tif (me.children.indexOf(request) === -1) {\n\t\t\t\t\tme.children.push(request);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconsole.warn(\n\t\t\t\t\t\"[HMR] unexpected require(\" +\n\t\t\t\t\t\trequest +\n\t\t\t\t\t\t\") from disposed module \" +\n\t\t\t\t\t\tmoduleId\n\t\t\t\t);\n\t\t\t\tcurrentParents = [];\n\t\t\t}\n\t\t\treturn require(request);\n\t\t};\n\t\tvar createPropertyDescriptor = function (name) {\n\t\t\treturn {\n\t\t\t\tconfigurable: true,\n\t\t\t\tenumerable: true,\n\t\t\t\tget: function () {\n\t\t\t\t\treturn require[name];\n\t\t\t\t},\n\t\t\t\tset: function (value) {\n\t\t\t\t\trequire[name] = value;\n\t\t\t\t}\n\t\t\t};\n\t\t};\n\t\tfor (var name in require) {\n\t\t\tif (Object.prototype.hasOwnProperty.call(require, name) && name !== \"e\") {\n\t\t\t\tObject.defineProperty(fn, name, createPropertyDescriptor(name));\n\t\t\t}\n\t\t}\n\t\tfn.e = function (chunkId, fetchPriority) {\n\t\t\treturn trackBlockingPromise(require.e(chunkId, fetchPriority));\n\t\t};\n\t\treturn fn;\n\t}\n\n\tfunction createModuleHotObject(moduleId, me) {\n\t\tvar _main = currentChildModule !== moduleId;\n\t\tvar hot = {\n\t\t\t// private stuff\n\t\t\t_acceptedDependencies: {},\n\t\t\t_acceptedErrorHandlers: {},\n\t\t\t_declinedDependencies: {},\n\t\t\t_selfAccepted: false,\n\t\t\t_selfDeclined: false,\n\t\t\t_selfInvalidated: false,\n\t\t\t_disposeHandlers: [],\n\t\t\t_main: _main,\n\t\t\t_requireSelf: function () {\n\t\t\t\tcurrentParents = me.parents.slice();\n\t\t\t\tcurrentChildModule = _main ? undefined : moduleId;\n\t\t\t\t__webpack_require__(moduleId);\n\t\t\t},\n\n\t\t\t// Module API\n\t\t\tactive: true,\n\t\t\taccept: function (dep, callback, errorHandler) {\n\t\t\t\tif (dep === undefined) hot._selfAccepted = true;\n\t\t\t\telse if (typeof dep === \"function\") hot._selfAccepted = dep;\n\t\t\t\telse if (typeof dep === \"object\" && dep !== null) {\n\t\t\t\t\tfor (var i = 0; i < dep.length; i++) {\n\t\t\t\t\t\thot._acceptedDependencies[dep[i]] = callback || function () {};\n\t\t\t\t\t\thot._acceptedErrorHandlers[dep[i]] = errorHandler;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\thot._acceptedDependencies[dep] = callback || function () {};\n\t\t\t\t\thot._acceptedErrorHandlers[dep] = errorHandler;\n\t\t\t\t}\n\t\t\t},\n\t\t\tdecline: function (dep) {\n\t\t\t\tif (dep === undefined) hot._selfDeclined = true;\n\t\t\t\telse if (typeof dep === \"object\" && dep !== null)\n\t\t\t\t\tfor (var i = 0; i < dep.length; i++)\n\t\t\t\t\t\thot._declinedDependencies[dep[i]] = true;\n\t\t\t\telse hot._declinedDependencies[dep] = true;\n\t\t\t},\n\t\t\tdispose: function (callback) {\n\t\t\t\thot._disposeHandlers.push(callback);\n\t\t\t},\n\t\t\taddDisposeHandler: function (callback) {\n\t\t\t\thot._disposeHandlers.push(callback);\n\t\t\t},\n\t\t\tremoveDisposeHandler: function (callback) {\n\t\t\t\tvar idx = hot._disposeHandlers.indexOf(callback);\n\t\t\t\tif (idx >= 0) hot._disposeHandlers.splice(idx, 1);\n\t\t\t},\n\t\t\tinvalidate: function () {\n\t\t\t\tthis._selfInvalidated = true;\n\t\t\t\tswitch (currentStatus) {\n\t\t\t\t\tcase \"idle\":\n\t\t\t\t\t\tcurrentUpdateApplyHandlers = [];\n\t\t\t\t\t\tObject.keys($hmrInvalidateModuleHandlers$).forEach(function (key) {\n\t\t\t\t\t\t\t$hmrInvalidateModuleHandlers$[key](\n\t\t\t\t\t\t\t\tmoduleId,\n\t\t\t\t\t\t\t\tcurrentUpdateApplyHandlers\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t});\n\t\t\t\t\t\tsetStatus(\"ready\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"ready\":\n\t\t\t\t\t\tObject.keys($hmrInvalidateModuleHandlers$).forEach(function (key) {\n\t\t\t\t\t\t\t$hmrInvalidateModuleHandlers$[key](\n\t\t\t\t\t\t\t\tmoduleId,\n\t\t\t\t\t\t\t\tcurrentUpdateApplyHandlers\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t});\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"prepare\":\n\t\t\t\t\tcase \"check\":\n\t\t\t\t\tcase \"dispose\":\n\t\t\t\t\tcase \"apply\":\n\t\t\t\t\t\t(queuedInvalidatedModules = queuedInvalidatedModules || []).push(\n\t\t\t\t\t\t\tmoduleId\n\t\t\t\t\t\t);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t// ignore requests in error states\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t// Management API\n\t\t\tcheck: hotCheck,\n\t\t\tapply: hotApply,\n\t\t\tstatus: function (l) {\n\t\t\t\tif (!l) return currentStatus;\n\t\t\t\tregisteredStatusHandlers.push(l);\n\t\t\t},\n\t\t\taddStatusHandler: function (l) {\n\t\t\t\tregisteredStatusHandlers.push(l);\n\t\t\t},\n\t\t\tremoveStatusHandler: function (l) {\n\t\t\t\tvar idx = registeredStatusHandlers.indexOf(l);\n\t\t\t\tif (idx >= 0) registeredStatusHandlers.splice(idx, 1);\n\t\t\t},\n\n\t\t\t// inherit from previous dispose call\n\t\t\tdata: currentModuleData[moduleId]\n\t\t};\n\t\tcurrentChildModule = undefined;\n\t\treturn hot;\n\t}\n\n\tfunction setStatus(newStatus) {\n\t\tcurrentStatus = newStatus;\n\t\tvar results = [];\n\n\t\tfor (var i = 0; i < registeredStatusHandlers.length; i++)\n\t\t\tresults[i] = registeredStatusHandlers[i].call(null, newStatus);\n\n\t\treturn Promise.all(results).then(function () {});\n\t}\n\n\tfunction unblock() {\n\t\tif (--blockingPromises === 0) {\n\t\t\tsetStatus(\"ready\").then(function () {\n\t\t\t\tif (blockingPromises === 0) {\n\t\t\t\t\tvar list = blockingPromisesWaiting;\n\t\t\t\t\tblockingPromisesWaiting = [];\n\t\t\t\t\tfor (var i = 0; i < list.length; i++) {\n\t\t\t\t\t\tlist[i]();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n\tfunction trackBlockingPromise(promise) {\n\t\tswitch (currentStatus) {\n\t\t\tcase \"ready\":\n\t\t\t\tsetStatus(\"prepare\");\n\t\t\t/* fallthrough */\n\t\t\tcase \"prepare\":\n\t\t\t\tblockingPromises++;\n\t\t\t\tpromise.then(unblock, unblock);\n\t\t\t\treturn promise;\n\t\t\tdefault:\n\t\t\t\treturn promise;\n\t\t}\n\t}\n\n\tfunction waitForBlockingPromises(fn) {\n\t\tif (blockingPromises === 0) return fn();\n\t\treturn new Promise(function (resolve) {\n\t\t\tblockingPromisesWaiting.push(function () {\n\t\t\t\tresolve(fn());\n\t\t\t});\n\t\t});\n\t}\n\n\tfunction hotCheck(applyOnUpdate) {\n\t\tif (currentStatus !== \"idle\") {\n\t\t\tthrow new Error(\"check() is only allowed in idle status\");\n\t\t}\n\t\treturn setStatus(\"check\")\n\t\t\t.then($hmrDownloadManifest$)\n\t\t\t.then(function (update) {\n\t\t\t\tif (!update) {\n\t\t\t\t\treturn setStatus(applyInvalidatedModules() ? \"ready\" : \"idle\").then(\n\t\t\t\t\t\tfunction () {\n\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\treturn setStatus(\"prepare\").then(function () {\n\t\t\t\t\tvar updatedModules = [];\n\t\t\t\t\tcurrentUpdateApplyHandlers = [];\n\n\t\t\t\t\treturn Promise.all(\n\t\t\t\t\t\tObject.keys($hmrDownloadUpdateHandlers$).reduce(function (\n\t\t\t\t\t\t\tpromises,\n\t\t\t\t\t\t\tkey\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t$hmrDownloadUpdateHandlers$[key](\n\t\t\t\t\t\t\t\tupdate.c,\n\t\t\t\t\t\t\t\tupdate.r,\n\t\t\t\t\t\t\t\tupdate.m,\n\t\t\t\t\t\t\t\tpromises,\n\t\t\t\t\t\t\t\tcurrentUpdateApplyHandlers,\n\t\t\t\t\t\t\t\tupdatedModules\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\treturn promises;\n\t\t\t\t\t\t}, [])\n\t\t\t\t\t).then(function () {\n\t\t\t\t\t\treturn waitForBlockingPromises(function () {\n\t\t\t\t\t\t\tif (applyOnUpdate) {\n\t\t\t\t\t\t\t\treturn internalApply(applyOnUpdate);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn setStatus(\"ready\").then(function () {\n\t\t\t\t\t\t\t\treturn updatedModules;\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t});\n\t}\n\n\tfunction hotApply(options) {\n\t\tif (currentStatus !== \"ready\") {\n\t\t\treturn Promise.resolve().then(function () {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t\"apply() is only allowed in ready status (state: \" +\n\t\t\t\t\t\tcurrentStatus +\n\t\t\t\t\t\t\")\"\n\t\t\t\t);\n\t\t\t});\n\t\t}\n\t\treturn internalApply(options);\n\t}\n\n\tfunction internalApply(options) {\n\t\toptions = options || {};\n\n\t\tapplyInvalidatedModules();\n\n\t\tvar results = currentUpdateApplyHandlers.map(function (handler) {\n\t\t\treturn handler(options);\n\t\t});\n\t\tcurrentUpdateApplyHandlers = undefined;\n\n\t\tvar errors = results\n\t\t\t.map(function (r) {\n\t\t\t\treturn r.error;\n\t\t\t})\n\t\t\t.filter(Boolean);\n\n\t\tif (errors.length > 0) {\n\t\t\treturn setStatus(\"abort\").then(function () {\n\t\t\t\tthrow errors[0];\n\t\t\t});\n\t\t}\n\n\t\t// Now in \"dispose\" phase\n\t\tvar disposePromise = setStatus(\"dispose\");\n\n\t\tresults.forEach(function (result) {\n\t\t\tif (result.dispose) result.dispose();\n\t\t});\n\n\t\t// Now in \"apply\" phase\n\t\tvar applyPromise = setStatus(\"apply\");\n\n\t\tvar error;\n\t\tvar reportError = function (err) {\n\t\t\tif (!error) error = err;\n\t\t};\n\n\t\tvar outdatedModules = [];\n\t\tresults.forEach(function (result) {\n\t\t\tif (result.apply) {\n\t\t\t\tvar modules = result.apply(reportError);\n\t\t\t\tif (modules) {\n\t\t\t\t\tfor (var i = 0; i < modules.length; i++) {\n\t\t\t\t\t\toutdatedModules.push(modules[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\treturn Promise.all([disposePromise, applyPromise]).then(function () {\n\t\t\t// handle errors in accept handlers and self accepted module load\n\t\t\tif (error) {\n\t\t\t\treturn setStatus(\"fail\").then(function () {\n\t\t\t\t\tthrow error;\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (queuedInvalidatedModules) {\n\t\t\t\treturn internalApply(options).then(function (list) {\n\t\t\t\t\toutdatedModules.forEach(function (moduleId) {\n\t\t\t\t\t\tif (list.indexOf(moduleId) < 0) list.push(moduleId);\n\t\t\t\t\t});\n\t\t\t\t\treturn list;\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn setStatus(\"idle\").then(function () {\n\t\t\t\treturn outdatedModules;\n\t\t\t});\n\t\t});\n\t}\n\n\tfunction applyInvalidatedModules() {\n\t\tif (queuedInvalidatedModules) {\n\t\t\tif (!currentUpdateApplyHandlers) currentUpdateApplyHandlers = [];\n\t\t\tObject.keys($hmrInvalidateModuleHandlers$).forEach(function (key) {\n\t\t\t\tqueuedInvalidatedModules.forEach(function (moduleId) {\n\t\t\t\t\t$hmrInvalidateModuleHandlers$[key](\n\t\t\t\t\t\tmoduleId,\n\t\t\t\t\t\tcurrentUpdateApplyHandlers\n\t\t\t\t\t);\n\t\t\t\t});\n\t\t\t});\n\t\t\tqueuedInvalidatedModules = undefined;\n\t\t\treturn true;\n\t\t}\n\t}\n};\n"
        }
    ]
}