{
    "sourceFile": "node_modules/next/dist/compiled/react-server-dom-webpack/cjs/react-server-dom-webpack-client.edge.production.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892734748,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @license React\n * react-server-dom-webpack-client.edge.production.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\"use strict\";\nvar ReactDOM = require(\"react-dom\"),\n  decoderOptions = { stream: !0 };\nfunction resolveClientReference(bundlerConfig, metadata) {\n  if (bundlerConfig) {\n    var moduleExports = bundlerConfig[metadata[0]];\n    if ((bundlerConfig = moduleExports && moduleExports[metadata[2]]))\n      moduleExports = bundlerConfig.name;\n    else {\n      bundlerConfig = moduleExports && moduleExports[\"*\"];\n      if (!bundlerConfig)\n        throw Error(\n          'Could not find the module \"' +\n            metadata[0] +\n            '\" in the React Server Consumer Manifest. This is probably a bug in the React Server Components bundler.'\n        );\n      moduleExports = metadata[2];\n    }\n    return 4 === metadata.length\n      ? [bundlerConfig.id, bundlerConfig.chunks, moduleExports, 1]\n      : [bundlerConfig.id, bundlerConfig.chunks, moduleExports];\n  }\n  return metadata;\n}\nfunction resolveServerReference(bundlerConfig, id) {\n  var name = \"\",\n    resolvedModuleData = bundlerConfig[id];\n  if (resolvedModuleData) name = resolvedModuleData.name;\n  else {\n    var idx = id.lastIndexOf(\"#\");\n    -1 !== idx &&\n      ((name = id.slice(idx + 1)),\n      (resolvedModuleData = bundlerConfig[id.slice(0, idx)]));\n    if (!resolvedModuleData)\n      throw Error(\n        'Could not find the module \"' +\n          id +\n          '\" in the React Server Manifest. This is probably a bug in the React Server Components bundler.'\n      );\n  }\n  return resolvedModuleData.async\n    ? [resolvedModuleData.id, resolvedModuleData.chunks, name, 1]\n    : [resolvedModuleData.id, resolvedModuleData.chunks, name];\n}\nvar chunkCache = new Map();\nfunction requireAsyncModule(id) {\n  var promise = globalThis.__next_require__(id);\n  if (\"function\" !== typeof promise.then || \"fulfilled\" === promise.status)\n    return null;\n  promise.then(\n    function (value) {\n      promise.status = \"fulfilled\";\n      promise.value = value;\n    },\n    function (reason) {\n      promise.status = \"rejected\";\n      promise.reason = reason;\n    }\n  );\n  return promise;\n}\nfunction ignoreReject() {}\nfunction preloadModule(metadata) {\n  for (var chunks = metadata[1], promises = [], i = 0; i < chunks.length; ) {\n    var chunkId = chunks[i++];\n    chunks[i++];\n    var entry = chunkCache.get(chunkId);\n    if (void 0 === entry) {\n      entry = __webpack_chunk_load__(chunkId);\n      promises.push(entry);\n      var resolve = chunkCache.set.bind(chunkCache, chunkId, null);\n      entry.then(resolve, ignoreReject);\n      chunkCache.set(chunkId, entry);\n    } else null !== entry && promises.push(entry);\n  }\n  return 4 === metadata.length\n    ? 0 === promises.length\n      ? requireAsyncModule(metadata[0])\n      : Promise.all(promises).then(function () {\n          return requireAsyncModule(metadata[0]);\n        })\n    : 0 < promises.length\n      ? Promise.all(promises)\n      : null;\n}\nfunction requireModule(metadata) {\n  var moduleExports = globalThis.__next_require__(metadata[0]);\n  if (4 === metadata.length && \"function\" === typeof moduleExports.then)\n    if (\"fulfilled\" === moduleExports.status)\n      moduleExports = moduleExports.value;\n    else throw moduleExports.reason;\n  return \"*\" === metadata[2]\n    ? moduleExports\n    : \"\" === metadata[2]\n      ? moduleExports.__esModule\n        ? moduleExports.default\n        : moduleExports\n      : moduleExports[metadata[2]];\n}\nfunction prepareDestinationWithChunks(moduleLoading, chunks, nonce$jscomp$0) {\n  if (null !== moduleLoading)\n    for (var i = 1; i < chunks.length; i += 2) {\n      var nonce = nonce$jscomp$0,\n        JSCompiler_temp_const = ReactDOMSharedInternals.d,\n        JSCompiler_temp_const$jscomp$0 = JSCompiler_temp_const.X,\n        JSCompiler_temp_const$jscomp$1 = moduleLoading.prefix + chunks[i];\n      var JSCompiler_inline_result = moduleLoading.crossOrigin;\n      JSCompiler_inline_result =\n        \"string\" === typeof JSCompiler_inline_result\n          ? \"use-credentials\" === JSCompiler_inline_result\n            ? JSCompiler_inline_result\n            : \"\"\n          : void 0;\n      JSCompiler_temp_const$jscomp$0.call(\n        JSCompiler_temp_const,\n        JSCompiler_temp_const$jscomp$1,\n        { crossOrigin: JSCompiler_inline_result, nonce: nonce }\n      );\n    }\n}\nvar ReactDOMSharedInternals =\n    ReactDOM.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,\n  REACT_ELEMENT_TYPE = Symbol.for(\"react.transitional.element\"),\n  REACT_LAZY_TYPE = Symbol.for(\"react.lazy\"),\n  MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\nfunction getIteratorFn(maybeIterable) {\n  if (null === maybeIterable || \"object\" !== typeof maybeIterable) return null;\n  maybeIterable =\n    (MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL]) ||\n    maybeIterable[\"@@iterator\"];\n  return \"function\" === typeof maybeIterable ? maybeIterable : null;\n}\nvar ASYNC_ITERATOR = Symbol.asyncIterator,\n  isArrayImpl = Array.isArray,\n  getPrototypeOf = Object.getPrototypeOf,\n  ObjectPrototype = Object.prototype,\n  knownServerReferences = new WeakMap();\nfunction serializeNumber(number) {\n  return Number.isFinite(number)\n    ? 0 === number && -Infinity === 1 / number\n      ? \"$-0\"\n      : number\n    : Infinity === number\n      ? \"$Infinity\"\n      : -Infinity === number\n        ? \"$-Infinity\"\n        : \"$NaN\";\n}\nfunction processReply(\n  root,\n  formFieldPrefix,\n  temporaryReferences,\n  resolve,\n  reject\n) {\n  function serializeTypedArray(tag, typedArray) {\n    typedArray = new Blob([\n      new Uint8Array(\n        typedArray.buffer,\n        typedArray.byteOffset,\n        typedArray.byteLength\n      )\n    ]);\n    var blobId = nextPartId++;\n    null === formData && (formData = new FormData());\n    formData.append(formFieldPrefix + blobId, typedArray);\n    return \"$\" + tag + blobId.toString(16);\n  }\n  function serializeBinaryReader(reader) {\n    function progress(entry) {\n      entry.done\n        ? ((entry = nextPartId++),\n          data.append(formFieldPrefix + entry, new Blob(buffer)),\n          data.append(\n            formFieldPrefix + streamId,\n            '\"$o' + entry.toString(16) + '\"'\n          ),\n          data.append(formFieldPrefix + streamId, \"C\"),\n          pendingParts--,\n          0 === pendingParts && resolve(data))\n        : (buffer.push(entry.value),\n          reader.read(new Uint8Array(1024)).then(progress, reject));\n    }\n    null === formData && (formData = new FormData());\n    var data = formData;\n    pendingParts++;\n    var streamId = nextPartId++,\n      buffer = [];\n    reader.read(new Uint8Array(1024)).then(progress, reject);\n    return \"$r\" + streamId.toString(16);\n  }\n  function serializeReader(reader) {\n    function progress(entry) {\n      if (entry.done)\n        data.append(formFieldPrefix + streamId, \"C\"),\n          pendingParts--,\n          0 === pendingParts && resolve(data);\n      else\n        try {\n          var partJSON = JSON.stringify(entry.value, resolveToJSON);\n          data.append(formFieldPrefix + streamId, partJSON);\n          reader.read().then(progress, reject);\n        } catch (x) {\n          reject(x);\n        }\n    }\n    null === formData && (formData = new FormData());\n    var data = formData;\n    pendingParts++;\n    var streamId = nextPartId++;\n    reader.read().then(progress, reject);\n    return \"$R\" + streamId.toString(16);\n  }\n  function serializeReadableStream(stream) {\n    try {\n      var binaryReader = stream.getReader({ mode: \"byob\" });\n    } catch (x) {\n      return serializeReader(stream.getReader());\n    }\n    return serializeBinaryReader(binaryReader);\n  }\n  function serializeAsyncIterable(iterable, iterator) {\n    function progress(entry) {\n      if (entry.done) {\n        if (void 0 === entry.value)\n          data.append(formFieldPrefix + streamId, \"C\");\n        else\n          try {\n            var partJSON = JSON.stringify(entry.value, resolveToJSON);\n            data.append(formFieldPrefix + streamId, \"C\" + partJSON);\n          } catch (x) {\n            reject(x);\n            return;\n          }\n        pendingParts--;\n        0 === pendingParts && resolve(data);\n      } else\n        try {\n          var partJSON$22 = JSON.stringify(entry.value, resolveToJSON);\n          data.append(formFieldPrefix + streamId, partJSON$22);\n          iterator.next().then(progress, reject);\n        } catch (x$23) {\n          reject(x$23);\n        }\n    }\n    null === formData && (formData = new FormData());\n    var data = formData;\n    pendingParts++;\n    var streamId = nextPartId++;\n    iterable = iterable === iterator;\n    iterator.next().then(progress, reject);\n    return \"$\" + (iterable ? \"x\" : \"X\") + streamId.toString(16);\n  }\n  function resolveToJSON(key, value) {\n    if (null === value) return null;\n    if (\"object\" === typeof value) {\n      switch (value.$$typeof) {\n        case REACT_ELEMENT_TYPE:\n          if (void 0 !== temporaryReferences && -1 === key.indexOf(\":\")) {\n            var parentReference = writtenObjects.get(this);\n            if (void 0 !== parentReference)\n              return (\n                temporaryReferences.set(parentReference + \":\" + key, value),\n                \"$T\"\n              );\n          }\n          throw Error(\n            \"React Element cannot be passed to Server Functions from the Client without a temporary reference set. Pass a TemporaryReferenceSet to the options.\"\n          );\n        case REACT_LAZY_TYPE:\n          parentReference = value._payload;\n          var init = value._init;\n          null === formData && (formData = new FormData());\n          pendingParts++;\n          try {\n            var resolvedModel = init(parentReference),\n              lazyId = nextPartId++,\n              partJSON = serializeModel(resolvedModel, lazyId);\n            formData.append(formFieldPrefix + lazyId, partJSON);\n            return \"$\" + lazyId.toString(16);\n          } catch (x) {\n            if (\n              \"object\" === typeof x &&\n              null !== x &&\n              \"function\" === typeof x.then\n            ) {\n              pendingParts++;\n              var lazyId$24 = nextPartId++;\n              parentReference = function () {\n                try {\n                  var partJSON$25 = serializeModel(value, lazyId$24),\n                    data$26 = formData;\n                  data$26.append(formFieldPrefix + lazyId$24, partJSON$25);\n                  pendingParts--;\n                  0 === pendingParts && resolve(data$26);\n                } catch (reason) {\n                  reject(reason);\n                }\n              };\n              x.then(parentReference, parentReference);\n              return \"$\" + lazyId$24.toString(16);\n            }\n            reject(x);\n            return null;\n          } finally {\n            pendingParts--;\n          }\n      }\n      if (\"function\" === typeof value.then) {\n        null === formData && (formData = new FormData());\n        pendingParts++;\n        var promiseId = nextPartId++;\n        value.then(function (partValue) {\n          try {\n            var partJSON$28 = serializeModel(partValue, promiseId);\n            partValue = formData;\n            partValue.append(formFieldPrefix + promiseId, partJSON$28);\n            pendingParts--;\n            0 === pendingParts && resolve(partValue);\n          } catch (reason) {\n            reject(reason);\n          }\n        }, reject);\n        return \"$@\" + promiseId.toString(16);\n      }\n      parentReference = writtenObjects.get(value);\n      if (void 0 !== parentReference)\n        if (modelRoot === value) modelRoot = null;\n        else return parentReference;\n      else\n        -1 === key.indexOf(\":\") &&\n          ((parentReference = writtenObjects.get(this)),\n          void 0 !== parentReference &&\n            ((key = parentReference + \":\" + key),\n            writtenObjects.set(value, key),\n            void 0 !== temporaryReferences &&\n              temporaryReferences.set(key, value)));\n      if (isArrayImpl(value)) return value;\n      if (value instanceof FormData) {\n        null === formData && (formData = new FormData());\n        var data$32 = formData;\n        key = nextPartId++;\n        var prefix = formFieldPrefix + key + \"_\";\n        value.forEach(function (originalValue, originalKey) {\n          data$32.append(prefix + originalKey, originalValue);\n        });\n        return \"$K\" + key.toString(16);\n      }\n      if (value instanceof Map)\n        return (\n          (key = nextPartId++),\n          (parentReference = serializeModel(Array.from(value), key)),\n          null === formData && (formData = new FormData()),\n          formData.append(formFieldPrefix + key, parentReference),\n          \"$Q\" + key.toString(16)\n        );\n      if (value instanceof Set)\n        return (\n          (key = nextPartId++),\n          (parentReference = serializeModel(Array.from(value), key)),\n          null === formData && (formData = new FormData()),\n          formData.append(formFieldPrefix + key, parentReference),\n          \"$W\" + key.toString(16)\n        );\n      if (value instanceof ArrayBuffer)\n        return (\n          (key = new Blob([value])),\n          (parentReference = nextPartId++),\n          null === formData && (formData = new FormData()),\n          formData.append(formFieldPrefix + parentReference, key),\n          \"$A\" + parentReference.toString(16)\n        );\n      if (value instanceof Int8Array) return serializeTypedArray(\"O\", value);\n      if (value instanceof Uint8Array) return serializeTypedArray(\"o\", value);\n      if (value instanceof Uint8ClampedArray)\n        return serializeTypedArray(\"U\", value);\n      if (value instanceof Int16Array) return serializeTypedArray(\"S\", value);\n      if (value instanceof Uint16Array) return serializeTypedArray(\"s\", value);\n      if (value instanceof Int32Array) return serializeTypedArray(\"L\", value);\n      if (value instanceof Uint32Array) return serializeTypedArray(\"l\", value);\n      if (value instanceof Float32Array) return serializeTypedArray(\"G\", value);\n      if (value instanceof Float64Array) return serializeTypedArray(\"g\", value);\n      if (value instanceof BigInt64Array)\n        return serializeTypedArray(\"M\", value);\n      if (value instanceof BigUint64Array)\n        return serializeTypedArray(\"m\", value);\n      if (value instanceof DataView) return serializeTypedArray(\"V\", value);\n      if (\"function\" === typeof Blob && value instanceof Blob)\n        return (\n          null === formData && (formData = new FormData()),\n          (key = nextPartId++),\n          formData.append(formFieldPrefix + key, value),\n          \"$B\" + key.toString(16)\n        );\n      if ((key = getIteratorFn(value)))\n        return (\n          (parentReference = key.call(value)),\n          parentReference === value\n            ? ((key = nextPartId++),\n              (parentReference = serializeModel(\n                Array.from(parentReference),\n                key\n              )),\n              null === formData && (formData = new FormData()),\n              formData.append(formFieldPrefix + key, parentReference),\n              \"$i\" + key.toString(16))\n            : Array.from(parentReference)\n        );\n      if (\n        \"function\" === typeof ReadableStream &&\n        value instanceof ReadableStream\n      )\n        return serializeReadableStream(value);\n      key = value[ASYNC_ITERATOR];\n      if (\"function\" === typeof key)\n        return serializeAsyncIterable(value, key.call(value));\n      key = getPrototypeOf(value);\n      if (\n        key !== ObjectPrototype &&\n        (null === key || null !== getPrototypeOf(key))\n      ) {\n        if (void 0 === temporaryReferences)\n          throw Error(\n            \"Only plain objects, and a few built-ins, can be passed to Server Functions. Classes or null prototypes are not supported.\"\n          );\n        return \"$T\";\n      }\n      return value;\n    }\n    if (\"string\" === typeof value) {\n      if (\"Z\" === value[value.length - 1] && this[key] instanceof Date)\n        return \"$D\" + value;\n      key = \"$\" === value[0] ? \"$\" + value : value;\n      return key;\n    }\n    if (\"boolean\" === typeof value) return value;\n    if (\"number\" === typeof value) return serializeNumber(value);\n    if (\"undefined\" === typeof value) return \"$undefined\";\n    if (\"function\" === typeof value) {\n      parentReference = knownServerReferences.get(value);\n      if (void 0 !== parentReference)\n        return (\n          (key = JSON.stringify(\n            { id: parentReference.id, bound: parentReference.bound },\n            resolveToJSON\n          )),\n          null === formData && (formData = new FormData()),\n          (parentReference = nextPartId++),\n          formData.set(formFieldPrefix + parentReference, key),\n          \"$F\" + parentReference.toString(16)\n        );\n      if (\n        void 0 !== temporaryReferences &&\n        -1 === key.indexOf(\":\") &&\n        ((parentReference = writtenObjects.get(this)),\n        void 0 !== parentReference)\n      )\n        return (\n          temporaryReferences.set(parentReference + \":\" + key, value), \"$T\"\n        );\n      throw Error(\n        \"Client Functions cannot be passed directly to Server Functions. Only Functions passed from the Server can be passed back again.\"\n      );\n    }\n    if (\"symbol\" === typeof value) {\n      if (\n        void 0 !== temporaryReferences &&\n        -1 === key.indexOf(\":\") &&\n        ((parentReference = writtenObjects.get(this)),\n        void 0 !== parentReference)\n      )\n        return (\n          temporaryReferences.set(parentReference + \":\" + key, value), \"$T\"\n        );\n      throw Error(\n        \"Symbols cannot be passed to a Server Function without a temporary reference set. Pass a TemporaryReferenceSet to the options.\"\n      );\n    }\n    if (\"bigint\" === typeof value) return \"$n\" + value.toString(10);\n    throw Error(\n      \"Type \" +\n        typeof value +\n        \" is not supported as an argument to a Server Function.\"\n    );\n  }\n  function serializeModel(model, id) {\n    \"object\" === typeof model &&\n      null !== model &&\n      ((id = \"$\" + id.toString(16)),\n      writtenObjects.set(model, id),\n      void 0 !== temporaryReferences && temporaryReferences.set(id, model));\n    modelRoot = model;\n    return JSON.stringify(model, resolveToJSON);\n  }\n  var nextPartId = 1,\n    pendingParts = 0,\n    formData = null,\n    writtenObjects = new WeakMap(),\n    modelRoot = root,\n    json = serializeModel(root, 0);\n  null === formData\n    ? resolve(json)\n    : (formData.set(formFieldPrefix + \"0\", json),\n      0 === pendingParts && resolve(formData));\n  return function () {\n    0 < pendingParts &&\n      ((pendingParts = 0),\n      null === formData ? resolve(json) : resolve(formData));\n  };\n}\nvar boundCache = new WeakMap();\nfunction encodeFormData(reference) {\n  var resolve,\n    reject,\n    thenable = new Promise(function (res, rej) {\n      resolve = res;\n      reject = rej;\n    });\n  processReply(\n    reference,\n    \"\",\n    void 0,\n    function (body) {\n      if (\"string\" === typeof body) {\n        var data = new FormData();\n        data.append(\"0\", body);\n        body = data;\n      }\n      thenable.status = \"fulfilled\";\n      thenable.value = body;\n      resolve(body);\n    },\n    function (e) {\n      thenable.status = \"rejected\";\n      thenable.reason = e;\n      reject(e);\n    }\n  );\n  return thenable;\n}\nfunction defaultEncodeFormAction(identifierPrefix) {\n  var referenceClosure = knownServerReferences.get(this);\n  if (!referenceClosure)\n    throw Error(\n      \"Tried to encode a Server Action from a different instance than the encoder is from. This is a bug in React.\"\n    );\n  var data = null;\n  if (null !== referenceClosure.bound) {\n    data = boundCache.get(referenceClosure);\n    data ||\n      ((data = encodeFormData({\n        id: referenceClosure.id,\n        bound: referenceClosure.bound\n      })),\n      boundCache.set(referenceClosure, data));\n    if (\"rejected\" === data.status) throw data.reason;\n    if (\"fulfilled\" !== data.status) throw data;\n    referenceClosure = data.value;\n    var prefixedData = new FormData();\n    referenceClosure.forEach(function (value, key) {\n      prefixedData.append(\"$ACTION_\" + identifierPrefix + \":\" + key, value);\n    });\n    data = prefixedData;\n    referenceClosure = \"$ACTION_REF_\" + identifierPrefix;\n  } else referenceClosure = \"$ACTION_ID_\" + referenceClosure.id;\n  return {\n    name: referenceClosure,\n    method: \"POST\",\n    encType: \"multipart/form-data\",\n    data: data\n  };\n}\nfunction isSignatureEqual(referenceId, numberOfBoundArgs) {\n  var referenceClosure = knownServerReferences.get(this);\n  if (!referenceClosure)\n    throw Error(\n      \"Tried to encode a Server Action from a different instance than the encoder is from. This is a bug in React.\"\n    );\n  if (referenceClosure.id !== referenceId) return !1;\n  var boundPromise = referenceClosure.bound;\n  if (null === boundPromise) return 0 === numberOfBoundArgs;\n  switch (boundPromise.status) {\n    case \"fulfilled\":\n      return boundPromise.value.length === numberOfBoundArgs;\n    case \"pending\":\n      throw boundPromise;\n    case \"rejected\":\n      throw boundPromise.reason;\n    default:\n      throw (\n        (\"string\" !== typeof boundPromise.status &&\n          ((boundPromise.status = \"pending\"),\n          boundPromise.then(\n            function (boundArgs) {\n              boundPromise.status = \"fulfilled\";\n              boundPromise.value = boundArgs;\n            },\n            function (error) {\n              boundPromise.status = \"rejected\";\n              boundPromise.reason = error;\n            }\n          )),\n        boundPromise)\n      );\n  }\n}\nfunction registerBoundServerReference(reference, id, bound, encodeFormAction) {\n  knownServerReferences.has(reference) ||\n    (knownServerReferences.set(reference, {\n      id: id,\n      originalBind: reference.bind,\n      bound: bound\n    }),\n    Object.defineProperties(reference, {\n      $$FORM_ACTION: {\n        value:\n          void 0 === encodeFormAction\n            ? defaultEncodeFormAction\n            : function () {\n                var referenceClosure = knownServerReferences.get(this);\n                if (!referenceClosure)\n                  throw Error(\n                    \"Tried to encode a Server Action from a different instance than the encoder is from. This is a bug in React.\"\n                  );\n                var boundPromise = referenceClosure.bound;\n                null === boundPromise && (boundPromise = Promise.resolve([]));\n                return encodeFormAction(referenceClosure.id, boundPromise);\n              }\n      },\n      $$IS_SIGNATURE_EQUAL: { value: isSignatureEqual },\n      bind: { value: bind }\n    }));\n}\nvar FunctionBind = Function.prototype.bind,\n  ArraySlice = Array.prototype.slice;\nfunction bind() {\n  var referenceClosure = knownServerReferences.get(this);\n  if (!referenceClosure) return FunctionBind.apply(this, arguments);\n  var newFn = referenceClosure.originalBind.apply(this, arguments),\n    args = ArraySlice.call(arguments, 1),\n    boundPromise = null;\n  boundPromise =\n    null !== referenceClosure.bound\n      ? Promise.resolve(referenceClosure.bound).then(function (boundArgs) {\n          return boundArgs.concat(args);\n        })\n      : Promise.resolve(args);\n  knownServerReferences.set(newFn, {\n    id: referenceClosure.id,\n    originalBind: newFn.bind,\n    bound: boundPromise\n  });\n  Object.defineProperties(newFn, {\n    $$FORM_ACTION: { value: this.$$FORM_ACTION },\n    $$IS_SIGNATURE_EQUAL: { value: isSignatureEqual },\n    bind: { value: bind }\n  });\n  return newFn;\n}\nfunction createBoundServerReference(metaData, callServer, encodeFormAction) {\n  function action() {\n    var args = Array.prototype.slice.call(arguments);\n    return bound\n      ? \"fulfilled\" === bound.status\n        ? callServer(id, bound.value.concat(args))\n        : Promise.resolve(bound).then(function (boundArgs) {\n            return callServer(id, boundArgs.concat(args));\n          })\n      : callServer(id, args);\n  }\n  var id = metaData.id,\n    bound = metaData.bound;\n  registerBoundServerReference(action, id, bound, encodeFormAction);\n  return action;\n}\nfunction createServerReference$1(id, callServer, encodeFormAction) {\n  function action() {\n    var args = Array.prototype.slice.call(arguments);\n    return callServer(id, args);\n  }\n  registerBoundServerReference(action, id, null, encodeFormAction);\n  return action;\n}\nfunction ReactPromise(status, value, reason, response) {\n  this.status = status;\n  this.value = value;\n  this.reason = reason;\n  this._response = response;\n}\nReactPromise.prototype = Object.create(Promise.prototype);\nReactPromise.prototype.then = function (resolve, reject) {\n  switch (this.status) {\n    case \"resolved_model\":\n      initializeModelChunk(this);\n      break;\n    case \"resolved_module\":\n      initializeModuleChunk(this);\n  }\n  switch (this.status) {\n    case \"fulfilled\":\n      resolve(this.value);\n      break;\n    case \"pending\":\n    case \"blocked\":\n      resolve &&\n        (null === this.value && (this.value = []), this.value.push(resolve));\n      reject &&\n        (null === this.reason && (this.reason = []), this.reason.push(reject));\n      break;\n    default:\n      reject && reject(this.reason);\n  }\n};\nfunction readChunk(chunk) {\n  switch (chunk.status) {\n    case \"resolved_model\":\n      initializeModelChunk(chunk);\n      break;\n    case \"resolved_module\":\n      initializeModuleChunk(chunk);\n  }\n  switch (chunk.status) {\n    case \"fulfilled\":\n      return chunk.value;\n    case \"pending\":\n    case \"blocked\":\n      throw chunk;\n    default:\n      throw chunk.reason;\n  }\n}\nfunction createPendingChunk(response) {\n  return new ReactPromise(\"pending\", null, null, response);\n}\nfunction wakeChunk(listeners, value) {\n  for (var i = 0; i < listeners.length; i++) (0, listeners[i])(value);\n}\nfunction wakeChunkIfInitialized(chunk, resolveListeners, rejectListeners) {\n  switch (chunk.status) {\n    case \"fulfilled\":\n      wakeChunk(resolveListeners, chunk.value);\n      break;\n    case \"pending\":\n    case \"blocked\":\n      if (chunk.value)\n        for (var i = 0; i < resolveListeners.length; i++)\n          chunk.value.push(resolveListeners[i]);\n      else chunk.value = resolveListeners;\n      if (chunk.reason) {\n        if (rejectListeners)\n          for (\n            resolveListeners = 0;\n            resolveListeners < rejectListeners.length;\n            resolveListeners++\n          )\n            chunk.reason.push(rejectListeners[resolveListeners]);\n      } else chunk.reason = rejectListeners;\n      break;\n    case \"rejected\":\n      rejectListeners && wakeChunk(rejectListeners, chunk.reason);\n  }\n}\nfunction triggerErrorOnChunk(chunk, error) {\n  if (\"pending\" !== chunk.status && \"blocked\" !== chunk.status)\n    chunk.reason.error(error);\n  else {\n    var listeners = chunk.reason;\n    chunk.status = \"rejected\";\n    chunk.reason = error;\n    null !== listeners && wakeChunk(listeners, error);\n  }\n}\nfunction createResolvedIteratorResultChunk(response, value, done) {\n  return new ReactPromise(\n    \"resolved_model\",\n    (done ? '{\"done\":true,\"value\":' : '{\"done\":false,\"value\":') + value + \"}\",\n    null,\n    response\n  );\n}\nfunction resolveIteratorResultChunk(chunk, value, done) {\n  resolveModelChunk(\n    chunk,\n    (done ? '{\"done\":true,\"value\":' : '{\"done\":false,\"value\":') + value + \"}\"\n  );\n}\nfunction resolveModelChunk(chunk, value) {\n  if (\"pending\" !== chunk.status) chunk.reason.enqueueModel(value);\n  else {\n    var resolveListeners = chunk.value,\n      rejectListeners = chunk.reason;\n    chunk.status = \"resolved_model\";\n    chunk.value = value;\n    null !== resolveListeners &&\n      (initializeModelChunk(chunk),\n      wakeChunkIfInitialized(chunk, resolveListeners, rejectListeners));\n  }\n}\nfunction resolveModuleChunk(chunk, value) {\n  if (\"pending\" === chunk.status || \"blocked\" === chunk.status) {\n    var resolveListeners = chunk.value,\n      rejectListeners = chunk.reason;\n    chunk.status = \"resolved_module\";\n    chunk.value = value;\n    null !== resolveListeners &&\n      (initializeModuleChunk(chunk),\n      wakeChunkIfInitialized(chunk, resolveListeners, rejectListeners));\n  }\n}\nvar initializingHandler = null;\nfunction initializeModelChunk(chunk) {\n  var prevHandler = initializingHandler;\n  initializingHandler = null;\n  var resolvedModel = chunk.value;\n  chunk.status = \"blocked\";\n  chunk.value = null;\n  chunk.reason = null;\n  try {\n    var value = JSON.parse(resolvedModel, chunk._response._fromJSON),\n      resolveListeners = chunk.value;\n    null !== resolveListeners &&\n      ((chunk.value = null),\n      (chunk.reason = null),\n      wakeChunk(resolveListeners, value));\n    if (null !== initializingHandler) {\n      if (initializingHandler.errored) throw initializingHandler.value;\n      if (0 < initializingHandler.deps) {\n        initializingHandler.value = value;\n        initializingHandler.chunk = chunk;\n        return;\n      }\n    }\n    chunk.status = \"fulfilled\";\n    chunk.value = value;\n  } catch (error) {\n    (chunk.status = \"rejected\"), (chunk.reason = error);\n  } finally {\n    initializingHandler = prevHandler;\n  }\n}\nfunction initializeModuleChunk(chunk) {\n  try {\n    var value = requireModule(chunk.value);\n    chunk.status = \"fulfilled\";\n    chunk.value = value;\n  } catch (error) {\n    (chunk.status = \"rejected\"), (chunk.reason = error);\n  }\n}\nfunction reportGlobalError(response, error) {\n  response._closed = !0;\n  response._closedReason = error;\n  response._chunks.forEach(function (chunk) {\n    \"pending\" === chunk.status && triggerErrorOnChunk(chunk, error);\n  });\n}\nfunction createLazyChunkWrapper(chunk) {\n  return { $$typeof: REACT_LAZY_TYPE, _payload: chunk, _init: readChunk };\n}\nfunction getChunk(response, id) {\n  var chunks = response._chunks,\n    chunk = chunks.get(id);\n  chunk ||\n    ((chunk = response._closed\n      ? new ReactPromise(\"rejected\", null, response._closedReason, response)\n      : createPendingChunk(response)),\n    chunks.set(id, chunk));\n  return chunk;\n}\nfunction waitForReference(\n  referencedChunk,\n  parentObject,\n  key,\n  response,\n  map,\n  path\n) {\n  function fulfill(value) {\n    for (var i = 1; i < path.length; i++) {\n      for (; value.$$typeof === REACT_LAZY_TYPE; )\n        if (((value = value._payload), value === handler.chunk))\n          value = handler.value;\n        else if (\"fulfilled\" === value.status) value = value.value;\n        else {\n          path.splice(0, i - 1);\n          value.then(fulfill, reject);\n          return;\n        }\n      value = value[path[i]];\n    }\n    i = map(response, value, parentObject, key);\n    parentObject[key] = i;\n    \"\" === key && null === handler.value && (handler.value = i);\n    if (\n      parentObject[0] === REACT_ELEMENT_TYPE &&\n      \"object\" === typeof handler.value &&\n      null !== handler.value &&\n      handler.value.$$typeof === REACT_ELEMENT_TYPE\n    )\n      switch (((value = handler.value), key)) {\n        case \"3\":\n          value.props = i;\n      }\n    handler.deps--;\n    0 === handler.deps &&\n      ((i = handler.chunk),\n      null !== i &&\n        \"blocked\" === i.status &&\n        ((value = i.value),\n        (i.status = \"fulfilled\"),\n        (i.value = handler.value),\n        null !== value && wakeChunk(value, handler.value)));\n  }\n  function reject(error) {\n    if (!handler.errored) {\n      handler.errored = !0;\n      handler.value = error;\n      var chunk = handler.chunk;\n      null !== chunk &&\n        \"blocked\" === chunk.status &&\n        triggerErrorOnChunk(chunk, error);\n    }\n  }\n  if (initializingHandler) {\n    var handler = initializingHandler;\n    handler.deps++;\n  } else\n    handler = initializingHandler = {\n      parent: null,\n      chunk: null,\n      value: null,\n      deps: 1,\n      errored: !1\n    };\n  referencedChunk.then(fulfill, reject);\n  return null;\n}\nfunction loadServerReference(response, metaData, parentObject, key) {\n  if (!response._serverReferenceConfig)\n    return createBoundServerReference(\n      metaData,\n      response._callServer,\n      response._encodeFormAction\n    );\n  var serverReference = resolveServerReference(\n      response._serverReferenceConfig,\n      metaData.id\n    ),\n    promise = preloadModule(serverReference);\n  if (promise)\n    metaData.bound && (promise = Promise.all([promise, metaData.bound]));\n  else if (metaData.bound) promise = Promise.resolve(metaData.bound);\n  else\n    return (\n      (promise = requireModule(serverReference)),\n      registerBoundServerReference(\n        promise,\n        metaData.id,\n        metaData.bound,\n        response._encodeFormAction\n      ),\n      promise\n    );\n  if (initializingHandler) {\n    var handler = initializingHandler;\n    handler.deps++;\n  } else\n    handler = initializingHandler = {\n      parent: null,\n      chunk: null,\n      value: null,\n      deps: 1,\n      errored: !1\n    };\n  promise.then(\n    function () {\n      var resolvedValue = requireModule(serverReference);\n      if (metaData.bound) {\n        var boundArgs = metaData.bound.value.slice(0);\n        boundArgs.unshift(null);\n        resolvedValue = resolvedValue.bind.apply(resolvedValue, boundArgs);\n      }\n      registerBoundServerReference(\n        resolvedValue,\n        metaData.id,\n        metaData.bound,\n        response._encodeFormAction\n      );\n      parentObject[key] = resolvedValue;\n      \"\" === key && null === handler.value && (handler.value = resolvedValue);\n      if (\n        parentObject[0] === REACT_ELEMENT_TYPE &&\n        \"object\" === typeof handler.value &&\n        null !== handler.value &&\n        handler.value.$$typeof === REACT_ELEMENT_TYPE\n      )\n        switch (((boundArgs = handler.value), key)) {\n          case \"3\":\n            boundArgs.props = resolvedValue;\n        }\n      handler.deps--;\n      0 === handler.deps &&\n        ((resolvedValue = handler.chunk),\n        null !== resolvedValue &&\n          \"blocked\" === resolvedValue.status &&\n          ((boundArgs = resolvedValue.value),\n          (resolvedValue.status = \"fulfilled\"),\n          (resolvedValue.value = handler.value),\n          null !== boundArgs && wakeChunk(boundArgs, handler.value)));\n    },\n    function (error) {\n      if (!handler.errored) {\n        handler.errored = !0;\n        handler.value = error;\n        var chunk = handler.chunk;\n        null !== chunk &&\n          \"blocked\" === chunk.status &&\n          triggerErrorOnChunk(chunk, error);\n      }\n    }\n  );\n  return null;\n}\nfunction getOutlinedModel(response, reference, parentObject, key, map) {\n  reference = reference.split(\":\");\n  var id = parseInt(reference[0], 16);\n  id = getChunk(response, id);\n  switch (id.status) {\n    case \"resolved_model\":\n      initializeModelChunk(id);\n      break;\n    case \"resolved_module\":\n      initializeModuleChunk(id);\n  }\n  switch (id.status) {\n    case \"fulfilled\":\n      var value = id.value;\n      for (id = 1; id < reference.length; id++) {\n        for (; value.$$typeof === REACT_LAZY_TYPE; )\n          if (((value = value._payload), \"fulfilled\" === value.status))\n            value = value.value;\n          else\n            return waitForReference(\n              value,\n              parentObject,\n              key,\n              response,\n              map,\n              reference.slice(id - 1)\n            );\n        value = value[reference[id]];\n      }\n      return map(response, value, parentObject, key);\n    case \"pending\":\n    case \"blocked\":\n      return waitForReference(id, parentObject, key, response, map, reference);\n    default:\n      return (\n        initializingHandler\n          ? ((initializingHandler.errored = !0),\n            (initializingHandler.value = id.reason))\n          : (initializingHandler = {\n              parent: null,\n              chunk: null,\n              value: id.reason,\n              deps: 0,\n              errored: !0\n            }),\n        null\n      );\n  }\n}\nfunction createMap(response, model) {\n  return new Map(model);\n}\nfunction createSet(response, model) {\n  return new Set(model);\n}\nfunction createBlob(response, model) {\n  return new Blob(model.slice(1), { type: model[0] });\n}\nfunction createFormData(response, model) {\n  response = new FormData();\n  for (var i = 0; i < model.length; i++)\n    response.append(model[i][0], model[i][1]);\n  return response;\n}\nfunction extractIterator(response, model) {\n  return model[Symbol.iterator]();\n}\nfunction createModel(response, model) {\n  return model;\n}\nfunction parseModelString(response, parentObject, key, value) {\n  if (\"$\" === value[0]) {\n    if (\"$\" === value)\n      return (\n        null !== initializingHandler &&\n          \"0\" === key &&\n          (initializingHandler = {\n            parent: initializingHandler,\n            chunk: null,\n            value: null,\n            deps: 0,\n            errored: !1\n          }),\n        REACT_ELEMENT_TYPE\n      );\n    switch (value[1]) {\n      case \"$\":\n        return value.slice(1);\n      case \"L\":\n        return (\n          (parentObject = parseInt(value.slice(2), 16)),\n          (response = getChunk(response, parentObject)),\n          createLazyChunkWrapper(response)\n        );\n      case \"@\":\n        if (2 === value.length) return new Promise(function () {});\n        parentObject = parseInt(value.slice(2), 16);\n        return getChunk(response, parentObject);\n      case \"S\":\n        return Symbol.for(value.slice(2));\n      case \"F\":\n        return (\n          (value = value.slice(2)),\n          getOutlinedModel(\n            response,\n            value,\n            parentObject,\n            key,\n            loadServerReference\n          )\n        );\n      case \"T\":\n        parentObject = \"$\" + value.slice(2);\n        response = response._tempRefs;\n        if (null == response)\n          throw Error(\n            \"Missing a temporary reference set but the RSC response returned a temporary reference. Pass a temporaryReference option with the set that was used with the reply.\"\n          );\n        return response.get(parentObject);\n      case \"Q\":\n        return (\n          (value = value.slice(2)),\n          getOutlinedModel(response, value, parentObject, key, createMap)\n        );\n      case \"W\":\n        return (\n          (value = value.slice(2)),\n          getOutlinedModel(response, value, parentObject, key, createSet)\n        );\n      case \"B\":\n        return (\n          (value = value.slice(2)),\n          getOutlinedModel(response, value, parentObject, key, createBlob)\n        );\n      case \"K\":\n        return (\n          (value = value.slice(2)),\n          getOutlinedModel(response, value, parentObject, key, createFormData)\n        );\n      case \"Z\":\n        return resolveErrorProd();\n      case \"i\":\n        return (\n          (value = value.slice(2)),\n          getOutlinedModel(response, value, parentObject, key, extractIterator)\n        );\n      case \"I\":\n        return Infinity;\n      case \"-\":\n        return \"$-0\" === value ? -0 : -Infinity;\n      case \"N\":\n        return NaN;\n      case \"u\":\n        return;\n      case \"D\":\n        return new Date(Date.parse(value.slice(2)));\n      case \"n\":\n        return BigInt(value.slice(2));\n      default:\n        return (\n          (value = value.slice(1)),\n          getOutlinedModel(response, value, parentObject, key, createModel)\n        );\n    }\n  }\n  return value;\n}\nfunction missingCall() {\n  throw Error(\n    'Trying to call a function from \"use server\" but the callServer option was not implemented in your router runtime.'\n  );\n}\nfunction ResponseInstance(\n  bundlerConfig,\n  serverReferenceConfig,\n  moduleLoading,\n  callServer,\n  encodeFormAction,\n  nonce,\n  temporaryReferences\n) {\n  var chunks = new Map();\n  this._bundlerConfig = bundlerConfig;\n  this._serverReferenceConfig = serverReferenceConfig;\n  this._moduleLoading = moduleLoading;\n  this._callServer = void 0 !== callServer ? callServer : missingCall;\n  this._encodeFormAction = encodeFormAction;\n  this._nonce = nonce;\n  this._chunks = chunks;\n  this._stringDecoder = new TextDecoder();\n  this._fromJSON = null;\n  this._rowLength = this._rowTag = this._rowID = this._rowState = 0;\n  this._buffer = [];\n  this._closed = !1;\n  this._closedReason = null;\n  this._tempRefs = temporaryReferences;\n  this._fromJSON = createFromJSONCallback(this);\n}\nfunction resolveBuffer(response, id, buffer) {\n  var chunks = response._chunks,\n    chunk = chunks.get(id);\n  chunk && \"pending\" !== chunk.status\n    ? chunk.reason.enqueueValue(buffer)\n    : chunks.set(id, new ReactPromise(\"fulfilled\", buffer, null, response));\n}\nfunction resolveModule(response, id, model) {\n  var chunks = response._chunks,\n    chunk = chunks.get(id);\n  model = JSON.parse(model, response._fromJSON);\n  var clientReference = resolveClientReference(response._bundlerConfig, model);\n  prepareDestinationWithChunks(\n    response._moduleLoading,\n    model[1],\n    response._nonce\n  );\n  if ((model = preloadModule(clientReference))) {\n    if (chunk) {\n      var blockedChunk = chunk;\n      blockedChunk.status = \"blocked\";\n    } else\n      (blockedChunk = new ReactPromise(\"blocked\", null, null, response)),\n        chunks.set(id, blockedChunk);\n    model.then(\n      function () {\n        return resolveModuleChunk(blockedChunk, clientReference);\n      },\n      function (error) {\n        return triggerErrorOnChunk(blockedChunk, error);\n      }\n    );\n  } else\n    chunk\n      ? resolveModuleChunk(chunk, clientReference)\n      : chunks.set(\n          id,\n          new ReactPromise(\"resolved_module\", clientReference, null, response)\n        );\n}\nfunction resolveStream(response, id, stream, controller) {\n  var chunks = response._chunks,\n    chunk = chunks.get(id);\n  chunk\n    ? \"pending\" === chunk.status &&\n      ((response = chunk.value),\n      (chunk.status = \"fulfilled\"),\n      (chunk.value = stream),\n      (chunk.reason = controller),\n      null !== response && wakeChunk(response, chunk.value))\n    : chunks.set(\n        id,\n        new ReactPromise(\"fulfilled\", stream, controller, response)\n      );\n}\nfunction startReadableStream(response, id, type) {\n  var controller = null;\n  type = new ReadableStream({\n    type: type,\n    start: function (c) {\n      controller = c;\n    }\n  });\n  var previousBlockedChunk = null;\n  resolveStream(response, id, type, {\n    enqueueValue: function (value) {\n      null === previousBlockedChunk\n        ? controller.enqueue(value)\n        : previousBlockedChunk.then(function () {\n            controller.enqueue(value);\n          });\n    },\n    enqueueModel: function (json) {\n      if (null === previousBlockedChunk) {\n        var chunk = new ReactPromise(\"resolved_model\", json, null, response);\n        initializeModelChunk(chunk);\n        \"fulfilled\" === chunk.status\n          ? controller.enqueue(chunk.value)\n          : (chunk.then(\n              function (v) {\n                return controller.enqueue(v);\n              },\n              function (e) {\n                return controller.error(e);\n              }\n            ),\n            (previousBlockedChunk = chunk));\n      } else {\n        chunk = previousBlockedChunk;\n        var chunk$52 = createPendingChunk(response);\n        chunk$52.then(\n          function (v) {\n            return controller.enqueue(v);\n          },\n          function (e) {\n            return controller.error(e);\n          }\n        );\n        previousBlockedChunk = chunk$52;\n        chunk.then(function () {\n          previousBlockedChunk === chunk$52 && (previousBlockedChunk = null);\n          resolveModelChunk(chunk$52, json);\n        });\n      }\n    },\n    close: function () {\n      if (null === previousBlockedChunk) controller.close();\n      else {\n        var blockedChunk = previousBlockedChunk;\n        previousBlockedChunk = null;\n        blockedChunk.then(function () {\n          return controller.close();\n        });\n      }\n    },\n    error: function (error) {\n      if (null === previousBlockedChunk) controller.error(error);\n      else {\n        var blockedChunk = previousBlockedChunk;\n        previousBlockedChunk = null;\n        blockedChunk.then(function () {\n          return controller.error(error);\n        });\n      }\n    }\n  });\n}\nfunction asyncIterator() {\n  return this;\n}\nfunction createIterator(next) {\n  next = { next: next };\n  next[ASYNC_ITERATOR] = asyncIterator;\n  return next;\n}\nfunction startAsyncIterable(response, id, iterator) {\n  var buffer = [],\n    closed = !1,\n    nextWriteIndex = 0,\n    $jscomp$compprop0 = {};\n  $jscomp$compprop0 =\n    (($jscomp$compprop0[ASYNC_ITERATOR] = function () {\n      var nextReadIndex = 0;\n      return createIterator(function (arg) {\n        if (void 0 !== arg)\n          throw Error(\n            \"Values cannot be passed to next() of AsyncIterables passed to Client Components.\"\n          );\n        if (nextReadIndex === buffer.length) {\n          if (closed)\n            return new ReactPromise(\n              \"fulfilled\",\n              { done: !0, value: void 0 },\n              null,\n              response\n            );\n          buffer[nextReadIndex] = createPendingChunk(response);\n        }\n        return buffer[nextReadIndex++];\n      });\n    }),\n    $jscomp$compprop0);\n  resolveStream(\n    response,\n    id,\n    iterator ? $jscomp$compprop0[ASYNC_ITERATOR]() : $jscomp$compprop0,\n    {\n      enqueueValue: function (value) {\n        if (nextWriteIndex === buffer.length)\n          buffer[nextWriteIndex] = new ReactPromise(\n            \"fulfilled\",\n            { done: !1, value: value },\n            null,\n            response\n          );\n        else {\n          var chunk = buffer[nextWriteIndex],\n            resolveListeners = chunk.value,\n            rejectListeners = chunk.reason;\n          chunk.status = \"fulfilled\";\n          chunk.value = { done: !1, value: value };\n          null !== resolveListeners &&\n            wakeChunkIfInitialized(chunk, resolveListeners, rejectListeners);\n        }\n        nextWriteIndex++;\n      },\n      enqueueModel: function (value) {\n        nextWriteIndex === buffer.length\n          ? (buffer[nextWriteIndex] = createResolvedIteratorResultChunk(\n              response,\n              value,\n              !1\n            ))\n          : resolveIteratorResultChunk(buffer[nextWriteIndex], value, !1);\n        nextWriteIndex++;\n      },\n      close: function (value) {\n        closed = !0;\n        nextWriteIndex === buffer.length\n          ? (buffer[nextWriteIndex] = createResolvedIteratorResultChunk(\n              response,\n              value,\n              !0\n            ))\n          : resolveIteratorResultChunk(buffer[nextWriteIndex], value, !0);\n        for (nextWriteIndex++; nextWriteIndex < buffer.length; )\n          resolveIteratorResultChunk(\n            buffer[nextWriteIndex++],\n            '\"$undefined\"',\n            !0\n          );\n      },\n      error: function (error) {\n        closed = !0;\n        for (\n          nextWriteIndex === buffer.length &&\n          (buffer[nextWriteIndex] = createPendingChunk(response));\n          nextWriteIndex < buffer.length;\n\n        )\n          triggerErrorOnChunk(buffer[nextWriteIndex++], error);\n      }\n    }\n  );\n}\nfunction resolveErrorProd() {\n  var error = Error(\n    \"An error occurred in the Server Components render. The specific message is omitted in production builds to avoid leaking sensitive details. A digest property is included on this error instance which may provide additional details about the nature of the error.\"\n  );\n  error.stack = \"Error: \" + error.message;\n  return error;\n}\nfunction mergeBuffer(buffer, lastChunk) {\n  for (var l = buffer.length, byteLength = lastChunk.length, i = 0; i < l; i++)\n    byteLength += buffer[i].byteLength;\n  byteLength = new Uint8Array(byteLength);\n  for (var i$53 = (i = 0); i$53 < l; i$53++) {\n    var chunk = buffer[i$53];\n    byteLength.set(chunk, i);\n    i += chunk.byteLength;\n  }\n  byteLength.set(lastChunk, i);\n  return byteLength;\n}\nfunction resolveTypedArray(\n  response,\n  id,\n  buffer,\n  lastChunk,\n  constructor,\n  bytesPerElement\n) {\n  buffer =\n    0 === buffer.length && 0 === lastChunk.byteOffset % bytesPerElement\n      ? lastChunk\n      : mergeBuffer(buffer, lastChunk);\n  constructor = new constructor(\n    buffer.buffer,\n    buffer.byteOffset,\n    buffer.byteLength / bytesPerElement\n  );\n  resolveBuffer(response, id, constructor);\n}\nfunction processFullBinaryRow(response, id, tag, buffer, chunk) {\n  switch (tag) {\n    case 65:\n      resolveBuffer(response, id, mergeBuffer(buffer, chunk).buffer);\n      return;\n    case 79:\n      resolveTypedArray(response, id, buffer, chunk, Int8Array, 1);\n      return;\n    case 111:\n      resolveBuffer(\n        response,\n        id,\n        0 === buffer.length ? chunk : mergeBuffer(buffer, chunk)\n      );\n      return;\n    case 85:\n      resolveTypedArray(response, id, buffer, chunk, Uint8ClampedArray, 1);\n      return;\n    case 83:\n      resolveTypedArray(response, id, buffer, chunk, Int16Array, 2);\n      return;\n    case 115:\n      resolveTypedArray(response, id, buffer, chunk, Uint16Array, 2);\n      return;\n    case 76:\n      resolveTypedArray(response, id, buffer, chunk, Int32Array, 4);\n      return;\n    case 108:\n      resolveTypedArray(response, id, buffer, chunk, Uint32Array, 4);\n      return;\n    case 71:\n      resolveTypedArray(response, id, buffer, chunk, Float32Array, 4);\n      return;\n    case 103:\n      resolveTypedArray(response, id, buffer, chunk, Float64Array, 8);\n      return;\n    case 77:\n      resolveTypedArray(response, id, buffer, chunk, BigInt64Array, 8);\n      return;\n    case 109:\n      resolveTypedArray(response, id, buffer, chunk, BigUint64Array, 8);\n      return;\n    case 86:\n      resolveTypedArray(response, id, buffer, chunk, DataView, 1);\n      return;\n  }\n  for (\n    var stringDecoder = response._stringDecoder, row = \"\", i = 0;\n    i < buffer.length;\n    i++\n  )\n    row += stringDecoder.decode(buffer[i], decoderOptions);\n  buffer = row += stringDecoder.decode(chunk);\n  switch (tag) {\n    case 73:\n      resolveModule(response, id, buffer);\n      break;\n    case 72:\n      id = buffer[0];\n      buffer = buffer.slice(1);\n      response = JSON.parse(buffer, response._fromJSON);\n      buffer = ReactDOMSharedInternals.d;\n      switch (id) {\n        case \"D\":\n          buffer.D(response);\n          break;\n        case \"C\":\n          \"string\" === typeof response\n            ? buffer.C(response)\n            : buffer.C(response[0], response[1]);\n          break;\n        case \"L\":\n          id = response[0];\n          tag = response[1];\n          3 === response.length\n            ? buffer.L(id, tag, response[2])\n            : buffer.L(id, tag);\n          break;\n        case \"m\":\n          \"string\" === typeof response\n            ? buffer.m(response)\n            : buffer.m(response[0], response[1]);\n          break;\n        case \"X\":\n          \"string\" === typeof response\n            ? buffer.X(response)\n            : buffer.X(response[0], response[1]);\n          break;\n        case \"S\":\n          \"string\" === typeof response\n            ? buffer.S(response)\n            : buffer.S(\n                response[0],\n                0 === response[1] ? void 0 : response[1],\n                3 === response.length ? response[2] : void 0\n              );\n          break;\n        case \"M\":\n          \"string\" === typeof response\n            ? buffer.M(response)\n            : buffer.M(response[0], response[1]);\n      }\n      break;\n    case 69:\n      tag = JSON.parse(buffer);\n      buffer = resolveErrorProd();\n      buffer.digest = tag.digest;\n      tag = response._chunks;\n      (chunk = tag.get(id))\n        ? triggerErrorOnChunk(chunk, buffer)\n        : tag.set(id, new ReactPromise(\"rejected\", null, buffer, response));\n      break;\n    case 84:\n      tag = response._chunks;\n      (chunk = tag.get(id)) && \"pending\" !== chunk.status\n        ? chunk.reason.enqueueValue(buffer)\n        : tag.set(id, new ReactPromise(\"fulfilled\", buffer, null, response));\n      break;\n    case 78:\n    case 68:\n    case 87:\n      throw Error(\n        \"Failed to read a RSC payload created by a development version of React on the server while using a production version on the client. Always use matching versions on the server and the client.\"\n      );\n    case 82:\n      startReadableStream(response, id, void 0);\n      break;\n    case 114:\n      startReadableStream(response, id, \"bytes\");\n      break;\n    case 88:\n      startAsyncIterable(response, id, !1);\n      break;\n    case 120:\n      startAsyncIterable(response, id, !0);\n      break;\n    case 67:\n      (response = response._chunks.get(id)) &&\n        \"fulfilled\" === response.status &&\n        response.reason.close(\"\" === buffer ? '\"$undefined\"' : buffer);\n      break;\n    default:\n      (tag = response._chunks),\n        (chunk = tag.get(id))\n          ? resolveModelChunk(chunk, buffer)\n          : tag.set(\n              id,\n              new ReactPromise(\"resolved_model\", buffer, null, response)\n            );\n  }\n}\nfunction createFromJSONCallback(response) {\n  return function (key, value) {\n    if (\"string\" === typeof value)\n      return parseModelString(response, this, key, value);\n    if (\"object\" === typeof value && null !== value) {\n      if (value[0] === REACT_ELEMENT_TYPE) {\n        if (\n          ((key = {\n            $$typeof: REACT_ELEMENT_TYPE,\n            type: value[1],\n            key: value[2],\n            ref: null,\n            props: value[3]\n          }),\n          null !== initializingHandler)\n        )\n          if (\n            ((value = initializingHandler),\n            (initializingHandler = value.parent),\n            value.errored)\n          )\n            (key = new ReactPromise(\"rejected\", null, value.value, response)),\n              (key = createLazyChunkWrapper(key));\n          else if (0 < value.deps) {\n            var blockedChunk = new ReactPromise(\n              \"blocked\",\n              null,\n              null,\n              response\n            );\n            value.value = key;\n            value.chunk = blockedChunk;\n            key = createLazyChunkWrapper(blockedChunk);\n          }\n      } else key = value;\n      return key;\n    }\n    return value;\n  };\n}\nfunction noServerCall() {\n  throw Error(\n    \"Server Functions cannot be called during initial render. This would create a fetch waterfall. Try to use a Server Component to pass data to Client Components instead.\"\n  );\n}\nfunction createResponseFromOptions(options) {\n  return new ResponseInstance(\n    options.serverConsumerManifest.moduleMap,\n    options.serverConsumerManifest.serverModuleMap,\n    options.serverConsumerManifest.moduleLoading,\n    noServerCall,\n    options.encodeFormAction,\n    \"string\" === typeof options.nonce ? options.nonce : void 0,\n    options && options.temporaryReferences\n      ? options.temporaryReferences\n      : void 0\n  );\n}\nfunction startReadingFromStream(response, stream) {\n  function progress(_ref) {\n    var value = _ref.value;\n    if (_ref.done) reportGlobalError(response, Error(\"Connection closed.\"));\n    else {\n      var i = 0,\n        rowState = response._rowState;\n      _ref = response._rowID;\n      for (\n        var rowTag = response._rowTag,\n          rowLength = response._rowLength,\n          buffer = response._buffer,\n          chunkLength = value.length;\n        i < chunkLength;\n\n      ) {\n        var lastIdx = -1;\n        switch (rowState) {\n          case 0:\n            lastIdx = value[i++];\n            58 === lastIdx\n              ? (rowState = 1)\n              : (_ref =\n                  (_ref << 4) | (96 < lastIdx ? lastIdx - 87 : lastIdx - 48));\n            continue;\n          case 1:\n            rowState = value[i];\n            84 === rowState ||\n            65 === rowState ||\n            79 === rowState ||\n            111 === rowState ||\n            85 === rowState ||\n            83 === rowState ||\n            115 === rowState ||\n            76 === rowState ||\n            108 === rowState ||\n            71 === rowState ||\n            103 === rowState ||\n            77 === rowState ||\n            109 === rowState ||\n            86 === rowState\n              ? ((rowTag = rowState), (rowState = 2), i++)\n              : (64 < rowState && 91 > rowState) ||\n                  35 === rowState ||\n                  114 === rowState ||\n                  120 === rowState\n                ? ((rowTag = rowState), (rowState = 3), i++)\n                : ((rowTag = 0), (rowState = 3));\n            continue;\n          case 2:\n            lastIdx = value[i++];\n            44 === lastIdx\n              ? (rowState = 4)\n              : (rowLength =\n                  (rowLength << 4) |\n                  (96 < lastIdx ? lastIdx - 87 : lastIdx - 48));\n            continue;\n          case 3:\n            lastIdx = value.indexOf(10, i);\n            break;\n          case 4:\n            (lastIdx = i + rowLength), lastIdx > value.length && (lastIdx = -1);\n        }\n        var offset = value.byteOffset + i;\n        if (-1 < lastIdx)\n          (rowLength = new Uint8Array(value.buffer, offset, lastIdx - i)),\n            processFullBinaryRow(response, _ref, rowTag, buffer, rowLength),\n            (i = lastIdx),\n            3 === rowState && i++,\n            (rowLength = _ref = rowTag = rowState = 0),\n            (buffer.length = 0);\n        else {\n          value = new Uint8Array(value.buffer, offset, value.byteLength - i);\n          buffer.push(value);\n          rowLength -= value.byteLength;\n          break;\n        }\n      }\n      response._rowState = rowState;\n      response._rowID = _ref;\n      response._rowTag = rowTag;\n      response._rowLength = rowLength;\n      return reader.read().then(progress).catch(error);\n    }\n  }\n  function error(e) {\n    reportGlobalError(response, e);\n  }\n  var reader = stream.getReader();\n  reader.read().then(progress).catch(error);\n}\nexports.createFromFetch = function (promiseForResponse, options) {\n  var response = createResponseFromOptions(options);\n  promiseForResponse.then(\n    function (r) {\n      startReadingFromStream(response, r.body);\n    },\n    function (e) {\n      reportGlobalError(response, e);\n    }\n  );\n  return getChunk(response, 0);\n};\nexports.createFromReadableStream = function (stream, options) {\n  options = createResponseFromOptions(options);\n  startReadingFromStream(options, stream);\n  return getChunk(options, 0);\n};\nexports.createServerReference = function (id) {\n  return createServerReference$1(id, noServerCall);\n};\nexports.createTemporaryReferenceSet = function () {\n  return new Map();\n};\nexports.encodeReply = function (value, options) {\n  return new Promise(function (resolve, reject) {\n    var abort = processReply(\n      value,\n      \"\",\n      options && options.temporaryReferences\n        ? options.temporaryReferences\n        : void 0,\n      resolve,\n      reject\n    );\n    if (options && options.signal) {\n      var signal = options.signal;\n      if (signal.aborted) abort(signal.reason);\n      else {\n        var listener = function () {\n          abort(signal.reason);\n          signal.removeEventListener(\"abort\", listener);\n        };\n        signal.addEventListener(\"abort\", listener);\n      }\n    }\n  });\n};\nexports.registerServerReference = function (reference, id, encodeFormAction) {\n  registerBoundServerReference(reference, id, null, encodeFormAction);\n  return reference;\n};\n"
        }
    ]
}