{
    "sourceFile": "node_modules/next/dist/compiled/react-server-dom-webpack/cjs/react-server-dom-webpack-plugin.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892735069,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @license React\n * react-server-dom-webpack-plugin.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\"use strict\";\nvar path = require(\"path\"),\n  url = require(\"url\"),\n  asyncLib = require(\"neo-async\"),\n  acorn = require(\"acorn-loose\"),\n  ModuleDependency = require(\"webpack/lib/dependencies/ModuleDependency\"),\n  NullDependency = require(\"webpack/lib/dependencies/NullDependency\"),\n  Template = require(\"webpack/lib/Template\"),\n  webpack = require(\"webpack\");\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (o) {\n    if (\"string\" === typeof o) return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    \"Object\" === n && o.constructor && (n = o.constructor.name);\n    if (\"Map\" === n || \"Set\" === n) return Array.from(o);\n    if (\"Arguments\" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))\n      return _arrayLikeToArray(o, minLen);\n  }\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (null == len || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it =\n    (\"undefined\" !== typeof Symbol && o[Symbol.iterator]) || o[\"@@iterator\"];\n  if (!it) {\n    if (\n      Array.isArray(o) ||\n      (it = _unsupportedIterableToArray(o)) ||\n      (allowArrayLike && o && \"number\" === typeof o.length)\n    ) {\n      it && (o = it);\n      var i = 0;\n      allowArrayLike = function () {};\n      return {\n        s: allowArrayLike,\n        n: function () {\n          return i >= o.length ? { done: !0 } : { done: !1, value: o[i++] };\n        },\n        e: function (e) {\n          throw e;\n        },\n        f: allowArrayLike\n      };\n    }\n    throw new TypeError(\n      \"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"\n    );\n  }\n  var normalCompletion = !0,\n    didErr = !1,\n    err;\n  return {\n    s: function () {\n      it = it.call(o);\n    },\n    n: function () {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function (e) {\n      didErr = !0;\n      err = e;\n    },\n    f: function () {\n      try {\n        normalCompletion || null == it.return || it.return();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\nconst isArrayImpl = Array.isArray;\nclass ClientReferenceDependency extends ModuleDependency {\n  constructor(request) {\n    super(request);\n  }\n  get type() {\n    return \"client-reference\";\n  }\n}\nconst clientFileName = require.resolve(\"../client.browser.js\");\nclass ReactFlightWebpackPlugin {\n  constructor(options) {\n    this.serverConsumerManifestFilename =\n      this.clientManifestFilename =\n      this.chunkName =\n      this.clientReferences =\n        void 0;\n    if (!options || \"boolean\" !== typeof options.isServer)\n      throw Error(\n        \"React Server Plugin: You must specify the isServer option as a boolean.\"\n      );\n    if (options.isServer) throw Error(\"TODO: Implement the server compiler.\");\n    options.clientReferences\n      ? \"string\" !== typeof options.clientReferences &&\n        isArrayImpl(options.clientReferences)\n        ? (this.clientReferences = options.clientReferences)\n        : (this.clientReferences = [options.clientReferences])\n      : (this.clientReferences = [\n          { directory: \".\", recursive: !0, include: /\\.(js|ts|jsx|tsx)$/ }\n        ]);\n    \"string\" === typeof options.chunkName\n      ? ((this.chunkName = options.chunkName),\n        /\\[(index|request)\\]/.test(this.chunkName) ||\n          (this.chunkName += \"[index]\"))\n      : (this.chunkName = \"client[index]\");\n    this.clientManifestFilename =\n      options.clientManifestFilename || \"react-client-manifest.json\";\n    this.serverConsumerManifestFilename =\n      options.serverConsumerManifestFilename || \"react-ssr-manifest.json\";\n  }\n  apply(compiler) {\n    const _this = this;\n    let resolvedClientReferences,\n      clientFileNameFound = !1;\n    compiler.hooks.beforeCompile.tapAsync(\n      \"React Server Plugin\",\n      (_ref, callback) => {\n        _ref = _ref.contextModuleFactory;\n        const contextResolver = compiler.resolverFactory.get(\"context\", {}),\n          normalResolver = compiler.resolverFactory.get(\"normal\");\n        _this.resolveAllClientFiles(\n          compiler.context,\n          contextResolver,\n          normalResolver,\n          compiler.inputFileSystem,\n          _ref,\n          function (err, resolvedClientRefs) {\n            err\n              ? callback(err)\n              : ((resolvedClientReferences = resolvedClientRefs), callback());\n          }\n        );\n      }\n    );\n    compiler.hooks.thisCompilation.tap(\n      \"React Server Plugin\",\n      (compilation, _ref2) => {\n        _ref2 = _ref2.normalModuleFactory;\n        compilation.dependencyFactories.set(ClientReferenceDependency, _ref2);\n        compilation.dependencyTemplates.set(\n          ClientReferenceDependency,\n          new NullDependency.Template()\n        );\n        compilation = (parser) => {\n          parser.hooks.program.tap(\"React Server Plugin\", () => {\n            const module = parser.state.module;\n            if (\n              module.resource === clientFileName &&\n              ((clientFileNameFound = !0), resolvedClientReferences)\n            )\n              for (let i = 0; i < resolvedClientReferences.length; i++) {\n                const dep = resolvedClientReferences[i];\n                var chunkName = _this.chunkName\n                  .replace(/\\[index\\]/g, \"\" + i)\n                  .replace(/\\[request\\]/g, Template.toPath(dep.userRequest));\n                chunkName = new webpack.AsyncDependenciesBlock(\n                  { name: chunkName },\n                  null,\n                  dep.request\n                );\n                chunkName.addDependency(dep);\n                module.addBlock(chunkName);\n              }\n          });\n        };\n        _ref2.hooks.parser\n          .for(\"javascript/auto\")\n          .tap(\"HarmonyModulesPlugin\", compilation);\n        _ref2.hooks.parser\n          .for(\"javascript/esm\")\n          .tap(\"HarmonyModulesPlugin\", compilation);\n        _ref2.hooks.parser\n          .for(\"javascript/dynamic\")\n          .tap(\"HarmonyModulesPlugin\", compilation);\n      }\n    );\n    compiler.hooks.make.tap(\"React Server Plugin\", (compilation) => {\n      compilation.hooks.processAssets.tap(\n        {\n          name: \"React Server Plugin\",\n          stage: webpack.Compilation.PROCESS_ASSETS_STAGE_REPORT\n        },\n        function () {\n          if (!1 === clientFileNameFound)\n            compilation.warnings.push(\n              new webpack.WebpackError(\n                \"Client runtime at react-server-dom-webpack/client was not found. React Server Components module map file \" +\n                  _this.clientManifestFilename +\n                  \" was not created.\"\n              )\n            );\n          else {\n            var configuredCrossOriginLoading =\n              compilation.outputOptions.crossOriginLoading;\n            configuredCrossOriginLoading =\n              \"string\" === typeof configuredCrossOriginLoading\n                ? \"use-credentials\" === configuredCrossOriginLoading\n                  ? configuredCrossOriginLoading\n                  : \"anonymous\"\n                : null;\n            var resolvedClientFiles = new Set(\n                (resolvedClientReferences || []).map((ref) => ref.request)\n              ),\n              clientManifest = {},\n              moduleMap = {};\n            configuredCrossOriginLoading = {\n              moduleLoading: {\n                prefix: compilation.outputOptions.publicPath || \"\",\n                crossOrigin: configuredCrossOriginLoading\n              },\n              moduleMap\n            };\n            var runtimeChunkFiles = new Set();\n            compilation.entrypoints.forEach((entrypoint) => {\n              (entrypoint = entrypoint.getRuntimeChunk()) &&\n                entrypoint.files.forEach((runtimeFile) => {\n                  runtimeChunkFiles.add(runtimeFile);\n                });\n            });\n            compilation.chunkGroups.forEach(function (chunkGroup) {\n              function recordModule(id, module) {\n                if (\n                  resolvedClientFiles.has(module.resource) &&\n                  ((module = url.pathToFileURL(module.resource).href),\n                  void 0 !== module)\n                ) {\n                  const ssrExports = {};\n                  clientManifest[module] = { id, chunks, name: \"*\" };\n                  ssrExports[\"*\"] = { specifier: module, name: \"*\" };\n                  moduleMap[id] = ssrExports;\n                }\n              }\n              const chunks = [];\n              chunkGroup.chunks.forEach(function (c) {\n                var _iterator = _createForOfIteratorHelper(c.files),\n                  _step;\n                try {\n                  for (_iterator.s(); !(_step = _iterator.n()).done; ) {\n                    const file = _step.value;\n                    if (!file.endsWith(\".js\")) break;\n                    if (file.endsWith(\".hot-update.js\")) break;\n                    chunks.push(c.id, file);\n                    break;\n                  }\n                } catch (err) {\n                  _iterator.e(err);\n                } finally {\n                  _iterator.f();\n                }\n              });\n              chunkGroup.chunks.forEach(function (chunk) {\n                chunk = compilation.chunkGraph.getChunkModulesIterable(chunk);\n                Array.from(chunk).forEach(function (module) {\n                  const moduleId = compilation.chunkGraph.getModuleId(module);\n                  recordModule(moduleId, module);\n                  module.modules &&\n                    module.modules.forEach((concatenatedMod) => {\n                      recordModule(moduleId, concatenatedMod);\n                    });\n                });\n              });\n            });\n            var clientOutput = JSON.stringify(clientManifest, null, 2);\n            compilation.emitAsset(\n              _this.clientManifestFilename,\n              new webpack.sources.RawSource(clientOutput, !1)\n            );\n            configuredCrossOriginLoading = JSON.stringify(\n              configuredCrossOriginLoading,\n              null,\n              2\n            );\n            compilation.emitAsset(\n              _this.serverConsumerManifestFilename,\n              new webpack.sources.RawSource(configuredCrossOriginLoading, !1)\n            );\n          }\n        }\n      );\n    });\n  }\n  resolveAllClientFiles(\n    context,\n    contextResolver,\n    normalResolver,\n    fs,\n    contextModuleFactory,\n    callback\n  ) {\n    function hasUseClientDirective(source) {\n      if (-1 === source.indexOf(\"use client\")) return !1;\n      let body;\n      try {\n        body = acorn.parse(source, {\n          ecmaVersion: \"2024\",\n          sourceType: \"module\"\n        }).body;\n      } catch (x) {\n        return !1;\n      }\n      for (source = 0; source < body.length; source++) {\n        const node = body[source];\n        if (\"ExpressionStatement\" !== node.type || !node.directive) break;\n        if (\"use client\" === node.directive) return !0;\n      }\n      return !1;\n    }\n    asyncLib.map(\n      this.clientReferences,\n      (clientReferencePath, cb) => {\n        \"string\" === typeof clientReferencePath\n          ? cb(null, [new ClientReferenceDependency(clientReferencePath)])\n          : contextResolver.resolve(\n              {},\n              context,\n              clientReferencePath.directory,\n              {},\n              (err, resolvedDirectory) => {\n                if (err) return cb(err);\n                contextModuleFactory.resolveDependencies(\n                  fs,\n                  {\n                    resource: resolvedDirectory,\n                    resourceQuery: \"\",\n                    recursive:\n                      void 0 === clientReferencePath.recursive\n                        ? !0\n                        : clientReferencePath.recursive,\n                    regExp: clientReferencePath.include,\n                    include: void 0,\n                    exclude: clientReferencePath.exclude\n                  },\n                  (err2, deps) => {\n                    if (err2) return cb(err2);\n                    err2 = deps.map((dep) => {\n                      var request = path.join(\n                        resolvedDirectory,\n                        dep.userRequest\n                      );\n                      request = new ClientReferenceDependency(request);\n                      request.userRequest = dep.userRequest;\n                      return request;\n                    });\n                    asyncLib.filter(\n                      err2,\n                      (clientRefDep, filterCb) => {\n                        normalResolver.resolve(\n                          {},\n                          context,\n                          clientRefDep.request,\n                          {},\n                          (err3, resolvedPath) => {\n                            if (err3 || \"string\" !== typeof resolvedPath)\n                              return filterCb(null, !1);\n                            fs.readFile(\n                              resolvedPath,\n                              \"utf-8\",\n                              (err4, content) => {\n                                if (err4 || \"string\" !== typeof content)\n                                  return filterCb(null, !1);\n                                err4 = hasUseClientDirective(content);\n                                filterCb(null, err4);\n                              }\n                            );\n                          }\n                        );\n                      },\n                      cb\n                    );\n                  }\n                );\n              }\n            );\n      },\n      (err, result) => {\n        if (err) return callback(err);\n        err = [];\n        for (let i = 0; i < result.length; i++) err.push.apply(err, result[i]);\n        callback(null, err);\n      }\n    );\n  }\n}\nmodule.exports = ReactFlightWebpackPlugin;\n"
        }
    ]
}