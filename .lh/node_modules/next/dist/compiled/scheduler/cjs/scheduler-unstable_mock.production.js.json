{
    "sourceFile": "node_modules/next/dist/compiled/scheduler/cjs/scheduler-unstable_mock.production.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892737945,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @license React\n * scheduler-unstable_mock.production.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\"use strict\";\nfunction push(heap, node) {\n  var index = heap.length;\n  heap.push(node);\n  a: for (; 0 < index; ) {\n    var parentIndex = (index - 1) >>> 1,\n      parent = heap[parentIndex];\n    if (0 < compare(parent, node))\n      (heap[parentIndex] = node), (heap[index] = parent), (index = parentIndex);\n    else break a;\n  }\n}\nfunction peek(heap) {\n  return 0 === heap.length ? null : heap[0];\n}\nfunction pop(heap) {\n  if (0 === heap.length) return null;\n  var first = heap[0],\n    last = heap.pop();\n  if (last !== first) {\n    heap[0] = last;\n    a: for (\n      var index = 0, length = heap.length, halfLength = length >>> 1;\n      index < halfLength;\n\n    ) {\n      var leftIndex = 2 * (index + 1) - 1,\n        left = heap[leftIndex],\n        rightIndex = leftIndex + 1,\n        right = heap[rightIndex];\n      if (0 > compare(left, last))\n        rightIndex < length && 0 > compare(right, left)\n          ? ((heap[index] = right),\n            (heap[rightIndex] = last),\n            (index = rightIndex))\n          : ((heap[index] = left),\n            (heap[leftIndex] = last),\n            (index = leftIndex));\n      else if (rightIndex < length && 0 > compare(right, last))\n        (heap[index] = right), (heap[rightIndex] = last), (index = rightIndex);\n      else break a;\n    }\n  }\n  return first;\n}\nfunction compare(a, b) {\n  var diff = a.sortIndex - b.sortIndex;\n  return 0 !== diff ? diff : a.id - b.id;\n}\nvar taskQueue = [],\n  timerQueue = [],\n  taskIdCounter = 1,\n  currentTask = null,\n  currentPriorityLevel = 3,\n  isPerformingWork = !1,\n  isHostCallbackScheduled = !1,\n  isHostTimeoutScheduled = !1,\n  currentMockTime = 0,\n  scheduledCallback = null,\n  scheduledTimeout = null,\n  timeoutTime = -1,\n  yieldedValues = null,\n  expectedNumberOfYields = -1,\n  didStop = !1,\n  isFlushing = !1,\n  needsPaint = !1,\n  shouldYieldForPaint = !1,\n  disableYieldValue = !1;\nfunction advanceTimers(currentTime) {\n  for (var timer = peek(timerQueue); null !== timer; ) {\n    if (null === timer.callback) pop(timerQueue);\n    else if (timer.startTime <= currentTime)\n      pop(timerQueue),\n        (timer.sortIndex = timer.expirationTime),\n        push(taskQueue, timer);\n    else break;\n    timer = peek(timerQueue);\n  }\n}\nfunction handleTimeout(currentTime) {\n  isHostTimeoutScheduled = !1;\n  advanceTimers(currentTime);\n  if (!isHostCallbackScheduled)\n    if (null !== peek(taskQueue))\n      (isHostCallbackScheduled = !0), (scheduledCallback = flushWork);\n    else {\n      var firstTimer = peek(timerQueue);\n      null !== firstTimer &&\n        ((currentTime = firstTimer.startTime - currentTime),\n        (scheduledTimeout = handleTimeout),\n        (timeoutTime = currentMockTime + currentTime));\n    }\n}\nfunction flushWork(hasTimeRemaining, initialTime) {\n  isHostCallbackScheduled = !1;\n  isHostTimeoutScheduled &&\n    ((isHostTimeoutScheduled = !1),\n    (scheduledTimeout = null),\n    (timeoutTime = -1));\n  isPerformingWork = !0;\n  var previousPriorityLevel = currentPriorityLevel;\n  try {\n    a: {\n      advanceTimers(initialTime);\n      for (\n        currentTask = peek(taskQueue);\n        null !== currentTask &&\n        (!(currentTask.expirationTime > initialTime) ||\n          (hasTimeRemaining && !shouldYieldToHost()));\n\n      ) {\n        var callback = currentTask.callback;\n        if (\"function\" === typeof callback) {\n          currentTask.callback = null;\n          currentPriorityLevel = currentTask.priorityLevel;\n          var continuationCallback = callback(\n            currentTask.expirationTime <= initialTime\n          );\n          initialTime = currentMockTime;\n          if (\"function\" === typeof continuationCallback) {\n            if (\n              ((currentTask.callback = continuationCallback),\n              advanceTimers(initialTime),\n              shouldYieldForPaint)\n            ) {\n              var JSCompiler_inline_result = (needsPaint = !0);\n              break a;\n            }\n          } else\n            currentTask === peek(taskQueue) && pop(taskQueue),\n              advanceTimers(initialTime);\n        } else pop(taskQueue);\n        currentTask = peek(taskQueue);\n      }\n      if (null !== currentTask) JSCompiler_inline_result = !0;\n      else {\n        var firstTimer = peek(timerQueue);\n        if (null !== firstTimer) {\n          var ms = firstTimer.startTime - initialTime;\n          scheduledTimeout = handleTimeout;\n          timeoutTime = currentMockTime + ms;\n        }\n        JSCompiler_inline_result = !1;\n      }\n    }\n    return JSCompiler_inline_result;\n  } finally {\n    (currentTask = null),\n      (currentPriorityLevel = previousPriorityLevel),\n      (isPerformingWork = !1);\n  }\n}\nfunction shouldYieldToHost() {\n  return (0 === expectedNumberOfYields && null === yieldedValues) ||\n    (-1 !== expectedNumberOfYields &&\n      null !== yieldedValues &&\n      yieldedValues.length >= expectedNumberOfYields) ||\n    (shouldYieldForPaint && needsPaint)\n    ? (didStop = !0)\n    : !1;\n}\nfunction unstable_flushAllWithoutAsserting() {\n  if (isFlushing) throw Error(\"Already flushing work.\");\n  if (null !== scheduledCallback) {\n    var cb = scheduledCallback;\n    isFlushing = !0;\n    try {\n      var hasMoreWork = !0;\n      do hasMoreWork = cb(!0, currentMockTime);\n      while (hasMoreWork);\n      hasMoreWork || (scheduledCallback = null);\n      return !0;\n    } finally {\n      isFlushing = !1;\n    }\n  } else return !1;\n}\nexports.log = function (value) {\n  \"disabledLog\" === console.log.name ||\n    disableYieldValue ||\n    (null === yieldedValues\n      ? (yieldedValues = [value])\n      : yieldedValues.push(value));\n};\nexports.reset = function () {\n  if (isFlushing) throw Error(\"Cannot reset while already flushing work.\");\n  currentMockTime = 0;\n  scheduledTimeout = scheduledCallback = null;\n  timeoutTime = -1;\n  yieldedValues = null;\n  expectedNumberOfYields = -1;\n  needsPaint = isFlushing = didStop = !1;\n};\nexports.unstable_IdlePriority = 5;\nexports.unstable_ImmediatePriority = 1;\nexports.unstable_LowPriority = 4;\nexports.unstable_NormalPriority = 3;\nexports.unstable_Profiling = null;\nexports.unstable_UserBlockingPriority = 2;\nexports.unstable_advanceTime = function (ms) {\n  \"disabledLog\" === console.log.name ||\n    disableYieldValue ||\n    ((currentMockTime += ms),\n    null !== scheduledTimeout &&\n      timeoutTime <= currentMockTime &&\n      (scheduledTimeout(currentMockTime),\n      (timeoutTime = -1),\n      (scheduledTimeout = null)));\n};\nexports.unstable_cancelCallback = function (task) {\n  task.callback = null;\n};\nexports.unstable_clearLog = function () {\n  if (null === yieldedValues) return [];\n  var values = yieldedValues;\n  yieldedValues = null;\n  return values;\n};\nexports.unstable_flushAll = function () {\n  if (null !== yieldedValues)\n    throw Error(\n      \"Log is not empty. Assert on the log of yielded values before flushing additional work.\"\n    );\n  unstable_flushAllWithoutAsserting();\n  if (null !== yieldedValues)\n    throw Error(\n      \"While flushing work, something yielded a value. Use an assertion helper to assert on the log of yielded values, e.g. expect(Scheduler).toFlushAndYield([...])\"\n    );\n};\nexports.unstable_flushAllWithoutAsserting = unstable_flushAllWithoutAsserting;\nexports.unstable_flushExpired = function () {\n  if (isFlushing) throw Error(\"Already flushing work.\");\n  if (null !== scheduledCallback) {\n    isFlushing = !0;\n    try {\n      scheduledCallback(!1, currentMockTime) || (scheduledCallback = null);\n    } finally {\n      isFlushing = !1;\n    }\n  }\n};\nexports.unstable_flushNumberOfYields = function (count) {\n  if (isFlushing) throw Error(\"Already flushing work.\");\n  if (null !== scheduledCallback) {\n    var cb = scheduledCallback;\n    expectedNumberOfYields = count;\n    isFlushing = !0;\n    try {\n      count = !0;\n      do count = cb(!0, currentMockTime);\n      while (count && !didStop);\n      count || (scheduledCallback = null);\n    } finally {\n      (expectedNumberOfYields = -1), (isFlushing = didStop = !1);\n    }\n  }\n};\nexports.unstable_flushUntilNextPaint = function () {\n  if (isFlushing) throw Error(\"Already flushing work.\");\n  if (null !== scheduledCallback) {\n    var cb = scheduledCallback;\n    shouldYieldForPaint = !0;\n    needsPaint = !1;\n    isFlushing = !0;\n    try {\n      var hasMoreWork = !0;\n      do hasMoreWork = cb(!0, currentMockTime);\n      while (hasMoreWork && !didStop);\n      hasMoreWork || (scheduledCallback = null);\n    } finally {\n      isFlushing = didStop = shouldYieldForPaint = !1;\n    }\n  }\n  return !1;\n};\nexports.unstable_forceFrameRate = function () {};\nexports.unstable_getCurrentPriorityLevel = function () {\n  return currentPriorityLevel;\n};\nexports.unstable_hasPendingWork = function () {\n  return null !== scheduledCallback;\n};\nexports.unstable_next = function (eventHandler) {\n  switch (currentPriorityLevel) {\n    case 1:\n    case 2:\n    case 3:\n      var priorityLevel = 3;\n      break;\n    default:\n      priorityLevel = currentPriorityLevel;\n  }\n  var previousPriorityLevel = currentPriorityLevel;\n  currentPriorityLevel = priorityLevel;\n  try {\n    return eventHandler();\n  } finally {\n    currentPriorityLevel = previousPriorityLevel;\n  }\n};\nexports.unstable_now = function () {\n  return currentMockTime;\n};\nexports.unstable_requestPaint = function () {\n  needsPaint = !0;\n};\nexports.unstable_runWithPriority = function (priorityLevel, eventHandler) {\n  switch (priorityLevel) {\n    case 1:\n    case 2:\n    case 3:\n    case 4:\n    case 5:\n      break;\n    default:\n      priorityLevel = 3;\n  }\n  var previousPriorityLevel = currentPriorityLevel;\n  currentPriorityLevel = priorityLevel;\n  try {\n    return eventHandler();\n  } finally {\n    currentPriorityLevel = previousPriorityLevel;\n  }\n};\nexports.unstable_scheduleCallback = function (\n  priorityLevel,\n  callback,\n  options\n) {\n  var currentTime = currentMockTime;\n  \"object\" === typeof options && null !== options\n    ? ((options = options.delay),\n      (options =\n        \"number\" === typeof options && 0 < options\n          ? currentTime + options\n          : currentTime))\n    : (options = currentTime);\n  switch (priorityLevel) {\n    case 1:\n      var timeout = -1;\n      break;\n    case 2:\n      timeout = 250;\n      break;\n    case 5:\n      timeout = 1073741823;\n      break;\n    case 4:\n      timeout = 1e4;\n      break;\n    default:\n      timeout = 5e3;\n  }\n  timeout = options + timeout;\n  priorityLevel = {\n    id: taskIdCounter++,\n    callback: callback,\n    priorityLevel: priorityLevel,\n    startTime: options,\n    expirationTime: timeout,\n    sortIndex: -1\n  };\n  options > currentTime\n    ? ((priorityLevel.sortIndex = options),\n      push(timerQueue, priorityLevel),\n      null === peek(taskQueue) &&\n        priorityLevel === peek(timerQueue) &&\n        (isHostTimeoutScheduled\n          ? ((scheduledTimeout = null), (timeoutTime = -1))\n          : (isHostTimeoutScheduled = !0),\n        (scheduledTimeout = handleTimeout),\n        (timeoutTime = currentMockTime + (options - currentTime))))\n    : ((priorityLevel.sortIndex = timeout),\n      push(taskQueue, priorityLevel),\n      isHostCallbackScheduled ||\n        isPerformingWork ||\n        ((isHostCallbackScheduled = !0), (scheduledCallback = flushWork)));\n  return priorityLevel;\n};\nexports.unstable_setDisableYieldValue = function (newValue) {\n  disableYieldValue = newValue;\n};\nexports.unstable_shouldYield = shouldYieldToHost;\nexports.unstable_wrapCallback = function (callback) {\n  var parentPriorityLevel = currentPriorityLevel;\n  return function () {\n    var previousPriorityLevel = currentPriorityLevel;\n    currentPriorityLevel = parentPriorityLevel;\n    try {\n      return callback.apply(this, arguments);\n    } finally {\n      currentPriorityLevel = previousPriorityLevel;\n    }\n  };\n};\n"
        }
    ]
}