{
    "sourceFile": "node_modules/next/dist/server/render-result.d.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892881689,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import type { OutgoingHttpHeaders, ServerResponse } from 'http';\nimport type { CacheControl } from './lib/cache-control';\nimport type { FetchMetrics } from './base-http';\nimport type { RenderResumeDataCache } from './resume-data-cache/resume-data-cache';\ntype ContentTypeOption = string | undefined;\nexport type AppPageRenderResultMetadata = {\n    flightData?: Buffer;\n    cacheControl?: CacheControl;\n    staticBailoutInfo?: {\n        stack?: string;\n        description?: string;\n    };\n    /**\n     * The postponed state if the render had postponed and needs to be resumed.\n     */\n    postponed?: string;\n    /**\n     * The headers to set on the response that were added by the render.\n     */\n    headers?: OutgoingHttpHeaders;\n    fetchTags?: string;\n    fetchMetrics?: FetchMetrics;\n    segmentData?: Map<string, Buffer>;\n    /**\n     * In development, the cache is warmed up before the render. This is attached\n     * to the metadata so that it can be used during the render.\n     */\n    devRenderResumeDataCache?: RenderResumeDataCache;\n};\nexport type PagesRenderResultMetadata = {\n    pageData?: any;\n    cacheControl?: CacheControl;\n    assetQueryString?: string;\n    isNotFound?: boolean;\n    isRedirect?: boolean;\n};\nexport type StaticRenderResultMetadata = {};\nexport type RenderResultMetadata = AppPageRenderResultMetadata & PagesRenderResultMetadata & StaticRenderResultMetadata;\nexport type RenderResultResponse = ReadableStream<Uint8Array>[] | ReadableStream<Uint8Array> | string | Buffer | null;\nexport type RenderResultOptions<Metadata extends RenderResultMetadata = RenderResultMetadata> = {\n    contentType?: ContentTypeOption;\n    waitUntil?: Promise<unknown>;\n    metadata: Metadata;\n};\nexport default class RenderResult<Metadata extends RenderResultMetadata = RenderResultMetadata> {\n    /**\n     * The detected content type for the response. This is used to set the\n     * `Content-Type` header.\n     */\n    readonly contentType: ContentTypeOption;\n    /**\n     * The metadata for the response. This is used to set the revalidation times\n     * and other metadata.\n     */\n    readonly metadata: Readonly<Metadata>;\n    /**\n     * The response itself. This can be a string, a stream, or null. If it's a\n     * string, then it's a static response. If it's a stream, then it's a\n     * dynamic response. If it's null, then the response was not found or was\n     * already sent.\n     */\n    private response;\n    /**\n     * Creates a new RenderResult instance from a static response.\n     *\n     * @param value the static response value\n     * @returns a new RenderResult instance\n     */\n    static fromStatic(value: string | Buffer): RenderResult<StaticRenderResultMetadata>;\n    private readonly waitUntil?;\n    constructor(response: RenderResultResponse, { contentType, waitUntil, metadata }: RenderResultOptions<Metadata>);\n    assignMetadata(metadata: Metadata): void;\n    /**\n     * Returns true if the response is null. It can be null if the response was\n     * not found or was already sent.\n     */\n    get isNull(): boolean;\n    /**\n     * Returns false if the response is a string. It can be a string if the page\n     * was prerendered. If it's not, then it was generated dynamically.\n     */\n    get isDynamic(): boolean;\n    toUnchunkedBuffer(stream?: false): Buffer;\n    toUnchunkedBuffer(stream: true): Promise<Buffer>;\n    /**\n     * Returns the response if it is a string. If the page was dynamic, this will\n     * return a promise if the `stream` option is true, or it will throw an error.\n     *\n     * @param stream Whether or not to return a promise if the response is dynamic\n     * @returns The response as a string\n     */\n    toUnchunkedString(stream?: false): string;\n    toUnchunkedString(stream: true): Promise<string>;\n    /**\n     * Returns the response if it is a stream, or throws an error if it is a\n     * string.\n     */\n    private get readable();\n    /**\n     * Chains a new stream to the response. This will convert the response to an\n     * array of streams if it is not already one and will add the new stream to\n     * the end. When this response is piped, all of the streams will be piped\n     * one after the other.\n     *\n     * @param readable The new stream to chain\n     */\n    chain(readable: ReadableStream<Uint8Array>): void;\n    /**\n     * Pipes the response to a writable stream. This will close/cancel the\n     * writable stream if an error is encountered. If this doesn't throw, then\n     * the writable stream will be closed or aborted.\n     *\n     * @param writable Writable stream to pipe the response to\n     */\n    pipeTo(writable: WritableStream<Uint8Array>): Promise<void>;\n    /**\n     * Pipes the response to a node response. This will close/cancel the node\n     * response if an error is encountered.\n     *\n     * @param res\n     */\n    pipeToNodeResponse(res: ServerResponse): Promise<void>;\n}\nexport {};\n"
        }
    ]
}