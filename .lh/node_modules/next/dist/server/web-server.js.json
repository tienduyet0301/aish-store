{
    "sourceFile": "node_modules/next/dist/server/web-server.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892898010,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"default\", {\n    enumerable: true,\n    get: function() {\n        return NextWebServer;\n    }\n});\nconst _web = require(\"./api-utils/web\");\nconst _baseserver = /*#__PURE__*/ _interop_require_wildcard(require(\"./base-server\"));\nconst _etag = require(\"./lib/etag\");\nconst _requestmeta = require(\"./request-meta\");\nconst _web1 = /*#__PURE__*/ _interop_require_default(require(\"./response-cache/web\"));\nconst _removetrailingslash = require(\"../shared/lib/router/utils/remove-trailing-slash\");\nconst _utils = require(\"../shared/lib/router/utils\");\nconst _serverutils = require(\"./server-utils\");\nconst _routeregex = require(\"../shared/lib/router/utils/route-regex\");\nconst _routematcher = require(\"../shared/lib/router/utils/route-matcher\");\nconst _incrementalcache = require(\"./lib/incremental-cache\");\nconst _buildcustomroute = require(\"../lib/build-custom-route\");\nconst _constants = require(\"../api/constants\");\nconst _globals = require(\"./web/globals\");\nconst _getedgepreviewprops = require(\"./web/get-edge-preview-props\");\nfunction _interop_require_default(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nfunction _getRequireWildcardCache(nodeInterop) {\n    if (typeof WeakMap !== \"function\") return null;\n    var cacheBabelInterop = new WeakMap();\n    var cacheNodeInterop = new WeakMap();\n    return (_getRequireWildcardCache = function(nodeInterop) {\n        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n    })(nodeInterop);\n}\nfunction _interop_require_wildcard(obj, nodeInterop) {\n    if (!nodeInterop && obj && obj.__esModule) {\n        return obj;\n    }\n    if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n        return {\n            default: obj\n        };\n    }\n    var cache = _getRequireWildcardCache(nodeInterop);\n    if (cache && cache.has(obj)) {\n        return cache.get(obj);\n    }\n    var newObj = {\n        __proto__: null\n    };\n    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n    for(var key in obj){\n        if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n            if (desc && (desc.get || desc.set)) {\n                Object.defineProperty(newObj, key, desc);\n            } else {\n                newObj[key] = obj[key];\n            }\n        }\n    }\n    newObj.default = obj;\n    if (cache) {\n        cache.set(obj, newObj);\n    }\n    return newObj;\n}\nclass NextWebServer extends _baseserver.default {\n    constructor(options){\n        super(options), this.handleCatchallRenderRequest = async (req, res, parsedUrl)=>{\n            let { pathname, query } = parsedUrl;\n            if (!pathname) {\n                throw Object.defineProperty(new Error('pathname is undefined'), \"__NEXT_ERROR_CODE\", {\n                    value: \"E408\",\n                    enumerable: false,\n                    configurable: true\n                });\n            }\n            // interpolate query information into page for dynamic route\n            // so that rewritten paths are handled properly\n            const normalizedPage = this.serverOptions.webServerConfig.pathname;\n            if (pathname !== normalizedPage) {\n                pathname = normalizedPage;\n                if ((0, _utils.isDynamicRoute)(pathname)) {\n                    const routeRegex = (0, _routeregex.getNamedRouteRegex)(pathname, {\n                        prefixRouteKeys: false\n                    });\n                    const dynamicRouteMatcher = (0, _routematcher.getRouteMatcher)(routeRegex);\n                    const defaultRouteMatches = dynamicRouteMatcher(pathname);\n                    const paramsResult = (0, _serverutils.normalizeDynamicRouteParams)(query, routeRegex, defaultRouteMatches, false);\n                    const normalizedParams = paramsResult.hasValidParams ? paramsResult.params : query;\n                    pathname = (0, _serverutils.interpolateDynamicPath)(pathname, normalizedParams, routeRegex);\n                    (0, _serverutils.normalizeVercelUrl)(req, Object.keys(routeRegex.routeKeys), routeRegex);\n                }\n            }\n            // next.js core assumes page path without trailing slash\n            pathname = (0, _removetrailingslash.removeTrailingSlash)(pathname);\n            if (this.i18nProvider) {\n                const { detectedLocale } = await this.i18nProvider.analyze(pathname);\n                if (detectedLocale) {\n                    (0, _requestmeta.addRequestMeta)(req, 'locale', detectedLocale);\n                }\n            }\n            const bubbleNoFallback = (0, _requestmeta.getRequestMeta)(req, 'bubbleNoFallback');\n            try {\n                await this.render(req, res, pathname, query, parsedUrl, true);\n                return true;\n            } catch (err) {\n                if (err instanceof _baseserver.NoFallbackError && bubbleNoFallback) {\n                    return false;\n                }\n                throw err;\n            }\n        };\n        // Extend `renderOpts`.\n        Object.assign(this.renderOpts, options.webServerConfig.extendRenderOpts);\n    }\n    async getIncrementalCache({ requestHeaders }) {\n        const dev = !!this.renderOpts.dev;\n        // incremental-cache is request specific\n        // although can have shared caches in module scope\n        // per-cache handler\n        return new _incrementalcache.IncrementalCache({\n            dev,\n            requestHeaders,\n            requestProtocol: 'https',\n            allowedRevalidateHeaderKeys: this.nextConfig.experimental.allowedRevalidateHeaderKeys,\n            minimalMode: this.minimalMode,\n            fetchCacheKeyPrefix: this.nextConfig.experimental.fetchCacheKeyPrefix,\n            maxMemoryCacheSize: this.nextConfig.cacheMaxMemorySize,\n            flushToDisk: false,\n            CurCacheHandler: this.serverOptions.webServerConfig.incrementalCacheHandler,\n            getPrerenderManifest: ()=>this.getPrerenderManifest()\n        });\n    }\n    getResponseCache() {\n        return new _web1.default(this.minimalMode);\n    }\n    async hasPage(page) {\n        return page === this.serverOptions.webServerConfig.page;\n    }\n    getBuildId() {\n        return this.serverOptions.buildId;\n    }\n    getEnabledDirectories() {\n        return {\n            app: this.serverOptions.webServerConfig.pagesType === 'app',\n            pages: this.serverOptions.webServerConfig.pagesType === 'pages'\n        };\n    }\n    getPagesManifest() {\n        return {\n            // keep same theme but server path doesn't need to be accurate\n            [this.serverOptions.webServerConfig.pathname]: `server${this.serverOptions.webServerConfig.page}.js`\n        };\n    }\n    getAppPathsManifest() {\n        const page = this.serverOptions.webServerConfig.page;\n        return {\n            [this.serverOptions.webServerConfig.page]: `app${page}.js`\n        };\n    }\n    attachRequestMeta(req, parsedUrl) {\n        (0, _requestmeta.addRequestMeta)(req, 'initQuery', {\n            ...parsedUrl.query\n        });\n    }\n    getPrerenderManifest() {\n        return {\n            version: -1,\n            routes: {},\n            dynamicRoutes: {},\n            notFoundRoutes: [],\n            preview: (0, _getedgepreviewprops.getEdgePreviewProps)()\n        };\n    }\n    getNextFontManifest() {\n        return this.serverOptions.webServerConfig.extendRenderOpts.nextFontManifest;\n    }\n    renderHTML(req, res, pathname, query, renderOpts) {\n        const { renderToHTML } = this.serverOptions.webServerConfig;\n        if (!renderToHTML) {\n            throw Object.defineProperty(new Error('Invariant: routeModule should be configured when rendering pages'), \"__NEXT_ERROR_CODE\", {\n                value: \"E4\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n        // For edge runtime if the pathname hit as /_not-found entrypoint,\n        // override the pathname to /404 for rendering\n        if (pathname === _constants.UNDERSCORE_NOT_FOUND_ROUTE) {\n            pathname = '/404';\n        }\n        return renderToHTML(req, res, pathname, query, // Edge runtime does not support ISR/PPR, so we don't need to pass in\n        // the unknown params.\n        null, Object.assign(renderOpts, {\n            disableOptimizedLoading: true,\n            runtime: 'experimental-edge'\n        }), undefined, false, {\n            buildId: this.serverOptions.buildId\n        });\n    }\n    async sendRenderResult(_req, res, options) {\n        res.setHeader('X-Edge-Runtime', '1');\n        // Add necessary headers.\n        // @TODO: Share the isomorphic logic with server/send-payload.ts.\n        if (options.poweredByHeader && options.type === 'html') {\n            res.setHeader('X-Powered-By', 'Next.js');\n        }\n        if (!res.getHeader('Content-Type')) {\n            res.setHeader('Content-Type', options.result.contentType ? options.result.contentType : options.type === 'json' ? 'application/json' : 'text/html; charset=utf-8');\n        }\n        let promise;\n        if (options.result.isDynamic) {\n            promise = options.result.pipeTo(res.transformStream.writable);\n        } else {\n            const payload = options.result.toUnchunkedString();\n            res.setHeader('Content-Length', String((0, _web.byteLength)(payload)));\n            if (options.generateEtags) {\n                res.setHeader('ETag', (0, _etag.generateETag)(payload));\n            }\n            res.body(payload);\n        }\n        res.send();\n        // If we have a promise, wait for it to resolve.\n        if (promise) await promise;\n    }\n    async findPageComponents({ page, query, params, url: _url }) {\n        const result = await this.serverOptions.webServerConfig.loadComponent(page);\n        if (!result) return null;\n        return {\n            query: {\n                ...query || {},\n                ...params || {}\n            },\n            components: result\n        };\n    }\n    // Below are methods that are not implemented by the web server as they are\n    // handled by the upstream proxy (edge runtime or node server).\n    async runApi() {\n        // This web server does not need to handle API requests.\n        return true;\n    }\n    async handleApiRequest() {\n        // Edge API requests are handled separately in minimal mode.\n        return false;\n    }\n    loadEnvConfig() {\n    // The web server does not need to load the env config. This is done by the\n    // runtime already.\n    }\n    getPublicDir() {\n        // Public files are not handled by the web server.\n        return '';\n    }\n    getHasStaticDir() {\n        return false;\n    }\n    getFontManifest() {\n        return undefined;\n    }\n    handleCompression() {\n    // For the web server layer, compression is automatically handled by the\n    // upstream proxy (edge runtime or node server) and we can simply skip here.\n    }\n    async handleUpgrade() {\n    // The web server does not support web sockets.\n    }\n    async getFallbackErrorComponents(_url) {\n        // The web server does not need to handle fallback errors in production.\n        return null;\n    }\n    getRoutesManifest() {\n        // The web server does not need to handle rewrite rules. This is done by the\n        // upstream proxy (edge runtime or node server).\n        return undefined;\n    }\n    getMiddleware() {\n        // The web server does not need to handle middleware. This is done by the\n        // upstream proxy (edge runtime or node server).\n        return Promise.resolve(undefined);\n    }\n    getFilesystemPaths() {\n        return new Set();\n    }\n    getinterceptionRoutePatterns() {\n        var _this_serverOptions_webServerConfig_interceptionRouteRewrites;\n        return ((_this_serverOptions_webServerConfig_interceptionRouteRewrites = this.serverOptions.webServerConfig.interceptionRouteRewrites) == null ? void 0 : _this_serverOptions_webServerConfig_interceptionRouteRewrites.map((rewrite)=>new RegExp((0, _buildcustomroute.buildCustomRoute)('rewrite', rewrite).regex))) ?? [];\n    }\n    async loadInstrumentationModule() {\n        return await (0, _globals.getEdgeInstrumentationModule)();\n    }\n    async instrumentationOnRequestError(...args) {\n        await super.instrumentationOnRequestError(...args);\n        const err = args[0];\n        if (process.env.NODE_ENV !== 'production' && typeof __next_log_error__ === 'function') {\n            __next_log_error__(err);\n        } else {\n            console.error(err);\n        }\n    }\n}\n\n//# sourceMappingURL=web-server.js.map"
        }
    ]
}