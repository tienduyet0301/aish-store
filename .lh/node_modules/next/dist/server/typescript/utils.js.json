{
    "sourceFile": "node_modules/next/dist/server/typescript/utils.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892893342,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    getEntryInfo: null,\n    getInfo: null,\n    getSource: null,\n    getSourceFromVirtualTsEnv: null,\n    getTs: null,\n    getTypeChecker: null,\n    init: null,\n    isAppEntryFile: null,\n    isDefaultFunctionExport: null,\n    isInsideApp: null,\n    isPageFile: null,\n    isPositionInsideNode: null,\n    log: null,\n    removeStringQuotes: null,\n    virtualTsEnv: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    getEntryInfo: function() {\n        return getEntryInfo;\n    },\n    getInfo: function() {\n        return getInfo;\n    },\n    getSource: function() {\n        return getSource;\n    },\n    getSourceFromVirtualTsEnv: function() {\n        return getSourceFromVirtualTsEnv;\n    },\n    getTs: function() {\n        return getTs;\n    },\n    getTypeChecker: function() {\n        return getTypeChecker;\n    },\n    init: function() {\n        return init;\n    },\n    isAppEntryFile: function() {\n        return isAppEntryFile;\n    },\n    isDefaultFunctionExport: function() {\n        return isDefaultFunctionExport;\n    },\n    isInsideApp: function() {\n        return isInsideApp;\n    },\n    isPageFile: function() {\n        return isPageFile;\n    },\n    isPositionInsideNode: function() {\n        return isPositionInsideNode;\n    },\n    log: function() {\n        return log;\n    },\n    removeStringQuotes: function() {\n        return removeStringQuotes;\n    },\n    virtualTsEnv: function() {\n        return virtualTsEnv;\n    }\n});\nconst _vfs = require(\"next/dist/compiled/@typescript/vfs\");\nconst _path = /*#__PURE__*/ _interop_require_wildcard(require(\"path\"));\nfunction _getRequireWildcardCache(nodeInterop) {\n    if (typeof WeakMap !== \"function\") return null;\n    var cacheBabelInterop = new WeakMap();\n    var cacheNodeInterop = new WeakMap();\n    return (_getRequireWildcardCache = function(nodeInterop) {\n        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n    })(nodeInterop);\n}\nfunction _interop_require_wildcard(obj, nodeInterop) {\n    if (!nodeInterop && obj && obj.__esModule) {\n        return obj;\n    }\n    if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n        return {\n            default: obj\n        };\n    }\n    var cache = _getRequireWildcardCache(nodeInterop);\n    if (cache && cache.has(obj)) {\n        return cache.get(obj);\n    }\n    var newObj = {\n        __proto__: null\n    };\n    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n    for(var key in obj){\n        if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n            if (desc && (desc.get || desc.set)) {\n                Object.defineProperty(newObj, key, desc);\n            } else {\n                newObj[key] = obj[key];\n            }\n        }\n    }\n    newObj.default = obj;\n    if (cache) {\n        cache.set(obj, newObj);\n    }\n    return newObj;\n}\nlet ts;\nlet info;\nlet appDirRegExp;\nlet virtualTsEnv;\nfunction log(message) {\n    info.project.projectService.logger.info('[next] ' + message);\n}\nfunction init(opts) {\n    const projectDir = opts.info.project.getCurrentDirectory();\n    ts = opts.ts;\n    info = opts.info;\n    appDirRegExp = new RegExp('^' + (projectDir + '(/src)?/app').replace(/[\\\\/]/g, '[\\\\/]'));\n    log('Initializing Next.js TypeScript plugin: ' + projectDir);\n    const compilerOptions = info.project.getCompilerOptions();\n    const fsMap = (0, _vfs.createDefaultMapFromNodeModules)(compilerOptions, ts, (0, _path.join)(projectDir, 'node_modules/typescript/lib'));\n    const system = (0, _vfs.createFSBackedSystem)(fsMap, projectDir, ts);\n    virtualTsEnv = (0, _vfs.createVirtualTypeScriptEnvironment)(system, [], ts, compilerOptions);\n    if (!virtualTsEnv) {\n        log('Failed to create virtual TypeScript environment. This is a bug in Next.js TypeScript plugin. Please report it by opening an issue at https://github.com/vercel/next.js/issues.');\n        return false;\n    }\n    log('Successfully initialized Next.js TypeScript plugin!');\n    return true;\n}\nfunction getTs() {\n    return ts;\n}\nfunction getInfo() {\n    return info;\n}\nfunction getTypeChecker() {\n    var _info_languageService_getProgram;\n    return (_info_languageService_getProgram = info.languageService.getProgram()) == null ? void 0 : _info_languageService_getProgram.getTypeChecker();\n}\nfunction getSource(fileName) {\n    var _info_languageService_getProgram;\n    return (_info_languageService_getProgram = info.languageService.getProgram()) == null ? void 0 : _info_languageService_getProgram.getSourceFile(fileName);\n}\nfunction getSourceFromVirtualTsEnv(fileName) {\n    if (virtualTsEnv.sys.fileExists(fileName)) {\n        return virtualTsEnv.getSourceFile(fileName);\n    }\n    return getSource(fileName);\n}\nfunction removeStringQuotes(str) {\n    return str.replace(/^['\"`]|['\"`]$/g, '');\n}\nconst isPositionInsideNode = (position, node)=>{\n    const start = node.getFullStart();\n    return start <= position && position <= node.getFullWidth() + start;\n};\nconst isDefaultFunctionExport = (node)=>{\n    if (ts.isFunctionDeclaration(node)) {\n        let hasExportKeyword = false;\n        let hasDefaultKeyword = false;\n        if (node.modifiers) {\n            for (const modifier of node.modifiers){\n                if (modifier.kind === ts.SyntaxKind.ExportKeyword) {\n                    hasExportKeyword = true;\n                } else if (modifier.kind === ts.SyntaxKind.DefaultKeyword) {\n                    hasDefaultKeyword = true;\n                }\n            }\n        }\n        // `export default function`\n        if (hasExportKeyword && hasDefaultKeyword) {\n            return true;\n        }\n    }\n    return false;\n};\nconst isInsideApp = (filePath)=>{\n    return appDirRegExp.test(filePath);\n};\nconst isAppEntryFile = (filePath)=>{\n    return appDirRegExp.test(filePath) && /^(page|layout)\\.(mjs|js|jsx|ts|tsx)$/.test(_path.default.basename(filePath));\n};\nconst isPageFile = (filePath)=>{\n    return appDirRegExp.test(filePath) && /^page\\.(mjs|js|jsx|ts|tsx)$/.test(_path.default.basename(filePath));\n};\nfunction getEntryInfo(fileName, throwOnInvalidDirective) {\n    const source = getSource(fileName);\n    if (source) {\n        let isDirective = true;\n        let isClientEntry = false;\n        let isServerEntry = false;\n        ts.forEachChild(source, (node)=>{\n            if (ts.isExpressionStatement(node) && ts.isStringLiteral(node.expression)) {\n                if (node.expression.text === 'use client') {\n                    if (isDirective) {\n                        isClientEntry = true;\n                    } else {\n                        if (throwOnInvalidDirective) {\n                            const e = {\n                                messageText: 'The `\"use client\"` directive must be put at the top of the file.',\n                                start: node.expression.getStart(),\n                                length: node.expression.getWidth()\n                            };\n                            throw e;\n                        }\n                    }\n                } else if (node.expression.text === 'use server') {\n                    if (isDirective) {\n                        isServerEntry = true;\n                    } else {\n                        if (throwOnInvalidDirective) {\n                            const e = {\n                                messageText: 'The `\"use server\"` directive must be put at the top of the file.',\n                                start: node.expression.getStart(),\n                                length: node.expression.getWidth()\n                            };\n                            throw e;\n                        }\n                    }\n                }\n                if (isClientEntry && isServerEntry) {\n                    const e = {\n                        messageText: 'Cannot use both \"use client\" and \"use server\" directives in the same file.',\n                        start: node.expression.getStart(),\n                        length: node.expression.getWidth()\n                    };\n                    throw e;\n                }\n            } else {\n                isDirective = false;\n            }\n        });\n        return {\n            client: isClientEntry,\n            server: isServerEntry\n        };\n    }\n    return {\n        client: false,\n        server: false\n    };\n}\n\n//# sourceMappingURL=utils.js.map"
        }
    ]
}