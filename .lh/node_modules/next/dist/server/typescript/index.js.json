{
    "sourceFile": "node_modules/next/dist/server/typescript/index.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892891222,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * This is a TypeScript language service plugin for Next.js app directory,\n * it provides the following features:\n *\n * - Warns about disallowed React APIs in server components.\n * - Warns about disallowed layout and page exports.\n * - Autocompletion for entry configurations.\n * - Hover hint and docs for entry configurations.\n */ \"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"createTSPlugin\", {\n    enumerable: true,\n    get: function() {\n        return createTSPlugin;\n    }\n});\nconst _utils = require(\"./utils\");\nconst _constant = require(\"./constant\");\nconst _config = /*#__PURE__*/ _interop_require_default(require(\"./rules/config\"));\nconst _server = /*#__PURE__*/ _interop_require_default(require(\"./rules/server\"));\nconst _entry = /*#__PURE__*/ _interop_require_default(require(\"./rules/entry\"));\nconst _clientboundary = /*#__PURE__*/ _interop_require_default(require(\"./rules/client-boundary\"));\nconst _serverboundary = /*#__PURE__*/ _interop_require_default(require(\"./rules/server-boundary\"));\nconst _metadata = /*#__PURE__*/ _interop_require_default(require(\"./rules/metadata\"));\nconst _error = /*#__PURE__*/ _interop_require_default(require(\"./rules/error\"));\nfunction _interop_require_default(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nconst createTSPlugin = ({ typescript: ts })=>{\n    function create(info) {\n        // Get plugin options\n        // config is the plugin options from the user's tsconfig.json\n        // e.g. { \"plugins\": [{ \"name\": \"next\", \"enabled\": true }] }\n        // config will be { \"name\": \"next\", \"enabled\": true }\n        // The default user config is { \"name\": \"next\" }\n        const isPluginEnabled = info.config.enabled ?? true;\n        const isPluginInitialized = (0, _utils.init)({\n            ts,\n            info\n        });\n        if (!isPluginEnabled || !isPluginInitialized) {\n            return info.languageService;\n        }\n        // Set up decorator object\n        const proxy = Object.create(null);\n        for (let k of Object.keys(info.languageService)){\n            const x = info.languageService[k];\n            // @ts-expect-error - JS runtime trickery which is tricky to type tersely\n            proxy[k] = (...args)=>x.apply(info.languageService, args);\n        }\n        // Auto completion\n        proxy.getCompletionsAtPosition = (fileName, position, options)=>{\n            let prior = info.languageService.getCompletionsAtPosition(fileName, position, options) || {\n                isGlobalCompletion: false,\n                isMemberCompletion: false,\n                isNewIdentifierLocation: false,\n                entries: []\n            };\n            if (!(0, _utils.isAppEntryFile)(fileName)) return prior;\n            // If it's a server entry.\n            const entryInfo = (0, _utils.getEntryInfo)(fileName);\n            if (!entryInfo.client) {\n                // Remove specified entries from completion list\n                prior.entries = _server.default.filterCompletionsAtPosition(prior.entries);\n                // Provide autocompletion for metadata fields\n                prior = _metadata.default.filterCompletionsAtPosition(fileName, position, options, prior);\n            }\n            // Add auto completions for export configs.\n            _config.default.addCompletionsAtPosition(fileName, position, prior);\n            const source = (0, _utils.getSource)(fileName);\n            if (!source) return prior;\n            ts.forEachChild(source, (node)=>{\n                // Auto completion for default export function's props.\n                if ((0, _utils.isPositionInsideNode)(position, node) && (0, _utils.isDefaultFunctionExport)(node)) {\n                    prior.entries.push(..._entry.default.getCompletionsAtPosition(fileName, node, position));\n                }\n            });\n            return prior;\n        };\n        // Show auto completion details\n        proxy.getCompletionEntryDetails = (fileName, position, entryName, formatOptions, source, preferences, data)=>{\n            const entryCompletionEntryDetails = _config.default.getCompletionEntryDetails(entryName, data);\n            if (entryCompletionEntryDetails) return entryCompletionEntryDetails;\n            const metadataCompletionEntryDetails = _metadata.default.getCompletionEntryDetails(fileName, position, entryName, formatOptions, source, preferences, data);\n            if (metadataCompletionEntryDetails) return metadataCompletionEntryDetails;\n            return info.languageService.getCompletionEntryDetails(fileName, position, entryName, formatOptions, source, preferences, data);\n        };\n        // Quick info\n        proxy.getQuickInfoAtPosition = (fileName, position)=>{\n            const prior = info.languageService.getQuickInfoAtPosition(fileName, position);\n            if (!(0, _utils.isAppEntryFile)(fileName)) return prior;\n            // Remove type suggestions for disallowed APIs in server components.\n            const entryInfo = (0, _utils.getEntryInfo)(fileName);\n            if (!entryInfo.client) {\n                const definitions = info.languageService.getDefinitionAtPosition(fileName, position);\n                if (definitions && _server.default.hasDisallowedReactAPIDefinition(definitions)) {\n                    return;\n                }\n                const metadataInfo = _metadata.default.getQuickInfoAtPosition(fileName, position);\n                if (metadataInfo) return metadataInfo;\n            }\n            const overridden = _config.default.getQuickInfoAtPosition(fileName, position);\n            if (overridden) return overridden;\n            return prior;\n        };\n        // Show errors for disallowed imports\n        proxy.getSemanticDiagnostics = (fileName)=>{\n            const prior = info.languageService.getSemanticDiagnostics(fileName);\n            const source = (0, _utils.getSource)(fileName);\n            if (!source) return prior;\n            let isClientEntry = false;\n            let isServerEntry = false;\n            const isAppEntry = (0, _utils.isAppEntryFile)(fileName);\n            try {\n                const entryInfo = (0, _utils.getEntryInfo)(fileName, true);\n                isClientEntry = entryInfo.client;\n                isServerEntry = entryInfo.server;\n            } catch (e) {\n                prior.push({\n                    file: source,\n                    category: ts.DiagnosticCategory.Error,\n                    code: _constant.NEXT_TS_ERRORS.MISPLACED_ENTRY_DIRECTIVE,\n                    ...e\n                });\n                isClientEntry = false;\n                isServerEntry = false;\n            }\n            if ((0, _utils.isInsideApp)(fileName)) {\n                const errorDiagnostic = _error.default.getSemanticDiagnostics(source, isClientEntry);\n                prior.push(...errorDiagnostic);\n            }\n            ts.forEachChild(source, (node)=>{\n                var _node_modifiers, _node_modifiers1;\n                if (ts.isImportDeclaration(node)) {\n                    // import ...\n                    if (isAppEntry) {\n                        if (!isClientEntry || isServerEntry) {\n                            // Check if it has valid imports in the server layer\n                            const diagnostics = _server.default.getSemanticDiagnosticsForImportDeclaration(source, node);\n                            prior.push(...diagnostics);\n                        }\n                    }\n                } else if (ts.isVariableStatement(node) && ((_node_modifiers = node.modifiers) == null ? void 0 : _node_modifiers.some((m)=>m.kind === ts.SyntaxKind.ExportKeyword))) {\n                    // export const ...\n                    if (isAppEntry) {\n                        // Check if it has correct option exports\n                        const diagnostics = _config.default.getSemanticDiagnosticsForExportVariableStatement(source, node);\n                        const metadataDiagnostics = isClientEntry ? _metadata.default.getSemanticDiagnosticsForExportVariableStatementInClientEntry(fileName, node) : _metadata.default.getSemanticDiagnosticsForExportVariableStatement(fileName, node);\n                        prior.push(...diagnostics, ...metadataDiagnostics);\n                    }\n                    if (isClientEntry) {\n                        prior.push(..._clientboundary.default.getSemanticDiagnosticsForExportVariableStatement(source, node));\n                    }\n                    if (isServerEntry) {\n                        prior.push(..._serverboundary.default.getSemanticDiagnosticsForExportVariableStatement(source, node));\n                    }\n                } else if ((0, _utils.isDefaultFunctionExport)(node)) {\n                    // export default function ...\n                    if (isAppEntry) {\n                        const diagnostics = _entry.default.getSemanticDiagnostics(fileName, source, node);\n                        prior.push(...diagnostics);\n                    }\n                    if (isClientEntry) {\n                        prior.push(..._clientboundary.default.getSemanticDiagnosticsForFunctionExport(source, node));\n                    }\n                    if (isServerEntry) {\n                        prior.push(..._serverboundary.default.getSemanticDiagnosticsForFunctionExport(source, node));\n                    }\n                } else if (ts.isFunctionDeclaration(node) && ((_node_modifiers1 = node.modifiers) == null ? void 0 : _node_modifiers1.some((m)=>m.kind === ts.SyntaxKind.ExportKeyword))) {\n                    // export function ...\n                    if (isAppEntry) {\n                        const metadataDiagnostics = isClientEntry ? _metadata.default.getSemanticDiagnosticsForExportVariableStatementInClientEntry(fileName, node) : _metadata.default.getSemanticDiagnosticsForExportVariableStatement(fileName, node);\n                        prior.push(...metadataDiagnostics);\n                    }\n                    if (isClientEntry) {\n                        prior.push(..._clientboundary.default.getSemanticDiagnosticsForFunctionExport(source, node));\n                    }\n                    if (isServerEntry) {\n                        prior.push(..._serverboundary.default.getSemanticDiagnosticsForFunctionExport(source, node));\n                    }\n                } else if (ts.isExportDeclaration(node)) {\n                    // export { ... }\n                    if (isAppEntry) {\n                        const metadataDiagnostics = isClientEntry ? _metadata.default.getSemanticDiagnosticsForExportDeclarationInClientEntry(fileName, node) : _metadata.default.getSemanticDiagnosticsForExportDeclaration(fileName, node);\n                        prior.push(...metadataDiagnostics);\n                    }\n                    if (isServerEntry) {\n                        prior.push(..._serverboundary.default.getSemanticDiagnosticsForExportDeclaration(source, node));\n                    }\n                }\n            });\n            return prior;\n        };\n        // Get definition and link for specific node\n        proxy.getDefinitionAndBoundSpan = (fileName, position)=>{\n            const entryInfo = (0, _utils.getEntryInfo)(fileName);\n            if ((0, _utils.isAppEntryFile)(fileName) && !entryInfo.client) {\n                const metadataDefinition = _metadata.default.getDefinitionAndBoundSpan(fileName, position);\n                if (metadataDefinition) return metadataDefinition;\n            }\n            return info.languageService.getDefinitionAndBoundSpan(fileName, position);\n        };\n        return proxy;\n    }\n    return {\n        create\n    };\n};\n\n//# sourceMappingURL=index.js.map"
        }
    ]
}