{
    "sourceFile": "node_modules/next/dist/server/typescript/rules/client-boundary.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892891303,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "// This module provides intellisense for all components that has the `\"use client\"` directive.\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"default\", {\n    enumerable: true,\n    get: function() {\n        return _default;\n    }\n});\nconst _constant = require(\"../constant\");\nconst _utils = require(\"../utils\");\nconst clientBoundary = {\n    getSemanticDiagnosticsForExportVariableStatement (source, node) {\n        const ts = (0, _utils.getTs)();\n        const diagnostics = [];\n        if (ts.isVariableDeclarationList(node.declarationList)) {\n            for (const declaration of node.declarationList.declarations){\n                const initializer = declaration.initializer;\n                if (initializer && ts.isArrowFunction(initializer)) {\n                    diagnostics.push(...clientBoundary.getSemanticDiagnosticsForFunctionExport(source, initializer));\n                }\n            }\n        }\n        return diagnostics;\n    },\n    getSemanticDiagnosticsForFunctionExport (source, node) {\n        var _node_parameters_, _node_parameters;\n        const ts = (0, _utils.getTs)();\n        const typeChecker = (0, _utils.getTypeChecker)();\n        if (!typeChecker) return [];\n        const diagnostics = [];\n        const isErrorFile = /[\\\\/]error\\.tsx?$/.test(source.fileName);\n        const isGlobalErrorFile = /[\\\\/]global-error\\.tsx?$/.test(source.fileName);\n        const props = (_node_parameters = node.parameters) == null ? void 0 : (_node_parameters_ = _node_parameters[0]) == null ? void 0 : _node_parameters_.name;\n        if (props && ts.isObjectBindingPattern(props)) {\n            for (const prop of props.elements){\n                var _type_symbol_getDeclarations, _type_symbol;\n                const type = typeChecker.getTypeAtLocation(prop);\n                const typeDeclarationNode = (_type_symbol = type.symbol) == null ? void 0 : (_type_symbol_getDeclarations = _type_symbol.getDeclarations()) == null ? void 0 : _type_symbol_getDeclarations[0];\n                const propName = (prop.propertyName || prop.name).getText();\n                if (typeDeclarationNode) {\n                    if (ts.isFunctionTypeNode(typeDeclarationNode)) {\n                        // By convention, props named \"action\" can accept functions since we\n                        // assume these are Server Actions. Structurally, there's no\n                        // difference between a Server Action and a normal function until\n                        // TypeScript exposes directives in the type of a function. This\n                        // will miss accidentally passing normal functions but a false\n                        // negative is better than a false positive given how frequent the\n                        // false-positive would be.\n                        const maybeServerAction = propName === 'action' || /.+Action$/.test(propName);\n                        // There's a special case for the error file that the `reset` prop\n                        // is allowed to be a function:\n                        // https://github.com/vercel/next.js/issues/46573\n                        const isErrorReset = (isErrorFile || isGlobalErrorFile) && propName === 'reset';\n                        if (!maybeServerAction && !isErrorReset) {\n                            diagnostics.push({\n                                file: source,\n                                category: ts.DiagnosticCategory.Warning,\n                                code: _constant.NEXT_TS_ERRORS.INVALID_CLIENT_ENTRY_PROP,\n                                messageText: `Props must be serializable for components in the \"use client\" entry file. ` + `\"${propName}\" is a function that's not a Server Action. ` + `Rename \"${propName}\" either to \"action\" or have its name end with \"Action\" e.g. \"${propName}Action\" to indicate it is a Server Action.`,\n                                start: prop.getStart(),\n                                length: prop.getWidth()\n                            });\n                        }\n                    } else if (// Show warning for not serializable props.\n                    ts.isConstructorTypeNode(typeDeclarationNode) || ts.isClassDeclaration(typeDeclarationNode)) {\n                        diagnostics.push({\n                            file: source,\n                            category: ts.DiagnosticCategory.Warning,\n                            code: _constant.NEXT_TS_ERRORS.INVALID_CLIENT_ENTRY_PROP,\n                            messageText: `Props must be serializable for components in the \"use client\" entry file, \"${propName}\" is invalid.`,\n                            start: prop.getStart(),\n                            length: prop.getWidth()\n                        });\n                    }\n                }\n            }\n        }\n        return diagnostics;\n    }\n};\nconst _default = clientBoundary;\n\n//# sourceMappingURL=client-boundary.js.map"
        }
    ]
}