{
    "sourceFile": "node_modules/next/dist/server/web/spec-extension/adapters/next-request.d.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892896521,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import type { BaseNextRequest } from '../../../base-http';\nimport type { NodeNextRequest } from '../../../base-http/node';\nimport type { WebNextRequest } from '../../../base-http/web';\nimport type { Writable } from 'node:stream';\nimport { NextRequest } from '../request';\nexport declare const ResponseAbortedName = \"ResponseAborted\";\nexport declare class ResponseAborted extends Error {\n    readonly name = \"ResponseAborted\";\n}\n/**\n * Creates an AbortController tied to the closing of a ServerResponse (or other\n * appropriate Writable).\n *\n * If the `close` event is fired before the `finish` event, then we'll send the\n * `abort` signal.\n */\nexport declare function createAbortController(response: Writable): AbortController;\n/**\n * Creates an AbortSignal tied to the closing of a ServerResponse (or other\n * appropriate Writable).\n *\n * This cannot be done with the request (IncomingMessage or Readable) because\n * the `abort` event will not fire if to data has been fully read (because that\n * will \"close\" the readable stream and nothing fires after that).\n */\nexport declare function signalFromNodeResponse(response: Writable): AbortSignal;\nexport declare class NextRequestAdapter {\n    static fromBaseNextRequest(request: BaseNextRequest, signal: AbortSignal): NextRequest;\n    static fromNodeNextRequest(request: NodeNextRequest, signal: AbortSignal): NextRequest;\n    static fromWebNextRequest(request: WebNextRequest): NextRequest;\n}\n"
        }
    ]
}