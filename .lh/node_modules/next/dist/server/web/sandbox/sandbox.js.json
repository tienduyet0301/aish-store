{
    "sourceFile": "node_modules/next/dist/server/web/sandbox/sandbox.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892896399,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    ErrorSource: null,\n    getRuntimeContext: null,\n    run: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    ErrorSource: function() {\n        return ErrorSource;\n    },\n    getRuntimeContext: function() {\n        return getRuntimeContext;\n    },\n    run: function() {\n        return run;\n    }\n});\nconst _context = require(\"./context\");\nconst _bodystreams = require(\"../../body-streams\");\nconst _approuterheaders = require(\"../../../client/components/app-router-headers\");\nconst _builtinrequestcontext = require(\"../../after/builtin-request-context\");\nconst ErrorSource = Symbol('SandboxError');\nconst FORBIDDEN_HEADERS = [\n    'content-length',\n    'content-encoding',\n    'transfer-encoding'\n];\n/**\n * Decorates the runner function making sure all errors it can produce are\n * tagged with `edge-server` so they can properly be rendered in dev.\n */ function withTaggedErrors(fn) {\n    if (process.env.NODE_ENV === 'development') {\n        const { getServerError } = require('../../../client/components/react-dev-overlay/server/middleware-webpack');\n        return (params)=>fn(params).then((result)=>{\n                var _result_waitUntil;\n                return {\n                    ...result,\n                    waitUntil: result == null ? void 0 : (_result_waitUntil = result.waitUntil) == null ? void 0 : _result_waitUntil.catch((error)=>{\n                        // TODO: used COMPILER_NAMES.edgeServer instead. Verify that it does not increase the runtime size.\n                        throw getServerError(error, 'edge-server');\n                    })\n                };\n            }).catch((error)=>{\n                // TODO: used COMPILER_NAMES.edgeServer instead\n                throw getServerError(error, 'edge-server');\n            });\n    }\n    return fn;\n}\nasync function getRuntimeContext(params) {\n    const { runtime, evaluateInContext } = await (0, _context.getModuleContext)({\n        moduleName: params.name,\n        onWarning: params.onWarning ?? (()=>{}),\n        onError: params.onError ?? (()=>{}),\n        useCache: params.useCache !== false,\n        edgeFunctionEntry: params.edgeFunctionEntry,\n        distDir: params.distDir\n    });\n    if (params.incrementalCache) {\n        runtime.context.globalThis.__incrementalCache = params.incrementalCache;\n    }\n    if (params.serverComponentsHmrCache) {\n        runtime.context.globalThis.__serverComponentsHmrCache = params.serverComponentsHmrCache;\n    }\n    for (const paramPath of params.paths){\n        evaluateInContext(paramPath);\n    }\n    return runtime;\n}\nconst run = withTaggedErrors(async function runWithTaggedErrors(params) {\n    var _params_request_body;\n    const runtime = await getRuntimeContext(params);\n    const edgeFunction = (await runtime.context._ENTRIES[`middleware_${params.name}`]).default;\n    const cloned = ![\n        'HEAD',\n        'GET'\n    ].includes(params.request.method) ? (_params_request_body = params.request.body) == null ? void 0 : _params_request_body.cloneBodyStream() : undefined;\n    const KUint8Array = runtime.evaluate('Uint8Array');\n    const urlInstance = new URL(params.request.url);\n    urlInstance.searchParams.delete(_approuterheaders.NEXT_RSC_UNION_QUERY);\n    params.request.url = urlInstance.toString();\n    const headers = new Headers();\n    for (const [key, value] of Object.entries(params.request.headers)){\n        headers.set(key, (value == null ? void 0 : value.toString()) ?? '');\n    }\n    try {\n        let result = undefined;\n        const builtinRequestCtx = {\n            ...(0, _builtinrequestcontext.getBuiltinRequestContext)(),\n            // FIXME(after):\n            // arguably, this is an abuse of \"@next/request-context\" --\n            // it'd make more sense to simply forward its existing value into the sandbox (in `createModuleContext`)\n            // but here we're using it to just pass in `waitUntil` regardless if we were running in this context or not.\n            waitUntil: params.request.waitUntil\n        };\n        await _context.edgeSandboxNextRequestContext.run(builtinRequestCtx, ()=>_context.requestStore.run({\n                headers\n            }, async ()=>{\n                result = await edgeFunction({\n                    request: {\n                        ...params.request,\n                        body: cloned && (0, _bodystreams.requestToBodyStream)(runtime.context, KUint8Array, cloned)\n                    }\n                });\n                for (const headerName of FORBIDDEN_HEADERS){\n                    result.response.headers.delete(headerName);\n                }\n            }));\n        if (!result) throw Object.defineProperty(new Error('Edge function did not return a response'), \"__NEXT_ERROR_CODE\", {\n            value: \"E332\",\n            enumerable: false,\n            configurable: true\n        });\n        return result;\n    } finally{\n        var _params_request_body1;\n        await ((_params_request_body1 = params.request.body) == null ? void 0 : _params_request_body1.finalize());\n    }\n});\n\n//# sourceMappingURL=sandbox.js.map"
        }
    ]
}