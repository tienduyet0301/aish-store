{
    "sourceFile": "node_modules/next/dist/server/load-components.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892878440,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    evalManifestWithRetries: null,\n    loadComponents: null,\n    loadManifestWithRetries: null,\n    tryLoadManifestWithRetries: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    evalManifestWithRetries: function() {\n        return evalManifestWithRetries;\n    },\n    loadComponents: function() {\n        return loadComponents;\n    },\n    loadManifestWithRetries: function() {\n        return loadManifestWithRetries;\n    },\n    tryLoadManifestWithRetries: function() {\n        return tryLoadManifestWithRetries;\n    }\n});\nconst _constants = require(\"../shared/lib/constants\");\nconst _path = require(\"path\");\nconst _require = require(\"./require\");\nconst _interopdefault = require(\"../lib/interop-default\");\nconst _tracer = require(\"./lib/trace/tracer\");\nconst _constants1 = require(\"./lib/trace/constants\");\nconst _loadmanifest = require(\"./load-manifest\");\nconst _wait = require(\"../lib/wait\");\nconst _encryptionutils = require(\"./app-render/encryption-utils\");\nconst _actionutils = require(\"./app-render/action-utils\");\nconst _normalizepagepath = require(\"../shared/lib/page-path/normalize-page-path\");\nconst _ismetadataroute = require(\"../lib/metadata/is-metadata-route\");\nasync function loadManifestWithRetries(manifestPath, attempts = 3) {\n    while(true){\n        try {\n            return (0, _loadmanifest.loadManifest)(manifestPath);\n        } catch (err) {\n            attempts--;\n            if (attempts <= 0) throw err;\n            await (0, _wait.wait)(100);\n        }\n    }\n}\nasync function tryLoadManifestWithRetries(manifestPath, attempts = 3) {\n    try {\n        return await loadManifestWithRetries(manifestPath, attempts);\n    } catch (err) {\n        return undefined;\n    }\n}\nasync function evalManifestWithRetries(manifestPath, attempts = 3) {\n    while(true){\n        try {\n            return (0, _loadmanifest.evalManifest)(manifestPath);\n        } catch (err) {\n            attempts--;\n            if (attempts <= 0) throw err;\n            await (0, _wait.wait)(100);\n        }\n    }\n}\nasync function tryLoadClientReferenceManifest(manifestPath, entryName, attempts) {\n    try {\n        const context = await evalManifestWithRetries(manifestPath, attempts);\n        return context.__RSC_MANIFEST[entryName];\n    } catch (err) {\n        return undefined;\n    }\n}\nasync function loadComponentsImpl({ distDir, page, isAppPath, isDev, sriEnabled }) {\n    let DocumentMod = {};\n    let AppMod = {};\n    if (!isAppPath) {\n        ;\n        [DocumentMod, AppMod] = await Promise.all([\n            (0, _require.requirePage)('/_document', distDir, false),\n            (0, _require.requirePage)('/_app', distDir, false)\n        ]);\n    }\n    // In dev mode we retry loading a manifest file to handle a race condition\n    // that can occur while app and pages are compiling at the same time, and the\n    // build-manifest is still being written to disk while an app path is\n    // attempting to load.\n    const manifestLoadAttempts = isDev ? 3 : 1;\n    let reactLoadableManifestPath;\n    if (!process.env.TURBOPACK) {\n        reactLoadableManifestPath = (0, _path.join)(distDir, _constants.REACT_LOADABLE_MANIFEST);\n    } else if (isAppPath) {\n        reactLoadableManifestPath = (0, _path.join)(distDir, 'server', 'app', page, _constants.REACT_LOADABLE_MANIFEST);\n    } else {\n        reactLoadableManifestPath = (0, _path.join)(distDir, 'server', 'pages', (0, _normalizepagepath.normalizePagePath)(page), _constants.REACT_LOADABLE_MANIFEST);\n    }\n    // Make sure to avoid loading the manifest for static metadata routes for better performance.\n    const hasClientManifest = !(0, _ismetadataroute.isStaticMetadataRoute)(page);\n    // Load the manifest files first\n    //\n    // Loading page-specific manifests shouldn't throw an error if the manifest couldn't be found, so\n    // that the `requirePage` call below will throw the correct error in that case\n    // (a `PageNotFoundError`).\n    const [buildManifest, reactLoadableManifest, dynamicCssManifest, clientReferenceManifest, serverActionsManifest, subresourceIntegrityManifest] = await Promise.all([\n        loadManifestWithRetries((0, _path.join)(distDir, _constants.BUILD_MANIFEST), manifestLoadAttempts),\n        tryLoadManifestWithRetries(reactLoadableManifestPath, manifestLoadAttempts),\n        // This manifest will only exist in Pages dir && Production && Webpack.\n        isAppPath || process.env.TURBOPACK ? undefined : loadManifestWithRetries((0, _path.join)(distDir, `${_constants.DYNAMIC_CSS_MANIFEST}.json`), manifestLoadAttempts).catch(()=>undefined),\n        isAppPath && hasClientManifest ? tryLoadClientReferenceManifest((0, _path.join)(distDir, 'server', 'app', page.replace(/%5F/g, '_') + '_' + _constants.CLIENT_REFERENCE_MANIFEST + '.js'), page.replace(/%5F/g, '_'), manifestLoadAttempts) : undefined,\n        isAppPath ? loadManifestWithRetries((0, _path.join)(distDir, 'server', _constants.SERVER_REFERENCE_MANIFEST + '.json'), manifestLoadAttempts).catch(()=>null) : null,\n        sriEnabled ? loadManifestWithRetries((0, _path.join)(distDir, 'server', _constants.SUBRESOURCE_INTEGRITY_MANIFEST + '.json')).catch(()=>undefined) : undefined\n    ]);\n    // Before requiring the actual page module, we have to set the reference\n    // manifests to our global store so Server Action's encryption util can access\n    // to them at the top level of the page module.\n    if (serverActionsManifest && clientReferenceManifest) {\n        (0, _encryptionutils.setReferenceManifestsSingleton)({\n            page,\n            clientReferenceManifest,\n            serverActionsManifest,\n            serverModuleMap: (0, _actionutils.createServerModuleMap)({\n                serverActionsManifest\n            })\n        });\n    }\n    const ComponentMod = await (0, _require.requirePage)(page, distDir, isAppPath);\n    const Component = (0, _interopdefault.interopDefault)(ComponentMod);\n    const Document = (0, _interopdefault.interopDefault)(DocumentMod);\n    const App = (0, _interopdefault.interopDefault)(AppMod);\n    const { getServerSideProps, getStaticProps, getStaticPaths, routeModule } = ComponentMod;\n    return {\n        App,\n        Document,\n        Component,\n        buildManifest,\n        subresourceIntegrityManifest,\n        reactLoadableManifest: reactLoadableManifest || {},\n        dynamicCssManifest,\n        pageConfig: ComponentMod.config || {},\n        ComponentMod,\n        getServerSideProps,\n        getStaticProps,\n        getStaticPaths,\n        clientReferenceManifest,\n        serverActionsManifest,\n        isAppPath,\n        page,\n        routeModule\n    };\n}\nconst loadComponents = (0, _tracer.getTracer)().wrap(_constants1.LoadComponentsSpan.loadComponents, loadComponentsImpl);\n\n//# sourceMappingURL=load-components.js.map"
        }
    ]
}