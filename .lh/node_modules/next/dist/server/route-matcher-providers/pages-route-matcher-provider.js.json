{
    "sourceFile": "node_modules/next/dist/server/route-matcher-providers/pages-route-matcher-provider.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892885180,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"PagesRouteMatcherProvider\", {\n    enumerable: true,\n    get: function() {\n        return PagesRouteMatcherProvider;\n    }\n});\nconst _isapiroute = require(\"../../lib/is-api-route\");\nconst _constants = require(\"../../shared/lib/constants\");\nconst _routekind = require(\"../route-kind\");\nconst _pagesroutematcher = require(\"../route-matchers/pages-route-matcher\");\nconst _manifestroutematcherprovider = require(\"./manifest-route-matcher-provider\");\nconst _pages = require(\"../normalizers/built/pages\");\nclass PagesRouteMatcherProvider extends _manifestroutematcherprovider.ManifestRouteMatcherProvider {\n    constructor(distDir, manifestLoader, i18nProvider){\n        super(_constants.PAGES_MANIFEST, manifestLoader), this.i18nProvider = i18nProvider;\n        this.normalizers = new _pages.PagesNormalizers(distDir);\n    }\n    async transform(manifest) {\n        // This matcher is only for Pages routes, not Pages API routes which are\n        // included in this manifest.\n        const pathnames = Object.keys(manifest).filter((pathname)=>!(0, _isapiroute.isAPIRoute)(pathname))// Remove any blocked pages (page that can't be routed to, like error or\n        // internal pages).\n        .filter((pathname)=>{\n            var _this_i18nProvider;\n            const normalized = ((_this_i18nProvider = this.i18nProvider) == null ? void 0 : _this_i18nProvider.analyze(pathname).pathname) ?? pathname;\n            // Skip any blocked pages.\n            if (_constants.BLOCKED_PAGES.includes(normalized)) return false;\n            return true;\n        });\n        const matchers = [];\n        for (const page of pathnames){\n            if (this.i18nProvider) {\n                // Match the locale on the page name, or default to the default locale.\n                const { detectedLocale, pathname } = this.i18nProvider.analyze(page);\n                matchers.push(new _pagesroutematcher.PagesLocaleRouteMatcher({\n                    kind: _routekind.RouteKind.PAGES,\n                    pathname,\n                    page,\n                    bundlePath: this.normalizers.bundlePath.normalize(page),\n                    filename: this.normalizers.filename.normalize(manifest[page]),\n                    i18n: {\n                        locale: detectedLocale\n                    }\n                }));\n            } else {\n                matchers.push(new _pagesroutematcher.PagesRouteMatcher({\n                    kind: _routekind.RouteKind.PAGES,\n                    // In `pages/`, the page is the same as the pathname.\n                    pathname: page,\n                    page,\n                    bundlePath: this.normalizers.bundlePath.normalize(page),\n                    filename: this.normalizers.filename.normalize(manifest[page])\n                }));\n            }\n        }\n        return matchers;\n    }\n}\n\n//# sourceMappingURL=pages-route-matcher-provider.js.map"
        }
    ]
}