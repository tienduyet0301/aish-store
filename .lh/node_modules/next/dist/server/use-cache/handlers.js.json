{
    "sourceFile": "node_modules/next/dist/server/use-cache/handlers.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892894591,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    getCacheHandler: null,\n    getCacheHandlerEntries: null,\n    getCacheHandlers: null,\n    initializeCacheHandlers: null,\n    setCacheHandler: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    getCacheHandler: function() {\n        return getCacheHandler;\n    },\n    getCacheHandlerEntries: function() {\n        return getCacheHandlerEntries;\n    },\n    getCacheHandlers: function() {\n        return getCacheHandlers;\n    },\n    initializeCacheHandlers: function() {\n        return initializeCacheHandlers;\n    },\n    setCacheHandler: function() {\n        return setCacheHandler;\n    }\n});\nconst _default = /*#__PURE__*/ _interop_require_default(require(\"../lib/cache-handlers/default\"));\nfunction _interop_require_default(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nconst debug = process.env.NEXT_PRIVATE_DEBUG_CACHE ? (message, ...args)=>{\n    console.log(`use-cache: ${message}`, ...args);\n} : undefined;\nconst handlersSymbol = Symbol.for('@next/cache-handlers');\nconst handlersMapSymbol = Symbol.for('@next/cache-handlers-map');\nconst handlersSetSymbol = Symbol.for('@next/cache-handlers-set');\n/**\n * The reference to the cache handlers. We store the cache handlers on the\n * global object so that we can access the same instance across different\n * boundaries (such as different copies of the same module).\n */ const reference = globalThis;\nfunction initializeCacheHandlers() {\n    // If the cache handlers have already been initialized, don't do it again.\n    if (reference[handlersMapSymbol]) {\n        debug == null ? void 0 : debug('cache handlers already initialized');\n        return false;\n    }\n    debug == null ? void 0 : debug('initializing cache handlers');\n    reference[handlersMapSymbol] = new Map();\n    // Initialize the cache from the symbol contents first.\n    if (reference[handlersSymbol]) {\n        let fallback;\n        if (reference[handlersSymbol].DefaultCache) {\n            debug == null ? void 0 : debug('setting \"default\" cache handler from symbol');\n            fallback = reference[handlersSymbol].DefaultCache;\n        } else {\n            debug == null ? void 0 : debug('setting \"default\" cache handler from default');\n            fallback = _default.default;\n        }\n        reference[handlersMapSymbol].set('default', fallback);\n        if (reference[handlersSymbol].RemoteCache) {\n            debug == null ? void 0 : debug('setting \"remote\" cache handler from symbol');\n            reference[handlersMapSymbol].set('remote', reference[handlersSymbol].RemoteCache);\n        } else {\n            debug == null ? void 0 : debug('setting \"remote\" cache handler from default');\n            reference[handlersMapSymbol].set('remote', fallback);\n        }\n    } else {\n        debug == null ? void 0 : debug('setting \"default\" cache handler from default');\n        reference[handlersMapSymbol].set('default', _default.default);\n        debug == null ? void 0 : debug('setting \"remote\" cache handler from default');\n        reference[handlersMapSymbol].set('remote', _default.default);\n    }\n    // Create a set of the cache handlers.\n    reference[handlersSetSymbol] = new Set(reference[handlersMapSymbol].values());\n    return true;\n}\nfunction getCacheHandler(kind) {\n    // This should never be called before initializeCacheHandlers.\n    if (!reference[handlersMapSymbol]) {\n        throw Object.defineProperty(new Error('Cache handlers not initialized'), \"__NEXT_ERROR_CODE\", {\n            value: \"E649\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    return reference[handlersMapSymbol].get(kind);\n}\nfunction getCacheHandlers() {\n    if (!reference[handlersSetSymbol]) {\n        return undefined;\n    }\n    return reference[handlersSetSymbol].values();\n}\nfunction getCacheHandlerEntries() {\n    if (!reference[handlersMapSymbol]) {\n        return undefined;\n    }\n    return reference[handlersMapSymbol].entries();\n}\nfunction setCacheHandler(kind, cacheHandler) {\n    // This should never be called before initializeCacheHandlers.\n    if (!reference[handlersMapSymbol] || !reference[handlersSetSymbol]) {\n        throw Object.defineProperty(new Error('Cache handlers not initialized'), \"__NEXT_ERROR_CODE\", {\n            value: \"E649\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    debug == null ? void 0 : debug('setting cache handler for \"%s\"', kind);\n    reference[handlersMapSymbol].set(kind, cacheHandler);\n    reference[handlersSetSymbol].add(cacheHandler);\n}\n\n//# sourceMappingURL=handlers.js.map"
        }
    ]
}