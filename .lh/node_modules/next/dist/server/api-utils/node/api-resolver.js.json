{
    "sourceFile": "node_modules/next/dist/server/api-utils/node/api-resolver.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892866656,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"apiResolver\", {\n    enumerable: true,\n    get: function() {\n        return apiResolver;\n    }\n});\nconst _bytes = /*#__PURE__*/ _interop_require_default(require(\"next/dist/compiled/bytes\"));\nconst _etag = require(\"../../lib/etag\");\nconst _sendpayload = require(\"../../send-payload\");\nconst _stream = require(\"stream\");\nconst _iserror = /*#__PURE__*/ _interop_require_default(require(\"../../../lib/is-error\"));\nconst _utils = require(\"../../../shared/lib/utils\");\nconst _interopdefault = require(\"../../../lib/interop-default\");\nconst _index = require(\"./../index\");\nconst _getcookieparser = require(\"./../get-cookie-parser\");\nconst _constants = require(\"../../../lib/constants\");\nconst _trygetpreviewdata = require(\"./try-get-preview-data\");\nconst _parsebody = require(\"./parse-body\");\nfunction _interop_require_default(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nfunction getMaxContentLength(responseLimit) {\n    if (responseLimit && typeof responseLimit !== 'boolean') {\n        return _bytes.default.parse(responseLimit);\n    }\n    return _index.RESPONSE_LIMIT_DEFAULT;\n}\n/**\n * Send `any` body to response\n * @param req request object\n * @param res response object\n * @param body of response\n */ function sendData(req, res, body) {\n    if (body === null || body === undefined) {\n        res.end();\n        return;\n    }\n    // strip irrelevant headers/body\n    if (res.statusCode === 204 || res.statusCode === 304) {\n        res.removeHeader('Content-Type');\n        res.removeHeader('Content-Length');\n        res.removeHeader('Transfer-Encoding');\n        if (process.env.NODE_ENV === 'development' && body) {\n            console.warn(`A body was attempted to be set with a 204 statusCode for ${req.url}, this is invalid and the body was ignored.\\n` + `See more info here https://nextjs.org/docs/messages/invalid-api-status-body`);\n        }\n        res.end();\n        return;\n    }\n    const contentType = res.getHeader('Content-Type');\n    if (body instanceof _stream.Stream) {\n        if (!contentType) {\n            res.setHeader('Content-Type', 'application/octet-stream');\n        }\n        body.pipe(res);\n        return;\n    }\n    const isJSONLike = [\n        'object',\n        'number',\n        'boolean'\n    ].includes(typeof body);\n    const stringifiedBody = isJSONLike ? JSON.stringify(body) : body;\n    const etag = (0, _etag.generateETag)(stringifiedBody);\n    if ((0, _sendpayload.sendEtagResponse)(req, res, etag)) {\n        return;\n    }\n    if (Buffer.isBuffer(body)) {\n        if (!contentType) {\n            res.setHeader('Content-Type', 'application/octet-stream');\n        }\n        res.setHeader('Content-Length', body.length);\n        res.end(body);\n        return;\n    }\n    if (isJSONLike) {\n        res.setHeader('Content-Type', 'application/json; charset=utf-8');\n    }\n    res.setHeader('Content-Length', Buffer.byteLength(stringifiedBody));\n    res.end(stringifiedBody);\n}\n/**\n * Send `JSON` object\n * @param res response object\n * @param jsonBody of data\n */ function sendJson(res, jsonBody) {\n    // Set header to application/json\n    res.setHeader('Content-Type', 'application/json; charset=utf-8');\n    // Use send to handle request\n    res.send(JSON.stringify(jsonBody));\n}\nfunction isValidData(str) {\n    return typeof str === 'string' && str.length >= 16;\n}\nfunction setDraftMode(res, options) {\n    if (!isValidData(options.previewModeId)) {\n        throw Object.defineProperty(new Error('invariant: invalid previewModeId'), \"__NEXT_ERROR_CODE\", {\n            value: \"E169\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    const expires = options.enable ? undefined : new Date(0);\n    // To delete a cookie, set `expires` to a date in the past:\n    // https://tools.ietf.org/html/rfc6265#section-4.1.1\n    // `Max-Age: 0` is not valid, thus ignored, and the cookie is persisted.\n    const { serialize } = require('next/dist/compiled/cookie');\n    const previous = res.getHeader('Set-Cookie');\n    res.setHeader(`Set-Cookie`, [\n        ...typeof previous === 'string' ? [\n            previous\n        ] : Array.isArray(previous) ? previous : [],\n        serialize(_index.COOKIE_NAME_PRERENDER_BYPASS, options.previewModeId, {\n            httpOnly: true,\n            sameSite: process.env.NODE_ENV !== 'development' ? 'none' : 'lax',\n            secure: process.env.NODE_ENV !== 'development',\n            path: '/',\n            expires\n        })\n    ]);\n    return res;\n}\nfunction setPreviewData(res, data, options) {\n    if (!isValidData(options.previewModeId)) {\n        throw Object.defineProperty(new Error('invariant: invalid previewModeId'), \"__NEXT_ERROR_CODE\", {\n            value: \"E169\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    if (!isValidData(options.previewModeEncryptionKey)) {\n        throw Object.defineProperty(new Error('invariant: invalid previewModeEncryptionKey'), \"__NEXT_ERROR_CODE\", {\n            value: \"E334\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    if (!isValidData(options.previewModeSigningKey)) {\n        throw Object.defineProperty(new Error('invariant: invalid previewModeSigningKey'), \"__NEXT_ERROR_CODE\", {\n            value: \"E436\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    const jsonwebtoken = require('next/dist/compiled/jsonwebtoken');\n    const { encryptWithSecret } = require('../../crypto-utils');\n    const payload = jsonwebtoken.sign({\n        data: encryptWithSecret(Buffer.from(options.previewModeEncryptionKey), JSON.stringify(data))\n    }, options.previewModeSigningKey, {\n        algorithm: 'HS256',\n        ...options.maxAge !== undefined ? {\n            expiresIn: options.maxAge\n        } : undefined\n    });\n    // limit preview mode cookie to 2KB since we shouldn't store too much\n    // data here and browsers drop cookies over 4KB\n    if (payload.length > 2048) {\n        throw Object.defineProperty(new Error(`Preview data is limited to 2KB currently, reduce how much data you are storing as preview data to continue`), \"__NEXT_ERROR_CODE\", {\n            value: \"E465\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    const { serialize } = require('next/dist/compiled/cookie');\n    const previous = res.getHeader('Set-Cookie');\n    res.setHeader(`Set-Cookie`, [\n        ...typeof previous === 'string' ? [\n            previous\n        ] : Array.isArray(previous) ? previous : [],\n        serialize(_index.COOKIE_NAME_PRERENDER_BYPASS, options.previewModeId, {\n            httpOnly: true,\n            sameSite: process.env.NODE_ENV !== 'development' ? 'none' : 'lax',\n            secure: process.env.NODE_ENV !== 'development',\n            path: '/',\n            ...options.maxAge !== undefined ? {\n                maxAge: options.maxAge\n            } : undefined,\n            ...options.path !== undefined ? {\n                path: options.path\n            } : undefined\n        }),\n        serialize(_index.COOKIE_NAME_PRERENDER_DATA, payload, {\n            httpOnly: true,\n            sameSite: process.env.NODE_ENV !== 'development' ? 'none' : 'lax',\n            secure: process.env.NODE_ENV !== 'development',\n            path: '/',\n            ...options.maxAge !== undefined ? {\n                maxAge: options.maxAge\n            } : undefined,\n            ...options.path !== undefined ? {\n                path: options.path\n            } : undefined\n        })\n    ]);\n    return res;\n}\nasync function revalidate(urlPath, opts, req, context) {\n    if (typeof urlPath !== 'string' || !urlPath.startsWith('/')) {\n        throw Object.defineProperty(new Error(`Invalid urlPath provided to revalidate(), must be a path e.g. /blog/post-1, received ${urlPath}`), \"__NEXT_ERROR_CODE\", {\n            value: \"E153\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    const revalidateHeaders = {\n        [_constants.PRERENDER_REVALIDATE_HEADER]: context.previewModeId,\n        ...opts.unstable_onlyGenerated ? {\n            [_constants.PRERENDER_REVALIDATE_ONLY_GENERATED_HEADER]: '1'\n        } : {}\n    };\n    const allowedRevalidateHeaderKeys = [\n        ...context.allowedRevalidateHeaderKeys || []\n    ];\n    if (context.trustHostHeader || context.dev) {\n        allowedRevalidateHeaderKeys.push('cookie');\n    }\n    if (context.trustHostHeader) {\n        allowedRevalidateHeaderKeys.push('x-vercel-protection-bypass');\n    }\n    for (const key of Object.keys(req.headers)){\n        if (allowedRevalidateHeaderKeys.includes(key)) {\n            revalidateHeaders[key] = req.headers[key];\n        }\n    }\n    try {\n        if (context.trustHostHeader) {\n            const res = await fetch(`https://${req.headers.host}${urlPath}`, {\n                method: 'HEAD',\n                headers: revalidateHeaders\n            });\n            // we use the cache header to determine successful revalidate as\n            // a non-200 status code can be returned from a successful revalidate\n            // e.g. notFound: true returns 404 status code but is successful\n            const cacheHeader = res.headers.get('x-vercel-cache') || res.headers.get('x-nextjs-cache');\n            if ((cacheHeader == null ? void 0 : cacheHeader.toUpperCase()) !== 'REVALIDATED' && res.status !== 200 && !(res.status === 404 && opts.unstable_onlyGenerated)) {\n                throw Object.defineProperty(new Error(`Invalid response ${res.status}`), \"__NEXT_ERROR_CODE\", {\n                    value: \"E175\",\n                    enumerable: false,\n                    configurable: true\n                });\n            }\n        } else if (context.revalidate) {\n            await context.revalidate({\n                urlPath,\n                revalidateHeaders,\n                opts\n            });\n        } else {\n            throw Object.defineProperty(new Error(`Invariant: required internal revalidate method not passed to api-utils`), \"__NEXT_ERROR_CODE\", {\n                value: \"E174\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n    } catch (err) {\n        throw Object.defineProperty(new Error(`Failed to revalidate ${urlPath}: ${(0, _iserror.default)(err) ? err.message : err}`), \"__NEXT_ERROR_CODE\", {\n            value: \"E240\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n}\nasync function apiResolver(req, res, query, resolverModule, apiContext, propagateError, dev, page, onError) {\n    const apiReq = req;\n    const apiRes = res;\n    try {\n        var _config_api, _config_api1, _config_api2;\n        if (!resolverModule) {\n            res.statusCode = 404;\n            res.end('Not Found');\n            return;\n        }\n        const config = resolverModule.config || {};\n        const bodyParser = ((_config_api = config.api) == null ? void 0 : _config_api.bodyParser) !== false;\n        const responseLimit = ((_config_api1 = config.api) == null ? void 0 : _config_api1.responseLimit) ?? true;\n        const externalResolver = ((_config_api2 = config.api) == null ? void 0 : _config_api2.externalResolver) || false;\n        // Parsing of cookies\n        (0, _index.setLazyProp)({\n            req: apiReq\n        }, 'cookies', (0, _getcookieparser.getCookieParser)(req.headers));\n        // Parsing query string\n        apiReq.query = query;\n        // Parsing preview data\n        (0, _index.setLazyProp)({\n            req: apiReq\n        }, 'previewData', ()=>(0, _trygetpreviewdata.tryGetPreviewData)(req, res, apiContext, !!apiContext.multiZoneDraftMode));\n        // Checking if preview mode is enabled\n        (0, _index.setLazyProp)({\n            req: apiReq\n        }, 'preview', ()=>apiReq.previewData !== false ? true : undefined);\n        // Set draftMode to the same value as preview\n        (0, _index.setLazyProp)({\n            req: apiReq\n        }, 'draftMode', ()=>apiReq.preview);\n        // Parsing of body\n        if (bodyParser && !apiReq.body) {\n            apiReq.body = await (0, _parsebody.parseBody)(apiReq, config.api && config.api.bodyParser && config.api.bodyParser.sizeLimit ? config.api.bodyParser.sizeLimit : '1mb');\n        }\n        let contentLength = 0;\n        const maxContentLength = getMaxContentLength(responseLimit);\n        const writeData = apiRes.write;\n        const endResponse = apiRes.end;\n        apiRes.write = (...args)=>{\n            contentLength += Buffer.byteLength(args[0] || '');\n            return writeData.apply(apiRes, args);\n        };\n        apiRes.end = (...args)=>{\n            if (args.length && typeof args[0] !== 'function') {\n                contentLength += Buffer.byteLength(args[0] || '');\n            }\n            if (responseLimit && contentLength >= maxContentLength) {\n                console.warn(`API response for ${req.url} exceeds ${_bytes.default.format(maxContentLength)}. API Routes are meant to respond quickly. https://nextjs.org/docs/messages/api-routes-response-size-limit`);\n            }\n            return endResponse.apply(apiRes, args);\n        };\n        apiRes.status = (statusCode)=>(0, _index.sendStatusCode)(apiRes, statusCode);\n        apiRes.send = (data)=>sendData(apiReq, apiRes, data);\n        apiRes.json = (data)=>sendJson(apiRes, data);\n        apiRes.redirect = (statusOrUrl, url)=>(0, _index.redirect)(apiRes, statusOrUrl, url);\n        apiRes.setDraftMode = (options = {\n            enable: true\n        })=>setDraftMode(apiRes, Object.assign({}, apiContext, options));\n        apiRes.setPreviewData = (data, options = {})=>setPreviewData(apiRes, data, Object.assign({}, apiContext, options));\n        apiRes.clearPreviewData = (options = {})=>(0, _index.clearPreviewData)(apiRes, options);\n        apiRes.revalidate = (urlPath, opts)=>revalidate(urlPath, opts || {}, req, apiContext);\n        const resolver = (0, _interopdefault.interopDefault)(resolverModule);\n        let wasPiped = false;\n        if (process.env.NODE_ENV !== 'production') {\n            // listen for pipe event and don't show resolve warning\n            res.once('pipe', ()=>wasPiped = true);\n        }\n        const apiRouteResult = await resolver(req, res);\n        if (process.env.NODE_ENV !== 'production') {\n            if (typeof apiRouteResult !== 'undefined') {\n                if (apiRouteResult instanceof Response) {\n                    throw Object.defineProperty(new Error('API route returned a Response object in the Node.js runtime, this is not supported. Please use `runtime: \"edge\"` instead: https://nextjs.org/docs/api-routes/edge-api-routes'), \"__NEXT_ERROR_CODE\", {\n                        value: \"E36\",\n                        enumerable: false,\n                        configurable: true\n                    });\n                }\n                console.warn(`API handler should not return a value, received ${typeof apiRouteResult}.`);\n            }\n            if (!externalResolver && !(0, _utils.isResSent)(res) && !wasPiped) {\n                console.warn(`API resolved without sending a response for ${req.url}, this may result in stalled requests.`);\n            }\n        }\n    } catch (err) {\n        onError == null ? void 0 : onError(err, req, {\n            routerKind: 'Pages Router',\n            routePath: page || '',\n            routeType: 'route',\n            revalidateReason: undefined\n        });\n        if (err instanceof _index.ApiError) {\n            (0, _index.sendError)(apiRes, err.statusCode, err.message);\n        } else {\n            if (dev) {\n                if ((0, _iserror.default)(err)) {\n                    err.page = page;\n                }\n                throw err;\n            }\n            console.error(err);\n            if (propagateError) {\n                throw err;\n            }\n            (0, _index.sendError)(apiRes, 500, 'Internal Server Error');\n        }\n    }\n}\n\n//# sourceMappingURL=api-resolver.js.map"
        }
    ]
}