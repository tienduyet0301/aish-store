{
    "sourceFile": "node_modules/next/dist/server/render.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892881790,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    errorToJSON: null,\n    renderToHTML: null,\n    renderToHTMLImpl: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    errorToJSON: function() {\n        return errorToJSON;\n    },\n    renderToHTML: function() {\n        return renderToHTML;\n    },\n    renderToHTMLImpl: function() {\n        return renderToHTMLImpl;\n    }\n});\nconst _jsxruntime = require(\"react/jsx-runtime\");\nconst _apiutils = require(\"./api-utils\");\nconst _getcookieparser = require(\"./api-utils/get-cookie-parser\");\nconst _react = /*#__PURE__*/ _interop_require_default(require(\"react\"));\nconst _ReactDOMServerPages = /*#__PURE__*/ _interop_require_default(require(\"next/dist/server/ReactDOMServerPages\"));\nconst _styledjsx = require(\"styled-jsx\");\nconst _constants = require(\"../lib/constants\");\nconst _constants1 = require(\"../shared/lib/constants\");\nconst _isserializableprops = require(\"../lib/is-serializable-props\");\nconst _ampmode = require(\"../shared/lib/amp-mode\");\nconst _ampcontextsharedruntime = require(\"../shared/lib/amp-context.shared-runtime\");\nconst _head = require(\"../shared/lib/head\");\nconst _headmanagercontextsharedruntime = require(\"../shared/lib/head-manager-context.shared-runtime\");\nconst _loadablesharedruntime = /*#__PURE__*/ _interop_require_default(require(\"../shared/lib/loadable.shared-runtime\"));\nconst _loadablecontextsharedruntime = require(\"../shared/lib/loadable-context.shared-runtime\");\nconst _routercontextsharedruntime = require(\"../shared/lib/router-context.shared-runtime\");\nconst _isdynamic = require(\"../shared/lib/router/utils/is-dynamic\");\nconst _utils = require(\"../shared/lib/utils\");\nconst _htmlcontextsharedruntime = require(\"../shared/lib/html-context.shared-runtime\");\nconst _normalizepagepath = require(\"../shared/lib/page-path/normalize-page-path\");\nconst _denormalizepagepath = require(\"../shared/lib/page-path/denormalize-page-path\");\nconst _requestmeta = require(\"./request-meta\");\nconst _redirectstatus = require(\"../lib/redirect-status\");\nconst _renderresult = /*#__PURE__*/ _interop_require_default(require(\"./render-result\"));\nconst _iserror = /*#__PURE__*/ _interop_require_default(require(\"../lib/is-error\"));\nconst _nodewebstreamshelper = require(\"./stream-utils/node-web-streams-helper\");\nconst _imageconfigcontextsharedruntime = require(\"../shared/lib/image-config-context.shared-runtime\");\nconst _stripansi = /*#__PURE__*/ _interop_require_default(require(\"next/dist/compiled/strip-ansi\"));\nconst _internalutils = require(\"./internal-utils\");\nconst _adapters = require(\"../shared/lib/router/adapters\");\nconst _approutercontextsharedruntime = require(\"../shared/lib/app-router-context.shared-runtime\");\nconst _hooksclientcontextsharedruntime = require(\"../shared/lib/hooks-client-context.shared-runtime\");\nconst _tracer = require(\"./lib/trace/tracer\");\nconst _constants2 = require(\"./lib/trace/constants\");\nconst _reflect = require(\"./web/spec-extension/adapters/reflect\");\nconst _cachecontrol = require(\"./lib/cache-control\");\nconst _errorsource = require(\"../shared/lib/error-source\");\nfunction _interop_require_default(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nlet tryGetPreviewData;\nlet warn;\nlet postProcessHTML;\nconst DOCTYPE = '<!DOCTYPE html>';\nif (process.env.NEXT_RUNTIME !== 'edge') {\n    tryGetPreviewData = require('./api-utils/node/try-get-preview-data').tryGetPreviewData;\n    warn = require('../build/output/log').warn;\n    postProcessHTML = require('./post-process').postProcessHTML;\n} else {\n    warn = console.warn.bind(console);\n    postProcessHTML = async (_pathname, html)=>html;\n}\nfunction noRouter() {\n    const message = 'No router instance found. you should only use \"next/router\" inside the client side of your app. https://nextjs.org/docs/messages/no-router-instance';\n    throw Object.defineProperty(new Error(message), \"__NEXT_ERROR_CODE\", {\n        value: \"E394\",\n        enumerable: false,\n        configurable: true\n    });\n}\nasync function renderToString(element) {\n    const renderStream = await _ReactDOMServerPages.default.renderToReadableStream(element);\n    await renderStream.allReady;\n    return (0, _nodewebstreamshelper.streamToString)(renderStream);\n}\nclass ServerRouter {\n    constructor(pathname, query, as, { isFallback }, isReady, basePath, locale, locales, defaultLocale, domainLocales, isPreview, isLocaleDomain){\n        this.route = pathname.replace(/\\/$/, '') || '/';\n        this.pathname = pathname;\n        this.query = query;\n        this.asPath = as;\n        this.isFallback = isFallback;\n        this.basePath = basePath;\n        this.locale = locale;\n        this.locales = locales;\n        this.defaultLocale = defaultLocale;\n        this.isReady = isReady;\n        this.domainLocales = domainLocales;\n        this.isPreview = !!isPreview;\n        this.isLocaleDomain = !!isLocaleDomain;\n    }\n    push() {\n        noRouter();\n    }\n    replace() {\n        noRouter();\n    }\n    reload() {\n        noRouter();\n    }\n    back() {\n        noRouter();\n    }\n    forward() {\n        noRouter();\n    }\n    prefetch() {\n        noRouter();\n    }\n    beforePopState() {\n        noRouter();\n    }\n}\nfunction enhanceComponents(options, App, Component) {\n    // For backwards compatibility\n    if (typeof options === 'function') {\n        return {\n            App,\n            Component: options(Component)\n        };\n    }\n    return {\n        App: options.enhanceApp ? options.enhanceApp(App) : App,\n        Component: options.enhanceComponent ? options.enhanceComponent(Component) : Component\n    };\n}\nfunction renderPageTree(App, Component, props) {\n    return /*#__PURE__*/ (0, _jsxruntime.jsx)(App, {\n        Component: Component,\n        ...props\n    });\n}\nconst invalidKeysMsg = (methodName, invalidKeys)=>{\n    const docsPathname = `invalid-${methodName.toLocaleLowerCase()}-value`;\n    return `Additional keys were returned from \\`${methodName}\\`. Properties intended for your component must be nested under the \\`props\\` key, e.g.:` + `\\n\\n\\treturn { props: { title: 'My Title', content: '...' } }` + `\\n\\nKeys that need to be moved: ${invalidKeys.join(', ')}.` + `\\nRead more: https://nextjs.org/docs/messages/${docsPathname}`;\n};\nfunction checkRedirectValues(redirect, req, method) {\n    const { destination, permanent, statusCode, basePath } = redirect;\n    let errors = [];\n    const hasStatusCode = typeof statusCode !== 'undefined';\n    const hasPermanent = typeof permanent !== 'undefined';\n    if (hasPermanent && hasStatusCode) {\n        errors.push(`\\`permanent\\` and \\`statusCode\\` can not both be provided`);\n    } else if (hasPermanent && typeof permanent !== 'boolean') {\n        errors.push(`\\`permanent\\` must be \\`true\\` or \\`false\\``);\n    } else if (hasStatusCode && !_redirectstatus.allowedStatusCodes.has(statusCode)) {\n        errors.push(`\\`statusCode\\` must undefined or one of ${[\n            ..._redirectstatus.allowedStatusCodes\n        ].join(', ')}`);\n    }\n    const destinationType = typeof destination;\n    if (destinationType !== 'string') {\n        errors.push(`\\`destination\\` should be string but received ${destinationType}`);\n    }\n    const basePathType = typeof basePath;\n    if (basePathType !== 'undefined' && basePathType !== 'boolean') {\n        errors.push(`\\`basePath\\` should be undefined or a false, received ${basePathType}`);\n    }\n    if (errors.length > 0) {\n        throw Object.defineProperty(new Error(`Invalid redirect object returned from ${method} for ${req.url}\\n` + errors.join(' and ') + '\\n' + `See more info here: https://nextjs.org/docs/messages/invalid-redirect-gssp`), \"__NEXT_ERROR_CODE\", {\n            value: \"E185\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n}\nfunction errorToJSON(err) {\n    let source = 'server';\n    if (process.env.NEXT_RUNTIME !== 'edge') {\n        source = (0, _errorsource.getErrorSource)(err) || 'server';\n    }\n    return {\n        name: err.name,\n        source,\n        message: (0, _stripansi.default)(err.message),\n        stack: err.stack,\n        digest: err.digest\n    };\n}\nfunction serializeError(dev, err) {\n    if (dev) {\n        return errorToJSON(err);\n    }\n    return {\n        name: 'Internal Server Error.',\n        message: '500 - Internal Server Error.',\n        statusCode: 500\n    };\n}\nasync function renderToHTMLImpl(req, res, pathname, query, renderOpts, extra, sharedContext, renderContext) {\n    // Adds support for reading `cookies` in `getServerSideProps` when SSR.\n    (0, _apiutils.setLazyProp)({\n        req: req\n    }, 'cookies', (0, _getcookieparser.getCookieParser)(req.headers));\n    const metadata = {};\n    metadata.assetQueryString = renderOpts.dev && renderOpts.assetQueryString || '';\n    if (renderOpts.dev && !metadata.assetQueryString) {\n        const userAgent = (req.headers['user-agent'] || '').toLowerCase();\n        if (userAgent.includes('safari') && !userAgent.includes('chrome')) {\n            // In dev we invalidate the cache by appending a timestamp to the resource URL.\n            // This is a workaround to fix https://github.com/vercel/next.js/issues/5860\n            // TODO: remove this workaround when https://bugs.webkit.org/show_bug.cgi?id=187726 is fixed.\n            // Note: The workaround breaks breakpoints on reload since the script url always changes,\n            // so we only apply it to Safari.\n            metadata.assetQueryString = `?ts=${Date.now()}`;\n        }\n    }\n    // if deploymentId is provided we append it to all asset requests\n    if (sharedContext.deploymentId) {\n        metadata.assetQueryString += `${metadata.assetQueryString ? '&' : '?'}dpl=${sharedContext.deploymentId}`;\n    }\n    // don't modify original query object\n    query = Object.assign({}, query);\n    const { err, dev = false, ampPath = '', pageConfig = {}, buildManifest, reactLoadableManifest, ErrorDebug, getStaticProps, getStaticPaths, getServerSideProps, isNextDataRequest, params, previewProps, basePath, images, runtime: globalRuntime, isExperimentalCompile, expireTime } = renderOpts;\n    const { App } = extra;\n    const assetQueryString = metadata.assetQueryString;\n    let Document = extra.Document;\n    let Component = renderOpts.Component;\n    const OriginComponent = Component;\n    const isFallback = renderContext.isFallback ?? false;\n    const notFoundSrcPage = renderContext.developmentNotFoundSourcePage;\n    // next internal queries should be stripped out\n    (0, _internalutils.stripInternalQueries)(query);\n    const isSSG = !!getStaticProps;\n    const isBuildTimeSSG = isSSG && renderOpts.nextExport;\n    const defaultAppGetInitialProps = App.getInitialProps === App.origGetInitialProps;\n    const hasPageGetInitialProps = !!(Component == null ? void 0 : Component.getInitialProps);\n    const hasPageScripts = Component == null ? void 0 : Component.unstable_scriptLoader;\n    const pageIsDynamic = (0, _isdynamic.isDynamicRoute)(pathname);\n    const defaultErrorGetInitialProps = pathname === '/_error' && Component.getInitialProps === Component.origGetInitialProps;\n    if (renderOpts.nextExport && hasPageGetInitialProps && !defaultErrorGetInitialProps) {\n        warn(`Detected getInitialProps on page '${pathname}'` + ` while running export. It's recommended to use getStaticProps` + ` which has a more correct behavior for static exporting.` + `\\nRead more: https://nextjs.org/docs/messages/get-initial-props-export`);\n    }\n    let isAutoExport = !hasPageGetInitialProps && defaultAppGetInitialProps && !isSSG && !getServerSideProps;\n    // if we are running from experimental compile and the page\n    // would normally be automatically statically optimized\n    // ensure we set cache header so it's not rendered on-demand\n    // every request\n    if (isAutoExport && !dev && isExperimentalCompile) {\n        res.setHeader('Cache-Control', (0, _cachecontrol.getCacheControlHeader)({\n            revalidate: false,\n            expire: expireTime\n        }));\n        isAutoExport = false;\n    }\n    if (hasPageGetInitialProps && isSSG) {\n        throw Object.defineProperty(new Error(_constants.SSG_GET_INITIAL_PROPS_CONFLICT + ` ${pathname}`), \"__NEXT_ERROR_CODE\", {\n            value: \"E262\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    if (hasPageGetInitialProps && getServerSideProps) {\n        throw Object.defineProperty(new Error(_constants.SERVER_PROPS_GET_INIT_PROPS_CONFLICT + ` ${pathname}`), \"__NEXT_ERROR_CODE\", {\n            value: \"E262\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    if (getServerSideProps && isSSG) {\n        throw Object.defineProperty(new Error(_constants.SERVER_PROPS_SSG_CONFLICT + ` ${pathname}`), \"__NEXT_ERROR_CODE\", {\n            value: \"E262\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    if (getServerSideProps && renderOpts.nextConfigOutput === 'export') {\n        throw Object.defineProperty(new Error('getServerSideProps cannot be used with \"output: export\". See more info here: https://nextjs.org/docs/advanced-features/static-html-export'), \"__NEXT_ERROR_CODE\", {\n            value: \"E369\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    if (getStaticPaths && !pageIsDynamic) {\n        throw Object.defineProperty(new Error(`getStaticPaths is only allowed for dynamic SSG pages and was found on '${pathname}'.` + `\\nRead more: https://nextjs.org/docs/messages/non-dynamic-getstaticpaths-usage`), \"__NEXT_ERROR_CODE\", {\n            value: \"E187\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    if (!!getStaticPaths && !isSSG) {\n        throw Object.defineProperty(new Error(`getStaticPaths was added without a getStaticProps in ${pathname}. Without getStaticProps, getStaticPaths does nothing`), \"__NEXT_ERROR_CODE\", {\n            value: \"E447\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    if (isSSG && pageIsDynamic && !getStaticPaths) {\n        throw Object.defineProperty(new Error(`getStaticPaths is required for dynamic SSG pages and is missing for '${pathname}'.` + `\\nRead more: https://nextjs.org/docs/messages/invalid-getstaticpaths-value`), \"__NEXT_ERROR_CODE\", {\n            value: \"E255\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    let asPath = renderOpts.resolvedAsPath || req.url;\n    if (dev) {\n        const { isValidElementType } = require('next/dist/compiled/react-is');\n        if (!isValidElementType(Component)) {\n            throw Object.defineProperty(new Error(`The default export is not a React Component in page: \"${pathname}\"`), \"__NEXT_ERROR_CODE\", {\n                value: \"E286\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n        if (!isValidElementType(App)) {\n            throw Object.defineProperty(new Error(`The default export is not a React Component in page: \"/_app\"`), \"__NEXT_ERROR_CODE\", {\n                value: \"E464\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n        if (!isValidElementType(Document)) {\n            throw Object.defineProperty(new Error(`The default export is not a React Component in page: \"/_document\"`), \"__NEXT_ERROR_CODE\", {\n                value: \"E511\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n        if (isAutoExport || isFallback) {\n            // remove query values except ones that will be set during export\n            query = {\n                ...query.amp ? {\n                    amp: query.amp\n                } : {}\n            };\n            asPath = `${pathname}${// ensure trailing slash is present for non-dynamic auto-export pages\n            req.url.endsWith('/') && pathname !== '/' && !pageIsDynamic ? '/' : ''}`;\n            req.url = pathname;\n        }\n        if (pathname === '/404' && (hasPageGetInitialProps || getServerSideProps)) {\n            throw Object.defineProperty(new Error(`\\`pages/404\\` ${_constants.STATIC_STATUS_PAGE_GET_INITIAL_PROPS_ERROR}`), \"__NEXT_ERROR_CODE\", {\n                value: \"E134\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n        if (_constants1.STATIC_STATUS_PAGES.includes(pathname) && (hasPageGetInitialProps || getServerSideProps)) {\n            throw Object.defineProperty(new Error(`\\`pages${pathname}\\` ${_constants.STATIC_STATUS_PAGE_GET_INITIAL_PROPS_ERROR}`), \"__NEXT_ERROR_CODE\", {\n                value: \"E125\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n        if (renderOpts == null ? void 0 : renderOpts.setIsrStatus) {\n            renderOpts.setIsrStatus(asPath, isSSG || isAutoExport ? true : null);\n        }\n    }\n    for (const methodName of [\n        'getStaticProps',\n        'getServerSideProps',\n        'getStaticPaths'\n    ]){\n        if (Component == null ? void 0 : Component[methodName]) {\n            throw Object.defineProperty(new Error(`page ${pathname} ${methodName} ${_constants.GSSP_COMPONENT_MEMBER_ERROR}`), \"__NEXT_ERROR_CODE\", {\n                value: \"E417\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n    }\n    await _loadablesharedruntime.default.preloadAll() // Make sure all dynamic imports are loaded\n    ;\n    let isPreview = undefined;\n    let previewData;\n    if ((isSSG || getServerSideProps) && !isFallback && process.env.NEXT_RUNTIME !== 'edge' && previewProps) {\n        // Reads of this are cached on the `req` object, so this should resolve\n        // instantly. There's no need to pass this data down from a previous\n        // invoke.\n        previewData = tryGetPreviewData(req, res, previewProps, !!renderOpts.multiZoneDraftMode);\n        isPreview = previewData !== false;\n    }\n    // url will always be set\n    const routerIsReady = !!(getServerSideProps || hasPageGetInitialProps || !defaultAppGetInitialProps && !isSSG || isExperimentalCompile);\n    const router = new ServerRouter(pathname, query, asPath, {\n        isFallback: isFallback\n    }, routerIsReady, basePath, renderOpts.locale, renderOpts.locales, renderOpts.defaultLocale, renderOpts.domainLocales, isPreview, (0, _requestmeta.getRequestMeta)(req, 'isLocaleDomain'));\n    const appRouter = (0, _adapters.adaptForAppRouterInstance)(router);\n    let scriptLoader = {};\n    const jsxStyleRegistry = (0, _styledjsx.createStyleRegistry)();\n    const ampState = {\n        ampFirst: pageConfig.amp === true,\n        hasQuery: Boolean(query.amp),\n        hybrid: pageConfig.amp === 'hybrid'\n    };\n    // Disable AMP under the web environment\n    const inAmpMode = process.env.NEXT_RUNTIME !== 'edge' && (0, _ampmode.isInAmpMode)(ampState);\n    let head = (0, _head.defaultHead)(inAmpMode);\n    const reactLoadableModules = [];\n    let initialScripts = {};\n    if (hasPageScripts) {\n        initialScripts.beforeInteractive = [].concat(hasPageScripts()).filter((script)=>script.props.strategy === 'beforeInteractive').map((script)=>script.props);\n    }\n    const AppContainer = ({ children })=>/*#__PURE__*/ (0, _jsxruntime.jsx)(_approutercontextsharedruntime.AppRouterContext.Provider, {\n            value: appRouter,\n            children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_hooksclientcontextsharedruntime.SearchParamsContext.Provider, {\n                value: (0, _adapters.adaptForSearchParams)(router),\n                children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_adapters.PathnameContextProviderAdapter, {\n                    router: router,\n                    isAutoExport: isAutoExport,\n                    children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_hooksclientcontextsharedruntime.PathParamsContext.Provider, {\n                        value: (0, _adapters.adaptForPathParams)(router),\n                        children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_routercontextsharedruntime.RouterContext.Provider, {\n                            value: router,\n                            children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_ampcontextsharedruntime.AmpStateContext.Provider, {\n                                value: ampState,\n                                children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_headmanagercontextsharedruntime.HeadManagerContext.Provider, {\n                                    value: {\n                                        updateHead: (state)=>{\n                                            head = state;\n                                        },\n                                        updateScripts: (scripts)=>{\n                                            scriptLoader = scripts;\n                                        },\n                                        scripts: initialScripts,\n                                        mountedInstances: new Set()\n                                    },\n                                    children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_loadablecontextsharedruntime.LoadableContext.Provider, {\n                                        value: (moduleName)=>reactLoadableModules.push(moduleName),\n                                        children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_styledjsx.StyleRegistry, {\n                                            registry: jsxStyleRegistry,\n                                            children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_imageconfigcontextsharedruntime.ImageConfigContext.Provider, {\n                                                value: images,\n                                                children: children\n                                            })\n                                        })\n                                    })\n                                })\n                            })\n                        })\n                    })\n                })\n            })\n        });\n    // The `useId` API uses the path indexes to generate an ID for each node.\n    // To guarantee the match of hydration, we need to ensure that the structure\n    // of wrapper nodes is isomorphic in server and client.\n    // TODO: With `enhanceApp` and `enhanceComponents` options, this approach may\n    // not be useful.\n    // https://github.com/facebook/react/pull/22644\n    const Noop = ()=>null;\n    const AppContainerWithIsomorphicFiberStructure = ({ children })=>{\n        return /*#__PURE__*/ (0, _jsxruntime.jsxs)(_jsxruntime.Fragment, {\n            children: [\n                /*#__PURE__*/ (0, _jsxruntime.jsx)(Noop, {}),\n                /*#__PURE__*/ (0, _jsxruntime.jsx)(AppContainer, {\n                    children: /*#__PURE__*/ (0, _jsxruntime.jsxs)(_jsxruntime.Fragment, {\n                        children: [\n                            dev ? /*#__PURE__*/ (0, _jsxruntime.jsxs)(_jsxruntime.Fragment, {\n                                children: [\n                                    children,\n                                    /*#__PURE__*/ (0, _jsxruntime.jsx)(Noop, {})\n                                ]\n                            }) : children,\n                            /*#__PURE__*/ (0, _jsxruntime.jsx)(Noop, {})\n                        ]\n                    })\n                })\n            ]\n        });\n    };\n    const ctx = {\n        err,\n        req: isAutoExport ? undefined : req,\n        res: isAutoExport ? undefined : res,\n        pathname,\n        query,\n        asPath,\n        locale: renderOpts.locale,\n        locales: renderOpts.locales,\n        defaultLocale: renderOpts.defaultLocale,\n        AppTree: (props)=>{\n            return /*#__PURE__*/ (0, _jsxruntime.jsx)(AppContainerWithIsomorphicFiberStructure, {\n                children: renderPageTree(App, OriginComponent, {\n                    ...props,\n                    router\n                })\n            });\n        },\n        defaultGetInitialProps: async (docCtx, options = {})=>{\n            const enhanceApp = (AppComp)=>{\n                return (props)=>/*#__PURE__*/ (0, _jsxruntime.jsx)(AppComp, {\n                        ...props\n                    });\n            };\n            const { html, head: renderPageHead } = await docCtx.renderPage({\n                enhanceApp\n            });\n            const styles = jsxStyleRegistry.styles({\n                nonce: options.nonce\n            });\n            jsxStyleRegistry.flush();\n            return {\n                html,\n                head: renderPageHead,\n                styles\n            };\n        }\n    };\n    let props;\n    const nextExport = !isSSG && (renderOpts.nextExport || dev && (isAutoExport || isFallback));\n    const styledJsxInsertedHTML = ()=>{\n        const styles = jsxStyleRegistry.styles();\n        jsxStyleRegistry.flush();\n        return /*#__PURE__*/ (0, _jsxruntime.jsx)(_jsxruntime.Fragment, {\n            children: styles\n        });\n    };\n    props = await (0, _utils.loadGetInitialProps)(App, {\n        AppTree: ctx.AppTree,\n        Component,\n        router,\n        ctx\n    });\n    if ((isSSG || getServerSideProps) && isPreview) {\n        props.__N_PREVIEW = true;\n    }\n    if (isSSG) {\n        props[_constants1.STATIC_PROPS_ID] = true;\n    }\n    if (isSSG && !isFallback) {\n        let data;\n        try {\n            data = await (0, _tracer.getTracer)().trace(_constants2.RenderSpan.getStaticProps, {\n                spanName: `getStaticProps ${pathname}`,\n                attributes: {\n                    'next.route': pathname\n                }\n            }, ()=>getStaticProps({\n                    ...pageIsDynamic ? {\n                        params\n                    } : undefined,\n                    ...isPreview ? {\n                        draftMode: true,\n                        preview: true,\n                        previewData: previewData\n                    } : undefined,\n                    locales: [\n                        ...renderOpts.locales ?? []\n                    ],\n                    locale: renderOpts.locale,\n                    defaultLocale: renderOpts.defaultLocale,\n                    revalidateReason: renderOpts.isOnDemandRevalidate ? 'on-demand' : isBuildTimeSSG ? 'build' : 'stale'\n                }));\n        } catch (staticPropsError) {\n            // remove not found error code to prevent triggering legacy\n            // 404 rendering\n            if (staticPropsError && staticPropsError.code === 'ENOENT') {\n                delete staticPropsError.code;\n            }\n            throw staticPropsError;\n        }\n        if (data == null) {\n            throw Object.defineProperty(new Error(_constants.GSP_NO_RETURNED_VALUE), \"__NEXT_ERROR_CODE\", {\n                value: \"E394\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n        const invalidKeys = Object.keys(data).filter((key)=>key !== 'revalidate' && key !== 'props' && key !== 'redirect' && key !== 'notFound');\n        if (invalidKeys.includes('unstable_revalidate')) {\n            throw Object.defineProperty(new Error(_constants.UNSTABLE_REVALIDATE_RENAME_ERROR), \"__NEXT_ERROR_CODE\", {\n                value: \"E394\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n        if (invalidKeys.length) {\n            throw Object.defineProperty(new Error(invalidKeysMsg('getStaticProps', invalidKeys)), \"__NEXT_ERROR_CODE\", {\n                value: \"E394\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n        if (process.env.NODE_ENV !== 'production') {\n            if (typeof data.notFound !== 'undefined' && typeof data.redirect !== 'undefined') {\n                throw Object.defineProperty(new Error(`\\`redirect\\` and \\`notFound\\` can not both be returned from ${isSSG ? 'getStaticProps' : 'getServerSideProps'} at the same time. Page: ${pathname}\\nSee more info here: https://nextjs.org/docs/messages/gssp-mixed-not-found-redirect`), \"__NEXT_ERROR_CODE\", {\n                    value: \"E454\",\n                    enumerable: false,\n                    configurable: true\n                });\n            }\n        }\n        if ('notFound' in data && data.notFound) {\n            if (pathname === '/404') {\n                throw Object.defineProperty(new Error(`The /404 page can not return notFound in \"getStaticProps\", please remove it to continue!`), \"__NEXT_ERROR_CODE\", {\n                    value: \"E121\",\n                    enumerable: false,\n                    configurable: true\n                });\n            }\n            metadata.isNotFound = true;\n        }\n        if ('redirect' in data && data.redirect && typeof data.redirect === 'object') {\n            checkRedirectValues(data.redirect, req, 'getStaticProps');\n            if (isBuildTimeSSG) {\n                throw Object.defineProperty(new Error(`\\`redirect\\` can not be returned from getStaticProps during prerendering (${req.url})\\n` + `See more info here: https://nextjs.org/docs/messages/gsp-redirect-during-prerender`), \"__NEXT_ERROR_CODE\", {\n                    value: \"E497\",\n                    enumerable: false,\n                    configurable: true\n                });\n            }\n            ;\n            data.props = {\n                __N_REDIRECT: data.redirect.destination,\n                __N_REDIRECT_STATUS: (0, _redirectstatus.getRedirectStatus)(data.redirect)\n            };\n            if (typeof data.redirect.basePath !== 'undefined') {\n                ;\n                data.props.__N_REDIRECT_BASE_PATH = data.redirect.basePath;\n            }\n            metadata.isRedirect = true;\n        }\n        if ((dev || isBuildTimeSSG) && !metadata.isNotFound && !(0, _isserializableprops.isSerializableProps)(pathname, 'getStaticProps', data.props)) {\n            // this fn should throw an error instead of ever returning `false`\n            throw Object.defineProperty(new Error('invariant: getStaticProps did not return valid props. Please report this.'), \"__NEXT_ERROR_CODE\", {\n                value: \"E129\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n        let revalidate;\n        if ('revalidate' in data) {\n            if (data.revalidate && renderOpts.nextConfigOutput === 'export') {\n                throw Object.defineProperty(new Error('ISR cannot be used with \"output: export\". See more info here: https://nextjs.org/docs/advanced-features/static-html-export'), \"__NEXT_ERROR_CODE\", {\n                    value: \"E201\",\n                    enumerable: false,\n                    configurable: true\n                });\n            }\n            if (typeof data.revalidate === 'number') {\n                if (!Number.isInteger(data.revalidate)) {\n                    throw Object.defineProperty(new Error(`A page's revalidate option must be seconds expressed as a natural number for ${req.url}. Mixed numbers, such as '${data.revalidate}', cannot be used.` + `\\nTry changing the value to '${Math.ceil(data.revalidate)}' or using \\`Math.ceil()\\` if you're computing the value.`), \"__NEXT_ERROR_CODE\", {\n                        value: \"E438\",\n                        enumerable: false,\n                        configurable: true\n                    });\n                } else if (data.revalidate <= 0) {\n                    throw Object.defineProperty(new Error(`A page's revalidate option can not be less than or equal to zero for ${req.url}. A revalidate option of zero means to revalidate after _every_ request, and implies stale data cannot be tolerated.` + `\\n\\nTo never revalidate, you can set revalidate to \\`false\\` (only ran once at build-time).` + `\\nTo revalidate as soon as possible, you can set the value to \\`1\\`.`), \"__NEXT_ERROR_CODE\", {\n                        value: \"E311\",\n                        enumerable: false,\n                        configurable: true\n                    });\n                } else {\n                    if (data.revalidate > 31536000) {\n                        // if it's greater than a year for some reason error\n                        console.warn(`Warning: A page's revalidate option was set to more than a year for ${req.url}. This may have been done in error.` + `\\nTo only run getStaticProps at build-time and not revalidate at runtime, you can set \\`revalidate\\` to \\`false\\`!`);\n                    }\n                    revalidate = data.revalidate;\n                }\n            } else if (data.revalidate === true) {\n                // When enabled, revalidate after 1 second. This value is optimal for\n                // the most up-to-date page possible, but without a 1-to-1\n                // request-refresh ratio.\n                revalidate = 1;\n            } else if (data.revalidate === false || typeof data.revalidate === 'undefined') {\n                // By default, we never revalidate.\n                revalidate = false;\n            } else {\n                throw Object.defineProperty(new Error(`A page's revalidate option must be seconds expressed as a natural number. Mixed numbers and strings cannot be used. Received '${JSON.stringify(data.revalidate)}' for ${req.url}`), \"__NEXT_ERROR_CODE\", {\n                    value: \"E161\",\n                    enumerable: false,\n                    configurable: true\n                });\n            }\n        } else {\n            // By default, we never revalidate.\n            revalidate = false;\n        }\n        props.pageProps = Object.assign({}, props.pageProps, 'props' in data ? data.props : undefined);\n        // pass up cache control and props for export\n        metadata.cacheControl = {\n            revalidate,\n            expire: undefined\n        };\n        metadata.pageData = props;\n        // this must come after revalidate is added to renderResultMeta\n        if (metadata.isNotFound) {\n            return new _renderresult.default(null, {\n                metadata\n            });\n        }\n    }\n    if (getServerSideProps) {\n        props[_constants1.SERVER_PROPS_ID] = true;\n    }\n    if (getServerSideProps && !isFallback) {\n        let data;\n        let canAccessRes = true;\n        let resOrProxy = res;\n        let deferredContent = false;\n        if (process.env.NODE_ENV !== 'production') {\n            resOrProxy = new Proxy(res, {\n                get: function(obj, prop) {\n                    if (!canAccessRes) {\n                        const message = `You should not access 'res' after getServerSideProps resolves.` + `\\nRead more: https://nextjs.org/docs/messages/gssp-no-mutating-res`;\n                        if (deferredContent) {\n                            throw Object.defineProperty(new Error(message), \"__NEXT_ERROR_CODE\", {\n                                value: \"E394\",\n                                enumerable: false,\n                                configurable: true\n                            });\n                        } else {\n                            warn(message);\n                        }\n                    }\n                    if (typeof prop === 'symbol') {\n                        return _reflect.ReflectAdapter.get(obj, prop, res);\n                    }\n                    return _reflect.ReflectAdapter.get(obj, prop, res);\n                }\n            });\n        }\n        try {\n            data = await (0, _tracer.getTracer)().trace(_constants2.RenderSpan.getServerSideProps, {\n                spanName: `getServerSideProps ${pathname}`,\n                attributes: {\n                    'next.route': pathname\n                }\n            }, async ()=>getServerSideProps({\n                    req: req,\n                    res: resOrProxy,\n                    query,\n                    resolvedUrl: renderOpts.resolvedUrl,\n                    ...pageIsDynamic ? {\n                        params\n                    } : undefined,\n                    ...previewData !== false ? {\n                        draftMode: true,\n                        preview: true,\n                        previewData: previewData\n                    } : undefined,\n                    // We create a copy here to avoid having the types of\n                    // `getServerSideProps` change. This ensures that users can't\n                    // mutate this array and have it poison the reference.\n                    locales: [\n                        ...renderOpts.locales ?? []\n                    ],\n                    locale: renderOpts.locale,\n                    defaultLocale: renderOpts.defaultLocale\n                }));\n            canAccessRes = false;\n            metadata.cacheControl = {\n                revalidate: 0,\n                expire: undefined\n            };\n        } catch (serverSidePropsError) {\n            // remove not found error code to prevent triggering legacy\n            // 404 rendering\n            if ((0, _iserror.default)(serverSidePropsError) && serverSidePropsError.code === 'ENOENT') {\n                delete serverSidePropsError.code;\n            }\n            throw serverSidePropsError;\n        }\n        if (data == null) {\n            throw Object.defineProperty(new Error(_constants.GSSP_NO_RETURNED_VALUE), \"__NEXT_ERROR_CODE\", {\n                value: \"E394\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n        if (data.props instanceof Promise) {\n            deferredContent = true;\n        }\n        const invalidKeys = Object.keys(data).filter((key)=>key !== 'props' && key !== 'redirect' && key !== 'notFound');\n        if (data.unstable_notFound) {\n            throw Object.defineProperty(new Error(`unstable_notFound has been renamed to notFound, please update the field to continue. Page: ${pathname}`), \"__NEXT_ERROR_CODE\", {\n                value: \"E516\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n        if (data.unstable_redirect) {\n            throw Object.defineProperty(new Error(`unstable_redirect has been renamed to redirect, please update the field to continue. Page: ${pathname}`), \"__NEXT_ERROR_CODE\", {\n                value: \"E284\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n        if (invalidKeys.length) {\n            throw Object.defineProperty(new Error(invalidKeysMsg('getServerSideProps', invalidKeys)), \"__NEXT_ERROR_CODE\", {\n                value: \"E394\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n        if ('notFound' in data && data.notFound) {\n            if (pathname === '/404') {\n                throw Object.defineProperty(new Error(`The /404 page can not return notFound in \"getStaticProps\", please remove it to continue!`), \"__NEXT_ERROR_CODE\", {\n                    value: \"E121\",\n                    enumerable: false,\n                    configurable: true\n                });\n            }\n            metadata.isNotFound = true;\n            return new _renderresult.default(null, {\n                metadata\n            });\n        }\n        if ('redirect' in data && typeof data.redirect === 'object') {\n            checkRedirectValues(data.redirect, req, 'getServerSideProps');\n            data.props = {\n                __N_REDIRECT: data.redirect.destination,\n                __N_REDIRECT_STATUS: (0, _redirectstatus.getRedirectStatus)(data.redirect)\n            };\n            if (typeof data.redirect.basePath !== 'undefined') {\n                ;\n                data.props.__N_REDIRECT_BASE_PATH = data.redirect.basePath;\n            }\n            metadata.isRedirect = true;\n        }\n        if (deferredContent) {\n            ;\n            data.props = await data.props;\n        }\n        if ((dev || isBuildTimeSSG) && !(0, _isserializableprops.isSerializableProps)(pathname, 'getServerSideProps', data.props)) {\n            // this fn should throw an error instead of ever returning `false`\n            throw Object.defineProperty(new Error('invariant: getServerSideProps did not return valid props. Please report this.'), \"__NEXT_ERROR_CODE\", {\n                value: \"E31\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n        props.pageProps = Object.assign({}, props.pageProps, data.props);\n        metadata.pageData = props;\n    }\n    if (!isSSG && // we only show this warning for legacy pages\n    !getServerSideProps && process.env.NODE_ENV !== 'production' && Object.keys((props == null ? void 0 : props.pageProps) || {}).includes('url')) {\n        console.warn(`The prop \\`url\\` is a reserved prop in Next.js for legacy reasons and will be overridden on page ${pathname}\\n` + `See more info here: https://nextjs.org/docs/messages/reserved-page-prop`);\n    }\n    // Avoid rendering page un-necessarily for getServerSideProps data request\n    // and getServerSideProps/getStaticProps redirects\n    if (isNextDataRequest && !isSSG || metadata.isRedirect) {\n        return new _renderresult.default(JSON.stringify(props), {\n            metadata\n        });\n    }\n    // We don't call getStaticProps or getServerSideProps while generating\n    // the fallback so make sure to set pageProps to an empty object\n    if (isFallback) {\n        props.pageProps = {};\n    }\n    // the response might be finished on the getInitialProps call\n    if ((0, _utils.isResSent)(res) && !isSSG) return new _renderresult.default(null, {\n        metadata\n    });\n    // we preload the buildManifest for auto-export dynamic pages\n    // to speed up hydrating query values\n    let filteredBuildManifest = buildManifest;\n    if (isAutoExport && pageIsDynamic) {\n        const page = (0, _denormalizepagepath.denormalizePagePath)((0, _normalizepagepath.normalizePagePath)(pathname));\n        // This code would be much cleaner using `immer` and directly pushing into\n        // the result from `getPageFiles`, we could maybe consider that in the\n        // future.\n        if (page in filteredBuildManifest.pages) {\n            filteredBuildManifest = {\n                ...filteredBuildManifest,\n                pages: {\n                    ...filteredBuildManifest.pages,\n                    [page]: [\n                        ...filteredBuildManifest.pages[page],\n                        ...filteredBuildManifest.lowPriorityFiles.filter((f)=>f.includes('_buildManifest'))\n                    ]\n                },\n                lowPriorityFiles: filteredBuildManifest.lowPriorityFiles.filter((f)=>!f.includes('_buildManifest'))\n            };\n        }\n    }\n    const Body = ({ children })=>{\n        return inAmpMode ? children : /*#__PURE__*/ (0, _jsxruntime.jsx)(\"div\", {\n            id: \"__next\",\n            children: children\n        });\n    };\n    const renderDocument = async ()=>{\n        // For `Document`, there are two cases that we don't support:\n        // 1. Using `Document.getInitialProps` in the Edge runtime.\n        // 2. Using the class component `Document` with concurrent features.\n        const BuiltinFunctionalDocument = Document[_constants1.NEXT_BUILTIN_DOCUMENT];\n        if (process.env.NEXT_RUNTIME === 'edge' && Document.getInitialProps) {\n            // In the Edge runtime, `Document.getInitialProps` isn't supported.\n            // We throw an error here if it's customized.\n            if (BuiltinFunctionalDocument) {\n                Document = BuiltinFunctionalDocument;\n            } else {\n                throw Object.defineProperty(new Error('`getInitialProps` in Document component is not supported with the Edge Runtime.'), \"__NEXT_ERROR_CODE\", {\n                    value: \"E386\",\n                    enumerable: false,\n                    configurable: true\n                });\n            }\n        }\n        async function loadDocumentInitialProps(renderShell) {\n            const renderPage = async (options = {})=>{\n                if (ctx.err && ErrorDebug) {\n                    // Always start rendering the shell even if there's an error.\n                    if (renderShell) {\n                        renderShell(App, Component);\n                    }\n                    const html = await renderToString(/*#__PURE__*/ (0, _jsxruntime.jsx)(Body, {\n                        children: /*#__PURE__*/ (0, _jsxruntime.jsx)(ErrorDebug, {})\n                    }));\n                    return {\n                        html,\n                        head\n                    };\n                }\n                if (dev && (props.router || props.Component)) {\n                    throw Object.defineProperty(new Error(`'router' and 'Component' can not be returned in getInitialProps from _app.js https://nextjs.org/docs/messages/cant-override-next-props`), \"__NEXT_ERROR_CODE\", {\n                        value: \"E230\",\n                        enumerable: false,\n                        configurable: true\n                    });\n                }\n                const { App: EnhancedApp, Component: EnhancedComponent } = enhanceComponents(options, App, Component);\n                const stream = await renderShell(EnhancedApp, EnhancedComponent);\n                await stream.allReady;\n                const html = await (0, _nodewebstreamshelper.streamToString)(stream);\n                return {\n                    html,\n                    head\n                };\n            };\n            const documentCtx = {\n                ...ctx,\n                renderPage\n            };\n            const docProps = await (0, _utils.loadGetInitialProps)(Document, documentCtx);\n            // the response might be finished on the getInitialProps call\n            if ((0, _utils.isResSent)(res) && !isSSG) return null;\n            if (!docProps || typeof docProps.html !== 'string') {\n                const message = `\"${(0, _utils.getDisplayName)(Document)}.getInitialProps()\" should resolve to an object with a \"html\" prop set with a valid html string`;\n                throw Object.defineProperty(new Error(message), \"__NEXT_ERROR_CODE\", {\n                    value: \"E394\",\n                    enumerable: false,\n                    configurable: true\n                });\n            }\n            return {\n                docProps,\n                documentCtx\n            };\n        }\n        const renderContent = (_App, _Component)=>{\n            const EnhancedApp = _App || App;\n            const EnhancedComponent = _Component || Component;\n            return ctx.err && ErrorDebug ? /*#__PURE__*/ (0, _jsxruntime.jsx)(Body, {\n                children: /*#__PURE__*/ (0, _jsxruntime.jsx)(ErrorDebug, {})\n            }) : /*#__PURE__*/ (0, _jsxruntime.jsx)(Body, {\n                children: /*#__PURE__*/ (0, _jsxruntime.jsx)(AppContainerWithIsomorphicFiberStructure, {\n                    children: renderPageTree(EnhancedApp, EnhancedComponent, {\n                        ...props,\n                        router\n                    })\n                })\n            });\n        };\n        // Always using react concurrent rendering mode with required react version 18.x\n        const renderShell = async (EnhancedApp, EnhancedComponent)=>{\n            const content = renderContent(EnhancedApp, EnhancedComponent);\n            return await (0, _nodewebstreamshelper.renderToInitialFizzStream)({\n                ReactDOMServer: _ReactDOMServerPages.default,\n                element: content\n            });\n        };\n        const hasDocumentGetInitialProps = process.env.NEXT_RUNTIME !== 'edge' && !!Document.getInitialProps;\n        // If it has getInitialProps, we will render the shell in `renderPage`.\n        // Otherwise we do it right now.\n        let documentInitialPropsRes;\n        const [rawStyledJsxInsertedHTML, content] = await Promise.all([\n            renderToString(styledJsxInsertedHTML()),\n            (async ()=>{\n                if (hasDocumentGetInitialProps) {\n                    documentInitialPropsRes = await loadDocumentInitialProps(renderShell);\n                    if (documentInitialPropsRes === null) return null;\n                    const { docProps } = documentInitialPropsRes;\n                    return docProps.html;\n                } else {\n                    documentInitialPropsRes = {};\n                    const stream = await renderShell(App, Component);\n                    await stream.allReady;\n                    return (0, _nodewebstreamshelper.streamToString)(stream);\n                }\n            })()\n        ]);\n        if (content === null) {\n            return null;\n        }\n        const contentHTML = rawStyledJsxInsertedHTML + content;\n        // @ts-ignore: documentInitialPropsRes is set\n        const { docProps } = documentInitialPropsRes || {};\n        const documentElement = (htmlProps)=>{\n            if (process.env.NEXT_RUNTIME === 'edge') {\n                return Document();\n            } else {\n                return /*#__PURE__*/ (0, _jsxruntime.jsx)(Document, {\n                    ...htmlProps,\n                    ...docProps\n                });\n            }\n        };\n        let styles;\n        if (hasDocumentGetInitialProps) {\n            styles = docProps.styles;\n            head = docProps.head;\n        } else {\n            styles = jsxStyleRegistry.styles();\n            jsxStyleRegistry.flush();\n        }\n        return {\n            contentHTML,\n            documentElement,\n            head,\n            headTags: [],\n            styles\n        };\n    };\n    (0, _tracer.getTracer)().setRootSpanAttribute('next.route', renderOpts.page);\n    const documentResult = await (0, _tracer.getTracer)().trace(_constants2.RenderSpan.renderDocument, {\n        spanName: `render route (pages) ${renderOpts.page}`,\n        attributes: {\n            'next.route': renderOpts.page\n        }\n    }, async ()=>renderDocument());\n    if (!documentResult) {\n        return new _renderresult.default(null, {\n            metadata\n        });\n    }\n    const dynamicImportsIds = new Set();\n    const dynamicImports = new Set();\n    for (const mod of reactLoadableModules){\n        const manifestItem = reactLoadableManifest[mod];\n        if (manifestItem) {\n            dynamicImportsIds.add(manifestItem.id);\n            manifestItem.files.forEach((item)=>{\n                dynamicImports.add(item);\n            });\n        }\n    }\n    const hybridAmp = ampState.hybrid;\n    const docComponentsRendered = {};\n    const { assetPrefix, defaultLocale, disableOptimizedLoading, domainLocales, locale, locales, runtimeConfig } = renderOpts;\n    const htmlProps = {\n        __NEXT_DATA__: {\n            props,\n            page: pathname,\n            query,\n            buildId: sharedContext.buildId,\n            assetPrefix: assetPrefix === '' ? undefined : assetPrefix,\n            runtimeConfig,\n            nextExport: nextExport === true ? true : undefined,\n            autoExport: isAutoExport === true ? true : undefined,\n            isFallback,\n            isExperimentalCompile,\n            dynamicIds: dynamicImportsIds.size === 0 ? undefined : Array.from(dynamicImportsIds),\n            err: renderOpts.err ? serializeError(dev, renderOpts.err) : undefined,\n            gsp: !!getStaticProps ? true : undefined,\n            gssp: !!getServerSideProps ? true : undefined,\n            customServer: sharedContext.customServer,\n            gip: hasPageGetInitialProps ? true : undefined,\n            appGip: !defaultAppGetInitialProps ? true : undefined,\n            locale,\n            locales,\n            defaultLocale,\n            domainLocales,\n            isPreview: isPreview === true ? true : undefined,\n            notFoundSrcPage: notFoundSrcPage && dev ? notFoundSrcPage : undefined\n        },\n        strictNextHead: renderOpts.strictNextHead,\n        buildManifest: filteredBuildManifest,\n        docComponentsRendered,\n        dangerousAsPath: router.asPath,\n        canonicalBase: !renderOpts.ampPath && (0, _requestmeta.getRequestMeta)(req, 'didStripLocale') ? `${renderOpts.canonicalBase || ''}/${renderOpts.locale}` : renderOpts.canonicalBase,\n        ampPath,\n        inAmpMode,\n        isDevelopment: !!dev,\n        hybridAmp,\n        dynamicImports: Array.from(dynamicImports),\n        dynamicCssManifest: new Set(renderOpts.dynamicCssManifest || []),\n        assetPrefix,\n        // Only enabled in production as development mode has features relying on HMR (style injection for example)\n        unstable_runtimeJS: process.env.NODE_ENV === 'production' ? pageConfig.unstable_runtimeJS : undefined,\n        unstable_JsPreload: pageConfig.unstable_JsPreload,\n        assetQueryString,\n        scriptLoader,\n        locale,\n        disableOptimizedLoading,\n        head: documentResult.head,\n        headTags: documentResult.headTags,\n        styles: documentResult.styles,\n        crossOrigin: renderOpts.crossOrigin,\n        optimizeCss: renderOpts.optimizeCss,\n        nextConfigOutput: renderOpts.nextConfigOutput,\n        nextScriptWorkers: renderOpts.nextScriptWorkers,\n        runtime: globalRuntime,\n        largePageDataBytes: renderOpts.largePageDataBytes,\n        nextFontManifest: renderOpts.nextFontManifest,\n        experimentalClientTraceMetadata: renderOpts.experimental.clientTraceMetadata\n    };\n    const document = /*#__PURE__*/ (0, _jsxruntime.jsx)(_ampcontextsharedruntime.AmpStateContext.Provider, {\n        value: ampState,\n        children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_htmlcontextsharedruntime.HtmlContext.Provider, {\n            value: htmlProps,\n            children: documentResult.documentElement(htmlProps)\n        })\n    });\n    const documentHTML = await (0, _tracer.getTracer)().trace(_constants2.RenderSpan.renderToString, async ()=>renderToString(document));\n    if (process.env.NODE_ENV !== 'production') {\n        const nonRenderedComponents = [];\n        const expectedDocComponents = [\n            'Main',\n            'Head',\n            'NextScript',\n            'Html'\n        ];\n        for (const comp of expectedDocComponents){\n            if (!docComponentsRendered[comp]) {\n                nonRenderedComponents.push(comp);\n            }\n        }\n        if (nonRenderedComponents.length) {\n            const missingComponentList = nonRenderedComponents.map((e)=>`<${e} />`).join(', ');\n            const plural = nonRenderedComponents.length !== 1 ? 's' : '';\n            console.warn(`Your custom Document (pages/_document) did not render all the required subcomponent${plural}.\\n` + `Missing component${plural}: ${missingComponentList}\\n` + 'Read how to fix here: https://nextjs.org/docs/messages/missing-document-component');\n        }\n    }\n    const [renderTargetPrefix, renderTargetSuffix] = documentHTML.split('<next-js-internal-body-render-target></next-js-internal-body-render-target>', 2);\n    let prefix = '';\n    if (!documentHTML.startsWith(DOCTYPE)) {\n        prefix += DOCTYPE;\n    }\n    prefix += renderTargetPrefix;\n    if (inAmpMode) {\n        prefix += '<!-- __NEXT_DATA__ -->';\n    }\n    const content = prefix + documentResult.contentHTML + renderTargetSuffix;\n    const optimizedHtml = await postProcessHTML(pathname, content, renderOpts, {\n        inAmpMode,\n        hybridAmp\n    });\n    return new _renderresult.default(optimizedHtml, {\n        metadata\n    });\n}\nconst renderToHTML = (req, res, pathname, query, renderOpts, sharedContext, renderContext)=>{\n    return renderToHTMLImpl(req, res, pathname, query, renderOpts, renderOpts, sharedContext, renderContext);\n};\n\n//# sourceMappingURL=render.js.map"
        }
    ]
}