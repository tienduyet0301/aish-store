{
    "sourceFile": "node_modules/next/dist/server/lib/start-server.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892877809,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    getRequestHandlers: null,\n    startServer: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    getRequestHandlers: function() {\n        return getRequestHandlers;\n    },\n    startServer: function() {\n        return startServer;\n    }\n});\nconst _getnetworkhost = require(\"../../lib/get-network-host\");\nrequire(\"../next\");\nrequire(\"../require-hook\");\nconst _fs = /*#__PURE__*/ _interop_require_default(require(\"fs\"));\nconst _v8 = /*#__PURE__*/ _interop_require_default(require(\"v8\"));\nconst _path = /*#__PURE__*/ _interop_require_default(require(\"path\"));\nconst _http = /*#__PURE__*/ _interop_require_default(require(\"http\"));\nconst _https = /*#__PURE__*/ _interop_require_default(require(\"https\"));\nconst _os = /*#__PURE__*/ _interop_require_default(require(\"os\"));\nconst _watchpack = /*#__PURE__*/ _interop_require_default(require(\"next/dist/compiled/watchpack\"));\nconst _log = /*#__PURE__*/ _interop_require_wildcard(require(\"../../build/output/log\"));\nconst _debug = /*#__PURE__*/ _interop_require_default(require(\"next/dist/compiled/debug\"));\nconst _utils = require(\"./utils\");\nconst _formathostname = require(\"./format-hostname\");\nconst _routerserver = require(\"./router-server\");\nconst _constants = require(\"../../shared/lib/constants\");\nconst _appinfolog = require(\"./app-info-log\");\nconst _turbopackwarning = require(\"../../lib/turbopack-warning\");\nconst _trace = require(\"../../trace\");\nconst _ispostpone = require(\"./router-utils/is-postpone\");\nconst _isipv6 = require(\"./is-ipv6\");\nconst _asynccallbackset = require(\"./async-callback-set\");\nfunction _interop_require_default(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nfunction _getRequireWildcardCache(nodeInterop) {\n    if (typeof WeakMap !== \"function\") return null;\n    var cacheBabelInterop = new WeakMap();\n    var cacheNodeInterop = new WeakMap();\n    return (_getRequireWildcardCache = function(nodeInterop) {\n        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n    })(nodeInterop);\n}\nfunction _interop_require_wildcard(obj, nodeInterop) {\n    if (!nodeInterop && obj && obj.__esModule) {\n        return obj;\n    }\n    if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n        return {\n            default: obj\n        };\n    }\n    var cache = _getRequireWildcardCache(nodeInterop);\n    if (cache && cache.has(obj)) {\n        return cache.get(obj);\n    }\n    var newObj = {\n        __proto__: null\n    };\n    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n    for(var key in obj){\n        if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n            if (desc && (desc.get || desc.set)) {\n                Object.defineProperty(newObj, key, desc);\n            } else {\n                newObj[key] = obj[key];\n            }\n        }\n    }\n    newObj.default = obj;\n    if (cache) {\n        cache.set(obj, newObj);\n    }\n    return newObj;\n}\nif (performance.getEntriesByName('next-start').length === 0) {\n    performance.mark('next-start');\n}\nconst debug = (0, _debug.default)('next:start-server');\nlet startServerSpan;\nasync function getRequestHandlers({ dir, port, isDev, onDevServerCleanup, server, hostname, minimalMode, keepAliveTimeout, experimentalHttpsServer, quiet }) {\n    return (0, _routerserver.initialize)({\n        dir,\n        port,\n        hostname,\n        onDevServerCleanup,\n        dev: isDev,\n        minimalMode,\n        server,\n        keepAliveTimeout,\n        experimentalHttpsServer,\n        startServerSpan,\n        quiet\n    });\n}\nasync function startServer(serverOptions) {\n    const { dir, isDev, hostname, minimalMode, allowRetry, keepAliveTimeout, selfSignedCertificate } = serverOptions;\n    let { port } = serverOptions;\n    process.title = `next-server (v${\"15.3.1\"})`;\n    let handlersReady = ()=>{};\n    let handlersError = ()=>{};\n    let handlersPromise = new Promise((resolve, reject)=>{\n        handlersReady = resolve;\n        handlersError = reject;\n    });\n    let requestHandler = async (req, res)=>{\n        if (handlersPromise) {\n            await handlersPromise;\n            return requestHandler(req, res);\n        }\n        throw Object.defineProperty(new Error('Invariant request handler was not setup'), \"__NEXT_ERROR_CODE\", {\n            value: \"E287\",\n            enumerable: false,\n            configurable: true\n        });\n    };\n    let upgradeHandler = async (req, socket, head)=>{\n        if (handlersPromise) {\n            await handlersPromise;\n            return upgradeHandler(req, socket, head);\n        }\n        throw Object.defineProperty(new Error('Invariant upgrade handler was not setup'), \"__NEXT_ERROR_CODE\", {\n            value: \"E290\",\n            enumerable: false,\n            configurable: true\n        });\n    };\n    let nextServer;\n    // setup server listener as fast as possible\n    if (selfSignedCertificate && !isDev) {\n        throw Object.defineProperty(new Error('Using a self signed certificate is only supported with `next dev`.'), \"__NEXT_ERROR_CODE\", {\n            value: \"E128\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    async function requestListener(req, res) {\n        try {\n            if (handlersPromise) {\n                await handlersPromise;\n                handlersPromise = undefined;\n            }\n            await requestHandler(req, res);\n        } catch (err) {\n            res.statusCode = 500;\n            res.end('Internal Server Error');\n            _log.error(`Failed to handle request for ${req.url}`);\n            console.error(err);\n        } finally{\n            if (isDev) {\n                if (_v8.default.getHeapStatistics().used_heap_size > 0.8 * _v8.default.getHeapStatistics().heap_size_limit) {\n                    _log.warn(`Server is approaching the used memory threshold, restarting...`);\n                    (0, _trace.trace)('server-restart-close-to-memory-threshold', undefined, {\n                        'memory.heapSizeLimit': String(_v8.default.getHeapStatistics().heap_size_limit),\n                        'memory.heapUsed': String(_v8.default.getHeapStatistics().used_heap_size)\n                    }).stop();\n                    await (0, _trace.flushAllTraces)();\n                    process.exit(_utils.RESTART_EXIT_CODE);\n                }\n            }\n        }\n    }\n    const server = selfSignedCertificate ? _https.default.createServer({\n        key: _fs.default.readFileSync(selfSignedCertificate.key),\n        cert: _fs.default.readFileSync(selfSignedCertificate.cert)\n    }, requestListener) : _http.default.createServer(requestListener);\n    if (keepAliveTimeout) {\n        server.keepAliveTimeout = keepAliveTimeout;\n    }\n    server.on('upgrade', async (req, socket, head)=>{\n        try {\n            await upgradeHandler(req, socket, head);\n        } catch (err) {\n            socket.destroy();\n            _log.error(`Failed to handle request for ${req.url}`);\n            console.error(err);\n        }\n    });\n    let portRetryCount = 0;\n    const originalPort = port;\n    server.on('error', (err)=>{\n        if (allowRetry && port && isDev && err.code === 'EADDRINUSE' && portRetryCount < 10) {\n            port += 1;\n            portRetryCount += 1;\n            server.listen(port, hostname);\n        } else {\n            _log.error(`Failed to start server`);\n            console.error(err);\n            process.exit(1);\n        }\n    });\n    let cleanupListeners = isDev ? new _asynccallbackset.AsyncCallbackSet() : undefined;\n    await new Promise((resolve)=>{\n        server.on('listening', async ()=>{\n            const nodeDebugType = (0, _utils.getNodeDebugType)();\n            const addr = server.address();\n            const actualHostname = (0, _formathostname.formatHostname)(typeof addr === 'object' ? (addr == null ? void 0 : addr.address) || hostname || 'localhost' : addr);\n            const formattedHostname = !hostname || actualHostname === '0.0.0.0' ? 'localhost' : actualHostname === '[::]' ? '[::1]' : (0, _formathostname.formatHostname)(hostname);\n            port = typeof addr === 'object' ? (addr == null ? void 0 : addr.port) || port : port;\n            if (portRetryCount) {\n                _log.warn(`Port ${originalPort} is in use, using available port ${port} instead.`);\n            }\n            const networkHostname = hostname ?? (0, _getnetworkhost.getNetworkHost)((0, _isipv6.isIPv6)(actualHostname) ? 'IPv6' : 'IPv4');\n            const protocol = selfSignedCertificate ? 'https' : 'http';\n            const networkUrl = networkHostname ? `${protocol}://${(0, _formathostname.formatHostname)(networkHostname)}:${port}` : null;\n            const appUrl = `${protocol}://${formattedHostname}:${port}`;\n            if (nodeDebugType) {\n                const formattedDebugAddress = (0, _utils.getFormattedDebugAddress)();\n                _log.info(`the --${nodeDebugType} option was detected, the Next.js router server should be inspected at ${formattedDebugAddress}.`);\n            }\n            // Store the selected port to:\n            // - expose it to render workers\n            // - re-use it for automatic dev server restarts with a randomly selected port\n            process.env.PORT = port + '';\n            process.env.__NEXT_PRIVATE_ORIGIN = appUrl;\n            // Only load env and config in dev to for logging purposes\n            let envInfo;\n            let experimentalFeatures;\n            if (isDev) {\n                const startServerInfo = await (0, _appinfolog.getStartServerInfo)(dir, isDev);\n                envInfo = startServerInfo.envInfo;\n                experimentalFeatures = startServerInfo.experimentalFeatures;\n            }\n            (0, _appinfolog.logStartInfo)({\n                networkUrl,\n                appUrl,\n                envInfo,\n                experimentalFeatures,\n                maxExperimentalFeatures: 3\n            });\n            _log.event(`Starting...`);\n            try {\n                let cleanupStarted = false;\n                let closeUpgraded = null;\n                const cleanup = ()=>{\n                    if (cleanupStarted) {\n                        // We can get duplicate signals, e.g. when `ctrl+c` is used in an\n                        // interactive shell (i.e. bash, zsh), the shell will recursively\n                        // send SIGINT to children. The parent `next-dev` process will also\n                        // send us SIGINT.\n                        return;\n                    }\n                    cleanupStarted = true;\n                    (async ()=>{\n                        debug('start-server process cleanup');\n                        // first, stop accepting new connections and finish pending requests,\n                        // because they might affect `nextServer.close()` (e.g. by scheduling an `after`)\n                        await new Promise((res)=>{\n                            server.close((err)=>{\n                                if (err) console.error(err);\n                                res();\n                            });\n                            if (isDev) {\n                                server.closeAllConnections();\n                                closeUpgraded == null ? void 0 : closeUpgraded();\n                            }\n                        });\n                        // now that no new requests can come in, clean up the rest\n                        await Promise.all([\n                            nextServer == null ? void 0 : nextServer.close().catch(console.error),\n                            cleanupListeners == null ? void 0 : cleanupListeners.runAll().catch(console.error)\n                        ]);\n                        debug('start-server process cleanup finished');\n                        process.exit(0);\n                    })();\n                };\n                const exception = (err)=>{\n                    if ((0, _ispostpone.isPostpone)(err)) {\n                        // React postpones that are unhandled might end up logged here but they're\n                        // not really errors. They're just part of rendering.\n                        return;\n                    }\n                    // This is the render worker, we keep the process alive\n                    console.error(err);\n                };\n                // Make sure commands gracefully respect termination signals (e.g. from Docker)\n                // Allow the graceful termination to be manually configurable\n                if (!process.env.NEXT_MANUAL_SIG_HANDLE) {\n                    process.on('SIGINT', cleanup);\n                    process.on('SIGTERM', cleanup);\n                }\n                process.on('rejectionHandled', ()=>{\n                // It is ok to await a Promise late in Next.js as it allows for better\n                // prefetching patterns to avoid waterfalls. We ignore loggining these.\n                // We should've already errored in anyway unhandledRejection.\n                });\n                process.on('uncaughtException', exception);\n                process.on('unhandledRejection', exception);\n                const initResult = await getRequestHandlers({\n                    dir,\n                    port,\n                    isDev,\n                    onDevServerCleanup: cleanupListeners ? cleanupListeners.add.bind(cleanupListeners) : undefined,\n                    server,\n                    hostname,\n                    minimalMode,\n                    keepAliveTimeout,\n                    experimentalHttpsServer: !!selfSignedCertificate\n                });\n                requestHandler = initResult.requestHandler;\n                upgradeHandler = initResult.upgradeHandler;\n                nextServer = initResult.server;\n                closeUpgraded = initResult.closeUpgraded;\n                const startServerProcessDuration = performance.mark('next-start-end') && performance.measure('next-start-duration', 'next-start', 'next-start-end').duration;\n                handlersReady();\n                const formatDurationText = startServerProcessDuration > 2000 ? `${Math.round(startServerProcessDuration / 100) / 10}s` : `${Math.round(startServerProcessDuration)}ms`;\n                _log.event(`Ready in ${formatDurationText}`);\n                if (process.env.TURBOPACK) {\n                    await (0, _turbopackwarning.validateTurboNextConfig)({\n                        dir: serverOptions.dir,\n                        isDev: true\n                    });\n                }\n            } catch (err) {\n                // fatal error if we can't setup\n                handlersError();\n                console.error(err);\n                process.exit(1);\n            }\n            resolve();\n        });\n        server.listen(port, hostname);\n    });\n    if (isDev) {\n        function watchConfigFiles(dirToWatch, onChange) {\n            const wp = new _watchpack.default();\n            wp.watch({\n                files: _constants.CONFIG_FILES.map((file)=>_path.default.join(dirToWatch, file))\n            });\n            wp.on('change', onChange);\n        }\n        watchConfigFiles(dir, async (filename)=>{\n            if (process.env.__NEXT_DISABLE_MEMORY_WATCHER) {\n                _log.info(`Detected change, manual restart required due to '__NEXT_DISABLE_MEMORY_WATCHER' usage`);\n                return;\n            }\n            _log.warn(`Found a change in ${_path.default.basename(filename)}. Restarting the server to apply the changes...`);\n            process.exit(_utils.RESTART_EXIT_CODE);\n        });\n    }\n}\nif (process.env.NEXT_PRIVATE_WORKER && process.send) {\n    process.addListener('message', async (msg)=>{\n        if (msg && typeof msg === 'object' && msg.nextWorkerOptions && process.send) {\n            startServerSpan = (0, _trace.trace)('start-dev-server', undefined, {\n                cpus: String(_os.default.cpus().length),\n                platform: _os.default.platform(),\n                'memory.freeMem': String(_os.default.freemem()),\n                'memory.totalMem': String(_os.default.totalmem()),\n                'memory.heapSizeLimit': String(_v8.default.getHeapStatistics().heap_size_limit)\n            });\n            await startServerSpan.traceAsyncFn(()=>startServer(msg.nextWorkerOptions));\n            const memoryUsage = process.memoryUsage();\n            startServerSpan.setAttribute('memory.rss', String(memoryUsage.rss));\n            startServerSpan.setAttribute('memory.heapTotal', String(memoryUsage.heapTotal));\n            startServerSpan.setAttribute('memory.heapUsed', String(memoryUsage.heapUsed));\n            process.send({\n                nextServerReady: true,\n                port: process.env.PORT\n            });\n        }\n    });\n    process.send({\n        nextWorkerReady: true\n    });\n}\n\n//# sourceMappingURL=start-server.js.map"
        }
    ]
}