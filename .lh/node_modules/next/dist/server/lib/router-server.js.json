{
    "sourceFile": "node_modules/next/dist/server/lib/router-server.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892876888,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "// this must come first as it includes require hooks\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"initialize\", {\n    enumerable: true,\n    get: function() {\n        return initialize;\n    }\n});\nrequire(\"../node-environment\");\nrequire(\"../require-hook\");\nconst _url = /*#__PURE__*/ _interop_require_default(require(\"url\"));\nconst _path = /*#__PURE__*/ _interop_require_default(require(\"path\"));\nconst _config = /*#__PURE__*/ _interop_require_default(require(\"../config\"));\nconst _servestatic = require(\"../serve-static\");\nconst _debug = /*#__PURE__*/ _interop_require_default(require(\"next/dist/compiled/debug\"));\nconst _log = /*#__PURE__*/ _interop_require_wildcard(require(\"../../build/output/log\"));\nconst _utils = require(\"../../shared/lib/utils\");\nconst _findpagesdir = require(\"../../lib/find-pages-dir\");\nconst _filesystem = require(\"./router-utils/filesystem\");\nconst _proxyrequest = require(\"./router-utils/proxy-request\");\nconst _pipereadable = require(\"../pipe-readable\");\nconst _resolveroutes = require(\"./router-utils/resolve-routes\");\nconst _requestmeta = require(\"../request-meta\");\nconst _pathhasprefix = require(\"../../shared/lib/router/utils/path-has-prefix\");\nconst _removepathprefix = require(\"../../shared/lib/router/utils/remove-path-prefix\");\nconst _compression = /*#__PURE__*/ _interop_require_default(require(\"next/dist/compiled/compression\"));\nconst _baseserver = require(\"../base-server\");\nconst _nextrequest = require(\"../web/spec-extension/adapters/next-request\");\nconst _ispostpone = require(\"./router-utils/is-postpone\");\nconst _parseurl = require(\"../../shared/lib/router/utils/parse-url\");\nconst _constants = require(\"../../shared/lib/constants\");\nconst _redirectstatuscode = require(\"../../client/components/redirect-status-code\");\nconst _devbundlerservice = require(\"./dev-bundler-service\");\nconst _trace = require(\"../../trace\");\nconst _ensureleadingslash = require(\"../../shared/lib/page-path/ensure-leading-slash\");\nconst _getnextpathnameinfo = require(\"../../shared/lib/router/utils/get-next-pathname-info\");\nconst _gethostname = require(\"../../shared/lib/get-hostname\");\nconst _detectdomainlocale = require(\"../../shared/lib/i18n/detect-domain-locale\");\nconst _mockrequest = require(\"./mock-request\");\nconst _hotreloadertypes = require(\"../dev/hot-reloader-types\");\nconst _normalizedassetprefix = require(\"../../shared/lib/normalized-asset-prefix\");\nconst _patchfetch = require(\"./patch-fetch\");\nconst _utils1 = require(\"./server-ipc/utils\");\nconst _blockcrosssite = require(\"./router-utils/block-cross-site\");\nconst _shared = require(\"../../trace/shared\");\nfunction _interop_require_default(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nfunction _getRequireWildcardCache(nodeInterop) {\n    if (typeof WeakMap !== \"function\") return null;\n    var cacheBabelInterop = new WeakMap();\n    var cacheNodeInterop = new WeakMap();\n    return (_getRequireWildcardCache = function(nodeInterop) {\n        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n    })(nodeInterop);\n}\nfunction _interop_require_wildcard(obj, nodeInterop) {\n    if (!nodeInterop && obj && obj.__esModule) {\n        return obj;\n    }\n    if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n        return {\n            default: obj\n        };\n    }\n    var cache = _getRequireWildcardCache(nodeInterop);\n    if (cache && cache.has(obj)) {\n        return cache.get(obj);\n    }\n    var newObj = {\n        __proto__: null\n    };\n    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n    for(var key in obj){\n        if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n            if (desc && (desc.get || desc.set)) {\n                Object.defineProperty(newObj, key, desc);\n            } else {\n                newObj[key] = obj[key];\n            }\n        }\n    }\n    newObj.default = obj;\n    if (cache) {\n        cache.set(obj, newObj);\n    }\n    return newObj;\n}\nconst debug = (0, _debug.default)('next:router-server:main');\nconst isNextFont = (pathname)=>pathname && /\\/media\\/[^/]+\\.(woff|woff2|eot|ttf|otf)$/.test(pathname);\nconst requestHandlers = {};\nasync function initialize(opts) {\n    if (!process.env.NODE_ENV) {\n        // @ts-ignore not readonly\n        process.env.NODE_ENV = opts.dev ? 'development' : 'production';\n    }\n    const config = await (0, _config.default)(opts.dev ? _constants.PHASE_DEVELOPMENT_SERVER : _constants.PHASE_PRODUCTION_SERVER, opts.dir, {\n        silent: false\n    });\n    let compress;\n    if ((config == null ? void 0 : config.compress) !== false) {\n        compress = (0, _compression.default)();\n    }\n    const fsChecker = await (0, _filesystem.setupFsCheck)({\n        dev: opts.dev,\n        dir: opts.dir,\n        config,\n        minimalMode: opts.minimalMode\n    });\n    const renderServer = {};\n    let developmentBundler;\n    let devBundlerService;\n    let originalFetch = globalThis.fetch;\n    if (opts.dev) {\n        const { Telemetry } = require('../../telemetry/storage');\n        const telemetry = new Telemetry({\n            distDir: _path.default.join(opts.dir, config.distDir)\n        });\n        _shared.traceGlobals.set('telemetry', telemetry);\n        const { pagesDir, appDir } = (0, _findpagesdir.findPagesDir)(opts.dir);\n        const { setupDevBundler } = require('./router-utils/setup-dev-bundler');\n        const resetFetch = ()=>{\n            globalThis.fetch = originalFetch;\n            globalThis[_patchfetch.NEXT_PATCH_SYMBOL] = false;\n        };\n        const setupDevBundlerSpan = opts.startServerSpan ? opts.startServerSpan.traceChild('setup-dev-bundler') : (0, _trace.trace)('setup-dev-bundler');\n        developmentBundler = await setupDevBundlerSpan.traceAsyncFn(()=>setupDevBundler({\n                // Passed here but the initialization of this object happens below, doing the initialization before the setupDev call breaks.\n                renderServer,\n                appDir,\n                pagesDir,\n                telemetry,\n                fsChecker,\n                dir: opts.dir,\n                nextConfig: config,\n                isCustomServer: opts.customServer,\n                turbo: !!process.env.TURBOPACK,\n                port: opts.port,\n                onDevServerCleanup: opts.onDevServerCleanup,\n                resetFetch\n            }));\n        devBundlerService = new _devbundlerservice.DevBundlerService(developmentBundler, // The request handler is assigned below, this allows us to create a lazy\n        // reference to it.\n        (req, res)=>{\n            return requestHandlers[opts.dir](req, res);\n        });\n    }\n    renderServer.instance = require('./render-server');\n    const requestHandlerImpl = async (req, res)=>{\n        // internal headers should not be honored by the request handler\n        if (!process.env.NEXT_PRIVATE_TEST_HEADERS) {\n            (0, _utils1.filterInternalHeaders)(req.headers);\n        }\n        if (!opts.minimalMode && config.i18n && config.i18n.localeDetection !== false) {\n            var _this;\n            const urlParts = (req.url || '').split('?', 1);\n            let urlNoQuery = urlParts[0] || '';\n            if (config.basePath) {\n                urlNoQuery = (0, _removepathprefix.removePathPrefix)(urlNoQuery, config.basePath);\n            }\n            const pathnameInfo = (0, _getnextpathnameinfo.getNextPathnameInfo)(urlNoQuery, {\n                nextConfig: config\n            });\n            const domainLocale = (0, _detectdomainlocale.detectDomainLocale)(config.i18n.domains, (0, _gethostname.getHostname)({\n                hostname: urlNoQuery\n            }, req.headers));\n            const defaultLocale = (domainLocale == null ? void 0 : domainLocale.defaultLocale) || config.i18n.defaultLocale;\n            const { getLocaleRedirect } = require('../../shared/lib/i18n/get-locale-redirect');\n            const parsedUrl = (0, _parseurl.parseUrl)((_this = req.url || '') == null ? void 0 : _this.replace(/^\\/+/, '/'));\n            const redirect = getLocaleRedirect({\n                defaultLocale,\n                domainLocale,\n                headers: req.headers,\n                nextConfig: config,\n                pathLocale: pathnameInfo.locale,\n                urlParsed: {\n                    ...parsedUrl,\n                    pathname: pathnameInfo.locale ? `/${pathnameInfo.locale}${urlNoQuery}` : urlNoQuery\n                }\n            });\n            if (redirect) {\n                res.setHeader('Location', redirect);\n                res.statusCode = _redirectstatuscode.RedirectStatusCode.TemporaryRedirect;\n                res.end(redirect);\n                return;\n            }\n        }\n        if (compress) {\n            // @ts-expect-error not express req/res\n            compress(req, res, ()=>{});\n        }\n        req.on('error', (_err)=>{\n        // TODO: log socket errors?\n        });\n        res.on('error', (_err)=>{\n        // TODO: log socket errors?\n        });\n        const invokedOutputs = new Set();\n        async function invokeRender(parsedUrl, invokePath, handleIndex, additionalRequestMeta) {\n            var _fsChecker_getMiddlewareMatchers;\n            // invokeRender expects /api routes to not be locale prefixed\n            // so normalize here before continuing\n            if (config.i18n && (0, _removepathprefix.removePathPrefix)(invokePath, config.basePath).startsWith(`/${(0, _requestmeta.getRequestMeta)(req, 'locale')}/api`)) {\n                invokePath = fsChecker.handleLocale((0, _removepathprefix.removePathPrefix)(invokePath, config.basePath)).pathname;\n            }\n            if (req.headers['x-nextjs-data'] && ((_fsChecker_getMiddlewareMatchers = fsChecker.getMiddlewareMatchers()) == null ? void 0 : _fsChecker_getMiddlewareMatchers.length) && (0, _removepathprefix.removePathPrefix)(invokePath, config.basePath) === '/404') {\n                res.setHeader('x-nextjs-matched-path', parsedUrl.pathname || '');\n                res.statusCode = 404;\n                res.setHeader('content-type', 'application/json');\n                res.end('{}');\n                return null;\n            }\n            if (!handlers) {\n                throw Object.defineProperty(new Error('Failed to initialize render server'), \"__NEXT_ERROR_CODE\", {\n                    value: \"E90\",\n                    enumerable: false,\n                    configurable: true\n                });\n            }\n            (0, _requestmeta.addRequestMeta)(req, 'invokePath', invokePath);\n            (0, _requestmeta.addRequestMeta)(req, 'invokeQuery', parsedUrl.query);\n            (0, _requestmeta.addRequestMeta)(req, 'middlewareInvoke', false);\n            for(const key in additionalRequestMeta || {}){\n                (0, _requestmeta.addRequestMeta)(req, key, additionalRequestMeta[key]);\n            }\n            debug('invokeRender', req.url, req.headers);\n            try {\n                var _renderServer_instance;\n                const initResult = await (renderServer == null ? void 0 : (_renderServer_instance = renderServer.instance) == null ? void 0 : _renderServer_instance.initialize(renderServerOpts));\n                try {\n                    await (initResult == null ? void 0 : initResult.requestHandler(req, res));\n                } catch (err) {\n                    if (err instanceof _baseserver.NoFallbackError) {\n                        // eslint-disable-next-line\n                        await handleRequest(handleIndex + 1);\n                        return;\n                    }\n                    throw err;\n                }\n                return;\n            } catch (e) {\n                // If the client aborts before we can receive a response object (when\n                // the headers are flushed), then we can early exit without further\n                // processing.\n                if ((0, _pipereadable.isAbortError)(e)) {\n                    return;\n                }\n                throw e;\n            }\n        }\n        const handleRequest = async (handleIndex)=>{\n            if (handleIndex > 5) {\n                throw Object.defineProperty(new Error(`Attempted to handle request too many times ${req.url}`), \"__NEXT_ERROR_CODE\", {\n                    value: \"E283\",\n                    enumerable: false,\n                    configurable: true\n                });\n            }\n            // handle hot-reloader first\n            if (developmentBundler) {\n                if ((0, _blockcrosssite.blockCrossSite)(req, res, config.allowedDevOrigins, opts.hostname)) {\n                    return;\n                }\n                const origUrl = req.url || '/';\n                if (config.basePath && (0, _pathhasprefix.pathHasPrefix)(origUrl, config.basePath)) {\n                    req.url = (0, _removepathprefix.removePathPrefix)(origUrl, config.basePath);\n                }\n                const parsedUrl = _url.default.parse(req.url || '/');\n                const hotReloaderResult = await developmentBundler.hotReloader.run(req, res, parsedUrl);\n                if (hotReloaderResult.finished) {\n                    return hotReloaderResult;\n                }\n                req.url = origUrl;\n            }\n            const { finished, parsedUrl, statusCode, resHeaders, bodyStream, matchedOutput } = await resolveRoutes({\n                req,\n                res,\n                isUpgradeReq: false,\n                signal: (0, _nextrequest.signalFromNodeResponse)(res),\n                invokedOutputs\n            });\n            if (res.closed || res.finished) {\n                return;\n            }\n            if (developmentBundler && (matchedOutput == null ? void 0 : matchedOutput.type) === 'devVirtualFsItem') {\n                const origUrl = req.url || '/';\n                if (config.basePath && (0, _pathhasprefix.pathHasPrefix)(origUrl, config.basePath)) {\n                    req.url = (0, _removepathprefix.removePathPrefix)(origUrl, config.basePath);\n                }\n                if (resHeaders) {\n                    for (const key of Object.keys(resHeaders)){\n                        res.setHeader(key, resHeaders[key]);\n                    }\n                }\n                const result = await developmentBundler.requestHandler(req, res);\n                if (result.finished) {\n                    return;\n                }\n                // TODO: throw invariant if we resolved to this but it wasn't handled?\n                req.url = origUrl;\n            }\n            debug('requestHandler!', req.url, {\n                matchedOutput,\n                statusCode,\n                resHeaders,\n                bodyStream: !!bodyStream,\n                parsedUrl: {\n                    pathname: parsedUrl.pathname,\n                    query: parsedUrl.query\n                },\n                finished\n            });\n            // apply any response headers from routing\n            for (const key of Object.keys(resHeaders || {})){\n                res.setHeader(key, resHeaders[key]);\n            }\n            // handle redirect\n            if (!bodyStream && statusCode && statusCode > 300 && statusCode < 400) {\n                const destination = _url.default.format(parsedUrl);\n                res.statusCode = statusCode;\n                res.setHeader('location', destination);\n                if (statusCode === _redirectstatuscode.RedirectStatusCode.PermanentRedirect) {\n                    res.setHeader('Refresh', `0;url=${destination}`);\n                }\n                return res.end(destination);\n            }\n            // handle middleware body response\n            if (bodyStream) {\n                res.statusCode = statusCode || 200;\n                return await (0, _pipereadable.pipeToNodeResponse)(bodyStream, res);\n            }\n            if (finished && parsedUrl.protocol) {\n                var _getRequestMeta;\n                return await (0, _proxyrequest.proxyRequest)(req, res, parsedUrl, undefined, (_getRequestMeta = (0, _requestmeta.getRequestMeta)(req, 'clonableBody')) == null ? void 0 : _getRequestMeta.cloneBodyStream(), config.experimental.proxyTimeout);\n            }\n            if ((matchedOutput == null ? void 0 : matchedOutput.fsPath) && matchedOutput.itemPath) {\n                if (opts.dev && (fsChecker.appFiles.has(matchedOutput.itemPath) || fsChecker.pageFiles.has(matchedOutput.itemPath))) {\n                    res.statusCode = 500;\n                    const message = `A conflicting public file and page file was found for path ${matchedOutput.itemPath} https://nextjs.org/docs/messages/conflicting-public-file-page`;\n                    await invokeRender(parsedUrl, '/_error', handleIndex, {\n                        invokeStatus: 500,\n                        invokeError: Object.defineProperty(new Error(message), \"__NEXT_ERROR_CODE\", {\n                            value: \"E394\",\n                            enumerable: false,\n                            configurable: true\n                        })\n                    });\n                    _log.error(message);\n                    return;\n                }\n                if (!res.getHeader('cache-control') && matchedOutput.type === 'nextStaticFolder') {\n                    if (opts.dev && !isNextFont(parsedUrl.pathname)) {\n                        res.setHeader('Cache-Control', 'no-store, must-revalidate');\n                    } else {\n                        res.setHeader('Cache-Control', 'public, max-age=31536000, immutable');\n                    }\n                }\n                if (!(req.method === 'GET' || req.method === 'HEAD')) {\n                    res.setHeader('Allow', [\n                        'GET',\n                        'HEAD'\n                    ]);\n                    res.statusCode = 405;\n                    return await invokeRender(_url.default.parse('/405', true), '/405', handleIndex, {\n                        invokeStatus: 405\n                    });\n                }\n                try {\n                    return await (0, _servestatic.serveStatic)(req, res, matchedOutput.itemPath, {\n                        root: matchedOutput.itemsRoot,\n                        // Ensures that etags are not generated for static files when disabled.\n                        etag: config.generateEtags\n                    });\n                } catch (err) {\n                    /**\n           * Hardcoded every possible error status code that could be thrown by \"serveStatic\" method\n           * This is done by searching \"this.error\" inside \"send\" module's source code:\n           * https://github.com/pillarjs/send/blob/master/index.js\n           * https://github.com/pillarjs/send/blob/develop/index.js\n           */ const POSSIBLE_ERROR_CODE_FROM_SERVE_STATIC = new Set([\n                        // send module will throw 500 when header is already sent or fs.stat error happens\n                        // https://github.com/pillarjs/send/blob/53f0ab476145670a9bdd3dc722ab2fdc8d358fc6/index.js#L392\n                        // Note: we will use Next.js built-in 500 page to handle 500 errors\n                        // 500,\n                        // send module will throw 404 when file is missing\n                        // https://github.com/pillarjs/send/blob/53f0ab476145670a9bdd3dc722ab2fdc8d358fc6/index.js#L421\n                        // Note: we will use Next.js built-in 404 page to handle 404 errors\n                        // 404,\n                        // send module will throw 403 when redirecting to a directory without enabling directory listing\n                        // https://github.com/pillarjs/send/blob/53f0ab476145670a9bdd3dc722ab2fdc8d358fc6/index.js#L484\n                        // Note: Next.js throws a different error (without status code) for directory listing\n                        // 403,\n                        // send module will throw 400 when fails to normalize the path\n                        // https://github.com/pillarjs/send/blob/53f0ab476145670a9bdd3dc722ab2fdc8d358fc6/index.js#L520\n                        400,\n                        // send module will throw 412 with conditional GET request\n                        // https://github.com/pillarjs/send/blob/53f0ab476145670a9bdd3dc722ab2fdc8d358fc6/index.js#L632\n                        412,\n                        // send module will throw 416 when range is not satisfiable\n                        // https://github.com/pillarjs/send/blob/53f0ab476145670a9bdd3dc722ab2fdc8d358fc6/index.js#L669\n                        416\n                    ]);\n                    let validErrorStatus = POSSIBLE_ERROR_CODE_FROM_SERVE_STATIC.has(err.statusCode);\n                    // normalize non-allowed status codes\n                    if (!validErrorStatus) {\n                        ;\n                        err.statusCode = 400;\n                    }\n                    if (typeof err.statusCode === 'number') {\n                        const invokePath = `/${err.statusCode}`;\n                        const invokeStatus = err.statusCode;\n                        res.statusCode = err.statusCode;\n                        return await invokeRender(_url.default.parse(invokePath, true), invokePath, handleIndex, {\n                            invokeStatus\n                        });\n                    }\n                    throw err;\n                }\n            }\n            if (matchedOutput) {\n                invokedOutputs.add(matchedOutput.itemPath);\n                return await invokeRender(parsedUrl, parsedUrl.pathname || '/', handleIndex, {\n                    invokeOutput: matchedOutput.itemPath\n                });\n            }\n            // 404 case\n            res.setHeader('Cache-Control', 'private, no-cache, no-store, max-age=0, must-revalidate');\n            // Short-circuit favicon.ico serving so that the 404 page doesn't get built as favicon is requested by the browser when loading any route.\n            if (opts.dev && !matchedOutput && parsedUrl.pathname === '/favicon.ico') {\n                res.statusCode = 404;\n                res.end('');\n                return null;\n            }\n            const appNotFound = opts.dev ? developmentBundler == null ? void 0 : developmentBundler.serverFields.hasAppNotFound : await fsChecker.getItem(_constants.UNDERSCORE_NOT_FOUND_ROUTE);\n            res.statusCode = 404;\n            if (appNotFound) {\n                return await invokeRender(parsedUrl, _constants.UNDERSCORE_NOT_FOUND_ROUTE, handleIndex, {\n                    invokeStatus: 404\n                });\n            }\n            await invokeRender(parsedUrl, '/404', handleIndex, {\n                invokeStatus: 404\n            });\n        };\n        try {\n            await handleRequest(0);\n        } catch (err) {\n            try {\n                let invokePath = '/500';\n                let invokeStatus = '500';\n                if (err instanceof _utils.DecodeError) {\n                    invokePath = '/400';\n                    invokeStatus = '400';\n                } else {\n                    console.error(err);\n                }\n                res.statusCode = Number(invokeStatus);\n                return await invokeRender(_url.default.parse(invokePath, true), invokePath, 0, {\n                    invokeStatus: res.statusCode\n                });\n            } catch (err2) {\n                console.error(err2);\n            }\n            res.statusCode = 500;\n            res.end('Internal Server Error');\n        }\n    };\n    let requestHandler = requestHandlerImpl;\n    if (config.experimental.testProxy) {\n        // Intercept fetch and other testmode apis.\n        const { wrapRequestHandlerWorker, interceptTestApis } = require('next/dist/experimental/testmode/server');\n        requestHandler = wrapRequestHandlerWorker(requestHandler);\n        interceptTestApis();\n        // We treat the intercepted fetch as \"original\" fetch that should be reset to during HMR.\n        originalFetch = globalThis.fetch;\n    }\n    requestHandlers[opts.dir] = requestHandler;\n    const renderServerOpts = {\n        port: opts.port,\n        dir: opts.dir,\n        hostname: opts.hostname,\n        minimalMode: opts.minimalMode,\n        dev: !!opts.dev,\n        server: opts.server,\n        serverFields: {\n            ...(developmentBundler == null ? void 0 : developmentBundler.serverFields) || {},\n            setIsrStatus: devBundlerService == null ? void 0 : devBundlerService.setIsrStatus.bind(devBundlerService)\n        },\n        experimentalTestProxy: !!config.experimental.testProxy,\n        experimentalHttpsServer: !!opts.experimentalHttpsServer,\n        bundlerService: devBundlerService,\n        startServerSpan: opts.startServerSpan,\n        quiet: opts.quiet,\n        onDevServerCleanup: opts.onDevServerCleanup\n    };\n    renderServerOpts.serverFields.routerServerHandler = requestHandlerImpl;\n    // pre-initialize workers\n    const handlers = await renderServer.instance.initialize(renderServerOpts);\n    const logError = async (type, err)=>{\n        if ((0, _ispostpone.isPostpone)(err)) {\n            // React postpones that are unhandled might end up logged here but they're\n            // not really errors. They're just part of rendering.\n            return;\n        }\n        if (type === 'unhandledRejection') {\n            _log.error('unhandledRejection: ', err);\n        } else if (type === 'uncaughtException') {\n            _log.error('uncaughtException: ', err);\n        }\n    };\n    process.on('uncaughtException', logError.bind(null, 'uncaughtException'));\n    process.on('unhandledRejection', logError.bind(null, 'unhandledRejection'));\n    const resolveRoutes = (0, _resolveroutes.getResolveRoutes)(fsChecker, config, opts, renderServer.instance, renderServerOpts, developmentBundler == null ? void 0 : developmentBundler.ensureMiddleware);\n    const upgradeHandler = async (req, socket, head)=>{\n        try {\n            req.on('error', (_err)=>{\n            // TODO: log socket errors?\n            // console.error(_err);\n            });\n            socket.on('error', (_err)=>{\n            // TODO: log socket errors?\n            // console.error(_err);\n            });\n            if (opts.dev && developmentBundler && req.url) {\n                if ((0, _blockcrosssite.blockCrossSite)(req, socket, config.allowedDevOrigins, opts.hostname)) {\n                    return;\n                }\n                const { basePath, assetPrefix } = config;\n                let hmrPrefix = basePath;\n                // assetPrefix overrides basePath for HMR path\n                if (assetPrefix) {\n                    hmrPrefix = (0, _normalizedassetprefix.normalizedAssetPrefix)(assetPrefix);\n                    if (URL.canParse(hmrPrefix)) {\n                        // remove trailing slash from pathname\n                        // return empty string if pathname is '/'\n                        // to avoid conflicts with '/_next' below\n                        hmrPrefix = new URL(hmrPrefix).pathname.replace(/\\/$/, '');\n                    }\n                }\n                const isHMRRequest = req.url.startsWith((0, _ensureleadingslash.ensureLeadingSlash)(`${hmrPrefix}/_next/webpack-hmr`));\n                // only handle HMR requests if the basePath in the request\n                // matches the basePath for the handler responding to the request\n                if (isHMRRequest) {\n                    return developmentBundler.hotReloader.onHMR(req, socket, head, (client)=>{\n                        client.send(JSON.stringify({\n                            action: _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.ISR_MANIFEST,\n                            data: (devBundlerService == null ? void 0 : devBundlerService.appIsrManifest) || {}\n                        }));\n                    });\n                }\n            }\n            const res = new _mockrequest.MockedResponse({\n                resWriter: ()=>{\n                    throw Object.defineProperty(new Error('Invariant: did not expect response writer to be written to for upgrade request'), \"__NEXT_ERROR_CODE\", {\n                        value: \"E522\",\n                        enumerable: false,\n                        configurable: true\n                    });\n                }\n            });\n            const { matchedOutput, parsedUrl } = await resolveRoutes({\n                req,\n                res,\n                isUpgradeReq: true,\n                signal: (0, _nextrequest.signalFromNodeResponse)(socket)\n            });\n            // TODO: allow upgrade requests to pages/app paths?\n            // this was not previously supported\n            if (matchedOutput) {\n                return socket.end();\n            }\n            if (parsedUrl.protocol) {\n                return await (0, _proxyrequest.proxyRequest)(req, socket, parsedUrl, head);\n            }\n        // If there's no matched output, we don't handle the request as user's\n        // custom WS server may be listening on the same path.\n        } catch (err) {\n            console.error('Error handling upgrade request', err);\n            socket.end();\n        }\n    };\n    return {\n        requestHandler,\n        upgradeHandler,\n        server: handlers.server,\n        closeUpgraded () {\n            var _developmentBundler_hotReloader;\n            developmentBundler == null ? void 0 : (_developmentBundler_hotReloader = developmentBundler.hotReloader) == null ? void 0 : _developmentBundler_hotReloader.close();\n        }\n    };\n}\n\n//# sourceMappingURL=router-server.js.map"
        }
    ]
}