{
    "sourceFile": "node_modules/next/dist/server/lib/router-utils/setup-dev-bundler.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892877536,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    propagateServerField: null,\n    setupDevBundler: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    propagateServerField: function() {\n        return propagateServerField;\n    },\n    setupDevBundler: function() {\n        return setupDevBundler;\n    }\n});\nconst _getpagestaticinfo = require(\"../../../build/analysis/get-page-static-info\");\nconst _swc = require(\"../../../build/swc\");\nconst _fs = /*#__PURE__*/ _interop_require_default(require(\"fs\"));\nconst _promises = require(\"fs/promises\");\nconst _url = /*#__PURE__*/ _interop_require_default(require(\"url\"));\nconst _path = /*#__PURE__*/ _interop_require_default(require(\"path\"));\nconst _querystring = /*#__PURE__*/ _interop_require_default(require(\"querystring\"));\nconst _watchpack = /*#__PURE__*/ _interop_require_default(require(\"next/dist/compiled/watchpack\"));\nconst _env = require(\"@next/env\");\nconst _findup = /*#__PURE__*/ _interop_require_default(require(\"next/dist/compiled/find-up\"));\nconst _filesystem = require(\"./filesystem\");\nconst _log = /*#__PURE__*/ _interop_require_wildcard(require(\"../../../build/output/log\"));\nconst _hotreloaderwebpack = /*#__PURE__*/ _interop_require_default(require(\"../../dev/hot-reloader-webpack\"));\nconst _shared = require(\"../../../trace/shared\");\nconst _loadjsconfig = /*#__PURE__*/ _interop_require_default(require(\"../../../build/load-jsconfig\"));\nconst _findpagefile = require(\"../find-page-file\");\nconst _events = require(\"../../../telemetry/events\");\nconst _defineenvplugin = require(\"../../../build/webpack/plugins/define-env-plugin\");\nconst _utils = require(\"../../../shared/lib/router/utils\");\nconst _entries = require(\"../../../build/entries\");\nconst _verifytypescriptsetup = require(\"../../../lib/verify-typescript-setup\");\nconst _verifypartytownsetup = require(\"../../../lib/verify-partytown-setup\");\nconst _routeregex = require(\"../../../shared/lib/router/utils/route-regex\");\nconst _apppaths = require(\"../../../shared/lib/router/utils/app-paths\");\nconst _builddataroute = require(\"./build-data-route\");\nconst _routematcher = require(\"../../../shared/lib/router/utils/route-matcher\");\nconst _normalizepathsep = require(\"../../../shared/lib/page-path/normalize-path-sep\");\nconst _createclientrouterfilter = require(\"../../../lib/create-client-router-filter\");\nconst _absolutepathtopage = require(\"../../../shared/lib/page-path/absolute-path-to-page\");\nconst _generateinterceptionroutesrewrites = require(\"../../../lib/generate-interception-routes-rewrites\");\nconst _constants = require(\"../../../shared/lib/constants\");\nconst _middlewareroutematcher = require(\"../../../shared/lib/router/utils/middleware-route-matcher\");\nconst _utils1 = require(\"../../../build/utils\");\nconst _shared1 = require(\"../../../build/webpack/plugins/next-types-plugin/shared\");\nconst _hotreloadertypes = require(\"../../dev/hot-reloader-types\");\nconst _pagetypes = require(\"../../../lib/page-types\");\nconst _hotreloaderturbopack = require(\"../../dev/hot-reloader-turbopack\");\nconst _encryptionutilsserver = require(\"../../app-render/encryption-utils-server\");\nconst _ismetadataroute = require(\"../../../lib/metadata/is-metadata-route\");\nconst _getmetadataroute = require(\"../../../lib/metadata/get-metadata-route\");\nconst _createenvdefinitions = require(\"../experimental/create-env-definitions\");\nconst _jsconfigpathsplugin = require(\"../../../build/webpack/plugins/jsconfig-paths-plugin\");\nconst _store = require(\"../../../build/output/store\");\nconst _utils2 = require(\"../../../shared/lib/turbopack/utils\");\nfunction _interop_require_default(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nfunction _getRequireWildcardCache(nodeInterop) {\n    if (typeof WeakMap !== \"function\") return null;\n    var cacheBabelInterop = new WeakMap();\n    var cacheNodeInterop = new WeakMap();\n    return (_getRequireWildcardCache = function(nodeInterop) {\n        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n    })(nodeInterop);\n}\nfunction _interop_require_wildcard(obj, nodeInterop) {\n    if (!nodeInterop && obj && obj.__esModule) {\n        return obj;\n    }\n    if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n        return {\n            default: obj\n        };\n    }\n    var cache = _getRequireWildcardCache(nodeInterop);\n    if (cache && cache.has(obj)) {\n        return cache.get(obj);\n    }\n    var newObj = {\n        __proto__: null\n    };\n    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n    for(var key in obj){\n        if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n            if (desc && (desc.get || desc.set)) {\n                Object.defineProperty(newObj, key, desc);\n            } else {\n                newObj[key] = obj[key];\n            }\n        }\n    }\n    newObj.default = obj;\n    if (cache) {\n        cache.set(obj, newObj);\n    }\n    return newObj;\n}\nasync function verifyTypeScript(opts) {\n    let usingTypeScript = false;\n    const verifyResult = await (0, _verifytypescriptsetup.verifyTypeScriptSetup)({\n        dir: opts.dir,\n        distDir: opts.nextConfig.distDir,\n        intentDirs: [\n            opts.pagesDir,\n            opts.appDir\n        ].filter(Boolean),\n        typeCheckPreflight: false,\n        tsconfigPath: opts.nextConfig.typescript.tsconfigPath,\n        disableStaticImages: opts.nextConfig.images.disableStaticImages,\n        hasAppDir: !!opts.appDir,\n        hasPagesDir: !!opts.pagesDir\n    });\n    if (verifyResult.version) {\n        usingTypeScript = true;\n    }\n    return usingTypeScript;\n}\nasync function propagateServerField(opts, field, args) {\n    var _opts_renderServer_instance, _opts_renderServer;\n    await ((_opts_renderServer = opts.renderServer) == null ? void 0 : (_opts_renderServer_instance = _opts_renderServer.instance) == null ? void 0 : _opts_renderServer_instance.propagateServerField(opts.dir, field, args));\n}\nasync function startWatcher(opts) {\n    const { nextConfig, appDir, pagesDir, dir, resetFetch } = opts;\n    const { useFileSystemPublicRoutes } = nextConfig;\n    const usingTypeScript = await verifyTypeScript(opts);\n    const distDir = _path.default.join(opts.dir, opts.nextConfig.distDir);\n    // we ensure the types directory exists here\n    if (usingTypeScript) {\n        const distTypesDir = _path.default.join(distDir, 'types');\n        if (!_fs.default.existsSync(distTypesDir)) {\n            await (0, _promises.mkdir)(distTypesDir, {\n                recursive: true\n            });\n        }\n    }\n    (0, _shared.setGlobal)('distDir', distDir);\n    (0, _shared.setGlobal)('phase', _constants.PHASE_DEVELOPMENT_SERVER);\n    const validFileMatcher = (0, _findpagefile.createValidFileMatcher)(nextConfig.pageExtensions, appDir);\n    const serverFields = {};\n    // Update logging state once based on next.config.js when initializing\n    _store.store.setState({\n        logging: nextConfig.logging !== false\n    });\n    const hotReloader = opts.turbo ? await (0, _hotreloaderturbopack.createHotReloaderTurbopack)(opts, serverFields, distDir, resetFetch) : new _hotreloaderwebpack.default(opts.dir, {\n        appDir,\n        pagesDir,\n        distDir,\n        config: opts.nextConfig,\n        buildId: 'development',\n        encryptionKey: await (0, _encryptionutilsserver.generateEncryptionKeyBase64)({\n            isBuild: false,\n            distDir\n        }),\n        telemetry: opts.telemetry,\n        rewrites: opts.fsChecker.rewrites,\n        previewProps: opts.fsChecker.prerenderManifest.preview,\n        resetFetch\n    });\n    await hotReloader.start();\n    if (opts.nextConfig.experimental.nextScriptWorkers) {\n        await (0, _verifypartytownsetup.verifyPartytownSetup)(opts.dir, _path.default.join(distDir, _constants.CLIENT_STATIC_FILES_PATH));\n    }\n    opts.fsChecker.ensureCallback(async function ensure(item) {\n        if (item.type === 'appFile' || item.type === 'pageFile') {\n            await hotReloader.ensurePage({\n                clientOnly: false,\n                page: item.itemPath,\n                isApp: item.type === 'appFile',\n                definition: undefined\n            });\n        }\n    });\n    let resolved = false;\n    let prevSortedRoutes = [];\n    await new Promise(async (resolve, reject)=>{\n        if (pagesDir) {\n            // Watchpack doesn't emit an event for an empty directory\n            _fs.default.readdir(pagesDir, (_, files)=>{\n                if (files == null ? void 0 : files.length) {\n                    return;\n                }\n                if (!resolved) {\n                    resolve();\n                    resolved = true;\n                }\n            });\n        }\n        const pages = pagesDir ? [\n            pagesDir\n        ] : [];\n        const app = appDir ? [\n            appDir\n        ] : [];\n        const directories = [\n            ...pages,\n            ...app\n        ];\n        const rootDir = pagesDir || appDir;\n        const files = [\n            ...(0, _utils1.getPossibleMiddlewareFilenames)(_path.default.join(rootDir, '..'), nextConfig.pageExtensions),\n            ...(0, _utils1.getPossibleInstrumentationHookFilenames)(_path.default.join(rootDir, '..'), nextConfig.pageExtensions)\n        ];\n        let nestedMiddleware = [];\n        const envFiles = [\n            '.env.development.local',\n            '.env.local',\n            '.env.development',\n            '.env'\n        ].map((file)=>_path.default.join(dir, file));\n        files.push(...envFiles);\n        // tsconfig/jsconfig paths hot-reloading\n        const tsconfigPaths = [\n            _path.default.join(dir, 'tsconfig.json'),\n            _path.default.join(dir, 'jsconfig.json')\n        ];\n        files.push(...tsconfigPaths);\n        const wp = new _watchpack.default({\n            ignored: (pathname)=>{\n                return !files.some((file)=>file.startsWith(pathname)) && !directories.some((d)=>pathname.startsWith(d) || d.startsWith(pathname));\n            }\n        });\n        const fileWatchTimes = new Map();\n        let enabledTypeScript = usingTypeScript;\n        let previousClientRouterFilters;\n        let previousConflictingPagePaths = new Set();\n        wp.on('aggregated', async ()=>{\n            var _serverFields_middleware, _serverFields_middleware1;\n            let middlewareMatchers;\n            const routedPages = [];\n            const knownFiles = wp.getTimeInfoEntries();\n            const appPaths = {};\n            const pageNameSet = new Set();\n            const conflictingAppPagePaths = new Set();\n            const appPageFilePaths = new Map();\n            const pagesPageFilePaths = new Map();\n            let envChange = false;\n            let tsconfigChange = false;\n            let conflictingPageChange = 0;\n            let hasRootAppNotFound = false;\n            const { appFiles, pageFiles } = opts.fsChecker;\n            appFiles.clear();\n            pageFiles.clear();\n            _shared1.devPageFiles.clear();\n            const sortedKnownFiles = [\n                ...knownFiles.keys()\n            ].sort((0, _entries.sortByPageExts)(nextConfig.pageExtensions));\n            for (const fileName of sortedKnownFiles){\n                if (!files.includes(fileName) && !directories.some((d)=>fileName.startsWith(d))) {\n                    continue;\n                }\n                const meta = knownFiles.get(fileName);\n                const watchTime = fileWatchTimes.get(fileName);\n                // If the file is showing up for the first time or the meta.timestamp is changed since last time\n                const watchTimeChange = watchTime === undefined || watchTime && watchTime !== (meta == null ? void 0 : meta.timestamp);\n                fileWatchTimes.set(fileName, meta == null ? void 0 : meta.timestamp);\n                if (envFiles.includes(fileName)) {\n                    if (watchTimeChange) {\n                        envChange = true;\n                    }\n                    continue;\n                }\n                if (tsconfigPaths.includes(fileName)) {\n                    if (fileName.endsWith('tsconfig.json')) {\n                        enabledTypeScript = true;\n                    }\n                    if (watchTimeChange) {\n                        tsconfigChange = true;\n                    }\n                    continue;\n                }\n                if ((meta == null ? void 0 : meta.accuracy) === undefined || !validFileMatcher.isPageFile(fileName)) {\n                    continue;\n                }\n                const isAppPath = Boolean(appDir && (0, _normalizepathsep.normalizePathSep)(fileName).startsWith((0, _normalizepathsep.normalizePathSep)(appDir) + '/'));\n                const isPagePath = Boolean(pagesDir && (0, _normalizepathsep.normalizePathSep)(fileName).startsWith((0, _normalizepathsep.normalizePathSep)(pagesDir) + '/'));\n                const rootFile = (0, _absolutepathtopage.absolutePathToPage)(fileName, {\n                    dir: dir,\n                    extensions: nextConfig.pageExtensions,\n                    keepIndex: false,\n                    pagesType: _pagetypes.PAGE_TYPES.ROOT\n                });\n                if ((0, _utils1.isMiddlewareFile)(rootFile)) {\n                    var _staticInfo_middleware;\n                    const staticInfo = await (0, _entries.getStaticInfoIncludingLayouts)({\n                        pageFilePath: fileName,\n                        config: nextConfig,\n                        appDir: appDir,\n                        page: rootFile,\n                        isDev: true,\n                        isInsideAppDir: isAppPath,\n                        pageExtensions: nextConfig.pageExtensions\n                    });\n                    if (nextConfig.output === 'export') {\n                        _log.error('Middleware cannot be used with \"output: export\". See more info here: https://nextjs.org/docs/advanced-features/static-html-export');\n                        continue;\n                    }\n                    serverFields.actualMiddlewareFile = rootFile;\n                    await propagateServerField(opts, 'actualMiddlewareFile', serverFields.actualMiddlewareFile);\n                    middlewareMatchers = ((_staticInfo_middleware = staticInfo.middleware) == null ? void 0 : _staticInfo_middleware.matchers) || [\n                        {\n                            regexp: '.*',\n                            originalSource: '/:path*'\n                        }\n                    ];\n                    continue;\n                }\n                if ((0, _utils1.isInstrumentationHookFile)(rootFile)) {\n                    serverFields.actualInstrumentationHookFile = rootFile;\n                    await propagateServerField(opts, 'actualInstrumentationHookFile', serverFields.actualInstrumentationHookFile);\n                    continue;\n                }\n                if (fileName.endsWith('.ts') || fileName.endsWith('.tsx')) {\n                    enabledTypeScript = true;\n                }\n                if (!(isAppPath || isPagePath)) {\n                    continue;\n                }\n                // Collect all current filenames for the TS plugin to use\n                _shared1.devPageFiles.add(fileName);\n                let pageName = (0, _absolutepathtopage.absolutePathToPage)(fileName, {\n                    dir: isAppPath ? appDir : pagesDir,\n                    extensions: nextConfig.pageExtensions,\n                    keepIndex: isAppPath,\n                    pagesType: isAppPath ? _pagetypes.PAGE_TYPES.APP : _pagetypes.PAGE_TYPES.PAGES\n                });\n                if (isAppPath && appDir && (0, _ismetadataroute.isMetadataRouteFile)(fileName.replace(appDir, ''), nextConfig.pageExtensions, true)) {\n                    const staticInfo = await (0, _getpagestaticinfo.getPageStaticInfo)({\n                        pageFilePath: fileName,\n                        nextConfig: {},\n                        page: pageName,\n                        isDev: true,\n                        pageType: _pagetypes.PAGE_TYPES.APP\n                    });\n                    pageName = (0, _getmetadataroute.normalizeMetadataPageToRoute)(pageName, !!(staticInfo.generateSitemaps || staticInfo.generateImageMetadata));\n                }\n                if (!isAppPath && pageName.startsWith('/api/') && nextConfig.output === 'export') {\n                    _log.error('API Routes cannot be used with \"output: export\". See more info here: https://nextjs.org/docs/advanced-features/static-html-export');\n                    continue;\n                }\n                if (isAppPath) {\n                    const isRootNotFound = validFileMatcher.isRootNotFound(fileName);\n                    hasRootAppNotFound = true;\n                    if (isRootNotFound) {\n                        continue;\n                    }\n                    if (!isRootNotFound && !validFileMatcher.isAppRouterPage(fileName)) {\n                        continue;\n                    }\n                    // Ignore files/directories starting with `_` in the app directory\n                    if ((0, _normalizepathsep.normalizePathSep)(pageName).includes('/_')) {\n                        continue;\n                    }\n                    const originalPageName = pageName;\n                    pageName = (0, _apppaths.normalizeAppPath)(pageName).replace(/%5F/g, '_');\n                    if (!appPaths[pageName]) {\n                        appPaths[pageName] = [];\n                    }\n                    appPaths[pageName].push(originalPageName);\n                    if (useFileSystemPublicRoutes) {\n                        appFiles.add(pageName);\n                    }\n                    if (routedPages.includes(pageName)) {\n                        continue;\n                    }\n                } else {\n                    if (useFileSystemPublicRoutes) {\n                        pageFiles.add(pageName);\n                        // always add to nextDataRoutes for now but in future only add\n                        // entries that actually use getStaticProps/getServerSideProps\n                        opts.fsChecker.nextDataRoutes.add(pageName);\n                    }\n                }\n                ;\n                (isAppPath ? appPageFilePaths : pagesPageFilePaths).set(pageName, fileName);\n                if (appDir && pageNameSet.has(pageName)) {\n                    conflictingAppPagePaths.add(pageName);\n                } else {\n                    pageNameSet.add(pageName);\n                }\n                /**\n         * If there is a middleware that is not declared in the root we will\n         * warn without adding it so it doesn't make its way into the system.\n         */ if (/[\\\\\\\\/]_middleware$/.test(pageName)) {\n                    nestedMiddleware.push(pageName);\n                    continue;\n                }\n                routedPages.push(pageName);\n            }\n            const numConflicting = conflictingAppPagePaths.size;\n            conflictingPageChange = numConflicting - previousConflictingPagePaths.size;\n            if (conflictingPageChange !== 0) {\n                if (numConflicting > 0) {\n                    let errorMessage = `Conflicting app and page file${numConflicting === 1 ? ' was' : 's were'} found, please remove the conflicting files to continue:\\n`;\n                    for (const p of conflictingAppPagePaths){\n                        const appPath = _path.default.relative(dir, appPageFilePaths.get(p));\n                        const pagesPath = _path.default.relative(dir, pagesPageFilePaths.get(p));\n                        errorMessage += `  \"${pagesPath}\" - \"${appPath}\"\\n`;\n                    }\n                    hotReloader.setHmrServerError(Object.defineProperty(new Error(errorMessage), \"__NEXT_ERROR_CODE\", {\n                        value: \"E394\",\n                        enumerable: false,\n                        configurable: true\n                    }));\n                } else if (numConflicting === 0) {\n                    hotReloader.clearHmrServerError();\n                    await propagateServerField(opts, 'reloadMatchers', undefined);\n                }\n            }\n            previousConflictingPagePaths = conflictingAppPagePaths;\n            let clientRouterFilters;\n            if (nextConfig.experimental.clientRouterFilter) {\n                clientRouterFilters = (0, _createclientrouterfilter.createClientRouterFilter)(Object.keys(appPaths), nextConfig.experimental.clientRouterFilterRedirects ? (nextConfig._originalRedirects || []).filter((r)=>!r.internal) : [], nextConfig.experimental.clientRouterFilterAllowedRate);\n                if (!previousClientRouterFilters || JSON.stringify(previousClientRouterFilters) !== JSON.stringify(clientRouterFilters)) {\n                    envChange = true;\n                    previousClientRouterFilters = clientRouterFilters;\n                }\n            }\n            if (!usingTypeScript && enabledTypeScript) {\n                // we tolerate the error here as this is best effort\n                // and the manual install command will be shown\n                await verifyTypeScript(opts).then(()=>{\n                    tsconfigChange = true;\n                }).catch(()=>{});\n            }\n            if (envChange || tsconfigChange) {\n                var _hotReloader_activeWebpackConfigs;\n                if (envChange) {\n                    var _nextConfig_experimental;\n                    const { loadedEnvFiles } = (0, _env.loadEnvConfig)(dir, process.env.NODE_ENV === 'development', _log, true, (envFilePath)=>{\n                        _log.info(`Reload env: ${envFilePath}`);\n                    });\n                    if (usingTypeScript && ((_nextConfig_experimental = nextConfig.experimental) == null ? void 0 : _nextConfig_experimental.typedEnv)) {\n                        // do not await, this is not essential for further process\n                        (0, _createenvdefinitions.createEnvDefinitions)({\n                            distDir,\n                            loadedEnvFiles: [\n                                ...loadedEnvFiles,\n                                {\n                                    path: nextConfig.configFileName,\n                                    env: nextConfig.env,\n                                    contents: ''\n                                }\n                            ]\n                        });\n                    }\n                    await propagateServerField(opts, 'loadEnvConfig', [\n                        {\n                            dev: true,\n                            forceReload: true,\n                            silent: true\n                        }\n                    ]);\n                }\n                let tsconfigResult;\n                if (tsconfigChange) {\n                    try {\n                        tsconfigResult = await (0, _loadjsconfig.default)(dir, nextConfig);\n                    } catch (_) {\n                    /* do we want to log if there are syntax errors in tsconfig while editing? */ }\n                }\n                if (hotReloader.turbopackProject) {\n                    const hasRewrites = opts.fsChecker.rewrites.afterFiles.length > 0 || opts.fsChecker.rewrites.beforeFiles.length > 0 || opts.fsChecker.rewrites.fallback.length > 0;\n                    await hotReloader.turbopackProject.update({\n                        defineEnv: (0, _swc.createDefineEnv)({\n                            isTurbopack: true,\n                            clientRouterFilters,\n                            config: nextConfig,\n                            dev: true,\n                            distDir,\n                            fetchCacheKeyPrefix: opts.nextConfig.experimental.fetchCacheKeyPrefix,\n                            hasRewrites,\n                            // TODO: Implement\n                            middlewareMatchers: undefined\n                        })\n                    });\n                }\n                (_hotReloader_activeWebpackConfigs = hotReloader.activeWebpackConfigs) == null ? void 0 : _hotReloader_activeWebpackConfigs.forEach((config, idx)=>{\n                    const isClient = idx === 0;\n                    const isNodeServer = idx === 1;\n                    const isEdgeServer = idx === 2;\n                    const hasRewrites = opts.fsChecker.rewrites.afterFiles.length > 0 || opts.fsChecker.rewrites.beforeFiles.length > 0 || opts.fsChecker.rewrites.fallback.length > 0;\n                    if (tsconfigChange) {\n                        var _config_resolve_plugins, _config_resolve;\n                        (_config_resolve = config.resolve) == null ? void 0 : (_config_resolve_plugins = _config_resolve.plugins) == null ? void 0 : _config_resolve_plugins.forEach((plugin)=>{\n                            // look for the JsConfigPathsPlugin and update with\n                            // the latest paths/baseUrl config\n                            if (plugin instanceof _jsconfigpathsplugin.JsConfigPathsPlugin && tsconfigResult) {\n                                var _config_resolve_modules, _config_resolve, _jsConfig_compilerOptions;\n                                const { resolvedBaseUrl, jsConfig } = tsconfigResult;\n                                const currentResolvedBaseUrl = plugin.resolvedBaseUrl;\n                                const resolvedUrlIndex = (_config_resolve = config.resolve) == null ? void 0 : (_config_resolve_modules = _config_resolve.modules) == null ? void 0 : _config_resolve_modules.findIndex((item)=>item === (currentResolvedBaseUrl == null ? void 0 : currentResolvedBaseUrl.baseUrl));\n                                if (resolvedBaseUrl) {\n                                    if (resolvedBaseUrl.baseUrl !== (currentResolvedBaseUrl == null ? void 0 : currentResolvedBaseUrl.baseUrl)) {\n                                        // remove old baseUrl and add new one\n                                        if (resolvedUrlIndex && resolvedUrlIndex > -1) {\n                                            var _config_resolve_modules1, _config_resolve1;\n                                            (_config_resolve1 = config.resolve) == null ? void 0 : (_config_resolve_modules1 = _config_resolve1.modules) == null ? void 0 : _config_resolve_modules1.splice(resolvedUrlIndex, 1);\n                                        }\n                                        // If the resolvedBaseUrl is implicit we only remove the previous value.\n                                        // Only add the baseUrl if it's explicitly set in tsconfig/jsconfig\n                                        if (!resolvedBaseUrl.isImplicit) {\n                                            var _config_resolve_modules2, _config_resolve2;\n                                            (_config_resolve2 = config.resolve) == null ? void 0 : (_config_resolve_modules2 = _config_resolve2.modules) == null ? void 0 : _config_resolve_modules2.push(resolvedBaseUrl.baseUrl);\n                                        }\n                                    }\n                                }\n                                if ((jsConfig == null ? void 0 : (_jsConfig_compilerOptions = jsConfig.compilerOptions) == null ? void 0 : _jsConfig_compilerOptions.paths) && resolvedBaseUrl) {\n                                    Object.keys(plugin.paths).forEach((key)=>{\n                                        delete plugin.paths[key];\n                                    });\n                                    Object.assign(plugin.paths, jsConfig.compilerOptions.paths);\n                                    plugin.resolvedBaseUrl = resolvedBaseUrl;\n                                }\n                            }\n                        });\n                    }\n                    if (envChange) {\n                        var _config_plugins;\n                        (_config_plugins = config.plugins) == null ? void 0 : _config_plugins.forEach((plugin)=>{\n                            // we look for the DefinePlugin definitions so we can\n                            // update them on the active compilers\n                            if (plugin && typeof plugin.definitions === 'object' && plugin.definitions.__NEXT_DEFINE_ENV) {\n                                const newDefine = (0, _defineenvplugin.getDefineEnv)({\n                                    isTurbopack: false,\n                                    clientRouterFilters,\n                                    config: nextConfig,\n                                    dev: true,\n                                    distDir,\n                                    fetchCacheKeyPrefix: opts.nextConfig.experimental.fetchCacheKeyPrefix,\n                                    hasRewrites,\n                                    isClient,\n                                    isEdgeServer,\n                                    isNodeOrEdgeCompilation: isNodeServer || isEdgeServer,\n                                    isNodeServer,\n                                    middlewareMatchers: undefined\n                                });\n                                Object.keys(plugin.definitions).forEach((key)=>{\n                                    if (!(key in newDefine)) {\n                                        delete plugin.definitions[key];\n                                    }\n                                });\n                                Object.assign(plugin.definitions, newDefine);\n                            }\n                        });\n                    }\n                });\n                await hotReloader.invalidate({\n                    reloadAfterInvalidation: envChange\n                });\n            }\n            if (nestedMiddleware.length > 0) {\n                _log.error(Object.defineProperty(new _utils1.NestedMiddlewareError(nestedMiddleware, dir, pagesDir || appDir), \"__NEXT_ERROR_CODE\", {\n                    value: \"E394\",\n                    enumerable: false,\n                    configurable: true\n                }).message);\n                nestedMiddleware = [];\n            }\n            // Make sure to sort parallel routes to make the result deterministic.\n            serverFields.appPathRoutes = Object.fromEntries(Object.entries(appPaths).map(([k, v])=>[\n                    k,\n                    v.sort()\n                ]));\n            await propagateServerField(opts, 'appPathRoutes', serverFields.appPathRoutes);\n            // TODO: pass this to fsChecker/next-dev-server?\n            serverFields.middleware = middlewareMatchers ? {\n                match: null,\n                page: '/',\n                matchers: middlewareMatchers\n            } : undefined;\n            await propagateServerField(opts, 'middleware', serverFields.middleware);\n            serverFields.hasAppNotFound = hasRootAppNotFound;\n            opts.fsChecker.middlewareMatcher = ((_serverFields_middleware = serverFields.middleware) == null ? void 0 : _serverFields_middleware.matchers) ? (0, _middlewareroutematcher.getMiddlewareRouteMatcher)((_serverFields_middleware1 = serverFields.middleware) == null ? void 0 : _serverFields_middleware1.matchers) : undefined;\n            const interceptionRoutes = (0, _generateinterceptionroutesrewrites.generateInterceptionRoutesRewrites)(Object.keys(appPaths), opts.nextConfig.basePath).map((item)=>(0, _filesystem.buildCustomRoute)('before_files_rewrite', item, opts.nextConfig.basePath, opts.nextConfig.experimental.caseSensitiveRoutes));\n            opts.fsChecker.rewrites.beforeFiles.push(...interceptionRoutes);\n            const exportPathMap = typeof nextConfig.exportPathMap === 'function' && await (nextConfig.exportPathMap == null ? void 0 : nextConfig.exportPathMap.call(nextConfig, {}, {\n                dev: true,\n                dir: opts.dir,\n                outDir: null,\n                distDir: distDir,\n                buildId: 'development'\n            })) || {};\n            const exportPathMapEntries = Object.entries(exportPathMap || {});\n            if (exportPathMapEntries.length > 0) {\n                opts.fsChecker.exportPathMapRoutes = exportPathMapEntries.map(([key, value])=>(0, _filesystem.buildCustomRoute)('before_files_rewrite', {\n                        source: key,\n                        destination: `${value.page}${value.query ? '?' : ''}${_querystring.default.stringify(value.query)}`\n                    }, opts.nextConfig.basePath, opts.nextConfig.experimental.caseSensitiveRoutes));\n            }\n            try {\n                // we serve a separate manifest with all pages for the client in\n                // dev mode so that we can match a page after a rewrite on the client\n                // before it has been built and is populated in the _buildManifest\n                const sortedRoutes = (0, _utils.getSortedRoutes)(routedPages);\n                opts.fsChecker.dynamicRoutes = sortedRoutes.map((page)=>{\n                    const regex = (0, _routeregex.getRouteRegex)(page);\n                    return {\n                        regex: regex.re.toString(),\n                        match: (0, _routematcher.getRouteMatcher)(regex),\n                        page\n                    };\n                });\n                const dataRoutes = [];\n                for (const page of sortedRoutes){\n                    const route = (0, _builddataroute.buildDataRoute)(page, 'development');\n                    const routeRegex = (0, _routeregex.getRouteRegex)(route.page);\n                    dataRoutes.push({\n                        ...route,\n                        regex: routeRegex.re.toString(),\n                        match: (0, _routematcher.getRouteMatcher)({\n                            // TODO: fix this in the manifest itself, must also be fixed in\n                            // upstream builder that relies on this\n                            re: opts.nextConfig.i18n ? new RegExp(route.dataRouteRegex.replace(`/development/`, `/development/(?<nextLocale>[^/]+?)/`)) : new RegExp(route.dataRouteRegex),\n                            groups: routeRegex.groups\n                        })\n                    });\n                }\n                opts.fsChecker.dynamicRoutes.unshift(...dataRoutes);\n                if (!(prevSortedRoutes == null ? void 0 : prevSortedRoutes.every((val, idx)=>val === sortedRoutes[idx]))) {\n                    const addedRoutes = sortedRoutes.filter((route)=>!prevSortedRoutes.includes(route));\n                    const removedRoutes = prevSortedRoutes.filter((route)=>!sortedRoutes.includes(route));\n                    // emit the change so clients fetch the update\n                    hotReloader.send({\n                        action: _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.DEV_PAGES_MANIFEST_UPDATE,\n                        data: [\n                            {\n                                devPagesManifest: true\n                            }\n                        ]\n                    });\n                    addedRoutes.forEach((route)=>{\n                        hotReloader.send({\n                            action: _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.ADDED_PAGE,\n                            data: [\n                                route\n                            ]\n                        });\n                    });\n                    removedRoutes.forEach((route)=>{\n                        hotReloader.send({\n                            action: _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.REMOVED_PAGE,\n                            data: [\n                                route\n                            ]\n                        });\n                    });\n                }\n                prevSortedRoutes = sortedRoutes;\n                if (!resolved) {\n                    resolve();\n                    resolved = true;\n                }\n            } catch (e) {\n                if (!resolved) {\n                    reject(e);\n                    resolved = true;\n                } else {\n                    _log.warn('Failed to reload dynamic routes:', e);\n                }\n            } finally{\n                // Reload the matchers. The filesystem would have been written to,\n                // and the matchers need to re-scan it to update the router.\n                await propagateServerField(opts, 'reloadMatchers', undefined);\n            }\n        });\n        wp.watch({\n            directories: [\n                dir\n            ],\n            startTime: 0\n        });\n    });\n    const clientPagesManifestPath = `/_next/${_constants.CLIENT_STATIC_FILES_PATH}/development/${_constants.DEV_CLIENT_PAGES_MANIFEST}`;\n    opts.fsChecker.devVirtualFsItems.add(clientPagesManifestPath);\n    const devMiddlewareManifestPath = `/_next/${_constants.CLIENT_STATIC_FILES_PATH}/development/${_constants.DEV_CLIENT_MIDDLEWARE_MANIFEST}`;\n    opts.fsChecker.devVirtualFsItems.add(devMiddlewareManifestPath);\n    const devTurbopackMiddlewareManifestPath = `/_next/${_constants.CLIENT_STATIC_FILES_PATH}/development/${_constants.TURBOPACK_CLIENT_MIDDLEWARE_MANIFEST}`;\n    opts.fsChecker.devVirtualFsItems.add(devTurbopackMiddlewareManifestPath);\n    async function requestHandler(req, res) {\n        var _parsedUrl_pathname, _parsedUrl_pathname1, _parsedUrl_pathname2;\n        const parsedUrl = _url.default.parse(req.url || '/');\n        if ((_parsedUrl_pathname = parsedUrl.pathname) == null ? void 0 : _parsedUrl_pathname.includes(clientPagesManifestPath)) {\n            res.statusCode = 200;\n            res.setHeader('Content-Type', 'application/json; charset=utf-8');\n            res.end(JSON.stringify({\n                pages: prevSortedRoutes.filter((route)=>!opts.fsChecker.appFiles.has(route))\n            }));\n            return {\n                finished: true\n            };\n        }\n        if (((_parsedUrl_pathname1 = parsedUrl.pathname) == null ? void 0 : _parsedUrl_pathname1.includes(devMiddlewareManifestPath)) || ((_parsedUrl_pathname2 = parsedUrl.pathname) == null ? void 0 : _parsedUrl_pathname2.includes(devTurbopackMiddlewareManifestPath))) {\n            var _serverFields_middleware;\n            res.statusCode = 200;\n            res.setHeader('Content-Type', 'application/json; charset=utf-8');\n            res.end(JSON.stringify(((_serverFields_middleware = serverFields.middleware) == null ? void 0 : _serverFields_middleware.matchers) || []));\n            return {\n                finished: true\n            };\n        }\n        return {\n            finished: false\n        };\n    }\n    function logErrorWithOriginalStack(err, type) {\n        if (err instanceof _utils2.ModuleBuildError) {\n            // Errors that may come from issues from the user's code\n            _log.error(err.message);\n        } else if (err instanceof _utils2.TurbopackInternalError) {\n        // An internal Turbopack error that has been handled by next-swc, written\n        // to disk and a simplified message shown to user on the Rust side.\n        } else if (type === 'warning') {\n            _log.warn(err);\n        } else if (type === 'app-dir') {\n            _log.error(err);\n        } else if (type) {\n            _log.error(`${type}:`, err);\n        } else {\n            _log.error(err);\n        }\n    }\n    return {\n        serverFields,\n        hotReloader,\n        requestHandler,\n        logErrorWithOriginalStack,\n        async ensureMiddleware (requestUrl) {\n            if (!serverFields.actualMiddlewareFile) return;\n            return hotReloader.ensurePage({\n                page: serverFields.actualMiddlewareFile,\n                clientOnly: false,\n                definition: undefined,\n                url: requestUrl\n            });\n        }\n    };\n}\nasync function setupDevBundler(opts) {\n    const isSrcDir = _path.default.relative(opts.dir, opts.pagesDir || opts.appDir || '').startsWith('src');\n    const result = await startWatcher(opts);\n    opts.telemetry.record((0, _events.eventCliSession)(_path.default.join(opts.dir, opts.nextConfig.distDir), opts.nextConfig, {\n        webpackVersion: 5,\n        isSrcDir,\n        turboFlag: !!opts.turbo,\n        cliCommand: 'dev',\n        appDir: !!opts.appDir,\n        pagesDir: !!opts.pagesDir,\n        isCustomServer: !!opts.isCustomServer,\n        hasNowJson: !!await (0, _findup.default)('now.json', {\n            cwd: opts.dir\n        })\n    }));\n    // Track build features for dev server here:\n    opts.telemetry.record({\n        eventName: _events.EVENT_BUILD_FEATURE_USAGE,\n        payload: {\n            featureName: 'turbopackPersistentCaching',\n            invocationCount: (0, _utils2.isPersistentCachingEnabled)(opts.nextConfig) ? 1 : 0\n        }\n    });\n    return result;\n}\n // Returns a trace rewritten through Turbopack's sourcemaps\n\n//# sourceMappingURL=setup-dev-bundler.js.map"
        }
    ]
}