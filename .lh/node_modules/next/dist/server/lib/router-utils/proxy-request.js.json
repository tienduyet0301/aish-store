{
    "sourceFile": "node_modules/next/dist/server/lib/router-utils/proxy-request.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892877357,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"proxyRequest\", {\n    enumerable: true,\n    get: function() {\n        return proxyRequest;\n    }\n});\nconst _url = /*#__PURE__*/ _interop_require_default(require(\"url\"));\nconst _serverrouteutils = require(\"../../server-route-utils\");\nconst _stream = require(\"stream\");\nconst _detachedpromise = require(\"../../../lib/detached-promise\");\nfunction _interop_require_default(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nasync function proxyRequest(req, res, parsedUrl, upgradeHead, reqBody, proxyTimeout) {\n    const { query } = parsedUrl;\n    delete parsedUrl.query;\n    parsedUrl.search = (0, _serverrouteutils.stringifyQuery)(req, query);\n    const target = _url.default.format(parsedUrl);\n    const HttpProxy = require('next/dist/compiled/http-proxy');\n    const proxy = new HttpProxy({\n        target,\n        changeOrigin: true,\n        ignorePath: true,\n        ws: true,\n        // we limit proxy requests to 30s by default, in development\n        // we don't time out WebSocket requests to allow proxying\n        proxyTimeout: proxyTimeout === null ? undefined : proxyTimeout || 30000,\n        headers: {\n            'x-forwarded-host': req.headers.host || ''\n        }\n    });\n    let finished = false;\n    // http-proxy does not properly detect a client disconnect in newer\n    // versions of Node.js. This is caused because it only listens for the\n    // `aborted` event on the our request object, but it also fully reads\n    // and closes the request object. Node **will not** fire `aborted` when\n    // the request is already closed. Listening for `close` on our response\n    // object will detect the disconnect, and we can abort the proxy's\n    // connection.\n    proxy.on('proxyReq', (proxyReq)=>{\n        res.on('close', ()=>proxyReq.destroy());\n    });\n    proxy.on('proxyRes', (proxyRes)=>{\n        if (res.destroyed) {\n            proxyRes.destroy();\n        } else {\n            res.on('close', ()=>proxyRes.destroy());\n        }\n    });\n    proxy.on('proxyRes', (proxyRes, innerReq, innerRes)=>{\n        const cleanup = (err)=>{\n            // cleanup event listeners to allow clean garbage collection\n            proxyRes.removeListener('error', cleanup);\n            proxyRes.removeListener('close', cleanup);\n            innerRes.removeListener('error', cleanup);\n            innerRes.removeListener('close', cleanup);\n            // destroy all source streams to propagate the caught event backward\n            innerReq.destroy(err);\n            proxyRes.destroy(err);\n        };\n        proxyRes.once('error', cleanup);\n        proxyRes.once('close', cleanup);\n        innerRes.once('error', cleanup);\n        innerRes.once('close', cleanup);\n    });\n    const detached = new _detachedpromise.DetachedPromise();\n    proxy.on('error', (err)=>{\n        console.error(`Failed to proxy ${target}`, err);\n        if (!finished) {\n            finished = true;\n            detached.reject(err);\n            if (!res.destroyed) {\n                if (!(res instanceof _stream.Duplex)) {\n                    res.statusCode = 500;\n                }\n                res.end('Internal Server Error');\n            }\n        }\n    });\n    // If upgrade head is present or the response is a Duplex stream, treat as\n    // WebSocket request.\n    if (upgradeHead || res instanceof _stream.Duplex) {\n        proxy.on('proxyReqWs', (proxyReq)=>{\n            proxyReq.on('close', ()=>{\n                if (!finished) {\n                    finished = true;\n                    detached.resolve(true);\n                }\n            });\n        });\n        proxy.ws(req, res, upgradeHead);\n        detached.resolve(true);\n    } else {\n        proxy.on('proxyReq', (proxyReq)=>{\n            proxyReq.on('close', ()=>{\n                if (!finished) {\n                    finished = true;\n                    detached.resolve(true);\n                }\n            });\n        });\n        proxy.web(req, res, {\n            buffer: reqBody\n        });\n    }\n    // When the proxy finishes proxying the request, shut down the proxy.\n    return detached.promise.finally(()=>{\n        proxy.close();\n    });\n}\n\n//# sourceMappingURL=proxy-request.js.map"
        }
    ]
}