{
    "sourceFile": "node_modules/next/dist/server/lib/router-utils/filesystem.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892877223,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    buildCustomRoute: null,\n    setupFsCheck: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    buildCustomRoute: function() {\n        return buildCustomRoute;\n    },\n    setupFsCheck: function() {\n        return setupFsCheck;\n    }\n});\nconst _path = /*#__PURE__*/ _interop_require_default(require(\"path\"));\nconst _promises = /*#__PURE__*/ _interop_require_default(require(\"fs/promises\"));\nconst _log = /*#__PURE__*/ _interop_require_wildcard(require(\"../../../build/output/log\"));\nconst _debug = /*#__PURE__*/ _interop_require_default(require(\"next/dist/compiled/debug\"));\nconst _lrucache = require(\"../lru-cache\");\nconst _loadcustomroutes = /*#__PURE__*/ _interop_require_default(require(\"../../../lib/load-custom-routes\"));\nconst _redirectstatus = require(\"../../../lib/redirect-status\");\nconst _fileexists = require(\"../../../lib/file-exists\");\nconst _recursivereaddir = require(\"../../../lib/recursive-readdir\");\nconst _utils = require(\"../../../shared/lib/router/utils\");\nconst _escaperegexp = require(\"../../../shared/lib/escape-regexp\");\nconst _pathmatch = require(\"../../../shared/lib/router/utils/path-match\");\nconst _routeregex = require(\"../../../shared/lib/router/utils/route-regex\");\nconst _routematcher = require(\"../../../shared/lib/router/utils/route-matcher\");\nconst _pathhasprefix = require(\"../../../shared/lib/router/utils/path-has-prefix\");\nconst _normalizelocalepath = require(\"../../../shared/lib/i18n/normalize-locale-path\");\nconst _removepathprefix = require(\"../../../shared/lib/router/utils/remove-path-prefix\");\nconst _middlewareroutematcher = require(\"../../../shared/lib/router/utils/middleware-route-matcher\");\nconst _constants = require(\"../../../shared/lib/constants\");\nconst _normalizepathsep = require(\"../../../shared/lib/page-path/normalize-path-sep\");\nconst _getmetadataroute = require(\"../../../lib/metadata/get-metadata-route\");\nconst _rsc = require(\"../../normalizers/request/rsc\");\nconst _prefetchrsc = require(\"../../normalizers/request/prefetch-rsc\");\nconst _encodeuripath = require(\"../../../shared/lib/encode-uri-path\");\nfunction _interop_require_default(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nfunction _getRequireWildcardCache(nodeInterop) {\n    if (typeof WeakMap !== \"function\") return null;\n    var cacheBabelInterop = new WeakMap();\n    var cacheNodeInterop = new WeakMap();\n    return (_getRequireWildcardCache = function(nodeInterop) {\n        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n    })(nodeInterop);\n}\nfunction _interop_require_wildcard(obj, nodeInterop) {\n    if (!nodeInterop && obj && obj.__esModule) {\n        return obj;\n    }\n    if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n        return {\n            default: obj\n        };\n    }\n    var cache = _getRequireWildcardCache(nodeInterop);\n    if (cache && cache.has(obj)) {\n        return cache.get(obj);\n    }\n    var newObj = {\n        __proto__: null\n    };\n    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n    for(var key in obj){\n        if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n            if (desc && (desc.get || desc.set)) {\n                Object.defineProperty(newObj, key, desc);\n            } else {\n                newObj[key] = obj[key];\n            }\n        }\n    }\n    newObj.default = obj;\n    if (cache) {\n        cache.set(obj, newObj);\n    }\n    return newObj;\n}\nconst debug = (0, _debug.default)('next:router-server:filesystem');\nconst buildCustomRoute = (type, item, basePath, caseSensitive)=>{\n    const restrictedRedirectPaths = [\n        '/_next'\n    ].map((p)=>basePath ? `${basePath}${p}` : p);\n    const match = (0, _pathmatch.getPathMatch)(item.source, {\n        strict: true,\n        removeUnnamedParams: true,\n        regexModifier: !item.internal ? (regex)=>(0, _redirectstatus.modifyRouteRegex)(regex, type === 'redirect' ? restrictedRedirectPaths : undefined) : undefined,\n        sensitive: caseSensitive\n    });\n    return {\n        ...item,\n        ...type === 'rewrite' ? {\n            check: true\n        } : {},\n        match\n    };\n};\nasync function setupFsCheck(opts) {\n    const getItemsLru = !opts.dev ? new _lrucache.LRUCache(1024 * 1024, function length(value) {\n        if (!value) return 0;\n        return (value.fsPath || '').length + value.itemPath.length + value.type.length;\n    }) : undefined;\n    // routes that have _next/data endpoints (SSG/SSP)\n    const nextDataRoutes = new Set();\n    const publicFolderItems = new Set();\n    const nextStaticFolderItems = new Set();\n    const legacyStaticFolderItems = new Set();\n    const appFiles = new Set();\n    const pageFiles = new Set();\n    let dynamicRoutes = [];\n    let middlewareMatcher = ()=>false;\n    const distDir = _path.default.join(opts.dir, opts.config.distDir);\n    const publicFolderPath = _path.default.join(opts.dir, 'public');\n    const nextStaticFolderPath = _path.default.join(distDir, 'static');\n    const legacyStaticFolderPath = _path.default.join(opts.dir, 'static');\n    let customRoutes = {\n        redirects: [],\n        rewrites: {\n            beforeFiles: [],\n            afterFiles: [],\n            fallback: []\n        },\n        headers: []\n    };\n    let buildId = 'development';\n    let prerenderManifest;\n    if (!opts.dev) {\n        var _middlewareManifest_middleware_, _middlewareManifest_middleware;\n        const buildIdPath = _path.default.join(opts.dir, opts.config.distDir, _constants.BUILD_ID_FILE);\n        try {\n            buildId = await _promises.default.readFile(buildIdPath, 'utf8');\n        } catch (err) {\n            if (err.code !== 'ENOENT') throw err;\n            throw Object.defineProperty(new Error(`Could not find a production build in the '${opts.config.distDir}' directory. Try building your app with 'next build' before starting the production server. https://nextjs.org/docs/messages/production-start-no-build-id`), \"__NEXT_ERROR_CODE\", {\n                value: \"E427\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n        try {\n            for (const file of (await (0, _recursivereaddir.recursiveReadDir)(publicFolderPath))){\n                // Ensure filename is encoded and normalized.\n                publicFolderItems.add((0, _encodeuripath.encodeURIPath)((0, _normalizepathsep.normalizePathSep)(file)));\n            }\n        } catch (err) {\n            if (err.code !== 'ENOENT') {\n                throw err;\n            }\n        }\n        try {\n            for (const file of (await (0, _recursivereaddir.recursiveReadDir)(legacyStaticFolderPath))){\n                // Ensure filename is encoded and normalized.\n                legacyStaticFolderItems.add((0, _encodeuripath.encodeURIPath)((0, _normalizepathsep.normalizePathSep)(file)));\n            }\n            _log.warn(`The static directory has been deprecated in favor of the public directory. https://nextjs.org/docs/messages/static-dir-deprecated`);\n        } catch (err) {\n            if (err.code !== 'ENOENT') {\n                throw err;\n            }\n        }\n        try {\n            for (const file of (await (0, _recursivereaddir.recursiveReadDir)(nextStaticFolderPath))){\n                // Ensure filename is encoded and normalized.\n                nextStaticFolderItems.add(_path.default.posix.join('/_next/static', (0, _encodeuripath.encodeURIPath)((0, _normalizepathsep.normalizePathSep)(file))));\n            }\n        } catch (err) {\n            if (opts.config.output !== 'standalone') throw err;\n        }\n        const routesManifestPath = _path.default.join(distDir, _constants.ROUTES_MANIFEST);\n        const prerenderManifestPath = _path.default.join(distDir, _constants.PRERENDER_MANIFEST);\n        const middlewareManifestPath = _path.default.join(distDir, 'server', _constants.MIDDLEWARE_MANIFEST);\n        const functionsConfigManifestPath = _path.default.join(distDir, 'server', _constants.FUNCTIONS_CONFIG_MANIFEST);\n        const pagesManifestPath = _path.default.join(distDir, 'server', _constants.PAGES_MANIFEST);\n        const appRoutesManifestPath = _path.default.join(distDir, _constants.APP_PATH_ROUTES_MANIFEST);\n        const routesManifest = JSON.parse(await _promises.default.readFile(routesManifestPath, 'utf8'));\n        prerenderManifest = JSON.parse(await _promises.default.readFile(prerenderManifestPath, 'utf8'));\n        const middlewareManifest = JSON.parse(await _promises.default.readFile(middlewareManifestPath, 'utf8').catch(()=>'{}'));\n        const functionsConfigManifest = JSON.parse(await _promises.default.readFile(functionsConfigManifestPath, 'utf8').catch(()=>'{}'));\n        const pagesManifest = JSON.parse(await _promises.default.readFile(pagesManifestPath, 'utf8'));\n        const appRoutesManifest = JSON.parse(await _promises.default.readFile(appRoutesManifestPath, 'utf8').catch(()=>'{}'));\n        for (const key of Object.keys(pagesManifest)){\n            // ensure the non-locale version is in the set\n            if (opts.config.i18n) {\n                pageFiles.add((0, _normalizelocalepath.normalizeLocalePath)(key, opts.config.i18n.locales).pathname);\n            } else {\n                pageFiles.add(key);\n            }\n        }\n        for (const key of Object.keys(appRoutesManifest)){\n            appFiles.add(appRoutesManifest[key]);\n        }\n        const escapedBuildId = (0, _escaperegexp.escapeStringRegexp)(buildId);\n        for (const route of routesManifest.dataRoutes){\n            if ((0, _utils.isDynamicRoute)(route.page)) {\n                const routeRegex = (0, _routeregex.getRouteRegex)(route.page);\n                dynamicRoutes.push({\n                    ...route,\n                    regex: routeRegex.re.toString(),\n                    match: (0, _routematcher.getRouteMatcher)({\n                        // TODO: fix this in the manifest itself, must also be fixed in\n                        // upstream builder that relies on this\n                        re: opts.config.i18n ? new RegExp(route.dataRouteRegex.replace(`/${escapedBuildId}/`, `/${escapedBuildId}/(?<nextLocale>[^/]+?)/`)) : new RegExp(route.dataRouteRegex),\n                        groups: routeRegex.groups\n                    })\n                });\n            }\n            nextDataRoutes.add(route.page);\n        }\n        for (const route of routesManifest.dynamicRoutes){\n            dynamicRoutes.push({\n                ...route,\n                match: (0, _routematcher.getRouteMatcher)((0, _routeregex.getRouteRegex)(route.page))\n            });\n        }\n        if ((_middlewareManifest_middleware = middlewareManifest.middleware) == null ? void 0 : (_middlewareManifest_middleware_ = _middlewareManifest_middleware['/']) == null ? void 0 : _middlewareManifest_middleware_.matchers) {\n            var _middlewareManifest_middleware_1, _middlewareManifest_middleware1;\n            middlewareMatcher = (0, _middlewareroutematcher.getMiddlewareRouteMatcher)((_middlewareManifest_middleware1 = middlewareManifest.middleware) == null ? void 0 : (_middlewareManifest_middleware_1 = _middlewareManifest_middleware1['/']) == null ? void 0 : _middlewareManifest_middleware_1.matchers);\n        } else if (functionsConfigManifest == null ? void 0 : functionsConfigManifest.functions['/_middleware']) {\n            middlewareMatcher = (0, _middlewareroutematcher.getMiddlewareRouteMatcher)(functionsConfigManifest.functions['/_middleware'].matchers ?? [\n                {\n                    regexp: '.*',\n                    originalSource: '/:path*'\n                }\n            ]);\n        }\n        customRoutes = {\n            redirects: routesManifest.redirects,\n            rewrites: routesManifest.rewrites ? Array.isArray(routesManifest.rewrites) ? {\n                beforeFiles: [],\n                afterFiles: routesManifest.rewrites,\n                fallback: []\n            } : routesManifest.rewrites : {\n                beforeFiles: [],\n                afterFiles: [],\n                fallback: []\n            },\n            headers: routesManifest.headers\n        };\n    } else {\n        // dev handling\n        customRoutes = await (0, _loadcustomroutes.default)(opts.config);\n        prerenderManifest = {\n            version: 4,\n            routes: {},\n            dynamicRoutes: {},\n            notFoundRoutes: [],\n            preview: {\n                previewModeId: require('crypto').randomBytes(16).toString('hex'),\n                previewModeSigningKey: require('crypto').randomBytes(32).toString('hex'),\n                previewModeEncryptionKey: require('crypto').randomBytes(32).toString('hex')\n            }\n        };\n    }\n    const headers = customRoutes.headers.map((item)=>buildCustomRoute('header', item, opts.config.basePath, opts.config.experimental.caseSensitiveRoutes));\n    const redirects = customRoutes.redirects.map((item)=>buildCustomRoute('redirect', item, opts.config.basePath, opts.config.experimental.caseSensitiveRoutes));\n    const rewrites = {\n        beforeFiles: customRoutes.rewrites.beforeFiles.map((item)=>buildCustomRoute('before_files_rewrite', item)),\n        afterFiles: customRoutes.rewrites.afterFiles.map((item)=>buildCustomRoute('rewrite', item, opts.config.basePath, opts.config.experimental.caseSensitiveRoutes)),\n        fallback: customRoutes.rewrites.fallback.map((item)=>buildCustomRoute('rewrite', item, opts.config.basePath, opts.config.experimental.caseSensitiveRoutes))\n    };\n    const { i18n } = opts.config;\n    const handleLocale = (pathname, locales)=>{\n        let locale;\n        if (i18n) {\n            const i18nResult = (0, _normalizelocalepath.normalizeLocalePath)(pathname, locales || i18n.locales);\n            pathname = i18nResult.pathname;\n            locale = i18nResult.detectedLocale;\n        }\n        return {\n            locale,\n            pathname\n        };\n    };\n    debug('nextDataRoutes', nextDataRoutes);\n    debug('dynamicRoutes', dynamicRoutes);\n    debug('customRoutes', customRoutes);\n    debug('publicFolderItems', publicFolderItems);\n    debug('nextStaticFolderItems', nextStaticFolderItems);\n    debug('pageFiles', pageFiles);\n    debug('appFiles', appFiles);\n    let ensureFn;\n    const normalizers = {\n        // Because we can't know if the app directory is enabled or not at this\n        // stage, we assume that it is.\n        rsc: new _rsc.RSCPathnameNormalizer(),\n        prefetchRSC: opts.config.experimental.ppr ? new _prefetchrsc.PrefetchRSCPathnameNormalizer() : undefined\n    };\n    return {\n        headers,\n        rewrites,\n        redirects,\n        buildId,\n        handleLocale,\n        appFiles,\n        pageFiles,\n        dynamicRoutes,\n        nextDataRoutes,\n        exportPathMapRoutes: undefined,\n        devVirtualFsItems: new Set(),\n        prerenderManifest,\n        middlewareMatcher: middlewareMatcher,\n        ensureCallback (fn) {\n            ensureFn = fn;\n        },\n        async getItem (itemPath) {\n            const originalItemPath = itemPath;\n            const itemKey = originalItemPath;\n            const lruResult = getItemsLru == null ? void 0 : getItemsLru.get(itemKey);\n            if (lruResult) {\n                return lruResult;\n            }\n            const { basePath } = opts.config;\n            const hasBasePath = (0, _pathhasprefix.pathHasPrefix)(itemPath, basePath);\n            // Return null if path doesn't start with basePath\n            if (basePath && !hasBasePath) {\n                return null;\n            }\n            // Remove basePath if it exists.\n            if (basePath && hasBasePath) {\n                itemPath = (0, _removepathprefix.removePathPrefix)(itemPath, basePath) || '/';\n            }\n            // Simulate minimal mode requests by normalizing RSC and postponed\n            // requests.\n            if (opts.minimalMode) {\n                var _normalizers_prefetchRSC;\n                if ((_normalizers_prefetchRSC = normalizers.prefetchRSC) == null ? void 0 : _normalizers_prefetchRSC.match(itemPath)) {\n                    itemPath = normalizers.prefetchRSC.normalize(itemPath, true);\n                } else if (normalizers.rsc.match(itemPath)) {\n                    itemPath = normalizers.rsc.normalize(itemPath, true);\n                }\n            }\n            if (itemPath !== '/' && itemPath.endsWith('/')) {\n                itemPath = itemPath.substring(0, itemPath.length - 1);\n            }\n            let decodedItemPath = itemPath;\n            try {\n                decodedItemPath = decodeURIComponent(itemPath);\n            } catch  {}\n            if (itemPath === '/_next/image') {\n                return {\n                    itemPath,\n                    type: 'nextImage'\n                };\n            }\n            const itemsToCheck = [\n                [\n                    this.devVirtualFsItems,\n                    'devVirtualFsItem'\n                ],\n                [\n                    nextStaticFolderItems,\n                    'nextStaticFolder'\n                ],\n                [\n                    legacyStaticFolderItems,\n                    'legacyStaticFolder'\n                ],\n                [\n                    publicFolderItems,\n                    'publicFolder'\n                ],\n                [\n                    appFiles,\n                    'appFile'\n                ],\n                [\n                    pageFiles,\n                    'pageFile'\n                ]\n            ];\n            for (let [items, type] of itemsToCheck){\n                let locale;\n                let curItemPath = itemPath;\n                let curDecodedItemPath = decodedItemPath;\n                const isDynamicOutput = type === 'pageFile' || type === 'appFile';\n                if (i18n) {\n                    var _i18n_domains;\n                    const localeResult = handleLocale(itemPath, // legacy behavior allows visiting static assets under\n                    // default locale but no other locale\n                    isDynamicOutput ? undefined : [\n                        i18n == null ? void 0 : i18n.defaultLocale,\n                        // default locales from domains need to be matched too\n                        ...((_i18n_domains = i18n.domains) == null ? void 0 : _i18n_domains.map((item)=>item.defaultLocale)) || []\n                    ]);\n                    if (localeResult.pathname !== curItemPath) {\n                        curItemPath = localeResult.pathname;\n                        locale = localeResult.locale;\n                        try {\n                            curDecodedItemPath = decodeURIComponent(curItemPath);\n                        } catch  {}\n                    }\n                }\n                if (type === 'legacyStaticFolder') {\n                    if (!(0, _pathhasprefix.pathHasPrefix)(curItemPath, '/static')) {\n                        continue;\n                    }\n                    curItemPath = curItemPath.substring('/static'.length);\n                    try {\n                        curDecodedItemPath = decodeURIComponent(curItemPath);\n                    } catch  {}\n                }\n                if (type === 'nextStaticFolder' && !(0, _pathhasprefix.pathHasPrefix)(curItemPath, '/_next/static')) {\n                    continue;\n                }\n                const nextDataPrefix = `/_next/data/${buildId}/`;\n                if (type === 'pageFile' && curItemPath.startsWith(nextDataPrefix) && curItemPath.endsWith('.json')) {\n                    items = nextDataRoutes;\n                    // remove _next/data/<build-id> prefix\n                    curItemPath = curItemPath.substring(nextDataPrefix.length - 1);\n                    // remove .json postfix\n                    curItemPath = curItemPath.substring(0, curItemPath.length - '.json'.length);\n                    const curLocaleResult = handleLocale(curItemPath);\n                    curItemPath = curLocaleResult.pathname === '/index' ? '/' : curLocaleResult.pathname;\n                    locale = curLocaleResult.locale;\n                    try {\n                        curDecodedItemPath = decodeURIComponent(curItemPath);\n                    } catch  {}\n                }\n                let matchedItem = items.has(curItemPath);\n                // check decoded variant as well\n                if (!matchedItem && !opts.dev) {\n                    matchedItem = items.has(curDecodedItemPath);\n                    if (matchedItem) curItemPath = curDecodedItemPath;\n                    else {\n                        // x-ref: https://github.com/vercel/next.js/issues/54008\n                        // There're cases that urls get decoded before requests, we should support both encoded and decoded ones.\n                        // e.g. nginx could decode the proxy urls, the below ones should be treated as the same:\n                        // decoded version: `/_next/static/chunks/pages/blog/[slug]-d4858831b91b69f6.js`\n                        // encoded version: `/_next/static/chunks/pages/blog/%5Bslug%5D-d4858831b91b69f6.js`\n                        try {\n                            // encode the special characters in the path and retrieve again to determine if path exists.\n                            const encodedCurItemPath = (0, _encodeuripath.encodeURIPath)(curItemPath);\n                            matchedItem = items.has(encodedCurItemPath);\n                        } catch  {}\n                    }\n                }\n                if (matchedItem || opts.dev) {\n                    let fsPath;\n                    let itemsRoot;\n                    switch(type){\n                        case 'nextStaticFolder':\n                            {\n                                itemsRoot = nextStaticFolderPath;\n                                curItemPath = curItemPath.substring('/_next/static'.length);\n                                break;\n                            }\n                        case 'legacyStaticFolder':\n                            {\n                                itemsRoot = legacyStaticFolderPath;\n                                break;\n                            }\n                        case 'publicFolder':\n                            {\n                                itemsRoot = publicFolderPath;\n                                break;\n                            }\n                        default:\n                            {\n                                break;\n                            }\n                    }\n                    if (itemsRoot && curItemPath) {\n                        fsPath = _path.default.posix.join(itemsRoot, curItemPath);\n                    }\n                    // dynamically check fs in development so we don't\n                    // have to wait on the watcher\n                    if (!matchedItem && opts.dev) {\n                        const isStaticAsset = [\n                            'nextStaticFolder',\n                            'publicFolder',\n                            'legacyStaticFolder'\n                        ].includes(type);\n                        if (isStaticAsset && itemsRoot) {\n                            let found = fsPath && await (0, _fileexists.fileExists)(fsPath, _fileexists.FileType.File);\n                            if (!found) {\n                                try {\n                                    // In dev, we ensure encoded paths match\n                                    // decoded paths on the filesystem so check\n                                    // that variation as well\n                                    const tempItemPath = decodeURIComponent(curItemPath);\n                                    fsPath = _path.default.posix.join(itemsRoot, tempItemPath);\n                                    found = await (0, _fileexists.fileExists)(fsPath, _fileexists.FileType.File);\n                                } catch  {}\n                                if (!found) {\n                                    continue;\n                                }\n                            }\n                        } else if (type === 'pageFile' || type === 'appFile') {\n                            var _ensureFn;\n                            const isAppFile = type === 'appFile';\n                            if (ensureFn && await ((_ensureFn = ensureFn({\n                                type,\n                                itemPath: isAppFile ? (0, _getmetadataroute.normalizeMetadataRoute)(curItemPath) : curItemPath\n                            })) == null ? void 0 : _ensureFn.catch(()=>'ENSURE_FAILED')) === 'ENSURE_FAILED') {\n                                continue;\n                            }\n                        } else {\n                            continue;\n                        }\n                    }\n                    // i18n locales aren't matched for app dir\n                    if (type === 'appFile' && locale && locale !== (i18n == null ? void 0 : i18n.defaultLocale)) {\n                        continue;\n                    }\n                    const itemResult = {\n                        type,\n                        fsPath,\n                        locale,\n                        itemsRoot,\n                        itemPath: curItemPath\n                    };\n                    getItemsLru == null ? void 0 : getItemsLru.set(itemKey, itemResult);\n                    return itemResult;\n                }\n            }\n            getItemsLru == null ? void 0 : getItemsLru.set(itemKey, null);\n            return null;\n        },\n        getDynamicRoutes () {\n            // this should include data routes\n            return this.dynamicRoutes;\n        },\n        getMiddlewareMatchers () {\n            return this.middlewareMatcher;\n        }\n    };\n}\n\n//# sourceMappingURL=filesystem.js.map"
        }
    ]
}