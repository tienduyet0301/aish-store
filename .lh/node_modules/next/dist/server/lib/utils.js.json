{
    "sourceFile": "node_modules/next/dist/server/lib/utils.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892878297,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    RESTART_EXIT_CODE: null,\n    formatDebugAddress: null,\n    formatNodeOptions: null,\n    getFormattedDebugAddress: null,\n    getFormattedNodeOptionsWithoutInspect: null,\n    getMaxOldSpaceSize: null,\n    getNodeDebugType: null,\n    getParsedDebugAddress: null,\n    getParsedNodeOptionsWithoutInspect: null,\n    parseValidPositiveInteger: null,\n    printAndExit: null,\n    tokenizeArgs: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    RESTART_EXIT_CODE: function() {\n        return RESTART_EXIT_CODE;\n    },\n    formatDebugAddress: function() {\n        return formatDebugAddress;\n    },\n    formatNodeOptions: function() {\n        return formatNodeOptions;\n    },\n    getFormattedDebugAddress: function() {\n        return getFormattedDebugAddress;\n    },\n    getFormattedNodeOptionsWithoutInspect: function() {\n        return getFormattedNodeOptionsWithoutInspect;\n    },\n    getMaxOldSpaceSize: function() {\n        return getMaxOldSpaceSize;\n    },\n    getNodeDebugType: function() {\n        return getNodeDebugType;\n    },\n    getParsedDebugAddress: function() {\n        return getParsedDebugAddress;\n    },\n    getParsedNodeOptionsWithoutInspect: function() {\n        return getParsedNodeOptionsWithoutInspect;\n    },\n    parseValidPositiveInteger: function() {\n        return parseValidPositiveInteger;\n    },\n    printAndExit: function() {\n        return printAndExit;\n    },\n    tokenizeArgs: function() {\n        return tokenizeArgs;\n    }\n});\nconst _nodeutil = require(\"node:util\");\nconst _commander = require(\"next/dist/compiled/commander\");\nfunction printAndExit(message, code = 1) {\n    if (code === 0) {\n        console.log(message);\n    } else {\n        console.error(message);\n    }\n    return process.exit(code);\n}\nconst parseNodeArgs = (args)=>{\n    const { values, tokens } = (0, _nodeutil.parseArgs)({\n        args,\n        strict: false,\n        tokens: true\n    });\n    // For the `NODE_OPTIONS`, we support arguments with values without the `=`\n    // sign. We need to parse them manually.\n    let orphan = null;\n    for(let i = 0; i < tokens.length; i++){\n        const token = tokens[i];\n        if (token.kind === 'option-terminator') {\n            break;\n        }\n        // When we encounter an option, if it's value is undefined, we should check\n        // to see if the following tokens are positional parameters. If they are,\n        // then the option is orphaned, and we can assign it.\n        if (token.kind === 'option') {\n            orphan = typeof token.value === 'undefined' ? token : null;\n            continue;\n        }\n        // If the token isn't a positional one, then we can't assign it to the found\n        // orphaned option.\n        if (token.kind !== 'positional') {\n            orphan = null;\n            continue;\n        }\n        // If we don't have an orphan, then we can skip this token.\n        if (!orphan) {\n            continue;\n        }\n        // If the token is a positional one, and it has a value, so add it to the\n        // values object. If it already exists, append it with a space.\n        if (orphan.name in values && typeof values[orphan.name] === 'string') {\n            values[orphan.name] += ` ${token.value}`;\n        } else {\n            values[orphan.name] = token.value;\n        }\n    }\n    return values;\n};\nconst tokenizeArgs = (input)=>{\n    let args = [];\n    let isInString = false;\n    let willStartNewArg = true;\n    for(let i = 0; i < input.length; i++){\n        let char = input[i];\n        // Skip any escaped characters in strings.\n        if (char === '\\\\' && isInString) {\n            // Ensure we don't have an escape character at the end.\n            if (input.length === i + 1) {\n                throw Object.defineProperty(new Error('Invalid escape character at the end.'), \"__NEXT_ERROR_CODE\", {\n                    value: \"E168\",\n                    enumerable: false,\n                    configurable: true\n                });\n            }\n            // Skip the next character.\n            char = input[++i];\n        } else if (char === ' ' && !isInString) {\n            willStartNewArg = true;\n            continue;\n        } else if (char === '\"') {\n            isInString = !isInString;\n            continue;\n        }\n        // If we're starting a new argument, we should add it to the array.\n        if (willStartNewArg) {\n            args.push(char);\n            willStartNewArg = false;\n        } else {\n            args[args.length - 1] += char;\n        }\n    }\n    if (isInString) {\n        throw Object.defineProperty(new Error('Unterminated string'), \"__NEXT_ERROR_CODE\", {\n            value: \"E208\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    return args;\n};\n/**\n * Get the node options from the environment variable `NODE_OPTIONS` and returns\n * them as an array of strings.\n *\n * @returns An array of strings with the node options.\n */ const getNodeOptionsArgs = ()=>{\n    if (!process.env.NODE_OPTIONS) return [];\n    return tokenizeArgs(process.env.NODE_OPTIONS);\n};\nconst formatDebugAddress = ({ host, port })=>{\n    if (host) return `${host}:${port}`;\n    return `${port}`;\n};\nconst getParsedDebugAddress = ()=>{\n    const args = getNodeOptionsArgs();\n    if (args.length === 0) return {\n        host: undefined,\n        port: 9229\n    };\n    const parsed = parseNodeArgs(args);\n    // We expect to find the debug port in one of these options. The first one\n    // found will be used.\n    const address = parsed.inspect ?? parsed['inspect-brk'] ?? parsed['inspect_brk'];\n    if (!address || typeof address !== 'string') {\n        return {\n            host: undefined,\n            port: 9229\n        };\n    }\n    // The address is in the form of `[host:]port`. Let's parse the address.\n    if (address.includes(':')) {\n        const [host, port] = address.split(':');\n        return {\n            host,\n            port: parseInt(port, 10)\n        };\n    }\n    return {\n        host: undefined,\n        port: parseInt(address, 10)\n    };\n};\nconst getFormattedDebugAddress = ()=>formatDebugAddress(getParsedDebugAddress());\nfunction formatNodeOptions(args) {\n    return Object.entries(args).map(([key, value])=>{\n        if (value === true) {\n            return `--${key}`;\n        }\n        if (value) {\n            return `--${key}=${// Values with spaces need to be quoted. We use JSON.stringify to\n            // also escape any nested quotes.\n            value.includes(' ') && !value.startsWith('\"') ? JSON.stringify(value) : value}`;\n        }\n        return null;\n    }).filter((arg)=>arg !== null).join(' ');\n}\nfunction getParsedNodeOptionsWithoutInspect() {\n    const args = getNodeOptionsArgs();\n    if (args.length === 0) return {};\n    const parsed = parseNodeArgs(args);\n    // Remove inspect options.\n    delete parsed.inspect;\n    delete parsed['inspect-brk'];\n    delete parsed['inspect_brk'];\n    return parsed;\n}\nfunction getFormattedNodeOptionsWithoutInspect() {\n    const args = getParsedNodeOptionsWithoutInspect();\n    if (Object.keys(args).length === 0) return '';\n    return formatNodeOptions(args);\n}\nfunction parseValidPositiveInteger(value) {\n    const parsedValue = parseInt(value, 10);\n    if (isNaN(parsedValue) || !isFinite(parsedValue) || parsedValue < 0) {\n        throw new _commander.InvalidArgumentError(`'${value}' is not a non-negative number.`);\n    }\n    return parsedValue;\n}\nconst RESTART_EXIT_CODE = 77;\nfunction getNodeDebugType() {\n    const args = [\n        ...process.execArgv,\n        ...getNodeOptionsArgs()\n    ];\n    if (args.length === 0) return;\n    const parsed = parseNodeArgs(args);\n    if (parsed.inspect) return 'inspect';\n    if (parsed['inspect-brk'] || parsed['inspect_brk']) return 'inspect-brk';\n}\nfunction getMaxOldSpaceSize() {\n    const args = getNodeOptionsArgs();\n    if (args.length === 0) return;\n    const parsed = parseNodeArgs(args);\n    const size = parsed['max-old-space-size'] || parsed['max_old_space_size'];\n    if (!size || typeof size !== 'string') return;\n    return parseInt(size, 10);\n}\n\n//# sourceMappingURL=utils.js.map"
        }
    ]
}