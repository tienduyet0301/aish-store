{
    "sourceFile": "node_modules/next/dist/server/lib/trace/tracer.d.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892878084,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import type { FetchEventResult } from '../../web/types';\nimport type { SpanTypes } from './constants';\nimport type { ContextAPI, Span, SpanOptions, AttributeValue, TextMapGetter } from 'next/dist/compiled/@opentelemetry/api';\ndeclare const SpanStatusCode: typeof import(\"@opentelemetry/api\").SpanStatusCode, SpanKind: typeof import(\"@opentelemetry/api\").SpanKind;\nexport declare class BubbledError extends Error {\n    readonly bubble?: boolean | undefined;\n    readonly result?: FetchEventResult | undefined;\n    constructor(bubble?: boolean | undefined, result?: FetchEventResult | undefined);\n}\nexport declare function isBubbledError(error: unknown): error is BubbledError;\ntype TracerSpanOptions = Omit<SpanOptions, 'attributes'> & {\n    parentSpan?: Span;\n    spanName?: string;\n    attributes?: Partial<Record<AttributeNames, AttributeValue | undefined>>;\n    hideSpan?: boolean;\n};\ninterface NextTracer {\n    getContext(): ContextAPI;\n    /**\n     * Instruments a function by automatically creating a span activated on its\n     * scope.\n     *\n     * The span will automatically be finished when one of these conditions is\n     * met:\n     *\n     * * The function returns a promise, in which case the span will finish when\n     * the promise is resolved or rejected.\n     * * The function takes a callback as its second parameter, in which case the\n     * span will finish when that callback is called.\n     * * The function doesn't accept a callback and doesn't return a promise, in\n     * which case the span will finish at the end of the function execution.\n     *\n     */\n    trace<T>(type: SpanTypes, fn: (span?: Span, done?: (error?: Error) => any) => Promise<T>): Promise<T>;\n    trace<T>(type: SpanTypes, fn: (span?: Span, done?: (error?: Error) => any) => T): T;\n    trace<T>(type: SpanTypes, options: TracerSpanOptions, fn: (span?: Span, done?: (error?: Error) => any) => Promise<T>): Promise<T>;\n    trace<T>(type: SpanTypes, options: TracerSpanOptions, fn: (span?: Span, done?: (error?: Error) => any) => T): T;\n    /**\n     * Wrap a function to automatically create a span activated on its\n     * scope when it's called.\n     *\n     * The span will automatically be finished when one of these conditions is\n     * met:\n     *\n     * * The function returns a promise, in which case the span will finish when\n     * the promise is resolved or rejected.\n     * * The function takes a callback as its last parameter, in which case the\n     * span will finish when that callback is called.\n     * * The function doesn't accept a callback and doesn't return a promise, in\n     * which case the span will finish at the end of the function execution.\n     */\n    wrap<T = (...args: Array<any>) => any>(type: SpanTypes, fn: T): T;\n    wrap<T = (...args: Array<any>) => any>(type: SpanTypes, options: TracerSpanOptions, fn: T): T;\n    wrap<T = (...args: Array<any>) => any>(type: SpanTypes, options: (...args: any[]) => TracerSpanOptions, fn: T): T;\n    /**\n     * Starts and returns a new Span representing a logical unit of work.\n     *\n     * This method do NOT modify the current Context by default. In result, any inner span will not\n     * automatically set its parent context to the span created by this method unless manually activate\n     * context via `tracer.getContext().with`. `trace`, or `wrap` is generally recommended as it gracefully\n     * handles context activation. (ref: https://github.com/open-telemetry/opentelemetry-js/issues/1923)\n     */\n    startSpan(type: SpanTypes): Span;\n    startSpan(type: SpanTypes, options: TracerSpanOptions): Span;\n    /**\n     * Returns currently activated span if current context is in the scope of the span.\n     * Returns undefined otherwise.\n     */\n    getActiveScopeSpan(): Span | undefined;\n    /**\n     * Returns trace propagation data for the currently active context. The format is equal to data provided\n     * through the OpenTelemetry propagator API.\n     */\n    getTracePropagationData(): ClientTraceDataEntry[];\n}\ntype NextAttributeNames = 'next.route' | 'next.page' | 'next.rsc' | 'next.segment' | 'next.span_name' | 'next.span_type' | 'next.clientComponentLoadCount';\ntype OTELAttributeNames = `http.${string}` | `net.${string}`;\ntype AttributeNames = NextAttributeNames | OTELAttributeNames;\nexport interface ClientTraceDataEntry {\n    key: string;\n    value: string;\n}\ndeclare class NextTracerImpl implements NextTracer {\n    /**\n     * Returns an instance to the trace with configured name.\n     * Since wrap / trace can be defined in any place prior to actual trace subscriber initialization,\n     * This should be lazily evaluated.\n     */\n    private getTracerInstance;\n    getContext(): ContextAPI;\n    getTracePropagationData(): ClientTraceDataEntry[];\n    getActiveScopeSpan(): Span | undefined;\n    withPropagatedContext<T, C>(carrier: C, fn: () => T, getter?: TextMapGetter<C>): T;\n    trace<T>(type: SpanTypes, fn: (span?: Span, done?: (error?: Error) => any) => Promise<T>): Promise<T>;\n    trace<T>(type: SpanTypes, fn: (span?: Span, done?: (error?: Error) => any) => T): T;\n    trace<T>(type: SpanTypes, options: TracerSpanOptions, fn: (span?: Span, done?: (error?: Error) => any) => Promise<T>): Promise<T>;\n    trace<T>(type: SpanTypes, options: TracerSpanOptions, fn: (span?: Span, done?: (error?: Error) => any) => T): T;\n    wrap<T = (...args: Array<any>) => any>(type: SpanTypes, fn: T): T;\n    wrap<T = (...args: Array<any>) => any>(type: SpanTypes, options: TracerSpanOptions, fn: T): T;\n    wrap<T = (...args: Array<any>) => any>(type: SpanTypes, options: (...args: any[]) => TracerSpanOptions, fn: T): T;\n    startSpan(type: SpanTypes): Span;\n    startSpan(type: SpanTypes, options: TracerSpanOptions): Span;\n    private getSpanContext;\n    getRootSpanAttributes(): Map<AttributeNames, AttributeValue | undefined> | undefined;\n    setRootSpanAttribute(key: AttributeNames, value: AttributeValue): void;\n}\ndeclare const getTracer: () => NextTracerImpl;\nexport { getTracer, SpanStatusCode, SpanKind };\nexport type { NextTracer, Span, SpanOptions, ContextAPI, TracerSpanOptions };\n"
        }
    ]
}