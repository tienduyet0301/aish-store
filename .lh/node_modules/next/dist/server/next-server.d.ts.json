{
    "sourceFile": "node_modules/next/dist/server/next-server.d.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892878687,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import './node-environment';\nimport './require-hook';\nimport './node-polyfill-crypto';\nimport type { CacheFs } from '../shared/lib/utils';\nimport type { MiddlewareManifest } from '../build/webpack/plugins/middleware-plugin';\nimport type RenderResult from './render-result';\nimport type { FetchEventResult } from './web/types';\nimport type { PrerenderManifest } from '../build';\nimport type { PagesManifest } from '../build/webpack/plugins/pages-manifest-plugin';\nimport type { NextParsedUrlQuery, NextUrlWithParsedQuery } from './request-meta';\nimport type { Params } from './request/params';\nimport type { RouteMatch } from './route-matches/route-match';\nimport type { IncomingMessage, ServerResponse } from 'http';\nimport type { UrlWithParsedQuery } from 'url';\nimport type { ParsedUrlQuery } from 'querystring';\nimport type { ParsedUrl } from '../shared/lib/router/utils/parse-url';\nimport type { CacheControl } from './lib/cache-control';\nimport type { WaitUntil } from './after/builtin-request-context';\nimport { NodeNextRequest, NodeNextResponse } from './base-http/node';\nimport type { Options, FindComponentsResult, MiddlewareRoutingItem, RequestContext, NormalizedRouteManifest, LoadedRenderOpts, RouteHandler, NextEnabledDirectories, BaseRequestHandler } from './base-server';\nimport BaseServer from './base-server';\nimport type { LoadComponentsReturnType } from './load-components';\nimport ResponseCache, { type IncrementalResponseCacheEntry } from './response-cache';\nimport { IncrementalCache } from './lib/incremental-cache';\nimport type { PagesAPIRouteMatch } from './route-matches/pages-api-route-match';\nimport type { NextFontManifest } from '../build/webpack/plugins/next-font-manifest-plugin';\nimport type { ServerOnInstrumentationRequestError } from './app-render/types';\nimport { AsyncCallbackSet } from './lib/async-callback-set';\nexport * from './base-server';\nexport type NodeRequestHandler = BaseRequestHandler<IncomingMessage | NodeNextRequest, ServerResponse | NodeNextResponse>;\ntype NodeRouteHandler = RouteHandler<NodeNextRequest, NodeNextResponse>;\nexport default class NextNodeServer extends BaseServer<Options, NodeNextRequest, NodeNextResponse> {\n    protected middlewareManifestPath: string;\n    private _serverDistDir;\n    private imageResponseCache?;\n    private registeredInstrumentation;\n    protected renderWorkersPromises?: Promise<void>;\n    protected dynamicRoutes?: {\n        match: import('../shared/lib/router/utils/route-matcher').RouteMatchFn;\n        page: string;\n        re: RegExp;\n    }[];\n    private routerServerHandler?;\n    protected cleanupListeners: AsyncCallbackSet;\n    protected internalWaitUntil: WaitUntil | undefined;\n    private isDev;\n    private sriEnabled;\n    constructor(options: Options);\n    unstable_preloadEntries(): Promise<void>;\n    protected handleUpgrade(): Promise<void>;\n    protected loadInstrumentationModule(): Promise<import(\"./instrumentation/types\").InstrumentationModule | undefined>;\n    protected prepareImpl(): Promise<void>;\n    protected runInstrumentationHookIfAvailable(): Promise<void>;\n    protected loadEnvConfig({ dev, forceReload, silent, }: {\n        dev: boolean;\n        forceReload?: boolean;\n        silent?: boolean;\n    }): void;\n    private loadCustomCacheHandlers;\n    protected getIncrementalCache({ requestHeaders, requestProtocol, }: {\n        requestHeaders: IncrementalCache['requestHeaders'];\n        requestProtocol: 'http' | 'https';\n    }): Promise<IncrementalCache>;\n    protected getResponseCache(): ResponseCache;\n    protected getPublicDir(): string;\n    protected getHasStaticDir(): boolean;\n    protected getPagesManifest(): PagesManifest | undefined;\n    protected getAppPathsManifest(): PagesManifest | undefined;\n    protected getinterceptionRoutePatterns(): RegExp[];\n    protected hasPage(pathname: string): Promise<boolean>;\n    protected getBuildId(): string;\n    protected getEnabledDirectories(dev: boolean): NextEnabledDirectories;\n    protected sendRenderResult(req: NodeNextRequest, res: NodeNextResponse, options: {\n        result: RenderResult;\n        type: 'html' | 'json' | 'rsc';\n        generateEtags: boolean;\n        poweredByHeader: boolean;\n        cacheControl: CacheControl | undefined;\n    }): Promise<void>;\n    protected runApi(req: NodeNextRequest, res: NodeNextResponse, query: ParsedUrlQuery, match: PagesAPIRouteMatch): Promise<boolean>;\n    protected renderHTML(req: NodeNextRequest, res: NodeNextResponse, pathname: string, query: NextParsedUrlQuery, renderOpts: LoadedRenderOpts): Promise<RenderResult>;\n    private renderHTMLImpl;\n    protected imageOptimizer(req: NodeNextRequest, res: NodeNextResponse, paramsResult: import('./image-optimizer').ImageParamsResult, previousCacheEntry?: IncrementalResponseCacheEntry | null): Promise<{\n        buffer: Buffer;\n        contentType: string;\n        maxAge: number;\n        upstreamEtag: string;\n        etag: string;\n    }>;\n    protected getPagePath(pathname: string, locales?: string[]): string;\n    protected renderPageComponent(ctx: RequestContext<NodeNextRequest, NodeNextResponse>, bubbleNoFallback: boolean): Promise<false | {\n        type: \"html\" | \"json\" | \"rsc\";\n        body: RenderResult;\n        cacheControl?: CacheControl;\n    } | null>;\n    protected findPageComponents({ locale, page, query, params, isAppPath, url, }: {\n        locale: string | undefined;\n        page: string;\n        query: NextParsedUrlQuery;\n        params: Params;\n        isAppPath: boolean;\n        sriEnabled?: boolean;\n        appPaths?: ReadonlyArray<string> | null;\n        shouldEnsure: boolean;\n        url?: string;\n    }): Promise<FindComponentsResult | null>;\n    private findPageComponentsImpl;\n    protected getNextFontManifest(): NextFontManifest | undefined;\n    protected handleNextImageRequest: NodeRouteHandler;\n    protected handleCatchallRenderRequest: NodeRouteHandler;\n    protected logErrorWithOriginalStack(_err?: unknown, _type?: 'unhandledRejection' | 'uncaughtException' | 'warning' | 'app-dir'): void;\n    protected ensurePage(_opts: {\n        page: string;\n        clientOnly: boolean;\n        appPaths?: ReadonlyArray<string> | null;\n        match?: RouteMatch;\n        url?: string;\n    }): Promise<void>;\n    /**\n     * Resolves `API` request, in development builds on demand\n     * @param req http request\n     * @param res http response\n     * @param pathname path of request\n     */\n    protected handleApiRequest(req: NodeNextRequest, res: NodeNextResponse, query: ParsedUrlQuery, match: PagesAPIRouteMatch): Promise<boolean>;\n    protected getCacheFilesystem(): CacheFs;\n    protected normalizeReq(req: NodeNextRequest | IncomingMessage): NodeNextRequest;\n    protected normalizeRes(res: NodeNextResponse | ServerResponse): NodeNextResponse;\n    getRequestHandler(): NodeRequestHandler;\n    private makeRequestHandler;\n    revalidate({ urlPath, revalidateHeaders, opts, }: {\n        urlPath: string;\n        revalidateHeaders: {\n            [key: string]: string | string[];\n        };\n        opts: {\n            unstable_onlyGenerated?: boolean;\n        };\n    }): Promise<void>;\n    render(req: NodeNextRequest | IncomingMessage, res: NodeNextResponse | ServerResponse, pathname: string, query?: NextParsedUrlQuery, parsedUrl?: NextUrlWithParsedQuery, internal?: boolean): Promise<void>;\n    renderToHTML(req: NodeNextRequest | IncomingMessage, res: NodeNextResponse | ServerResponse, pathname: string, query?: ParsedUrlQuery): Promise<string | null>;\n    protected renderErrorToResponseImpl(ctx: RequestContext<NodeNextRequest, NodeNextResponse>, err: Error | null): Promise<{\n        type: \"html\" | \"json\" | \"rsc\";\n        body: RenderResult;\n        cacheControl?: CacheControl;\n    } | null>;\n    renderError(err: Error | null, req: NodeNextRequest | IncomingMessage, res: NodeNextResponse | ServerResponse, pathname: string, query?: NextParsedUrlQuery, setHeaders?: boolean): Promise<void>;\n    renderErrorToHTML(err: Error | null, req: NodeNextRequest | IncomingMessage, res: NodeNextResponse | ServerResponse, pathname: string, query?: ParsedUrlQuery): Promise<string | null>;\n    render404(req: NodeNextRequest | IncomingMessage, res: NodeNextResponse | ServerResponse, parsedUrl?: NextUrlWithParsedQuery, setHeaders?: boolean): Promise<void>;\n    protected getMiddlewareManifest(): MiddlewareManifest | null;\n    /** Returns the middleware routing item if there is one. */\n    protected getMiddleware(): Promise<MiddlewareRoutingItem | undefined>;\n    protected getEdgeFunctionsPages(): string[];\n    /**\n     * Get information for the edge function located in the provided page\n     * folder. If the edge function info can't be found it will throw\n     * an error.\n     */\n    protected getEdgeFunctionInfo(params: {\n        page: string;\n        /** Whether we should look for a middleware or not */\n        middleware: boolean;\n    }): {\n        name: string;\n        paths: string[];\n        wasm: {\n            filePath: string;\n            name: string;\n        }[];\n        env: {\n            [key: string]: string;\n        };\n        assets?: {\n            filePath: string;\n            name: string;\n        }[];\n    } | null;\n    private loadNodeMiddleware;\n    /**\n     * Checks if a middleware exists. This method is useful for the development\n     * server where we need to check the filesystem. Here we just check the\n     * middleware manifest.\n     */\n    protected hasMiddleware(pathname: string): Promise<boolean>;\n    /**\n     * A placeholder for a function to be defined in the development server.\n     * It will make sure that the root middleware or an edge function has been compiled\n     * so that we can run it.\n     */\n    protected ensureMiddleware(_url?: string): Promise<void>;\n    protected ensureEdgeFunction(_params: {\n        page: string;\n        appPaths: string[] | null;\n        url?: string;\n    }): Promise<void>;\n    /**\n     * This method gets all middleware matchers and execute them when the request\n     * matches. It will make sure that each middleware exists and is compiled and\n     * ready to be invoked. The development server will decorate it to add warns\n     * and errors with rich traces.\n     */\n    protected runMiddleware(params: {\n        request: NodeNextRequest;\n        response: NodeNextResponse;\n        parsedUrl: ParsedUrl;\n        parsed: UrlWithParsedQuery;\n        onWarning?: (warning: Error) => void;\n    }): Promise<FetchEventResult | {\n        finished: boolean;\n    }>;\n    protected handleCatchallMiddlewareRequest: NodeRouteHandler;\n    private _cachedPreviewManifest;\n    protected getPrerenderManifest(): PrerenderManifest;\n    protected getRoutesManifest(): NormalizedRouteManifest | undefined;\n    protected attachRequestMeta(req: NodeNextRequest, parsedUrl: NextUrlWithParsedQuery, isUpgradeReq?: boolean): void;\n    protected runEdgeFunction(params: {\n        req: NodeNextRequest;\n        res: NodeNextResponse;\n        query: ParsedUrlQuery;\n        params: Params | undefined;\n        page: string;\n        appPaths: string[] | null;\n        match?: RouteMatch;\n        onError?: (err: unknown) => void;\n        onWarning?: (warning: Error) => void;\n    }): Promise<FetchEventResult | null>;\n    protected get serverDistDir(): string;\n    protected getFallbackErrorComponents(_url?: string): Promise<LoadComponentsReturnType | null>;\n    protected instrumentationOnRequestError(...args: Parameters<ServerOnInstrumentationRequestError>): Promise<void>;\n    protected onServerClose(listener: () => Promise<void>): void;\n    close(): Promise<void>;\n    protected getInternalWaitUntil(): WaitUntil;\n    private createInternalWaitUntil;\n}\n"
        }
    ]
}