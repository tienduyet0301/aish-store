{
    "sourceFile": "node_modules/next/dist/server/after/awaiter.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892866214,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    AwaiterMulti: null,\n    AwaiterOnce: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    AwaiterMulti: function() {\n        return AwaiterMulti;\n    },\n    AwaiterOnce: function() {\n        return AwaiterOnce;\n    }\n});\nconst _invarianterror = require(\"../../shared/lib/invariant-error\");\nclass AwaiterMulti {\n    constructor({ onError } = {}){\n        this.promises = new Set();\n        this.waitUntil = (promise)=>{\n            // if a promise settles before we await it, we should drop it --\n            // storing them indefinitely could result in a memory leak.\n            const cleanup = ()=>{\n                this.promises.delete(promise);\n            };\n            promise.then(cleanup, (err)=>{\n                cleanup();\n                this.onError(err);\n            });\n            this.promises.add(promise);\n        };\n        this.onError = onError ?? console.error;\n    }\n    async awaiting() {\n        while(this.promises.size > 0){\n            const promises = Array.from(this.promises);\n            this.promises.clear();\n            await Promise.allSettled(promises);\n        }\n    }\n}\nclass AwaiterOnce {\n    constructor(options = {}){\n        this.done = false;\n        this.waitUntil = (promise)=>{\n            if (this.done) {\n                throw Object.defineProperty(new _invarianterror.InvariantError('Cannot call waitUntil() on an AwaiterOnce that was already awaited'), \"__NEXT_ERROR_CODE\", {\n                    value: \"E563\",\n                    enumerable: false,\n                    configurable: true\n                });\n            }\n            return this.awaiter.waitUntil(promise);\n        };\n        this.awaiter = new AwaiterMulti(options);\n    }\n    async awaiting() {\n        if (!this.pending) {\n            this.pending = this.awaiter.awaiting().finally(()=>{\n                this.done = true;\n            });\n        }\n        return this.pending;\n    }\n}\n\n//# sourceMappingURL=awaiter.js.map"
        }
    ]
}