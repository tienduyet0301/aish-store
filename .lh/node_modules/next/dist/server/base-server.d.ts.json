{
    "sourceFile": "node_modules/next/dist/server/base-server.d.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892871690,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import type { __ApiPreviewProps } from './api-utils';\nimport type { LoadComponentsReturnType } from './load-components';\nimport type { MiddlewareRouteMatch } from '../shared/lib/router/utils/middleware-route-matcher';\nimport type { Params } from './request/params';\nimport type { NextConfig, NextConfigComplete } from './config-shared';\nimport type { NextParsedUrlQuery, NextUrlWithParsedQuery } from './request-meta';\nimport type { ParsedUrlQuery } from 'querystring';\nimport type { RenderOptsPartial as PagesRenderOptsPartial } from './render';\nimport type { RenderOptsPartial as AppRenderOptsPartial, ServerOnInstrumentationRequestError } from './app-render/types';\nimport { type ServerComponentsHmrCache, type ResponseCacheBase } from './response-cache';\nimport type { UrlWithParsedQuery } from 'url';\nimport type { PagesManifest } from '../build/webpack/plugins/pages-manifest-plugin';\nimport type { BaseNextRequest, BaseNextResponse } from './base-http';\nimport type { ManifestRewriteRoute, ManifestRoute, PrerenderManifest } from '../build';\nimport type { ClientReferenceManifest } from '../build/webpack/plugins/flight-manifest-plugin';\nimport type { NextFontManifest } from '../build/webpack/plugins/next-font-manifest-plugin';\nimport type { PagesAPIRouteMatch } from './route-matches/pages-api-route-match';\nimport type { Server as HTTPServer, IncomingMessage, ServerResponse as HTTPServerResponse } from 'http';\nimport type { MiddlewareMatcher } from '../build/analysis/get-page-static-info';\nimport type { InstrumentationModule } from './instrumentation/types';\nimport { type CacheControl } from './lib/cache-control';\nimport RenderResult from './render-result';\nimport type { RouteMatcherManager } from './route-matcher-managers/route-matcher-manager';\nimport { LocaleRouteNormalizer } from './normalizers/locale-route-normalizer';\nimport { I18NProvider } from './lib/i18n-provider';\nimport { RSCPathnameNormalizer } from './normalizers/request/rsc';\nimport { PrefetchRSCPathnameNormalizer } from './normalizers/request/prefetch-rsc';\nimport { NextDataPathnameNormalizer } from './normalizers/request/next-data';\nimport type { DeepReadonly } from '../shared/lib/deep-readonly';\nimport { type WaitUntil } from './after/builtin-request-context';\nimport { FallbackMode } from '../lib/fallback';\nimport { SegmentPrefixRSCPathnameNormalizer } from './normalizers/request/segment-prefix-rsc';\nexport type FindComponentsResult = {\n    components: LoadComponentsReturnType;\n    query: NextParsedUrlQuery;\n};\nexport interface MiddlewareRoutingItem {\n    page: string;\n    match: MiddlewareRouteMatch;\n    matchers?: MiddlewareMatcher[];\n}\nexport type RouteHandler<ServerRequest extends BaseNextRequest = BaseNextRequest, ServerResponse extends BaseNextResponse = BaseNextResponse> = (req: ServerRequest, res: ServerResponse, parsedUrl: NextUrlWithParsedQuery) => PromiseLike<boolean> | boolean;\n/**\n * The normalized route manifest is the same as the route manifest, but with\n * the rewrites normalized to the object shape that the router expects.\n */\nexport type NormalizedRouteManifest = {\n    readonly dynamicRoutes: ReadonlyArray<ManifestRoute>;\n    readonly rewrites: {\n        readonly beforeFiles: ReadonlyArray<ManifestRewriteRoute>;\n        readonly afterFiles: ReadonlyArray<ManifestRewriteRoute>;\n        readonly fallback: ReadonlyArray<ManifestRewriteRoute>;\n    };\n};\nexport interface Options {\n    /**\n     * Object containing the configuration next.config.js\n     */\n    conf: NextConfig;\n    /**\n     * Set to false when the server was created by Next.js\n     */\n    customServer?: boolean;\n    /**\n     * Tells if Next.js is running in dev mode\n     */\n    dev?: boolean;\n    /**\n     * Enables the experimental testing mode.\n     */\n    experimentalTestProxy?: boolean;\n    /**\n     * Whether or not the dev server is running in experimental HTTPS mode\n     */\n    experimentalHttpsServer?: boolean;\n    /**\n     * Where the Next project is located\n     */\n    dir?: string;\n    /**\n     * Tells if Next.js is at the platform-level\n     */\n    minimalMode?: boolean;\n    /**\n     * Hide error messages containing server information\n     */\n    quiet?: boolean;\n    /**\n     * The hostname the server is running behind\n     */\n    hostname?: string;\n    /**\n     * The port the server is running behind\n     */\n    port?: number;\n    /**\n     * The HTTP Server that Next.js is running behind\n     */\n    httpServer?: HTTPServer;\n}\nexport type RenderOpts = PagesRenderOptsPartial & AppRenderOptsPartial;\nexport type LoadedRenderOpts = RenderOpts & LoadComponentsReturnType & RequestLifecycleOpts;\nexport type RequestLifecycleOpts = {\n    waitUntil: ((promise: Promise<any>) => void) | undefined;\n    onClose: (callback: () => void) => void;\n    onAfterTaskError: ((error: unknown) => void) | undefined;\n};\ntype BaseRenderOpts = RenderOpts & {\n    poweredByHeader: boolean;\n    generateEtags: boolean;\n    previewProps: __ApiPreviewProps;\n};\n/**\n * The public interface for rendering with the server programmatically. This\n * would typically only allow the base request or response to extend it, but\n * because this can be programmatically accessed, we assume that it could also\n * be the base Node.js request and response types.\n */\nexport interface BaseRequestHandler<ServerRequest extends BaseNextRequest | IncomingMessage = BaseNextRequest, ServerResponse extends BaseNextResponse | HTTPServerResponse = BaseNextResponse> {\n    (req: ServerRequest, res: ServerResponse, parsedUrl?: NextUrlWithParsedQuery | undefined): Promise<void> | void;\n}\nexport type RequestContext<ServerRequest extends BaseNextRequest = BaseNextRequest, ServerResponse extends BaseNextResponse = BaseNextResponse> = {\n    req: ServerRequest;\n    res: ServerResponse;\n    pathname: string;\n    query: NextParsedUrlQuery;\n    renderOpts: RenderOpts;\n};\nexport declare class NoFallbackError extends Error {\n}\nexport declare class WrappedBuildError extends Error {\n    innerError: Error;\n    constructor(innerError: Error);\n}\ntype ResponsePayload = {\n    type: 'html' | 'json' | 'rsc';\n    body: RenderResult;\n    cacheControl?: CacheControl;\n};\nexport type NextEnabledDirectories = {\n    readonly pages: boolean;\n    readonly app: boolean;\n};\nexport default abstract class Server<ServerOptions extends Options = Options, ServerRequest extends BaseNextRequest = BaseNextRequest, ServerResponse extends BaseNextResponse = BaseNextResponse> {\n    readonly hostname?: string;\n    readonly fetchHostname?: string;\n    readonly port?: number;\n    protected readonly dir: string;\n    protected readonly quiet: boolean;\n    protected readonly nextConfig: NextConfigComplete;\n    protected readonly distDir: string;\n    protected readonly publicDir: string;\n    protected readonly hasStaticDir: boolean;\n    protected readonly pagesManifest?: PagesManifest;\n    protected readonly appPathsManifest?: PagesManifest;\n    protected readonly buildId: string;\n    protected readonly minimalMode: boolean;\n    protected readonly renderOpts: BaseRenderOpts;\n    protected readonly serverOptions: Readonly<ServerOptions>;\n    protected readonly appPathRoutes?: Record<string, string[]>;\n    protected readonly clientReferenceManifest?: DeepReadonly<ClientReferenceManifest>;\n    protected interceptionRoutePatterns: RegExp[];\n    protected nextFontManifest?: DeepReadonly<NextFontManifest>;\n    protected instrumentation: InstrumentationModule | undefined;\n    private readonly responseCache;\n    protected abstract getPublicDir(): string;\n    protected abstract getHasStaticDir(): boolean;\n    protected abstract getPagesManifest(): PagesManifest | undefined;\n    protected abstract getAppPathsManifest(): PagesManifest | undefined;\n    protected abstract getBuildId(): string;\n    protected abstract getinterceptionRoutePatterns(): RegExp[];\n    protected readonly enabledDirectories: NextEnabledDirectories;\n    protected abstract getEnabledDirectories(dev: boolean): NextEnabledDirectories;\n    protected readonly experimentalTestProxy?: boolean;\n    protected abstract findPageComponents(params: {\n        locale: string | undefined;\n        page: string;\n        query: NextParsedUrlQuery;\n        params: Params;\n        isAppPath: boolean;\n        sriEnabled?: boolean;\n        appPaths?: ReadonlyArray<string> | null;\n        shouldEnsure?: boolean;\n        url?: string;\n    }): Promise<FindComponentsResult | null>;\n    protected abstract getPrerenderManifest(): DeepReadonly<PrerenderManifest>;\n    protected abstract getNextFontManifest(): DeepReadonly<NextFontManifest> | undefined;\n    protected abstract attachRequestMeta(req: ServerRequest, parsedUrl: NextUrlWithParsedQuery): void;\n    protected abstract hasPage(pathname: string): Promise<boolean>;\n    protected abstract sendRenderResult(req: ServerRequest, res: ServerResponse, options: {\n        result: RenderResult;\n        type: 'html' | 'json' | 'rsc';\n        generateEtags: boolean;\n        poweredByHeader: boolean;\n        cacheControl: CacheControl | undefined;\n    }): Promise<void>;\n    protected abstract runApi(req: ServerRequest, res: ServerResponse, query: ParsedUrlQuery, match: PagesAPIRouteMatch): Promise<boolean>;\n    protected abstract renderHTML(req: ServerRequest, res: ServerResponse, pathname: string, query: NextParsedUrlQuery, renderOpts: LoadedRenderOpts): Promise<RenderResult>;\n    protected abstract getIncrementalCache(options: {\n        requestHeaders: Record<string, undefined | string | string[]>;\n        requestProtocol: 'http' | 'https';\n    }): Promise<import('./lib/incremental-cache').IncrementalCache>;\n    protected abstract getResponseCache(options: {\n        dev: boolean;\n    }): ResponseCacheBase;\n    protected getServerComponentsHmrCache(): ServerComponentsHmrCache | undefined;\n    protected abstract loadEnvConfig(params: {\n        dev: boolean;\n        forceReload?: boolean;\n    }): void;\n    readonly matchers: RouteMatcherManager;\n    protected readonly i18nProvider?: I18NProvider;\n    protected readonly localeNormalizer?: LocaleRouteNormalizer;\n    protected readonly normalizers: {\n        readonly rsc: RSCPathnameNormalizer | undefined;\n        readonly prefetchRSC: PrefetchRSCPathnameNormalizer | undefined;\n        readonly segmentPrefetchRSC: SegmentPrefixRSCPathnameNormalizer | undefined;\n        readonly data: NextDataPathnameNormalizer | undefined;\n    };\n    private readonly isAppPPREnabled;\n    private readonly isAppSegmentPrefetchEnabled;\n    /**\n     * This is used to persist cache scopes across\n     * prefetch -> full route requests for dynamic IO\n     * it's only fully used in dev\n     */\n    constructor(options: ServerOptions);\n    protected reloadMatchers(): Promise<void>;\n    private handleRSCRequest;\n    private handleNextDataRequest;\n    protected handleNextImageRequest: RouteHandler<ServerRequest, ServerResponse>;\n    protected handleCatchallRenderRequest: RouteHandler<ServerRequest, ServerResponse>;\n    protected handleCatchallMiddlewareRequest: RouteHandler<ServerRequest, ServerResponse>;\n    protected getRouteMatchers(): RouteMatcherManager;\n    protected instrumentationOnRequestError(...args: Parameters<ServerOnInstrumentationRequestError>): Promise<void>;\n    logError(err: Error): void;\n    handleRequest(req: ServerRequest, res: ServerResponse, parsedUrl?: NextUrlWithParsedQuery): Promise<void>;\n    private handleRequestImpl;\n    /**\n     * Normalizes a pathname without attaching any metadata from any matched\n     * normalizer.\n     *\n     * @param pathname the pathname to normalize\n     * @returns the normalized pathname\n     */\n    private normalize;\n    private normalizeAndAttachMetadata;\n    getRequestHandler(): BaseRequestHandler<ServerRequest, ServerResponse>;\n    protected abstract handleUpgrade(req: ServerRequest, socket: any, head?: any): Promise<void>;\n    setAssetPrefix(prefix?: string): void;\n    protected prepared: boolean;\n    protected preparedPromise: Promise<void> | null;\n    /**\n     * Runs async initialization of server.\n     * It is idempotent, won't fire underlying initialization more than once.\n     */\n    prepare(): Promise<void>;\n    protected prepareImpl(): Promise<void>;\n    protected loadInstrumentationModule(): Promise<any>;\n    close(): Promise<void>;\n    protected getAppPathRoutes(): Record<string, string[]>;\n    protected run(req: ServerRequest, res: ServerResponse, parsedUrl: UrlWithParsedQuery): Promise<void>;\n    private runImpl;\n    private pipe;\n    private pipeImpl;\n    private getStaticHTML;\n    render(req: ServerRequest, res: ServerResponse, pathname: string, query?: NextParsedUrlQuery, parsedUrl?: NextUrlWithParsedQuery, internalRender?: boolean): Promise<void>;\n    protected getWaitUntil(): WaitUntil | undefined;\n    protected getInternalWaitUntil(): WaitUntil | undefined;\n    private renderImpl;\n    protected getStaticPaths({ pathname, }: {\n        pathname: string;\n        requestHeaders: import('./lib/incremental-cache').IncrementalCache['requestHeaders'];\n        page: string;\n        isAppPath: boolean;\n    }): Promise<{\n        staticPaths?: string[];\n        fallbackMode?: FallbackMode;\n    }>;\n    private renderToResponseWithComponents;\n    protected pathCouldBeIntercepted(resolvedPathname: string): boolean;\n    protected setVaryHeader(req: ServerRequest, res: ServerResponse, isAppPath: boolean, resolvedPathname: string): void;\n    private renderToResponseWithComponentsImpl;\n    private stripNextDataPath;\n    protected getOriginalAppPaths(route: string): string[] | null;\n    protected renderPageComponent(ctx: RequestContext<ServerRequest, ServerResponse>, bubbleNoFallback: boolean): Promise<false | ResponsePayload | null>;\n    private renderToResponse;\n    protected abstract getMiddleware(): Promise<MiddlewareRoutingItem | undefined>;\n    protected abstract getFallbackErrorComponents(url?: string): Promise<LoadComponentsReturnType | null>;\n    protected abstract getRoutesManifest(): NormalizedRouteManifest | undefined;\n    private renderToResponseImpl;\n    renderToHTML(req: ServerRequest, res: ServerResponse, pathname: string, query?: ParsedUrlQuery): Promise<string | null>;\n    private renderToHTMLImpl;\n    renderError(err: Error | null, req: ServerRequest, res: ServerResponse, pathname: string, query?: NextParsedUrlQuery, setHeaders?: boolean): Promise<void>;\n    private renderErrorImpl;\n    private customErrorNo404Warn;\n    private renderErrorToResponse;\n    protected renderErrorToResponseImpl(ctx: RequestContext<ServerRequest, ServerResponse>, err: Error | null): Promise<ResponsePayload | null>;\n    renderErrorToHTML(err: Error | null, req: ServerRequest, res: ServerResponse, pathname: string, query?: ParsedUrlQuery): Promise<string | null>;\n    render404(req: ServerRequest, res: ServerResponse, parsedUrl?: Pick<NextUrlWithParsedQuery, 'pathname' | 'query'>, setHeaders?: boolean): Promise<void>;\n}\nexport {};\n"
        }
    ]
}