{
    "sourceFile": "node_modules/next/dist/server/route-matcher-managers/dev-route-matcher-manager.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892883938,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"DevRouteMatcherManager\", {\n    enumerable: true,\n    get: function() {\n        return DevRouteMatcherManager;\n    }\n});\nconst _routekind = require(\"../route-kind\");\nconst _defaultroutematchermanager = require(\"./default-route-matcher-manager\");\nconst _path = /*#__PURE__*/ _interop_require_default(require(\"../../shared/lib/isomorphic/path\"));\nconst _log = /*#__PURE__*/ _interop_require_wildcard(require(\"../../build/output/log\"));\nconst _picocolors = require(\"../../lib/picocolors\");\nfunction _interop_require_default(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nfunction _getRequireWildcardCache(nodeInterop) {\n    if (typeof WeakMap !== \"function\") return null;\n    var cacheBabelInterop = new WeakMap();\n    var cacheNodeInterop = new WeakMap();\n    return (_getRequireWildcardCache = function(nodeInterop) {\n        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n    })(nodeInterop);\n}\nfunction _interop_require_wildcard(obj, nodeInterop) {\n    if (!nodeInterop && obj && obj.__esModule) {\n        return obj;\n    }\n    if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n        return {\n            default: obj\n        };\n    }\n    var cache = _getRequireWildcardCache(nodeInterop);\n    if (cache && cache.has(obj)) {\n        return cache.get(obj);\n    }\n    var newObj = {\n        __proto__: null\n    };\n    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n    for(var key in obj){\n        if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n            if (desc && (desc.get || desc.set)) {\n                Object.defineProperty(newObj, key, desc);\n            } else {\n                newObj[key] = obj[key];\n            }\n        }\n    }\n    newObj.default = obj;\n    if (cache) {\n        cache.set(obj, newObj);\n    }\n    return newObj;\n}\nclass DevRouteMatcherManager extends _defaultroutematchermanager.DefaultRouteMatcherManager {\n    constructor(production, ensurer, dir){\n        super(), this.production = production, this.ensurer = ensurer, this.dir = dir;\n    }\n    async test(pathname, options) {\n        // Try to find a match within the developer routes.\n        const match = await super.match(pathname, options);\n        // Return if the match wasn't null. Unlike the implementation of `match`\n        // which uses `matchAll` here, this does not call `ensure` on the match\n        // found via the development matches.\n        return match !== null;\n    }\n    validate(pathname, matcher, options) {\n        const match = super.validate(pathname, matcher, options);\n        // If a match was found, check to see if there were any conflicting app or\n        // pages files.\n        // TODO: maybe expand this to _any_ duplicated routes instead?\n        if (match && matcher.duplicated && matcher.duplicated.some((duplicate)=>duplicate.definition.kind === _routekind.RouteKind.APP_PAGE || duplicate.definition.kind === _routekind.RouteKind.APP_ROUTE) && matcher.duplicated.some((duplicate)=>duplicate.definition.kind === _routekind.RouteKind.PAGES || duplicate.definition.kind === _routekind.RouteKind.PAGES_API)) {\n            return null;\n        }\n        return match;\n    }\n    async *matchAll(pathname, options) {\n        // Compile the development routes.\n        // TODO: we may want to only run this during testing, users won't be fast enough to require this many dir scans\n        await super.reload();\n        // Iterate over the development matches to see if one of them match the\n        // request path.\n        for await (const development of super.matchAll(pathname, options)){\n            // We're here, which means that we haven't seen this match yet, so we\n            // should try to ensure it and recompile the production matcher.\n            await this.ensurer.ensure(development, pathname);\n            await this.production.reload();\n            // Iterate over the production matches again, this time we should be able\n            // to match it against the production matcher unless there's an error.\n            for await (const production of this.production.matchAll(pathname, options)){\n                yield production;\n            }\n        }\n        // We tried direct matching against the pathname and against all the dynamic\n        // paths, so there was no match.\n        return null;\n    }\n    async reload() {\n        // Compile the production routes again.\n        await this.production.reload();\n        // Compile the development routes.\n        await super.reload();\n        // Check for and warn of any duplicates.\n        for (const [pathname, matchers] of Object.entries(this.matchers.duplicates)){\n            // We only want to warn about matchers resolving to the same path if their\n            // identities are different.\n            const identity = matchers[0].identity;\n            if (matchers.slice(1).some((matcher)=>matcher.identity !== identity)) {\n                continue;\n            }\n            _log.warn(`Duplicate page detected. ${matchers.map((matcher)=>(0, _picocolors.cyan)(_path.default.relative(this.dir, matcher.definition.filename))).join(' and ')} resolve to ${(0, _picocolors.cyan)(pathname)}`);\n        }\n    }\n}\n\n//# sourceMappingURL=dev-route-matcher-manager.js.map"
        }
    ]
}