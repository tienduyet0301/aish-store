{
    "sourceFile": "node_modules/next/dist/server/request-meta.d.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892882518,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import type { IncomingMessage } from 'http';\nimport type { ParsedUrlQuery } from 'querystring';\nimport type { UrlWithParsedQuery } from 'url';\nimport type { BaseNextRequest } from './base-http';\nimport type { CloneableBody } from './body-streams';\nimport type { RouteMatch } from './route-matches/route-match';\nimport type { NEXT_RSC_UNION_QUERY } from '../client/components/app-router-headers';\nimport type { ServerComponentsHmrCache } from './response-cache';\nexport declare const NEXT_REQUEST_META: unique symbol;\nexport type NextIncomingMessage = (BaseNextRequest | IncomingMessage) & {\n    [NEXT_REQUEST_META]?: RequestMeta;\n};\nexport interface RequestMeta {\n    /**\n     * The query that was used to make the request.\n     */\n    initQuery?: ParsedUrlQuery;\n    /**\n     * The URL that was used to make the request.\n     */\n    initURL?: string;\n    /**\n     * The protocol that was used to make the request.\n     */\n    initProtocol?: string;\n    /**\n     * The body that was read from the request. This is used to allow the body to\n     * be read multiple times.\n     */\n    clonableBody?: CloneableBody;\n    /**\n     * True when the request matched a locale domain that was configured in the\n     * next.config.js file.\n     */\n    isLocaleDomain?: boolean;\n    /**\n     * True when the request had locale information stripped from the pathname\n     * part of the URL.\n     */\n    didStripLocale?: boolean;\n    /**\n     * If the request had it's URL rewritten, this is the URL it was rewritten to.\n     */\n    rewroteURL?: string;\n    /**\n     * The cookies that were added by middleware and were added to the response.\n     */\n    middlewareCookie?: string[];\n    /**\n     * The match on the request for a given route.\n     */\n    match?: RouteMatch;\n    /**\n     * The incremental cache to use for the request.\n     */\n    incrementalCache?: any;\n    /**\n     * The server components HMR cache, only for dev.\n     */\n    serverComponentsHmrCache?: ServerComponentsHmrCache;\n    /**\n     * Equals the segment path that was used for the prefetch RSC request.\n     */\n    segmentPrefetchRSCRequest?: string;\n    /**\n     * True when the request is for the prefetch flight data.\n     */\n    isPrefetchRSCRequest?: true;\n    /**\n     * True when the request is for the flight data.\n     */\n    isRSCRequest?: true;\n    /**\n     * True when the request is for the `/_next/data` route using the pages\n     * router.\n     */\n    isNextDataReq?: true;\n    /**\n     * Postponed state to use for resumption. If present it's assumed that the\n     * request is for a page that has postponed (there are no guarantees that the\n     * page actually has postponed though as it would incur an additional cache\n     * lookup).\n     */\n    postponed?: string;\n    /**\n     * If provided, this will be called when a response cache entry was generated\n     * or looked up in the cache.\n     */\n    onCacheEntry?: (cacheEntry: any, requestMeta: any) => Promise<boolean | void> | boolean | void;\n    /**\n     * The previous revalidate before rendering 404 page for notFound: true\n     */\n    notFoundRevalidate?: number | false;\n    /**\n     * In development, the original source page that returned a 404.\n     */\n    developmentNotFoundSourcePage?: string;\n    /**\n     * The path we routed to and should be invoked\n     */\n    invokePath?: string;\n    /**\n     * The specific page output we should be matching\n     */\n    invokeOutput?: string;\n    /**\n     * The status we are invoking the request with from routing\n     */\n    invokeStatus?: number;\n    /**\n     * The routing error we are invoking with\n     */\n    invokeError?: Error;\n    /**\n     * The query parsed for the invocation\n     */\n    invokeQuery?: Record<string, undefined | string | string[]>;\n    /**\n     * Whether the request is a middleware invocation\n     */\n    middlewareInvoke?: boolean;\n    /**\n     * Whether the default route matches were set on the request during routing.\n     */\n    didSetDefaultRouteMatches?: boolean;\n    /**\n     * Whether the request is for the custom error page.\n     */\n    customErrorRender?: true;\n    /**\n     * Whether to bubble up the NoFallbackError to the caller when a 404 is\n     * returned.\n     */\n    bubbleNoFallback?: true;\n    /**\n     * True when the request had locale information inferred from the default\n     * locale.\n     */\n    localeInferredFromDefault?: true;\n    /**\n     * The locale that was inferred or explicitly set for the request.\n     */\n    locale?: string;\n    /**\n     * The default locale that was inferred or explicitly set for the request.\n     */\n    defaultLocale?: string;\n}\n/**\n * Gets the request metadata. If no key is provided, the entire metadata object\n * is returned.\n *\n * @param req the request to get the metadata from\n * @param key the key to get from the metadata (optional)\n * @returns the value for the key or the entire metadata object\n */\nexport declare function getRequestMeta(req: NextIncomingMessage, key?: undefined): RequestMeta;\nexport declare function getRequestMeta<K extends keyof RequestMeta>(req: NextIncomingMessage, key: K): RequestMeta[K];\n/**\n * Sets the request metadata.\n *\n * @param req the request to set the metadata on\n * @param meta the metadata to set\n * @returns the mutated request metadata\n */\nexport declare function setRequestMeta(req: NextIncomingMessage, meta: RequestMeta): RequestMeta;\n/**\n * Adds a value to the request metadata.\n *\n * @param request the request to mutate\n * @param key the key to set\n * @param value the value to set\n * @returns the mutated request metadata\n */\nexport declare function addRequestMeta<K extends keyof RequestMeta>(request: NextIncomingMessage, key: K, value: RequestMeta[K]): RequestMeta;\n/**\n * Removes a key from the request metadata.\n *\n * @param request the request to mutate\n * @param key the key to remove\n * @returns the mutated request metadata\n */\nexport declare function removeRequestMeta<K extends keyof RequestMeta>(request: NextIncomingMessage, key: K): RequestMeta;\ntype NextQueryMetadata = {\n    /**\n     * The `_rsc` query parameter used for cache busting to ensure that the RSC\n     * requests do not get cached by the browser explicitly.\n     */\n    [NEXT_RSC_UNION_QUERY]?: string;\n};\nexport type NextParsedUrlQuery = ParsedUrlQuery & NextQueryMetadata & {\n    amp?: '1';\n};\nexport interface NextUrlWithParsedQuery extends UrlWithParsedQuery {\n    query: NextParsedUrlQuery;\n}\nexport {};\n"
        }
    ]
}