{
    "sourceFile": "node_modules/next/dist/server/dev/on-demand-entry-handler.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892873253,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    ADDED: null,\n    BUILDING: null,\n    BUILT: null,\n    EntryTypes: null,\n    findPagePathData: null,\n    getEntries: null,\n    getEntryKey: null,\n    getInvalidator: null,\n    onDemandEntryHandler: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    ADDED: function() {\n        return ADDED;\n    },\n    BUILDING: function() {\n        return BUILDING;\n    },\n    BUILT: function() {\n        return BUILT;\n    },\n    EntryTypes: function() {\n        return EntryTypes;\n    },\n    findPagePathData: function() {\n        return findPagePathData;\n    },\n    getEntries: function() {\n        return getEntries;\n    },\n    getEntryKey: function() {\n        return getEntryKey;\n    },\n    getInvalidator: function() {\n        return getInvalidator;\n    },\n    onDemandEntryHandler: function() {\n        return onDemandEntryHandler;\n    }\n});\nconst _debug = /*#__PURE__*/ _interop_require_default(require(\"next/dist/compiled/debug\"));\nconst _events = require(\"events\");\nconst _findpagefile = require(\"../lib/find-page-file\");\nconst _entries = require(\"../../build/entries\");\nconst _path = require(\"path\");\nconst _normalizepathsep = require(\"../../shared/lib/page-path/normalize-path-sep\");\nconst _normalizepagepath = require(\"../../shared/lib/page-path/normalize-page-path\");\nconst _ensureleadingslash = require(\"../../shared/lib/page-path/ensure-leading-slash\");\nconst _removepagepathtail = require(\"../../shared/lib/page-path/remove-page-path-tail\");\nconst _output = require(\"../../build/output\");\nconst _getroutefromentrypoint = /*#__PURE__*/ _interop_require_default(require(\"../get-route-from-entrypoint\"));\nconst _utils = require(\"../../build/utils\");\nconst _utils1 = require(\"../../shared/lib/utils\");\nconst _constants = require(\"../../shared/lib/constants\");\nconst _segment = require(\"../../shared/lib/segment\");\nconst _hotreloadertypes = require(\"./hot-reloader-types\");\nconst _apppageroutedefinition = require(\"../route-definitions/app-page-route-definition\");\nconst _scheduler = require(\"../../lib/scheduler\");\nconst _batcher = require(\"../../lib/batcher\");\nconst _apppaths = require(\"../../shared/lib/router/utils/app-paths\");\nconst _pagetypes = require(\"../../lib/page-types\");\nconst _flightdatahelpers = require(\"../../client/flight-data-helpers\");\nfunction _interop_require_default(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nconst debug = (0, _debug.default)('next:on-demand-entry-handler');\n/**\n * Returns object keys with type inferred from the object key\n */ const keys = Object.keys;\nconst COMPILER_KEYS = keys(_constants.COMPILER_INDEXES);\nfunction treePathToEntrypoint(segmentPath, parentPath) {\n    const [parallelRouteKey, segment] = segmentPath;\n    // TODO-APP: modify this path to cover parallelRouteKey convention\n    const path = (parentPath ? parentPath + '/' : '') + (parallelRouteKey !== 'children' && !segment.startsWith('@') ? `@${parallelRouteKey}/` : '') + (segment === '' ? 'page' : segment);\n    // Last segment\n    if (segmentPath.length === 2) {\n        return path;\n    }\n    const childSegmentPath = (0, _flightdatahelpers.getNextFlightSegmentPath)(segmentPath);\n    return treePathToEntrypoint(childSegmentPath, path);\n}\nfunction convertDynamicParamTypeToSyntax(dynamicParamTypeShort, param) {\n    switch(dynamicParamTypeShort){\n        case 'c':\n        case 'ci':\n            return `[...${param}]`;\n        case 'oc':\n            return `[[...${param}]]`;\n        case 'd':\n        case 'di':\n            return `[${param}]`;\n        default:\n            throw Object.defineProperty(new Error('Unknown dynamic param type'), \"__NEXT_ERROR_CODE\", {\n                value: \"E378\",\n                enumerable: false,\n                configurable: true\n            });\n    }\n}\nfunction getEntryKey(compilerType, pageBundleType, page) {\n    // TODO: handle the /children slot better\n    // this is a quick hack to handle when children is provided as children/page instead of /page\n    const pageKey = page.replace(/(@[^/]+)\\/children/g, '$1');\n    return `${compilerType}@${pageBundleType}@${pageKey}`;\n}\nfunction getPageBundleType(pageBundlePath) {\n    // Handle special case for /_error\n    if (pageBundlePath === '/_error') return _pagetypes.PAGE_TYPES.PAGES;\n    if ((0, _utils.isMiddlewareFilename)(pageBundlePath)) return _pagetypes.PAGE_TYPES.ROOT;\n    return pageBundlePath.startsWith('pages/') ? _pagetypes.PAGE_TYPES.PAGES : pageBundlePath.startsWith('app/') ? _pagetypes.PAGE_TYPES.APP : _pagetypes.PAGE_TYPES.ROOT;\n}\nfunction getEntrypointsFromTree(tree, isFirst, parentPath = []) {\n    const [segment, parallelRoutes] = tree;\n    const currentSegment = Array.isArray(segment) ? convertDynamicParamTypeToSyntax(segment[2], segment[0]) : segment;\n    const isPageSegment = currentSegment.startsWith(_segment.PAGE_SEGMENT_KEY);\n    const currentPath = [\n        ...parentPath,\n        isPageSegment ? '' : currentSegment\n    ];\n    if (!isFirst && isPageSegment) {\n        // TODO get rid of '' at the start of tree\n        return [\n            treePathToEntrypoint(currentPath.slice(1))\n        ];\n    }\n    return Object.keys(parallelRoutes).reduce((paths, key)=>{\n        const childTree = parallelRoutes[key];\n        const childPages = getEntrypointsFromTree(childTree, false, [\n            ...currentPath,\n            key\n        ]);\n        return [\n            ...paths,\n            ...childPages\n        ];\n    }, []);\n}\nconst ADDED = Symbol('added');\nconst BUILDING = Symbol('building');\nconst BUILT = Symbol('built');\nvar EntryTypes = /*#__PURE__*/ function(EntryTypes) {\n    EntryTypes[EntryTypes[\"ENTRY\"] = 0] = \"ENTRY\";\n    EntryTypes[EntryTypes[\"CHILD_ENTRY\"] = 1] = \"CHILD_ENTRY\";\n    return EntryTypes;\n}({});\nconst entriesMap = new Map();\n// remove /server from end of output for server compiler\nconst normalizeOutputPath = (dir)=>dir.replace(/[/\\\\]server$/, '');\nconst getEntries = (dir)=>{\n    dir = normalizeOutputPath(dir);\n    const entries = entriesMap.get(dir) || {};\n    entriesMap.set(dir, entries);\n    return entries;\n};\nconst invalidators = new Map();\nconst getInvalidator = (dir)=>{\n    dir = normalizeOutputPath(dir);\n    return invalidators.get(dir);\n};\nconst doneCallbacks = new _events.EventEmitter();\nconst lastClientAccessPages = [\n    ''\n];\nconst lastServerAccessPagesForAppDir = [\n    ''\n];\n// Make sure only one invalidation happens at a time\n// Otherwise, webpack hash gets changed and it'll force the client to reload.\nclass Invalidator {\n    constructor(multiCompiler){\n        this.building = new Set();\n        this.rebuildAgain = new Set();\n        this.multiCompiler = multiCompiler;\n    }\n    shouldRebuildAll() {\n        return this.rebuildAgain.size > 0;\n    }\n    invalidate(compilerKeys = COMPILER_KEYS) {\n        for (const key of compilerKeys){\n            var _this_multiCompiler_compilers_COMPILER_INDEXES_key_watching;\n            // If there's a current build is processing, we won't abort it by invalidating.\n            // (If aborted, it'll cause a client side hard reload)\n            // But let it to invalidate just after the completion.\n            // So, it can re-build the queued pages at once.\n            if (this.building.has(key)) {\n                this.rebuildAgain.add(key);\n                continue;\n            }\n            this.building.add(key);\n            (_this_multiCompiler_compilers_COMPILER_INDEXES_key_watching = this.multiCompiler.compilers[_constants.COMPILER_INDEXES[key]].watching) == null ? void 0 : _this_multiCompiler_compilers_COMPILER_INDEXES_key_watching.invalidate();\n        }\n    }\n    startBuilding(compilerKey) {\n        this.building.add(compilerKey);\n    }\n    doneBuilding(compilerKeys = []) {\n        const rebuild = [];\n        for (const key of compilerKeys){\n            this.building.delete(key);\n            if (this.rebuildAgain.has(key)) {\n                rebuild.push(key);\n                this.rebuildAgain.delete(key);\n            }\n        }\n        if (rebuild.length > 0) {\n            this.invalidate(rebuild);\n        }\n    }\n    willRebuild(compilerKey) {\n        return this.rebuildAgain.has(compilerKey);\n    }\n}\nfunction disposeInactiveEntries(entries, maxInactiveAge) {\n    Object.keys(entries).forEach((entryKey)=>{\n        const entryData = entries[entryKey];\n        const { lastActiveTime, status, dispose, bundlePath } = entryData;\n        // TODO-APP: implement disposing of CHILD_ENTRY\n        if (entryData.type === 1) {\n            return;\n        }\n        // For the root middleware and the instrumentation hook files,\n        // we don't dispose them periodically as it's needed for every request.\n        if ((0, _utils.isMiddlewareFilename)(bundlePath) || (0, _utils.isInstrumentationHookFilename)(bundlePath)) {\n            return;\n        }\n        if (dispose) // Skip pages already scheduled for disposing\n        return;\n        // This means this entry is currently building or just added\n        // We don't need to dispose those entries.\n        if (status !== BUILT) return;\n        // We should not build the last accessed page even we didn't get any pings\n        // Sometimes, it's possible our XHR ping to wait before completing other requests.\n        // In that case, we should not dispose the current viewing page\n        if (lastClientAccessPages.includes(entryKey) || lastServerAccessPagesForAppDir.includes(entryKey)) return;\n        if (lastActiveTime && Date.now() - lastActiveTime > maxInactiveAge) {\n            entries[entryKey].dispose = true;\n        }\n    });\n}\n// Normalize both app paths and page paths\nfunction tryToNormalizePagePath(page) {\n    try {\n        return (0, _normalizepagepath.normalizePagePath)(page);\n    } catch (err) {\n        console.error(err);\n        throw new _utils1.PageNotFoundError(page);\n    }\n}\nasync function findPagePathData(rootDir, page, extensions, pagesDir, appDir) {\n    const normalizedPagePath = tryToNormalizePagePath(page);\n    let pagePath = null;\n    const isInstrumentation = (0, _utils.isInstrumentationHookFile)(normalizedPagePath);\n    if ((0, _utils.isMiddlewareFile)(normalizedPagePath) || isInstrumentation) {\n        pagePath = await (0, _findpagefile.findPageFile)(rootDir, normalizedPagePath, extensions, false);\n        if (!pagePath) {\n            throw new _utils1.PageNotFoundError(normalizedPagePath);\n        }\n        const pageUrl = (0, _ensureleadingslash.ensureLeadingSlash)((0, _removepagepathtail.removePagePathTail)((0, _normalizepathsep.normalizePathSep)(pagePath), {\n            extensions\n        }));\n        let bundlePath = normalizedPagePath;\n        let pageKey = _path.posix.normalize(pageUrl);\n        if (isInstrumentation || (0, _utils.isMiddlewareFile)(normalizedPagePath)) {\n            bundlePath = bundlePath.replace('/src', '');\n            pageKey = page.replace('/src', '');\n        }\n        return {\n            filename: (0, _path.join)(rootDir, pagePath),\n            bundlePath: bundlePath.slice(1),\n            page: pageKey\n        };\n    }\n    // Check appDir first falling back to pagesDir\n    if (appDir) {\n        if (page === _constants.UNDERSCORE_NOT_FOUND_ROUTE_ENTRY) {\n            const notFoundPath = await (0, _findpagefile.findPageFile)(appDir, 'not-found', extensions, true);\n            if (notFoundPath) {\n                return {\n                    filename: (0, _path.join)(appDir, notFoundPath),\n                    bundlePath: `app${_constants.UNDERSCORE_NOT_FOUND_ROUTE_ENTRY}`,\n                    page: _constants.UNDERSCORE_NOT_FOUND_ROUTE_ENTRY\n                };\n            }\n            return {\n                filename: require.resolve('next/dist/client/components/not-found-error'),\n                bundlePath: `app${_constants.UNDERSCORE_NOT_FOUND_ROUTE_ENTRY}`,\n                page: _constants.UNDERSCORE_NOT_FOUND_ROUTE_ENTRY\n            };\n        }\n        pagePath = await (0, _findpagefile.findPageFile)(appDir, normalizedPagePath, extensions, true);\n        if (pagePath) {\n            const pageUrl = (0, _ensureleadingslash.ensureLeadingSlash)((0, _removepagepathtail.removePagePathTail)((0, _normalizepathsep.normalizePathSep)(pagePath), {\n                keepIndex: true,\n                extensions\n            }));\n            return {\n                filename: (0, _path.join)(appDir, pagePath),\n                bundlePath: _path.posix.join('app', pageUrl),\n                page: _path.posix.normalize(pageUrl)\n            };\n        }\n    }\n    if (!pagePath && pagesDir) {\n        pagePath = await (0, _findpagefile.findPageFile)(pagesDir, normalizedPagePath, extensions, false);\n    }\n    if (pagePath !== null && pagesDir) {\n        const pageUrl = (0, _ensureleadingslash.ensureLeadingSlash)((0, _removepagepathtail.removePagePathTail)((0, _normalizepathsep.normalizePathSep)(pagePath), {\n            extensions\n        }));\n        return {\n            filename: (0, _path.join)(pagesDir, pagePath),\n            bundlePath: _path.posix.join('pages', (0, _normalizepagepath.normalizePagePath)(pageUrl)),\n            page: _path.posix.normalize(pageUrl)\n        };\n    }\n    if (page === '/_error') {\n        return {\n            filename: require.resolve('next/dist/pages/_error'),\n            bundlePath: page,\n            page: (0, _normalizepathsep.normalizePathSep)(page)\n        };\n    } else {\n        throw new _utils1.PageNotFoundError(normalizedPagePath);\n    }\n}\nfunction onDemandEntryHandler({ hotReloader, maxInactiveAge, multiCompiler, nextConfig, pagesBufferLength, pagesDir, rootDir, appDir }) {\n    const hasAppDir = !!appDir;\n    let curInvalidator = getInvalidator(multiCompiler.outputPath);\n    const curEntries = getEntries(multiCompiler.outputPath);\n    if (!curInvalidator) {\n        curInvalidator = new Invalidator(multiCompiler);\n        invalidators.set(multiCompiler.outputPath, curInvalidator);\n    }\n    const startBuilding = (compilation)=>{\n        const compilationName = compilation.name;\n        curInvalidator.startBuilding(compilationName);\n    };\n    for (const compiler of multiCompiler.compilers){\n        compiler.hooks.make.tap('NextJsOnDemandEntries', startBuilding);\n    }\n    function getPagePathsFromEntrypoints(type, entrypoints) {\n        const pagePaths = [];\n        for (const entrypoint of entrypoints.values()){\n            const page = (0, _getroutefromentrypoint.default)(entrypoint.name, hasAppDir);\n            if (page) {\n                var _entrypoint_name;\n                const pageBundleType = ((_entrypoint_name = entrypoint.name) == null ? void 0 : _entrypoint_name.startsWith('app/')) ? _pagetypes.PAGE_TYPES.APP : _pagetypes.PAGE_TYPES.PAGES;\n                pagePaths.push(getEntryKey(type, pageBundleType, page));\n            } else if ((0, _utils.isMiddlewareFilename)(entrypoint.name) || (0, _utils.isInstrumentationHookFilename)(entrypoint.name)) {\n                pagePaths.push(getEntryKey(type, _pagetypes.PAGE_TYPES.ROOT, `/${entrypoint.name}`));\n            }\n        }\n        return pagePaths;\n    }\n    for (const compiler of multiCompiler.compilers){\n        compiler.hooks.done.tap('NextJsOnDemandEntries', ()=>{\n            var _getInvalidator;\n            return (_getInvalidator = getInvalidator(compiler.outputPath)) == null ? void 0 : _getInvalidator.doneBuilding([\n                compiler.name\n            ]);\n        });\n    }\n    multiCompiler.hooks.done.tap('NextJsOnDemandEntries', (multiStats)=>{\n        var _getInvalidator;\n        const [clientStats, serverStats, edgeServerStats] = multiStats.stats;\n        const entryNames = [\n            ...getPagePathsFromEntrypoints(_constants.COMPILER_NAMES.client, clientStats.compilation.entrypoints),\n            ...getPagePathsFromEntrypoints(_constants.COMPILER_NAMES.server, serverStats.compilation.entrypoints),\n            ...edgeServerStats ? getPagePathsFromEntrypoints(_constants.COMPILER_NAMES.edgeServer, edgeServerStats.compilation.entrypoints) : []\n        ];\n        for (const name of entryNames){\n            const entry = curEntries[name];\n            if (!entry) {\n                continue;\n            }\n            if (entry.status !== BUILDING) {\n                continue;\n            }\n            entry.status = BUILT;\n            doneCallbacks.emit(name);\n        }\n        (_getInvalidator = getInvalidator(multiCompiler.outputPath)) == null ? void 0 : _getInvalidator.doneBuilding([\n            ...COMPILER_KEYS\n        ]);\n    });\n    const pingIntervalTime = Math.max(1000, Math.min(5000, maxInactiveAge));\n    setInterval(function() {\n        disposeInactiveEntries(curEntries, maxInactiveAge);\n    }, pingIntervalTime + 1000).unref();\n    function handleAppDirPing(tree) {\n        const pages = getEntrypointsFromTree(tree, true);\n        for (const page of pages){\n            for (const compilerType of [\n                _constants.COMPILER_NAMES.client,\n                _constants.COMPILER_NAMES.server,\n                _constants.COMPILER_NAMES.edgeServer\n            ]){\n                const entryKey = getEntryKey(compilerType, _pagetypes.PAGE_TYPES.APP, `/${page}`);\n                const entryInfo = curEntries[entryKey];\n                // If there's no entry, it may have been invalidated and needs to be re-built.\n                if (!entryInfo) {\n                    continue;\n                }\n                // We don't need to maintain active state of anything other than BUILT entries\n                if (entryInfo.status !== BUILT) continue;\n                // If there's an entryInfo\n                if (!lastServerAccessPagesForAppDir.includes(entryKey)) {\n                    lastServerAccessPagesForAppDir.unshift(entryKey);\n                    // Maintain the buffer max length\n                    // TODO: verify that the current pageKey is not at the end of the array as multiple entrypoints can exist\n                    if (lastServerAccessPagesForAppDir.length > pagesBufferLength) {\n                        lastServerAccessPagesForAppDir.pop();\n                    }\n                }\n                entryInfo.lastActiveTime = Date.now();\n                entryInfo.dispose = false;\n            }\n        }\n    }\n    function handlePing(pg) {\n        const page = (0, _normalizepathsep.normalizePathSep)(pg);\n        for (const compilerType of [\n            _constants.COMPILER_NAMES.client,\n            _constants.COMPILER_NAMES.server,\n            _constants.COMPILER_NAMES.edgeServer\n        ]){\n            const entryKey = getEntryKey(compilerType, _pagetypes.PAGE_TYPES.PAGES, page);\n            const entryInfo = curEntries[entryKey];\n            // If there's no entry, it may have been invalidated and needs to be re-built.\n            if (!entryInfo) {\n                // if (page !== lastEntry) client pings, but there's no entry for page\n                if (compilerType === _constants.COMPILER_NAMES.client) {\n                    return;\n                }\n                continue;\n            }\n            // We don't need to maintain active state of anything other than BUILT entries\n            if (entryInfo.status !== BUILT) continue;\n            // If there's an entryInfo\n            if (!lastClientAccessPages.includes(entryKey)) {\n                lastClientAccessPages.unshift(entryKey);\n                // Maintain the buffer max length\n                if (lastClientAccessPages.length > pagesBufferLength) {\n                    lastClientAccessPages.pop();\n                }\n            }\n            entryInfo.lastActiveTime = Date.now();\n            entryInfo.dispose = false;\n        }\n        return;\n    }\n    async function ensurePageImpl({ page, appPaths, definition, isApp, url }) {\n        const stalledTime = 60;\n        const stalledEnsureTimeout = setTimeout(()=>{\n            debug(`Ensuring ${page} has taken longer than ${stalledTime}s, if this continues to stall this may be a bug`);\n        }, stalledTime * 1000);\n        try {\n            let route;\n            if (definition) {\n                route = definition;\n            } else {\n                route = await findPagePathData(rootDir, page, nextConfig.pageExtensions, pagesDir, appDir);\n            }\n            const isInsideAppDir = !!appDir && route.filename.startsWith(appDir);\n            if (typeof isApp === 'boolean' && isApp !== isInsideAppDir) {\n                Error.stackTraceLimit = 15;\n                throw Object.defineProperty(new Error(`Ensure bailed, found path \"${route.page}\" does not match ensure type (${isApp ? 'app' : 'pages'})`), \"__NEXT_ERROR_CODE\", {\n                    value: \"E419\",\n                    enumerable: false,\n                    configurable: true\n                });\n            }\n            const pageBundleType = getPageBundleType(route.bundlePath);\n            const addEntry = (compilerType)=>{\n                const entryKey = getEntryKey(compilerType, pageBundleType, route.page);\n                if (curEntries[entryKey] && // there can be an overlap in the entryKey for the instrumentation hook file and a page named the same\n                // this is a quick fix to support this scenario by overwriting the instrumentation hook entry, since we only use it one time\n                // any changes to the instrumentation hook file will require a restart of the dev server anyway\n                !(0, _utils.isInstrumentationHookFilename)(curEntries[entryKey].bundlePath)) {\n                    curEntries[entryKey].dispose = false;\n                    curEntries[entryKey].lastActiveTime = Date.now();\n                    if (curEntries[entryKey].status === BUILT) {\n                        return {\n                            entryKey,\n                            newEntry: false,\n                            shouldInvalidate: false\n                        };\n                    }\n                    return {\n                        entryKey,\n                        newEntry: false,\n                        shouldInvalidate: true\n                    };\n                }\n                curEntries[entryKey] = {\n                    type: 0,\n                    appPaths,\n                    absolutePagePath: route.filename,\n                    request: route.filename,\n                    bundlePath: route.bundlePath,\n                    dispose: false,\n                    lastActiveTime: Date.now(),\n                    status: ADDED\n                };\n                return {\n                    entryKey: entryKey,\n                    newEntry: true,\n                    shouldInvalidate: true\n                };\n            };\n            const staticInfo = await (0, _entries.getStaticInfoIncludingLayouts)({\n                page,\n                pageFilePath: route.filename,\n                isInsideAppDir,\n                pageExtensions: nextConfig.pageExtensions,\n                isDev: true,\n                config: nextConfig,\n                appDir\n            });\n            const added = new Map();\n            const isServerComponent = isInsideAppDir && staticInfo.rsc !== _constants.RSC_MODULE_TYPES.client;\n            let pageRuntime = staticInfo.runtime;\n            if ((0, _utils.isMiddlewareFile)(page) && !nextConfig.experimental.nodeMiddleware) {\n                pageRuntime = 'edge';\n            }\n            (0, _entries.runDependingOnPageType)({\n                page: route.page,\n                pageRuntime,\n                pageType: pageBundleType,\n                onClient: ()=>{\n                    // Skip adding the client entry for app / Server Components.\n                    if (isServerComponent || isInsideAppDir) {\n                        return;\n                    }\n                    added.set(_constants.COMPILER_NAMES.client, addEntry(_constants.COMPILER_NAMES.client));\n                },\n                onServer: ()=>{\n                    added.set(_constants.COMPILER_NAMES.server, addEntry(_constants.COMPILER_NAMES.server));\n                    const edgeServerEntry = getEntryKey(_constants.COMPILER_NAMES.edgeServer, pageBundleType, route.page);\n                    if (curEntries[edgeServerEntry] && !(0, _utils.isInstrumentationHookFile)(route.page)) {\n                        // Runtime switched from edge to server\n                        delete curEntries[edgeServerEntry];\n                    }\n                },\n                onEdgeServer: ()=>{\n                    added.set(_constants.COMPILER_NAMES.edgeServer, addEntry(_constants.COMPILER_NAMES.edgeServer));\n                    const serverEntry = getEntryKey(_constants.COMPILER_NAMES.server, pageBundleType, route.page);\n                    if (curEntries[serverEntry] && !(0, _utils.isInstrumentationHookFile)(route.page)) {\n                        // Runtime switched from server to edge\n                        delete curEntries[serverEntry];\n                    }\n                }\n            });\n            const addedValues = [\n                ...added.values()\n            ];\n            const entriesThatShouldBeInvalidated = [\n                ...added.entries()\n            ].filter(([, entry])=>entry.shouldInvalidate);\n            const hasNewEntry = addedValues.some((entry)=>entry.newEntry);\n            if (hasNewEntry) {\n                const routePage = isApp ? route.page : (0, _apppaths.normalizeAppPath)(route.page);\n                (0, _output.reportTrigger)(routePage, url);\n            }\n            if (entriesThatShouldBeInvalidated.length > 0) {\n                const invalidatePromise = Promise.all(entriesThatShouldBeInvalidated.map(([compilerKey, { entryKey }])=>{\n                    return new Promise((resolve, reject)=>{\n                        doneCallbacks.once(entryKey, (err)=>{\n                            if (err) {\n                                return reject(err);\n                            }\n                            // If the invalidation also triggers a rebuild, we need to\n                            // wait for that additional build to prevent race conditions.\n                            const needsRebuild = curInvalidator.willRebuild(compilerKey);\n                            if (needsRebuild) {\n                                doneCallbacks.once(entryKey, (rebuildErr)=>{\n                                    if (rebuildErr) {\n                                        return reject(rebuildErr);\n                                    }\n                                    resolve();\n                                });\n                            } else {\n                                resolve();\n                            }\n                        });\n                    });\n                }));\n                curInvalidator.invalidate([\n                    ...added.keys()\n                ]);\n                await invalidatePromise;\n            }\n        } finally{\n            clearTimeout(stalledEnsureTimeout);\n        }\n    }\n    // Make sure that we won't have multiple invalidations ongoing concurrently.\n    const batcher = _batcher.Batcher.create({\n        // The cache key here is composed of the elements that affect the\n        // compilation, namely, the page, whether it's client only, and whether\n        // it's an app page. This ensures that we don't have multiple compilations\n        // for the same page happening concurrently.\n        //\n        // We don't include the whole match because it contains match specific\n        // parameters (like route params) that would just bust this cache. Any\n        // details that would possibly bust the cache should be listed here.\n        cacheKeyFn: (options)=>JSON.stringify(options),\n        // Schedule the invocation of the ensurePageImpl function on the next tick.\n        schedulerFn: _scheduler.scheduleOnNextTick\n    });\n    return {\n        async ensurePage ({ page, appPaths = null, definition, isApp, url }) {\n            // If the route is actually an app page route, then we should have access\n            // to the app route definition, and therefore, the appPaths from it.\n            if (!appPaths && definition && (0, _apppageroutedefinition.isAppPageRouteDefinition)(definition)) {\n                appPaths = definition.appPaths;\n            }\n            // Wrap the invocation of the ensurePageImpl function in the pending\n            // wrapper, which will ensure that we don't have multiple compilations\n            // for the same page happening concurrently.\n            return batcher.batch({\n                page,\n                appPaths,\n                definition,\n                isApp\n            }, async ()=>{\n                await ensurePageImpl({\n                    page,\n                    appPaths,\n                    definition,\n                    isApp,\n                    url\n                });\n            });\n        },\n        onHMR (client, getHmrServerError) {\n            let bufferedHmrServerError = null;\n            client.addEventListener('close', ()=>{\n                bufferedHmrServerError = null;\n            });\n            client.addEventListener('message', ({ data })=>{\n                try {\n                    const error = getHmrServerError();\n                    // New error occurred: buffered error is flushed and new error occurred\n                    if (!bufferedHmrServerError && error) {\n                        hotReloader.send({\n                            action: _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.SERVER_ERROR,\n                            errorJSON: (0, _utils1.stringifyError)(error)\n                        });\n                        bufferedHmrServerError = null;\n                    }\n                    const parsedData = JSON.parse(typeof data !== 'string' ? data.toString() : data);\n                    if (parsedData.event === 'ping') {\n                        if (parsedData.appDirRoute) {\n                            handleAppDirPing(parsedData.tree);\n                        } else {\n                            handlePing(parsedData.page);\n                        }\n                    }\n                } catch  {}\n            });\n        }\n    };\n}\n\n//# sourceMappingURL=on-demand-entry-handler.js.map"
        }
    ]
}