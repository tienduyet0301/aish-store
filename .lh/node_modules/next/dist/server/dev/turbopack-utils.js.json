{
    "sourceFile": "node_modules/next/dist/server/dev/turbopack-utils.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892873526,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    AssetMapper: null,\n    addMetadataIdToRoute: null,\n    addRouteSuffix: null,\n    handleEntrypoints: null,\n    handlePagesErrorRoute: null,\n    handleRouteType: null,\n    hasEntrypointForKey: null,\n    msToNs: null,\n    normalizedPageToTurbopackStructureRoute: null,\n    printNonFatalIssue: null,\n    processTopLevelIssues: null,\n    removeRouteSuffix: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    AssetMapper: function() {\n        return AssetMapper;\n    },\n    addMetadataIdToRoute: function() {\n        return addMetadataIdToRoute;\n    },\n    addRouteSuffix: function() {\n        return addRouteSuffix;\n    },\n    handleEntrypoints: function() {\n        return handleEntrypoints;\n    },\n    handlePagesErrorRoute: function() {\n        return handlePagesErrorRoute;\n    },\n    handleRouteType: function() {\n        return handleRouteType;\n    },\n    hasEntrypointForKey: function() {\n        return hasEntrypointForKey;\n    },\n    msToNs: function() {\n        return msToNs;\n    },\n    normalizedPageToTurbopackStructureRoute: function() {\n        return normalizedPageToTurbopackStructureRoute;\n    },\n    printNonFatalIssue: function() {\n        return printNonFatalIssue;\n    },\n    processTopLevelIssues: function() {\n        return processTopLevelIssues;\n    },\n    removeRouteSuffix: function() {\n        return removeRouteSuffix;\n    }\n});\nconst _hotreloadertypes = require(\"./hot-reloader-types\");\nconst _log = /*#__PURE__*/ _interop_require_wildcard(require(\"../../build/output/log\"));\nconst _entrykey = require(\"../../shared/lib/turbopack/entry-key\");\nconst _ismetadataroute = require(\"../../lib/metadata/is-metadata-route\");\nconst _utils = require(\"../../shared/lib/turbopack/utils\");\nfunction _getRequireWildcardCache(nodeInterop) {\n    if (typeof WeakMap !== \"function\") return null;\n    var cacheBabelInterop = new WeakMap();\n    var cacheNodeInterop = new WeakMap();\n    return (_getRequireWildcardCache = function(nodeInterop) {\n        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n    })(nodeInterop);\n}\nfunction _interop_require_wildcard(obj, nodeInterop) {\n    if (!nodeInterop && obj && obj.__esModule) {\n        return obj;\n    }\n    if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n        return {\n            default: obj\n        };\n    }\n    var cache = _getRequireWildcardCache(nodeInterop);\n    if (cache && cache.has(obj)) {\n        return cache.get(obj);\n    }\n    var newObj = {\n        __proto__: null\n    };\n    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n    for(var key in obj){\n        if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n            if (desc && (desc.get || desc.set)) {\n                Object.defineProperty(newObj, key, desc);\n            } else {\n                newObj[key] = obj[key];\n            }\n        }\n    }\n    newObj.default = obj;\n    if (cache) {\n        cache.set(obj, newObj);\n    }\n    return newObj;\n}\nconst onceErrorSet = new Set();\n/**\n * Check if given issue is a warning to be display only once.\n * This mimics behavior of get-page-static-info's warnOnce.\n * @param issue\n * @returns\n */ function shouldEmitOnceWarning(issue) {\n    const { severity, title, stage } = issue;\n    if (severity === 'warning' && title.value === 'Invalid page configuration') {\n        if (onceErrorSet.has(issue)) {\n            return false;\n        }\n        onceErrorSet.add(issue);\n    }\n    if (severity === 'warning' && stage === 'config' && (0, _utils.renderStyledStringToErrorAnsi)(issue.title).includes(\"can't be external\")) {\n        if (onceErrorSet.has(issue)) {\n            return false;\n        }\n        onceErrorSet.add(issue);\n    }\n    return true;\n}\nfunction printNonFatalIssue(issue) {\n    if ((0, _utils.isRelevantWarning)(issue) && shouldEmitOnceWarning(issue)) {\n        _log.warn((0, _utils.formatIssue)(issue));\n    }\n}\nfunction processTopLevelIssues(currentTopLevelIssues, result) {\n    currentTopLevelIssues.clear();\n    for (const issue of result.issues){\n        const issueKey = (0, _utils.getIssueKey)(issue);\n        currentTopLevelIssues.set(issueKey, issue);\n    }\n}\nconst MILLISECONDS_IN_NANOSECOND = BigInt(1000000);\nfunction msToNs(ms) {\n    return BigInt(Math.floor(ms)) * MILLISECONDS_IN_NANOSECOND;\n}\nasync function handleRouteType({ dev, page, pathname, route, currentEntryIssues, entrypoints, manifestLoader, readyIds, devRewrites, productionRewrites, hooks, logErrors }) {\n    const shouldCreateWebpackStats = process.env.TURBOPACK_STATS != null;\n    switch(route.type){\n        case 'page':\n            {\n                const clientKey = (0, _entrykey.getEntryKey)('pages', 'client', page);\n                const serverKey = (0, _entrykey.getEntryKey)('pages', 'server', page);\n                try {\n                    // In the best case scenario, Turbopack chunks document, app, page separately in that order,\n                    // so it can happen that the chunks of document change, but the chunks of app and page\n                    // don't. We still need to reload the page chunks in that case though, otherwise the version\n                    // of the document or app component export from the pages template is stale.\n                    let documentOrAppChanged = false;\n                    if (entrypoints.global.app) {\n                        const key = (0, _entrykey.getEntryKey)('pages', 'server', '_app');\n                        const writtenEndpoint = await entrypoints.global.app.writeToDisk();\n                        documentOrAppChanged ||= (hooks == null ? void 0 : hooks.handleWrittenEndpoint(key, writtenEndpoint, false)) ?? false;\n                        (0, _utils.processIssues)(currentEntryIssues, key, writtenEndpoint, false, logErrors);\n                    }\n                    await manifestLoader.loadBuildManifest('_app');\n                    await manifestLoader.loadPagesManifest('_app');\n                    if (entrypoints.global.document) {\n                        const key = (0, _entrykey.getEntryKey)('pages', 'server', '_document');\n                        const writtenEndpoint = await entrypoints.global.document.writeToDisk();\n                        documentOrAppChanged ||= (hooks == null ? void 0 : hooks.handleWrittenEndpoint(key, writtenEndpoint, false)) ?? false;\n                        (0, _utils.processIssues)(currentEntryIssues, key, writtenEndpoint, false, logErrors);\n                    }\n                    await manifestLoader.loadPagesManifest('_document');\n                    const writtenEndpoint = await route.htmlEndpoint.writeToDisk();\n                    hooks == null ? void 0 : hooks.handleWrittenEndpoint(serverKey, writtenEndpoint, documentOrAppChanged);\n                    const type = writtenEndpoint == null ? void 0 : writtenEndpoint.type;\n                    await manifestLoader.loadBuildManifest(page);\n                    await manifestLoader.loadPagesManifest(page);\n                    if (type === 'edge') {\n                        await manifestLoader.loadMiddlewareManifest(page, 'pages');\n                    } else {\n                        manifestLoader.deleteMiddlewareManifest(serverKey);\n                    }\n                    await manifestLoader.loadFontManifest('/_app', 'pages');\n                    await manifestLoader.loadFontManifest(page, 'pages');\n                    if (shouldCreateWebpackStats) {\n                        await manifestLoader.loadWebpackStats(page, 'pages');\n                    }\n                    await manifestLoader.writeManifests({\n                        devRewrites,\n                        productionRewrites,\n                        entrypoints\n                    });\n                    (0, _utils.processIssues)(currentEntryIssues, serverKey, writtenEndpoint, false, logErrors);\n                } finally{\n                    if (dev) {\n                        // TODO subscriptions should only be caused by the WebSocket connections\n                        // otherwise we don't known when to unsubscribe and this leaking\n                        hooks == null ? void 0 : hooks.subscribeToChanges(serverKey, false, route.dataEndpoint, ()=>{\n                            // Report the next compilation again\n                            readyIds == null ? void 0 : readyIds.delete(pathname);\n                            return {\n                                event: _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.SERVER_ONLY_CHANGES,\n                                pages: [\n                                    page\n                                ]\n                            };\n                        }, (e)=>{\n                            return {\n                                action: _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.RELOAD_PAGE,\n                                data: `error in ${page} data subscription: ${e}`\n                            };\n                        });\n                        hooks == null ? void 0 : hooks.subscribeToChanges(clientKey, false, route.htmlEndpoint, ()=>{\n                            return {\n                                event: _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.CLIENT_CHANGES\n                            };\n                        }, (e)=>{\n                            return {\n                                action: _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.RELOAD_PAGE,\n                                data: `error in ${page} html subscription: ${e}`\n                            };\n                        });\n                        if (entrypoints.global.document) {\n                            hooks == null ? void 0 : hooks.subscribeToChanges((0, _entrykey.getEntryKey)('pages', 'server', '_document'), false, entrypoints.global.document, ()=>{\n                                return {\n                                    action: _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.RELOAD_PAGE,\n                                    data: '_document has changed (page route)'\n                                };\n                            }, (e)=>{\n                                return {\n                                    action: _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.RELOAD_PAGE,\n                                    data: `error in _document subscription (page route): ${e}`\n                                };\n                            });\n                        }\n                    }\n                }\n                break;\n            }\n        case 'page-api':\n            {\n                const key = (0, _entrykey.getEntryKey)('pages', 'server', page);\n                const writtenEndpoint = await route.endpoint.writeToDisk();\n                hooks == null ? void 0 : hooks.handleWrittenEndpoint(key, writtenEndpoint, false);\n                const type = writtenEndpoint.type;\n                await manifestLoader.loadPagesManifest(page);\n                if (type === 'edge') {\n                    await manifestLoader.loadMiddlewareManifest(page, 'pages');\n                } else {\n                    manifestLoader.deleteMiddlewareManifest(key);\n                }\n                await manifestLoader.writeManifests({\n                    devRewrites,\n                    productionRewrites,\n                    entrypoints\n                });\n                (0, _utils.processIssues)(currentEntryIssues, key, writtenEndpoint, true, logErrors);\n                break;\n            }\n        case 'app-page':\n            {\n                const key = (0, _entrykey.getEntryKey)('app', 'server', page);\n                const writtenEndpoint = await route.htmlEndpoint.writeToDisk();\n                hooks == null ? void 0 : hooks.handleWrittenEndpoint(key, writtenEndpoint, false);\n                if (dev) {\n                    // TODO subscriptions should only be caused by the WebSocket connections\n                    // otherwise we don't known when to unsubscribe and this leaking\n                    hooks == null ? void 0 : hooks.subscribeToChanges(key, true, route.rscEndpoint, (change, hash)=>{\n                        if (change.issues.some((issue)=>issue.severity === 'error')) {\n                            // Ignore any updates that has errors\n                            // There will be another update without errors eventually\n                            return;\n                        }\n                        // Report the next compilation again\n                        readyIds == null ? void 0 : readyIds.delete(pathname);\n                        return {\n                            action: _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.SERVER_COMPONENT_CHANGES,\n                            hash\n                        };\n                    }, (e)=>{\n                        return {\n                            action: _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.RELOAD_PAGE,\n                            data: `error in ${page} app-page subscription: ${e}`\n                        };\n                    });\n                }\n                const type = writtenEndpoint.type;\n                if (type === 'edge') {\n                    await manifestLoader.loadMiddlewareManifest(page, 'app');\n                } else {\n                    manifestLoader.deleteMiddlewareManifest(key);\n                }\n                await manifestLoader.loadAppBuildManifest(page);\n                await manifestLoader.loadBuildManifest(page, 'app');\n                await manifestLoader.loadAppPathsManifest(page);\n                await manifestLoader.loadActionManifest(page);\n                await manifestLoader.loadFontManifest(page, 'app');\n                if (shouldCreateWebpackStats) {\n                    await manifestLoader.loadWebpackStats(page, 'app');\n                }\n                await manifestLoader.writeManifests({\n                    devRewrites,\n                    productionRewrites,\n                    entrypoints\n                });\n                (0, _utils.processIssues)(currentEntryIssues, key, writtenEndpoint, dev, logErrors);\n                break;\n            }\n        case 'app-route':\n            {\n                const key = (0, _entrykey.getEntryKey)('app', 'server', page);\n                const writtenEndpoint = await route.endpoint.writeToDisk();\n                hooks == null ? void 0 : hooks.handleWrittenEndpoint(key, writtenEndpoint, false);\n                const type = writtenEndpoint.type;\n                await manifestLoader.loadAppPathsManifest(page);\n                if (type === 'edge') {\n                    await manifestLoader.loadMiddlewareManifest(page, 'app');\n                } else {\n                    manifestLoader.deleteMiddlewareManifest(key);\n                }\n                await manifestLoader.writeManifests({\n                    devRewrites,\n                    productionRewrites,\n                    entrypoints\n                });\n                (0, _utils.processIssues)(currentEntryIssues, key, writtenEndpoint, true, logErrors);\n                break;\n            }\n        default:\n            {\n                throw Object.defineProperty(new Error(`unknown route type ${route.type} for ${page}`), \"__NEXT_ERROR_CODE\", {\n                    value: \"E316\",\n                    enumerable: false,\n                    configurable: true\n                });\n            }\n    }\n}\nclass AssetMapper {\n    /**\n   * Overrides asset paths for a key and updates the mapping from path to key.\n   *\n   * @param key\n   * @param assetPaths asset paths relative to the .next directory\n   */ setPathsForKey(key, assetPaths) {\n        this.delete(key);\n        const newAssetPaths = new Set(assetPaths);\n        this.entryMap.set(key, newAssetPaths);\n        for (const assetPath of newAssetPaths){\n            let assetPathKeys = this.assetMap.get(assetPath);\n            if (!assetPathKeys) {\n                assetPathKeys = new Set();\n                this.assetMap.set(assetPath, assetPathKeys);\n            }\n            assetPathKeys.add(key);\n        }\n    }\n    /**\n   * Deletes the key and any asset only referenced by this key.\n   *\n   * @param key\n   */ delete(key) {\n        for (const assetPath of this.getAssetPathsByKey(key)){\n            const assetPathKeys = this.assetMap.get(assetPath);\n            assetPathKeys == null ? void 0 : assetPathKeys.delete(key);\n            if (!(assetPathKeys == null ? void 0 : assetPathKeys.size)) {\n                this.assetMap.delete(assetPath);\n            }\n        }\n        this.entryMap.delete(key);\n    }\n    getAssetPathsByKey(key) {\n        return Array.from(this.entryMap.get(key) ?? []);\n    }\n    getKeysByAsset(path) {\n        return Array.from(this.assetMap.get(path) ?? []);\n    }\n    keys() {\n        return this.entryMap.keys();\n    }\n    constructor(){\n        this.entryMap = new Map();\n        this.assetMap = new Map();\n    }\n}\nfunction hasEntrypointForKey(entrypoints, key, assetMapper) {\n    const { type, page } = (0, _entrykey.splitEntryKey)(key);\n    switch(type){\n        case 'app':\n            return entrypoints.app.has(page);\n        case 'pages':\n            switch(page){\n                case '_app':\n                    return entrypoints.global.app != null;\n                case '_document':\n                    return entrypoints.global.document != null;\n                case '_error':\n                    return entrypoints.global.error != null;\n                default:\n                    return entrypoints.page.has(page);\n            }\n        case 'root':\n            switch(page){\n                case 'middleware':\n                    return entrypoints.global.middleware != null;\n                case 'instrumentation':\n                    return entrypoints.global.instrumentation != null;\n                default:\n                    return false;\n            }\n        case 'assets':\n            if (!assetMapper) {\n                return false;\n            }\n            return assetMapper.getKeysByAsset(page).some((pageKey)=>hasEntrypointForKey(entrypoints, pageKey, assetMapper));\n        default:\n            {\n                // validation that we covered all cases, this should never run.\n                // eslint-disable-next-line @typescript-eslint/no-unused-vars\n                const _ = type;\n                return false;\n            }\n    }\n}\nasync function handleEntrypoints({ entrypoints, currentEntrypoints, currentEntryIssues, manifestLoader, devRewrites, logErrors, dev }) {\n    currentEntrypoints.global.app = entrypoints.pagesAppEndpoint;\n    currentEntrypoints.global.document = entrypoints.pagesDocumentEndpoint;\n    currentEntrypoints.global.error = entrypoints.pagesErrorEndpoint;\n    currentEntrypoints.global.instrumentation = entrypoints.instrumentation;\n    currentEntrypoints.page.clear();\n    currentEntrypoints.app.clear();\n    for (const [pathname, route] of entrypoints.routes){\n        switch(route.type){\n            case 'page':\n            case 'page-api':\n                currentEntrypoints.page.set(pathname, route);\n                break;\n            case 'app-page':\n                {\n                    route.pages.forEach((page)=>{\n                        currentEntrypoints.app.set(page.originalName, {\n                            type: 'app-page',\n                            ...page\n                        });\n                    });\n                    break;\n                }\n            case 'app-route':\n                {\n                    currentEntrypoints.app.set(route.originalName, route);\n                    break;\n                }\n            default:\n                _log.info(`skipping ${pathname} (${route.type})`);\n                break;\n        }\n    }\n    if (dev) {\n        await handleEntrypointsDevCleanup({\n            currentEntryIssues,\n            currentEntrypoints,\n            ...dev\n        });\n    }\n    const { middleware, instrumentation } = entrypoints;\n    // We check for explicit true/false, since it's initialized to\n    // undefined during the first loop (middlewareChanges event is\n    // unnecessary during the first serve)\n    if (currentEntrypoints.global.middleware && !middleware) {\n        const key = (0, _entrykey.getEntryKey)('root', 'server', 'middleware');\n        // Went from middleware to no middleware\n        await (dev == null ? void 0 : dev.hooks.unsubscribeFromChanges(key));\n        currentEntryIssues.delete(key);\n        dev.hooks.sendHmr('middleware', {\n            event: _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.MIDDLEWARE_CHANGES\n        });\n    } else if (!currentEntrypoints.global.middleware && middleware) {\n        // Went from no middleware to middleware\n        dev.hooks.sendHmr('middleware', {\n            event: _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.MIDDLEWARE_CHANGES\n        });\n    }\n    currentEntrypoints.global.middleware = middleware;\n    if (instrumentation) {\n        const processInstrumentation = async (name, prop)=>{\n            const prettyName = {\n                nodeJs: 'Node.js',\n                edge: 'Edge'\n            };\n            const finishBuilding = dev.hooks.startBuilding(`instrumentation ${prettyName[prop]}`, undefined, true);\n            const key = (0, _entrykey.getEntryKey)('root', 'server', name);\n            const writtenEndpoint = await instrumentation[prop].writeToDisk();\n            dev.hooks.handleWrittenEndpoint(key, writtenEndpoint, false);\n            (0, _utils.processIssues)(currentEntryIssues, key, writtenEndpoint, false, logErrors);\n            finishBuilding();\n        };\n        await processInstrumentation('instrumentation.nodeJs', 'nodeJs');\n        await processInstrumentation('instrumentation.edge', 'edge');\n        await manifestLoader.loadMiddlewareManifest('instrumentation', 'instrumentation');\n        await manifestLoader.writeManifests({\n            devRewrites,\n            productionRewrites: undefined,\n            entrypoints: currentEntrypoints\n        });\n        dev.serverFields.actualInstrumentationHookFile = '/instrumentation';\n        await dev.hooks.propagateServerField('actualInstrumentationHookFile', dev.serverFields.actualInstrumentationHookFile);\n    } else {\n        dev.serverFields.actualInstrumentationHookFile = undefined;\n        await dev.hooks.propagateServerField('actualInstrumentationHookFile', dev.serverFields.actualInstrumentationHookFile);\n    }\n    if (middleware) {\n        const key = (0, _entrykey.getEntryKey)('root', 'server', 'middleware');\n        const endpoint = middleware.endpoint;\n        async function processMiddleware() {\n            var _manifestLoader_getMiddlewareManifest;\n            const finishBuilding = dev.hooks.startBuilding('middleware', undefined, true);\n            const writtenEndpoint = await endpoint.writeToDisk();\n            dev.hooks.handleWrittenEndpoint(key, writtenEndpoint, false);\n            (0, _utils.processIssues)(currentEntryIssues, key, writtenEndpoint, false, logErrors);\n            await manifestLoader.loadMiddlewareManifest('middleware', 'middleware');\n            const middlewareConfig = (_manifestLoader_getMiddlewareManifest = manifestLoader.getMiddlewareManifest(key)) == null ? void 0 : _manifestLoader_getMiddlewareManifest.middleware['/'];\n            if (dev && middlewareConfig) {\n                dev.serverFields.middleware = {\n                    match: null,\n                    page: '/',\n                    matchers: middlewareConfig.matchers\n                };\n            }\n            finishBuilding();\n        }\n        await processMiddleware();\n        if (dev) {\n            dev == null ? void 0 : dev.hooks.subscribeToChanges(key, false, endpoint, async ()=>{\n                const finishBuilding = dev.hooks.startBuilding('middleware', undefined, true);\n                await processMiddleware();\n                await dev.hooks.propagateServerField('actualMiddlewareFile', dev.serverFields.actualMiddlewareFile);\n                await dev.hooks.propagateServerField('middleware', dev.serverFields.middleware);\n                await manifestLoader.writeManifests({\n                    devRewrites,\n                    productionRewrites: undefined,\n                    entrypoints: currentEntrypoints\n                });\n                finishBuilding == null ? void 0 : finishBuilding();\n                return {\n                    event: _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.MIDDLEWARE_CHANGES\n                };\n            }, ()=>{\n                return {\n                    event: _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.MIDDLEWARE_CHANGES\n                };\n            });\n        }\n    } else {\n        manifestLoader.deleteMiddlewareManifest((0, _entrykey.getEntryKey)('root', 'server', 'middleware'));\n        dev.serverFields.actualMiddlewareFile = undefined;\n        dev.serverFields.middleware = undefined;\n    }\n    await dev.hooks.propagateServerField('actualMiddlewareFile', dev.serverFields.actualMiddlewareFile);\n    await dev.hooks.propagateServerField('middleware', dev.serverFields.middleware);\n}\nasync function handleEntrypointsDevCleanup({ currentEntryIssues, currentEntrypoints, assetMapper, changeSubscriptions, clients, clientStates, hooks }) {\n    // this needs to be first as `hasEntrypointForKey` uses the `assetMapper`\n    for (const key of assetMapper.keys()){\n        if (!hasEntrypointForKey(currentEntrypoints, key, assetMapper)) {\n            assetMapper.delete(key);\n        }\n    }\n    for (const key of changeSubscriptions.keys()){\n        // middleware is handled separately\n        if (!hasEntrypointForKey(currentEntrypoints, key, assetMapper)) {\n            await hooks.unsubscribeFromChanges(key);\n        }\n    }\n    for (const [key] of currentEntryIssues){\n        if (!hasEntrypointForKey(currentEntrypoints, key, assetMapper)) {\n            currentEntryIssues.delete(key);\n        }\n    }\n    for (const client of clients){\n        const state = clientStates.get(client);\n        if (!state) {\n            continue;\n        }\n        for (const key of state.clientIssues.keys()){\n            if (!hasEntrypointForKey(currentEntrypoints, key, assetMapper)) {\n                state.clientIssues.delete(key);\n            }\n        }\n        for (const id of state.subscriptions.keys()){\n            if (!hasEntrypointForKey(currentEntrypoints, (0, _entrykey.getEntryKey)('assets', 'client', id), assetMapper)) {\n                hooks.unsubscribeFromHmrEvents(client, id);\n            }\n        }\n    }\n}\nasync function handlePagesErrorRoute({ currentEntryIssues, entrypoints, manifestLoader, devRewrites, productionRewrites, logErrors, hooks }) {\n    if (entrypoints.global.app) {\n        const key = (0, _entrykey.getEntryKey)('pages', 'server', '_app');\n        const writtenEndpoint = await entrypoints.global.app.writeToDisk();\n        hooks.handleWrittenEndpoint(key, writtenEndpoint, false);\n        hooks.subscribeToChanges(key, false, entrypoints.global.app, ()=>{\n            // There's a special case for this in `../client/page-bootstrap.ts`.\n            // https://github.com/vercel/next.js/blob/08d7a7e5189a835f5dcb82af026174e587575c0e/packages/next/src/client/page-bootstrap.ts#L69-L71\n            return {\n                event: _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.CLIENT_CHANGES\n            };\n        }, ()=>{\n            return {\n                action: _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.RELOAD_PAGE,\n                data: '_app has changed (error route)'\n            };\n        });\n        (0, _utils.processIssues)(currentEntryIssues, key, writtenEndpoint, false, logErrors);\n    }\n    await manifestLoader.loadBuildManifest('_app');\n    await manifestLoader.loadPagesManifest('_app');\n    await manifestLoader.loadFontManifest('_app');\n    if (entrypoints.global.document) {\n        const key = (0, _entrykey.getEntryKey)('pages', 'server', '_document');\n        const writtenEndpoint = await entrypoints.global.document.writeToDisk();\n        hooks.handleWrittenEndpoint(key, writtenEndpoint, false);\n        hooks.subscribeToChanges(key, false, entrypoints.global.document, ()=>{\n            return {\n                action: _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.RELOAD_PAGE,\n                data: '_document has changed (error route)'\n            };\n        }, (e)=>{\n            return {\n                action: _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.RELOAD_PAGE,\n                data: `error in _document subscription (error route): ${e}`\n            };\n        });\n        (0, _utils.processIssues)(currentEntryIssues, key, writtenEndpoint, false, logErrors);\n    }\n    await manifestLoader.loadPagesManifest('_document');\n    if (entrypoints.global.error) {\n        const key = (0, _entrykey.getEntryKey)('pages', 'server', '_error');\n        const writtenEndpoint = await entrypoints.global.error.writeToDisk();\n        hooks.handleWrittenEndpoint(key, writtenEndpoint, false);\n        hooks.subscribeToChanges(key, false, entrypoints.global.error, ()=>{\n            // There's a special case for this in `../client/page-bootstrap.ts`.\n            // https://github.com/vercel/next.js/blob/08d7a7e5189a835f5dcb82af026174e587575c0e/packages/next/src/client/page-bootstrap.ts#L69-L71\n            return {\n                event: _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.CLIENT_CHANGES\n            };\n        }, (e)=>{\n            return {\n                action: _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.RELOAD_PAGE,\n                data: `error in _error subscription: ${e}`\n            };\n        });\n        (0, _utils.processIssues)(currentEntryIssues, key, writtenEndpoint, false, logErrors);\n    }\n    await manifestLoader.loadBuildManifest('_error');\n    await manifestLoader.loadPagesManifest('_error');\n    await manifestLoader.loadFontManifest('_error');\n    await manifestLoader.writeManifests({\n        devRewrites,\n        productionRewrites,\n        entrypoints\n    });\n}\nfunction removeRouteSuffix(route) {\n    return route.replace(/\\/route$/, '');\n}\nfunction addRouteSuffix(route) {\n    return route + '/route';\n}\nfunction addMetadataIdToRoute(route) {\n    return route + '/[__metadata_id__]';\n}\nfunction normalizedPageToTurbopackStructureRoute(route, ext) {\n    let entrypointKey = route;\n    if ((0, _ismetadataroute.isMetadataRoute)(entrypointKey)) {\n        entrypointKey = entrypointKey.endsWith('/route') ? entrypointKey.slice(0, -'/route'.length) : entrypointKey;\n        if (ext) {\n            if (entrypointKey.endsWith('/[__metadata_id__]')) {\n                entrypointKey = entrypointKey.slice(0, -'/[__metadata_id__]'.length);\n            }\n            if (entrypointKey.endsWith('/sitemap.xml') && ext !== '.xml') {\n                // For dynamic sitemap route, remove the extension\n                entrypointKey = entrypointKey.slice(0, -'.xml'.length);\n            }\n        }\n        entrypointKey = entrypointKey + '/route';\n    }\n    return entrypointKey;\n}\n\n//# sourceMappingURL=turbopack-utils.js.map"
        }
    ]
}