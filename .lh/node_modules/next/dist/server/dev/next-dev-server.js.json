{
    "sourceFile": "node_modules/next/dist/server/dev/next-dev-server.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892873177,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"default\", {\n    enumerable: true,\n    get: function() {\n        return DevServer;\n    }\n});\nconst _requestmeta = require(\"../request-meta\");\nconst _fs = /*#__PURE__*/ _interop_require_default(require(\"fs\"));\nconst _jestworker = require(\"next/dist/compiled/jest-worker\");\nconst _path = require(\"path\");\nconst _output = require(\"../../build/output\");\nconst _constants = require(\"../../lib/constants\");\nconst _findpagesdir = require(\"../../lib/find-pages-dir\");\nconst _constants1 = require(\"../../shared/lib/constants\");\nconst _nextserver = /*#__PURE__*/ _interop_require_wildcard(require(\"../next-server\"));\nconst _normalizepagepath = require(\"../../shared/lib/page-path/normalize-page-path\");\nconst _pathhasprefix = require(\"../../shared/lib/router/utils/path-has-prefix\");\nconst _removepathprefix = require(\"../../shared/lib/router/utils/remove-path-prefix\");\nconst _storage = require(\"../../telemetry/storage\");\nconst _trace = require(\"../../trace\");\nconst _findpagefile = require(\"../lib/find-page-file\");\nconst _utils = require(\"../lib/utils\");\nconst _coalescedfunction = require(\"../../lib/coalesced-function\");\nconst _loaddefaulterrorcomponents = require(\"../load-default-error-components\");\nconst _utils1 = require(\"../../shared/lib/utils\");\nconst _log = /*#__PURE__*/ _interop_require_wildcard(require(\"../../build/output/log\"));\nconst _iserror = /*#__PURE__*/ _interop_require_wildcard(require(\"../../lib/is-error\"));\nconst _utils2 = require(\"../../build/utils\");\nconst _formatservererror = require(\"../../lib/format-server-error\");\nconst _devroutematchermanager = require(\"../route-matcher-managers/dev-route-matcher-manager\");\nconst _devpagesroutematcherprovider = require(\"../route-matcher-providers/dev/dev-pages-route-matcher-provider\");\nconst _devpagesapiroutematcherprovider = require(\"../route-matcher-providers/dev/dev-pages-api-route-matcher-provider\");\nconst _devapppageroutematcherprovider = require(\"../route-matcher-providers/dev/dev-app-page-route-matcher-provider\");\nconst _devapprouteroutematcherprovider = require(\"../route-matcher-providers/dev/dev-app-route-route-matcher-provider\");\nconst _nodemanifestloader = require(\"../route-matcher-providers/helpers/manifest-loaders/node-manifest-loader\");\nconst _batchedfilereader = require(\"../route-matcher-providers/dev/helpers/file-reader/batched-file-reader\");\nconst _defaultfilereader = require(\"../route-matcher-providers/dev/helpers/file-reader/default-file-reader\");\nconst _lrucache = require(\"../lib/lru-cache\");\nconst _middlewareroutematcher = require(\"../../shared/lib/router/utils/middleware-route-matcher\");\nconst _detachedpromise = require(\"../../lib/detached-promise\");\nconst _ispostpone = require(\"../lib/router-utils/is-postpone\");\nconst _generateinterceptionroutesrewrites = require(\"../../lib/generate-interception-routes-rewrites\");\nconst _buildcustomroute = require(\"../../lib/build-custom-route\");\nconst _errorsource = require(\"../../shared/lib/error-source\");\nconst _logrequests = require(\"./log-requests\");\nconst _fallback = require(\"../../lib/fallback\");\nfunction _interop_require_default(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nfunction _getRequireWildcardCache(nodeInterop) {\n    if (typeof WeakMap !== \"function\") return null;\n    var cacheBabelInterop = new WeakMap();\n    var cacheNodeInterop = new WeakMap();\n    return (_getRequireWildcardCache = function(nodeInterop) {\n        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n    })(nodeInterop);\n}\nfunction _interop_require_wildcard(obj, nodeInterop) {\n    if (!nodeInterop && obj && obj.__esModule) {\n        return obj;\n    }\n    if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n        return {\n            default: obj\n        };\n    }\n    var cache = _getRequireWildcardCache(nodeInterop);\n    if (cache && cache.has(obj)) {\n        return cache.get(obj);\n    }\n    var newObj = {\n        __proto__: null\n    };\n    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n    for(var key in obj){\n        if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n            if (desc && (desc.get || desc.set)) {\n                Object.defineProperty(newObj, key, desc);\n            } else {\n                newObj[key] = obj[key];\n            }\n        }\n    }\n    newObj.default = obj;\n    if (cache) {\n        cache.set(obj, newObj);\n    }\n    return newObj;\n}\n// Load ReactDevOverlay only when needed\nlet ReactDevOverlayImpl;\nconst ReactDevOverlay = (props)=>{\n    if (ReactDevOverlayImpl === undefined) {\n        ReactDevOverlayImpl = require('../../client/components/react-dev-overlay/pages/pages-dev-overlay').PagesDevOverlay;\n    }\n    return ReactDevOverlayImpl(props);\n};\nclass DevServer extends _nextserver.default {\n    getStaticPathsWorker() {\n        const worker = new _jestworker.Worker(require.resolve('./static-paths-worker'), {\n            maxRetries: 1,\n            // For dev server, it's not necessary to spin up too many workers as long as you are not doing a load test.\n            // This helps reusing the memory a lot.\n            numWorkers: 1,\n            enableWorkerThreads: this.nextConfig.experimental.workerThreads,\n            forkOptions: {\n                env: {\n                    ...process.env,\n                    // discard --inspect/--inspect-brk flags from process.env.NODE_OPTIONS. Otherwise multiple Node.js debuggers\n                    // would be started if user launch Next.js in debugging mode. The number of debuggers is linked to\n                    // the number of workers Next.js tries to launch. The only worker users are interested in debugging\n                    // is the main Next.js one\n                    NODE_OPTIONS: (0, _utils.getFormattedNodeOptionsWithoutInspect)()\n                }\n            }\n        });\n        worker.getStdout().pipe(process.stdout);\n        worker.getStderr().pipe(process.stderr);\n        return worker;\n    }\n    constructor(options){\n        var _this_nextConfig_experimental_amp, _this_nextConfig_experimental;\n        try {\n            // Increase the number of stack frames on the server\n            Error.stackTraceLimit = 50;\n        } catch  {}\n        super({\n            ...options,\n            dev: true\n        }), /**\n   * The promise that resolves when the server is ready. When this is unset\n   * the server is ready.\n   */ this.ready = new _detachedpromise.DetachedPromise();\n        this.bundlerService = options.bundlerService;\n        this.startServerSpan = options.startServerSpan ?? (0, _trace.trace)('start-next-dev-server');\n        this.renderOpts.dev = true;\n        this.renderOpts.ErrorDebug = ReactDevOverlay;\n        this.staticPathsCache = new _lrucache.LRUCache(// 5MB\n        5 * 1024 * 1024, function length(value) {\n            var _JSON_stringify;\n            return ((_JSON_stringify = JSON.stringify(value.staticPaths)) == null ? void 0 : _JSON_stringify.length) ?? 0;\n        });\n        this.renderOpts.ampSkipValidation = ((_this_nextConfig_experimental = this.nextConfig.experimental) == null ? void 0 : (_this_nextConfig_experimental_amp = _this_nextConfig_experimental.amp) == null ? void 0 : _this_nextConfig_experimental_amp.skipValidation) ?? false;\n        this.renderOpts.ampValidator = (html, pathname)=>{\n            const validatorPath = this.nextConfig.experimental && this.nextConfig.experimental.amp && this.nextConfig.experimental.amp.validator || require.resolve('next/dist/compiled/amphtml-validator/validator_wasm.js');\n            const AmpHtmlValidator = require('next/dist/compiled/amphtml-validator');\n            return AmpHtmlValidator.getInstance(validatorPath).then((validator)=>{\n                const result = validator.validateString(html);\n                (0, _output.ampValidation)(pathname, result.errors.filter((e)=>e.severity === 'ERROR').filter((e)=>this._filterAmpDevelopmentScript(html, e)), result.errors.filter((e)=>e.severity !== 'ERROR'));\n            });\n        };\n        const { pagesDir, appDir } = (0, _findpagesdir.findPagesDir)(this.dir);\n        this.pagesDir = pagesDir;\n        this.appDir = appDir;\n        if (this.nextConfig.experimental.serverComponentsHmrCache) {\n            this.serverComponentsHmrCache = new _lrucache.LRUCache(this.nextConfig.cacheMaxMemorySize, function length(value) {\n                return JSON.stringify(value).length;\n            });\n        }\n    }\n    getServerComponentsHmrCache() {\n        return this.serverComponentsHmrCache;\n    }\n    getRouteMatchers() {\n        const { pagesDir, appDir } = (0, _findpagesdir.findPagesDir)(this.dir);\n        const ensurer = {\n            ensure: async (match, pathname)=>{\n                await this.ensurePage({\n                    definition: match.definition,\n                    page: match.definition.page,\n                    clientOnly: false,\n                    url: pathname\n                });\n            }\n        };\n        const matchers = new _devroutematchermanager.DevRouteMatcherManager(super.getRouteMatchers(), ensurer, this.dir);\n        const extensions = this.nextConfig.pageExtensions;\n        const extensionsExpression = new RegExp(`\\\\.(?:${extensions.join('|')})$`);\n        // If the pages directory is available, then configure those matchers.\n        if (pagesDir) {\n            const fileReader = new _batchedfilereader.BatchedFileReader(new _defaultfilereader.DefaultFileReader({\n                // Only allow files that have the correct extensions.\n                pathnameFilter: (pathname)=>extensionsExpression.test(pathname)\n            }));\n            matchers.push(new _devpagesroutematcherprovider.DevPagesRouteMatcherProvider(pagesDir, extensions, fileReader, this.localeNormalizer));\n            matchers.push(new _devpagesapiroutematcherprovider.DevPagesAPIRouteMatcherProvider(pagesDir, extensions, fileReader, this.localeNormalizer));\n        }\n        if (appDir) {\n            // We create a new file reader for the app directory because we don't want\n            // to include any folders or files starting with an underscore. This will\n            // prevent the reader from wasting time reading files that we know we\n            // don't care about.\n            const fileReader = new _batchedfilereader.BatchedFileReader(new _defaultfilereader.DefaultFileReader({\n                // Ignore any directory prefixed with an underscore.\n                ignorePartFilter: (part)=>part.startsWith('_')\n            }));\n            matchers.push(new _devapppageroutematcherprovider.DevAppPageRouteMatcherProvider(appDir, extensions, fileReader));\n            matchers.push(new _devapprouteroutematcherprovider.DevAppRouteRouteMatcherProvider(appDir, extensions, fileReader));\n        }\n        return matchers;\n    }\n    getBuildId() {\n        return 'development';\n    }\n    async prepareImpl() {\n        var _this_ready;\n        (0, _trace.setGlobal)('distDir', this.distDir);\n        (0, _trace.setGlobal)('phase', _constants1.PHASE_DEVELOPMENT_SERVER);\n        const telemetry = new _storage.Telemetry({\n            distDir: this.distDir\n        });\n        await super.prepareImpl();\n        await this.matchers.reload();\n        (_this_ready = this.ready) == null ? void 0 : _this_ready.resolve();\n        this.ready = undefined;\n        // In dev, this needs to be called after prepare because the build entries won't be known in the constructor\n        this.interceptionRoutePatterns = this.getinterceptionRoutePatterns();\n        // This is required by the tracing subsystem.\n        (0, _trace.setGlobal)('appDir', this.appDir);\n        (0, _trace.setGlobal)('pagesDir', this.pagesDir);\n        (0, _trace.setGlobal)('telemetry', telemetry);\n        process.on('unhandledRejection', (reason)=>{\n            if ((0, _ispostpone.isPostpone)(reason)) {\n                // React postpones that are unhandled might end up logged here but they're\n                // not really errors. They're just part of rendering.\n                return;\n            }\n            this.logErrorWithOriginalStack(reason, 'unhandledRejection');\n        });\n        process.on('uncaughtException', (err)=>{\n            this.logErrorWithOriginalStack(err, 'uncaughtException');\n        });\n    }\n    async hasPage(pathname) {\n        let normalizedPath;\n        try {\n            normalizedPath = (0, _normalizepagepath.normalizePagePath)(pathname);\n        } catch (err) {\n            console.error(err);\n            // if normalizing the page fails it means it isn't valid\n            // so it doesn't exist so don't throw and return false\n            // to ensure we return 404 instead of 500\n            return false;\n        }\n        if ((0, _utils2.isMiddlewareFile)(normalizedPath)) {\n            return (0, _findpagefile.findPageFile)(this.dir, normalizedPath, this.nextConfig.pageExtensions, false).then(Boolean);\n        }\n        let appFile = null;\n        let pagesFile = null;\n        if (this.appDir) {\n            appFile = await (0, _findpagefile.findPageFile)(this.appDir, normalizedPath + '/page', this.nextConfig.pageExtensions, true);\n        }\n        if (this.pagesDir) {\n            pagesFile = await (0, _findpagefile.findPageFile)(this.pagesDir, normalizedPath, this.nextConfig.pageExtensions, false);\n        }\n        if (appFile && pagesFile) {\n            return false;\n        }\n        return Boolean(appFile || pagesFile);\n    }\n    async runMiddleware(params) {\n        try {\n            const result = await super.runMiddleware({\n                ...params,\n                onWarning: (warn)=>{\n                    this.logErrorWithOriginalStack(warn, 'warning');\n                }\n            });\n            if ('finished' in result) {\n                return result;\n            }\n            result.waitUntil.catch((error)=>{\n                this.logErrorWithOriginalStack(error, 'unhandledRejection');\n            });\n            return result;\n        } catch (error) {\n            if (error instanceof _utils1.DecodeError) {\n                throw error;\n            }\n            /**\n       * We only log the error when it is not a MiddlewareNotFound error as\n       * in that case we should be already displaying a compilation error\n       * which is what makes the module not found.\n       */ if (!(error instanceof _utils1.MiddlewareNotFoundError)) {\n                this.logErrorWithOriginalStack(error);\n            }\n            const err = (0, _iserror.getProperError)(error);\n            (0, _errorsource.decorateServerError)(err, _constants1.COMPILER_NAMES.edgeServer);\n            const { request, response, parsedUrl } = params;\n            /**\n       * When there is a failure for an internal Next.js request from\n       * middleware we bypass the error without finishing the request\n       * so we can serve the required chunks to render the error.\n       */ if (request.url.includes('/_next/static') || request.url.includes('/__nextjs_original-stack-frame') || request.url.includes('/__nextjs_source-map') || request.url.includes('/__nextjs_error_feedback')) {\n                return {\n                    finished: false\n                };\n            }\n            response.statusCode = 500;\n            await this.renderError(err, request, response, parsedUrl.pathname);\n            return {\n                finished: true\n            };\n        }\n    }\n    async runEdgeFunction(params) {\n        try {\n            return super.runEdgeFunction({\n                ...params,\n                onError: (err)=>this.logErrorWithOriginalStack(err, 'app-dir'),\n                onWarning: (warn)=>{\n                    this.logErrorWithOriginalStack(warn, 'warning');\n                }\n            });\n        } catch (error) {\n            if (error instanceof _utils1.DecodeError) {\n                throw error;\n            }\n            this.logErrorWithOriginalStack(error, 'warning');\n            const err = (0, _iserror.getProperError)(error);\n            const { req, res, page } = params;\n            res.statusCode = 500;\n            await this.renderError(err, req, res, page);\n            return null;\n        }\n    }\n    getRequestHandler() {\n        const handler = super.getRequestHandler();\n        return (req, res, parsedUrl)=>{\n            const request = this.normalizeReq(req);\n            const response = this.normalizeRes(res);\n            const loggingConfig = this.nextConfig.logging;\n            if (loggingConfig !== false) {\n                const start = Date.now();\n                const isMiddlewareRequest = (0, _requestmeta.getRequestMeta)(req, 'middlewareInvoke');\n                if (!isMiddlewareRequest) {\n                    response.originalResponse.once('close', ()=>{\n                        // NOTE: The route match is only attached to the request's meta data\n                        // after the request handler is created, so we need to check it in the\n                        // close handler and not before.\n                        const routeMatch = (0, _requestmeta.getRequestMeta)(req).match;\n                        if (!routeMatch) {\n                            return;\n                        }\n                        (0, _logrequests.logRequests)({\n                            request,\n                            response,\n                            loggingConfig,\n                            requestDurationInMs: Date.now() - start\n                        });\n                    });\n                }\n            }\n            return handler(request, response, parsedUrl);\n        };\n    }\n    async handleRequest(req, res, parsedUrl) {\n        const span = (0, _trace.trace)('handle-request', undefined, {\n            url: req.url\n        });\n        const result = await span.traceAsyncFn(async ()=>{\n            var _this_ready;\n            await ((_this_ready = this.ready) == null ? void 0 : _this_ready.promise);\n            return await super.handleRequest(req, res, parsedUrl);\n        });\n        const memoryUsage = process.memoryUsage();\n        span.traceChild('memory-usage', {\n            url: req.url,\n            'memory.rss': String(memoryUsage.rss),\n            'memory.heapUsed': String(memoryUsage.heapUsed),\n            'memory.heapTotal': String(memoryUsage.heapTotal)\n        }).stop();\n        return result;\n    }\n    async run(req, res, parsedUrl) {\n        var _this_ready;\n        await ((_this_ready = this.ready) == null ? void 0 : _this_ready.promise);\n        const { basePath } = this.nextConfig;\n        let originalPathname = null;\n        // TODO: see if we can remove this in the future\n        if (basePath && (0, _pathhasprefix.pathHasPrefix)(parsedUrl.pathname || '/', basePath)) {\n            // strip basePath before handling dev bundles\n            // If replace ends up replacing the full url it'll be `undefined`, meaning we have to default it to `/`\n            originalPathname = parsedUrl.pathname;\n            parsedUrl.pathname = (0, _removepathprefix.removePathPrefix)(parsedUrl.pathname || '/', basePath);\n        }\n        const { pathname } = parsedUrl;\n        if (pathname.startsWith('/_next')) {\n            if (_fs.default.existsSync((0, _path.join)(this.publicDir, '_next'))) {\n                throw Object.defineProperty(new Error(_constants.PUBLIC_DIR_MIDDLEWARE_CONFLICT), \"__NEXT_ERROR_CODE\", {\n                    value: \"E394\",\n                    enumerable: false,\n                    configurable: true\n                });\n            }\n        }\n        if (originalPathname) {\n            // restore the path before continuing so that custom-routes can accurately determine\n            // if they should match against the basePath or not\n            parsedUrl.pathname = originalPathname;\n        }\n        try {\n            return await super.run(req, res, parsedUrl);\n        } catch (error) {\n            const err = (0, _iserror.getProperError)(error);\n            (0, _formatservererror.formatServerError)(err);\n            this.logErrorWithOriginalStack(err);\n            if (!res.sent) {\n                res.statusCode = 500;\n                try {\n                    return await this.renderError(err, req, res, pathname, {\n                        __NEXT_PAGE: (0, _iserror.default)(err) && err.page || pathname || ''\n                    });\n                } catch (internalErr) {\n                    console.error(internalErr);\n                    res.body('Internal Server Error').send();\n                }\n            }\n        }\n    }\n    logErrorWithOriginalStack(err, type) {\n        this.bundlerService.logErrorWithOriginalStack(err, type);\n    }\n    getPagesManifest() {\n        return _nodemanifestloader.NodeManifestLoader.require((0, _path.join)(this.serverDistDir, _constants1.PAGES_MANIFEST)) ?? undefined;\n    }\n    getAppPathsManifest() {\n        if (!this.enabledDirectories.app) return undefined;\n        return _nodemanifestloader.NodeManifestLoader.require((0, _path.join)(this.serverDistDir, _constants1.APP_PATHS_MANIFEST)) ?? undefined;\n    }\n    getinterceptionRoutePatterns() {\n        const rewrites = (0, _generateinterceptionroutesrewrites.generateInterceptionRoutesRewrites)(Object.keys(this.appPathRoutes ?? {}), this.nextConfig.basePath).map((route)=>new RegExp((0, _buildcustomroute.buildCustomRoute)('rewrite', route).regex));\n        if (this.nextConfig.output === 'export' && rewrites.length > 0) {\n            _log.error('Intercepting routes are not supported with static export.\\nRead more: https://nextjs.org/docs/app/building-your-application/deploying/static-exports#unsupported-features');\n            process.exit(1);\n        }\n        return rewrites ?? [];\n    }\n    async getMiddleware() {\n        var _this_middleware;\n        // We need to populate the match\n        // field as it isn't serializable\n        if (((_this_middleware = this.middleware) == null ? void 0 : _this_middleware.match) === null) {\n            this.middleware.match = (0, _middlewareroutematcher.getMiddlewareRouteMatcher)(this.middleware.matchers || []);\n        }\n        return this.middleware;\n    }\n    getNextFontManifest() {\n        return undefined;\n    }\n    async hasMiddleware() {\n        return this.hasPage(this.actualMiddlewareFile);\n    }\n    async ensureMiddleware(url) {\n        return this.ensurePage({\n            page: this.actualMiddlewareFile,\n            clientOnly: false,\n            definition: undefined,\n            url\n        });\n    }\n    async loadInstrumentationModule() {\n        let instrumentationModule;\n        if (this.actualInstrumentationHookFile && await this.ensurePage({\n            page: this.actualInstrumentationHookFile,\n            clientOnly: false,\n            definition: undefined\n        }).then(()=>true).catch(()=>false)) {\n            try {\n                instrumentationModule = await require((0, _path.join)(this.distDir, 'server', _constants.INSTRUMENTATION_HOOK_FILENAME));\n            } catch (err) {\n                err.message = `An error occurred while loading instrumentation hook: ${err.message}`;\n                throw err;\n            }\n        }\n        return instrumentationModule;\n    }\n    async runInstrumentationHookIfAvailable() {\n        await this.startServerSpan.traceChild('run-instrumentation-hook').traceAsyncFn(()=>{\n            var _this_instrumentation_register, _this_instrumentation;\n            return (_this_instrumentation = this.instrumentation) == null ? void 0 : (_this_instrumentation_register = _this_instrumentation.register) == null ? void 0 : _this_instrumentation_register.call(_this_instrumentation);\n        });\n    }\n    async ensureEdgeFunction({ page, appPaths, url }) {\n        return this.ensurePage({\n            page,\n            appPaths,\n            clientOnly: false,\n            definition: undefined,\n            url\n        });\n    }\n    generateRoutes(_dev) {\n    // In development we expose all compiled files for react-error-overlay's line show feature\n    // We use unshift so that we're sure the routes is defined before Next's default routes\n    // routes.unshift({\n    //   match: getPathMatch('/_next/development/:path*'),\n    //   type: 'route',\n    //   name: '_next/development catchall',\n    //   fn: async (req, res, params) => {\n    //     const p = pathJoin(this.distDir, ...(params.path || []))\n    //     await this.serveStatic(req, res, p)\n    //     return {\n    //       finished: true,\n    //     }\n    //   },\n    // })\n    }\n    _filterAmpDevelopmentScript(html, event) {\n        if (event.code !== 'DISALLOWED_SCRIPT_TAG') {\n            return true;\n        }\n        const snippetChunks = html.split('\\n');\n        let snippet;\n        if (!(snippet = html.split('\\n')[event.line - 1]) || !(snippet = snippet.substring(event.col))) {\n            return true;\n        }\n        snippet = snippet + snippetChunks.slice(event.line).join('\\n');\n        snippet = snippet.substring(0, snippet.indexOf('</script>'));\n        return !snippet.includes('data-amp-development-mode-only');\n    }\n    async getStaticPaths({ pathname, requestHeaders, page, isAppPath }) {\n        // we lazy load the staticPaths to prevent the user\n        // from waiting on them for the page to load in dev mode\n        const __getStaticPaths = async ()=>{\n            const { configFileName, publicRuntimeConfig, serverRuntimeConfig, httpAgentOptions } = this.nextConfig;\n            const { locales, defaultLocale } = this.nextConfig.i18n || {};\n            const staticPathsWorker = this.getStaticPathsWorker();\n            try {\n                var _this_nextConfig_experimental_sri;\n                const pathsResult = await staticPathsWorker.loadStaticPaths({\n                    dir: this.dir,\n                    distDir: this.distDir,\n                    pathname,\n                    config: {\n                        pprConfig: this.nextConfig.experimental.ppr,\n                        configFileName,\n                        publicRuntimeConfig,\n                        serverRuntimeConfig,\n                        dynamicIO: Boolean(this.nextConfig.experimental.dynamicIO)\n                    },\n                    httpAgentOptions,\n                    locales,\n                    defaultLocale,\n                    page,\n                    isAppPath,\n                    requestHeaders,\n                    cacheHandler: this.nextConfig.cacheHandler,\n                    cacheHandlers: this.nextConfig.experimental.cacheHandlers,\n                    cacheLifeProfiles: this.nextConfig.experimental.cacheLife,\n                    fetchCacheKeyPrefix: this.nextConfig.experimental.fetchCacheKeyPrefix,\n                    isrFlushToDisk: this.nextConfig.experimental.isrFlushToDisk,\n                    maxMemoryCacheSize: this.nextConfig.cacheMaxMemorySize,\n                    nextConfigOutput: this.nextConfig.output,\n                    buildId: this.buildId,\n                    authInterrupts: Boolean(this.nextConfig.experimental.authInterrupts),\n                    sriEnabled: Boolean((_this_nextConfig_experimental_sri = this.nextConfig.experimental.sri) == null ? void 0 : _this_nextConfig_experimental_sri.algorithm)\n                });\n                return pathsResult;\n            } finally{\n                // we don't re-use workers so destroy the used one\n                staticPathsWorker.end();\n            }\n        };\n        const result = this.staticPathsCache.get(pathname);\n        const nextInvoke = (0, _coalescedfunction.withCoalescedInvoke)(__getStaticPaths)(`staticPaths-${pathname}`, []).then((res)=>{\n            const { prerenderedRoutes: staticPaths, fallbackMode: fallback } = res.value;\n            if (!isAppPath && this.nextConfig.output === 'export') {\n                if (fallback === _fallback.FallbackMode.BLOCKING_STATIC_RENDER) {\n                    throw Object.defineProperty(new Error('getStaticPaths with \"fallback: blocking\" cannot be used with \"output: export\". See more info here: https://nextjs.org/docs/advanced-features/static-html-export'), \"__NEXT_ERROR_CODE\", {\n                        value: \"E11\",\n                        enumerable: false,\n                        configurable: true\n                    });\n                } else if (fallback === _fallback.FallbackMode.PRERENDER) {\n                    throw Object.defineProperty(new Error('getStaticPaths with \"fallback: true\" cannot be used with \"output: export\". See more info here: https://nextjs.org/docs/advanced-features/static-html-export'), \"__NEXT_ERROR_CODE\", {\n                        value: \"E210\",\n                        enumerable: false,\n                        configurable: true\n                    });\n                }\n            }\n            const value = {\n                staticPaths: staticPaths == null ? void 0 : staticPaths.map((route)=>route.pathname),\n                fallbackMode: fallback\n            };\n            this.staticPathsCache.set(pathname, value);\n            return value;\n        }).catch((err)=>{\n            this.staticPathsCache.remove(pathname);\n            if (!result) throw err;\n            _log.error(`Failed to generate static paths for ${pathname}:`);\n            console.error(err);\n        });\n        if (result) {\n            return result;\n        }\n        return nextInvoke;\n    }\n    async ensurePage(opts) {\n        await this.bundlerService.ensurePage(opts);\n    }\n    async findPageComponents({ locale, page, query, params, isAppPath, appPaths = null, shouldEnsure, url }) {\n        var _this_ready;\n        await ((_this_ready = this.ready) == null ? void 0 : _this_ready.promise);\n        const compilationErr = await this.getCompilationError(page);\n        if (compilationErr) {\n            // Wrap build errors so that they don't get logged again\n            throw new _nextserver.WrappedBuildError(compilationErr);\n        }\n        if (shouldEnsure || this.serverOptions.customServer) {\n            await this.ensurePage({\n                page,\n                appPaths,\n                clientOnly: false,\n                definition: undefined,\n                url\n            });\n        }\n        this.nextFontManifest = super.getNextFontManifest();\n        return await super.findPageComponents({\n            page,\n            query,\n            params,\n            locale,\n            isAppPath,\n            shouldEnsure,\n            url\n        });\n    }\n    async getFallbackErrorComponents(url) {\n        await this.bundlerService.getFallbackErrorComponents(url);\n        return await (0, _loaddefaulterrorcomponents.loadDefaultErrorComponents)(this.distDir);\n    }\n    async getCompilationError(page) {\n        return await this.bundlerService.getCompilationError(page);\n    }\n    async instrumentationOnRequestError(...args) {\n        await super.instrumentationOnRequestError(...args);\n        const err = args[0];\n        this.logErrorWithOriginalStack(err, 'app-dir');\n    }\n}\n\n//# sourceMappingURL=next-dev-server.js.map"
        }
    ]
}