{
    "sourceFile": "node_modules/next/dist/server/dev/log-requests.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892873053,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    ignoreLoggingIncomingRequests: null,\n    logRequests: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    ignoreLoggingIncomingRequests: function() {\n        return ignoreLoggingIncomingRequests;\n    },\n    logRequests: function() {\n        return logRequests;\n    }\n});\nconst _picocolors = require(\"../../lib/picocolors\");\nconst _url = require(\"../../lib/url\");\nconst _requestmeta = require(\"../request-meta\");\nfunction ignoreLoggingIncomingRequests(request, loggingConfig) {\n    var _loggingConfig_incomingRequests;\n    // If it's boolean use the boolean value\n    if (typeof (loggingConfig == null ? void 0 : loggingConfig.incomingRequests) === 'boolean') {\n        return !loggingConfig.incomingRequests;\n    }\n    // Any of the value on the chain is falsy, will not ignore the request.\n    const ignore = loggingConfig == null ? void 0 : (_loggingConfig_incomingRequests = loggingConfig.incomingRequests) == null ? void 0 : _loggingConfig_incomingRequests.ignore;\n    // If ignore is not set, don't ignore anything\n    if (!ignore) {\n        return false;\n    }\n    // If array of RegExp, ignore if any pattern matches\n    return ignore.some((pattern)=>pattern.test(request.url));\n}\nfunction logRequests(options) {\n    const { request, response, loggingConfig, requestDurationInMs } = options;\n    if (!ignoreLoggingIncomingRequests(request, loggingConfig)) {\n        logIncomingRequests({\n            request,\n            requestDurationInMs,\n            statusCode: response.statusCode\n        });\n    }\n    if (request.fetchMetrics) {\n        for (const fetchMetric of request.fetchMetrics){\n            logFetchMetric(fetchMetric, loggingConfig);\n        }\n    }\n}\nfunction logIncomingRequests(options) {\n    const { request, requestDurationInMs, statusCode } = options;\n    const isRSC = (0, _requestmeta.getRequestMeta)(request, 'isRSCRequest');\n    const url = isRSC ? (0, _url.stripNextRscUnionQuery)(request.url) : request.url;\n    const statusCodeColor = statusCode < 200 ? _picocolors.white : statusCode < 300 ? _picocolors.green : statusCode < 400 ? _picocolors.blue : statusCode < 500 ? _picocolors.yellow : _picocolors.red;\n    const coloredStatus = statusCodeColor(statusCode.toString());\n    return writeLine(`${request.method} ${url} ${coloredStatus} in ${requestDurationInMs}ms`);\n}\nfunction logFetchMetric(fetchMetric, loggingConfig) {\n    var _loggingConfig_fetches;\n    let { cacheReason, cacheStatus, cacheWarning, end, method, start, status, url } = fetchMetric;\n    if (cacheStatus === 'hmr' && !(loggingConfig == null ? void 0 : (_loggingConfig_fetches = loggingConfig.fetches) == null ? void 0 : _loggingConfig_fetches.hmrRefreshes)) {\n        // Cache hits during HMR refreshes are intentionally not logged, unless\n        // explicitly enabled in the logging config.\n        return;\n    }\n    if (loggingConfig == null ? void 0 : loggingConfig.fetches) {\n        if (url.length > 48 && !loggingConfig.fetches.fullUrl) {\n            url = truncateUrl(url);\n        }\n        writeLine((0, _picocolors.white)(`${method} ${url} ${status} in ${Math.round(end - start)}ms ${formatCacheStatus(cacheStatus)}`), 1);\n        if (cacheStatus === 'skip' || cacheStatus === 'miss') {\n            writeLine((0, _picocolors.gray)(`Cache ${cacheStatus === 'skip' ? 'skipped' : 'missed'} reason: (${(0, _picocolors.white)(cacheReason)})`), 2);\n        }\n    } else if (cacheWarning) {\n        // When logging for fetches is not enabled, we still want to print any\n        // associated warnings, so we print the request first to provide context.\n        writeLine((0, _picocolors.white)(`${method} ${url}`), 1);\n    }\n    if (cacheWarning) {\n        writeLine(`${(0, _picocolors.yellow)((0, _picocolors.bold)('⚠'))} ${(0, _picocolors.white)(cacheWarning)}`, 2);\n    }\n}\nfunction writeLine(text, indentationLevel = 0) {\n    process.stdout.write(` ${'│ '.repeat(indentationLevel)}${text}\\n`);\n}\nfunction truncate(text, maxLength) {\n    return maxLength !== undefined && text.length > maxLength ? text.substring(0, maxLength) + '..' : text;\n}\nfunction truncateUrl(url) {\n    const { protocol, host, pathname, search } = new URL(url);\n    return protocol + '//' + truncate(host, 16) + truncate(pathname, 24) + truncate(search, 16);\n}\nfunction formatCacheStatus(cacheStatus) {\n    switch(cacheStatus){\n        case 'hmr':\n            return (0, _picocolors.green)('(HMR cache)');\n        case 'hit':\n            return (0, _picocolors.green)('(cache hit)');\n        default:\n            return (0, _picocolors.yellow)(`(cache ${cacheStatus})`);\n    }\n}\n\n//# sourceMappingURL=log-requests.js.map"
        }
    ]
}