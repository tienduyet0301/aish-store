{
    "sourceFile": "node_modules/next/dist/server/dev/hot-reloader-webpack.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892872979,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    default: null,\n    getVersionInfo: null,\n    matchNextPageBundleRequest: null,\n    renderScriptError: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    default: function() {\n        return HotReloaderWebpack;\n    },\n    getVersionInfo: function() {\n        return getVersionInfo;\n    },\n    matchNextPageBundleRequest: function() {\n        return matchNextPageBundleRequest;\n    },\n    renderScriptError: function() {\n        return renderScriptError;\n    }\n});\nconst _webpack = require(\"next/dist/compiled/webpack/webpack\");\nconst _middlewarewebpack = require(\"../../client/components/react-dev-overlay/server/middleware-webpack\");\nconst _hotmiddleware = require(\"./hot-middleware\");\nconst _path = require(\"path\");\nconst _entries = require(\"../../build/entries\");\nconst _output = require(\"../../build/output\");\nconst _log = /*#__PURE__*/ _interop_require_wildcard(require(\"../../build/output/log\"));\nconst _webpackconfig = /*#__PURE__*/ _interop_require_wildcard(require(\"../../build/webpack-config\"));\nconst _constants = require(\"../../lib/constants\");\nconst _recursivedelete = require(\"../../lib/recursive-delete\");\nconst _constants1 = require(\"../../shared/lib/constants\");\nconst _pathmatch = require(\"../../shared/lib/router/utils/path-match\");\nconst _findpagefile = require(\"../lib/find-page-file\");\nconst _ondemandentryhandler = require(\"./on-demand-entry-handler\");\nconst _denormalizepagepath = require(\"../../shared/lib/page-path/denormalize-page-path\");\nconst _normalizepathsep = require(\"../../shared/lib/page-path/normalize-path-sep\");\nconst _getroutefromentrypoint = /*#__PURE__*/ _interop_require_default(require(\"../get-route-from-entrypoint\"));\nconst _utils = require(\"../../build/utils\");\nconst _utils1 = require(\"../../shared/lib/utils\");\nconst _trace = require(\"../../trace\");\nconst _iserror = require(\"../../lib/is-error\");\nconst _ws = /*#__PURE__*/ _interop_require_default(require(\"next/dist/compiled/ws\"));\nconst _fs = require(\"fs\");\nconst _parseversioninfo = require(\"./parse-version-info\");\nconst _isapiroute = require(\"../../lib/is-api-route\");\nconst _nextrouteloader = require(\"../../build/webpack/loaders/next-route-loader\");\nconst _isinternalcomponent = require(\"../../lib/is-internal-component\");\nconst _routekind = require(\"../route-kind\");\nconst _hotreloadertypes = require(\"./hot-reloader-types\");\nconst _pagetypes = require(\"../../lib/page-types\");\nconst _messages = require(\"./messages\");\nconst _utils2 = require(\"../lib/utils\");\nconst _getnexterrorfeedbackmiddleware = require(\"../../client/components/react-dev-overlay/server/get-next-error-feedback-middleware\");\nconst _getdevoverlayfontmiddleware = require(\"../../client/components/react-dev-overlay/font/get-dev-overlay-font-middleware\");\nconst _devindicatormiddleware = require(\"./dev-indicator-middleware\");\nconst _getwebpackbundler = /*#__PURE__*/ _interop_require_default(require(\"../../shared/lib/get-webpack-bundler\"));\nfunction _interop_require_default(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nfunction _getRequireWildcardCache(nodeInterop) {\n    if (typeof WeakMap !== \"function\") return null;\n    var cacheBabelInterop = new WeakMap();\n    var cacheNodeInterop = new WeakMap();\n    return (_getRequireWildcardCache = function(nodeInterop) {\n        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n    })(nodeInterop);\n}\nfunction _interop_require_wildcard(obj, nodeInterop) {\n    if (!nodeInterop && obj && obj.__esModule) {\n        return obj;\n    }\n    if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n        return {\n            default: obj\n        };\n    }\n    var cache = _getRequireWildcardCache(nodeInterop);\n    if (cache && cache.has(obj)) {\n        return cache.get(obj);\n    }\n    var newObj = {\n        __proto__: null\n    };\n    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n    for(var key in obj){\n        if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n            if (desc && (desc.get || desc.set)) {\n                Object.defineProperty(newObj, key, desc);\n            } else {\n                newObj[key] = obj[key];\n            }\n        }\n    }\n    newObj.default = obj;\n    if (cache) {\n        cache.set(obj, newObj);\n    }\n    return newObj;\n}\nconst MILLISECONDS_IN_NANOSECOND = BigInt(1000000);\nfunction diff(a, b) {\n    return new Set([\n        ...a\n    ].filter((v)=>!b.has(v)));\n}\nconst wsServer = new _ws.default.Server({\n    noServer: true\n});\nasync function renderScriptError(res, error, { verbose = true } = {}) {\n    // Asks CDNs and others to not to cache the errored page\n    res.setHeader('Cache-Control', 'no-cache, no-store, max-age=0, must-revalidate');\n    if (error.code === 'ENOENT') {\n        return {\n            finished: undefined\n        };\n    }\n    if (verbose) {\n        console.error(error.stack);\n    }\n    res.statusCode = 500;\n    res.end('500 - Internal Error');\n    return {\n        finished: true\n    };\n}\nfunction addCorsSupport(req, res) {\n    // Only rewrite CORS handling when URL matches a hot-reloader middleware\n    if (!req.url.startsWith('/__next')) {\n        return {\n            preflight: false\n        };\n    }\n    if (!req.headers.origin) {\n        return {\n            preflight: false\n        };\n    }\n    res.setHeader('Access-Control-Allow-Origin', req.headers.origin);\n    res.setHeader('Access-Control-Allow-Methods', 'OPTIONS, GET');\n    // Based on https://github.com/primus/access-control/blob/4cf1bc0e54b086c91e6aa44fb14966fa5ef7549c/index.js#L158\n    if (req.headers['access-control-request-headers']) {\n        res.setHeader('Access-Control-Allow-Headers', req.headers['access-control-request-headers']);\n    }\n    if (req.method === 'OPTIONS') {\n        res.writeHead(200);\n        res.end();\n        return {\n            preflight: true\n        };\n    }\n    return {\n        preflight: false\n    };\n}\nconst matchNextPageBundleRequest = (0, _pathmatch.getPathMatch)('/_next/static/chunks/pages/:path*.js(\\\\.map|)');\n// Iteratively look up the issuer till it ends up at the root\nfunction findEntryModule(module1, compilation) {\n    for(;;){\n        const issuer = compilation.moduleGraph.getIssuer(module1);\n        if (!issuer) return module1;\n        module1 = issuer;\n    }\n}\nfunction erroredPages(compilation) {\n    const failedPages = {};\n    for (const error of compilation.errors){\n        if (!error.module) {\n            continue;\n        }\n        const entryModule = findEntryModule(error.module, compilation);\n        const { name } = entryModule;\n        if (!name) {\n            continue;\n        }\n        // Only pages have to be reloaded\n        const enhancedName = (0, _getroutefromentrypoint.default)(name);\n        if (!enhancedName) {\n            continue;\n        }\n        if (!failedPages[enhancedName]) {\n            failedPages[enhancedName] = [];\n        }\n        failedPages[enhancedName].push(error);\n    }\n    return failedPages;\n}\nasync function getVersionInfo() {\n    let installed = '0.0.0';\n    try {\n        installed = require('next/package.json').version;\n        let res;\n        try {\n            // use NPM registry regardless user using Yarn\n            res = await fetch('https://registry.npmjs.org/-/package/next/dist-tags');\n        } catch  {\n        // ignore fetch errors\n        }\n        if (!res || !res.ok) return {\n            installed,\n            staleness: 'unknown'\n        };\n        const { latest, canary } = await res.json();\n        return (0, _parseversioninfo.parseVersionInfo)({\n            installed,\n            latest,\n            canary\n        });\n    } catch (e) {\n        console.error(e);\n        return {\n            installed,\n            staleness: 'unknown'\n        };\n    }\n}\nclass HotReloaderWebpack {\n    constructor(dir, { config, pagesDir, distDir, buildId, encryptionKey, previewProps, rewrites, appDir, telemetry, resetFetch }){\n        this.clientError = null;\n        this.serverError = null;\n        this.hmrServerError = null;\n        this.pagesMapping = {};\n        this.versionInfo = {\n            staleness: 'unknown',\n            installed: '0.0.0'\n        };\n        this.reloadAfterInvalidation = false;\n        this.hasAmpEntrypoints = false;\n        this.hasAppRouterEntrypoints = false;\n        this.hasPagesRouterEntrypoints = false;\n        this.buildId = buildId;\n        this.encryptionKey = encryptionKey;\n        this.dir = dir;\n        this.middlewares = [];\n        this.pagesDir = pagesDir;\n        this.appDir = appDir;\n        this.distDir = distDir;\n        this.clientStats = null;\n        this.serverStats = null;\n        this.edgeServerStats = null;\n        this.serverPrevDocumentHash = null;\n        this.telemetry = telemetry;\n        this.resetFetch = resetFetch;\n        this.config = config;\n        this.previewProps = previewProps;\n        this.rewrites = rewrites;\n        this.hotReloaderSpan = (0, _trace.trace)('hot-reloader', undefined, {\n            version: \"15.3.1\"\n        });\n        // Ensure the hotReloaderSpan is flushed immediately as it's the parentSpan for all processing\n        // of the current `next dev` invocation.\n        this.hotReloaderSpan.stop();\n    }\n    async run(req, res, parsedUrl) {\n        // Usually CORS support is not needed for the hot-reloader (this is dev only feature)\n        // With when the app runs for multi-zones support behind a proxy,\n        // the current page is trying to access this URL via assetPrefix.\n        // That's when the CORS support is needed.\n        const { preflight } = addCorsSupport(req, res);\n        if (preflight) {\n            return {};\n        }\n        // When a request comes in that is a page bundle, e.g. /_next/static/<buildid>/pages/index.js\n        // we have to compile the page using on-demand-entries, this middleware will handle doing that\n        // by adding the page to on-demand-entries, waiting till it's done\n        // and then the bundle will be served like usual by the actual route in server/index.js\n        const handlePageBundleRequest = async (pageBundleRes, parsedPageBundleUrl)=>{\n            const { pathname } = parsedPageBundleUrl;\n            if (!pathname) return {};\n            const params = matchNextPageBundleRequest(pathname);\n            if (!params) return {};\n            let decodedPagePath;\n            try {\n                decodedPagePath = `/${params.path.map((param)=>decodeURIComponent(param)).join('/')}`;\n            } catch (_) {\n                throw Object.defineProperty(new _utils1.DecodeError('failed to decode param'), \"__NEXT_ERROR_CODE\", {\n                    value: \"E528\",\n                    enumerable: false,\n                    configurable: true\n                });\n            }\n            const page = (0, _denormalizepagepath.denormalizePagePath)(decodedPagePath);\n            if (page === '/_error' || _constants1.BLOCKED_PAGES.indexOf(page) === -1) {\n                try {\n                    await this.ensurePage({\n                        page,\n                        clientOnly: true,\n                        url: req.url\n                    });\n                } catch (error) {\n                    return await renderScriptError(pageBundleRes, (0, _iserror.getProperError)(error));\n                }\n                const errors = await this.getCompilationErrors(page);\n                if (errors.length > 0) {\n                    return await renderScriptError(pageBundleRes, errors[0], {\n                        verbose: false\n                    });\n                }\n            }\n            return {};\n        };\n        const { finished } = await handlePageBundleRequest(res, parsedUrl);\n        for (const middleware of this.middlewares){\n            let calledNext = false;\n            await middleware(req, res, ()=>{\n                calledNext = true;\n            });\n            if (!calledNext) {\n                return {\n                    finished: true\n                };\n            }\n        }\n        return {\n            finished\n        };\n    }\n    setHmrServerError(error) {\n        this.hmrServerError = error;\n    }\n    clearHmrServerError() {\n        if (this.hmrServerError) {\n            this.setHmrServerError(null);\n            this.send({\n                action: _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.RELOAD_PAGE,\n                data: 'clear hmr server error'\n            });\n        }\n    }\n    async refreshServerComponents(hash) {\n        this.send({\n            action: _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.SERVER_COMPONENT_CHANGES,\n            hash\n        });\n    }\n    onHMR(req, _socket, head, callback) {\n        wsServer.handleUpgrade(req, req.socket, head, (client)=>{\n            var _this_webpackHotMiddleware, _this_onDemandEntries;\n            (_this_webpackHotMiddleware = this.webpackHotMiddleware) == null ? void 0 : _this_webpackHotMiddleware.onHMR(client);\n            (_this_onDemandEntries = this.onDemandEntries) == null ? void 0 : _this_onDemandEntries.onHMR(client, ()=>this.hmrServerError);\n            callback(client);\n            client.addEventListener('message', ({ data })=>{\n                data = typeof data !== 'string' ? data.toString() : data;\n                try {\n                    const payload = JSON.parse(data);\n                    let traceChild;\n                    switch(payload.event){\n                        case 'span-end':\n                            {\n                                traceChild = {\n                                    name: payload.spanName,\n                                    startTime: BigInt(Math.floor(payload.startTime)) * MILLISECONDS_IN_NANOSECOND,\n                                    attrs: payload.attributes,\n                                    endTime: BigInt(Math.floor(payload.endTime)) * MILLISECONDS_IN_NANOSECOND\n                                };\n                                break;\n                            }\n                        case 'client-hmr-latency':\n                            {\n                                traceChild = {\n                                    name: payload.event,\n                                    startTime: BigInt(payload.startTime) * MILLISECONDS_IN_NANOSECOND,\n                                    endTime: BigInt(payload.endTime) * MILLISECONDS_IN_NANOSECOND,\n                                    attrs: {\n                                        updatedModules: payload.updatedModules.map((m)=>m.replace(`(${_constants.WEBPACK_LAYERS.appPagesBrowser})/`, '').replace(/^\\.\\//, '[project]/')),\n                                        page: payload.page,\n                                        isPageHidden: payload.isPageHidden\n                                    }\n                                };\n                                break;\n                            }\n                        case 'client-reload-page':\n                        case 'client-success':\n                            {\n                                traceChild = {\n                                    name: payload.event\n                                };\n                                break;\n                            }\n                        case 'client-error':\n                            {\n                                traceChild = {\n                                    name: payload.event,\n                                    attrs: {\n                                        errorCount: payload.errorCount\n                                    }\n                                };\n                                break;\n                            }\n                        case 'client-warning':\n                            {\n                                traceChild = {\n                                    name: payload.event,\n                                    attrs: {\n                                        warningCount: payload.warningCount\n                                    }\n                                };\n                                break;\n                            }\n                        case 'client-removed-page':\n                        case 'client-added-page':\n                            {\n                                traceChild = {\n                                    name: payload.event,\n                                    attrs: {\n                                        page: payload.page || ''\n                                    }\n                                };\n                                break;\n                            }\n                        case 'client-full-reload':\n                            {\n                                const { event, stackTrace, hadRuntimeError } = payload;\n                                traceChild = {\n                                    name: event,\n                                    attrs: {\n                                        stackTrace: stackTrace ?? ''\n                                    }\n                                };\n                                if (hadRuntimeError) {\n                                    _log.warn(_messages.FAST_REFRESH_RUNTIME_RELOAD);\n                                    break;\n                                }\n                                let fileMessage = '';\n                                if (stackTrace) {\n                                    var _exec;\n                                    const file = (_exec = /Aborted because (.+) is not accepted/.exec(stackTrace)) == null ? void 0 : _exec[1];\n                                    if (file) {\n                                        // `file` is filepath in `pages/` but it can be a webpack url.\n                                        // If it's a webpack loader URL, it will include the app-pages layer\n                                        if (file.startsWith(`(${_constants.WEBPACK_LAYERS.appPagesBrowser})/`)) {\n                                            const fileUrl = new URL(file, 'file://');\n                                            const cwd = process.cwd();\n                                            const modules = fileUrl.searchParams.getAll('modules').map((filepath)=>filepath.slice(cwd.length + 1)).filter((filepath)=>!filepath.startsWith('node_modules'));\n                                            if (modules.length > 0) {\n                                                fileMessage = ` when ${modules.join(', ')} changed`;\n                                            }\n                                        } else if (// Handle known webpack layers\n                                        file.startsWith(`(${_constants.WEBPACK_LAYERS.pagesDirBrowser})/`)) {\n                                            const cleanedFilePath = file.slice(`(${_constants.WEBPACK_LAYERS.pagesDirBrowser})/`.length);\n                                            fileMessage = ` when ${cleanedFilePath} changed`;\n                                        } else {\n                                            fileMessage = ` when ${file} changed`;\n                                        }\n                                    }\n                                }\n                                _log.warn(`Fast Refresh had to perform a full reload${fileMessage}. Read more: https://nextjs.org/docs/messages/fast-refresh-reload`);\n                                break;\n                            }\n                        default:\n                            {\n                                break;\n                            }\n                    }\n                    if (traceChild) {\n                        this.hotReloaderSpan.manualTraceChild(traceChild.name, traceChild.startTime, traceChild.endTime, {\n                            ...traceChild.attrs,\n                            clientId: payload.id\n                        });\n                    }\n                } catch (_) {\n                // invalid WebSocket message\n                }\n            });\n        });\n    }\n    async clean(span) {\n        return span.traceChild('clean').traceAsyncFn(()=>(0, _recursivedelete.recursiveDelete)((0, _path.join)(this.dir, this.config.distDir), /^cache/));\n    }\n    async getWebpackConfig(span) {\n        const webpackConfigSpan = span.traceChild('get-webpack-config');\n        const pageExtensions = this.config.pageExtensions;\n        return webpackConfigSpan.traceAsyncFn(async ()=>{\n            const pagePaths = !this.pagesDir ? [] : await webpackConfigSpan.traceChild('get-page-paths').traceAsyncFn(()=>Promise.all([\n                    (0, _findpagefile.findPageFile)(this.pagesDir, '/_app', pageExtensions, false),\n                    (0, _findpagefile.findPageFile)(this.pagesDir, '/_document', pageExtensions, false)\n                ]));\n            this.pagesMapping = await webpackConfigSpan.traceChild('create-pages-mapping').traceAsyncFn(()=>(0, _entries.createPagesMapping)({\n                    isDev: true,\n                    pageExtensions: this.config.pageExtensions,\n                    pagesType: _pagetypes.PAGE_TYPES.PAGES,\n                    pagePaths: pagePaths.filter((i)=>typeof i === 'string'),\n                    pagesDir: this.pagesDir,\n                    appDir: this.appDir\n                }));\n            const entrypoints = await webpackConfigSpan.traceChild('create-entrypoints').traceAsyncFn(()=>(0, _entries.createEntrypoints)({\n                    appDir: this.appDir,\n                    buildId: this.buildId,\n                    config: this.config,\n                    envFiles: [],\n                    isDev: true,\n                    pages: this.pagesMapping,\n                    pagesDir: this.pagesDir,\n                    previewMode: this.previewProps,\n                    rootDir: this.dir,\n                    pageExtensions: this.config.pageExtensions\n                }));\n            const commonWebpackOptions = {\n                dev: true,\n                buildId: this.buildId,\n                encryptionKey: this.encryptionKey,\n                config: this.config,\n                pagesDir: this.pagesDir,\n                rewrites: this.rewrites,\n                originalRewrites: this.config._originalRewrites,\n                originalRedirects: this.config._originalRedirects,\n                runWebpackSpan: this.hotReloaderSpan,\n                appDir: this.appDir\n            };\n            return webpackConfigSpan.traceChild('generate-webpack-config').traceAsyncFn(async ()=>{\n                const info = await (0, _webpackconfig.loadProjectInfo)({\n                    dir: this.dir,\n                    config: commonWebpackOptions.config,\n                    dev: true\n                });\n                return Promise.all([\n                    // order is important here\n                    (0, _webpackconfig.default)(this.dir, {\n                        ...commonWebpackOptions,\n                        compilerType: _constants1.COMPILER_NAMES.client,\n                        entrypoints: entrypoints.client,\n                        ...info\n                    }),\n                    (0, _webpackconfig.default)(this.dir, {\n                        ...commonWebpackOptions,\n                        compilerType: _constants1.COMPILER_NAMES.server,\n                        entrypoints: entrypoints.server,\n                        ...info\n                    }),\n                    (0, _webpackconfig.default)(this.dir, {\n                        ...commonWebpackOptions,\n                        compilerType: _constants1.COMPILER_NAMES.edgeServer,\n                        entrypoints: entrypoints.edgeServer,\n                        ...info\n                    })\n                ]);\n            });\n        });\n    }\n    async buildFallbackError() {\n        if (this.fallbackWatcher) return;\n        const info = await (0, _webpackconfig.loadProjectInfo)({\n            dir: this.dir,\n            config: this.config,\n            dev: true\n        });\n        const fallbackConfig = await (0, _webpackconfig.default)(this.dir, {\n            runWebpackSpan: this.hotReloaderSpan,\n            dev: true,\n            compilerType: _constants1.COMPILER_NAMES.client,\n            config: this.config,\n            buildId: this.buildId,\n            encryptionKey: this.encryptionKey,\n            appDir: this.appDir,\n            pagesDir: this.pagesDir,\n            rewrites: {\n                beforeFiles: [],\n                afterFiles: [],\n                fallback: []\n            },\n            originalRewrites: {\n                beforeFiles: [],\n                afterFiles: [],\n                fallback: []\n            },\n            originalRedirects: [],\n            isDevFallback: true,\n            entrypoints: (await (0, _entries.createEntrypoints)({\n                appDir: this.appDir,\n                buildId: this.buildId,\n                config: this.config,\n                envFiles: [],\n                isDev: true,\n                pages: {\n                    '/_app': 'next/dist/pages/_app',\n                    '/_error': 'next/dist/pages/_error'\n                },\n                pagesDir: this.pagesDir,\n                previewMode: this.previewProps,\n                rootDir: this.dir,\n                pageExtensions: this.config.pageExtensions\n            })).client,\n            ...info\n        });\n        const fallbackCompiler = (0, _getwebpackbundler.default)()(fallbackConfig);\n        this.fallbackWatcher = await new Promise((resolve)=>{\n            let bootedFallbackCompiler = false;\n            fallbackCompiler.watch(// @ts-ignore webpack supports an array of watchOptions when using a multiCompiler\n            fallbackConfig.watchOptions, // Errors are handled separately\n            (_err)=>{\n                if (!bootedFallbackCompiler) {\n                    bootedFallbackCompiler = true;\n                    resolve(true);\n                }\n            });\n        });\n    }\n    async tracedGetVersionInfo(span) {\n        const versionInfoSpan = span.traceChild('get-version-info');\n        return versionInfoSpan.traceAsyncFn(async ()=>getVersionInfo());\n    }\n    async start() {\n        const startSpan = this.hotReloaderSpan.traceChild('start');\n        startSpan.stop() // Stop immediately to create an artificial parent span\n        ;\n        this.versionInfo = await this.tracedGetVersionInfo(startSpan);\n        const nodeDebugType = (0, _utils2.getNodeDebugType)();\n        if (nodeDebugType && !this.devtoolsFrontendUrl) {\n            const debugPort = process.debugPort;\n            let debugInfo;\n            try {\n                // It requires to use 127.0.0.1 instead of localhost for server-side fetching.\n                const debugInfoList = await fetch(`http://127.0.0.1:${debugPort}/json/list`).then((res)=>res.json());\n                // There will be only one item for current process, so always get the first item.\n                debugInfo = debugInfoList[0];\n            } catch  {}\n            if (debugInfo) {\n                this.devtoolsFrontendUrl = debugInfo.devtoolsFrontendUrl;\n            }\n        }\n        await this.clean(startSpan);\n        // Ensure distDir exists before writing package.json\n        await _fs.promises.mkdir(this.distDir, {\n            recursive: true\n        });\n        const distPackageJsonPath = (0, _path.join)(this.distDir, 'package.json');\n        // Ensure commonjs handling is used for files in the distDir (generally .next)\n        // Files outside of the distDir can be \"type\": \"module\"\n        await _fs.promises.writeFile(distPackageJsonPath, '{\"type\": \"commonjs\"}');\n        this.activeWebpackConfigs = await this.getWebpackConfig(startSpan);\n        for (const config of this.activeWebpackConfigs){\n            const defaultEntry = config.entry;\n            config.entry = async (...args)=>{\n                var _this_multiCompiler;\n                const outputPath = ((_this_multiCompiler = this.multiCompiler) == null ? void 0 : _this_multiCompiler.outputPath) || '';\n                const entries = (0, _ondemandentryhandler.getEntries)(outputPath);\n                // @ts-ignore entry is always a function\n                const entrypoints = await defaultEntry(...args);\n                const isClientCompilation = config.name === _constants1.COMPILER_NAMES.client;\n                const isNodeServerCompilation = config.name === _constants1.COMPILER_NAMES.server;\n                const isEdgeServerCompilation = config.name === _constants1.COMPILER_NAMES.edgeServer;\n                await Promise.all(Object.keys(entries).map(async (entryKey)=>{\n                    const entryData = entries[entryKey];\n                    const { bundlePath, dispose } = entryData;\n                    const result = /^(client|server|edge-server)@(app|pages|root)@(.*)/g.exec(entryKey);\n                    const [, key /* pageType */ , , page] = result// this match should always happen\n                    ;\n                    if (key === _constants1.COMPILER_NAMES.client && !isClientCompilation) return;\n                    if (key === _constants1.COMPILER_NAMES.server && !isNodeServerCompilation) return;\n                    if (key === _constants1.COMPILER_NAMES.edgeServer && !isEdgeServerCompilation) return;\n                    const isEntry = entryData.type === _ondemandentryhandler.EntryTypes.ENTRY;\n                    const isChildEntry = entryData.type === _ondemandentryhandler.EntryTypes.CHILD_ENTRY;\n                    // Check if the page was removed or disposed and remove it\n                    if (isEntry) {\n                        const pageExists = !dispose && (0, _fs.existsSync)(entryData.absolutePagePath);\n                        if (!pageExists) {\n                            delete entries[entryKey];\n                            return;\n                        }\n                    }\n                    // For child entries, if it has an entry file and it's gone, remove it\n                    if (isChildEntry) {\n                        if (entryData.absoluteEntryFilePath) {\n                            const pageExists = !dispose && (0, _fs.existsSync)(entryData.absoluteEntryFilePath);\n                            if (!pageExists) {\n                                delete entries[entryKey];\n                                return;\n                            }\n                        }\n                    }\n                    // Ensure _error is considered a `pages` page.\n                    if (page === '/_error') {\n                        this.hasPagesRouterEntrypoints = true;\n                    }\n                    const hasAppDir = !!this.appDir;\n                    const isAppPath = hasAppDir && bundlePath.startsWith('app/');\n                    const staticInfo = isEntry ? await (0, _entries.getStaticInfoIncludingLayouts)({\n                        isInsideAppDir: isAppPath,\n                        pageExtensions: this.config.pageExtensions,\n                        pageFilePath: entryData.absolutePagePath,\n                        appDir: this.appDir,\n                        config: this.config,\n                        isDev: true,\n                        page\n                    }) : undefined;\n                    if ((staticInfo == null ? void 0 : staticInfo.type) === _pagetypes.PAGE_TYPES.PAGES) {\n                        var _staticInfo_config_config, _staticInfo_config, _staticInfo_config_config1, _staticInfo_config1;\n                        if (((_staticInfo_config = staticInfo.config) == null ? void 0 : (_staticInfo_config_config = _staticInfo_config.config) == null ? void 0 : _staticInfo_config_config.amp) === true || ((_staticInfo_config1 = staticInfo.config) == null ? void 0 : (_staticInfo_config_config1 = _staticInfo_config1.config) == null ? void 0 : _staticInfo_config_config1.amp) === 'hybrid') {\n                            this.hasAmpEntrypoints = true;\n                        }\n                    }\n                    const isServerComponent = isAppPath && (staticInfo == null ? void 0 : staticInfo.rsc) !== _constants1.RSC_MODULE_TYPES.client;\n                    const pageType = entryData.bundlePath.startsWith('pages/') ? _pagetypes.PAGE_TYPES.PAGES : entryData.bundlePath.startsWith('app/') ? _pagetypes.PAGE_TYPES.APP : _pagetypes.PAGE_TYPES.ROOT;\n                    if (pageType === 'pages') {\n                        this.hasPagesRouterEntrypoints = true;\n                    }\n                    if (pageType === 'app') {\n                        this.hasAppRouterEntrypoints = true;\n                    }\n                    const isInstrumentation = (0, _utils.isInstrumentationHookFile)(page) && pageType === _pagetypes.PAGE_TYPES.ROOT;\n                    let pageRuntime = staticInfo == null ? void 0 : staticInfo.runtime;\n                    if ((0, _utils.isMiddlewareFile)(page) && !this.config.experimental.nodeMiddleware && pageRuntime === 'nodejs') {\n                        _log.warn('nodejs runtime support for middleware requires experimental.nodeMiddleware be enabled in your next.config');\n                        pageRuntime = 'edge';\n                    }\n                    (0, _entries.runDependingOnPageType)({\n                        page,\n                        pageRuntime,\n                        pageType,\n                        onEdgeServer: ()=>{\n                            // TODO-APP: verify if child entry should support.\n                            if (!isEdgeServerCompilation || !isEntry) return;\n                            entries[entryKey].status = _ondemandentryhandler.BUILDING;\n                            if (isInstrumentation) {\n                                const normalizedBundlePath = bundlePath.replace('src/', '');\n                                entrypoints[normalizedBundlePath] = (0, _entries.finalizeEntrypoint)({\n                                    compilerType: _constants1.COMPILER_NAMES.edgeServer,\n                                    name: normalizedBundlePath,\n                                    value: (0, _entries.getInstrumentationEntry)({\n                                        absolutePagePath: entryData.absolutePagePath,\n                                        isEdgeServer: true,\n                                        isDev: true\n                                    }),\n                                    isServerComponent: true,\n                                    hasAppDir\n                                });\n                                return;\n                            }\n                            const appDirLoader = isAppPath ? (0, _entries.getAppEntry)({\n                                name: bundlePath,\n                                page,\n                                appPaths: entryData.appPaths,\n                                pagePath: _path.posix.join(_constants.APP_DIR_ALIAS, (0, _path.relative)(this.appDir, entryData.absolutePagePath).replace(/\\\\/g, '/')),\n                                appDir: this.appDir,\n                                pageExtensions: this.config.pageExtensions,\n                                rootDir: this.dir,\n                                isDev: true,\n                                tsconfigPath: this.config.typescript.tsconfigPath,\n                                basePath: this.config.basePath,\n                                assetPrefix: this.config.assetPrefix,\n                                nextConfigOutput: this.config.output,\n                                preferredRegion: staticInfo == null ? void 0 : staticInfo.preferredRegion,\n                                middlewareConfig: Buffer.from(JSON.stringify((staticInfo == null ? void 0 : staticInfo.middleware) || {})).toString('base64')\n                            }).import : undefined;\n                            entrypoints[bundlePath] = (0, _entries.finalizeEntrypoint)({\n                                compilerType: _constants1.COMPILER_NAMES.edgeServer,\n                                name: bundlePath,\n                                value: (0, _entries.getEdgeServerEntry)({\n                                    absolutePagePath: entryData.absolutePagePath,\n                                    rootDir: this.dir,\n                                    buildId: this.buildId,\n                                    bundlePath,\n                                    config: this.config,\n                                    isDev: true,\n                                    page,\n                                    pages: this.pagesMapping,\n                                    isServerComponent,\n                                    appDirLoader,\n                                    pagesType: isAppPath ? _pagetypes.PAGE_TYPES.APP : _pagetypes.PAGE_TYPES.PAGES,\n                                    preferredRegion: staticInfo == null ? void 0 : staticInfo.preferredRegion\n                                }),\n                                hasAppDir\n                            });\n                        },\n                        onClient: ()=>{\n                            if (!isClientCompilation) return;\n                            if (isChildEntry) {\n                                entries[entryKey].status = _ondemandentryhandler.BUILDING;\n                                entrypoints[bundlePath] = (0, _entries.finalizeEntrypoint)({\n                                    name: bundlePath,\n                                    compilerType: _constants1.COMPILER_NAMES.client,\n                                    value: entryData.request,\n                                    hasAppDir\n                                });\n                            } else {\n                                entries[entryKey].status = _ondemandentryhandler.BUILDING;\n                                entrypoints[bundlePath] = (0, _entries.finalizeEntrypoint)({\n                                    name: bundlePath,\n                                    compilerType: _constants1.COMPILER_NAMES.client,\n                                    value: (0, _entries.getClientEntry)({\n                                        absolutePagePath: entryData.absolutePagePath,\n                                        page\n                                    }),\n                                    hasAppDir\n                                });\n                            }\n                        },\n                        onServer: ()=>{\n                            // TODO-APP: verify if child entry should support.\n                            if (!isNodeServerCompilation || !isEntry) return;\n                            entries[entryKey].status = _ondemandentryhandler.BUILDING;\n                            let relativeRequest = (0, _path.relative)(config.context, entryData.absolutePagePath);\n                            if (!(0, _path.isAbsolute)(relativeRequest) && !relativeRequest.startsWith('../')) {\n                                relativeRequest = `./${relativeRequest}`;\n                            }\n                            let value;\n                            if (isInstrumentation) {\n                                value = (0, _entries.getInstrumentationEntry)({\n                                    absolutePagePath: entryData.absolutePagePath,\n                                    isEdgeServer: false,\n                                    isDev: true\n                                });\n                                entrypoints[bundlePath] = (0, _entries.finalizeEntrypoint)({\n                                    compilerType: _constants1.COMPILER_NAMES.server,\n                                    name: bundlePath,\n                                    isServerComponent: true,\n                                    value,\n                                    hasAppDir\n                                });\n                            } else if ((0, _utils.isMiddlewareFile)(page)) {\n                                value = (0, _entries.getEdgeServerEntry)({\n                                    absolutePagePath: entryData.absolutePagePath,\n                                    rootDir: this.dir,\n                                    buildId: this.buildId,\n                                    bundlePath,\n                                    config: this.config,\n                                    isDev: true,\n                                    page,\n                                    pages: this.pagesMapping,\n                                    isServerComponent,\n                                    pagesType: _pagetypes.PAGE_TYPES.PAGES,\n                                    preferredRegion: staticInfo == null ? void 0 : staticInfo.preferredRegion\n                                });\n                            } else if (isAppPath) {\n                                value = (0, _entries.getAppEntry)({\n                                    name: bundlePath,\n                                    page,\n                                    appPaths: entryData.appPaths,\n                                    pagePath: _path.posix.join(_constants.APP_DIR_ALIAS, (0, _path.relative)(this.appDir, entryData.absolutePagePath).replace(/\\\\/g, '/')),\n                                    appDir: this.appDir,\n                                    pageExtensions: this.config.pageExtensions,\n                                    rootDir: this.dir,\n                                    isDev: true,\n                                    tsconfigPath: this.config.typescript.tsconfigPath,\n                                    basePath: this.config.basePath,\n                                    assetPrefix: this.config.assetPrefix,\n                                    nextConfigOutput: this.config.output,\n                                    preferredRegion: staticInfo == null ? void 0 : staticInfo.preferredRegion,\n                                    middlewareConfig: Buffer.from(JSON.stringify((staticInfo == null ? void 0 : staticInfo.middleware) || {})).toString('base64')\n                                });\n                            } else if ((0, _isapiroute.isAPIRoute)(page)) {\n                                value = (0, _nextrouteloader.getRouteLoaderEntry)({\n                                    kind: _routekind.RouteKind.PAGES_API,\n                                    page,\n                                    absolutePagePath: relativeRequest,\n                                    preferredRegion: staticInfo == null ? void 0 : staticInfo.preferredRegion,\n                                    middlewareConfig: (staticInfo == null ? void 0 : staticInfo.middleware) || {}\n                                });\n                            } else if (!(0, _utils.isMiddlewareFile)(page) && !(0, _isinternalcomponent.isInternalComponent)(relativeRequest) && !(0, _isinternalcomponent.isNonRoutePagesPage)(page) && !isInstrumentation) {\n                                value = (0, _nextrouteloader.getRouteLoaderEntry)({\n                                    kind: _routekind.RouteKind.PAGES,\n                                    page,\n                                    pages: this.pagesMapping,\n                                    absolutePagePath: relativeRequest,\n                                    preferredRegion: staticInfo == null ? void 0 : staticInfo.preferredRegion,\n                                    middlewareConfig: (staticInfo == null ? void 0 : staticInfo.middleware) ?? {}\n                                });\n                            } else {\n                                value = relativeRequest;\n                            }\n                            entrypoints[bundlePath] = (0, _entries.finalizeEntrypoint)({\n                                compilerType: _constants1.COMPILER_NAMES.server,\n                                name: bundlePath,\n                                isServerComponent,\n                                value,\n                                hasAppDir\n                            });\n                        }\n                    });\n                }));\n                if (!this.hasAmpEntrypoints) {\n                    delete entrypoints[_constants1.CLIENT_STATIC_FILES_RUNTIME_AMP];\n                }\n                if (!this.hasPagesRouterEntrypoints) {\n                    delete entrypoints[_constants1.CLIENT_STATIC_FILES_RUNTIME_MAIN];\n                    delete entrypoints['pages/_app'];\n                    delete entrypoints['pages/_error'];\n                    delete entrypoints['/_error'];\n                    delete entrypoints['pages/_document'];\n                }\n                // Remove React Refresh entrypoint chunk as `app` doesn't require it.\n                if (!this.hasAmpEntrypoints && !this.hasPagesRouterEntrypoints) {\n                    delete entrypoints[_constants1.CLIENT_STATIC_FILES_RUNTIME_REACT_REFRESH];\n                }\n                if (!this.hasAppRouterEntrypoints) {\n                    delete entrypoints[_constants1.CLIENT_STATIC_FILES_RUNTIME_MAIN_APP];\n                }\n                return entrypoints;\n            };\n        }\n        // Enable building of client compilation before server compilation in development\n        // @ts-ignore webpack 5\n        this.activeWebpackConfigs.parallelism = 1;\n        this.multiCompiler = (0, _getwebpackbundler.default)()(this.activeWebpackConfigs);\n        // Copy over the filesystem so that it is shared between all compilers.\n        const inputFileSystem = this.multiCompiler.compilers[0].inputFileSystem;\n        for (const compiler of this.multiCompiler.compilers){\n            compiler.inputFileSystem = inputFileSystem;\n            // This is set for the initial compile. After that Watching class in webpack adds it.\n            compiler.fsStartTime = Date.now();\n            // Ensure NodeEnvironmentPlugin doesn't purge the inputFileSystem. Purging is handled in `done` below.\n            compiler.hooks.beforeRun.intercept({\n                register (tapInfo) {\n                    if (tapInfo.name === 'NodeEnvironmentPlugin') {\n                        return null;\n                    }\n                    return tapInfo;\n                }\n            });\n        }\n        this.multiCompiler.hooks.done.tap('NextjsHotReloader', ()=>{\n            var _inputFileSystem_purge;\n            inputFileSystem == null ? void 0 : (_inputFileSystem_purge = inputFileSystem.purge) == null ? void 0 : _inputFileSystem_purge.call(inputFileSystem);\n        });\n        (0, _output.watchCompilers)(this.multiCompiler.compilers[0], this.multiCompiler.compilers[1], this.multiCompiler.compilers[2]);\n        // Watch for changes to client/server page files so we can tell when just\n        // the server file changes and trigger a reload for GS(S)P pages\n        const changedClientPages = new Set();\n        const changedServerPages = new Set();\n        const changedEdgeServerPages = new Set();\n        const changedServerComponentPages = new Set();\n        const changedCSSImportPages = new Set();\n        const prevClientPageHashes = new Map();\n        const prevServerPageHashes = new Map();\n        const prevEdgeServerPageHashes = new Map();\n        const prevCSSImportModuleHashes = new Map();\n        const pageExtensionRegex = new RegExp(`\\\\.(?:${this.config.pageExtensions.join('|')})$`);\n        const trackPageChanges = (pageHashMap, changedItems, serverComponentChangedItems)=>(stats)=>{\n                try {\n                    stats.entrypoints.forEach((entry, key)=>{\n                        if (key.startsWith('pages/') || key.startsWith('app/') || (0, _utils.isMiddlewareFilename)(key)) {\n                            // TODO this doesn't handle on demand loaded chunks\n                            entry.chunks.forEach((chunk)=>{\n                                if (chunk.id === key) {\n                                    const modsIterable = stats.chunkGraph.getChunkModulesIterable(chunk);\n                                    let hasCSSModuleChanges = false;\n                                    let chunksHash = new _webpack.StringXor();\n                                    let chunksHashServerLayer = new _webpack.StringXor();\n                                    modsIterable.forEach((mod)=>{\n                                        if (mod.resource && mod.resource.replace(/\\\\/g, '/').includes(key) && // Shouldn't match CSS modules, etc.\n                                        pageExtensionRegex.test(mod.resource)) {\n                                            var _mod_buildInfo_rsc, _mod_buildInfo;\n                                            // use original source to calculate hash since mod.hash\n                                            // includes the source map in development which changes\n                                            // every time for both server and client so we calculate\n                                            // the hash without the source map for the page module\n                                            const hash = require('crypto').createHash('sha1').update(mod.originalSource().buffer()).digest().toString('hex');\n                                            if (mod.layer === _constants.WEBPACK_LAYERS.reactServerComponents && (mod == null ? void 0 : (_mod_buildInfo = mod.buildInfo) == null ? void 0 : (_mod_buildInfo_rsc = _mod_buildInfo.rsc) == null ? void 0 : _mod_buildInfo_rsc.type) !== 'client') {\n                                                chunksHashServerLayer.add(hash);\n                                            }\n                                            chunksHash.add(hash);\n                                        } else {\n                                            var _mod_buildInfo_rsc1, _mod_buildInfo1;\n                                            // for non-pages we can use the module hash directly\n                                            const hash = stats.chunkGraph.getModuleHash(mod, chunk.runtime);\n                                            if (mod.layer === _constants.WEBPACK_LAYERS.reactServerComponents && (mod == null ? void 0 : (_mod_buildInfo1 = mod.buildInfo) == null ? void 0 : (_mod_buildInfo_rsc1 = _mod_buildInfo1.rsc) == null ? void 0 : _mod_buildInfo_rsc1.type) !== 'client') {\n                                                chunksHashServerLayer.add(hash);\n                                            }\n                                            chunksHash.add(hash);\n                                            // Both CSS import changes from server and client\n                                            // components are tracked.\n                                            if (key.startsWith('app/') && /\\.(css|scss|sass)$/.test(mod.resource || '')) {\n                                                const resourceKey = mod.layer + ':' + mod.resource;\n                                                const prevHash = prevCSSImportModuleHashes.get(resourceKey);\n                                                if (prevHash && prevHash !== hash) {\n                                                    hasCSSModuleChanges = true;\n                                                }\n                                                prevCSSImportModuleHashes.set(resourceKey, hash);\n                                            }\n                                        }\n                                    });\n                                    const prevHash = pageHashMap.get(key);\n                                    const curHash = chunksHash.toString();\n                                    if (prevHash && prevHash !== curHash) {\n                                        changedItems.add(key);\n                                    }\n                                    pageHashMap.set(key, curHash);\n                                    if (serverComponentChangedItems) {\n                                        const serverKey = _constants.WEBPACK_LAYERS.reactServerComponents + ':' + key;\n                                        const prevServerHash = pageHashMap.get(serverKey);\n                                        const curServerHash = chunksHashServerLayer.toString();\n                                        if (prevServerHash && prevServerHash !== curServerHash) {\n                                            serverComponentChangedItems.add(key);\n                                        }\n                                        pageHashMap.set(serverKey, curServerHash);\n                                    }\n                                    if (hasCSSModuleChanges) {\n                                        changedCSSImportPages.add(key);\n                                    }\n                                }\n                            });\n                        }\n                    });\n                } catch (err) {\n                    console.error(err);\n                }\n            };\n        this.multiCompiler.compilers[0].hooks.emit.tap('NextjsHotReloaderForClient', trackPageChanges(prevClientPageHashes, changedClientPages));\n        this.multiCompiler.compilers[1].hooks.emit.tap('NextjsHotReloaderForServer', trackPageChanges(prevServerPageHashes, changedServerPages, changedServerComponentPages));\n        this.multiCompiler.compilers[2].hooks.emit.tap('NextjsHotReloaderForServer', trackPageChanges(prevEdgeServerPageHashes, changedEdgeServerPages, changedServerComponentPages));\n        // This plugin watches for changes to _document.js and notifies the client side that it should reload the page\n        this.multiCompiler.compilers[1].hooks.failed.tap('NextjsHotReloaderForServer', (err)=>{\n            this.serverError = err;\n            this.serverStats = null;\n            this.serverChunkNames = undefined;\n        });\n        this.multiCompiler.compilers[2].hooks.done.tap('NextjsHotReloaderForServer', (stats)=>{\n            this.serverError = null;\n            this.edgeServerStats = stats;\n        });\n        this.multiCompiler.compilers[1].hooks.done.tap('NextjsHotReloaderForServer', (stats)=>{\n            this.serverError = null;\n            this.serverStats = stats;\n            if (!this.pagesDir) {\n                return;\n            }\n            const { compilation } = stats;\n            // We only watch `_document` for changes on the server compilation\n            // the rest of the files will be triggered by the client compilation\n            const documentChunk = compilation.namedChunks.get('pages/_document');\n            // If the document chunk can't be found we do nothing\n            if (!documentChunk) {\n                return;\n            }\n            // Initial value\n            if (this.serverPrevDocumentHash === null) {\n                this.serverPrevDocumentHash = documentChunk.hash || null;\n                return;\n            }\n            // If _document.js didn't change we don't trigger a reload.\n            if (documentChunk.hash === this.serverPrevDocumentHash) {\n                return;\n            }\n            // As document chunk will change if new app pages are joined,\n            // since react bundle is different it will effect the chunk hash.\n            // So we diff the chunk changes, if there's only new app page chunk joins,\n            // then we don't trigger a reload by checking pages/_document chunk change.\n            if (this.appDir) {\n                const chunkNames = new Set(compilation.namedChunks.keys());\n                const diffChunkNames = (0, _utils.difference)(this.serverChunkNames || new Set(), chunkNames);\n                if (diffChunkNames.length === 0 || diffChunkNames.every((chunkName)=>chunkName.startsWith('app/'))) {\n                    return;\n                }\n                this.serverChunkNames = chunkNames;\n            }\n            this.serverPrevDocumentHash = documentChunk.hash || null;\n            // Notify reload to reload the page, as _document.js was changed (different hash)\n            this.send({\n                action: _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.RELOAD_PAGE,\n                data: '_document has changed'\n            });\n        });\n        this.multiCompiler.hooks.done.tap('NextjsHotReloaderForServer', (stats)=>{\n            const reloadAfterInvalidation = this.reloadAfterInvalidation;\n            this.reloadAfterInvalidation = false;\n            const serverOnlyChanges = (0, _utils.difference)(changedServerPages, changedClientPages);\n            const edgeServerOnlyChanges = (0, _utils.difference)(changedEdgeServerPages, changedClientPages);\n            const pageChanges = serverOnlyChanges.concat(edgeServerOnlyChanges).filter((key)=>key.startsWith('pages/'));\n            const middlewareChanges = [\n                ...Array.from(changedEdgeServerPages),\n                ...Array.from(changedServerPages)\n            ].filter((name)=>(0, _utils.isMiddlewareFilename)(name));\n            if (middlewareChanges.length > 0) {\n                this.send({\n                    event: _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.MIDDLEWARE_CHANGES\n                });\n            }\n            if (pageChanges.length > 0) {\n                this.send({\n                    event: _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.SERVER_ONLY_CHANGES,\n                    pages: serverOnlyChanges.map((pg)=>(0, _denormalizepagepath.denormalizePagePath)(pg.slice('pages'.length)))\n                });\n            }\n            if (changedServerComponentPages.size || changedCSSImportPages.size || reloadAfterInvalidation) {\n                this.resetFetch();\n                this.refreshServerComponents(stats.hash);\n            }\n            changedClientPages.clear();\n            changedServerPages.clear();\n            changedEdgeServerPages.clear();\n            changedServerComponentPages.clear();\n            changedCSSImportPages.clear();\n        });\n        this.multiCompiler.compilers[0].hooks.failed.tap('NextjsHotReloaderForClient', (err)=>{\n            this.clientError = err;\n            this.clientStats = null;\n        });\n        this.multiCompiler.compilers[0].hooks.done.tap('NextjsHotReloaderForClient', (stats)=>{\n            this.clientError = null;\n            this.clientStats = stats;\n            const { compilation } = stats;\n            const chunkNames = new Set([\n                ...compilation.namedChunks.keys()\n            ].filter((name)=>!!(0, _getroutefromentrypoint.default)(name)));\n            if (this.prevChunkNames) {\n                // detect chunks which have to be replaced with a new template\n                // e.g, pages/index.js <-> pages/_error.js\n                const addedPages = diff(chunkNames, this.prevChunkNames);\n                const removedPages = diff(this.prevChunkNames, chunkNames);\n                if (addedPages.size > 0) {\n                    for (const addedPage of addedPages){\n                        const page = (0, _getroutefromentrypoint.default)(addedPage);\n                        this.send({\n                            action: _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.ADDED_PAGE,\n                            data: [\n                                page\n                            ]\n                        });\n                    }\n                }\n                if (removedPages.size > 0) {\n                    for (const removedPage of removedPages){\n                        const page = (0, _getroutefromentrypoint.default)(removedPage);\n                        this.send({\n                            action: _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.REMOVED_PAGE,\n                            data: [\n                                page\n                            ]\n                        });\n                    }\n                }\n            }\n            this.prevChunkNames = chunkNames;\n        });\n        this.webpackHotMiddleware = new _hotmiddleware.WebpackHotMiddleware(this.multiCompiler.compilers, this.versionInfo, this.devtoolsFrontendUrl);\n        let booted = false;\n        this.watcher = await new Promise((resolve)=>{\n            var _this_multiCompiler;\n            const watcher = (_this_multiCompiler = this.multiCompiler) == null ? void 0 : _this_multiCompiler.watch(// @ts-ignore webpack supports an array of watchOptions when using a multiCompiler\n            this.activeWebpackConfigs.map((config)=>config.watchOptions), // Errors are handled separately\n            (_err)=>{\n                if (!booted) {\n                    booted = true;\n                    resolve(watcher);\n                }\n            });\n        });\n        this.onDemandEntries = (0, _ondemandentryhandler.onDemandEntryHandler)({\n            hotReloader: this,\n            multiCompiler: this.multiCompiler,\n            pagesDir: this.pagesDir,\n            appDir: this.appDir,\n            rootDir: this.dir,\n            nextConfig: this.config,\n            ...this.config.onDemandEntries\n        });\n        this.middlewares = [\n            (0, _middlewarewebpack.getOverlayMiddleware)({\n                rootDirectory: this.dir,\n                clientStats: ()=>this.clientStats,\n                serverStats: ()=>this.serverStats,\n                edgeServerStats: ()=>this.edgeServerStats\n            }),\n            (0, _middlewarewebpack.getSourceMapMiddleware)({\n                clientStats: ()=>this.clientStats,\n                serverStats: ()=>this.serverStats,\n                edgeServerStats: ()=>this.edgeServerStats\n            }),\n            (0, _getnexterrorfeedbackmiddleware.getNextErrorFeedbackMiddleware)(this.telemetry),\n            (0, _getdevoverlayfontmiddleware.getDevOverlayFontMiddleware)(),\n            (0, _devindicatormiddleware.getDisableDevIndicatorMiddleware)()\n        ];\n    }\n    invalidate({ reloadAfterInvalidation } = {\n        reloadAfterInvalidation: false\n    }) {\n        var _this_multiCompiler;\n        // Cache the `reloadAfterInvalidation` flag, and use it to reload the page when compilation is done\n        this.reloadAfterInvalidation = reloadAfterInvalidation;\n        const outputPath = (_this_multiCompiler = this.multiCompiler) == null ? void 0 : _this_multiCompiler.outputPath;\n        if (outputPath) {\n            var _getInvalidator;\n            (_getInvalidator = (0, _ondemandentryhandler.getInvalidator)(outputPath)) == null ? void 0 : _getInvalidator.invalidate();\n        }\n    }\n    async getCompilationErrors(page) {\n        var _this_clientStats, _this_serverStats, _this_edgeServerStats;\n        const getErrors = ({ compilation })=>{\n            var _failedPages_normalizedPage;\n            const failedPages = erroredPages(compilation);\n            const normalizedPage = (0, _normalizepathsep.normalizePathSep)(page);\n            // If there is an error related to the requesting page we display it instead of the first error\n            return ((_failedPages_normalizedPage = failedPages[normalizedPage]) == null ? void 0 : _failedPages_normalizedPage.length) > 0 ? failedPages[normalizedPage] : compilation.errors;\n        };\n        if (this.clientError) {\n            return [\n                this.clientError\n            ];\n        } else if (this.serverError) {\n            return [\n                this.serverError\n            ];\n        } else if ((_this_clientStats = this.clientStats) == null ? void 0 : _this_clientStats.hasErrors()) {\n            return getErrors(this.clientStats);\n        } else if ((_this_serverStats = this.serverStats) == null ? void 0 : _this_serverStats.hasErrors()) {\n            return getErrors(this.serverStats);\n        } else if ((_this_edgeServerStats = this.edgeServerStats) == null ? void 0 : _this_edgeServerStats.hasErrors()) {\n            return getErrors(this.edgeServerStats);\n        } else {\n            return [];\n        }\n    }\n    send(action) {\n        this.webpackHotMiddleware.publish(action);\n    }\n    async ensurePage({ page, clientOnly, appPaths, definition, isApp, url }) {\n        return this.hotReloaderSpan.traceChild('ensure-page', {\n            inputPage: page\n        }).traceAsyncFn(async ()=>{\n            var _this_onDemandEntries;\n            // Make sure we don't re-build or dispose prebuilt pages\n            if (page !== '/_error' && _constants1.BLOCKED_PAGES.indexOf(page) !== -1) {\n                return;\n            }\n            const error = clientOnly ? this.clientError : this.serverError || this.clientError;\n            if (error) {\n                throw error;\n            }\n            return (_this_onDemandEntries = this.onDemandEntries) == null ? void 0 : _this_onDemandEntries.ensurePage({\n                page,\n                appPaths,\n                definition,\n                isApp,\n                url\n            });\n        });\n    }\n    close() {\n        var _this_webpackHotMiddleware;\n        (_this_webpackHotMiddleware = this.webpackHotMiddleware) == null ? void 0 : _this_webpackHotMiddleware.close();\n    }\n}\n\n//# sourceMappingURL=hot-reloader-webpack.js.map"
        }
    ]
}