{
    "sourceFile": "node_modules/next/dist/server/response-cache/types.d.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892882821,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import type { OutgoingHttpHeaders } from 'http';\nimport type RenderResult from '../render-result';\nimport type { CacheControl, Revalidate } from '../lib/cache-control';\nimport type { RouteKind } from '../route-kind';\nexport interface ResponseCacheBase {\n    get(key: string | null, responseGenerator: ResponseGenerator, context: {\n        isOnDemandRevalidate?: boolean;\n        isPrefetch?: boolean;\n        incrementalCache: IncrementalCache;\n        /**\n         * This is a hint to the cache to help it determine what kind of route\n         * this is so it knows where to look up the cache entry from. If not\n         * provided it will test the filesystem to check.\n         */\n        routeKind: RouteKind;\n        /**\n         * True if this is a fallback request.\n         */\n        isFallback?: boolean;\n        /**\n         * True if the route is enabled for PPR.\n         */\n        isRoutePPREnabled?: boolean;\n    }): Promise<ResponseCacheEntry | null>;\n}\nexport interface ServerComponentsHmrCache {\n    get(key: string): CachedFetchData | undefined;\n    set(key: string, data: CachedFetchData): void;\n}\nexport type CachedFetchData = {\n    headers: Record<string, string>;\n    body: string;\n    url: string;\n    status?: number;\n};\nexport declare const enum CachedRouteKind {\n    APP_PAGE = \"APP_PAGE\",\n    APP_ROUTE = \"APP_ROUTE\",\n    PAGES = \"PAGES\",\n    FETCH = \"FETCH\",\n    REDIRECT = \"REDIRECT\",\n    IMAGE = \"IMAGE\"\n}\nexport interface CachedFetchValue {\n    kind: CachedRouteKind.FETCH;\n    data: CachedFetchData;\n    tags?: string[];\n    revalidate: number;\n}\nexport interface CachedRedirectValue {\n    kind: CachedRouteKind.REDIRECT;\n    props: Object;\n}\nexport interface CachedAppPageValue {\n    kind: CachedRouteKind.APP_PAGE;\n    html: RenderResult;\n    rscData: Buffer | undefined;\n    status: number | undefined;\n    postponed: string | undefined;\n    headers: OutgoingHttpHeaders | undefined;\n    segmentData: Map<string, Buffer> | undefined;\n}\nexport interface CachedPageValue {\n    kind: CachedRouteKind.PAGES;\n    html: RenderResult;\n    pageData: Object;\n    status: number | undefined;\n    headers: OutgoingHttpHeaders | undefined;\n}\nexport interface CachedRouteValue {\n    kind: CachedRouteKind.APP_ROUTE;\n    body: Buffer;\n    status: number;\n    headers: OutgoingHttpHeaders;\n}\nexport interface CachedImageValue {\n    kind: CachedRouteKind.IMAGE;\n    etag: string;\n    upstreamEtag: string;\n    buffer: Buffer;\n    extension: string;\n    isMiss?: boolean;\n    isStale?: boolean;\n}\nexport interface IncrementalCachedAppPageValue {\n    kind: CachedRouteKind.APP_PAGE;\n    html: string;\n    rscData: Buffer | undefined;\n    headers: OutgoingHttpHeaders | undefined;\n    postponed: string | undefined;\n    status: number | undefined;\n    segmentData: Map<string, Buffer> | undefined;\n}\nexport interface IncrementalCachedPageValue {\n    kind: CachedRouteKind.PAGES;\n    html: string;\n    pageData: Object;\n    headers: OutgoingHttpHeaders | undefined;\n    status: number | undefined;\n}\nexport interface IncrementalResponseCacheEntry {\n    cacheControl?: CacheControl;\n    /**\n     * timestamp in milliseconds to revalidate after\n     */\n    revalidateAfter?: Revalidate;\n    /**\n     * `-1` here dictates a blocking revalidate should be used\n     */\n    isStale?: boolean | -1;\n    isMiss?: boolean;\n    isFallback: boolean | undefined;\n    value: Exclude<IncrementalCacheValue, CachedFetchValue> | null;\n}\nexport interface IncrementalFetchCacheEntry {\n    /**\n     * `-1` here dictates a blocking revalidate should be used\n     */\n    isStale?: boolean | -1;\n    value: CachedFetchValue;\n}\nexport type IncrementalCacheEntry = IncrementalResponseCacheEntry | IncrementalFetchCacheEntry;\nexport type IncrementalCacheValue = CachedRedirectValue | IncrementalCachedPageValue | IncrementalCachedAppPageValue | CachedImageValue | CachedFetchValue | CachedRouteValue;\nexport type ResponseCacheValue = CachedRedirectValue | CachedPageValue | CachedAppPageValue | CachedImageValue | CachedRouteValue;\nexport type ResponseCacheEntry = {\n    cacheControl?: CacheControl;\n    value: ResponseCacheValue | null;\n    isStale?: boolean | -1;\n    isMiss?: boolean;\n    isFallback: boolean | undefined;\n};\n/**\n * @param hasResolved whether the responseGenerator has resolved it's promise\n * @param previousCacheEntry the previous cache entry if it exists or the current\n */\nexport type ResponseGenerator = (state: {\n    hasResolved: boolean;\n    previousCacheEntry?: IncrementalResponseCacheEntry | null;\n    isRevalidating?: boolean;\n}) => Promise<ResponseCacheEntry | null>;\nexport declare const enum IncrementalCacheKind {\n    APP_PAGE = \"APP_PAGE\",\n    APP_ROUTE = \"APP_ROUTE\",\n    PAGES = \"PAGES\",\n    FETCH = \"FETCH\",\n    IMAGE = \"IMAGE\"\n}\nexport interface GetIncrementalFetchCacheContext {\n    kind: IncrementalCacheKind.FETCH;\n    revalidate?: Revalidate;\n    fetchUrl?: string;\n    fetchIdx?: number;\n    tags?: string[];\n    softTags?: string[];\n}\nexport interface GetIncrementalResponseCacheContext {\n    kind: Exclude<IncrementalCacheKind, IncrementalCacheKind.FETCH>;\n    /**\n     * True if the route is enabled for PPR.\n     */\n    isRoutePPREnabled?: boolean;\n    /**\n     * True if this is a fallback request.\n     */\n    isFallback: boolean;\n}\nexport interface SetIncrementalFetchCacheContext {\n    fetchCache: true;\n    fetchUrl?: string;\n    fetchIdx?: number;\n    tags?: string[];\n}\nexport interface SetIncrementalResponseCacheContext {\n    fetchCache?: false;\n    cacheControl?: CacheControl;\n    /**\n     * True if the route is enabled for PPR.\n     */\n    isRoutePPREnabled?: boolean;\n    /**\n     * True if this is a fallback request.\n     */\n    isFallback?: boolean;\n}\nexport interface IncrementalResponseCache {\n    get(cacheKey: string, ctx: GetIncrementalResponseCacheContext): Promise<IncrementalResponseCacheEntry | null>;\n    set(key: string, data: Exclude<IncrementalCacheValue, CachedFetchValue> | null, ctx: SetIncrementalResponseCacheContext): Promise<void>;\n}\nexport interface IncrementalCache extends IncrementalResponseCache {\n    get(cacheKey: string, ctx: GetIncrementalFetchCacheContext): Promise<IncrementalFetchCacheEntry | null>;\n    get(cacheKey: string, ctx: GetIncrementalResponseCacheContext): Promise<IncrementalResponseCacheEntry | null>;\n    set(key: string, data: CachedFetchValue | null, ctx: SetIncrementalFetchCacheContext): Promise<void>;\n    set(key: string, data: Exclude<IncrementalCacheValue, CachedFetchValue> | null, ctx: SetIncrementalResponseCacheContext): Promise<void>;\n}\n"
        }
    ]
}