{
    "sourceFile": "node_modules/next/dist/server/image-optimizer.d.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892874044,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import type { IncomingMessage, ServerResponse } from 'http';\nimport { type UrlWithParsedQuery } from 'url';\nimport type { ImageConfigComplete } from '../shared/lib/image-config';\nimport type { NextConfigComplete } from './config-shared';\nimport type { NextUrlWithParsedQuery } from './request-meta';\nimport { type CachedImageValue, type IncrementalCacheEntry, type IncrementalCacheValue, type IncrementalResponseCacheEntry } from './response-cache';\nimport type { CacheControl } from './lib/cache-control';\ntype XCacheHeader = 'MISS' | 'HIT' | 'STALE';\nexport declare function getSharp(concurrency: number | null | undefined): typeof import(\"sharp\");\nexport interface ImageParamsResult {\n    href: string;\n    isAbsolute: boolean;\n    isStatic: boolean;\n    width: number;\n    quality: number;\n    mimeType: string;\n    sizes: number[];\n    minimumCacheTTL: number;\n}\ninterface ImageUpstream {\n    buffer: Buffer;\n    contentType: string | null | undefined;\n    cacheControl: string | null | undefined;\n    etag: string;\n}\nexport declare function getHash(items: (string | number | Buffer)[]): string;\nexport declare function extractEtag(etag: string | null | undefined, imageBuffer: Buffer): string;\nexport declare function getImageEtag(image: Buffer): string;\n/**\n * Inspects the first few bytes of a buffer to determine if\n * it matches the \"magic number\" of known file signatures.\n * https://en.wikipedia.org/wiki/List_of_file_signatures\n */\nexport declare function detectContentType(buffer: Buffer): \"image/svg+xml\" | \"image/avif\" | \"image/webp\" | \"image/jpeg\" | \"image/png\" | \"image/x-icon\" | \"image/gif\" | \"image/x-icns\" | \"image/tiff\" | \"image/bmp\" | null;\nexport declare class ImageOptimizerCache {\n    private cacheDir;\n    private nextConfig;\n    static validateParams(req: IncomingMessage, query: UrlWithParsedQuery['query'], nextConfig: NextConfigComplete, isDev: boolean): ImageParamsResult | {\n        errorMessage: string;\n    };\n    static getCacheKey({ href, width, quality, mimeType, }: {\n        href: string;\n        width: number;\n        quality: number;\n        mimeType: string;\n    }): string;\n    constructor({ distDir, nextConfig, }: {\n        distDir: string;\n        nextConfig: NextConfigComplete;\n    });\n    get(cacheKey: string): Promise<IncrementalResponseCacheEntry | null>;\n    set(cacheKey: string, value: IncrementalCacheValue | null, { cacheControl, }: {\n        cacheControl?: CacheControl;\n    }): Promise<void>;\n}\nexport declare class ImageError extends Error {\n    statusCode: number;\n    constructor(statusCode: number, message: string);\n}\nexport declare function getMaxAge(str: string | null | undefined): number;\nexport declare function getPreviouslyCachedImageOrNull(upstreamImage: ImageUpstream, previousCacheEntry: IncrementalCacheEntry | null | undefined): CachedImageValue | null;\nexport declare function optimizeImage({ buffer, contentType, quality, width, height, concurrency, limitInputPixels, sequentialRead, timeoutInSeconds, }: {\n    buffer: Buffer;\n    contentType: string;\n    quality: number;\n    width: number;\n    height?: number;\n    concurrency?: number | null;\n    limitInputPixels?: number;\n    sequentialRead?: boolean | null;\n    timeoutInSeconds?: number;\n}): Promise<Buffer>;\nexport declare function fetchExternalImage(href: string): Promise<ImageUpstream>;\nexport declare function fetchInternalImage(href: string, _req: IncomingMessage, _res: ServerResponse, handleRequest: (newReq: IncomingMessage, newRes: ServerResponse, newParsedUrl?: NextUrlWithParsedQuery) => Promise<void>): Promise<ImageUpstream>;\nexport declare function imageOptimizer(imageUpstream: ImageUpstream, paramsResult: Pick<ImageParamsResult, 'href' | 'width' | 'quality' | 'mimeType'>, nextConfig: {\n    experimental: Pick<NextConfigComplete['experimental'], 'imgOptConcurrency' | 'imgOptMaxInputPixels' | 'imgOptSequentialRead' | 'imgOptTimeoutInSeconds'>;\n    images: Pick<NextConfigComplete['images'], 'dangerouslyAllowSVG' | 'minimumCacheTTL'>;\n}, opts: {\n    isDev?: boolean;\n    silent?: boolean;\n    previousCacheEntry?: IncrementalResponseCacheEntry | null;\n}): Promise<{\n    buffer: Buffer;\n    contentType: string;\n    maxAge: number;\n    etag: string;\n    upstreamEtag: string;\n    error?: unknown;\n}>;\nexport declare function sendResponse(req: IncomingMessage, res: ServerResponse, url: string, extension: string, buffer: Buffer, etag: string, isStatic: boolean, xCache: XCacheHeader, imagesConfig: ImageConfigComplete, maxAge: number, isDev: boolean): void;\nexport declare function getImageSize(buffer: Buffer): Promise<{\n    width?: number;\n    height?: number;\n}>;\nexport {};\n"
        }
    ]
}