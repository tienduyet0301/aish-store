{
    "sourceFile": "node_modules/next/dist/server/resume-data-cache/resume-data-cache.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892883162,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    createPrerenderResumeDataCache: null,\n    createRenderResumeDataCache: null,\n    stringifyResumeDataCache: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    createPrerenderResumeDataCache: function() {\n        return createPrerenderResumeDataCache;\n    },\n    createRenderResumeDataCache: function() {\n        return createRenderResumeDataCache;\n    },\n    stringifyResumeDataCache: function() {\n        return stringifyResumeDataCache;\n    }\n});\nconst _invarianterror = require(\"../../shared/lib/invariant-error\");\nconst _cachestore = require(\"./cache-store\");\nasync function stringifyResumeDataCache(resumeDataCache) {\n    if (process.env.NEXT_RUNTIME === 'edge') {\n        throw Object.defineProperty(new _invarianterror.InvariantError('`stringifyResumeDataCache` should not be called in edge runtime.'), \"__NEXT_ERROR_CODE\", {\n            value: \"E602\",\n            enumerable: false,\n            configurable: true\n        });\n    } else {\n        if (resumeDataCache.fetch.size === 0 && resumeDataCache.cache.size === 0) {\n            return 'null';\n        }\n        const json = {\n            store: {\n                fetch: Object.fromEntries(Array.from(resumeDataCache.fetch.entries())),\n                cache: Object.fromEntries((await (0, _cachestore.serializeUseCacheCacheStore)(resumeDataCache.cache.entries())).filter((entry)=>entry !== null)),\n                encryptedBoundArgs: Object.fromEntries(Array.from(resumeDataCache.encryptedBoundArgs.entries()))\n            }\n        };\n        // Compress the JSON string using zlib. As the data we already want to\n        // decompress is in memory, we use the synchronous deflateSync function.\n        const { deflateSync } = require('node:zlib');\n        return deflateSync(JSON.stringify(json)).toString('base64');\n    }\n}\nfunction createPrerenderResumeDataCache() {\n    return {\n        cache: new Map(),\n        fetch: new Map(),\n        encryptedBoundArgs: new Map(),\n        decryptedBoundArgs: new Map()\n    };\n}\nfunction createRenderResumeDataCache(prerenderResumeDataCacheOrPersistedCache) {\n    if (process.env.NEXT_RUNTIME === 'edge') {\n        throw Object.defineProperty(new _invarianterror.InvariantError('`createRenderResumeDataCache` should not be called in edge runtime.'), \"__NEXT_ERROR_CODE\", {\n            value: \"E556\",\n            enumerable: false,\n            configurable: true\n        });\n    } else {\n        if (typeof prerenderResumeDataCacheOrPersistedCache !== 'string') {\n            // If the cache is already a prerender cache, we can return it directly,\n            // we're just performing a type change.\n            return prerenderResumeDataCacheOrPersistedCache;\n        }\n        if (prerenderResumeDataCacheOrPersistedCache === 'null') {\n            return {\n                cache: new Map(),\n                fetch: new Map(),\n                encryptedBoundArgs: new Map(),\n                decryptedBoundArgs: new Map()\n            };\n        }\n        // This should be a compressed string. Let's decompress it using zlib.\n        // As the data we already want to decompress is in memory, we use the\n        // synchronous inflateSync function.\n        const { inflateSync } = require('node:zlib');\n        const json = JSON.parse(inflateSync(Buffer.from(prerenderResumeDataCacheOrPersistedCache, 'base64')).toString('utf-8'));\n        return {\n            cache: (0, _cachestore.parseUseCacheCacheStore)(Object.entries(json.store.cache)),\n            fetch: new Map(Object.entries(json.store.fetch)),\n            encryptedBoundArgs: new Map(Object.entries(json.store.encryptedBoundArgs)),\n            decryptedBoundArgs: new Map()\n        };\n    }\n}\n\n//# sourceMappingURL=resume-data-cache.js.map"
        }
    ]
}