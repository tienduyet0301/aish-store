{
    "sourceFile": "node_modules/next/dist/server/next.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892878916,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    NextServer: null,\n    default: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    NextServer: function() {\n        return NextServer;\n    },\n    // exports = module.exports\n    // Support `import next from 'next'`\n    default: function() {\n        return _default;\n    }\n});\nrequire(\"./require-hook\");\nrequire(\"./node-polyfill-crypto\");\nconst _log = /*#__PURE__*/ _interop_require_wildcard(require(\"../build/output/log\"));\nconst _config = /*#__PURE__*/ _interop_require_default(require(\"./config\"));\nconst _path = /*#__PURE__*/ _interop_require_wildcard(require(\"path\"));\nconst _constants = require(\"../lib/constants\");\nconst _constants1 = require(\"../shared/lib/constants\");\nconst _tracer = require(\"./lib/trace/tracer\");\nconst _constants2 = require(\"./lib/trace/constants\");\nconst _formaturl = require(\"../shared/lib/router/utils/format-url\");\nconst _asynccallbackset = require(\"./lib/async-callback-set\");\nfunction _interop_require_default(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nfunction _getRequireWildcardCache(nodeInterop) {\n    if (typeof WeakMap !== \"function\") return null;\n    var cacheBabelInterop = new WeakMap();\n    var cacheNodeInterop = new WeakMap();\n    return (_getRequireWildcardCache = function(nodeInterop) {\n        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n    })(nodeInterop);\n}\nfunction _interop_require_wildcard(obj, nodeInterop) {\n    if (!nodeInterop && obj && obj.__esModule) {\n        return obj;\n    }\n    if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n        return {\n            default: obj\n        };\n    }\n    var cache = _getRequireWildcardCache(nodeInterop);\n    if (cache && cache.has(obj)) {\n        return cache.get(obj);\n    }\n    var newObj = {\n        __proto__: null\n    };\n    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n    for(var key in obj){\n        if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n            if (desc && (desc.get || desc.set)) {\n                Object.defineProperty(newObj, key, desc);\n            } else {\n                newObj[key] = obj[key];\n            }\n        }\n    }\n    newObj.default = obj;\n    if (cache) {\n        cache.set(obj, newObj);\n    }\n    return newObj;\n}\nlet ServerImpl;\nconst getServerImpl = async ()=>{\n    if (ServerImpl === undefined) {\n        ServerImpl = (await Promise.resolve(require('./next-server'))).default;\n    }\n    return ServerImpl;\n};\nconst SYMBOL_LOAD_CONFIG = Symbol('next.load_config');\nclass NextServer {\n    constructor(options){\n        this.options = options;\n    }\n    get hostname() {\n        return this.options.hostname;\n    }\n    get port() {\n        return this.options.port;\n    }\n    getRequestHandler() {\n        return async (req, res, parsedUrl)=>{\n            return (0, _tracer.getTracer)().trace(_constants2.NextServerSpan.getRequestHandler, async ()=>{\n                const requestHandler = await this.getServerRequestHandler();\n                return requestHandler(req, res, parsedUrl);\n            });\n        };\n    }\n    getUpgradeHandler() {\n        return async (req, socket, head)=>{\n            const server = await this.getServer();\n            // @ts-expect-error we mark this as protected so it\n            // causes an error here\n            return server.handleUpgrade.apply(server, [\n                req,\n                socket,\n                head\n            ]);\n        };\n    }\n    setAssetPrefix(assetPrefix) {\n        if (this.server) {\n            this.server.setAssetPrefix(assetPrefix);\n        } else {\n            this.preparedAssetPrefix = assetPrefix;\n        }\n    }\n    logError(...args) {\n        if (this.server) {\n            this.server.logError(...args);\n        }\n    }\n    async render(...args) {\n        const server = await this.getServer();\n        return server.render(...args);\n    }\n    async renderToHTML(...args) {\n        const server = await this.getServer();\n        return server.renderToHTML(...args);\n    }\n    async renderError(...args) {\n        const server = await this.getServer();\n        return server.renderError(...args);\n    }\n    async renderErrorToHTML(...args) {\n        const server = await this.getServer();\n        return server.renderErrorToHTML(...args);\n    }\n    async render404(...args) {\n        const server = await this.getServer();\n        return server.render404(...args);\n    }\n    async prepare(serverFields) {\n        const server = await this.getServer();\n        if (serverFields) {\n            Object.assign(server, serverFields);\n        }\n        // We shouldn't prepare the server in production,\n        // because this code won't be executed when deployed\n        if (this.options.dev) {\n            await server.prepare();\n        }\n    }\n    async close() {\n        if (this.server) {\n            await this.server.close();\n        }\n    }\n    async createServer(options) {\n        let ServerImplementation;\n        if (options.dev) {\n            ServerImplementation = require('./dev/next-dev-server').default;\n        } else {\n            ServerImplementation = await getServerImpl();\n        }\n        const server = new ServerImplementation(options);\n        return server;\n    }\n    async [SYMBOL_LOAD_CONFIG]() {\n        const dir = (0, _path.resolve)(this.options.dir || '.');\n        const config = await (0, _config.default)(this.options.dev ? _constants1.PHASE_DEVELOPMENT_SERVER : _constants1.PHASE_PRODUCTION_SERVER, dir, {\n            customConfig: this.options.conf,\n            silent: true\n        });\n        // check serialized build config when available\n        if (!this.options.dev) {\n            try {\n                const serializedConfig = require(_path.default.join(dir, config.distDir, _constants1.SERVER_FILES_MANIFEST)).config;\n                // @ts-expect-error internal field\n                config.experimental.isExperimentalCompile = serializedConfig.experimental.isExperimentalCompile;\n            } catch (_) {\n            // if distDir is customized we don't know until we\n            // load the config so fallback to loading the config\n            // from next.config.js\n            }\n        }\n        return config;\n    }\n    async getServer() {\n        if (!this.serverPromise) {\n            this.serverPromise = this[SYMBOL_LOAD_CONFIG]().then(async (conf)=>{\n                if (!this.options.dev) {\n                    if (conf.output === 'standalone') {\n                        if (!process.env.__NEXT_PRIVATE_STANDALONE_CONFIG) {\n                            _log.warn(`\"next start\" does not work with \"output: standalone\" configuration. Use \"node .next/standalone/server.js\" instead.`);\n                        }\n                    } else if (conf.output === 'export') {\n                        throw Object.defineProperty(new Error(`\"next start\" does not work with \"output: export\" configuration. Use \"npx serve@latest out\" instead.`), \"__NEXT_ERROR_CODE\", {\n                            value: \"E375\",\n                            enumerable: false,\n                            configurable: true\n                        });\n                    }\n                }\n                this.server = await this.createServer({\n                    ...this.options,\n                    conf\n                });\n                if (this.preparedAssetPrefix) {\n                    this.server.setAssetPrefix(this.preparedAssetPrefix);\n                }\n                return this.server;\n            });\n        }\n        return this.serverPromise;\n    }\n    async getServerRequestHandler() {\n        if (this.reqHandler) return this.reqHandler;\n        // Memoize request handler creation\n        if (!this.reqHandlerPromise) {\n            this.reqHandlerPromise = this.getServer().then((server)=>{\n                this.reqHandler = (0, _tracer.getTracer)().wrap(_constants2.NextServerSpan.getServerRequestHandler, server.getRequestHandler().bind(server));\n                delete this.reqHandlerPromise;\n                return this.reqHandler;\n            });\n        }\n        return this.reqHandlerPromise;\n    }\n}\n/** The wrapper server used for `import next from \"next\" (in a custom server)` */ class NextCustomServer {\n    constructor(options){\n        this.didWebSocketSetup = false;\n        this.options = options;\n    }\n    getInit() {\n        if (!this.init) {\n            throw Object.defineProperty(new Error('prepare() must be called before performing this operation'), \"__NEXT_ERROR_CODE\", {\n                value: \"E355\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n        return this.init;\n    }\n    get requestHandler() {\n        return this.getInit().requestHandler;\n    }\n    get upgradeHandler() {\n        return this.getInit().upgradeHandler;\n    }\n    get server() {\n        return this.getInit().server;\n    }\n    get hostname() {\n        return this.options.hostname;\n    }\n    get port() {\n        return this.options.port;\n    }\n    async prepare() {\n        const { getRequestHandlers } = require('./lib/start-server');\n        let onDevServerCleanup;\n        if (this.options.dev) {\n            this.cleanupListeners = new _asynccallbackset.AsyncCallbackSet();\n            onDevServerCleanup = this.cleanupListeners.add.bind(this.cleanupListeners);\n        }\n        const initResult = await getRequestHandlers({\n            dir: this.options.dir,\n            port: this.options.port || 3000,\n            isDev: !!this.options.dev,\n            onDevServerCleanup,\n            hostname: this.options.hostname || 'localhost',\n            minimalMode: this.options.minimalMode,\n            quiet: this.options.quiet\n        });\n        this.init = initResult;\n    }\n    setupWebSocketHandler(customServer, _req) {\n        if (!this.didWebSocketSetup) {\n            var _req_socket;\n            this.didWebSocketSetup = true;\n            customServer = customServer || (_req == null ? void 0 : (_req_socket = _req.socket) == null ? void 0 : _req_socket.server);\n            if (customServer) {\n                customServer.on('upgrade', async (req, socket, head)=>{\n                    this.upgradeHandler(req, socket, head);\n                });\n            }\n        }\n    }\n    getRequestHandler() {\n        return async (req, res, parsedUrl)=>{\n            this.setupWebSocketHandler(this.options.httpServer, req);\n            if (parsedUrl) {\n                req.url = (0, _formaturl.formatUrl)(parsedUrl);\n            }\n            return this.requestHandler(req, res);\n        };\n    }\n    async render(...args) {\n        let [req, res, pathname, query, parsedUrl] = args;\n        this.setupWebSocketHandler(this.options.httpServer, req);\n        if (!pathname.startsWith('/')) {\n            console.error(`Cannot render page with path \"${pathname}\"`);\n            pathname = `/${pathname}`;\n        }\n        pathname = pathname === '/index' ? '/' : pathname;\n        req.url = (0, _formaturl.formatUrl)({\n            ...parsedUrl,\n            pathname,\n            query\n        });\n        await this.requestHandler(req, res);\n        return;\n    }\n    setAssetPrefix(assetPrefix) {\n        this.server.setAssetPrefix(assetPrefix);\n    }\n    getUpgradeHandler() {\n        return this.server.getUpgradeHandler();\n    }\n    logError(...args) {\n        this.server.logError(...args);\n    }\n    async renderToHTML(...args) {\n        return this.server.renderToHTML(...args);\n    }\n    async renderError(...args) {\n        return this.server.renderError(...args);\n    }\n    async renderErrorToHTML(...args) {\n        return this.server.renderErrorToHTML(...args);\n    }\n    async render404(...args) {\n        return this.server.render404(...args);\n    }\n    async close() {\n        var _this_init, _this_cleanupListeners;\n        await Promise.allSettled([\n            (_this_init = this.init) == null ? void 0 : _this_init.server.close(),\n            (_this_cleanupListeners = this.cleanupListeners) == null ? void 0 : _this_cleanupListeners.runAll()\n        ]);\n    }\n}\n// This file is used for when users run `require('next')`\nfunction createServer(options) {\n    if (options && (options.turbo || options.turbopack || process.env.IS_TURBOPACK_TEST)) {\n        process.env.TURBOPACK = '1';\n    }\n    // The package is used as a TypeScript plugin.\n    if (options && 'typescript' in options && 'version' in options.typescript) {\n        const pluginMod = require('./next-typescript');\n        return pluginMod.createTSPlugin(options);\n    }\n    if (options == null) {\n        throw Object.defineProperty(new Error('The server has not been instantiated properly. https://nextjs.org/docs/messages/invalid-server-options'), \"__NEXT_ERROR_CODE\", {\n            value: \"E75\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    if (!('isNextDevCommand' in options) && process.env.NODE_ENV && ![\n        'production',\n        'development',\n        'test'\n    ].includes(process.env.NODE_ENV)) {\n        _log.warn(_constants.NON_STANDARD_NODE_ENV);\n    }\n    if (options.dev && typeof options.dev !== 'boolean') {\n        console.warn(\"Warning: 'dev' is not a boolean which could introduce unexpected behavior. https://nextjs.org/docs/messages/invalid-server-options\");\n    }\n    // When the caller is a custom server (using next()).\n    if (options.customServer !== false) {\n        const dir = (0, _path.resolve)(options.dir || '.');\n        return new NextCustomServer({\n            ...options,\n            dir\n        });\n    }\n    // When the caller is Next.js internals (i.e. render worker, start server, etc)\n    return new NextServer(options);\n}\n// Support commonjs `require('next')`\nmodule.exports = createServer;\nconst _default = createServer;\n\n//# sourceMappingURL=next.js.map"
        }
    ]
}