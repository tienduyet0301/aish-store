{
    "sourceFile": "node_modules/next/dist/server/app-render/make-get-server-inserted-html.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892869529,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"makeGetServerInsertedHTML\", {\n    enumerable: true,\n    get: function() {\n        return makeGetServerInsertedHTML;\n    }\n});\nconst _jsxruntime = require(\"react/jsx-runtime\");\nconst _react = /*#__PURE__*/ _interop_require_default(require(\"react\"));\nconst _httpaccessfallback = require(\"../../client/components/http-access-fallback/http-access-fallback\");\nconst _redirect = require(\"../../client/components/redirect\");\nconst _redirecterror = require(\"../../client/components/redirect-error\");\nconst _serveredge = require(\"react-dom/server.edge\");\nconst _nodewebstreamshelper = require(\"../stream-utils/node-web-streams-helper\");\nconst _redirectstatuscode = require(\"../../client/components/redirect-status-code\");\nconst _addpathprefix = require(\"../../shared/lib/router/utils/add-path-prefix\");\nfunction _interop_require_default(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nfunction makeGetServerInsertedHTML({ polyfills, renderServerInsertedHTML, serverCapturedErrors, tracingMetadata, basePath }) {\n    let flushedErrorMetaTagsUntilIndex = 0;\n    // flag for static content that only needs to be flushed once\n    let hasFlushedInitially = false;\n    const polyfillTags = polyfills.map((polyfill)=>{\n        return /*#__PURE__*/ (0, _jsxruntime.jsx)(\"script\", {\n            ...polyfill\n        }, polyfill.src);\n    });\n    return async function getServerInsertedHTML() {\n        // Loop through all the errors that have been captured but not yet\n        // flushed.\n        const errorMetaTags = [];\n        while(flushedErrorMetaTagsUntilIndex < serverCapturedErrors.length){\n            const error = serverCapturedErrors[flushedErrorMetaTagsUntilIndex];\n            flushedErrorMetaTagsUntilIndex++;\n            if ((0, _httpaccessfallback.isHTTPAccessFallbackError)(error)) {\n                errorMetaTags.push(/*#__PURE__*/ (0, _jsxruntime.jsx)(\"meta\", {\n                    name: \"robots\",\n                    content: \"noindex\"\n                }, error.digest), process.env.NODE_ENV === 'development' ? /*#__PURE__*/ (0, _jsxruntime.jsx)(\"meta\", {\n                    name: \"next-error\",\n                    content: \"not-found\"\n                }, \"next-error\") : null);\n            } else if ((0, _redirecterror.isRedirectError)(error)) {\n                const redirectUrl = (0, _addpathprefix.addPathPrefix)((0, _redirect.getURLFromRedirectError)(error), basePath);\n                const statusCode = (0, _redirect.getRedirectStatusCodeFromError)(error);\n                const isPermanent = statusCode === _redirectstatuscode.RedirectStatusCode.PermanentRedirect ? true : false;\n                if (redirectUrl) {\n                    errorMetaTags.push(/*#__PURE__*/ (0, _jsxruntime.jsx)(\"meta\", {\n                        id: \"__next-page-redirect\",\n                        httpEquiv: \"refresh\",\n                        content: `${isPermanent ? 0 : 1};url=${redirectUrl}`\n                    }, error.digest));\n                }\n            }\n        }\n        const traceMetaTags = (tracingMetadata || []).map(({ key, value }, index)=>/*#__PURE__*/ (0, _jsxruntime.jsx)(\"meta\", {\n                name: key,\n                content: value\n            }, `next-trace-data-${index}`));\n        const serverInsertedHTML = renderServerInsertedHTML();\n        // Skip React rendering if we know the content is empty.\n        if (polyfillTags.length === 0 && traceMetaTags.length === 0 && errorMetaTags.length === 0 && Array.isArray(serverInsertedHTML) && serverInsertedHTML.length === 0) {\n            return '';\n        }\n        const stream = await (0, _serveredge.renderToReadableStream)(/*#__PURE__*/ (0, _jsxruntime.jsxs)(_jsxruntime.Fragment, {\n            children: [\n                /* Insert the polyfills if they haven't been flushed yet. */ hasFlushedInitially ? null : polyfillTags,\n                serverInsertedHTML,\n                hasFlushedInitially ? null : traceMetaTags,\n                errorMetaTags\n            ]\n        }), {\n            // Larger chunk because this isn't sent over the network.\n            // Let's set it to 1MB.\n            progressiveChunkSize: 1024 * 1024\n        });\n        hasFlushedInitially = true;\n        // There's no need to wait for the stream to be ready\n        // e.g. calling `await stream.allReady` because `streamToString` will\n        // wait and decode the stream progressively with better parallelism.\n        return (0, _nodewebstreamshelper.streamToString)(stream);\n    };\n}\n\n//# sourceMappingURL=make-get-server-inserted-html.js.map"
        }
    ]
}