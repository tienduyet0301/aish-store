{
    "sourceFile": "node_modules/next/dist/server/app-render/use-flight-response.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892870726,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    createInlinedDataReadableStream: null,\n    useFlightStream: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    createInlinedDataReadableStream: function() {\n        return createInlinedDataReadableStream;\n    },\n    useFlightStream: function() {\n        return useFlightStream;\n    }\n});\nconst _htmlescape = require(\"../htmlescape\");\nconst isEdgeRuntime = process.env.NEXT_RUNTIME === 'edge';\nconst INLINE_FLIGHT_PAYLOAD_BOOTSTRAP = 0;\nconst INLINE_FLIGHT_PAYLOAD_DATA = 1;\nconst INLINE_FLIGHT_PAYLOAD_FORM_STATE = 2;\nconst INLINE_FLIGHT_PAYLOAD_BINARY = 3;\nconst flightResponses = new WeakMap();\nconst encoder = new TextEncoder();\nfunction useFlightStream(flightStream, clientReferenceManifest, nonce) {\n    const response = flightResponses.get(flightStream);\n    if (response) {\n        return response;\n    }\n    // react-server-dom-webpack/client.edge must not be hoisted for require cache clearing to work correctly\n    const { createFromReadableStream } = // eslint-disable-next-line import/no-extraneous-dependencies\n    require('react-server-dom-webpack/client.edge');\n    const newResponse = createFromReadableStream(flightStream, {\n        serverConsumerManifest: {\n            moduleLoading: clientReferenceManifest.moduleLoading,\n            moduleMap: isEdgeRuntime ? clientReferenceManifest.edgeSSRModuleMapping : clientReferenceManifest.ssrModuleMapping,\n            serverModuleMap: null\n        },\n        nonce\n    });\n    flightResponses.set(flightStream, newResponse);\n    return newResponse;\n}\nfunction createInlinedDataReadableStream(flightStream, nonce, formState) {\n    const startScriptTag = nonce ? `<script nonce=${JSON.stringify(nonce)}>` : '<script>';\n    const flightReader = flightStream.getReader();\n    const decoder = new TextDecoder('utf-8', {\n        fatal: true\n    });\n    const readable = new ReadableStream({\n        type: 'bytes',\n        start (controller) {\n            try {\n                writeInitialInstructions(controller, startScriptTag, formState);\n            } catch (error) {\n                // during encoding or enqueueing forward the error downstream\n                controller.error(error);\n            }\n        },\n        async pull (controller) {\n            try {\n                const { done, value } = await flightReader.read();\n                if (value) {\n                    try {\n                        const decodedString = decoder.decode(value, {\n                            stream: !done\n                        });\n                        // The chunk cannot be decoded as valid UTF-8 string as it might\n                        // have arbitrary binary data.\n                        writeFlightDataInstruction(controller, startScriptTag, decodedString);\n                    } catch  {\n                        // The chunk cannot be decoded as valid UTF-8 string.\n                        writeFlightDataInstruction(controller, startScriptTag, value);\n                    }\n                }\n                if (done) {\n                    controller.close();\n                }\n            } catch (error) {\n                // There was a problem in the upstream reader or during decoding or enqueuing\n                // forward the error downstream\n                controller.error(error);\n            }\n        }\n    });\n    return readable;\n}\nfunction writeInitialInstructions(controller, scriptStart, formState) {\n    if (formState != null) {\n        controller.enqueue(encoder.encode(`${scriptStart}(self.__next_f=self.__next_f||[]).push(${(0, _htmlescape.htmlEscapeJsonString)(JSON.stringify([\n            INLINE_FLIGHT_PAYLOAD_BOOTSTRAP\n        ]))});self.__next_f.push(${(0, _htmlescape.htmlEscapeJsonString)(JSON.stringify([\n            INLINE_FLIGHT_PAYLOAD_FORM_STATE,\n            formState\n        ]))})</script>`));\n    } else {\n        controller.enqueue(encoder.encode(`${scriptStart}(self.__next_f=self.__next_f||[]).push(${(0, _htmlescape.htmlEscapeJsonString)(JSON.stringify([\n            INLINE_FLIGHT_PAYLOAD_BOOTSTRAP\n        ]))})</script>`));\n    }\n}\nfunction writeFlightDataInstruction(controller, scriptStart, chunk) {\n    let htmlInlinedData;\n    if (typeof chunk === 'string') {\n        htmlInlinedData = (0, _htmlescape.htmlEscapeJsonString)(JSON.stringify([\n            INLINE_FLIGHT_PAYLOAD_DATA,\n            chunk\n        ]));\n    } else {\n        // The chunk cannot be embedded as a UTF-8 string in the script tag.\n        // Instead let's inline it in base64.\n        // Credits to Devon Govett (devongovett) for the technique.\n        // https://github.com/devongovett/rsc-html-stream\n        const base64 = btoa(String.fromCodePoint(...chunk));\n        htmlInlinedData = (0, _htmlescape.htmlEscapeJsonString)(JSON.stringify([\n            INLINE_FLIGHT_PAYLOAD_BINARY,\n            base64\n        ]));\n    }\n    controller.enqueue(encoder.encode(`${scriptStart}self.__next_f.push(${htmlInlinedData})</script>`));\n}\n\n//# sourceMappingURL=use-flight-response.js.map"
        }
    ]
}