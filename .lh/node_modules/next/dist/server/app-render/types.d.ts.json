{
    "sourceFile": "node_modules/next/dist/server/app-render/types.d.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892870607,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import type { LoadComponentsReturnType } from '../load-components';\nimport type { ServerRuntime, SizeLimit } from '../../types';\nimport type { NextConfigComplete } from '../../server/config-shared';\nimport type { ClientReferenceManifest } from '../../build/webpack/plugins/flight-manifest-plugin';\nimport type { NextFontManifest } from '../../build/webpack/plugins/next-font-manifest-plugin';\nimport type { ParsedUrlQuery } from 'querystring';\nimport type { AppPageModule } from '../route-modules/app-page/module';\nimport type { HeadData, LoadingModuleData } from '../../shared/lib/app-router-context.shared-runtime';\nimport type { DeepReadonly } from '../../shared/lib/deep-readonly';\nimport type { __ApiPreviewProps } from '../api-utils';\nimport s from 'next/dist/compiled/superstruct';\nimport type { RequestLifecycleOpts } from '../base-server';\nimport type { InstrumentationOnRequestError } from '../instrumentation/types';\nimport type { NextRequestHint } from '../web/adapter';\nimport type { BaseNextRequest } from '../base-http';\nimport type { IncomingMessage } from 'http';\nimport type { RenderResumeDataCache } from '../resume-data-cache/resume-data-cache';\nexport type DynamicParamTypes = 'catchall' | 'catchall-intercepted' | 'optional-catchall' | 'dynamic' | 'dynamic-intercepted';\ndeclare const dynamicParamTypesSchema: s.Struct<\"d\" | \"c\" | \"ci\" | \"oc\" | \"di\", {\n    d: \"d\";\n    c: \"c\";\n    ci: \"ci\";\n    oc: \"oc\";\n    di: \"di\";\n}>;\nexport type DynamicParamTypesShort = s.Infer<typeof dynamicParamTypesSchema>;\ndeclare const segmentSchema: s.Struct<string | [string, string, \"d\" | \"c\" | \"ci\" | \"oc\" | \"di\"], null>;\nexport type Segment = s.Infer<typeof segmentSchema>;\nexport declare const flightRouterStateSchema: s.Describe<any>;\n/**\n * Router state\n */\nexport type FlightRouterState = [\n    segment: Segment,\n    parallelRoutes: {\n        [parallelRouterKey: string]: FlightRouterState;\n    },\n    url?: string | null,\n    /**\n     * \"refresh\" and \"refetch\", despite being similarly named, have different\n     * semantics:\n     * - \"refetch\" is used during a request to inform the server where rendering\n     *   should start from.\n     *\n     * - \"refresh\" is used by the client to mark that a segment should re-fetch the\n     *   data from the server for the current segment. It uses the \"url\" property\n     *   above to determine where to fetch from.\n     *\n     * - \"inside-shared-layout\" is used during a prefetch request to inform the\n     *   server that even if the segment matches, it should be treated as if it's\n     *   within the \"new\" part of a navigation — inside the shared layout. If\n     *   the segment doesn't match, then it has no effect, since it would be\n     *   treated as new regardless. If it does match, though, the server does not\n     *   need to render it, because the client already has it.\n     *\n     *   A bit confusing, but that's because it has only one extremely narrow use\n     *   case — during a non-PPR prefetch, the server uses it to find the first\n     *   loading boundary beneath a shared layout.\n     *\n     *   TODO: We should rethink the protocol for dynamic requests. It might not\n     *   make sense for the client to send a FlightRouterState, since this type is\n     *   overloaded with concerns.\n     */\n    refresh?: 'refetch' | 'refresh' | 'inside-shared-layout' | null,\n    isRootLayout?: boolean\n];\n/**\n * Individual Flight response path\n */\nexport type FlightSegmentPath = any[] | [\n    segment: Segment,\n    parallelRouterKey: string,\n    segment: Segment,\n    parallelRouterKey: string,\n    segment: Segment,\n    parallelRouterKey: string\n];\n/**\n * Represents a tree of segments and the Flight data (i.e. React nodes) that\n * correspond to each one. The tree is isomorphic to the FlightRouterState;\n * however in the future we want to be able to fetch arbitrary partial segments\n * without having to fetch all its children. So this response format will\n * likely change.\n */\nexport type CacheNodeSeedData = [\n    segment: Segment,\n    node: React.ReactNode | null,\n    parallelRoutes: {\n        [parallelRouterKey: string]: CacheNodeSeedData | null;\n    },\n    loading: LoadingModuleData | Promise<LoadingModuleData>,\n    isPartial: boolean\n];\nexport type FlightDataSegment = [\n    Segment,\n    FlightRouterState,\n    CacheNodeSeedData | null,\n    HeadData,\n    boolean\n];\nexport type FlightDataPath = any[] | [\n    ...FlightSegmentPath[],\n    ...FlightDataSegment\n];\n/**\n * The Flight response data\n */\nexport type FlightData = Array<FlightDataPath> | string;\nexport type ActionResult = Promise<any>;\nexport type ServerOnInstrumentationRequestError = (error: unknown, request: NextRequestHint | BaseNextRequest | IncomingMessage, errorContext: Parameters<InstrumentationOnRequestError>[2]) => void | Promise<void>;\nexport interface RenderOptsPartial {\n    previewProps: __ApiPreviewProps | undefined;\n    err?: Error | null;\n    dev?: boolean;\n    basePath: string;\n    trailingSlash: boolean;\n    clientReferenceManifest?: DeepReadonly<ClientReferenceManifest>;\n    supportsDynamicResponse: boolean;\n    runtime?: ServerRuntime;\n    serverComponents?: boolean;\n    enableTainting?: boolean;\n    assetPrefix?: string;\n    crossOrigin?: '' | 'anonymous' | 'use-credentials' | undefined;\n    nextFontManifest?: DeepReadonly<NextFontManifest>;\n    botType?: 'dom' | 'html' | undefined;\n    serveStreamingMetadata?: boolean;\n    incrementalCache?: import('../lib/incremental-cache').IncrementalCache;\n    cacheLifeProfiles?: {\n        [profile: string]: import('../use-cache/cache-life').CacheLife;\n    };\n    setIsrStatus?: (key: string, value: boolean | null) => void;\n    isRevalidate?: boolean;\n    nextExport?: boolean;\n    nextConfigOutput?: 'standalone' | 'export';\n    onInstrumentationRequestError?: ServerOnInstrumentationRequestError;\n    isDraftMode?: boolean;\n    deploymentId?: string;\n    onUpdateCookies?: (cookies: string[]) => void;\n    loadConfig?: (phase: string, dir: string, customConfig?: object | null, rawConfig?: boolean, silent?: boolean) => Promise<NextConfigComplete>;\n    serverActions?: {\n        bodySizeLimit?: SizeLimit;\n        allowedOrigins?: string[];\n    };\n    params?: ParsedUrlQuery;\n    isPrefetch?: boolean;\n    htmlLimitedBots: string | undefined;\n    experimental: {\n        /**\n         * When true, it indicates that the current page supports partial\n         * prerendering.\n         */\n        isRoutePPREnabled?: boolean;\n        expireTime: number | undefined;\n        clientTraceMetadata: string[] | undefined;\n        dynamicIO: boolean;\n        clientSegmentCache: boolean | 'client-only';\n        dynamicOnHover: boolean;\n        inlineCss: boolean;\n        authInterrupts: boolean;\n    };\n    postponed?: string;\n    /**\n     * Should wait for react stream allReady to resolve all suspense boundaries,\n     * in order to perform a full page render.\n     */\n    shouldWaitOnAllReady?: boolean;\n    /**\n     * The resume data cache that was generated for this partially prerendered\n     * page during dev warmup.\n     */\n    devRenderResumeDataCache?: RenderResumeDataCache;\n    /**\n     * When true, the page will be rendered using the static rendering to detect\n     * any dynamic API's that would have stopped the page from being fully\n     * statically generated.\n     */\n    isDebugDynamicAccesses?: boolean;\n    /**\n     * The maximum length of the headers that are emitted by React and added to\n     * the response.\n     */\n    reactMaxHeadersLength: number | undefined;\n    isStaticGeneration?: boolean;\n}\nexport type RenderOpts = LoadComponentsReturnType<AppPageModule> & RenderOptsPartial & RequestLifecycleOpts;\nexport type PreloadCallbacks = (() => void)[];\nexport type InitialRSCPayload = {\n    /** buildId */\n    b: string;\n    /** assetPrefix */\n    p: string;\n    /** initialCanonicalUrlParts */\n    c: string[];\n    /** couldBeIntercepted */\n    i: boolean;\n    /** initialFlightData */\n    f: FlightDataPath[];\n    /** missingSlots */\n    m: Set<string> | undefined;\n    /** GlobalError */\n    G: [React.ComponentType<any>, React.ReactNode | undefined];\n    /** postponed */\n    s: boolean;\n    /** prerendered */\n    S: boolean;\n};\nexport type NavigationFlightResponse = {\n    /** buildId */\n    b: string;\n    /** flightData */\n    f: FlightData;\n    /** prerendered */\n    S: boolean;\n};\nexport type ActionFlightResponse = {\n    /** actionResult */\n    a: ActionResult;\n    /** buildId */\n    b: string;\n    /** flightData */\n    f: FlightData;\n};\nexport type RSCPayload = InitialRSCPayload | NavigationFlightResponse | ActionFlightResponse;\nexport {};\n"
        }
    ]
}