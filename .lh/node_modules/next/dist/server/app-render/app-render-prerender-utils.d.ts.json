{
    "sourceFile": "node_modules/next/dist/server/app-render/app-render-prerender-utils.d.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892867286,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * This is a utility function to make scheduling sequential tasks that run back to back easier.\n * We schedule on the same queue (setImmediate) at the same time to ensure no other events can sneak in between.\n */\nexport declare function prerenderAndAbortInSequentialTasks<R>(prerender: () => Promise<R>, abort: () => void): Promise<R>;\nexport declare function prerenderServerWithPhases(signal: AbortSignal, render: () => ReadableStream<Uint8Array>, finalPhase: () => void): Promise<ServerPrerenderStreamResult>;\nexport declare function prerenderServerWithPhases(signal: AbortSignal, render: () => ReadableStream<Uint8Array>, secondPhase: () => void, finalPhase: () => void): Promise<ServerPrerenderStreamResult>;\nexport declare function prerenderServerWithPhases(signal: AbortSignal, render: () => ReadableStream<Uint8Array>, secondPhase: () => void, thirdPhase: () => void, ...remainingPhases: Array<() => void>): Promise<ServerPrerenderStreamResult>;\nexport declare class ServerPrerenderStreamResult {\n    private currentChunks;\n    private chunksByPhase;\n    private trailingChunks;\n    private status;\n    private reason;\n    constructor(stream: ReadableStream<Uint8Array>);\n    markPhase(): void;\n    markComplete(): void;\n    markInterrupted(): void;\n    /**\n     * Returns a stream which only releases chunks when `releasePhase` is called. This stream will never \"complete\" because\n     * we rely upon the stream remaining open when prerendering to avoid triggering errors for incomplete chunks in the client.\n     *\n     * asPhasedStream is expected to be called once per result however it is safe to call multiple times as long as we have not\n     * transferred the underlying data. Generally this will only happen when streaming to a response\n     */\n    asPhasedStream(): PhasedStream<Uint8Array<ArrayBufferLike>>;\n    /**\n     * Returns a stream which will release all chunks immediately. This stream will \"complete\" synchronously. It should be used outside\n     * of render use cases like loading client chunks ahead of SSR or writing the streamed content to disk.\n     */\n    asStream(): ReadableStream<any>;\n}\ndeclare class PhasedStream<T> extends ReadableStream<T> {\n    private nextPhase;\n    private chunksByPhase;\n    private destination;\n    constructor(chunksByPhase: Array<Array<T>>);\n    releasePhase(): void;\n    assertExhausted(): void;\n}\nexport declare function prerenderClientWithPhases<T>(render: () => Promise<T>, finalPhase: () => void): Promise<T>;\nexport declare function prerenderClientWithPhases<T>(render: () => Promise<T>, secondPhase: () => void, finalPhase: () => void): Promise<T>;\nexport declare function prerenderClientWithPhases<T>(render: () => Promise<T>, secondPhase: () => void, thirdPhase: () => void, ...remainingPhases: Array<() => void>): Promise<T>;\nexport declare class ReactServerResult {\n    private _stream;\n    constructor(stream: ReadableStream<Uint8Array>);\n    tee(): ReadableStream<Uint8Array<ArrayBufferLike>>;\n    consume(): ReadableStream<Uint8Array<ArrayBufferLike>>;\n}\nexport type ReactServerPrerenderResolveToType = {\n    prelude: ReadableStream<Uint8Array>;\n};\nexport declare function createReactServerPrerenderResult(underlying: Promise<ReactServerPrerenderResolveToType>): Promise<ReactServerPrerenderResult>;\nexport declare function createReactServerPrerenderResultFromRender(underlying: ReadableStream<Uint8Array>): Promise<ReactServerPrerenderResult>;\nexport declare class ReactServerPrerenderResult {\n    private _chunks;\n    private assertChunks;\n    private consumeChunks;\n    consume(): void;\n    constructor(chunks: Array<Uint8Array>);\n    asUnclosingStream(): ReadableStream<Uint8Array>;\n    consumeAsUnclosingStream(): ReadableStream<Uint8Array>;\n    asStream(): ReadableStream<Uint8Array>;\n    consumeAsStream(): ReadableStream<Uint8Array>;\n}\nexport {};\n"
        }
    ]
}