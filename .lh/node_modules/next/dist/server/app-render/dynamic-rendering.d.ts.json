{
    "sourceFile": "node_modules/next/dist/server/app-render/dynamic-rendering.d.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892868256,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * The functions provided by this module are used to communicate certain properties\n * about the currently running code so that Next.js can make decisions on how to handle\n * the current execution in different rendering modes such as pre-rendering, resuming, and SSR.\n *\n * Today Next.js treats all code as potentially static. Certain APIs may only make sense when dynamically rendering.\n * Traditionally this meant deopting the entire render to dynamic however with PPR we can now deopt parts\n * of a React tree as dynamic while still keeping other parts static. There are really two different kinds of\n * Dynamic indications.\n *\n * The first is simply an intention to be dynamic. unstable_noStore is an example of this where\n * the currently executing code simply declares that the current scope is dynamic but if you use it\n * inside unstable_cache it can still be cached. This type of indication can be removed if we ever\n * make the default dynamic to begin with because the only way you would ever be static is inside\n * a cache scope which this indication does not affect.\n *\n * The second is an indication that a dynamic data source was read. This is a stronger form of dynamic\n * because it means that it is inappropriate to cache this at all. using a dynamic data source inside\n * unstable_cache should error. If you want to use some dynamic data inside unstable_cache you should\n * read that data outside the cache and pass it in as an argument to the cached function.\n */\nimport type { WorkStore } from '../app-render/work-async-storage.external';\nimport type { WorkUnitStore, RequestStore, PrerenderStoreModern } from '../app-render/work-unit-async-storage.external';\nexport type DynamicAccess = {\n    /**\n     * If debugging, this will contain the stack trace of where the dynamic access\n     * occurred. This is used to provide more information to the user about why\n     * their page is being rendered dynamically.\n     */\n    stack?: string;\n    /**\n     * The expression that was accessed dynamically.\n     */\n    expression: string;\n};\nexport type DynamicTrackingState = {\n    /**\n     * When true, stack information will also be tracked during dynamic access.\n     */\n    readonly isDebugDynamicAccesses: boolean | undefined;\n    /**\n     * The dynamic accesses that occurred during the render.\n     */\n    readonly dynamicAccesses: Array<DynamicAccess>;\n    syncDynamicExpression: undefined | string;\n    syncDynamicErrorWithStack: null | Error;\n    syncDynamicLogged?: boolean;\n};\nexport type DynamicValidationState = {\n    hasSuspendedDynamic: boolean;\n    hasDynamicMetadata: boolean;\n    hasDynamicViewport: boolean;\n    hasSyncDynamicErrors: boolean;\n    dynamicErrors: Array<Error>;\n};\nexport declare function createDynamicTrackingState(isDebugDynamicAccesses: boolean | undefined): DynamicTrackingState;\nexport declare function createDynamicValidationState(): DynamicValidationState;\nexport declare function getFirstDynamicReason(trackingState: DynamicTrackingState): undefined | string;\n/**\n * This function communicates that the current scope should be treated as dynamic.\n *\n * In most cases this function is a no-op but if called during\n * a PPR prerender it will postpone the current sub-tree and calling\n * it during a normal prerender will cause the entire prerender to abort\n */\nexport declare function markCurrentScopeAsDynamic(store: WorkStore, workUnitStore: undefined | Exclude<WorkUnitStore, PrerenderStoreModern>, expression: string): void;\n/**\n * This function communicates that some dynamic path parameter was read. This\n * differs from the more general `trackDynamicDataAccessed` in that it is will\n * not error when `dynamic = \"error\"` is set.\n *\n * @param store The static generation store\n * @param expression The expression that was accessed dynamically\n */\nexport declare function trackFallbackParamAccessed(store: WorkStore, expression: string): void;\nexport declare function abortOnSynchronousPlatformIOAccess(route: string, expression: string, errorWithStack: Error, prerenderStore: PrerenderStoreModern): void;\nexport declare function trackSynchronousPlatformIOAccessInDev(requestStore: RequestStore): void;\nexport declare const trackSynchronousRequestDataAccessInDev: typeof trackSynchronousPlatformIOAccessInDev;\n/**\n * This component will call `React.postpone` that throws the postponed error.\n */\ntype PostponeProps = {\n    reason: string;\n    route: string;\n};\nexport declare function Postpone({ reason, route }: PostponeProps): never;\nexport declare function postponeWithTracking(route: string, expression: string, dynamicTracking: null | DynamicTrackingState): never;\nexport declare function isDynamicPostpone(err: unknown): boolean;\ntype DigestError = Error & {\n    digest: string;\n};\nexport declare function isPrerenderInterruptedError(error: unknown): error is DigestError;\nexport declare function accessedDynamicData(dynamicAccesses: Array<DynamicAccess>): boolean;\nexport declare function consumeDynamicAccess(serverDynamic: DynamicTrackingState, clientDynamic: DynamicTrackingState): DynamicTrackingState['dynamicAccesses'];\nexport declare function formatDynamicAPIAccesses(dynamicAccesses: Array<DynamicAccess>): string[];\n/**\n * This is a bit of a hack to allow us to abort a render using a Postpone instance instead of an Error which changes React's\n * abort semantics slightly.\n */\nexport declare function createPostponedAbortSignal(reason: string): AbortSignal;\n/**\n * In a prerender, we may end up with hanging Promises as inputs due them\n * stalling on connection() or because they're loading dynamic data. In that\n * case we need to abort the encoding of arguments since they'll never complete.\n */\nexport declare function createHangingInputAbortSignal(workUnitStore: PrerenderStoreModern): AbortSignal;\nexport declare function annotateDynamicAccess(expression: string, prerenderStore: PrerenderStoreModern): void;\nexport declare function useDynamicRouteParams(expression: string): void;\nexport declare function trackAllowedDynamicAccess(route: string, componentStack: string, dynamicValidation: DynamicValidationState, serverDynamic: DynamicTrackingState, clientDynamic: DynamicTrackingState): void;\nexport declare function throwIfDisallowedDynamic(route: string, dynamicValidation: DynamicValidationState, serverDynamic: DynamicTrackingState, clientDynamic: DynamicTrackingState): void;\nexport {};\n"
        }
    ]
}