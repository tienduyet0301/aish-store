{
    "sourceFile": "node_modules/next/dist/server/app-render/work-async-storage.external.d.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892870923,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import type { AsyncLocalStorage } from 'async_hooks';\nimport type { IncrementalCache } from '../lib/incremental-cache';\nimport type { FetchMetrics } from '../base-http';\nimport type { FallbackRouteParams } from '../request/fallback-params';\nimport type { DeepReadonly } from '../../shared/lib/deep-readonly';\nimport type { AppSegmentConfig } from '../../build/segment-config/app/app-segment-config';\nimport type { AfterContext } from '../after/after-context';\nimport type { CacheLife } from '../use-cache/cache-life';\nimport { workAsyncStorageInstance } from './work-async-storage-instance';\nimport type { LazyResult } from '../lib/lazy-result';\nexport interface WorkStore {\n    readonly isStaticGeneration: boolean;\n    /**\n     * The page that is being rendered. This relates to the path to the page file.\n     */\n    readonly page: string;\n    /**\n     * The route that is being rendered. This is the page property without the\n     * trailing `/page` or `/route` suffix.\n     */\n    readonly route: string;\n    /**\n     * The set of unknown route parameters. Accessing these will be tracked as\n     * a dynamic access.\n     */\n    readonly fallbackRouteParams: FallbackRouteParams | null;\n    readonly incrementalCache?: IncrementalCache;\n    readonly cacheLifeProfiles?: {\n        [profile: string]: CacheLife;\n    };\n    readonly isOnDemandRevalidate?: boolean;\n    readonly isPrerendering?: boolean;\n    readonly isRevalidate?: boolean;\n    forceDynamic?: boolean;\n    fetchCache?: AppSegmentConfig['fetchCache'];\n    forceStatic?: boolean;\n    dynamicShouldError?: boolean;\n    pendingRevalidates?: Record<string, Promise<any>>;\n    pendingRevalidateWrites?: Array<Promise<void>>;\n    readonly afterContext: AfterContext;\n    dynamicUsageDescription?: string;\n    dynamicUsageStack?: string;\n    /**\n     * Invalid usage errors might be caught in userland. We attach them to the\n     * work store to ensure we can still fail the build or dev render.\n     */\n    invalidUsageError?: Error;\n    nextFetchId?: number;\n    pathWasRevalidated?: boolean;\n    /**\n     * Tags that were revalidated during the current request. They need to be sent\n     * to cache handlers to propagate their revalidation.\n     */\n    pendingRevalidatedTags?: string[];\n    /**\n     * Tags that were previously revalidated (e.g. by a redirecting server action)\n     * and have already been sent to cache handlers. Retrieved cache entries that\n     * include any of these tags must be discarded.\n     */\n    readonly previouslyRevalidatedTags: readonly string[];\n    /**\n     * This map contains lazy results so that we can evaluate them when the first\n     * cache entry is read. It allows us to skip refreshing tags if no caches are\n     * read at all.\n     */\n    readonly refreshTagsByCacheKind: Map<string, LazyResult<void>>;\n    fetchMetrics?: FetchMetrics;\n    isDraftMode?: boolean;\n    isUnstableNoStore?: boolean;\n    isPrefetchRequest?: boolean;\n    requestEndedState?: {\n        ended?: boolean;\n    };\n    buildId: string;\n    readonly reactLoadableManifest?: DeepReadonly<Record<string, {\n        files: string[];\n    }>>;\n    readonly assetPrefix?: string;\n    dynamicIOEnabled: boolean;\n    dev: boolean;\n}\nexport type WorkAsyncStorage = AsyncLocalStorage<WorkStore>;\nexport { workAsyncStorageInstance as workAsyncStorage };\n"
        }
    ]
}