{
    "sourceFile": "node_modules/next/dist/server/app-render/work-unit-async-storage.external.d.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892871058,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import type { AsyncLocalStorage } from 'async_hooks';\nimport type { DraftModeProvider } from '../async-storage/draft-mode-provider';\nimport type { ResponseCookies } from '../web/spec-extension/cookies';\nimport type { ReadonlyHeaders } from '../web/spec-extension/adapters/headers';\nimport type { ReadonlyRequestCookies } from '../web/spec-extension/adapters/request-cookies';\nimport type { CacheSignal } from './cache-signal';\nimport type { DynamicTrackingState } from './dynamic-rendering';\nimport { workUnitAsyncStorageInstance } from './work-unit-async-storage-instance';\nimport type { ServerComponentsHmrCache } from '../response-cache';\nimport type { RenderResumeDataCache, PrerenderResumeDataCache } from '../resume-data-cache/resume-data-cache';\nimport type { Params } from '../request/params';\nimport type { ImplicitTags } from '../lib/implicit-tags';\nimport type { WorkStore } from './work-async-storage.external';\nexport type WorkUnitPhase = 'action' | 'render' | 'after';\nexport interface CommonWorkUnitStore {\n    /** NOTE: Will be mutated as phases change */\n    phase: WorkUnitPhase;\n    readonly implicitTags: ImplicitTags;\n}\nexport interface RequestStore extends CommonWorkUnitStore {\n    type: 'request';\n    /**\n     * The URL of the request. This only specifies the pathname and the search\n     * part of the URL.\n     */\n    readonly url: {\n        /**\n         * The pathname of the requested URL.\n         */\n        readonly pathname: string;\n        /**\n         * The search part of the requested URL. If the request did not provide a\n         * search part, this will be an empty string.\n         */\n        readonly search: string;\n    };\n    readonly headers: ReadonlyHeaders;\n    cookies: ReadonlyRequestCookies;\n    readonly mutableCookies: ResponseCookies;\n    readonly userspaceMutableCookies: ResponseCookies;\n    readonly draftMode: DraftModeProvider;\n    readonly isHmrRefresh?: boolean;\n    readonly serverComponentsHmrCache?: ServerComponentsHmrCache;\n    readonly rootParams: Params;\n    /**\n     * The resume data cache for this request. This will be a immutable cache.\n     */\n    renderResumeDataCache: RenderResumeDataCache | null;\n    usedDynamic?: boolean;\n    prerenderPhase?: boolean;\n}\n/**\n * The Prerender store is for tracking information related to prerenders.\n *\n * It can be used for both RSC and SSR prerendering and should be scoped as close\n * to the individual `renderTo...` API call as possible. To keep the type simple\n * we don't distinguish between RSC and SSR prerendering explicitly but instead\n * use conditional object properties to infer which mode we are in. For instance cache tracking\n * only needs to happen during the RSC prerender when we are prospectively prerendering\n * to fill all caches.\n */\nexport interface PrerenderStoreModern extends CommonWorkUnitStore {\n    type: 'prerender';\n    /**\n     * This signal is aborted when the React render is complete. (i.e. it is the same signal passed to react)\n     */\n    readonly renderSignal: AbortSignal;\n    /**\n     * This is the AbortController which represents the boundary between Prerender and dynamic. In some renders it is\n     * the same as the controller for the renderSignal but in others it is a separate controller. It should be aborted\n     * whenever the we are no longer in the prerender phase of rendering. Typically this is after one task or when you call\n     * a sync API which requires the prerender to end immediately\n     */\n    readonly controller: AbortController;\n    /**\n     * when not null this signal is used to track cache reads during prerendering and\n     * to await all cache reads completing before aborting the prerender.\n     */\n    readonly cacheSignal: null | CacheSignal;\n    /**\n     * During some prerenders we want to track dynamic access.\n     */\n    readonly dynamicTracking: null | DynamicTrackingState;\n    readonly rootParams: Params;\n    revalidate: number;\n    expire: number;\n    stale: number;\n    tags: null | string[];\n    /**\n     * The resume data cache for this prerender.\n     */\n    prerenderResumeDataCache: PrerenderResumeDataCache | null;\n    validating?: boolean;\n    /**\n     * The HMR refresh hash is only provided in dev mode. It is needed for the dev\n     * warmup render to ensure that the cache keys will be identical for the\n     * subsequent dynamic render.\n     */\n    readonly hmrRefreshHash: string | undefined;\n}\nexport interface PrerenderStorePPR extends CommonWorkUnitStore {\n    type: 'prerender-ppr';\n    readonly rootParams: Params;\n    readonly dynamicTracking: null | DynamicTrackingState;\n    revalidate: number;\n    expire: number;\n    stale: number;\n    tags: null | string[];\n    /**\n     * The resume data cache for this prerender.\n     */\n    prerenderResumeDataCache: PrerenderResumeDataCache;\n}\nexport interface PrerenderStoreLegacy extends CommonWorkUnitStore {\n    type: 'prerender-legacy';\n    readonly rootParams: Params;\n    revalidate: number;\n    expire: number;\n    stale: number;\n    tags: null | string[];\n}\nexport type PrerenderStore = PrerenderStoreLegacy | PrerenderStorePPR | PrerenderStoreModern;\nexport interface CommonCacheStore extends Omit<CommonWorkUnitStore, 'implicitTags'> {\n    /**\n     * A cache work unit store might not always have an outer work unit store,\n     * from which implicit tags could be inherited.\n     */\n    readonly implicitTags: ImplicitTags | undefined;\n}\nexport interface UseCacheStore extends CommonCacheStore {\n    type: 'cache';\n    revalidate: number;\n    expire: number;\n    stale: number;\n    explicitRevalidate: undefined | number;\n    explicitExpire: undefined | number;\n    explicitStale: undefined | number;\n    tags: null | string[];\n    readonly hmrRefreshHash: string | undefined;\n    readonly isHmrRefresh: boolean;\n    readonly serverComponentsHmrCache: ServerComponentsHmrCache | undefined;\n    readonly forceRevalidate: boolean;\n    readonly draftMode: DraftModeProvider | undefined;\n}\nexport interface UnstableCacheStore extends CommonCacheStore {\n    type: 'unstable-cache';\n    readonly draftMode: DraftModeProvider | undefined;\n}\n/**\n * The Cache store is for tracking information inside a \"use cache\" or unstable_cache context.\n * Inside this context we should never expose any request or page specific information.\n */\nexport type CacheStore = UseCacheStore | UnstableCacheStore;\nexport type WorkUnitStore = RequestStore | CacheStore | PrerenderStore;\nexport type WorkUnitAsyncStorage = AsyncLocalStorage<WorkUnitStore>;\nexport { workUnitAsyncStorageInstance as workUnitAsyncStorage };\nexport declare function getExpectedRequestStore(callingExpression: string): RequestStore;\nexport declare function throwForMissingRequestStore(callingExpression: string): never;\nexport declare function getPrerenderResumeDataCache(workUnitStore: WorkUnitStore): PrerenderResumeDataCache | null;\nexport declare function getRenderResumeDataCache(workUnitStore: WorkUnitStore): RenderResumeDataCache | null;\nexport declare function getHmrRefreshHash(workStore: WorkStore, workUnitStore: WorkUnitStore): string | undefined;\n/**\n * Returns a draft mode provider only if draft mode is enabled.\n */\nexport declare function getDraftModeProviderForCacheScope(workStore: WorkStore, workUnitStore: WorkUnitStore): DraftModeProvider | undefined;\n"
        }
    ]
}