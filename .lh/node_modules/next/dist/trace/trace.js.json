{
    "sourceFile": "node_modules/next/dist/trace/trace.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892911993,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    Span: null,\n    SpanStatus: null,\n    clearTraceEvents: null,\n    exportTraceState: null,\n    flushAllTraces: null,\n    getTraceEvents: null,\n    initializeTraceState: null,\n    recordTraceEvents: null,\n    trace: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    Span: function() {\n        return Span;\n    },\n    SpanStatus: function() {\n        return SpanStatus;\n    },\n    clearTraceEvents: function() {\n        return clearTraceEvents;\n    },\n    exportTraceState: function() {\n        return exportTraceState;\n    },\n    flushAllTraces: function() {\n        return flushAllTraces;\n    },\n    getTraceEvents: function() {\n        return getTraceEvents;\n    },\n    initializeTraceState: function() {\n        return initializeTraceState;\n    },\n    recordTraceEvents: function() {\n        return recordTraceEvents;\n    },\n    trace: function() {\n        return trace;\n    }\n});\nconst _report = require(\"./report\");\nconst NUM_OF_MICROSEC_IN_NANOSEC = BigInt('1000');\nconst NUM_OF_MILLISEC_IN_NANOSEC = BigInt('1000000');\nlet count = 0;\nconst getId = ()=>{\n    count++;\n    return count;\n};\nlet defaultParentSpanId;\nlet shouldSaveTraceEvents;\nlet savedTraceEvents = [];\nconst RECORD_SPAN_THRESHOLD_MS = parseInt(process.env.NEXT_TRACE_SPAN_THRESHOLD_MS ?? '-1');\nvar SpanStatus = /*#__PURE__*/ function(SpanStatus) {\n    SpanStatus[\"Started\"] = \"started\";\n    SpanStatus[\"Stopped\"] = \"stopped\";\n    return SpanStatus;\n}({});\nclass Span {\n    constructor({ name, parentId, attrs, startTime }){\n        this.name = name;\n        this.parentId = parentId ?? defaultParentSpanId;\n        this.attrs = attrs ? {\n            ...attrs\n        } : {};\n        this.status = \"started\";\n        this.id = getId();\n        this._start = startTime || process.hrtime.bigint();\n        // hrtime cannot be used to reconstruct tracing span's actual start time\n        // since it does not have relation to clock time:\n        // `These times are relative to an arbitrary time in the past, and not related to the time of day and therefore not subject to clock drift`\n        // https://nodejs.org/api/process.html#processhrtimetime\n        // Capturing current datetime as additional metadata for external reconstruction.\n        this.now = Date.now();\n    }\n    // Durations are reported as microseconds. This gives 1000x the precision\n    // of something like Date.now(), which reports in milliseconds.\n    // Additionally, ~285 years can be safely represented as microseconds as\n    // a float64 in both JSON and JavaScript.\n    stop(stopTime) {\n        if (this.status === \"stopped\") {\n            // Don't report the same span twice.\n            // TODO: In the future this should throw as `.stop()` shouldn't be called multiple times.\n            return;\n        }\n        const end = stopTime || process.hrtime.bigint();\n        const duration = (end - this._start) / NUM_OF_MICROSEC_IN_NANOSEC;\n        this.status = \"stopped\";\n        if (duration > Number.MAX_SAFE_INTEGER) {\n            throw Object.defineProperty(new Error(`Duration is too long to express as float64: ${duration}`), \"__NEXT_ERROR_CODE\", {\n                value: \"E513\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n        const timestamp = this._start / NUM_OF_MICROSEC_IN_NANOSEC;\n        const traceEvent = {\n            name: this.name,\n            duration: Number(duration),\n            timestamp: Number(timestamp),\n            id: this.id,\n            parentId: this.parentId,\n            tags: this.attrs,\n            startTime: this.now\n        };\n        if (duration > RECORD_SPAN_THRESHOLD_MS * 1000) {\n            _report.reporter.report(traceEvent);\n            if (shouldSaveTraceEvents) {\n                savedTraceEvents.push(traceEvent);\n            }\n        }\n    }\n    traceChild(name, attrs) {\n        return new Span({\n            name,\n            parentId: this.id,\n            attrs\n        });\n    }\n    manualTraceChild(name, // Start time in nanoseconds since epoch.\n    startTime, // Stop time in nanoseconds since epoch.\n    stopTime, attrs) {\n        // We need to convert the time info to the same base as hrtime since that is used usually.\n        const correction = process.hrtime.bigint() - BigInt(Date.now()) * NUM_OF_MILLISEC_IN_NANOSEC;\n        const span = new Span({\n            name,\n            parentId: this.id,\n            attrs,\n            startTime: startTime ? startTime + correction : process.hrtime.bigint()\n        });\n        span.stop(stopTime ? stopTime + correction : process.hrtime.bigint());\n    }\n    getId() {\n        return this.id;\n    }\n    setAttribute(key, value) {\n        this.attrs[key] = value;\n    }\n    traceFn(fn) {\n        try {\n            return fn(this);\n        } finally{\n            this.stop();\n        }\n    }\n    async traceAsyncFn(fn) {\n        try {\n            return await fn(this);\n        } finally{\n            this.stop();\n        }\n    }\n}\nconst trace = (name, parentId, attrs)=>{\n    return new Span({\n        name,\n        parentId,\n        attrs\n    });\n};\nconst flushAllTraces = (opts)=>_report.reporter.flushAll(opts);\nconst exportTraceState = ()=>({\n        defaultParentSpanId,\n        lastId: count,\n        shouldSaveTraceEvents\n    });\nconst initializeTraceState = (state)=>{\n    count = state.lastId;\n    defaultParentSpanId = state.defaultParentSpanId;\n    shouldSaveTraceEvents = state.shouldSaveTraceEvents;\n};\nfunction getTraceEvents() {\n    return savedTraceEvents;\n}\nfunction recordTraceEvents(events) {\n    for (const traceEvent of events){\n        _report.reporter.report(traceEvent);\n        if (traceEvent.id > count) {\n            count = traceEvent.id + 1;\n        }\n    }\n    if (shouldSaveTraceEvents) {\n        savedTraceEvents.push(...events);\n    }\n}\nconst clearTraceEvents = ()=>savedTraceEvents = [];\n\n//# sourceMappingURL=trace.js.map"
        }
    ]
}