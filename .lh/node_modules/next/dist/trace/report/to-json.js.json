{
    "sourceFile": "node_modules/next/dist/trace/report/to-json.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892911677,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    batcher: null,\n    default: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    batcher: function() {\n        return batcher;\n    },\n    default: function() {\n        return _default;\n    }\n});\nconst _shared = require(\"../shared\");\nconst _fs = /*#__PURE__*/ _interop_require_default(require(\"fs\"));\nconst _path = /*#__PURE__*/ _interop_require_default(require(\"path\"));\nconst _constants = require(\"../../shared/lib/constants\");\nfunction _interop_require_default(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nconst localEndpoint = {\n    serviceName: 'nextjs',\n    ipv4: '127.0.0.1',\n    port: 9411\n};\nfunction batcher(reportEvents) {\n    const events = [];\n    // Promise queue to ensure events are always sent on flushAll\n    const queue = new Set();\n    return {\n        flushAll: async ()=>{\n            await Promise.all(queue);\n            if (events.length > 0) {\n                await reportEvents(events);\n                events.length = 0;\n            }\n        },\n        report: (event)=>{\n            events.push(event);\n            if (events.length > 100) {\n                const evts = events.slice();\n                events.length = 0;\n                const report = reportEvents(evts);\n                queue.add(report);\n                report.then(()=>queue.delete(report));\n            }\n        }\n    };\n}\nlet writeStream;\nlet batch;\nconst writeStreamOptions = {\n    flags: 'a',\n    encoding: 'utf8'\n};\nclass RotatingWriteStream {\n    constructor(file, sizeLimit){\n        this.file = file;\n        this.size = 0;\n        this.sizeLimit = sizeLimit;\n        this.createWriteStream();\n    }\n    createWriteStream() {\n        this.writeStream = _fs.default.createWriteStream(this.file, writeStreamOptions);\n    }\n    // Recreate the file\n    async rotate() {\n        await this.end();\n        try {\n            _fs.default.unlinkSync(this.file);\n        } catch (err) {\n            // It's fine if the file does not exist yet\n            if (err.code !== 'ENOENT') {\n                throw err;\n            }\n        }\n        this.size = 0;\n        this.createWriteStream();\n        this.rotatePromise = undefined;\n    }\n    async write(data) {\n        if (this.rotatePromise) await this.rotatePromise;\n        this.size += data.length;\n        if (this.size > this.sizeLimit) {\n            await (this.rotatePromise = this.rotate());\n        }\n        if (!this.writeStream.write(data, 'utf8')) {\n            if (this.drainPromise === undefined) {\n                this.drainPromise = new Promise((resolve, _reject)=>{\n                    this.writeStream.once('drain', ()=>{\n                        this.drainPromise = undefined;\n                        resolve();\n                    });\n                });\n            }\n            await this.drainPromise;\n        }\n    }\n    end() {\n        return new Promise((resolve)=>{\n            this.writeStream.end(resolve);\n        });\n    }\n}\nconst reportToLocalHost = (event)=>{\n    const distDir = _shared.traceGlobals.get('distDir');\n    const phase = _shared.traceGlobals.get('phase');\n    if (!distDir || !phase) {\n        return;\n    }\n    if (!batch) {\n        batch = batcher(async (events)=>{\n            if (!writeStream) {\n                await _fs.default.promises.mkdir(distDir, {\n                    recursive: true\n                });\n                const file = _path.default.join(distDir, 'trace');\n                writeStream = new RotatingWriteStream(file, // Development is limited to 50MB, production is unlimited\n                phase === _constants.PHASE_DEVELOPMENT_SERVER ? 52428800 : Infinity);\n            }\n            const eventsJson = JSON.stringify(events);\n            try {\n                await writeStream.write(eventsJson + '\\n');\n            } catch (err) {\n                console.log(err);\n            }\n        });\n    }\n    batch.report({\n        ...event,\n        traceId: _shared.traceId\n    });\n};\nconst _default = {\n    flushAll: (opts)=>batch ? batch.flushAll().then(()=>{\n            const phase = _shared.traceGlobals.get('phase');\n            // Only end writeStream when manually flushing in production\n            if ((opts == null ? void 0 : opts.end) || phase !== _constants.PHASE_DEVELOPMENT_SERVER) {\n                return writeStream.end();\n            }\n        }) : undefined,\n    report: reportToLocalHost\n};\n\n//# sourceMappingURL=to-json.js.map"
        }
    ]
}