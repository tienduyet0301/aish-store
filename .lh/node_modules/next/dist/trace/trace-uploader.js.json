{
    "sourceFile": "node_modules/next/dist/trace/trace-uploader.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892911920,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nconst _findup = /*#__PURE__*/ _interop_require_default(require(\"next/dist/compiled/find-up\"));\nconst _promises = /*#__PURE__*/ _interop_require_default(require(\"fs/promises\"));\nconst _child_process = /*#__PURE__*/ _interop_require_default(require(\"child_process\"));\nconst _assert = /*#__PURE__*/ _interop_require_default(require(\"assert\"));\nconst _os = /*#__PURE__*/ _interop_require_default(require(\"os\"));\nconst _readline = require(\"readline\");\nconst _fs = require(\"fs\");\nconst _path = /*#__PURE__*/ _interop_require_default(require(\"path\"));\nfunction _interop_require_default(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nconst COMMON_ALLOWED_EVENTS = [\n    'memory-usage'\n];\n// Predefined set of the event names to be included in the trace.\n// If the trace span's name matches to one of the event names in the set,\n// it'll up uploaded to the trace server.\nconst DEV_ALLOWED_EVENTS = new Set([\n    ...COMMON_ALLOWED_EVENTS,\n    'client-hmr-latency',\n    'hot-reloader',\n    'webpack-invalid-client',\n    'webpack-invalidated-server',\n    'navigation-to-hydration',\n    'start-dev-server',\n    'compile-path',\n    'memory-usage',\n    'server-restart-close-to-memory-threshold'\n]);\nconst BUILD_ALLOWED_EVENTS = new Set([\n    ...COMMON_ALLOWED_EVENTS,\n    'next-build',\n    'webpack-compilation',\n    'run-webpack-compiler',\n    'create-entrypoints',\n    'worker-main-edge-server',\n    'worker-main-client',\n    'worker-main-server',\n    'server',\n    'make',\n    'seal',\n    'chunk-graph',\n    'optimize-modules',\n    'optimize-chunks',\n    'optimize',\n    'optimize-tree',\n    'optimize-chunk-modules',\n    'module-hash',\n    'client',\n    'static-check',\n    'node-file-trace-build',\n    'static-generation',\n    'next-export',\n    'verify-typescript-setup',\n    'verify-and-lint'\n]);\nconst { NEXT_TRACE_UPLOAD_DEBUG, // An external env to allow to upload full trace without picking up the relavant spans.\n// This is mainly for the debugging purpose, to allwo manual audit for full trace for the given build.\n// [NOTE] This may fail if build is large and generated trace is excessively large.\nNEXT_TRACE_UPLOAD_FULL } = process.env;\nconst isDebugEnabled = !!NEXT_TRACE_UPLOAD_DEBUG || !!NEXT_TRACE_UPLOAD_FULL;\nconst shouldUploadFullTrace = !!NEXT_TRACE_UPLOAD_FULL;\nconst [, , traceUploadUrl, mode, projectDir, distDir, _isTurboSession, traceId, anonymousId, sessionId] = process.argv;\nconst isTurboSession = _isTurboSession === 'true';\n(async function upload() {\n    const nextVersion = JSON.parse(await _promises.default.readFile(_path.default.resolve(__dirname, '../../package.json'), 'utf8')).version;\n    const projectPkgJsonPath = await (0, _findup.default)('package.json');\n    (0, _assert.default)(projectPkgJsonPath);\n    const projectPkgJson = JSON.parse(await _promises.default.readFile(projectPkgJsonPath, 'utf-8'));\n    const pkgName = projectPkgJson.name;\n    const commit = _child_process.default.spawnSync(_os.default.platform() === 'win32' ? 'git.exe' : 'git', [\n        'rev-parse',\n        'HEAD'\n    ], {\n        shell: true\n    }).stdout.toString().trimEnd();\n    const readLineInterface = (0, _readline.createInterface)({\n        input: (0, _fs.createReadStream)(_path.default.join(projectDir, distDir, 'trace')),\n        crlfDelay: Infinity\n    });\n    const sessionTrace = [];\n    for await (const line of readLineInterface){\n        const lineEvents = JSON.parse(line);\n        for (const event of lineEvents){\n            if (event.traceId !== traceId) {\n                continue;\n            }\n            if (// Always include root spans\n            event.parentId === undefined || shouldUploadFullTrace || (mode === 'dev' ? DEV_ALLOWED_EVENTS.has(event.name) : BUILD_ALLOWED_EVENTS.has(event.name))) {\n                sessionTrace.push(event);\n            }\n        }\n    }\n    const body = {\n        metadata: {\n            anonymousId,\n            arch: _os.default.arch(),\n            commit,\n            cpus: _os.default.cpus().length,\n            isTurboSession,\n            mode,\n            nextVersion,\n            pkgName,\n            platform: _os.default.platform(),\n            sessionId\n        },\n        // The trace file can contain events spanning multiple sessions.\n        // Only submit traces for the current session, as the metadata we send is\n        // intended for this session only.\n        traces: [\n            sessionTrace\n        ]\n    };\n    if (isDebugEnabled) {\n        console.log('Sending request with body', JSON.stringify(body, null, 2));\n    }\n    let res = await fetch(traceUploadUrl, {\n        method: 'POST',\n        headers: {\n            'Content-Type': 'application/json',\n            'x-trace-transfer-mode': shouldUploadFullTrace ? 'full' : 'default'\n        },\n        body: JSON.stringify(body)\n    });\n    if (isDebugEnabled) {\n        console.log('Received response', res.status, await res.json());\n    }\n})();\n\n//# sourceMappingURL=trace-uploader.js.map"
        }
    ]
}