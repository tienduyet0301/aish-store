{
    "sourceFile": "node_modules/next/dist/telemetry/storage.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892911410,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"Telemetry\", {\n    enumerable: true,\n    get: function() {\n        return Telemetry;\n    }\n});\nconst _picocolors = require(\"../lib/picocolors\");\nconst _conf = /*#__PURE__*/ _interop_require_default(require(\"next/dist/compiled/conf\"));\nconst _crypto = require(\"crypto\");\nconst _isdocker = /*#__PURE__*/ _interop_require_default(require(\"next/dist/compiled/is-docker\"));\nconst _path = /*#__PURE__*/ _interop_require_default(require(\"path\"));\nconst _anonymousmeta = require(\"./anonymous-meta\");\nconst _ciinfo = /*#__PURE__*/ _interop_require_wildcard(require(\"../server/ci-info\"));\nconst _posttelemetrypayload = require(\"./post-telemetry-payload\");\nconst _projectid = require(\"./project-id\");\nconst _ponyfill = require(\"next/dist/compiled/@edge-runtime/ponyfill\");\nconst _fs = /*#__PURE__*/ _interop_require_default(require(\"fs\"));\nfunction _interop_require_default(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nfunction _getRequireWildcardCache(nodeInterop) {\n    if (typeof WeakMap !== \"function\") return null;\n    var cacheBabelInterop = new WeakMap();\n    var cacheNodeInterop = new WeakMap();\n    return (_getRequireWildcardCache = function(nodeInterop) {\n        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n    })(nodeInterop);\n}\nfunction _interop_require_wildcard(obj, nodeInterop) {\n    if (!nodeInterop && obj && obj.__esModule) {\n        return obj;\n    }\n    if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n        return {\n            default: obj\n        };\n    }\n    var cache = _getRequireWildcardCache(nodeInterop);\n    if (cache && cache.has(obj)) {\n        return cache.get(obj);\n    }\n    var newObj = {\n        __proto__: null\n    };\n    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n    for(var key in obj){\n        if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n            if (desc && (desc.get || desc.set)) {\n                Object.defineProperty(newObj, key, desc);\n            } else {\n                newObj[key] = obj[key];\n            }\n        }\n    }\n    newObj.default = obj;\n    if (cache) {\n        cache.set(obj, newObj);\n    }\n    return newObj;\n}\n// This is the key that stores whether or not telemetry is enabled or disabled.\nconst TELEMETRY_KEY_ENABLED = 'telemetry.enabled';\n// This is the key that specifies when the user was informed about anonymous\n// telemetry collection.\nconst TELEMETRY_KEY_NOTIFY_DATE = 'telemetry.notifiedAt';\n// This is a quasi-persistent identifier used to dedupe recurring events. It's\n// generated from random data and completely anonymous.\nconst TELEMETRY_KEY_ID = `telemetry.anonymousId`;\n// This is the cryptographic salt that is included within every hashed value.\n// This salt value is never sent to us, ensuring privacy and the one-way nature\n// of the hash (prevents dictionary lookups of pre-computed hashes).\n// See the `oneWayHash` function.\nconst TELEMETRY_KEY_SALT = `telemetry.salt`;\nfunction getStorageDirectory(distDir) {\n    const isLikelyEphemeral = _ciinfo.isCI || (0, _isdocker.default)();\n    if (isLikelyEphemeral) {\n        return _path.default.join(distDir, 'cache');\n    }\n    return undefined;\n}\nclass Telemetry {\n    constructor({ distDir }){\n        this.notify = ()=>{\n            if (this.isDisabled || !this.conf) {\n                return;\n            }\n            // The end-user has already been notified about our telemetry integration. We\n            // don't need to constantly annoy them about it.\n            // We will re-inform users about the telemetry if significant changes are\n            // ever made.\n            if (this.conf.get(TELEMETRY_KEY_NOTIFY_DATE, '')) {\n                return;\n            }\n            this.conf.set(TELEMETRY_KEY_NOTIFY_DATE, Date.now().toString());\n            console.log(`${(0, _picocolors.magenta)((0, _picocolors.bold)('Attention'))}: Next.js now collects completely anonymous telemetry regarding usage.`);\n            console.log(`This information is used to shape Next.js' roadmap and prioritize features.`);\n            console.log(`You can learn more, including how to opt-out if you'd not like to participate in this anonymous program, by visiting the following URL:`);\n            console.log((0, _picocolors.cyan)('https://nextjs.org/telemetry'));\n            console.log();\n        };\n        this.setEnabled = (_enabled)=>{\n            const enabled = !!_enabled;\n            this.conf && this.conf.set(TELEMETRY_KEY_ENABLED, enabled);\n            return this.conf && this.conf.path;\n        };\n        this.oneWayHash = (payload)=>{\n            const hash = (0, _crypto.createHash)('sha256');\n            // Always prepend the payload value with salt. This ensures the hash is truly\n            // one-way.\n            hash.update(this.salt);\n            // Update is an append operation, not a replacement. The salt from the prior\n            // update is still present!\n            hash.update(payload);\n            return hash.digest('hex');\n        };\n        this.record = (_events, deferred)=>{\n            const prom = (deferred ? // flushDetached we can skip starting the initial\n            // submitRecord which will then be cancelled\n            new Promise((resolve)=>resolve({\n                    isFulfilled: true,\n                    isRejected: false,\n                    value: _events\n                })) : this.submitRecord(_events)).then((value)=>({\n                    isFulfilled: true,\n                    isRejected: false,\n                    value\n                })).catch((reason)=>({\n                    isFulfilled: false,\n                    isRejected: true,\n                    reason\n                }))// Acts as `Promise#finally` because `catch` transforms the error\n            .then((res)=>{\n                // Clean up the event to prevent unbounded `Set` growth\n                if (!deferred) {\n                    this.queue.delete(prom);\n                }\n                return res;\n            });\n            prom._events = Array.isArray(_events) ? _events : [\n                _events\n            ];\n            prom._controller = prom._controller;\n            // Track this `Promise` so we can flush pending events\n            this.queue.add(prom);\n            return prom;\n        };\n        this.flush = async ()=>Promise.all(this.queue).catch(()=>null);\n        // writes current events to disk and spawns separate\n        // detached process to submit the records without blocking\n        // the main process from exiting\n        this.flushDetached = (mode, dir)=>{\n            const allEvents = [];\n            this.queue.forEach((item)=>{\n                try {\n                    var _item__controller;\n                    (_item__controller = item._controller) == null ? void 0 : _item__controller.abort();\n                    allEvents.push(...item._events);\n                } catch (_) {\n                // if we fail to abort ignore this event\n                }\n            });\n            _fs.default.mkdirSync(this.distDir, {\n                recursive: true\n            });\n            _fs.default.writeFileSync(_path.default.join(this.distDir, '_events.json'), JSON.stringify(allEvents));\n            // Note: cross-spawn is not used here as it causes\n            // a new command window to appear when we don't want it to\n            const child_process = require('child_process');\n            // we use spawnSync when debugging to ensure logs are piped\n            // correctly to stdout/stderr\n            const spawn = this.NEXT_TELEMETRY_DEBUG ? child_process.spawnSync : child_process.spawn;\n            spawn(process.execPath, [\n                require.resolve('./detached-flush'),\n                mode,\n                dir\n            ], {\n                detached: !this.NEXT_TELEMETRY_DEBUG,\n                windowsHide: true,\n                shell: false,\n                ...this.NEXT_TELEMETRY_DEBUG ? {\n                    stdio: 'inherit'\n                } : {}\n            });\n        };\n        this.submitRecord = async (_events)=>{\n            let events;\n            if (Array.isArray(_events)) {\n                events = _events;\n            } else {\n                events = [\n                    _events\n                ];\n            }\n            if (events.length < 1) {\n                return Promise.resolve();\n            }\n            if (this.NEXT_TELEMETRY_DEBUG) {\n                // Print to standard error to simplify selecting the output\n                events.forEach(({ eventName, payload })=>console.error(`[telemetry] ` + JSON.stringify({\n                        eventName,\n                        payload\n                    }, null, 2)));\n                // Do not send the telemetry data if debugging. Users may use this feature\n                // to preview what data would be sent.\n                return Promise.resolve();\n            }\n            // Skip recording telemetry if the feature is disabled\n            if (this.isDisabled) {\n                return Promise.resolve();\n            }\n            const postController = new _ponyfill.AbortController();\n            const res = (0, _posttelemetrypayload.postNextTelemetryPayload)({\n                context: {\n                    anonymousId: this.anonymousId,\n                    projectId: await this.getProjectId(),\n                    sessionId: this.sessionId\n                },\n                meta: (0, _anonymousmeta.getAnonymousMeta)(),\n                events: events.map(({ eventName, payload })=>({\n                        eventName,\n                        fields: payload\n                    }))\n            }, postController.signal);\n            res._controller = postController;\n            return res;\n        };\n        // Read in the constructor so that .env can be loaded before reading\n        const { NEXT_TELEMETRY_DISABLED, NEXT_TELEMETRY_DEBUG } = process.env;\n        this.NEXT_TELEMETRY_DISABLED = NEXT_TELEMETRY_DISABLED;\n        this.NEXT_TELEMETRY_DEBUG = NEXT_TELEMETRY_DEBUG;\n        this.distDir = distDir;\n        const storageDirectory = getStorageDirectory(distDir);\n        try {\n            // `conf` incorrectly throws a permission error during initialization\n            // instead of waiting for first use. We need to handle it, otherwise the\n            // process may crash.\n            this.conf = new _conf.default({\n                projectName: 'nextjs',\n                cwd: storageDirectory\n            });\n        } catch (_) {\n            this.conf = null;\n        }\n        this.sessionId = (0, _crypto.randomBytes)(32).toString('hex');\n        this.queue = new Set();\n        this.notify();\n    }\n    get anonymousId() {\n        const val = this.conf && this.conf.get(TELEMETRY_KEY_ID);\n        if (val) {\n            return val;\n        }\n        const generated = (0, _crypto.randomBytes)(32).toString('hex');\n        this.conf && this.conf.set(TELEMETRY_KEY_ID, generated);\n        return generated;\n    }\n    get salt() {\n        const val = this.conf && this.conf.get(TELEMETRY_KEY_SALT);\n        if (val) {\n            return val;\n        }\n        const generated = (0, _crypto.randomBytes)(16).toString('hex');\n        this.conf && this.conf.set(TELEMETRY_KEY_SALT, generated);\n        return generated;\n    }\n    get isDisabled() {\n        if (!!this.NEXT_TELEMETRY_DISABLED || !this.conf) {\n            return true;\n        }\n        return this.conf.get(TELEMETRY_KEY_ENABLED, true) === false;\n    }\n    get isEnabled() {\n        return !this.NEXT_TELEMETRY_DISABLED && !!this.conf && this.conf.get(TELEMETRY_KEY_ENABLED, true) !== false;\n    }\n    async getProjectId() {\n        this.loadProjectId = this.loadProjectId || (0, _projectid.getRawProjectId)();\n        return this.oneWayHash(await this.loadProjectId);\n    }\n}\n\n//# sourceMappingURL=storage.js.map"
        }
    ]
}