{
    "sourceFile": "node_modules/next/dist/lib/typescript/getTypeScriptConfiguration.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892864607,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"getTypeScriptConfiguration\", {\n    enumerable: true,\n    get: function() {\n        return getTypeScriptConfiguration;\n    }\n});\nconst _picocolors = require(\"../picocolors\");\nconst _os = /*#__PURE__*/ _interop_require_default(require(\"os\"));\nconst _path = /*#__PURE__*/ _interop_require_default(require(\"path\"));\nconst _fatalerror = require(\"../fatal-error\");\nconst _iserror = /*#__PURE__*/ _interop_require_default(require(\"../is-error\"));\nfunction _interop_require_default(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nasync function getTypeScriptConfiguration(ts, tsConfigPath, metaOnly) {\n    try {\n        var _result_errors;\n        const formatDiagnosticsHost = {\n            getCanonicalFileName: (fileName)=>fileName,\n            getCurrentDirectory: ts.sys.getCurrentDirectory,\n            getNewLine: ()=>_os.default.EOL\n        };\n        const { config, error } = ts.readConfigFile(tsConfigPath, ts.sys.readFile);\n        if (error) {\n            throw Object.defineProperty(new _fatalerror.FatalError(ts.formatDiagnostic(error, formatDiagnosticsHost)), \"__NEXT_ERROR_CODE\", {\n                value: \"E394\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n        let configToParse = config;\n        const result = ts.parseJsonConfigFileContent(configToParse, // When only interested in meta info,\n        // avoid enumerating all files (for performance reasons)\n        metaOnly ? {\n            ...ts.sys,\n            readDirectory (_path, extensions, _excludes, _includes, _depth) {\n                return [\n                    extensions ? `file${extensions[0]}` : `file.ts`\n                ];\n            }\n        } : ts.sys, _path.default.dirname(tsConfigPath));\n        if (result.errors) {\n            result.errors = result.errors.filter(({ code })=>// No inputs were found in config file\n                code !== 18003);\n        }\n        if ((_result_errors = result.errors) == null ? void 0 : _result_errors.length) {\n            throw Object.defineProperty(new _fatalerror.FatalError(ts.formatDiagnostic(result.errors[0], formatDiagnosticsHost)), \"__NEXT_ERROR_CODE\", {\n                value: \"E394\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n        return result;\n    } catch (err) {\n        if ((0, _iserror.default)(err) && err.name === 'SyntaxError') {\n            const reason = '\\n' + (err.message ?? '');\n            throw Object.defineProperty(new _fatalerror.FatalError((0, _picocolors.bold)('Could not parse' + (0, _picocolors.cyan)('tsconfig.json') + '.' + ' Please make sure it contains syntactically correct JSON.') + reason), \"__NEXT_ERROR_CODE\", {\n                value: \"E339\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n        throw err;\n    }\n}\n\n//# sourceMappingURL=getTypeScriptConfiguration.js.map"
        }
    ]
}