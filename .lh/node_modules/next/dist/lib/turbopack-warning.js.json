{
    "sourceFile": "node_modules/next/dist/lib/turbopack-warning.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892864450,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"validateTurboNextConfig\", {\n    enumerable: true,\n    get: function() {\n        return validateTurboNextConfig;\n    }\n});\nconst _path = /*#__PURE__*/ _interop_require_default(require(\"path\"));\nconst _config = /*#__PURE__*/ _interop_require_default(require(\"../server/config\"));\nconst _log = /*#__PURE__*/ _interop_require_wildcard(require(\"../build/output/log\"));\nconst _constants = require(\"../shared/lib/constants\");\nfunction _interop_require_default(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nfunction _getRequireWildcardCache(nodeInterop) {\n    if (typeof WeakMap !== \"function\") return null;\n    var cacheBabelInterop = new WeakMap();\n    var cacheNodeInterop = new WeakMap();\n    return (_getRequireWildcardCache = function(nodeInterop) {\n        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n    })(nodeInterop);\n}\nfunction _interop_require_wildcard(obj, nodeInterop) {\n    if (!nodeInterop && obj && obj.__esModule) {\n        return obj;\n    }\n    if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n        return {\n            default: obj\n        };\n    }\n    var cache = _getRequireWildcardCache(nodeInterop);\n    if (cache && cache.has(obj)) {\n        return cache.get(obj);\n    }\n    var newObj = {\n        __proto__: null\n    };\n    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n    for(var key in obj){\n        if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n            if (desc && (desc.get || desc.set)) {\n                Object.defineProperty(newObj, key, desc);\n            } else {\n                newObj[key] = obj[key];\n            }\n        }\n    }\n    newObj.default = obj;\n    if (cache) {\n        cache.set(obj, newObj);\n    }\n    return newObj;\n}\nconst unsupportedTurbopackNextConfigOptions = [\n    // is this supported?\n    // 'amp',\n    // 'experimental.amp',\n    // Left to be implemented (priority)\n    // 'experimental.clientRouterFilter',\n    // 'experimental.optimizePackageImports',\n    // 'compiler.emotion',\n    // 'compiler.reactRemoveProperties',\n    // 'compiler.relay',\n    // 'compiler.removeConsole',\n    // 'compiler.styledComponents',\n    'experimental.fetchCacheKeyPrefix',\n    // Left to be implemented\n    // 'excludeDefaultMomentLocales',\n    // 'experimental.optimizeServerReact',\n    'experimental.clientRouterFilterAllowedRate',\n    // 'experimental.serverMinification',\n    // 'experimental.serverSourceMaps',\n    'experimental.allowedRevalidateHeaderKeys',\n    'experimental.extensionAlias',\n    'experimental.fallbackNodePolyfills',\n    'experimental.sri.algorithm',\n    'experimental.swcTraceProfiling',\n    'experimental.typedRoutes',\n    // Left to be implemented (Might not be needed for Turbopack)\n    'experimental.craCompat',\n    'experimental.disablePostcssPresetEnv',\n    'experimental.esmExternals',\n    // This is used to force swc-loader to run regardless of finding Babel.\n    'experimental.forceSwcTransforms',\n    'experimental.fullySpecified',\n    'experimental.urlImports',\n    'experimental.slowModuleDetection'\n];\n// The following will need to be supported by `next build --turbopack`\nconst unsupportedProductionSpecificTurbopackNextConfigOptions = [];\nasync function validateTurboNextConfig({ dir, isDev }) {\n    const { getPkgManager } = require('../lib/helpers/get-pkg-manager');\n    const { getBabelConfigFile } = require('../build/get-babel-config-file');\n    const { defaultConfig } = require('../server/config-shared');\n    const { bold, cyan, red, underline } = require('../lib/picocolors');\n    const { interopDefault } = require('../lib/interop-default');\n    let unsupportedParts = '';\n    let babelrc = await getBabelConfigFile(dir);\n    if (babelrc) babelrc = _path.default.basename(babelrc);\n    let hasWebpackConfig = false;\n    let hasTurboConfig = false;\n    let unsupportedConfig = [];\n    let rawNextConfig = {};\n    const phase = isDev ? _constants.PHASE_DEVELOPMENT_SERVER : _constants.PHASE_PRODUCTION_BUILD;\n    try {\n        rawNextConfig = interopDefault(await (0, _config.default)(phase, dir, {\n            rawConfig: true\n        }));\n        if (typeof rawNextConfig === 'function') {\n            rawNextConfig = rawNextConfig(phase, {\n                defaultConfig\n            });\n        }\n        const flattenKeys = (obj, prefix = '')=>{\n            let keys = [];\n            for(const key in obj){\n                if (typeof (obj == null ? void 0 : obj[key]) === 'undefined') {\n                    continue;\n                }\n                const pre = prefix.length ? `${prefix}.` : '';\n                if (typeof obj[key] === 'object' && !Array.isArray(obj[key]) && obj[key] !== null) {\n                    keys = keys.concat(flattenKeys(obj[key], pre + key));\n                } else {\n                    keys.push(pre + key);\n                }\n            }\n            return keys;\n        };\n        const getDeepValue = (obj, keys)=>{\n            if (typeof keys === 'string') {\n                keys = keys.split('.');\n            }\n            if (keys.length === 1) {\n                return obj == null ? void 0 : obj[keys == null ? void 0 : keys[0]];\n            }\n            return getDeepValue(obj == null ? void 0 : obj[keys == null ? void 0 : keys[0]], keys.slice(1));\n        };\n        const customKeys = flattenKeys(rawNextConfig);\n        let unsupportedKeys = isDev ? unsupportedTurbopackNextConfigOptions : [\n            ...unsupportedTurbopackNextConfigOptions,\n            ...unsupportedProductionSpecificTurbopackNextConfigOptions\n        ];\n        for (const key of customKeys){\n            if (key.startsWith('webpack') && rawNextConfig.webpack) {\n                hasWebpackConfig = true;\n            }\n            if (key.startsWith('turbopack')) {\n                hasTurboConfig = true;\n            }\n            let isUnsupported = unsupportedKeys.some((unsupportedKey)=>// Either the key matches (or is a more specific subkey) of\n                // unsupportedKey, or the key is the path to a specific subkey.\n                // | key     | unsupportedKey |\n                // |---------|----------------|\n                // | foo     | foo            |\n                // | foo.bar | foo            |\n                // | foo     | foo.bar        |\n                key.startsWith(unsupportedKey) || unsupportedKey.startsWith(`${key}.`)) && getDeepValue(rawNextConfig, key) !== getDeepValue(defaultConfig, key);\n            if (isUnsupported) {\n                unsupportedConfig.push(key);\n            }\n        }\n    } catch (e) {\n        _log.error('Unexpected error occurred while checking config', e);\n    }\n    const feedbackMessage = `Learn more about Next.js and Turbopack: ${underline('https://nextjs.org/docs/architecture/turbopack')}\\n`;\n    if (hasWebpackConfig && !hasTurboConfig) {\n        _log.warn(`Webpack is configured while Turbopack is not, which may cause problems.`);\n        _log.warn(`See instructions if you need to configure Turbopack:\\n  https://nextjs.org/docs/app/api-reference/next-config-js/turbo\\n`);\n    }\n    if (babelrc) {\n        unsupportedParts += `Babel detected (${cyan(babelrc)})\\n  Babel is not yet supported. To use Turbopack at the moment,\\n  you'll need to remove your usage of Babel.`;\n    }\n    if (unsupportedConfig.length === 1 && unsupportedConfig[0] === 'experimental.optimizePackageImports') {\n        _log.warn(`'experimental.optimizePackageImports' is not yet supported by Turbopack and will be ignored.`);\n    } else if (unsupportedConfig.length) {\n        unsupportedParts += `\\n\\n- Unsupported Next.js configuration option(s) (${cyan('next.config.js')})\\n  To use Turbopack, remove the following configuration options:\\n${unsupportedConfig.map((name)=>`    - ${red(name)}\\n`).join('')}`;\n    }\n    if (unsupportedParts) {\n        const pkgManager = getPkgManager(dir);\n        _log.error(`You are using configuration and/or tools that are not yet\\nsupported by Next.js with Turbopack:\\n${unsupportedParts}\\n\nIf you cannot make the changes above, but still want to try out\\nNext.js with Turbopack, create the Next.js playground app\\nby running the following commands:\n\n  ${bold(cyan(`${pkgManager === 'npm' ? 'npx create-next-app' : `${pkgManager} create next-app`} --example with-turbopack with-turbopack-app`))}\\n  cd with-turbopack-app\\n  ${pkgManager} run dev\n        `);\n        _log.warn(feedbackMessage);\n        process.exit(1);\n    }\n    return rawNextConfig;\n}\n\n//# sourceMappingURL=turbopack-warning.js.map"
        }
    ]
}