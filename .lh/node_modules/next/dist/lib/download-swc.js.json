{
    "sourceFile": "node_modules/next/dist/lib/download-swc.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892857275,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    downloadNativeNextSwc: null,\n    downloadWasmSwc: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    downloadNativeNextSwc: function() {\n        return downloadNativeNextSwc;\n    },\n    downloadWasmSwc: function() {\n        return downloadWasmSwc;\n    }\n});\nconst _fs = /*#__PURE__*/ _interop_require_default(require(\"fs\"));\nconst _path = /*#__PURE__*/ _interop_require_default(require(\"path\"));\nconst _log = /*#__PURE__*/ _interop_require_wildcard(require(\"../build/output/log\"));\nconst _tar = /*#__PURE__*/ _interop_require_default(require(\"next/dist/compiled/tar\"));\nconst _getregistry = require(\"./helpers/get-registry\");\nconst _getcachedirectory = require(\"./helpers/get-cache-directory\");\nfunction _interop_require_default(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nfunction _getRequireWildcardCache(nodeInterop) {\n    if (typeof WeakMap !== \"function\") return null;\n    var cacheBabelInterop = new WeakMap();\n    var cacheNodeInterop = new WeakMap();\n    return (_getRequireWildcardCache = function(nodeInterop) {\n        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n    })(nodeInterop);\n}\nfunction _interop_require_wildcard(obj, nodeInterop) {\n    if (!nodeInterop && obj && obj.__esModule) {\n        return obj;\n    }\n    if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n        return {\n            default: obj\n        };\n    }\n    var cache = _getRequireWildcardCache(nodeInterop);\n    if (cache && cache.has(obj)) {\n        return cache.get(obj);\n    }\n    var newObj = {\n        __proto__: null\n    };\n    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n    for(var key in obj){\n        if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n            if (desc && (desc.get || desc.set)) {\n                Object.defineProperty(newObj, key, desc);\n            } else {\n                newObj[key] = obj[key];\n            }\n        }\n    }\n    newObj.default = obj;\n    if (cache) {\n        cache.set(obj, newObj);\n    }\n    return newObj;\n}\nconst { WritableStream } = require('node:stream/web');\nconst MAX_VERSIONS_TO_CACHE = 8;\nasync function extractBinary(outputDirectory, pkgName, tarFileName) {\n    const cacheDirectory = (0, _getcachedirectory.getCacheDirectory)('next-swc', process.env['NEXT_SWC_PATH']);\n    const extractFromTar = ()=>_tar.default.x({\n            file: _path.default.join(cacheDirectory, tarFileName),\n            cwd: outputDirectory,\n            strip: 1\n        });\n    if (!_fs.default.existsSync(_path.default.join(cacheDirectory, tarFileName))) {\n        _log.info(`Downloading swc package ${pkgName}... to ${cacheDirectory}`);\n        await _fs.default.promises.mkdir(cacheDirectory, {\n            recursive: true\n        });\n        const tempFile = _path.default.join(cacheDirectory, `${tarFileName}.temp-${Date.now()}`);\n        const registry = (0, _getregistry.getRegistry)();\n        const downloadUrl = `${registry}${pkgName}/-/${tarFileName}`;\n        await fetch(downloadUrl).then((res)=>{\n            const { ok, body } = res;\n            if (!ok || !body) {\n                _log.error(`Failed to download swc package from ${downloadUrl}`);\n            }\n            if (!ok) {\n                throw Object.defineProperty(new Error(`request failed with status ${res.status}`), \"__NEXT_ERROR_CODE\", {\n                    value: \"E109\",\n                    enumerable: false,\n                    configurable: true\n                });\n            }\n            if (!body) {\n                throw Object.defineProperty(new Error('request failed with empty body'), \"__NEXT_ERROR_CODE\", {\n                    value: \"E143\",\n                    enumerable: false,\n                    configurable: true\n                });\n            }\n            const cacheWriteStream = _fs.default.createWriteStream(tempFile);\n            return body.pipeTo(new WritableStream({\n                write (chunk) {\n                    return new Promise((resolve, reject)=>cacheWriteStream.write(chunk, (error)=>{\n                            if (error) {\n                                reject(error);\n                                return;\n                            }\n                            resolve();\n                        }));\n                },\n                close () {\n                    return new Promise((resolve, reject)=>cacheWriteStream.close((error)=>{\n                            if (error) {\n                                reject(error);\n                                return;\n                            }\n                            resolve();\n                        }));\n                }\n            }));\n        });\n        await _fs.default.promises.access(tempFile) // ensure the temp file existed\n        ;\n        await _fs.default.promises.rename(tempFile, _path.default.join(cacheDirectory, tarFileName));\n    } else {\n        _log.info(`Using cached swc package ${pkgName}...`);\n    }\n    await extractFromTar();\n    const cacheFiles = await _fs.default.promises.readdir(cacheDirectory);\n    if (cacheFiles.length > MAX_VERSIONS_TO_CACHE) {\n        cacheFiles.sort((a, b)=>{\n            if (a.length < b.length) return -1;\n            return a.localeCompare(b);\n        });\n        // prune oldest versions in cache\n        for(let i = 0; i++; i < cacheFiles.length - MAX_VERSIONS_TO_CACHE){\n            await _fs.default.promises.unlink(_path.default.join(cacheDirectory, cacheFiles[i])).catch(()=>{});\n        }\n    }\n}\nasync function downloadNativeNextSwc(version, bindingsDirectory, triplesABI) {\n    for (const triple of triplesABI){\n        const pkgName = `@next/swc-${triple}`;\n        const tarFileName = `${pkgName.substring(6)}-${version}.tgz`;\n        const outputDirectory = _path.default.join(bindingsDirectory, pkgName);\n        if (_fs.default.existsSync(outputDirectory)) {\n            // if the package is already downloaded a different\n            // failure occurred than not being present\n            return;\n        }\n        await _fs.default.promises.mkdir(outputDirectory, {\n            recursive: true\n        });\n        await extractBinary(outputDirectory, pkgName, tarFileName);\n    }\n}\nasync function downloadWasmSwc(version, wasmDirectory, variant = 'nodejs') {\n    const pkgName = `@next/swc-wasm-${variant}`;\n    const tarFileName = `${pkgName.substring(6)}-${version}.tgz`;\n    const outputDirectory = _path.default.join(wasmDirectory, pkgName);\n    if (_fs.default.existsSync(outputDirectory)) {\n        // if the package is already downloaded a different\n        // failure occurred than not being present\n        return;\n    }\n    await _fs.default.promises.mkdir(outputDirectory, {\n        recursive: true\n    });\n    await extractBinary(outputDirectory, pkgName, tarFileName);\n}\n\n//# sourceMappingURL=download-swc.js.map"
        }
    ]
}