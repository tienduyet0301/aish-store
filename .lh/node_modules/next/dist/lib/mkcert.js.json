{
    "sourceFile": "node_modules/next/dist/lib/mkcert.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892862866,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"createSelfSignedCertificate\", {\n    enumerable: true,\n    get: function() {\n        return createSelfSignedCertificate;\n    }\n});\nconst _nodefs = /*#__PURE__*/ _interop_require_default(require(\"node:fs\"));\nconst _nodepath = /*#__PURE__*/ _interop_require_default(require(\"node:path\"));\nconst _nodecrypto = require(\"node:crypto\");\nconst _getcachedirectory = require(\"./helpers/get-cache-directory\");\nconst _log = /*#__PURE__*/ _interop_require_wildcard(require(\"../build/output/log\"));\nconst _nodechild_process = require(\"node:child_process\");\nfunction _interop_require_default(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nfunction _getRequireWildcardCache(nodeInterop) {\n    if (typeof WeakMap !== \"function\") return null;\n    var cacheBabelInterop = new WeakMap();\n    var cacheNodeInterop = new WeakMap();\n    return (_getRequireWildcardCache = function(nodeInterop) {\n        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n    })(nodeInterop);\n}\nfunction _interop_require_wildcard(obj, nodeInterop) {\n    if (!nodeInterop && obj && obj.__esModule) {\n        return obj;\n    }\n    if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n        return {\n            default: obj\n        };\n    }\n    var cache = _getRequireWildcardCache(nodeInterop);\n    if (cache && cache.has(obj)) {\n        return cache.get(obj);\n    }\n    var newObj = {\n        __proto__: null\n    };\n    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n    for(var key in obj){\n        if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n            if (desc && (desc.get || desc.set)) {\n                Object.defineProperty(newObj, key, desc);\n            } else {\n                newObj[key] = obj[key];\n            }\n        }\n    }\n    newObj.default = obj;\n    if (cache) {\n        cache.set(obj, newObj);\n    }\n    return newObj;\n}\nconst { WritableStream } = require('node:stream/web');\nconst MKCERT_VERSION = 'v1.4.4';\nfunction getBinaryName() {\n    const platform = process.platform;\n    const arch = process.arch === 'x64' ? 'amd64' : process.arch;\n    if (platform === 'win32') {\n        return `mkcert-${MKCERT_VERSION}-windows-${arch}.exe`;\n    }\n    if (platform === 'darwin') {\n        return `mkcert-${MKCERT_VERSION}-darwin-${arch}`;\n    }\n    if (platform === 'linux') {\n        return `mkcert-${MKCERT_VERSION}-linux-${arch}`;\n    }\n    throw Object.defineProperty(new Error(`Unsupported platform: ${platform}`), \"__NEXT_ERROR_CODE\", {\n        value: \"E141\",\n        enumerable: false,\n        configurable: true\n    });\n}\nasync function downloadBinary() {\n    try {\n        const binaryName = getBinaryName();\n        const cacheDirectory = (0, _getcachedirectory.getCacheDirectory)('mkcert');\n        const binaryPath = _nodepath.default.join(cacheDirectory, binaryName);\n        if (_nodefs.default.existsSync(binaryPath)) {\n            return binaryPath;\n        }\n        const downloadUrl = `https://github.com/FiloSottile/mkcert/releases/download/${MKCERT_VERSION}/${binaryName}`;\n        await _nodefs.default.promises.mkdir(cacheDirectory, {\n            recursive: true\n        });\n        _log.info(`Downloading mkcert package...`);\n        const response = await fetch(downloadUrl);\n        if (!response.ok || !response.body) {\n            throw Object.defineProperty(new Error(`request failed with status ${response.status}`), \"__NEXT_ERROR_CODE\", {\n                value: \"E109\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n        _log.info(`Download response was successful, writing to disk`);\n        const binaryWriteStream = _nodefs.default.createWriteStream(binaryPath);\n        await response.body.pipeTo(new WritableStream({\n            write (chunk) {\n                return new Promise((resolve, reject)=>{\n                    binaryWriteStream.write(chunk, (error)=>{\n                        if (error) {\n                            reject(error);\n                            return;\n                        }\n                        resolve();\n                    });\n                });\n            },\n            close () {\n                return new Promise((resolve, reject)=>{\n                    binaryWriteStream.close((error)=>{\n                        if (error) {\n                            reject(error);\n                            return;\n                        }\n                        resolve();\n                    });\n                });\n            }\n        }));\n        await _nodefs.default.promises.chmod(binaryPath, 493);\n        return binaryPath;\n    } catch (err) {\n        _log.error('Error downloading mkcert:', err);\n    }\n}\nasync function createSelfSignedCertificate(host, certDir = 'certificates') {\n    try {\n        const binaryPath = await downloadBinary();\n        if (!binaryPath) throw Object.defineProperty(new Error('missing mkcert binary'), \"__NEXT_ERROR_CODE\", {\n            value: \"E198\",\n            enumerable: false,\n            configurable: true\n        });\n        const resolvedCertDir = _nodepath.default.resolve(process.cwd(), `./${certDir}`);\n        await _nodefs.default.promises.mkdir(resolvedCertDir, {\n            recursive: true\n        });\n        const keyPath = _nodepath.default.resolve(resolvedCertDir, 'localhost-key.pem');\n        const certPath = _nodepath.default.resolve(resolvedCertDir, 'localhost.pem');\n        if (_nodefs.default.existsSync(keyPath) && _nodefs.default.existsSync(certPath)) {\n            const cert = new _nodecrypto.X509Certificate(_nodefs.default.readFileSync(certPath));\n            const key = _nodefs.default.readFileSync(keyPath);\n            if (cert.checkHost(host ?? 'localhost') && cert.checkPrivateKey((0, _nodecrypto.createPrivateKey)(key))) {\n                _log.info('Using already generated self signed certificate');\n                const caLocation = (0, _nodechild_process.execSync)(`\"${binaryPath}\" -CAROOT`).toString().trim();\n                return {\n                    key: keyPath,\n                    cert: certPath,\n                    rootCA: `${caLocation}/rootCA.pem`\n                };\n            }\n        }\n        _log.info('Attempting to generate self signed certificate. This may prompt for your password');\n        const defaultHosts = [\n            'localhost',\n            '127.0.0.1',\n            '::1'\n        ];\n        const hosts = host && !defaultHosts.includes(host) ? [\n            ...defaultHosts,\n            host\n        ] : defaultHosts;\n        (0, _nodechild_process.execSync)(`\"${binaryPath}\" -install -key-file \"${keyPath}\" -cert-file \"${certPath}\" ${hosts.join(' ')}`, {\n            stdio: 'ignore'\n        });\n        const caLocation = (0, _nodechild_process.execSync)(`\"${binaryPath}\" -CAROOT`).toString().trim();\n        if (!_nodefs.default.existsSync(keyPath) || !_nodefs.default.existsSync(certPath)) {\n            throw Object.defineProperty(new Error('Certificate files not found'), \"__NEXT_ERROR_CODE\", {\n                value: \"E131\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n        _log.info(`CA Root certificate created in ${caLocation}`);\n        _log.info(`Certificates created in ${resolvedCertDir}`);\n        const gitignorePath = _nodepath.default.resolve(process.cwd(), './.gitignore');\n        if (_nodefs.default.existsSync(gitignorePath)) {\n            const gitignore = await _nodefs.default.promises.readFile(gitignorePath, 'utf8');\n            if (!gitignore.includes(certDir)) {\n                _log.info('Adding certificates to .gitignore');\n                await _nodefs.default.promises.appendFile(gitignorePath, `\\n${certDir}`);\n            }\n        }\n        return {\n            key: keyPath,\n            cert: certPath,\n            rootCA: `${caLocation}/rootCA.pem`\n        };\n    } catch (err) {\n        _log.error('Failed to generate self-signed certificate. Falling back to http.', err);\n    }\n}\n\n//# sourceMappingURL=mkcert.js.map"
        }
    ]
}