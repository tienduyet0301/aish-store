{
    "sourceFile": "node_modules/next/dist/lib/recursive-copy.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892863721,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"recursiveCopy\", {\n    enumerable: true,\n    get: function() {\n        return recursiveCopy;\n    }\n});\nconst _path = /*#__PURE__*/ _interop_require_default(require(\"path\"));\nconst _fs = require(\"fs\");\nconst _asyncsema = require(\"next/dist/compiled/async-sema\");\nconst _iserror = /*#__PURE__*/ _interop_require_default(require(\"./is-error\"));\nfunction _interop_require_default(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nconst COPYFILE_EXCL = _fs.constants.COPYFILE_EXCL;\nasync function recursiveCopy(source, dest, { concurrency = 32, overwrite = false, filter = ()=>true } = {}) {\n    const cwdPath = process.cwd();\n    const from = _path.default.resolve(cwdPath, source);\n    const to = _path.default.resolve(cwdPath, dest);\n    const sema = new _asyncsema.Sema(concurrency);\n    // deep copy the file/directory\n    async function _copy(item, lstats) {\n        const target = item.replace(from, to);\n        await sema.acquire();\n        if (!lstats) {\n            // after lock on first run\n            lstats = await _fs.promises.lstat(from);\n        }\n        // readdir & lstat do not follow symbolic links\n        // if part is a symbolic link, follow it with stat\n        let isFile = lstats.isFile();\n        let isDirectory = lstats.isDirectory();\n        if (lstats.isSymbolicLink()) {\n            const stats = await _fs.promises.stat(item);\n            isFile = stats.isFile();\n            isDirectory = stats.isDirectory();\n        }\n        if (isDirectory) {\n            try {\n                await _fs.promises.mkdir(target, {\n                    recursive: true\n                });\n            } catch (err) {\n                // do not throw `folder already exists` errors\n                if ((0, _iserror.default)(err) && err.code !== 'EEXIST') {\n                    throw err;\n                }\n            }\n            sema.release();\n            const files = await _fs.promises.readdir(item, {\n                withFileTypes: true\n            });\n            await Promise.all(files.map((file)=>_copy(_path.default.join(item, file.name), file)));\n        } else if (isFile && // before we send the path to filter\n        // we remove the base path (from) and replace \\ by / (windows)\n        filter(item.replace(from, '').replace(/\\\\/g, '/'))) {\n            await _fs.promises.copyFile(item, target, overwrite ? undefined : COPYFILE_EXCL).catch((err)=>{\n                // if overwrite is false we shouldn't fail on EEXIST\n                if (err.code !== 'EEXIST') {\n                    throw err;\n                }\n            });\n            sema.release();\n        } else {\n            sema.release();\n        }\n    }\n    await _copy(from);\n}\n\n//# sourceMappingURL=recursive-copy.js.map"
        }
    ]
}