{
    "sourceFile": "node_modules/next/dist/lib/recursive-delete.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892863788,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"recursiveDelete\", {\n    enumerable: true,\n    get: function() {\n        return recursiveDelete;\n    }\n});\nconst _fs = require(\"fs\");\nconst _path = require(\"path\");\nconst _iserror = /*#__PURE__*/ _interop_require_default(require(\"./is-error\"));\nconst _wait = require(\"./wait\");\nfunction _interop_require_default(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nconst unlinkPath = async (p, isDir = false, t = 1)=>{\n    try {\n        if (isDir) {\n            await _fs.promises.rmdir(p);\n        } else {\n            await _fs.promises.unlink(p);\n        }\n    } catch (e) {\n        const code = (0, _iserror.default)(e) && e.code;\n        if ((code === 'EBUSY' || code === 'ENOTEMPTY' || code === 'EPERM' || code === 'EMFILE') && t < 3) {\n            await (0, _wait.wait)(t * 100);\n            return unlinkPath(p, isDir, t++);\n        }\n        if (code === 'ENOENT') {\n            return;\n        }\n        throw e;\n    }\n};\nasync function recursiveDelete(/** Directory to delete the contents of */ dir, /** Exclude based on relative file path */ exclude, /** Ensures that parameter dir exists, this is not passed recursively */ previousPath = '') {\n    let result;\n    try {\n        result = await _fs.promises.readdir(dir, {\n            withFileTypes: true\n        });\n    } catch (e) {\n        if ((0, _iserror.default)(e) && e.code === 'ENOENT') {\n            return;\n        }\n        throw e;\n    }\n    await Promise.all(result.map(async (part)=>{\n        const absolutePath = (0, _path.join)(dir, part.name);\n        // readdir does not follow symbolic links\n        // if part is a symbolic link, follow it using stat\n        let isDirectory = part.isDirectory();\n        const isSymlink = part.isSymbolicLink();\n        if (isSymlink) {\n            const linkPath = await _fs.promises.readlink(absolutePath);\n            try {\n                const stats = await _fs.promises.stat((0, _path.isAbsolute)(linkPath) ? linkPath : (0, _path.join)((0, _path.dirname)(absolutePath), linkPath));\n                isDirectory = stats.isDirectory();\n            } catch  {}\n        }\n        const pp = (0, _path.join)(previousPath, part.name);\n        const isNotExcluded = !exclude || !exclude.test(pp);\n        if (isNotExcluded) {\n            if (isDirectory) {\n                await recursiveDelete(absolutePath, exclude, pp);\n            }\n            return unlinkPath(absolutePath, !isSymlink && isDirectory);\n        }\n    }));\n}\n\n//# sourceMappingURL=recursive-delete.js.map"
        }
    ]
}