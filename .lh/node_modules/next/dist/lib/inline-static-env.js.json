{
    "sourceFile": "node_modules/next/dist/lib/inline-static-env.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892859775,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"inlineStaticEnv\", {\n    enumerable: true,\n    get: function() {\n        return inlineStaticEnv;\n    }\n});\nconst _fs = /*#__PURE__*/ _interop_require_default(require(\"fs\"));\nconst _path = /*#__PURE__*/ _interop_require_default(require(\"path\"));\nconst _crypto = /*#__PURE__*/ _interop_require_default(require(\"crypto\"));\nconst _util = require(\"util\");\nconst _glob = /*#__PURE__*/ _interop_require_default(require(\"next/dist/compiled/glob\"));\nconst _asyncsema = require(\"next/dist/compiled/async-sema\");\nconst _staticenv = require(\"./static-env\");\nfunction _interop_require_default(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nconst glob = (0, _util.promisify)(_glob.default);\nasync function inlineStaticEnv({ distDir, config }) {\n    const nextConfigEnv = (0, _staticenv.getNextConfigEnv)(config);\n    const staticEnv = (0, _staticenv.getStaticEnv)(config);\n    const serverDir = _path.default.join(distDir, 'server');\n    const serverChunks = await glob('**/*.{js,json,js.map}', {\n        cwd: serverDir\n    });\n    const clientDir = _path.default.join(distDir, 'static');\n    const clientChunks = await glob('**/*.{js,json,js.map}', {\n        cwd: clientDir\n    });\n    const manifestChunks = await glob('*.{js,json,js.map}', {\n        cwd: distDir\n    });\n    const inlineSema = new _asyncsema.Sema(8);\n    const nextConfigEnvKeys = Object.keys(nextConfigEnv).map((item)=>item.split('process.env.').pop());\n    const builtRegEx = new RegExp(`[\\\\w]{1,}(\\\\.env)?\\\\.(?:NEXT_PUBLIC_[\\\\w]{1,}${nextConfigEnvKeys.length ? '|' + nextConfigEnvKeys.join('|') : ''})`, 'g');\n    const changedClientFiles = [];\n    const filesToCheck = new Set(manifestChunks.map((f)=>_path.default.join(distDir, f)));\n    for (const [parentDir, files] of [\n        [\n            serverDir,\n            serverChunks\n        ],\n        [\n            clientDir,\n            clientChunks\n        ]\n    ]){\n        await Promise.all(files.map(async (file)=>{\n            await inlineSema.acquire();\n            const filepath = _path.default.join(parentDir, file);\n            const content = await _fs.default.promises.readFile(filepath, 'utf8');\n            const newContent = content.replace(builtRegEx, (match)=>{\n                let normalizedMatch = `process.env.${match.split('.').pop()}`;\n                if (staticEnv[normalizedMatch]) {\n                    return JSON.stringify(staticEnv[normalizedMatch]);\n                }\n                return match;\n            });\n            await _fs.default.promises.writeFile(filepath, newContent);\n            if (content !== newContent && parentDir === clientDir) {\n                changedClientFiles.push({\n                    file,\n                    content: newContent\n                });\n            }\n            filesToCheck.add(filepath);\n            inlineSema.release();\n        }));\n    }\n    const hashChanges = [];\n    // hashes need updating for any changed client files\n    for (const { file, content } of changedClientFiles){\n        var _file_match;\n        // hash is 16 chars currently for all client chunks\n        const originalHash = ((_file_match = file.match(/([a-z0-9]{16})\\./)) == null ? void 0 : _file_match[1]) || '';\n        if (!originalHash) {\n            throw Object.defineProperty(new Error(`Invariant: client chunk changed but failed to detect hash ${file}`), \"__NEXT_ERROR_CODE\", {\n                value: \"E663\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n        const newHash = _crypto.default.createHash('sha256').update(content).digest('hex').substring(0, 16);\n        hashChanges.push({\n            originalHash,\n            newHash\n        });\n        const filepath = _path.default.join(clientDir, file);\n        const newFilepath = filepath.replace(originalHash, newHash);\n        filesToCheck.delete(filepath);\n        filesToCheck.add(newFilepath);\n        await _fs.default.promises.rename(filepath, newFilepath);\n    }\n    // update build-manifest and webpack-runtime with new hashes\n    for (let file of filesToCheck){\n        const content = await _fs.default.promises.readFile(file, 'utf-8');\n        let newContent = content;\n        for (const { originalHash, newHash } of hashChanges){\n            newContent = newContent.replaceAll(originalHash, newHash);\n        }\n        if (content !== newContent) {\n            await _fs.default.promises.writeFile(file, newContent);\n        }\n    }\n}\n\n//# sourceMappingURL=inline-static-env.js.map"
        }
    ]
}