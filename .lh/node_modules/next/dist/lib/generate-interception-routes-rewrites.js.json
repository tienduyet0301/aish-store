{
    "sourceFile": "node_modules/next/dist/lib/generate-interception-routes-rewrites.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892858795,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    generateInterceptionRoutesRewrites: null,\n    isInterceptionRouteRewrite: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    generateInterceptionRoutesRewrites: function() {\n        return generateInterceptionRoutesRewrites;\n    },\n    isInterceptionRouteRewrite: function() {\n        return isInterceptionRouteRewrite;\n    }\n});\nconst _pathtoregexp = require(\"next/dist/compiled/path-to-regexp\");\nconst _approuterheaders = require(\"../client/components/app-router-headers\");\nconst _interceptionroutes = require(\"../shared/lib/router/utils/interception-routes\");\n// a function that converts normalised paths (e.g. /foo/[bar]/[baz]) to the format expected by pathToRegexp (e.g. /foo/:bar/:baz)\nfunction toPathToRegexpPath(path) {\n    return path.replace(/\\[\\[?([^\\]]+)\\]\\]?/g, (_, capture)=>{\n        // path-to-regexp only supports word characters, so we replace any non-word characters with underscores\n        const paramName = capture.replace(/\\W+/g, '_');\n        // handle catch-all segments (e.g. /foo/bar/[...baz] or /foo/bar/[[...baz]])\n        if (capture.startsWith('...')) {\n            return `:${capture.slice(3)}*`;\n        }\n        return ':' + paramName;\n    });\n}\nfunction generateInterceptionRoutesRewrites(appPaths, basePath = '') {\n    const rewrites = [];\n    for (const appPath of appPaths){\n        if ((0, _interceptionroutes.isInterceptionRouteAppPath)(appPath)) {\n            const { interceptingRoute, interceptedRoute } = (0, _interceptionroutes.extractInterceptionRouteInformation)(appPath);\n            const normalizedInterceptingRoute = `${interceptingRoute !== '/' ? toPathToRegexpPath(interceptingRoute) : ''}/(.*)?`;\n            const normalizedInterceptedRoute = toPathToRegexpPath(interceptedRoute);\n            const normalizedAppPath = toPathToRegexpPath(appPath);\n            // pathToRegexp returns a regex that matches the path, but we need to\n            // convert it to a string that can be used in a header value\n            // to the format that Next/the proxy expects\n            let interceptingRouteRegex = (0, _pathtoregexp.pathToRegexp)(normalizedInterceptingRoute).toString().slice(2, -3);\n            rewrites.push({\n                source: `${basePath}${normalizedInterceptedRoute}`,\n                destination: `${basePath}${normalizedAppPath}`,\n                has: [\n                    {\n                        type: 'header',\n                        key: _approuterheaders.NEXT_URL,\n                        value: interceptingRouteRegex\n                    }\n                ]\n            });\n        }\n    }\n    return rewrites;\n}\nfunction isInterceptionRouteRewrite(route) {\n    var _route_has_, _route_has;\n    // When we generate interception rewrites in the above implementation, we always do so with only a single `has` condition.\n    return ((_route_has = route.has) == null ? void 0 : (_route_has_ = _route_has[0]) == null ? void 0 : _route_has_.key) === _approuterheaders.NEXT_URL;\n}\n\n//# sourceMappingURL=generate-interception-routes-rewrites.js.map"
        }
    ]
}