{
    "sourceFile": "node_modules/next/dist/lib/verifyAndLint.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892865372,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"verifyAndLint\", {\n    enumerable: true,\n    get: function() {\n        return verifyAndLint;\n    }\n});\nconst _picocolors = require(\"./picocolors\");\nconst _worker = require(\"./worker\");\nconst _fs = require(\"fs\");\nconst _path = require(\"path\");\nconst _constants = require(\"./constants\");\nconst _events = require(\"../telemetry/events\");\nconst _compileerror = require(\"./compile-error\");\nconst _iserror = /*#__PURE__*/ _interop_require_default(require(\"./is-error\"));\nfunction _interop_require_default(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nasync function verifyAndLint(dir, cacheLocation, configLintDirs, enableWorkerThreads, telemetry) {\n    let lintWorkers;\n    try {\n        lintWorkers = new _worker.Worker(require.resolve('./eslint/runLintCheck'), {\n            exposedMethods: [\n                'runLintCheck'\n            ],\n            numWorkers: 1,\n            enableWorkerThreads,\n            maxRetries: 0\n        });\n        const lintDirs = (configLintDirs ?? _constants.ESLINT_DEFAULT_DIRS).reduce((res, d)=>{\n            const currDir = (0, _path.join)(dir, d);\n            if (!(0, _fs.existsSync)(currDir)) return res;\n            res.push(currDir);\n            return res;\n        }, []);\n        const lintResults = await (lintWorkers == null ? void 0 : lintWorkers.runLintCheck(dir, lintDirs, {\n            lintDuringBuild: true,\n            eslintOptions: {\n                cacheLocation\n            }\n        }));\n        const lintOutput = typeof lintResults === 'string' ? lintResults : lintResults == null ? void 0 : lintResults.output;\n        if (typeof lintResults !== 'string' && (lintResults == null ? void 0 : lintResults.eventInfo)) {\n            telemetry.record((0, _events.eventLintCheckCompleted)({\n                ...lintResults.eventInfo,\n                buildLint: true\n            }));\n        }\n        if (typeof lintResults !== 'string' && (lintResults == null ? void 0 : lintResults.isError) && lintOutput) {\n            await telemetry.flush();\n            throw Object.defineProperty(new _compileerror.CompileError(lintOutput), \"__NEXT_ERROR_CODE\", {\n                value: \"E394\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n        if (lintOutput) {\n            console.log(lintOutput);\n        }\n    } catch (err) {\n        if ((0, _iserror.default)(err)) {\n            if (err.type === 'CompileError' || err instanceof _compileerror.CompileError) {\n                console.error((0, _picocolors.red)('\\nFailed to compile.'));\n                console.error(err.message);\n                process.exit(1);\n            } else if (err.type === 'FatalError') {\n                console.error(err.message);\n                process.exit(1);\n            }\n        }\n        throw err;\n    } finally{\n        try {\n            lintWorkers == null ? void 0 : lintWorkers.end();\n        } catch  {}\n    }\n}\n\n//# sourceMappingURL=verifyAndLint.js.map"
        }
    ]
}