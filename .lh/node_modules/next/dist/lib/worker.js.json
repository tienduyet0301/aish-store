{
    "sourceFile": "node_modules/next/dist/lib/worker.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892865555,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"Worker\", {\n    enumerable: true,\n    get: function() {\n        return Worker;\n    }\n});\nconst _jestworker = require(\"next/dist/compiled/jest-worker\");\nconst _stream = require(\"stream\");\nconst RESTARTED = Symbol('restarted');\nconst cleanupWorkers = (worker)=>{\n    var _worker__workerPool;\n    for (const curWorker of ((_worker__workerPool = worker._workerPool) == null ? void 0 : _worker__workerPool._workers) || []){\n        var _curWorker__child;\n        (_curWorker__child = curWorker._child) == null ? void 0 : _curWorker__child.kill('SIGINT');\n    }\n};\nclass Worker {\n    constructor(workerPath, options){\n        let { timeout, onRestart, logger = console, ...farmOptions } = options;\n        let restartPromise;\n        let resolveRestartPromise;\n        let activeTasks = 0;\n        this._worker = undefined;\n        // ensure we end workers if they weren't before exit\n        process.on('exit', ()=>{\n            this.close();\n        });\n        const createWorker = ()=>{\n            var _farmOptions_forkOptions;\n            this._worker = new _jestworker.Worker(workerPath, {\n                ...farmOptions,\n                forkOptions: {\n                    ...farmOptions.forkOptions,\n                    env: {\n                        ...((_farmOptions_forkOptions = farmOptions.forkOptions) == null ? void 0 : _farmOptions_forkOptions.env) || {},\n                        ...process.env,\n                        IS_NEXT_WORKER: 'true'\n                    }\n                },\n                maxRetries: 0\n            });\n            restartPromise = new Promise((resolve)=>resolveRestartPromise = resolve);\n            /**\n       * Jest Worker has two worker types, ChildProcessWorker (uses child_process) and NodeThreadWorker (uses worker_threads)\n       * Next.js uses ChildProcessWorker by default, but it can be switched to NodeThreadWorker with an experimental flag\n       *\n       * We only want to handle ChildProcessWorker's orphan process issue, so we access the private property \"_child\":\n       * https://github.com/facebook/jest/blob/b38d7d345a81d97d1dc3b68b8458b1837fbf19be/packages/jest-worker/src/workers/ChildProcessWorker.ts\n       *\n       * But this property is not available in NodeThreadWorker, so we need to check if we are using ChildProcessWorker\n       */ if (!farmOptions.enableWorkerThreads) {\n                var _this__worker__workerPool;\n                for (const worker of ((_this__worker__workerPool = this._worker._workerPool) == null ? void 0 : _this__worker__workerPool._workers) || []){\n                    var _worker__child, // if a child process emits a particular message, we track that as activity\n                    // so the parent process can keep track of progress\n                    _worker__child1;\n                    (_worker__child = worker._child) == null ? void 0 : _worker__child.on('exit', (code, signal)=>{\n                        if ((code || signal && signal !== 'SIGINT') && this._worker) {\n                            logger.error(`Next.js build worker exited with code: ${code} and signal: ${signal}`);\n                            // if a child process doesn't exit gracefully, we want to bubble up the exit code to the parent process\n                            process.exit(code ?? 1);\n                        }\n                    });\n                    (_worker__child1 = worker._child) == null ? void 0 : _worker__child1.on('message', ([, data])=>{\n                        if (data && typeof data === 'object' && 'type' in data && data.type === 'activity') {\n                            onActivity();\n                        }\n                    });\n                }\n            }\n            let aborted = false;\n            const onActivityAbort = ()=>{\n                if (!aborted) {\n                    options.onActivityAbort == null ? void 0 : options.onActivityAbort.call(options);\n                    aborted = true;\n                }\n            };\n            // Listen to the worker's stdout and stderr, if there's any thing logged, abort the activity first\n            const abortActivityStreamOnLog = new _stream.Transform({\n                transform (_chunk, _encoding, callback) {\n                    onActivityAbort();\n                    callback();\n                }\n            });\n            // Stop the activity if there's any output from the worker\n            this._worker.getStdout().pipe(abortActivityStreamOnLog);\n            this._worker.getStderr().pipe(abortActivityStreamOnLog);\n            // Pipe the worker's stdout and stderr to the parent process\n            this._worker.getStdout().pipe(process.stdout);\n            this._worker.getStderr().pipe(process.stderr);\n        };\n        createWorker();\n        const onHanging = ()=>{\n            const worker = this._worker;\n            if (!worker) return;\n            const resolve = resolveRestartPromise;\n            createWorker();\n            logger.warn(`Sending SIGTERM signal to static worker due to timeout${timeout ? ` of ${timeout / 1000} seconds` : ''}. Subsequent errors may be a result of the worker exiting.`);\n            worker.end().then(()=>{\n                resolve(RESTARTED);\n            });\n        };\n        let hangingTimer = false;\n        const onActivity = ()=>{\n            if (hangingTimer) clearTimeout(hangingTimer);\n            if (options.onActivity) options.onActivity();\n            hangingTimer = activeTasks > 0 && setTimeout(onHanging, timeout);\n        };\n        for (const method of farmOptions.exposedMethods){\n            if (method.startsWith('_')) continue;\n            this[method] = timeout ? async (...args)=>{\n                activeTasks++;\n                try {\n                    let attempts = 0;\n                    for(;;){\n                        onActivity();\n                        const result = await Promise.race([\n                            this._worker[method](...args),\n                            restartPromise\n                        ]);\n                        if (result !== RESTARTED) return result;\n                        if (onRestart) onRestart(method, args, ++attempts);\n                    }\n                } finally{\n                    activeTasks--;\n                    onActivity();\n                }\n            } : this._worker[method].bind(this._worker);\n        }\n    }\n    end() {\n        const worker = this._worker;\n        if (!worker) {\n            throw Object.defineProperty(new Error('Farm is ended, no more calls can be done to it'), \"__NEXT_ERROR_CODE\", {\n                value: \"E265\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n        cleanupWorkers(worker);\n        this._worker = undefined;\n        return worker.end();\n    }\n    /**\n   * Quietly end the worker if it exists\n   */ close() {\n        if (this._worker) {\n            cleanupWorkers(this._worker);\n            this._worker.end();\n        }\n    }\n}\n\n//# sourceMappingURL=worker.js.map"
        }
    ]
}