{
    "sourceFile": "node_modules/next/dist/export/routes/app-route.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892856025,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    ExportedAppRouteFiles: null,\n    exportAppRoute: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    ExportedAppRouteFiles: function() {\n        return ExportedAppRouteFiles;\n    },\n    exportAppRoute: function() {\n        return exportAppRoute;\n    }\n});\nconst _constants = require(\"../../lib/constants\");\nconst _node = require(\"../../server/base-http/node\");\nconst _nextrequest = require(\"../../server/web/spec-extension/adapters/next-request\");\nconst _utils = require(\"../../server/web/utils\");\nconst _isdynamicusageerror = require(\"../helpers/is-dynamic-usage-error\");\nconst _ciinfo = require(\"../../server/ci-info\");\nconst _isstaticgenenabled = require(\"../../server/route-modules/app-route/helpers/is-static-gen-enabled\");\nconst _ismetadataroute = require(\"../../lib/metadata/is-metadata-route\");\nconst _apppaths = require(\"../../shared/lib/router/utils/app-paths\");\nconst _runwithafter = require(\"../../server/after/run-with-after\");\nvar ExportedAppRouteFiles = /*#__PURE__*/ function(ExportedAppRouteFiles) {\n    ExportedAppRouteFiles[\"BODY\"] = \"BODY\";\n    ExportedAppRouteFiles[\"META\"] = \"META\";\n    return ExportedAppRouteFiles;\n}({});\nasync function exportAppRoute(req, res, params, page, module1, incrementalCache, cacheLifeProfiles, htmlFilepath, fileWriter, experimental, buildId) {\n    // Ensure that the URL is absolute.\n    req.url = `http://localhost:3000${req.url}`;\n    // Adapt the request and response to the Next.js request and response.\n    const request = _nextrequest.NextRequestAdapter.fromNodeNextRequest(new _node.NodeNextRequest(req), (0, _nextrequest.signalFromNodeResponse)(res));\n    const afterRunner = new _runwithafter.AfterRunner();\n    // Create the context for the handler. This contains the params from\n    // the route and the context for the request.\n    const context = {\n        params,\n        prerenderManifest: {\n            version: 4,\n            routes: {},\n            dynamicRoutes: {},\n            preview: {\n                previewModeEncryptionKey: '',\n                previewModeId: '',\n                previewModeSigningKey: ''\n            },\n            notFoundRoutes: []\n        },\n        renderOpts: {\n            experimental,\n            nextExport: true,\n            supportsDynamicResponse: false,\n            incrementalCache,\n            waitUntil: afterRunner.context.waitUntil,\n            onClose: afterRunner.context.onClose,\n            onAfterTaskError: afterRunner.context.onTaskError,\n            cacheLifeProfiles\n        },\n        sharedContext: {\n            buildId\n        }\n    };\n    if (_ciinfo.hasNextSupport) {\n        context.renderOpts.isRevalidate = true;\n    }\n    try {\n        const userland = module1.userland;\n        // we don't bail from the static optimization for\n        // metadata routes, since it's app-route we can always append /route suffix.\n        const routePath = (0, _apppaths.normalizeAppPath)(page) + '/route';\n        const isPageMetadataRoute = (0, _ismetadataroute.isMetadataRoute)(routePath);\n        if (!(0, _isstaticgenenabled.isStaticGenEnabled)(userland) && !isPageMetadataRoute && // We don't disable static gen when dynamicIO is enabled because we\n        // expect that anything dynamic in the GET handler will make it dynamic\n        // and thus avoid the cache surprises that led to us removing static gen\n        // unless specifically opted into\n        experimental.dynamicIO !== true) {\n            return {\n                cacheControl: {\n                    revalidate: 0,\n                    expire: undefined\n                }\n            };\n        }\n        const response = await module1.handle(request, context);\n        const isValidStatus = response.status < 400 || response.status === 404;\n        if (!isValidStatus) {\n            return {\n                cacheControl: {\n                    revalidate: 0,\n                    expire: undefined\n                }\n            };\n        }\n        const blob = await response.blob();\n        // TODO(after): if we abort a prerender because of an error in an after-callback\n        // we should probably communicate that better (and not log the error twice)\n        await afterRunner.executeAfter();\n        const revalidate = typeof context.renderOpts.collectedRevalidate === 'undefined' || context.renderOpts.collectedRevalidate >= _constants.INFINITE_CACHE ? false : context.renderOpts.collectedRevalidate;\n        const expire = typeof context.renderOpts.collectedExpire === 'undefined' || context.renderOpts.collectedExpire >= _constants.INFINITE_CACHE ? undefined : context.renderOpts.collectedExpire;\n        const headers = (0, _utils.toNodeOutgoingHttpHeaders)(response.headers);\n        const cacheTags = context.renderOpts.collectedTags;\n        if (cacheTags) {\n            headers[_constants.NEXT_CACHE_TAGS_HEADER] = cacheTags;\n        }\n        if (!headers['content-type'] && blob.type) {\n            headers['content-type'] = blob.type;\n        }\n        // Writing response body to a file.\n        const body = Buffer.from(await blob.arrayBuffer());\n        fileWriter.append(htmlFilepath.replace(/\\.html$/, _constants.NEXT_BODY_SUFFIX), body);\n        // Write the request metadata to a file.\n        const meta = {\n            status: response.status,\n            headers\n        };\n        fileWriter.append(htmlFilepath.replace(/\\.html$/, _constants.NEXT_META_SUFFIX), JSON.stringify(meta));\n        return {\n            cacheControl: {\n                revalidate,\n                expire\n            },\n            metadata: meta\n        };\n    } catch (err) {\n        if (!(0, _isdynamicusageerror.isDynamicUsageError)(err)) {\n            throw err;\n        }\n        return {\n            cacheControl: {\n                revalidate: 0,\n                expire: undefined\n            }\n        };\n    }\n}\n\n//# sourceMappingURL=app-route.js.map"
        }
    ]
}