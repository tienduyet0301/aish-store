{
    "sourceFile": "node_modules/next/dist/export/routes/app-page.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892855938,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    exportAppPage: null,\n    prospectiveRenderAppPage: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    exportAppPage: function() {\n        return exportAppPage;\n    },\n    prospectiveRenderAppPage: function() {\n        return prospectiveRenderAppPage;\n    }\n});\nconst _isdynamicusageerror = require(\"../helpers/is-dynamic-usage-error\");\nconst _constants = require(\"../../lib/constants\");\nconst _ciinfo = require(\"../../server/ci-info\");\nconst _modulerender = require(\"../../server/route-modules/app-page/module.render\");\nconst _bailouttocsr = require(\"../../shared/lib/lazy-dynamic/bailout-to-csr\");\nconst _node = require(\"../../server/base-http/node\");\nconst _approuterheaders = require(\"../../client/components/app-router-headers\");\nconst _runwithafter = require(\"../../server/after/run-with-after\");\nasync function prospectiveRenderAppPage(req, res, page, pathname, query, fallbackRouteParams, partialRenderOpts, sharedContext) {\n    const afterRunner = new _runwithafter.AfterRunner();\n    // If the page is `/_not-found`, then we should update the page to be `/404`.\n    // UNDERSCORE_NOT_FOUND_ROUTE value used here, however we don't want to import it here as it causes constants to be inlined which we don't want here.\n    if (page === '/_not-found/page') {\n        pathname = '/404';\n    }\n    try {\n        await (0, _modulerender.lazyRenderAppPage)(new _node.NodeNextRequest(req), new _node.NodeNextResponse(res), pathname, query, fallbackRouteParams, {\n            ...partialRenderOpts,\n            waitUntil: afterRunner.context.waitUntil,\n            onClose: afterRunner.context.onClose,\n            onAfterTaskError: afterRunner.context.onTaskError\n        }, undefined, false, sharedContext);\n        // TODO(after): if we abort a prerender because of an error in an after-callback\n        // we should probably communicate that better (and not log the error twice)\n        await afterRunner.executeAfter();\n    } catch (err) {\n        if (!(0, _isdynamicusageerror.isDynamicUsageError)(err)) {\n            throw err;\n        }\n        // We should fail rendering if a client side rendering bailout\n        // occurred at the page level.\n        if ((0, _bailouttocsr.isBailoutToCSRError)(err)) {\n            throw err;\n        }\n    }\n}\nasync function exportAppPage(req, res, page, path, pathname, query, fallbackRouteParams, partialRenderOpts, htmlFilepath, debugOutput, isDynamicError, fileWriter, sharedContext) {\n    const afterRunner = new _runwithafter.AfterRunner();\n    const renderOpts = {\n        ...partialRenderOpts,\n        waitUntil: afterRunner.context.waitUntil,\n        onClose: afterRunner.context.onClose,\n        onAfterTaskError: afterRunner.context.onTaskError\n    };\n    let isDefaultNotFound = false;\n    // If the page is `/_not-found`, then we should update the page to be `/404`.\n    // UNDERSCORE_NOT_FOUND_ROUTE value used here, however we don't want to import it here as it causes constants to be inlined which we don't want here.\n    if (page === '/_not-found/page') {\n        isDefaultNotFound = true;\n        pathname = '/404';\n    }\n    try {\n        const result = await (0, _modulerender.lazyRenderAppPage)(new _node.NodeNextRequest(req), new _node.NodeNextResponse(res), pathname, query, fallbackRouteParams, renderOpts, undefined, false, sharedContext);\n        const html = result.toUnchunkedString();\n        // TODO(after): if we abort a prerender because of an error in an after-callback\n        // we should probably communicate that better (and not log the error twice)\n        await afterRunner.executeAfter();\n        const { metadata } = result;\n        const { flightData, cacheControl = {\n            revalidate: false,\n            expire: undefined\n        }, postponed, fetchTags, fetchMetrics, segmentData } = metadata;\n        // Ensure we don't postpone without having PPR enabled.\n        if (postponed && !renderOpts.experimental.isRoutePPREnabled) {\n            throw Object.defineProperty(new Error('Invariant: page postponed without PPR being enabled'), \"__NEXT_ERROR_CODE\", {\n                value: \"E156\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n        if (cacheControl.revalidate === 0) {\n            if (isDynamicError) {\n                throw Object.defineProperty(new Error(`Page with dynamic = \"error\" encountered dynamic data method on ${path}.`), \"__NEXT_ERROR_CODE\", {\n                    value: \"E388\",\n                    enumerable: false,\n                    configurable: true\n                });\n            }\n            const { staticBailoutInfo = {} } = metadata;\n            if (debugOutput && (staticBailoutInfo == null ? void 0 : staticBailoutInfo.description)) {\n                logDynamicUsageWarning({\n                    path,\n                    description: staticBailoutInfo.description,\n                    stack: staticBailoutInfo.stack\n                });\n            }\n            return {\n                cacheControl,\n                fetchMetrics\n            };\n        }\n        // If page data isn't available, it means that the page couldn't be rendered\n        // properly so long as we don't have unknown route params. When a route doesn't\n        // have unknown route params, there will not be any flight data.\n        if (!flightData && (!fallbackRouteParams || fallbackRouteParams.size === 0)) {\n            throw Object.defineProperty(new Error(`Invariant: failed to get page data for ${path}`), \"__NEXT_ERROR_CODE\", {\n                value: \"E194\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n        if (flightData) {\n            // If PPR is enabled, we want to emit a prefetch rsc file for the page\n            // instead of the standard rsc. This is because the standard rsc will\n            // contain the dynamic data. We do this if any routes have PPR enabled so\n            // that the cache read/write is the same.\n            if (renderOpts.experimental.isRoutePPREnabled) {\n                // If PPR is enabled, we should emit the flight data as the prefetch\n                // payload.\n                // TODO: This will eventually be replaced by the per-segment prefetch\n                // output below.\n                fileWriter.append(htmlFilepath.replace(/\\.html$/, _constants.RSC_PREFETCH_SUFFIX), flightData);\n            } else {\n                // Writing the RSC payload to a file if we don't have PPR enabled.\n                fileWriter.append(htmlFilepath.replace(/\\.html$/, _constants.RSC_SUFFIX), flightData);\n            }\n        }\n        let segmentPaths;\n        if (segmentData) {\n            // Emit the per-segment prefetch data. We emit them as separate files\n            // so that the cache handler has the option to treat each as a\n            // separate entry.\n            segmentPaths = [];\n            const segmentsDir = htmlFilepath.replace(/\\.html$/, _constants.RSC_SEGMENTS_DIR_SUFFIX);\n            for (const [segmentPath, buffer] of segmentData){\n                segmentPaths.push(segmentPath);\n                const segmentDataFilePath = segmentsDir + segmentPath + _constants.RSC_SEGMENT_SUFFIX;\n                fileWriter.append(segmentDataFilePath, buffer);\n            }\n        }\n        const headers = {\n            ...metadata.headers\n        };\n        // If we're writing the file to disk, we know it's a prerender.\n        headers[_approuterheaders.NEXT_IS_PRERENDER_HEADER] = '1';\n        if (fetchTags) {\n            headers[_constants.NEXT_CACHE_TAGS_HEADER] = fetchTags;\n        }\n        // Writing static HTML to a file.\n        fileWriter.append(htmlFilepath, html ?? '');\n        const isParallelRoute = /\\/@\\w+/.test(page);\n        const isNonSuccessfulStatusCode = res.statusCode > 300;\n        // When PPR is enabled, we don't always send 200 for routes that have been\n        // pregenerated, so we should grab the status code from the mocked\n        // response.\n        let status = renderOpts.experimental.isRoutePPREnabled ? res.statusCode : undefined;\n        if (isDefaultNotFound) {\n            // Override the default /_not-found page status code to 404\n            status = 404;\n        } else if (isNonSuccessfulStatusCode && !isParallelRoute) {\n            // If it's parallel route the status from mock response is 404\n            status = res.statusCode;\n        }\n        // Writing the request metadata to a file.\n        const meta = {\n            status,\n            headers,\n            postponed,\n            segmentPaths\n        };\n        fileWriter.append(htmlFilepath.replace(/\\.html$/, _constants.NEXT_META_SUFFIX), JSON.stringify(meta, null, 2));\n        return {\n            // Only include the metadata if the environment has next support.\n            metadata: _ciinfo.hasNextSupport ? meta : undefined,\n            hasEmptyPrelude: Boolean(postponed) && html === '',\n            hasPostponed: Boolean(postponed),\n            cacheControl,\n            fetchMetrics\n        };\n    } catch (err) {\n        if (!(0, _isdynamicusageerror.isDynamicUsageError)(err)) {\n            throw err;\n        }\n        // We should fail rendering if a client side rendering bailout\n        // occurred at the page level.\n        if ((0, _bailouttocsr.isBailoutToCSRError)(err)) {\n            throw err;\n        }\n        let fetchMetrics;\n        if (debugOutput) {\n            const store = renderOpts.store;\n            const { dynamicUsageDescription, dynamicUsageStack } = store;\n            fetchMetrics = store.fetchMetrics;\n            logDynamicUsageWarning({\n                path,\n                description: dynamicUsageDescription ?? '',\n                stack: dynamicUsageStack\n            });\n        }\n        return {\n            cacheControl: {\n                revalidate: 0,\n                expire: undefined\n            },\n            fetchMetrics\n        };\n    }\n}\nfunction logDynamicUsageWarning({ path, description, stack }) {\n    const errMessage = Object.defineProperty(new Error(`Static generation failed due to dynamic usage on ${path}, reason: ${description}`), \"__NEXT_ERROR_CODE\", {\n        value: \"E381\",\n        enumerable: false,\n        configurable: true\n    });\n    if (stack) {\n        errMessage.stack = errMessage.message + stack.substring(stack.indexOf('\\n'));\n    }\n    console.warn(errMessage);\n}\n\n//# sourceMappingURL=app-page.js.map"
        }
    ]
}