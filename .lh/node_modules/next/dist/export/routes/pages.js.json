{
    "sourceFile": "node_modules/next/dist/export/routes/pages.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892856096,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"exportPagesPage\", {\n    enumerable: true,\n    get: function() {\n        return exportPagesPage;\n    }\n});\nconst _renderresult = /*#__PURE__*/ _interop_require_default(require(\"../../server/render-result\"));\nconst _path = require(\"path\");\nconst _ampmode = require(\"../../shared/lib/amp-mode\");\nconst _constants = require(\"../../lib/constants\");\nconst _bailouttocsr = require(\"../../shared/lib/lazy-dynamic/bailout-to-csr\");\nconst _amphtmlvalidator = /*#__PURE__*/ _interop_require_default(require(\"next/dist/compiled/amphtml-validator\"));\nconst _fileexists = require(\"../../lib/file-exists\");\nconst _modulerender = require(\"../../server/route-modules/pages/module.render\");\nfunction _interop_require_default(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nasync function exportPagesPage(req, res, path, page, query, params, htmlFilepath, htmlFilename, ampPath, subFolders, outDir, ampValidatorPath, pagesDataDir, buildExport, isDynamic, sharedContext, renderContext, hasOrigQueryValues, renderOpts, components, fileWriter) {\n    var _components_pageConfig, _components_pageConfig1;\n    const ampState = {\n        ampFirst: ((_components_pageConfig = components.pageConfig) == null ? void 0 : _components_pageConfig.amp) === true,\n        hasQuery: Boolean(query.amp),\n        hybrid: ((_components_pageConfig1 = components.pageConfig) == null ? void 0 : _components_pageConfig1.amp) === 'hybrid'\n    };\n    if (!ampValidatorPath) {\n        ampValidatorPath = require.resolve('next/dist/compiled/amphtml-validator/validator_wasm.js');\n    }\n    const inAmpMode = (0, _ampmode.isInAmpMode)(ampState);\n    const hybridAmp = ampState.hybrid;\n    if (components.getServerSideProps) {\n        throw Object.defineProperty(new Error(`Error for page ${page}: ${_constants.SERVER_PROPS_EXPORT_ERROR}`), \"__NEXT_ERROR_CODE\", {\n            value: \"E15\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    // for non-dynamic SSG pages we should have already\n    // prerendered the file\n    if (!buildExport && components.getStaticProps && !isDynamic) {\n        return;\n    }\n    // Pages router merges page params (e.g. [lang]) with query params\n    // primarily to support them both being accessible on `useRouter().query`.\n    // If we extracted dynamic params from the path, we need to merge them\n    // back into the query object.\n    const searchAndDynamicParams = {\n        ...query,\n        ...params\n    };\n    if (components.getStaticProps && !htmlFilepath.endsWith('.html')) {\n        // make sure it ends with .html if the name contains a dot\n        htmlFilepath += '.html';\n        htmlFilename += '.html';\n    }\n    let renderResult;\n    if (typeof components.Component === 'string') {\n        renderResult = _renderresult.default.fromStatic(components.Component);\n        if (hasOrigQueryValues) {\n            throw Object.defineProperty(new Error(`\\nError: you provided query values for ${path} which is an auto-exported page. These can not be applied since the page can no longer be re-rendered on the server. To disable auto-export for this page add \\`getInitialProps\\`\\n`), \"__NEXT_ERROR_CODE\", {\n                value: \"E505\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n    } else {\n        /**\n     * This sets environment variable to be used at the time of SSR by head.tsx.\n     * Using this from process.env allows targeting SSR by calling\n     * `process.env.__NEXT_OPTIMIZE_CSS`.\n     */ if (renderOpts.optimizeCss) {\n            process.env.__NEXT_OPTIMIZE_CSS = JSON.stringify(true);\n        }\n        try {\n            renderResult = await (0, _modulerender.lazyRenderPagesPage)(req, res, page, searchAndDynamicParams, renderOpts, sharedContext, renderContext);\n        } catch (err) {\n            if (!(0, _bailouttocsr.isBailoutToCSRError)(err)) throw err;\n        }\n    }\n    const ssgNotFound = renderResult == null ? void 0 : renderResult.metadata.isNotFound;\n    const ampValidations = [];\n    const validateAmp = async (rawAmpHtml, ampPageName, validatorPath)=>{\n        const validator = await _amphtmlvalidator.default.getInstance(validatorPath);\n        const result = validator.validateString(rawAmpHtml);\n        const errors = result.errors.filter((e)=>e.severity === 'ERROR');\n        const warnings = result.errors.filter((e)=>e.severity !== 'ERROR');\n        if (warnings.length || errors.length) {\n            ampValidations.push({\n                page: ampPageName,\n                result: {\n                    errors,\n                    warnings\n                }\n            });\n        }\n    };\n    const html = renderResult && !renderResult.isNull ? renderResult.toUnchunkedString() : '';\n    let ampRenderResult;\n    if (inAmpMode && !renderOpts.ampSkipValidation) {\n        if (!ssgNotFound) {\n            await validateAmp(html, path, ampValidatorPath);\n        }\n    } else if (hybridAmp) {\n        const ampHtmlFilename = subFolders ? (0, _path.join)(ampPath, 'index.html') : `${ampPath}.html`;\n        const ampHtmlFilepath = (0, _path.join)(outDir, ampHtmlFilename);\n        const exists = await (0, _fileexists.fileExists)(ampHtmlFilepath, _fileexists.FileType.File);\n        if (!exists) {\n            try {\n                ampRenderResult = await (0, _modulerender.lazyRenderPagesPage)(req, res, page, {\n                    ...searchAndDynamicParams,\n                    amp: '1'\n                }, renderOpts, sharedContext, renderContext);\n            } catch (err) {\n                if (!(0, _bailouttocsr.isBailoutToCSRError)(err)) throw err;\n            }\n            const ampHtml = ampRenderResult && !ampRenderResult.isNull ? ampRenderResult.toUnchunkedString() : '';\n            if (!renderOpts.ampSkipValidation) {\n                await validateAmp(ampHtml, page + '?amp=1', ampValidatorPath);\n            }\n            fileWriter.append(ampHtmlFilepath, ampHtml);\n        }\n    }\n    const metadata = (renderResult == null ? void 0 : renderResult.metadata) || (ampRenderResult == null ? void 0 : ampRenderResult.metadata) || {};\n    if (metadata.pageData) {\n        const dataFile = (0, _path.join)(pagesDataDir, htmlFilename.replace(/\\.html$/, _constants.NEXT_DATA_SUFFIX));\n        fileWriter.append(dataFile, JSON.stringify(metadata.pageData));\n        if (hybridAmp) {\n            fileWriter.append(dataFile.replace(/\\.json$/, '.amp.json'), JSON.stringify(metadata.pageData));\n        }\n    }\n    if (!ssgNotFound) {\n        // don't attempt writing to disk if getStaticProps returned not found\n        fileWriter.append(htmlFilepath, html);\n    }\n    return {\n        ampValidations,\n        cacheControl: metadata.cacheControl ?? {\n            revalidate: false,\n            expire: undefined\n        },\n        ssgNotFound\n    };\n}\n\n//# sourceMappingURL=pages.js.map"
        }
    ]
}