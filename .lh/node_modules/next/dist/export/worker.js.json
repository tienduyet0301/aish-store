{
    "sourceFile": "node_modules/next/dist/export/worker.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892856313,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"exportPages\", {\n    enumerable: true,\n    get: function() {\n        return exportPages;\n    }\n});\nrequire(\"../server/node-environment\");\nconst _path = require(\"path\");\nconst _promises = /*#__PURE__*/ _interop_require_default(require(\"fs/promises\"));\nconst _loadcomponents = require(\"../server/load-components\");\nconst _isdynamic = require(\"../shared/lib/router/utils/is-dynamic\");\nconst _normalizepagepath = require(\"../shared/lib/page-path/normalize-page-path\");\nconst _normalizelocalepath = require(\"../shared/lib/i18n/normalize-locale-path\");\nconst _trace = require(\"../trace\");\nconst _setuphttpagentenv = require(\"../server/setup-http-agent-env\");\nconst _iserror = /*#__PURE__*/ _interop_require_default(require(\"../lib/is-error\"));\nconst _requestmeta = require(\"../server/request-meta\");\nconst _apppaths = require(\"../shared/lib/router/utils/app-paths\");\nconst _mockrequest = require(\"../server/lib/mock-request\");\nconst _isapprouteroute = require(\"../lib/is-app-route-route\");\nconst _ciinfo = require(\"../server/ci-info\");\nconst _approute = require(\"./routes/app-route\");\nconst _apppage = require(\"./routes/app-page\");\nconst _pages = require(\"./routes/pages\");\nconst _getparams = require(\"./helpers/get-params\");\nconst _createincrementalcache = require(\"./helpers/create-incremental-cache\");\nconst _ispostpone = require(\"../server/lib/router-utils/is-postpone\");\nconst _isdynamicusageerror = require(\"./helpers/is-dynamic-usage-error\");\nconst _bailouttocsr = require(\"../shared/lib/lazy-dynamic/bailout-to-csr\");\nconst _turborepoaccesstrace = require(\"../build/turborepo-access-trace\");\nconst _fallbackparams = require(\"../server/request/fallback-params\");\nconst _needsexperimentalreact = require(\"../lib/needs-experimental-react\");\nconst _staticgenerationbailout = require(\"../client/components/static-generation-bailout\");\nconst _multifilewriter = require(\"../lib/multi-file-writer\");\nfunction _interop_require_default(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nprocess.env.NEXT_IS_EXPORT_WORKER = 'true';\nconst envConfig = require('../shared/lib/runtime-config.external');\nglobalThis.__NEXT_DATA__ = {\n    nextExport: true\n};\nclass TimeoutError extends Error {\n    constructor(...args){\n        super(...args), this.code = 'NEXT_EXPORT_TIMEOUT_ERROR';\n    }\n}\nclass ExportPageError extends Error {\n    constructor(...args){\n        super(...args), this.code = 'NEXT_EXPORT_PAGE_ERROR';\n    }\n}\nasync function exportPageImpl(input, fileWriter) {\n    var _req_url;\n    const { path, pathMap, distDir, pagesDataDir, buildExport = false, serverRuntimeConfig, subFolders = false, optimizeCss, disableOptimizedLoading, debugOutput = false, enableExperimentalReact, ampValidatorPath, trailingSlash, sriEnabled } = input;\n    if (enableExperimentalReact) {\n        process.env.__NEXT_EXPERIMENTAL_REACT = 'true';\n    }\n    const { page, // The parameters that are currently unknown.\n    _fallbackRouteParams = [], // Check if this is an `app/` page.\n    _isAppDir: isAppDir = false, // Check if this should error when dynamic usage is detected.\n    _isDynamicError: isDynamicError = false, // If this page supports partial prerendering, then we need to pass that to\n    // the renderOpts.\n    _isRoutePPREnabled: isRoutePPREnabled, // If this is a prospective render, we don't actually want to persist the\n    // result, we just want to use it to error the build if there's a problem.\n    _isProspectiveRender: isProspectiveRender = false, // Pull the original query out.\n    query: originalQuery = {} } = pathMap;\n    const fallbackRouteParams = (0, _fallbackparams.getFallbackRouteParams)(_fallbackRouteParams);\n    let query = {\n        ...originalQuery\n    };\n    const pathname = (0, _apppaths.normalizeAppPath)(page);\n    const isDynamic = (0, _isdynamic.isDynamicRoute)(page);\n    const outDir = isAppDir ? (0, _path.join)(distDir, 'server/app') : input.outDir;\n    const filePath = (0, _normalizepagepath.normalizePagePath)(path);\n    const ampPath = `${filePath}.amp`;\n    let renderAmpPath = ampPath;\n    let updatedPath = pathMap._ssgPath || path;\n    let locale = pathMap._locale || input.renderOpts.locale;\n    if (input.renderOpts.locale) {\n        const localePathResult = (0, _normalizelocalepath.normalizeLocalePath)(path, input.renderOpts.locales);\n        if (localePathResult.detectedLocale) {\n            updatedPath = localePathResult.pathname;\n            locale = localePathResult.detectedLocale;\n            if (locale === input.renderOpts.defaultLocale) {\n                renderAmpPath = `${(0, _normalizepagepath.normalizePagePath)(updatedPath)}.amp`;\n            }\n        }\n    }\n    // We need to show a warning if they try to provide query values\n    // for an auto-exported page since they won't be available\n    const hasOrigQueryValues = Object.keys(originalQuery).length > 0;\n    // Check if the page is a specified dynamic route\n    const { pathname: nonLocalizedPath } = (0, _normalizelocalepath.normalizeLocalePath)(path, input.renderOpts.locales);\n    let params;\n    if (isDynamic && page !== nonLocalizedPath) {\n        const normalizedPage = isAppDir ? (0, _apppaths.normalizeAppPath)(page) : page;\n        params = (0, _getparams.getParams)(normalizedPage, updatedPath);\n    }\n    const { req, res } = (0, _mockrequest.createRequestResponseMocks)({\n        url: updatedPath\n    });\n    // If this is a status code page, then set the response code.\n    for (const statusCode of [\n        404,\n        500\n    ]){\n        if ([\n            `/${statusCode}`,\n            `/${statusCode}.html`,\n            `/${statusCode}/index.html`\n        ].some((p)=>p === updatedPath || `/${locale}${p}` === updatedPath)) {\n            res.statusCode = statusCode;\n        }\n    }\n    // Ensure that the URL has a trailing slash if it's configured.\n    if (trailingSlash && !((_req_url = req.url) == null ? void 0 : _req_url.endsWith('/'))) {\n        req.url += '/';\n    }\n    if (locale && buildExport && input.renderOpts.domainLocales && input.renderOpts.domainLocales.some((dl)=>{\n        var _dl_locales;\n        return dl.defaultLocale === locale || ((_dl_locales = dl.locales) == null ? void 0 : _dl_locales.includes(locale || ''));\n    })) {\n        (0, _requestmeta.addRequestMeta)(req, 'isLocaleDomain', true);\n    }\n    envConfig.setConfig({\n        serverRuntimeConfig,\n        publicRuntimeConfig: input.renderOpts.runtimeConfig\n    });\n    const getHtmlFilename = (p)=>subFolders ? `${p}${_path.sep}index.html` : `${p}.html`;\n    let htmlFilename = getHtmlFilename(filePath);\n    // dynamic routes can provide invalid extensions e.g. /blog/[...slug] returns an\n    // extension of `.slug]`\n    const pageExt = isDynamic || isAppDir ? '' : (0, _path.extname)(page);\n    const pathExt = isDynamic || isAppDir ? '' : (0, _path.extname)(path);\n    // force output 404.html for backwards compat\n    if (path === '/404.html') {\n        htmlFilename = path;\n    } else if (pageExt !== pathExt && pathExt !== '') {\n        const isBuiltinPaths = [\n            '/500',\n            '/404'\n        ].some((p)=>p === path || p === path + '.html');\n        // If the ssg path has .html extension, and it's not builtin paths, use it directly\n        // Otherwise, use that as the filename instead\n        const isHtmlExtPath = !isBuiltinPaths && path.endsWith('.html');\n        htmlFilename = isHtmlExtPath ? getHtmlFilename(path) : path;\n    } else if (path === '/') {\n        // If the path is the root, just use index.html\n        htmlFilename = 'index.html';\n    }\n    const baseDir = (0, _path.join)(outDir, (0, _path.dirname)(htmlFilename));\n    let htmlFilepath = (0, _path.join)(outDir, htmlFilename);\n    await _promises.default.mkdir(baseDir, {\n        recursive: true\n    });\n    const components = await (0, _loadcomponents.loadComponents)({\n        distDir,\n        page,\n        isAppPath: isAppDir,\n        isDev: false,\n        sriEnabled\n    });\n    // Handle App Routes.\n    if (isAppDir && (0, _isapprouteroute.isAppRouteRoute)(page)) {\n        return (0, _approute.exportAppRoute)(req, res, params, page, components.routeModule, input.renderOpts.incrementalCache, input.renderOpts.cacheLifeProfiles, htmlFilepath, fileWriter, input.renderOpts.experimental, input.buildId);\n    }\n    const renderOpts = {\n        ...components,\n        ...input.renderOpts,\n        ampPath: renderAmpPath,\n        params,\n        optimizeCss,\n        disableOptimizedLoading,\n        locale,\n        supportsDynamicResponse: false,\n        // During the export phase in next build, we always enable the streaming metadata since if there's\n        // any dynamic access in metadata we can determine it in the build phase.\n        // If it's static, then it won't affect anything.\n        // If it's dynamic, then it can be handled when request hits the route.\n        serveStreamingMetadata: true,\n        experimental: {\n            ...input.renderOpts.experimental,\n            isRoutePPREnabled\n        }\n    };\n    if (_ciinfo.hasNextSupport) {\n        renderOpts.isRevalidate = true;\n    }\n    // Handle App Pages\n    if (isAppDir) {\n        const sharedContext = {\n            buildId: input.buildId\n        };\n        // If this is a prospective render, don't return any metrics or revalidate\n        // timings as we aren't persisting this render (it was only to error).\n        if (isProspectiveRender) {\n            return (0, _apppage.prospectiveRenderAppPage)(req, res, page, pathname, query, fallbackRouteParams, renderOpts, sharedContext);\n        }\n        return (0, _apppage.exportAppPage)(req, res, page, path, pathname, query, fallbackRouteParams, renderOpts, htmlFilepath, debugOutput, isDynamicError, fileWriter, sharedContext);\n    }\n    const sharedContext = {\n        buildId: input.buildId,\n        deploymentId: input.renderOpts.deploymentId,\n        customServer: undefined\n    };\n    const renderContext = {\n        isFallback: pathMap._pagesFallback ?? false,\n        isDraftMode: false,\n        developmentNotFoundSourcePage: undefined\n    };\n    return (0, _pages.exportPagesPage)(req, res, path, page, query, params, htmlFilepath, htmlFilename, ampPath, subFolders, outDir, ampValidatorPath, pagesDataDir, buildExport, isDynamic, sharedContext, renderContext, hasOrigQueryValues, renderOpts, components, fileWriter);\n}\nasync function exportPages(input) {\n    const { exportPathMap, paths, dir, distDir, outDir, cacheHandler, cacheMaxMemorySize, fetchCacheKeyPrefix, pagesDataDir, renderOpts, nextConfig, options } = input;\n    // If the fetch cache was enabled, we need to create an incremental\n    // cache instance for this page.\n    const incrementalCache = await (0, _createincrementalcache.createIncrementalCache)({\n        cacheHandler,\n        cacheMaxMemorySize,\n        fetchCacheKeyPrefix,\n        distDir,\n        dir,\n        // skip writing to disk in minimal mode for now, pending some\n        // changes to better support it\n        flushToDisk: !_ciinfo.hasNextSupport,\n        cacheHandlers: nextConfig.experimental.cacheHandlers\n    });\n    renderOpts.incrementalCache = incrementalCache;\n    const maxConcurrency = nextConfig.experimental.staticGenerationMaxConcurrency ?? 8;\n    const results = [];\n    const exportPageWithRetry = async (path, maxAttempts)=>{\n        const pathMap = exportPathMap[path];\n        const { page } = exportPathMap[path];\n        const pageKey = page !== path ? `${page}: ${path}` : path;\n        let attempt = 0;\n        let result;\n        while(attempt < maxAttempts){\n            try {\n                var _nextConfig_experimental_amp, _nextConfig_experimental_sri;\n                result = await Promise.race([\n                    exportPage({\n                        path,\n                        pathMap,\n                        distDir,\n                        outDir,\n                        pagesDataDir,\n                        renderOpts,\n                        ampValidatorPath: ((_nextConfig_experimental_amp = nextConfig.experimental.amp) == null ? void 0 : _nextConfig_experimental_amp.validator) || undefined,\n                        trailingSlash: nextConfig.trailingSlash,\n                        serverRuntimeConfig: nextConfig.serverRuntimeConfig,\n                        subFolders: nextConfig.trailingSlash && !options.buildExport,\n                        buildExport: options.buildExport,\n                        optimizeCss: nextConfig.experimental.optimizeCss,\n                        disableOptimizedLoading: nextConfig.experimental.disableOptimizedLoading,\n                        parentSpanId: input.parentSpanId,\n                        httpAgentOptions: nextConfig.httpAgentOptions,\n                        debugOutput: options.debugOutput,\n                        enableExperimentalReact: (0, _needsexperimentalreact.needsExperimentalReact)(nextConfig),\n                        sriEnabled: Boolean((_nextConfig_experimental_sri = nextConfig.experimental.sri) == null ? void 0 : _nextConfig_experimental_sri.algorithm),\n                        buildId: input.buildId\n                    }),\n                    // If exporting the page takes longer than the timeout, reject the promise.\n                    new Promise((_, reject)=>{\n                        setTimeout(()=>{\n                            reject(new TimeoutError());\n                        }, nextConfig.staticPageGenerationTimeout * 1000);\n                    })\n                ]);\n                // If there was an error in the export, throw it immediately. In the catch block, we might retry the export,\n                // or immediately fail the build, depending on user configuration. We might also continue on and attempt other pages.\n                if (result && 'error' in result) {\n                    throw new ExportPageError();\n                }\n                break;\n            } catch (err) {\n                // The only error that should be caught here is an ExportError, as `exportPage` doesn't throw and instead returns an object with an `error` property.\n                // This is an overly cautious check to ensure that we don't accidentally catch an unexpected error.\n                if (!(err instanceof ExportPageError || err instanceof TimeoutError)) {\n                    throw err;\n                }\n                if (err instanceof TimeoutError) {\n                    // If the export times out, we will restart the worker up to 3 times.\n                    maxAttempts = 3;\n                }\n                // We've reached the maximum number of attempts\n                if (attempt >= maxAttempts - 1) {\n                    // Log a message if we've reached the maximum number of attempts.\n                    // We only care to do this if maxAttempts was configured.\n                    if (maxAttempts > 1) {\n                        console.info(`Failed to build ${pageKey} after ${maxAttempts} attempts.`);\n                    }\n                    // If prerenderEarlyExit is enabled, we'll exit the build immediately.\n                    if (nextConfig.experimental.prerenderEarlyExit) {\n                        console.error(`Export encountered an error on ${pageKey}, exiting the build.`);\n                        process.exit(1);\n                    } else {\n                    // Otherwise, this is a no-op. The build will continue, and a summary of failed pages will be displayed at the end.\n                    }\n                } else {\n                    // Otherwise, we have more attempts to make. Wait before retrying\n                    if (err instanceof TimeoutError) {\n                        console.info(`Failed to build ${pageKey} (attempt ${attempt + 1} of ${maxAttempts}) because it took more than ${nextConfig.staticPageGenerationTimeout} seconds. Retrying again shortly.`);\n                    } else {\n                        console.info(`Failed to build ${pageKey} (attempt ${attempt + 1} of ${maxAttempts}). Retrying again shortly.`);\n                    }\n                    // Exponential backoff with random jitter to avoid thundering herd on retries\n                    const baseDelay = 500 // 500ms\n                    ;\n                    const maxDelay = 2000 // 2 seconds\n                    ;\n                    const delay = Math.min(baseDelay * Math.pow(2, attempt), maxDelay);\n                    const jitter = Math.random() * 0.3 * delay // Add up to 30% random jitter\n                    ;\n                    await new Promise((r)=>setTimeout(r, delay + jitter));\n                }\n            }\n            attempt++;\n        }\n        return {\n            result,\n            path,\n            pageKey\n        };\n    };\n    for(let i = 0; i < paths.length; i += maxConcurrency){\n        const subset = paths.slice(i, i + maxConcurrency);\n        const subsetResults = await Promise.all(subset.map((path)=>exportPageWithRetry(path, nextConfig.experimental.staticGenerationRetryCount ?? 1)));\n        results.push(...subsetResults);\n    }\n    return results;\n}\nasync function exportPage(input) {\n    (0, _trace.trace)('export-page', input.parentSpanId).setAttribute('path', input.path);\n    // Configure the http agent.\n    (0, _setuphttpagentenv.setHttpClientAndAgentOptions)({\n        httpAgentOptions: input.httpAgentOptions\n    });\n    const fileWriter = new _multifilewriter.MultiFileWriter({\n        writeFile: (filePath, data)=>_promises.default.writeFile(filePath, data),\n        mkdir: (dir)=>_promises.default.mkdir(dir, {\n                recursive: true\n            })\n    });\n    const exportPageSpan = (0, _trace.trace)('export-page-worker', input.parentSpanId);\n    const start = Date.now();\n    const turborepoAccessTraceResult = new _turborepoaccesstrace.TurborepoAccessTraceResult();\n    // Export the page.\n    let result;\n    try {\n        result = await exportPageSpan.traceAsyncFn(()=>(0, _turborepoaccesstrace.turborepoTraceAccess)(()=>exportPageImpl(input, fileWriter), turborepoAccessTraceResult));\n        // Wait for all the files to flush to disk.\n        await fileWriter.wait();\n        // If there was no result, then we can exit early.\n        if (!result) return;\n        // If there was an error, then we can exit early.\n        if ('error' in result) {\n            return {\n                error: result.error,\n                duration: Date.now() - start\n            };\n        }\n    } catch (err) {\n        console.error(`Error occurred prerendering page \"${input.path}\". Read more: https://nextjs.org/docs/messages/prerender-error`);\n        // bailoutToCSRError errors should not leak to the user as they are not actionable; they're\n        // a framework signal\n        if (!(0, _bailouttocsr.isBailoutToCSRError)(err)) {\n            // A static generation bailout error is a framework signal to fail static generation but\n            // and will encode a reason in the error message. If there is a message, we'll print it.\n            // Otherwise there's nothing to show as we don't want to leak an error internal error stack to the user.\n            if ((0, _staticgenerationbailout.isStaticGenBailoutError)(err)) {\n                if (err.message) {\n                    console.error(`Error: ${err.message}`);\n                }\n            } else if ((0, _iserror.default)(err) && err.stack) {\n                console.error(err.stack);\n            } else {\n                console.error(err);\n            }\n        }\n        return {\n            error: true,\n            duration: Date.now() - start\n        };\n    }\n    // Notify the parent process that we processed a page (used by the progress activity indicator)\n    process.send == null ? void 0 : process.send.call(process, [\n        3,\n        {\n            type: 'activity'\n        }\n    ]);\n    // Otherwise we can return the result.\n    return {\n        duration: Date.now() - start,\n        ampValidations: result.ampValidations,\n        cacheControl: result.cacheControl,\n        metadata: result.metadata,\n        ssgNotFound: result.ssgNotFound,\n        hasEmptyPrelude: result.hasEmptyPrelude,\n        hasPostponed: result.hasPostponed,\n        turborepoAccessTraceResult: turborepoAccessTraceResult.serialize(),\n        fetchMetrics: result.fetchMetrics\n    };\n}\nprocess.on('unhandledRejection', (err)=>{\n    // if it's a postpone error, it'll be handled later\n    // when the postponed promise is actually awaited.\n    if ((0, _ispostpone.isPostpone)(err)) {\n        return;\n    }\n    // we don't want to log these errors\n    if ((0, _isdynamicusageerror.isDynamicUsageError)(err)) {\n        return;\n    }\n    console.error(err);\n});\nprocess.on('rejectionHandled', ()=>{\n// It is ok to await a Promise late in Next.js as it allows for better\n// prefetching patterns to avoid waterfalls. We ignore logging these.\n// We should've already errored in anyway unhandledRejection.\n});\nconst FATAL_UNHANDLED_NEXT_API_EXIT_CODE = 78;\nprocess.on('uncaughtException', (err)=>{\n    if ((0, _isdynamicusageerror.isDynamicUsageError)(err)) {\n        console.error('A Next.js API that uses exceptions to signal framework behavior was uncaught. This suggests improper usage of a Next.js API. The original error is printed below and the build will now exit.');\n        console.error(err);\n        process.exit(FATAL_UNHANDLED_NEXT_API_EXIT_CODE);\n    } else {\n        console.error(err);\n    }\n});\n\n//# sourceMappingURL=worker.js.map"
        }
    ]
}