{
    "sourceFile": "node_modules/next/dist/export/index.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892855842,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    ExportError: null,\n    default: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    ExportError: function() {\n        return ExportError;\n    },\n    default: function() {\n        return exportApp;\n    }\n});\nconst _build = require(\"../build\");\nconst _picocolors = require(\"../lib/picocolors\");\nconst _findup = /*#__PURE__*/ _interop_require_default(require(\"next/dist/compiled/find-up\"));\nconst _fs = require(\"fs\");\nrequire(\"../server/require-hook\");\nconst _path = require(\"path\");\nconst _index = require(\"../build/output/index\");\nconst _log = /*#__PURE__*/ _interop_require_wildcard(require(\"../build/output/log\"));\nconst _constants = require(\"../lib/constants\");\nconst _recursivecopy = require(\"../lib/recursive-copy\");\nconst _constants1 = require(\"../shared/lib/constants\");\nconst _config = /*#__PURE__*/ _interop_require_default(require(\"../server/config\"));\nconst _events = require(\"../telemetry/events\");\nconst _ciinfo = require(\"../server/ci-info\");\nconst _storage = require(\"../telemetry/storage\");\nconst _normalizepagepath = require(\"../shared/lib/page-path/normalize-page-path\");\nconst _denormalizepagepath = require(\"../shared/lib/page-path/denormalize-page-path\");\nconst _env = require(\"@next/env\");\nconst _isapiroute = require(\"../lib/is-api-route\");\nconst _require = require(\"../server/require\");\nconst _isapprouteroute = require(\"../lib/is-app-route-route\");\nconst _isapppageroute = require(\"../lib/is-app-page-route\");\nconst _iserror = /*#__PURE__*/ _interop_require_default(require(\"../lib/is-error\"));\nconst _formatmanifest = require(\"../build/manifests/formatter/format-manifest\");\nconst _turborepoaccesstrace = require(\"../build/turborepo-access-trace\");\nconst _progress = require(\"../build/progress\");\nconst _generateinterceptionroutesrewrites = require(\"../lib/generate-interception-routes-rewrites\");\nconst _serverreferenceinfo = require(\"../shared/lib/server-reference-info\");\nconst _segmentvalueencoding = require(\"../shared/lib/segment-cache/segment-value-encoding\");\nfunction _interop_require_default(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nfunction _getRequireWildcardCache(nodeInterop) {\n    if (typeof WeakMap !== \"function\") return null;\n    var cacheBabelInterop = new WeakMap();\n    var cacheNodeInterop = new WeakMap();\n    return (_getRequireWildcardCache = function(nodeInterop) {\n        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n    })(nodeInterop);\n}\nfunction _interop_require_wildcard(obj, nodeInterop) {\n    if (!nodeInterop && obj && obj.__esModule) {\n        return obj;\n    }\n    if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n        return {\n            default: obj\n        };\n    }\n    var cache = _getRequireWildcardCache(nodeInterop);\n    if (cache && cache.has(obj)) {\n        return cache.get(obj);\n    }\n    var newObj = {\n        __proto__: null\n    };\n    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n    for(var key in obj){\n        if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n            if (desc && (desc.get || desc.set)) {\n                Object.defineProperty(newObj, key, desc);\n            } else {\n                newObj[key] = obj[key];\n            }\n        }\n    }\n    newObj.default = obj;\n    if (cache) {\n        cache.set(obj, newObj);\n    }\n    return newObj;\n}\nclass ExportError extends Error {\n    constructor(...args){\n        super(...args), this.code = 'NEXT_EXPORT_ERROR';\n    }\n}\nasync function exportAppImpl(dir, options, span) {\n    var _nextConfig_amp, _nextConfig_experimental_amp, _nextConfig_experimental_amp1;\n    dir = (0, _path.resolve)(dir);\n    // attempt to load global env values so they are available in next.config.js\n    span.traceChild('load-dotenv').traceFn(()=>(0, _env.loadEnvConfig)(dir, false, _log));\n    const { enabledDirectories } = options;\n    const nextConfig = options.nextConfig || await span.traceChild('load-next-config').traceAsyncFn(()=>(0, _config.default)(_constants1.PHASE_EXPORT, dir));\n    const distDir = (0, _path.join)(dir, nextConfig.distDir);\n    const telemetry = options.buildExport ? null : new _storage.Telemetry({\n        distDir\n    });\n    if (telemetry) {\n        telemetry.record((0, _events.eventCliSession)(distDir, nextConfig, {\n            webpackVersion: null,\n            cliCommand: 'export',\n            isSrcDir: null,\n            hasNowJson: !!await (0, _findup.default)('now.json', {\n                cwd: dir\n            }),\n            isCustomServer: null,\n            turboFlag: false,\n            pagesDir: null,\n            appDir: null\n        }));\n    }\n    const subFolders = nextConfig.trailingSlash && !options.buildExport;\n    if (!options.silent && !options.buildExport) {\n        _log.info(`using build directory: ${distDir}`);\n    }\n    const buildIdFile = (0, _path.join)(distDir, _constants1.BUILD_ID_FILE);\n    if (!(0, _fs.existsSync)(buildIdFile)) {\n        throw Object.defineProperty(new ExportError(`Could not find a production build in the '${distDir}' directory. Try building your app with 'next build' before starting the static export. https://nextjs.org/docs/messages/next-export-no-build-id`), \"__NEXT_ERROR_CODE\", {\n            value: \"E610\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    const customRoutes = [\n        'rewrites',\n        'redirects',\n        'headers'\n    ].filter((config)=>typeof nextConfig[config] === 'function');\n    if (!_ciinfo.hasNextSupport && !options.buildExport && customRoutes.length > 0) {\n        _log.warn(`rewrites, redirects, and headers are not applied when exporting your application, detected (${customRoutes.join(', ')}). See more info here: https://nextjs.org/docs/messages/export-no-custom-routes`);\n    }\n    const buildId = await _fs.promises.readFile(buildIdFile, 'utf8');\n    const pagesManifest = !options.pages && require((0, _path.join)(distDir, _constants1.SERVER_DIRECTORY, _constants1.PAGES_MANIFEST));\n    let prerenderManifest;\n    try {\n        prerenderManifest = require((0, _path.join)(distDir, _constants1.PRERENDER_MANIFEST));\n    } catch  {}\n    let appRoutePathManifest;\n    try {\n        appRoutePathManifest = require((0, _path.join)(distDir, _constants1.APP_PATH_ROUTES_MANIFEST));\n    } catch (err) {\n        if ((0, _iserror.default)(err) && (err.code === 'ENOENT' || err.code === 'MODULE_NOT_FOUND')) {\n            // the manifest doesn't exist which will happen when using\n            // \"pages\" dir instead of \"app\" dir.\n            appRoutePathManifest = undefined;\n        } else {\n            // the manifest is malformed (invalid json)\n            throw err;\n        }\n    }\n    const excludedPrerenderRoutes = new Set();\n    const pages = options.pages || Object.keys(pagesManifest);\n    const defaultPathMap = {};\n    let hasApiRoutes = false;\n    for (const page of pages){\n        // _document and _app are not real pages\n        // _error is exported as 404.html later on\n        // API Routes are Node.js functions\n        if ((0, _isapiroute.isAPIRoute)(page)) {\n            hasApiRoutes = true;\n            continue;\n        }\n        if (page === '/_document' || page === '/_app' || page === '/_error') {\n            continue;\n        }\n        // iSSG pages that are dynamic should not export templated version by\n        // default. In most cases, this would never work. There is no server that\n        // could run `getStaticProps`. If users make their page work lazily, they\n        // can manually add it to the `exportPathMap`.\n        if (prerenderManifest == null ? void 0 : prerenderManifest.dynamicRoutes[page]) {\n            excludedPrerenderRoutes.add(page);\n            continue;\n        }\n        defaultPathMap[page] = {\n            page\n        };\n    }\n    const mapAppRouteToPage = new Map();\n    if (!options.buildExport && appRoutePathManifest) {\n        for (const [pageName, routePath] of Object.entries(appRoutePathManifest)){\n            mapAppRouteToPage.set(routePath, pageName);\n            if ((0, _isapppageroute.isAppPageRoute)(pageName) && !(prerenderManifest == null ? void 0 : prerenderManifest.routes[routePath]) && !(prerenderManifest == null ? void 0 : prerenderManifest.dynamicRoutes[routePath])) {\n                defaultPathMap[routePath] = {\n                    page: pageName,\n                    _isAppDir: true\n                };\n            }\n        }\n    }\n    // Initialize the output directory\n    const outDir = options.outdir;\n    if (outDir === (0, _path.join)(dir, 'public')) {\n        throw Object.defineProperty(new ExportError(`The 'public' directory is reserved in Next.js and can not be used as the export out directory. https://nextjs.org/docs/messages/can-not-output-to-public`), \"__NEXT_ERROR_CODE\", {\n            value: \"E588\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    if (outDir === (0, _path.join)(dir, 'static')) {\n        throw Object.defineProperty(new ExportError(`The 'static' directory is reserved in Next.js and can not be used as the export out directory. https://nextjs.org/docs/messages/can-not-output-to-static`), \"__NEXT_ERROR_CODE\", {\n            value: \"E548\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    await _fs.promises.rm(outDir, {\n        recursive: true,\n        force: true\n    });\n    await _fs.promises.mkdir((0, _path.join)(outDir, '_next', buildId), {\n        recursive: true\n    });\n    await _fs.promises.writeFile((0, _path.join)(distDir, _constants1.EXPORT_DETAIL), (0, _formatmanifest.formatManifest)({\n        version: 1,\n        outDirectory: outDir,\n        success: false\n    }), 'utf8');\n    // Copy static directory\n    if (!options.buildExport && (0, _fs.existsSync)((0, _path.join)(dir, 'static'))) {\n        if (!options.silent) {\n            _log.info('Copying \"static\" directory');\n        }\n        await span.traceChild('copy-static-directory').traceAsyncFn(()=>(0, _recursivecopy.recursiveCopy)((0, _path.join)(dir, 'static'), (0, _path.join)(outDir, 'static')));\n    }\n    // Copy .next/static directory\n    if (!options.buildExport && (0, _fs.existsSync)((0, _path.join)(distDir, _constants1.CLIENT_STATIC_FILES_PATH))) {\n        if (!options.silent) {\n            _log.info('Copying \"static build\" directory');\n        }\n        await span.traceChild('copy-next-static-directory').traceAsyncFn(()=>(0, _recursivecopy.recursiveCopy)((0, _path.join)(distDir, _constants1.CLIENT_STATIC_FILES_PATH), (0, _path.join)(outDir, '_next', _constants1.CLIENT_STATIC_FILES_PATH)));\n    }\n    // Get the exportPathMap from the config file\n    if (typeof nextConfig.exportPathMap !== 'function') {\n        nextConfig.exportPathMap = async (defaultMap)=>{\n            return defaultMap;\n        };\n    }\n    const { i18n, images: { loader = 'default', unoptimized } } = nextConfig;\n    if (i18n && !options.buildExport) {\n        throw Object.defineProperty(new ExportError(`i18n support is not compatible with next export. See here for more info on deploying: https://nextjs.org/docs/messages/export-no-custom-routes`), \"__NEXT_ERROR_CODE\", {\n            value: \"E587\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    if (!options.buildExport) {\n        const { isNextImageImported } = await span.traceChild('is-next-image-imported').traceAsyncFn(()=>_fs.promises.readFile((0, _path.join)(distDir, _constants1.EXPORT_MARKER), 'utf8').then((text)=>JSON.parse(text)).catch(()=>({})));\n        if (isNextImageImported && loader === 'default' && !unoptimized && !_ciinfo.hasNextSupport) {\n            throw Object.defineProperty(new ExportError(`Image Optimization using the default loader is not compatible with export.\n  Possible solutions:\n    - Use \\`next start\\` to run a server, which includes the Image Optimization API.\n    - Configure \\`images.unoptimized = true\\` in \\`next.config.js\\` to disable the Image Optimization API.\n  Read more: https://nextjs.org/docs/messages/export-image-api`), \"__NEXT_ERROR_CODE\", {\n                value: \"E603\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n    }\n    let serverActionsManifest;\n    if (enabledDirectories.app) {\n        serverActionsManifest = require((0, _path.join)(distDir, _constants1.SERVER_DIRECTORY, _constants1.SERVER_REFERENCE_MANIFEST + '.json'));\n        if (nextConfig.output === 'export') {\n            var _routesManifest_rewrites_beforeFiles, _routesManifest_rewrites;\n            const routesManifest = require((0, _path.join)(distDir, _constants1.ROUTES_MANIFEST));\n            // We already prevent rewrites earlier in the process, however Next.js will insert rewrites\n            // for interception routes so we need to check for that here.\n            if ((routesManifest == null ? void 0 : (_routesManifest_rewrites = routesManifest.rewrites) == null ? void 0 : (_routesManifest_rewrites_beforeFiles = _routesManifest_rewrites.beforeFiles) == null ? void 0 : _routesManifest_rewrites_beforeFiles.length) > 0) {\n                const hasInterceptionRouteRewrite = routesManifest.rewrites.beforeFiles.some(_generateinterceptionroutesrewrites.isInterceptionRouteRewrite);\n                if (hasInterceptionRouteRewrite) {\n                    throw Object.defineProperty(new ExportError(`Intercepting routes are not supported with static export.\\nRead more: https://nextjs.org/docs/app/building-your-application/deploying/static-exports#unsupported-features`), \"__NEXT_ERROR_CODE\", {\n                        value: \"E626\",\n                        enumerable: false,\n                        configurable: true\n                    });\n                }\n            }\n            const actionIds = [\n                ...Object.keys(serverActionsManifest.node),\n                ...Object.keys(serverActionsManifest.edge)\n            ];\n            if (actionIds.some((actionId)=>(0, _serverreferenceinfo.extractInfoFromServerReferenceId)(actionId).type === 'server-action')) {\n                throw Object.defineProperty(new ExportError(`Server Actions are not supported with static export.\\nRead more: https://nextjs.org/docs/app/building-your-application/deploying/static-exports#unsupported-features`), \"__NEXT_ERROR_CODE\", {\n                    value: \"E625\",\n                    enumerable: false,\n                    configurable: true\n                });\n            }\n        }\n    }\n    // Start the rendering process\n    const renderOpts = {\n        previewProps: prerenderManifest == null ? void 0 : prerenderManifest.preview,\n        nextExport: true,\n        assetPrefix: nextConfig.assetPrefix.replace(/\\/$/, ''),\n        distDir,\n        dev: false,\n        basePath: nextConfig.basePath,\n        trailingSlash: nextConfig.trailingSlash,\n        canonicalBase: ((_nextConfig_amp = nextConfig.amp) == null ? void 0 : _nextConfig_amp.canonicalBase) || '',\n        ampSkipValidation: ((_nextConfig_experimental_amp = nextConfig.experimental.amp) == null ? void 0 : _nextConfig_experimental_amp.skipValidation) || false,\n        ampOptimizerConfig: ((_nextConfig_experimental_amp1 = nextConfig.experimental.amp) == null ? void 0 : _nextConfig_experimental_amp1.optimizer) || undefined,\n        locales: i18n == null ? void 0 : i18n.locales,\n        locale: i18n == null ? void 0 : i18n.defaultLocale,\n        defaultLocale: i18n == null ? void 0 : i18n.defaultLocale,\n        domainLocales: i18n == null ? void 0 : i18n.domains,\n        disableOptimizedLoading: nextConfig.experimental.disableOptimizedLoading,\n        // Exported pages do not currently support dynamic HTML.\n        supportsDynamicResponse: false,\n        crossOrigin: nextConfig.crossOrigin,\n        optimizeCss: nextConfig.experimental.optimizeCss,\n        nextConfigOutput: nextConfig.output,\n        nextScriptWorkers: nextConfig.experimental.nextScriptWorkers,\n        largePageDataBytes: nextConfig.experimental.largePageDataBytes,\n        serverActions: nextConfig.experimental.serverActions,\n        serverComponents: enabledDirectories.app,\n        cacheLifeProfiles: nextConfig.experimental.cacheLife,\n        nextFontManifest: require((0, _path.join)(distDir, 'server', `${_constants1.NEXT_FONT_MANIFEST}.json`)),\n        images: nextConfig.images,\n        ...enabledDirectories.app ? {\n            serverActionsManifest\n        } : {},\n        strictNextHead: nextConfig.experimental.strictNextHead ?? true,\n        deploymentId: nextConfig.deploymentId,\n        htmlLimitedBots: nextConfig.htmlLimitedBots.source,\n        experimental: {\n            clientTraceMetadata: nextConfig.experimental.clientTraceMetadata,\n            expireTime: nextConfig.expireTime,\n            dynamicIO: nextConfig.experimental.dynamicIO ?? false,\n            clientSegmentCache: nextConfig.experimental.clientSegmentCache === 'client-only' ? 'client-only' : Boolean(nextConfig.experimental.clientSegmentCache),\n            dynamicOnHover: nextConfig.experimental.dynamicOnHover ?? false,\n            inlineCss: nextConfig.experimental.inlineCss ?? false,\n            authInterrupts: !!nextConfig.experimental.authInterrupts\n        },\n        reactMaxHeadersLength: nextConfig.reactMaxHeadersLength\n    };\n    const { publicRuntimeConfig } = nextConfig;\n    if (Object.keys(publicRuntimeConfig).length > 0) {\n        renderOpts.runtimeConfig = publicRuntimeConfig;\n    }\n    // We need this for server rendering the Link component.\n    ;\n    globalThis.__NEXT_DATA__ = {\n        nextExport: true\n    };\n    const exportPathMap = await span.traceChild('run-export-path-map').traceAsyncFn(async ()=>{\n        const exportMap = await nextConfig.exportPathMap(defaultPathMap, {\n            dev: false,\n            dir,\n            outDir,\n            distDir,\n            buildId\n        });\n        return exportMap;\n    });\n    // only add missing 404 page when `buildExport` is false\n    if (!options.buildExport) {\n        // only add missing /404 if not specified in `exportPathMap`\n        if (!exportPathMap['/404']) {\n            exportPathMap['/404'] = {\n                page: '/_error'\n            };\n        }\n        /**\n     * exports 404.html for backwards compat\n     * E.g. GitHub Pages, GitLab Pages, Cloudflare Pages, Netlify\n     */ if (!exportPathMap['/404.html']) {\n            // alias /404.html to /404 to be compatible with custom 404 / _error page\n            exportPathMap['/404.html'] = exportPathMap['/404'];\n        }\n    }\n    // make sure to prevent duplicates\n    const exportPaths = [\n        ...new Set(Object.keys(exportPathMap).map((path)=>(0, _denormalizepagepath.denormalizePagePath)((0, _normalizepagepath.normalizePagePath)(path))))\n    ];\n    const filteredPaths = exportPaths.filter((route)=>exportPathMap[route]._isAppDir || // Remove API routes\n        !(0, _isapiroute.isAPIRoute)(exportPathMap[route].page));\n    if (filteredPaths.length !== exportPaths.length) {\n        hasApiRoutes = true;\n    }\n    if (filteredPaths.length === 0) {\n        return null;\n    }\n    if (prerenderManifest && !options.buildExport) {\n        const fallbackEnabledPages = new Set();\n        for (const path of Object.keys(exportPathMap)){\n            const page = exportPathMap[path].page;\n            const prerenderInfo = prerenderManifest.dynamicRoutes[page];\n            if (prerenderInfo && prerenderInfo.fallback !== false) {\n                fallbackEnabledPages.add(page);\n            }\n        }\n        if (fallbackEnabledPages.size > 0) {\n            throw Object.defineProperty(new ExportError(`Found pages with \\`fallback\\` enabled:\\n${[\n                ...fallbackEnabledPages\n            ].join('\\n')}\\n${_constants.SSG_FALLBACK_EXPORT_ERROR}\\n`), \"__NEXT_ERROR_CODE\", {\n                value: \"E533\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n    }\n    let hasMiddleware = false;\n    if (!options.buildExport) {\n        try {\n            var _functionsConfigManifest_functions;\n            const middlewareManifest = require((0, _path.join)(distDir, _constants1.SERVER_DIRECTORY, _constants1.MIDDLEWARE_MANIFEST));\n            const functionsConfigManifest = require((0, _path.join)(distDir, _constants1.SERVER_DIRECTORY, _constants1.FUNCTIONS_CONFIG_MANIFEST));\n            hasMiddleware = Object.keys(middlewareManifest.middleware).length > 0 || Boolean((_functionsConfigManifest_functions = functionsConfigManifest.functions) == null ? void 0 : _functionsConfigManifest_functions['/_middleware']);\n        } catch  {}\n        // Warn if the user defines a path for an API page\n        if (hasApiRoutes || hasMiddleware) {\n            if (nextConfig.output === 'export') {\n                _log.warn((0, _picocolors.yellow)(`Statically exporting a Next.js application via \\`next export\\` disables API routes and middleware.`) + `\\n` + (0, _picocolors.yellow)(`This command is meant for static-only hosts, and is` + ' ' + (0, _picocolors.bold)(`not necessary to make your application static.`)) + `\\n` + (0, _picocolors.yellow)(`Pages in your application without server-side data dependencies will be automatically statically exported by \\`next build\\`, including pages powered by \\`getStaticProps\\`.`) + `\\n` + (0, _picocolors.yellow)(`Learn more: https://nextjs.org/docs/messages/api-routes-static-export`));\n            }\n        }\n    }\n    const pagesDataDir = options.buildExport ? outDir : (0, _path.join)(outDir, '_next/data', buildId);\n    const ampValidations = {};\n    const publicDir = (0, _path.join)(dir, _constants1.CLIENT_PUBLIC_FILES_PATH);\n    // Copy public directory\n    if (!options.buildExport && (0, _fs.existsSync)(publicDir)) {\n        if (!options.silent) {\n            _log.info('Copying \"public\" directory');\n        }\n        await span.traceChild('copy-public-directory').traceAsyncFn(()=>(0, _recursivecopy.recursiveCopy)(publicDir, outDir, {\n                filter (path) {\n                    // Exclude paths used by pages\n                    return !exportPathMap[path];\n                }\n            }));\n    }\n    const failedExportAttemptsByPage = new Map();\n    // Chunk filtered pages into smaller groups, and call the export worker on each group.\n    // We've set a default minimum of 25 pages per chunk to ensure that even setups\n    // with only a few static pages can leverage a shared incremental cache, however this\n    // value can be configured.\n    const minChunkSize = nextConfig.experimental.staticGenerationMinPagesPerWorker ?? 25;\n    // Calculate the number of workers needed to ensure each chunk has at least minChunkSize pages\n    const numWorkers = Math.min(options.numWorkers, Math.ceil(filteredPaths.length / minChunkSize));\n    // Calculate the chunk size based on the number of workers\n    const chunkSize = Math.ceil(filteredPaths.length / numWorkers);\n    const chunks = Array.from({\n        length: numWorkers\n    }, (_, i)=>filteredPaths.slice(i * chunkSize, (i + 1) * chunkSize));\n    // Distribute remaining pages\n    const remainingPages = filteredPaths.slice(numWorkers * chunkSize);\n    remainingPages.forEach((page, index)=>{\n        chunks[index % chunks.length].push(page);\n    });\n    const progress = (0, _progress.createProgress)(filteredPaths.length, options.statusMessage || 'Exporting');\n    const worker = (0, _build.createStaticWorker)(nextConfig, progress);\n    const results = (await Promise.all(chunks.map((paths)=>worker.exportPages({\n            buildId,\n            paths,\n            exportPathMap,\n            parentSpanId: span.getId(),\n            pagesDataDir,\n            renderOpts,\n            options,\n            dir,\n            distDir,\n            outDir,\n            nextConfig,\n            cacheHandler: nextConfig.cacheHandler,\n            cacheMaxMemorySize: nextConfig.cacheMaxMemorySize,\n            fetchCache: true,\n            fetchCacheKeyPrefix: nextConfig.experimental.fetchCacheKeyPrefix\n        })))).flat();\n    let hadValidationError = false;\n    const collector = {\n        byPath: new Map(),\n        byPage: new Map(),\n        ssgNotFoundPaths: new Set(),\n        turborepoAccessTraceResults: new Map()\n    };\n    for (const { result, path, pageKey } of results){\n        if (!result) continue;\n        if ('error' in result) {\n            failedExportAttemptsByPage.set(pageKey, true);\n            continue;\n        }\n        const { page } = exportPathMap[path];\n        if (result.turborepoAccessTraceResult) {\n            var _collector_turborepoAccessTraceResults;\n            (_collector_turborepoAccessTraceResults = collector.turborepoAccessTraceResults) == null ? void 0 : _collector_turborepoAccessTraceResults.set(path, _turborepoaccesstrace.TurborepoAccessTraceResult.fromSerialized(result.turborepoAccessTraceResult));\n        }\n        // Capture any amp validations.\n        if (result.ampValidations) {\n            for (const validation of result.ampValidations){\n                ampValidations[validation.page] = validation.result;\n                hadValidationError ||= validation.result.errors.length > 0;\n            }\n        }\n        if (options.buildExport) {\n            // Update path info by path.\n            const info = collector.byPath.get(path) ?? {};\n            if (result.cacheControl) {\n                info.cacheControl = result.cacheControl;\n            }\n            if (typeof result.metadata !== 'undefined') {\n                info.metadata = result.metadata;\n            }\n            if (typeof result.hasEmptyPrelude !== 'undefined') {\n                info.hasEmptyPrelude = result.hasEmptyPrelude;\n            }\n            if (typeof result.hasPostponed !== 'undefined') {\n                info.hasPostponed = result.hasPostponed;\n            }\n            if (typeof result.fetchMetrics !== 'undefined') {\n                info.fetchMetrics = result.fetchMetrics;\n            }\n            collector.byPath.set(path, info);\n            // Update not found.\n            if (result.ssgNotFound === true) {\n                collector.ssgNotFoundPaths.add(path);\n            }\n            // Update durations.\n            const durations = collector.byPage.get(page) ?? {\n                durationsByPath: new Map()\n            };\n            durations.durationsByPath.set(path, result.duration);\n            collector.byPage.set(page, durations);\n        }\n    }\n    // Export mode provide static outputs that are not compatible with PPR mode.\n    if (!options.buildExport && nextConfig.experimental.ppr) {\n        // TODO: add message\n        throw Object.defineProperty(new Error('Invariant: PPR cannot be enabled in export mode'), \"__NEXT_ERROR_CODE\", {\n            value: \"E54\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    // copy prerendered routes to outDir\n    if (!options.buildExport && prerenderManifest) {\n        await Promise.all(Object.keys(prerenderManifest.routes).map(async (unnormalizedRoute)=>{\n            const { srcRoute } = prerenderManifest.routes[unnormalizedRoute];\n            const appPageName = mapAppRouteToPage.get(srcRoute || '');\n            const pageName = appPageName || srcRoute || unnormalizedRoute;\n            const isAppPath = Boolean(appPageName);\n            const isAppRouteHandler = appPageName && (0, _isapprouteroute.isAppRouteRoute)(appPageName);\n            // returning notFound: true from getStaticProps will not\n            // output html/json files during the build\n            if (prerenderManifest.notFoundRoutes.includes(unnormalizedRoute)) {\n                return;\n            }\n            // TODO: This rewrites /index/foo to /index/index/foo. Investigate and\n            // fix. I presume this was because normalizePagePath was designed for\n            // some other use case and then reused here for static exports without\n            // realizing the implications.\n            const route = (0, _normalizepagepath.normalizePagePath)(unnormalizedRoute);\n            const pagePath = (0, _require.getPagePath)(pageName, distDir, undefined, isAppPath);\n            const distPagesDir = (0, _path.join)(pagePath, // strip leading / and then recurse number of nested dirs\n            // to place from base folder\n            pageName.slice(1).split('/').map(()=>'..').join('/'));\n            const orig = (0, _path.join)(distPagesDir, route);\n            const handlerSrc = `${orig}.body`;\n            const handlerDest = (0, _path.join)(outDir, route);\n            if (isAppRouteHandler && (0, _fs.existsSync)(handlerSrc)) {\n                await _fs.promises.mkdir((0, _path.dirname)(handlerDest), {\n                    recursive: true\n                });\n                await _fs.promises.copyFile(handlerSrc, handlerDest);\n                return;\n            }\n            const htmlDest = (0, _path.join)(outDir, `${route}${subFolders && route !== '/index' ? `${_path.sep}index` : ''}.html`);\n            const ampHtmlDest = (0, _path.join)(outDir, `${route}.amp${subFolders ? `${_path.sep}index` : ''}.html`);\n            const jsonDest = isAppPath ? (0, _path.join)(outDir, `${route}${subFolders && route !== '/index' ? `${_path.sep}index` : ''}.txt`) : (0, _path.join)(pagesDataDir, `${route}.json`);\n            await _fs.promises.mkdir((0, _path.dirname)(htmlDest), {\n                recursive: true\n            });\n            await _fs.promises.mkdir((0, _path.dirname)(jsonDest), {\n                recursive: true\n            });\n            const htmlSrc = `${orig}.html`;\n            const jsonSrc = `${orig}${isAppPath ? _constants.RSC_SUFFIX : '.json'}`;\n            await _fs.promises.copyFile(htmlSrc, htmlDest);\n            await _fs.promises.copyFile(jsonSrc, jsonDest);\n            if ((0, _fs.existsSync)(`${orig}.amp.html`)) {\n                await _fs.promises.mkdir((0, _path.dirname)(ampHtmlDest), {\n                    recursive: true\n                });\n                await _fs.promises.copyFile(`${orig}.amp.html`, ampHtmlDest);\n            }\n            const segmentsDir = `${orig}${_constants.RSC_SEGMENTS_DIR_SUFFIX}`;\n            if (isAppPath && (0, _fs.existsSync)(segmentsDir)) {\n                // Output a data file for each of this page's segments\n                //\n                // These files are requested by the client router's internal\n                // prefetcher, not the user directly. So we don't need to account for\n                // things like trailing slash handling.\n                //\n                // To keep the protocol simple, we can use the non-normalized route\n                // path instead of the normalized one (which, among other things,\n                // rewrites `/` to `/index`).\n                const segmentsDirDest = (0, _path.join)(outDir, unnormalizedRoute);\n                const segmentPaths = await collectSegmentPaths(segmentsDir);\n                await Promise.all(segmentPaths.map(async (segmentFileSrc)=>{\n                    const segmentPath = '/' + segmentFileSrc.slice(0, -_constants.RSC_SEGMENT_SUFFIX.length);\n                    const segmentFilename = (0, _segmentvalueencoding.convertSegmentPathToStaticExportFilename)(segmentPath);\n                    const segmentFileDest = (0, _path.join)(segmentsDirDest, segmentFilename);\n                    await _fs.promises.mkdir((0, _path.dirname)(segmentFileDest), {\n                        recursive: true\n                    });\n                    await _fs.promises.copyFile((0, _path.join)(segmentsDir, segmentFileSrc), segmentFileDest);\n                }));\n            }\n        }));\n    }\n    if (Object.keys(ampValidations).length) {\n        console.log((0, _index.formatAmpMessages)(ampValidations));\n    }\n    if (hadValidationError) {\n        throw Object.defineProperty(new ExportError(`AMP Validation caused the export to fail. https://nextjs.org/docs/messages/amp-export-validation`), \"__NEXT_ERROR_CODE\", {\n            value: \"E596\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    if (failedExportAttemptsByPage.size > 0) {\n        const failedPages = Array.from(failedExportAttemptsByPage.keys());\n        throw Object.defineProperty(new ExportError(`Export encountered errors on following paths:\\n\\t${failedPages.sort().join('\\n\\t')}`), \"__NEXT_ERROR_CODE\", {\n            value: \"E535\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    await _fs.promises.writeFile((0, _path.join)(distDir, _constants1.EXPORT_DETAIL), (0, _formatmanifest.formatManifest)({\n        version: 1,\n        outDirectory: outDir,\n        success: true\n    }), 'utf8');\n    if (telemetry) {\n        await telemetry.flush();\n    }\n    await worker.end();\n    return collector;\n}\nasync function collectSegmentPaths(segmentsDirectory) {\n    const results = [];\n    await collectSegmentPathsImpl(segmentsDirectory, segmentsDirectory, results);\n    return results;\n}\nasync function collectSegmentPathsImpl(segmentsDirectory, directory, results) {\n    const segmentFiles = await _fs.promises.readdir(directory, {\n        withFileTypes: true\n    });\n    await Promise.all(segmentFiles.map(async (segmentFile)=>{\n        if (segmentFile.isDirectory()) {\n            await collectSegmentPathsImpl(segmentsDirectory, (0, _path.join)(directory, segmentFile.name), results);\n            return;\n        }\n        if (!segmentFile.name.endsWith(_constants.RSC_SEGMENT_SUFFIX)) {\n            return;\n        }\n        results.push((0, _path.relative)(segmentsDirectory, (0, _path.join)(directory, segmentFile.name)));\n    }));\n}\nasync function exportApp(dir, options, span) {\n    const nextExportSpan = span.traceChild('next-export');\n    return nextExportSpan.traceAsyncFn(async ()=>{\n        return await exportAppImpl(dir, options, nextExportSpan);\n    });\n}\n\n//# sourceMappingURL=index.js.map"
        }
    ]
}