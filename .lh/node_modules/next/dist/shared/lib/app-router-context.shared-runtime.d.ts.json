{
    "sourceFile": "node_modules/next/dist/shared/lib/app-router-context.shared-runtime.d.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892898409,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import type { FetchServerResponseResult } from '../../client/components/router-reducer/fetch-server-response';\nimport type { FocusAndScrollRef, PrefetchKind } from '../../client/components/router-reducer/router-reducer-types';\nimport type { FlightRouterState, FlightSegmentPath } from '../../server/app-render/types';\nimport React from 'react';\nexport type ChildSegmentMap = Map<string, CacheNode>;\n/**\n * Cache node used in app-router / layout-router.\n */\nexport type CacheNode = ReadyCacheNode | LazyCacheNode;\nexport type LoadingModuleData = [React.JSX.Element, React.ReactNode, React.ReactNode] | null;\n/** viewport metadata node */\nexport type HeadData = React.ReactNode;\nexport type LazyCacheNode = {\n    /**\n     * When rsc is null, this is a lazily-initialized cache node.\n     *\n     * If the app attempts to render it, it triggers a lazy data fetch,\n     * postpones the render, and schedules an update to a new tree.\n     *\n     * TODO: This mechanism should not be used when PPR is enabled, though it\n     * currently is in some cases until we've implemented partial\n     * segment fetching.\n     */\n    rsc: null;\n    /**\n     * A prefetched version of the segment data. See explanation in corresponding\n     * field of ReadyCacheNode (below).\n     *\n     * Since LazyCacheNode mostly only exists in the non-PPR implementation, this\n     * will usually be null, but it could have been cloned from a previous\n     * CacheNode that was created by the PPR implementation. Eventually we want\n     * to migrate everything away from LazyCacheNode entirely.\n     */\n    prefetchRsc: React.ReactNode;\n    /**\n     * A pending response for the lazy data fetch. If this is not present\n     * during render, it is lazily created.\n     */\n    lazyData: Promise<FetchServerResponseResult> | null;\n    prefetchHead: HeadData | null;\n    head: HeadData;\n    loading: LoadingModuleData | Promise<LoadingModuleData>;\n    /**\n     * Child parallel routes.\n     */\n    parallelRoutes: Map<string, ChildSegmentMap>;\n    /**\n     * The timestamp of the navigation that last updated the CacheNode's data. If\n     * a CacheNode is reused from a previous navigation, this value is not\n     * updated. Used to track the staleness of the data.\n     */\n    navigatedAt: number;\n};\nexport type ReadyCacheNode = {\n    /**\n     * When rsc is not null, it represents the RSC data for the\n     * corresponding segment.\n     *\n     * `null` is a valid React Node but because segment data is always a\n     * <LayoutRouter> component, we can use `null` to represent empty.\n     *\n     * TODO: For additional type safety, update this type to\n     * Exclude<React.ReactNode, null>. Need to update createEmptyCacheNode to\n     * accept rsc as an argument, or just inline the callers.\n     */\n    rsc: React.ReactNode;\n    /**\n     * Represents a static version of the segment that can be shown immediately,\n     * and may or may not contain dynamic holes. It's prefetched before a\n     * navigation occurs.\n     *\n     * During rendering, we will choose whether to render `rsc` or `prefetchRsc`\n     * with `useDeferredValue`. As with the `rsc` field, a value of `null` means\n     * no value was provided. In this case, the LayoutRouter will go straight to\n     * rendering the `rsc` value; if that one is also missing, it will suspend and\n     * trigger a lazy fetch.\n     */\n    prefetchRsc: React.ReactNode;\n    /**\n     * There should never be a lazy data request in this case.\n     */\n    lazyData: null;\n    prefetchHead: HeadData | null;\n    head: HeadData;\n    loading: LoadingModuleData | Promise<LoadingModuleData>;\n    parallelRoutes: Map<string, ChildSegmentMap>;\n    navigatedAt: number;\n};\nexport interface NavigateOptions {\n    scroll?: boolean;\n}\nexport interface PrefetchOptions {\n    kind: PrefetchKind;\n}\nexport interface AppRouterInstance {\n    /**\n     * Navigate to the previous history entry.\n     */\n    back(): void;\n    /**\n     * Navigate to the next history entry.\n     */\n    forward(): void;\n    /**\n     * Refresh the current page.\n     */\n    refresh(): void;\n    /**\n     * Navigate to the provided href.\n     * Pushes a new history entry.\n     */\n    push(href: string, options?: NavigateOptions): void;\n    /**\n     * Navigate to the provided href.\n     * Replaces the current history entry.\n     */\n    replace(href: string, options?: NavigateOptions): void;\n    /**\n     * Prefetch the provided href.\n     */\n    prefetch(href: string, options?: PrefetchOptions): void;\n}\nexport declare const AppRouterContext: React.Context<AppRouterInstance | null>;\nexport declare const LayoutRouterContext: React.Context<{\n    parentTree: FlightRouterState;\n    parentCacheNode: CacheNode;\n    parentSegmentPath: FlightSegmentPath | null;\n    url: string;\n} | null>;\nexport declare const GlobalLayoutRouterContext: React.Context<{\n    tree: FlightRouterState;\n    focusAndScrollRef: FocusAndScrollRef;\n    nextUrl: string | null;\n}>;\nexport declare const TemplateContext: React.Context<React.ReactNode>;\nexport declare const MissingSlotContext: React.Context<Set<string>>;\n"
        }
    ]
}