{
    "sourceFile": "node_modules/next/dist/shared/lib/router/router.d.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892906032,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import type { ComponentType } from 'react';\nimport type { DomainLocale } from '../../../server/config';\nimport type { MittEmitter } from '../mitt';\nimport type { ParsedUrlQuery } from 'querystring';\nimport type { RouterEvent } from '../../../client/router';\nimport type { StyleSheetTuple } from '../../../client/page-loader';\nimport type { UrlObject } from 'url';\nimport type PageLoader from '../../../client/page-loader';\nimport type { NextPageContext, NEXT_DATA } from '../utils';\ndeclare global {\n    interface Window {\n        __NEXT_DATA__: NEXT_DATA;\n    }\n}\ninterface RouteProperties {\n    shallow: boolean;\n}\ninterface TransitionOptions {\n    shallow?: boolean;\n    locale?: string | false;\n    scroll?: boolean;\n    unstable_skipClientCache?: boolean;\n}\ninterface NextHistoryState {\n    url: string;\n    as: string;\n    options: TransitionOptions;\n}\nexport type HistoryState = null | {\n    __NA: true;\n    __N?: false;\n} | {\n    __N: false;\n    __NA?: false;\n} | ({\n    __NA?: false;\n    __N: true;\n    key: string;\n} & NextHistoryState);\ninterface MiddlewareEffectParams<T extends FetchDataOutput> {\n    fetchData?: () => Promise<T>;\n    locale?: string;\n    asPath: string;\n    router: Router;\n}\nexport declare function matchesMiddleware<T extends FetchDataOutput>(options: MiddlewareEffectParams<T>): Promise<boolean>;\nexport type Url = UrlObject | string;\nexport type BaseRouter = {\n    route: string;\n    pathname: string;\n    query: ParsedUrlQuery;\n    asPath: string;\n    basePath: string;\n    locale?: string | undefined;\n    locales?: readonly string[] | undefined;\n    defaultLocale?: string | undefined;\n    domainLocales?: readonly DomainLocale[] | undefined;\n    isLocaleDomain: boolean;\n};\nexport type NextRouter = BaseRouter & Pick<Router, 'push' | 'replace' | 'reload' | 'back' | 'forward' | 'prefetch' | 'beforePopState' | 'events' | 'isFallback' | 'isReady' | 'isPreview'>;\nexport type PrefetchOptions = {\n    priority?: boolean;\n    locale?: string | false;\n    unstable_skipClientCache?: boolean;\n};\nexport type PrivateRouteInfo = (Omit<CompletePrivateRouteInfo, 'styleSheets'> & {\n    initial: true;\n}) | CompletePrivateRouteInfo;\nexport type CompletePrivateRouteInfo = {\n    Component: ComponentType;\n    styleSheets: StyleSheetTuple[];\n    __N_SSG?: boolean;\n    __N_SSP?: boolean;\n    props?: Record<string, any>;\n    err?: Error;\n    error?: any;\n    route?: string;\n    resolvedAs?: string;\n    query?: ParsedUrlQuery;\n};\nexport type AppProps = Pick<CompletePrivateRouteInfo, 'Component' | 'err'> & {\n    router: Router;\n} & Record<string, any>;\nexport type AppComponent = ComponentType<AppProps>;\ntype Subscription = (data: PrivateRouteInfo, App: AppComponent, resetScroll: {\n    x: number;\n    y: number;\n} | null) => Promise<void>;\ntype BeforePopStateCallback = (state: NextHistoryState) => boolean;\ntype ComponentLoadCancel = (() => void) | null;\ntype HistoryMethod = 'replaceState' | 'pushState';\ninterface FetchDataOutput {\n    dataHref: string;\n    json: Record<string, any> | null;\n    response: Response;\n    text: string;\n    cacheKey: string;\n}\ninterface NextDataCache {\n    [asPath: string]: Promise<FetchDataOutput>;\n}\nexport declare function createKey(): string;\nexport default class Router implements BaseRouter {\n    basePath: string;\n    /**\n     * Map of all components loaded in `Router`\n     */\n    components: {\n        [pathname: string]: PrivateRouteInfo;\n    };\n    sdc: NextDataCache;\n    sbc: NextDataCache;\n    sub: Subscription;\n    clc: ComponentLoadCancel;\n    pageLoader: PageLoader;\n    _bps: BeforePopStateCallback | undefined;\n    events: MittEmitter<RouterEvent>;\n    _wrapApp: (App: AppComponent) => any;\n    isSsr: boolean;\n    _inFlightRoute?: string | undefined;\n    _shallow?: boolean | undefined;\n    locales?: readonly string[] | undefined;\n    defaultLocale?: string | undefined;\n    domainLocales?: readonly DomainLocale[] | undefined;\n    isReady: boolean;\n    isLocaleDomain: boolean;\n    isFirstPopStateEvent: boolean;\n    _initialMatchesMiddlewarePromise: Promise<boolean>;\n    _bfl_s?: import('../../lib/bloom-filter').BloomFilter;\n    _bfl_d?: import('../../lib/bloom-filter').BloomFilter;\n    private state;\n    private _key;\n    static events: MittEmitter<RouterEvent>;\n    constructor(pathname: string, query: ParsedUrlQuery, as: string, { initialProps, pageLoader, App, wrapApp, Component, err, subscription, isFallback, locale, locales, defaultLocale, domainLocales, isPreview, }: {\n        subscription: Subscription;\n        initialProps: any;\n        pageLoader: any;\n        Component: ComponentType;\n        App: AppComponent;\n        wrapApp: (WrapAppComponent: AppComponent) => any;\n        err?: Error;\n        isFallback: boolean;\n        locale?: string;\n        locales?: readonly string[];\n        defaultLocale?: string;\n        domainLocales?: readonly DomainLocale[];\n        isPreview?: boolean;\n    });\n    onPopState: (e: PopStateEvent) => void;\n    reload(): void;\n    /**\n     * Go back in history\n     */\n    back(): void;\n    /**\n     * Go forward in history\n     */\n    forward(): void;\n    /**\n     * Performs a `pushState` with arguments\n     * @param url of the route\n     * @param as masks `url` for the browser\n     * @param options object you can define `shallow` and other options\n     */\n    push(url: Url, as?: Url, options?: TransitionOptions): Promise<boolean>;\n    /**\n     * Performs a `replaceState` with arguments\n     * @param url of the route\n     * @param as masks `url` for the browser\n     * @param options object you can define `shallow` and other options\n     */\n    replace(url: Url, as?: Url, options?: TransitionOptions): Promise<boolean>;\n    _bfl(as: string, resolvedAs?: string, locale?: string | false, skipNavigate?: boolean): Promise<unknown>;\n    private change;\n    changeState(method: HistoryMethod, url: string, as: string, options?: TransitionOptions): void;\n    handleRouteInfoError(err: Error & {\n        code?: any;\n        cancelled?: boolean;\n    }, pathname: string, query: ParsedUrlQuery, as: string, routeProps: RouteProperties, loadErrorFail?: boolean): Promise<CompletePrivateRouteInfo>;\n    getRouteInfo({ route: requestedRoute, pathname, query, as, resolvedAs, routeProps, locale, hasMiddleware, isPreview, unstable_skipClientCache, isQueryUpdating, isMiddlewareRewrite, isNotFound, }: {\n        route: string;\n        pathname: string;\n        query: ParsedUrlQuery;\n        as: string;\n        resolvedAs: string;\n        hasMiddleware?: boolean;\n        routeProps: RouteProperties;\n        locale: string | undefined;\n        isPreview: boolean;\n        unstable_skipClientCache?: boolean;\n        isQueryUpdating?: boolean;\n        isMiddlewareRewrite?: boolean;\n        isNotFound?: boolean;\n    }): Promise<{\n        type: \"redirect-external\";\n        destination: string;\n    } | {\n        type: \"redirect-internal\";\n        newAs: string;\n        newUrl: string;\n    } | PrivateRouteInfo>;\n    private set;\n    /**\n     * Callback to execute before replacing router state\n     * @param cb callback to be executed\n     */\n    beforePopState(cb: BeforePopStateCallback): void;\n    onlyAHashChange(as: string): boolean;\n    scrollToHash(as: string): void;\n    urlIsNew(asPath: string): boolean;\n    /**\n     * Prefetch page code, you may wait for the data during page rendering.\n     * This feature only works in production!\n     * @param url the href of prefetched page\n     * @param asPath the as path of the prefetched page\n     */\n    prefetch(url: string, asPath?: string, options?: PrefetchOptions): Promise<void>;\n    fetchComponent(route: string): Promise<import(\"../../../client/page-loader\").GoodPageCache>;\n    _getData<T>(fn: () => Promise<T>): Promise<T>;\n    getInitialProps(Component: ComponentType, ctx: NextPageContext): Promise<Record<string, any>>;\n    get route(): string;\n    get pathname(): string;\n    get query(): ParsedUrlQuery;\n    get asPath(): string;\n    get locale(): string | undefined;\n    get isFallback(): boolean;\n    get isPreview(): boolean;\n}\nexport {};\n"
        }
    ]
}