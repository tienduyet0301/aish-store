{
    "sourceFile": "node_modules/next/dist/shared/lib/router/utils/route-regex.d.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892908593,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "export interface Group {\n    pos: number;\n    repeat: boolean;\n    optional: boolean;\n}\nexport interface RouteRegex {\n    groups: {\n        [groupName: string]: Group;\n    };\n    re: RegExp;\n}\ntype GetNamedRouteRegexOptions = {\n    /**\n     * Whether to prefix the route keys with the NEXT_INTERCEPTION_MARKER_PREFIX\n     * or NEXT_QUERY_PARAM_PREFIX. This is only relevant when creating the\n     * routes-manifest during the build.\n     */\n    prefixRouteKeys: boolean;\n    /**\n     * Whether to include the suffix in the route regex. This means that when you\n     * have something like `/[...slug].json` the `.json` part will be included\n     * in the regex, yielding `/(.*).json` as the regex.\n     */\n    includeSuffix?: boolean;\n    /**\n     * Whether to include the prefix in the route regex. This means that when you\n     * have something like `/[...slug].json` the `/` part will be included\n     * in the regex, yielding `^/(.*).json$` as the regex.\n     *\n     * Note that interception markers will already be included without the need\n     */\n    includePrefix?: boolean;\n    /**\n     * Whether to exclude the optional trailing slash from the route regex.\n     */\n    excludeOptionalTrailingSlash?: boolean;\n    /**\n     * Whether to backtrack duplicate keys. This is only relevant when creating\n     * the routes-manifest during the build.\n     */\n    backreferenceDuplicateKeys?: boolean;\n};\ntype GetRouteRegexOptions = {\n    /**\n     * Whether to include extra parts in the route regex. This means that when you\n     * have something like `/[...slug].json` the `.json` part will be included\n     * in the regex, yielding `/(.*).json` as the regex.\n     */\n    includeSuffix?: boolean;\n    /**\n     * Whether to include the prefix in the route regex. This means that when you\n     * have something like `/[...slug].json` the `/` part will be included\n     * in the regex, yielding `^/(.*).json$` as the regex.\n     *\n     * Note that interception markers will already be included without the need\n     * of adding this option.\n     */\n    includePrefix?: boolean;\n    /**\n     * Whether to exclude the optional trailing slash from the route regex.\n     */\n    excludeOptionalTrailingSlash?: boolean;\n};\n/**\n * Parses a given parameter from a route to a data structure that can be used\n * to generate the parametrized route.\n * Examples:\n *   - `[[...slug]]` -> `{ key: 'slug', repeat: true, optional: true }`\n *   - `[...slug]` -> `{ key: 'slug', repeat: true, optional: false }`\n *   - `[[foo]]` -> `{ key: 'foo', repeat: false, optional: true }`\n *   - `[bar]` -> `{ key: 'bar', repeat: false, optional: false }`\n *   - `fizz` -> `{ key: 'fizz', repeat: false, optional: false }`\n * @param param - The parameter to parse.\n * @returns The parsed parameter as a data structure.\n */\nexport declare function parseParameter(param: string): {\n    key: string;\n    repeat: boolean;\n    optional: boolean;\n};\n/**\n * From a normalized route this function generates a regular expression and\n * a corresponding groups object intended to be used to store matching groups\n * from the regular expression.\n */\nexport declare function getRouteRegex(normalizedRoute: string, { includeSuffix, includePrefix, excludeOptionalTrailingSlash, }?: GetRouteRegexOptions): RouteRegex;\n/**\n * This function extends `getRouteRegex` generating also a named regexp where\n * each group is named along with a routeKeys object that indexes the assigned\n * named group with its corresponding key. When the routeKeys need to be\n * prefixed to uniquely identify internally the \"prefixRouteKey\" arg should\n * be \"true\" currently this is only the case when creating the routes-manifest\n * during the build\n */\nexport declare function getNamedRouteRegex(normalizedRoute: string, options: GetNamedRouteRegexOptions): {\n    namedRegex: string;\n    routeKeys: {\n        [named: string]: string;\n    };\n    groups: {\n        [groupName: string]: Group;\n    };\n    re: RegExp;\n};\n/**\n * Generates a named regexp.\n * This is intended to be using for build time only.\n */\nexport declare function getNamedMiddlewareRegex(normalizedRoute: string, options: {\n    catchAll?: boolean;\n}): {\n    namedRegex: string;\n};\nexport {};\n"
        }
    ]
}