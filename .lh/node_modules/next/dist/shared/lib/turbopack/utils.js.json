{
    "sourceFile": "node_modules/next/dist/shared/lib/turbopack/utils.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892909670,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    ModuleBuildError: null,\n    TurbopackInternalError: null,\n    formatIssue: null,\n    getIssueKey: null,\n    getTurbopackJsConfig: null,\n    isPersistentCachingEnabled: null,\n    isRelevantWarning: null,\n    isWellKnownError: null,\n    processIssues: null,\n    renderStyledStringToErrorAnsi: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    ModuleBuildError: function() {\n        return ModuleBuildError;\n    },\n    TurbopackInternalError: function() {\n        return TurbopackInternalError;\n    },\n    formatIssue: function() {\n        return formatIssue;\n    },\n    getIssueKey: function() {\n        return getIssueKey;\n    },\n    getTurbopackJsConfig: function() {\n        return getTurbopackJsConfig;\n    },\n    isPersistentCachingEnabled: function() {\n        return isPersistentCachingEnabled;\n    },\n    isRelevantWarning: function() {\n        return isRelevantWarning;\n    },\n    isWellKnownError: function() {\n        return isWellKnownError;\n    },\n    processIssues: function() {\n        return processIssues;\n    },\n    renderStyledStringToErrorAnsi: function() {\n        return renderStyledStringToErrorAnsi;\n    }\n});\nconst _interop_require_default = require(\"@swc/helpers/_/_interop_require_default\");\nconst _interop_require_wildcard = require(\"@swc/helpers/_/_interop_require_wildcard\");\nconst _picocolors = require(\"../../../lib/picocolors\");\nconst _isinternal = /*#__PURE__*/ _interop_require_default._(require(\"../is-internal\"));\nconst _magicidentifier = require(\"../magic-identifier\");\nconst _log = /*#__PURE__*/ _interop_require_wildcard._(require(\"../../../build/output/log\"));\nconst _loadjsconfig = /*#__PURE__*/ _interop_require_default._(require(\"../../../build/load-jsconfig\"));\nconst _events = require(\"../../../telemetry/events\");\nconst _shared = require(\"../../../trace/shared\");\nclass ModuleBuildError extends Error {\n    constructor(...args){\n        super(...args), this.name = 'ModuleBuildError';\n    }\n}\nclass TurbopackInternalError extends Error {\n    static createAndRecordTelemetry(cause) {\n        const error = new TurbopackInternalError(cause);\n        const telemetry = _shared.traceGlobals.get('telemetry');\n        if (telemetry) {\n            telemetry.record((0, _events.eventErrorThrown)(error));\n        } else {\n            console.error('Expected `telemetry` to be set in globals');\n        }\n        return error;\n    }\n    constructor(cause){\n        super(cause.message), this.name = 'TurbopackInternalError', // Manually set this as this isn't statically determinable\n        this.__NEXT_ERROR_CODE = 'TurbopackInternalError';\n        this.stack = cause.stack;\n    }\n}\nfunction isWellKnownError(issue) {\n    const { title } = issue;\n    const formattedTitle = renderStyledStringToErrorAnsi(title);\n    // TODO: add more well known errors\n    if (formattedTitle.includes('Module not found') || formattedTitle.includes('Unknown module type')) {\n        return true;\n    }\n    return false;\n}\nfunction getIssueKey(issue) {\n    return issue.severity + \"-\" + issue.filePath + \"-\" + JSON.stringify(issue.title) + \"-\" + JSON.stringify(issue.description);\n}\nasync function getTurbopackJsConfig(dir, nextConfig) {\n    const { jsConfig } = await (0, _loadjsconfig.default)(dir, nextConfig);\n    return jsConfig != null ? jsConfig : {\n        compilerOptions: {}\n    };\n}\nfunction processIssues(currentEntryIssues, key, result, throwIssue, logErrors) {\n    const newIssues = new Map();\n    currentEntryIssues.set(key, newIssues);\n    const relevantIssues = new Set();\n    for (const issue of result.issues){\n        if (issue.severity !== 'error' && issue.severity !== 'fatal' && issue.severity !== 'warning') continue;\n        const issueKey = getIssueKey(issue);\n        newIssues.set(issueKey, issue);\n        if (issue.severity !== 'warning') {\n            if (throwIssue) {\n                const formatted = formatIssue(issue);\n                relevantIssues.add(formatted);\n            } else if (logErrors && isWellKnownError(issue)) {\n                const formatted = formatIssue(issue);\n                _log.error(formatted);\n            }\n        }\n    }\n    if (relevantIssues.size && throwIssue) {\n        throw Object.defineProperty(new ModuleBuildError([\n            ...relevantIssues\n        ].join('\\n\\n')), \"__NEXT_ERROR_CODE\", {\n            value: \"E394\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n}\nfunction formatIssue(issue) {\n    const { filePath, title, description, source } = issue;\n    let { documentationLink } = issue;\n    let formattedTitle = renderStyledStringToErrorAnsi(title).replace(/\\n/g, '\\n    ');\n    // TODO: Use error codes to identify these\n    // TODO: Generalize adapting Turbopack errors to Next.js errors\n    if (formattedTitle.includes('Module not found')) {\n        // For compatiblity with webpack\n        // TODO: include columns in webpack errors.\n        documentationLink = 'https://nextjs.org/docs/messages/module-not-found';\n    }\n    let formattedFilePath = filePath.replace('[project]/', './').replaceAll('/./', '/').replace('\\\\\\\\?\\\\', '');\n    let message = '';\n    if (source && source.range) {\n        const { start } = source.range;\n        message = formattedFilePath + \":\" + (start.line + 1) + \":\" + (start.column + 1) + \"\\n\" + formattedTitle;\n    } else if (formattedFilePath) {\n        message = formattedFilePath + \"\\n\" + formattedTitle;\n    } else {\n        message = formattedTitle;\n    }\n    message += '\\n';\n    if ((source == null ? void 0 : source.range) && source.source.content && // ignore Next.js/React internals, as these can often be huge bundled files.\n    !(0, _isinternal.default)(filePath)) {\n        const { start, end } = source.range;\n        const { codeFrameColumns } = require('next/dist/compiled/babel/code-frame');\n        message += codeFrameColumns(source.source.content, {\n            start: {\n                line: start.line + 1,\n                column: start.column + 1\n            },\n            end: {\n                line: end.line + 1,\n                column: end.column + 1\n            }\n        }, {\n            forceColor: true\n        }).trim() + '\\n\\n';\n    }\n    if (description) {\n        message += renderStyledStringToErrorAnsi(description) + '\\n\\n';\n    }\n    // TODO: make it possible to enable this for debugging, but not in tests.\n    // if (detail) {\n    //   message += renderStyledStringToErrorAnsi(detail) + '\\n\\n'\n    // }\n    // TODO: Include a trace from the issue.\n    if (documentationLink) {\n        message += documentationLink + '\\n\\n';\n    }\n    return message;\n}\nfunction isRelevantWarning(issue) {\n    return issue.severity === 'warning' && !isNodeModulesIssue(issue);\n}\nfunction isNodeModulesIssue(issue) {\n    if (issue.severity === 'warning' && issue.stage === 'config') {\n        // Override for the externalize issue\n        // `Package foo (serverExternalPackages or default list) can't be external`\n        if (renderStyledStringToErrorAnsi(issue.title).includes(\"can't be external\")) {\n            return false;\n        }\n    }\n    return issue.severity === 'warning' && (issue.filePath.match(/^(?:.*[\\\\/])?node_modules(?:[\\\\/].*)?$/) !== null || // Ignore Next.js itself when running next directly in the monorepo where it is not inside\n    // node_modules anyway.\n    // TODO(mischnic) prevent matches when this is published to npm\n    issue.filePath.startsWith('[project]/packages/next/'));\n}\nfunction renderStyledStringToErrorAnsi(string) {\n    function decodeMagicIdentifiers(str) {\n        return str.replaceAll(_magicidentifier.MAGIC_IDENTIFIER_REGEX, (ident)=>{\n            try {\n                return (0, _picocolors.magenta)(\"{\" + (0, _magicidentifier.decodeMagicIdentifier)(ident) + \"}\");\n            } catch (e) {\n                return (0, _picocolors.magenta)(\"{\" + ident + \" (decoding failed: \" + e + \")}\");\n            }\n        });\n    }\n    switch(string.type){\n        case 'text':\n            return decodeMagicIdentifiers(string.value);\n        case 'strong':\n            return (0, _picocolors.bold)((0, _picocolors.red)(decodeMagicIdentifiers(string.value)));\n        case 'code':\n            return (0, _picocolors.green)(decodeMagicIdentifiers(string.value));\n        case 'line':\n            return string.value.map(renderStyledStringToErrorAnsi).join('');\n        case 'stack':\n            return string.value.map(renderStyledStringToErrorAnsi).join('\\n');\n        default:\n            throw Object.defineProperty(new Error('Unknown StyledString type', string), \"__NEXT_ERROR_CODE\", {\n                value: \"E138\",\n                enumerable: false,\n                configurable: true\n            });\n    }\n}\nfunction isPersistentCachingEnabled(config) {\n    var _config_experimental;\n    return ((_config_experimental = config.experimental) == null ? void 0 : _config_experimental.turbopackPersistentCaching) || false;\n}\n\n//# sourceMappingURL=utils.js.map"
        }
    ]
}