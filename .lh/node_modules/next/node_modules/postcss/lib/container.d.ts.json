{
    "sourceFile": "node_modules/next/node_modules/postcss/lib/container.d.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892914633,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import AtRule from './at-rule.js'\nimport Comment from './comment.js'\nimport Declaration from './declaration.js'\nimport Node, { ChildNode, ChildProps, NodeProps } from './node.js'\nimport Rule from './rule.js'\n\ndeclare namespace Container {\n  export interface ValueOptions {\n    /**\n     * String that’s used to narrow down values and speed up the regexp search.\n     */\n    fast?: string\n\n    /**\n     * An array of property names.\n     */\n    props?: string[]\n  }\n\n  export interface ContainerProps extends NodeProps {\n    nodes?: (ChildNode | ChildProps)[]\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-use-before-define\n  export { Container_ as default }\n}\n\n/**\n * The `Root`, `AtRule`, and `Rule` container nodes\n * inherit some common methods to help work with their children.\n *\n * Note that all containers can store any content. If you write a rule inside\n * a rule, PostCSS will parse it.\n */\ndeclare abstract class Container_<Child extends Node = ChildNode> extends Node {\n  /**\n   * An array containing the container’s children.\n   *\n   * ```js\n   * const root = postcss.parse('a { color: black }')\n   * root.nodes.length           //=> 1\n   * root.nodes[0].selector      //=> 'a'\n   * root.nodes[0].nodes[0].prop //=> 'color'\n   * ```\n   */\n  nodes: Child[]\n\n  /**\n   * Inserts new nodes to the end of the container.\n   *\n   * ```js\n   * const decl1 = new Declaration({ prop: 'color', value: 'black' })\n   * const decl2 = new Declaration({ prop: 'background-color', value: 'white' })\n   * rule.append(decl1, decl2)\n   *\n   * root.append({ name: 'charset', params: '\"UTF-8\"' })  // at-rule\n   * root.append({ selector: 'a' })                       // rule\n   * rule.append({ prop: 'color', value: 'black' })       // declaration\n   * rule.append({ text: 'Comment' })                     // comment\n   *\n   * root.append('a {}')\n   * root.first.append('color: black; z-index: 1')\n   * ```\n   *\n   * @param nodes New nodes.\n   * @return This node for methods chain.\n   */\n  append(\n    ...nodes: (ChildProps | ChildProps[] | Node | Node[] | string | string[])[]\n  ): this\n\n  assign(overrides: Container.ContainerProps | object): this\n  clone(overrides?: Partial<Container.ContainerProps>): Container<Child>\n  cloneAfter(overrides?: Partial<Container.ContainerProps>): Container<Child>\n  cloneBefore(overrides?: Partial<Container.ContainerProps>): Container<Child>\n\n  /**\n   * Iterates through the container’s immediate children,\n   * calling `callback` for each child.\n   *\n   * Returning `false` in the callback will break iteration.\n   *\n   * This method only iterates through the container’s immediate children.\n   * If you need to recursively iterate through all the container’s descendant\n   * nodes, use `Container#walk`.\n   *\n   * Unlike the for `{}`-cycle or `Array#forEach` this iterator is safe\n   * if you are mutating the array of child nodes during iteration.\n   * PostCSS will adjust the current index to match the mutations.\n   *\n   * ```js\n   * const root = postcss.parse('a { color: black; z-index: 1 }')\n   * const rule = root.first\n   *\n   * for (const decl of rule.nodes) {\n   *   decl.cloneBefore({ prop: '-webkit-' + decl.prop })\n   *   // Cycle will be infinite, because cloneBefore moves the current node\n   *   // to the next index\n   * }\n   *\n   * rule.each(decl => {\n   *   decl.cloneBefore({ prop: '-webkit-' + decl.prop })\n   *   // Will be executed only for color and z-index\n   * })\n   * ```\n   *\n   * @param callback Iterator receives each node and index.\n   * @return Returns `false` if iteration was broke.\n   */\n  each(\n    callback: (node: Child, index: number) => false | void\n  ): false | undefined\n\n  /**\n   * Returns `true` if callback returns `true`\n   * for all of the container’s children.\n   *\n   * ```js\n   * const noPrefixes = rule.every(i => i.prop[0] !== '-')\n   * ```\n   *\n   * @param condition Iterator returns true or false.\n   * @return Is every child pass condition.\n   */\n  every(\n    condition: (node: Child, index: number, nodes: Child[]) => boolean\n  ): boolean\n  /**\n   * Returns a `child`’s index within the `Container#nodes` array.\n   *\n   * ```js\n   * rule.index( rule.nodes[2] ) //=> 2\n   * ```\n   *\n   * @param child Child of the current container.\n   * @return Child index.\n   */\n  index(child: Child | number): number\n\n  /**\n   * Insert new node after old node within the container.\n   *\n   * @param oldNode Child or child’s index.\n   * @param newNode New node.\n   * @return This node for methods chain.\n   */\n  insertAfter(\n    oldNode: Child | number,\n    newNode: Child | Child[] | ChildProps | ChildProps[] | string | string[]\n  ): this\n  /**\n   * Insert new node before old node within the container.\n   *\n   * ```js\n   * rule.insertBefore(decl, decl.clone({ prop: '-webkit-' + decl.prop }))\n   * ```\n   *\n   * @param oldNode Child or child’s index.\n   * @param newNode New node.\n   * @return This node for methods chain.\n   */\n  insertBefore(\n    oldNode: Child | number,\n    newNode: Child | Child[] | ChildProps | ChildProps[] | string | string[]\n  ): this\n\n  /**\n   * Traverses the container’s descendant nodes, calling callback\n   * for each comment node.\n   *\n   * Like `Container#each`, this method is safe\n   * to use if you are mutating arrays during iteration.\n   *\n   * ```js\n   * root.walkComments(comment => {\n   *   comment.remove()\n   * })\n   * ```\n   *\n   * @param callback Iterator receives each node and index.\n   * @return Returns `false` if iteration was broke.\n   */\n\n  /**\n   * Inserts new nodes to the start of the container.\n   *\n   * ```js\n   * const decl1 = new Declaration({ prop: 'color', value: 'black' })\n   * const decl2 = new Declaration({ prop: 'background-color', value: 'white' })\n   * rule.prepend(decl1, decl2)\n   *\n   * root.append({ name: 'charset', params: '\"UTF-8\"' })  // at-rule\n   * root.append({ selector: 'a' })                       // rule\n   * rule.append({ prop: 'color', value: 'black' })       // declaration\n   * rule.append({ text: 'Comment' })                     // comment\n   *\n   * root.append('a {}')\n   * root.first.append('color: black; z-index: 1')\n   * ```\n   *\n   * @param nodes New nodes.\n   * @return This node for methods chain.\n   */\n  prepend(\n    ...nodes: (ChildProps | ChildProps[] | Node | Node[] | string | string[])[]\n  ): this\n  /**\n   * Add child to the end of the node.\n   *\n   * ```js\n   * rule.push(new Declaration({ prop: 'color', value: 'black' }))\n   * ```\n   *\n   * @param child New node.\n   * @return This node for methods chain.\n   */\n  push(child: Child): this\n\n  /**\n   * Removes all children from the container\n   * and cleans their parent properties.\n   *\n   * ```js\n   * rule.removeAll()\n   * rule.nodes.length //=> 0\n   * ```\n   *\n   * @return This node for methods chain.\n   */\n  removeAll(): this\n\n  /**\n   * Removes node from the container and cleans the parent properties\n   * from the node and its children.\n   *\n   * ```js\n   * rule.nodes.length  //=> 5\n   * rule.removeChild(decl)\n   * rule.nodes.length  //=> 4\n   * decl.parent        //=> undefined\n   * ```\n   *\n   * @param child Child or child’s index.\n   * @return This node for methods chain.\n   */\n  removeChild(child: Child | number): this\n\n  replaceValues(\n    pattern: RegExp | string,\n    replaced: { (substring: string, ...args: any[]): string } | string\n  ): this\n\n  /**\n   * Passes all declaration values within the container that match pattern\n   * through callback, replacing those values with the returned result\n   * of callback.\n   *\n   * This method is useful if you are using a custom unit or function\n   * and need to iterate through all values.\n   *\n   * ```js\n   * root.replaceValues(/\\d+rem/, { fast: 'rem' }, string => {\n   *   return 15 * parseInt(string) + 'px'\n   * })\n   * ```\n   *\n   * @param pattern      Replace pattern.\n   * @param {object} opts                Options to speed up the search.\n   * @param callback   String to replace pattern or callback\n   *                                     that returns a new value. The callback\n   *                                     will receive the same arguments\n   *                                     as those passed to a function parameter\n   *                                     of `String#replace`.\n   * @return This node for methods chain.\n   */\n  replaceValues(\n    pattern: RegExp | string,\n    options: Container.ValueOptions,\n    replaced: { (substring: string, ...args: any[]): string } | string\n  ): this\n\n  /**\n   * Returns `true` if callback returns `true` for (at least) one\n   * of the container’s children.\n   *\n   * ```js\n   * const hasPrefix = rule.some(i => i.prop[0] === '-')\n   * ```\n   *\n   * @param condition Iterator returns true or false.\n   * @return Is some child pass condition.\n   */\n  some(\n    condition: (node: Child, index: number, nodes: Child[]) => boolean\n  ): boolean\n\n  /**\n   * Traverses the container’s descendant nodes, calling callback\n   * for each node.\n   *\n   * Like container.each(), this method is safe to use\n   * if you are mutating arrays during iteration.\n   *\n   * If you only need to iterate through the container’s immediate children,\n   * use `Container#each`.\n   *\n   * ```js\n   * root.walk(node => {\n   *   // Traverses all descendant nodes.\n   * })\n   * ```\n   *\n   * @param callback Iterator receives each node and index.\n   * @return  Returns `false` if iteration was broke.\n   */\n  walk(\n    callback: (node: ChildNode, index: number) => false | void\n  ): false | undefined\n\n  /**\n   * Traverses the container’s descendant nodes, calling callback\n   * for each at-rule node.\n   *\n   * If you pass a filter, iteration will only happen over at-rules\n   * that have matching names.\n   *\n   * Like `Container#each`, this method is safe\n   * to use if you are mutating arrays during iteration.\n   *\n   * ```js\n   * root.walkAtRules(rule => {\n   *   if (isOld(rule.name)) rule.remove()\n   * })\n   *\n   * let first = false\n   * root.walkAtRules('charset', rule => {\n   *   if (!first) {\n   *     first = true\n   *   } else {\n   *     rule.remove()\n   *   }\n   * })\n   * ```\n   *\n   * @param name     String or regular expression to filter at-rules by name.\n   * @param callback Iterator receives each node and index.\n   * @return Returns `false` if iteration was broke.\n   */\n  walkAtRules(\n    nameFilter: RegExp | string,\n    callback: (atRule: AtRule, index: number) => false | void\n  ): false | undefined\n\n  walkAtRules(\n    callback: (atRule: AtRule, index: number) => false | void\n  ): false | undefined\n  walkComments(\n    callback: (comment: Comment, indexed: number) => false | void\n  ): false | undefined\n\n  walkComments(\n    callback: (comment: Comment, indexed: number) => false | void\n  ): false | undefined\n\n  /**\n   * Traverses the container’s descendant nodes, calling callback\n   * for each declaration node.\n   *\n   * If you pass a filter, iteration will only happen over declarations\n   * with matching properties.\n   *\n   * ```js\n   * root.walkDecls(decl => {\n   *   checkPropertySupport(decl.prop)\n   * })\n   *\n   * root.walkDecls('border-radius', decl => {\n   *   decl.remove()\n   * })\n   *\n   * root.walkDecls(/^background/, decl => {\n   *   decl.value = takeFirstColorFromGradient(decl.value)\n   * })\n   * ```\n   *\n   * Like `Container#each`, this method is safe\n   * to use if you are mutating arrays during iteration.\n   *\n   * @param prop     String or regular expression to filter declarations\n   *                 by property name.\n   * @param callback Iterator receives each node and index.\n   * @return Returns `false` if iteration was broke.\n   */\n  walkDecls(\n    propFilter: RegExp | string,\n    callback: (decl: Declaration, index: number) => false | void\n  ): false | undefined\n\n  walkDecls(\n    callback: (decl: Declaration, index: number) => false | void\n  ): false | undefined\n\n  /**\n   * Traverses the container’s descendant nodes, calling callback\n   * for each rule node.\n   *\n   * If you pass a filter, iteration will only happen over rules\n   * with matching selectors.\n   *\n   * Like `Container#each`, this method is safe\n   * to use if you are mutating arrays during iteration.\n   *\n   * ```js\n   * const selectors = []\n   * root.walkRules(rule => {\n   *   selectors.push(rule.selector)\n   * })\n   * console.log(`Your CSS uses ${ selectors.length } selectors`)\n   * ```\n   *\n   * @param selector String or regular expression to filter rules by selector.\n   * @param callback Iterator receives each node and index.\n   * @return Returns `false` if iteration was broke.\n   */\n  walkRules(\n    selectorFilter: RegExp | string,\n    callback: (rule: Rule, index: number) => false | void\n  ): false | undefined\n  walkRules(\n    callback: (rule: Rule, index: number) => false | void\n  ): false | undefined\n  /**\n   * The container’s first child.\n   *\n   * ```js\n   * rule.first === rules.nodes[0]\n   * ```\n   */\n  get first(): Child | undefined\n  /**\n   * The container’s last child.\n   *\n   * ```js\n   * rule.last === rule.nodes[rule.nodes.length - 1]\n   * ```\n   */\n  get last(): Child | undefined\n}\n\ndeclare class Container<Child extends Node = ChildNode> extends Container_<Child> {}\n\nexport = Container\n"
        }
    ]
}