{
    "sourceFile": "node_modules/next/node_modules/postcss/lib/processor.d.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892916004,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import Document from './document.js'\nimport LazyResult from './lazy-result.js'\nimport NoWorkResult from './no-work-result.js'\nimport {\n  AcceptedPlugin,\n  Plugin,\n  ProcessOptions,\n  TransformCallback,\n  Transformer\n} from './postcss.js'\nimport Result from './result.js'\nimport Root from './root.js'\n\ndeclare namespace Processor {\n  // eslint-disable-next-line @typescript-eslint/no-use-before-define\n  export { Processor_ as default }\n}\n\n/**\n * Contains plugins to process CSS. Create one `Processor` instance,\n * initialize its plugins, and then use that instance on numerous CSS files.\n *\n * ```js\n * const processor = postcss([autoprefixer, postcssNested])\n * processor.process(css1).then(result => console.log(result.css))\n * processor.process(css2).then(result => console.log(result.css))\n * ```\n */\ndeclare class Processor_ {\n  /**\n   * Plugins added to this processor.\n   *\n   * ```js\n   * const processor = postcss([autoprefixer, postcssNested])\n   * processor.plugins.length //=> 2\n   * ```\n   */\n  plugins: (Plugin | TransformCallback | Transformer)[]\n\n  /**\n   * Current PostCSS version.\n   *\n   * ```js\n   * if (result.processor.version.split('.')[0] !== '6') {\n   *   throw new Error('This plugin works only with PostCSS 6')\n   * }\n   * ```\n   */\n  version: string\n\n  /**\n   * @param plugins PostCSS plugins\n   */\n  constructor(plugins?: AcceptedPlugin[])\n\n  /**\n   * Parses source CSS and returns a `LazyResult` Promise proxy.\n   * Because some plugins can be asynchronous it doesnâ€™t make\n   * any transformations. Transformations will be applied\n   * in the `LazyResult` methods.\n   *\n   * ```js\n   * processor.process(css, { from: 'a.css', to: 'a.out.css' })\n   *   .then(result => {\n   *      console.log(result.css)\n   *   })\n   * ```\n   *\n   * @param css String with input CSS or any object with a `toString()` method,\n   *            like a Buffer. Optionally, send a `Result` instance\n   *            and the processor will take the `Root` from it.\n   * @param opts Options.\n   * @return Promise proxy.\n   */\n  process(\n    css: { toString(): string } | LazyResult | Result | Root | string\n  ): LazyResult | NoWorkResult\n  process<RootNode extends Document | Root = Root>(\n    css: { toString(): string } | LazyResult | Result | Root | string,\n    options: ProcessOptions<RootNode>\n  ): LazyResult<RootNode>\n\n  /**\n   * Adds a plugin to be used as a CSS processor.\n   *\n   * PostCSS plugin can be in 4 formats:\n   * * A plugin in `Plugin` format.\n   * * A plugin creator function with `pluginCreator.postcss = true`.\n   *   PostCSS will call this function without argument to get plugin.\n   * * A function. PostCSS will pass the function a {@link Root}\n   *   as the first argument and current `Result` instance\n   *   as the second.\n   * * Another `Processor` instance. PostCSS will copy plugins\n   *   from that instance into this one.\n   *\n   * Plugins can also be added by passing them as arguments when creating\n   * a `postcss` instance (see [`postcss(plugins)`]).\n   *\n   * Asynchronous plugins should return a `Promise` instance.\n   *\n   * ```js\n   * const processor = postcss()\n   *   .use(autoprefixer)\n   *   .use(postcssNested)\n   * ```\n   *\n   * @param plugin PostCSS plugin or `Processor` with plugins.\n   * @return Current processor to make methods chain.\n   */\n  use(plugin: AcceptedPlugin): this\n}\n\ndeclare class Processor extends Processor_ {}\n\nexport = Processor\n"
        }
    ]
}