{
    "sourceFile": "node_modules/next/node_modules/postcss/lib/postcss.d.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892915837,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import { RawSourceMap, SourceMapGenerator } from 'source-map-js'\n\nimport AtRule, { AtRuleProps } from './at-rule.js'\nimport Comment, { CommentProps } from './comment.js'\nimport Container, { ContainerProps } from './container.js'\nimport CssSyntaxError from './css-syntax-error.js'\nimport Declaration, { DeclarationProps } from './declaration.js'\nimport Document, { DocumentProps } from './document.js'\nimport Input, { FilePosition } from './input.js'\nimport LazyResult from './lazy-result.js'\nimport list from './list.js'\nimport Node, {\n  AnyNode,\n  ChildNode,\n  ChildProps,\n  NodeErrorOptions,\n  NodeProps,\n  Position,\n  Source\n} from './node.js'\nimport Processor from './processor.js'\nimport Result, { Message } from './result.js'\nimport Root, { RootProps } from './root.js'\nimport Rule, { RuleProps } from './rule.js'\nimport Warning, { WarningOptions } from './warning.js'\n\ntype DocumentProcessor = (\n  document: Document,\n  helper: postcss.Helpers\n) => Promise<void> | void\ntype RootProcessor = (root: Root, helper: postcss.Helpers) => Promise<void> | void\ntype DeclarationProcessor = (\n  decl: Declaration,\n  helper: postcss.Helpers\n) => Promise<void> | void\ntype RuleProcessor = (rule: Rule, helper: postcss.Helpers) => Promise<void> | void\ntype AtRuleProcessor = (atRule: AtRule, helper: postcss.Helpers) => Promise<void> | void\ntype CommentProcessor = (\n  comment: Comment,\n  helper: postcss.Helpers\n) => Promise<void> | void\n\ninterface Processors {\n  /**\n   * Will be called on all`AtRule` nodes.\n   *\n   * Will be called again on node or children changes.\n   */\n  AtRule?: { [name: string]: AtRuleProcessor } | AtRuleProcessor\n\n  /**\n   * Will be called on all `AtRule` nodes, when all children will be processed.\n   *\n   * Will be called again on node or children changes.\n   */\n  AtRuleExit?: { [name: string]: AtRuleProcessor } | AtRuleProcessor\n\n  /**\n   * Will be called on all `Comment` nodes.\n   *\n   * Will be called again on node or children changes.\n   */\n  Comment?: CommentProcessor\n\n  /**\n   * Will be called on all `Comment` nodes after listeners\n   * for `Comment` event.\n   *\n   * Will be called again on node or children changes.\n   */\n  CommentExit?: CommentProcessor\n\n  /**\n   * Will be called on all `Declaration` nodes after listeners\n   * for `Declaration` event.\n   *\n   * Will be called again on node or children changes.\n   */\n  Declaration?: { [prop: string]: DeclarationProcessor } | DeclarationProcessor\n\n  /**\n   * Will be called on all `Declaration` nodes.\n   *\n   * Will be called again on node or children changes.\n   */\n  DeclarationExit?:\n    | { [prop: string]: DeclarationProcessor }\n    | DeclarationProcessor\n\n  /**\n   * Will be called on `Document` node.\n   *\n   * Will be called again on children changes.\n   */\n  Document?: DocumentProcessor\n\n  /**\n   * Will be called on `Document` node, when all children will be processed.\n   *\n   * Will be called again on children changes.\n   */\n  DocumentExit?: DocumentProcessor\n\n  /**\n   * Will be called on `Root` node once.\n   */\n  Once?: RootProcessor\n\n  /**\n   * Will be called on `Root` node once, when all children will be processed.\n   */\n  OnceExit?: RootProcessor\n\n  /**\n   * Will be called on `Root` node.\n   *\n   * Will be called again on children changes.\n   */\n  Root?: RootProcessor\n\n  /**\n   * Will be called on `Root` node, when all children will be processed.\n   *\n   * Will be called again on children changes.\n   */\n  RootExit?: RootProcessor\n\n  /**\n   * Will be called on all `Rule` nodes.\n   *\n   * Will be called again on node or children changes.\n   */\n  Rule?: RuleProcessor\n\n  /**\n   * Will be called on all `Rule` nodes, when all children will be processed.\n   *\n   * Will be called again on node or children changes.\n   */\n  RuleExit?: RuleProcessor\n}\n\ndeclare namespace postcss {\n  export {\n    AnyNode,\n    AtRule,\n    AtRuleProps,\n    ChildNode,\n    ChildProps,\n    Comment,\n    CommentProps,\n    Container,\n    ContainerProps,\n    CssSyntaxError,\n    Declaration,\n    DeclarationProps,\n    Document,\n    DocumentProps,\n    FilePosition,\n    Input,\n    LazyResult,\n    list,\n    Message,\n    Node,\n    NodeErrorOptions,\n    NodeProps,\n    Position,\n    Processor,\n    Result,\n    Root,\n    RootProps,\n    Rule,\n    RuleProps,\n    Source,\n    Warning,\n    WarningOptions\n  }\n\n  export type SourceMap = SourceMapGenerator & {\n    toJSON(): RawSourceMap\n  }\n\n  export type Helpers = { postcss: Postcss; result: Result } & Postcss\n\n  export interface Plugin extends Processors {\n    postcssPlugin: string\n    prepare?: (result: Result) => Processors\n  }\n\n  export interface PluginCreator<PluginOptions> {\n    (opts?: PluginOptions): Plugin | Processor\n    postcss: true\n  }\n\n  export interface Transformer extends TransformCallback {\n    postcssPlugin: string\n    postcssVersion: string\n  }\n\n  export interface TransformCallback {\n    (root: Root, result: Result): Promise<void> | void\n  }\n\n  export interface OldPlugin<T> extends Transformer {\n    (opts?: T): Transformer\n    postcss: Transformer\n  }\n\n  export type AcceptedPlugin =\n    | {\n        postcss: Processor | TransformCallback\n      }\n    | OldPlugin<any>\n    | Plugin\n    | PluginCreator<any>\n    | Processor\n    | TransformCallback\n\n  export interface Parser<RootNode = Document | Root> {\n    (\n      css: { toString(): string } | string,\n      opts?: Pick<ProcessOptions, 'from' | 'map'>\n    ): RootNode\n  }\n\n  export interface Builder {\n    (part: string, node?: AnyNode, type?: 'end' | 'start'): void\n  }\n\n  export interface Stringifier {\n    (node: AnyNode, builder: Builder): void\n  }\n\n  export interface JSONHydrator {\n    (data: object): Node\n    (data: object[]): Node[]\n  }\n\n  export interface Syntax<RootNode = Document | Root> {\n    /**\n     * Function to generate AST by string.\n     */\n    parse?: Parser<RootNode>\n\n    /**\n     * Class to generate string by AST.\n     */\n    stringify?: Stringifier\n  }\n\n  export interface SourceMapOptions {\n    /**\n     * Use absolute path in generated source map.\n     */\n    absolute?: boolean\n\n    /**\n     * Indicates that PostCSS should add annotation comments to the CSS.\n     * By default, PostCSS will always add a comment with a path\n     * to the source map. PostCSS will not add annotations to CSS files\n     * that do not contain any comments.\n     *\n     * By default, PostCSS presumes that you want to save the source map as\n     * `opts.to + '.map'` and will use this path in the annotation comment.\n     * A different path can be set by providing a string value for annotation.\n     *\n     * If you have set `inline: true`, annotation cannot be disabled.\n     */\n    annotation?: ((file: string, root: Root) => string) | boolean | string\n\n    /**\n     * Override `from` in mapâ€™s sources.\n     */\n    from?: string\n\n    /**\n     * Indicates that the source map should be embedded in the output CSS\n     * as a Base64-encoded comment. By default, it is `true`.\n     * But if all previous maps are external, not inline, PostCSS will not embed\n     * the map even if you do not set this option.\n     *\n     * If you have an inline source map, the result.map property will be empty,\n     * as the source map will be contained within the text of `result.css`.\n     */\n    inline?: boolean\n\n    /**\n     * Source map content from a previous processing step (e.g., Sass).\n     *\n     * PostCSS will try to read the previous source map\n     * automatically (based on comments within the source CSS), but you can use\n     * this option to identify it manually.\n     *\n     * If desired, you can omit the previous map with prev: `false`.\n     */\n    prev?: ((file: string) => string) | boolean | object | string\n\n    /**\n     * Indicates that PostCSS should set the origin content (e.g., Sass source)\n     * of the source map. By default, it is true. But if all previous maps do not\n     * contain sources content, PostCSS will also leave it out even if you\n     * do not set this option.\n     */\n    sourcesContent?: boolean\n  }\n\n  export interface ProcessOptions<RootNode = Document | Root> {\n    /**\n     * The path of the CSS source file. You should always set `from`,\n     * because it is used in source map generation and syntax error messages.\n     */\n    from?: string\n\n    /**\n     * Source map options\n     */\n    map?: boolean | SourceMapOptions\n\n    /**\n     * Function to generate AST by string.\n     */\n    parser?: Parser<RootNode> | Syntax<RootNode>\n\n    /**\n     * Class to generate string by AST.\n     */\n    stringifier?: Stringifier | Syntax<RootNode>\n\n    /**\n     * Object with parse and stringify.\n     */\n    syntax?: Syntax<RootNode>\n\n    /**\n     * The path where you'll put the output CSS file. You should always set `to`\n     * to generate correct source maps.\n     */\n    to?: string\n  }\n\n  export type Postcss = typeof postcss\n\n  /**\n   * Default function to convert a node tree into a CSS string.\n   */\n  export let stringify: Stringifier\n\n  /**\n   * Parses source css and returns a new `Root` or `Document` node,\n   * which contains the source CSS nodes.\n   *\n   * ```js\n   * // Simple CSS concatenation with source map support\n   * const root1 = postcss.parse(css1, { from: file1 })\n   * const root2 = postcss.parse(css2, { from: file2 })\n   * root1.append(root2).toResult().css\n   * ```\n   */\n  export let parse: Parser<Root>\n\n  /**\n   * Rehydrate a JSON AST (from `Node#toJSON`) back into the AST classes.\n   *\n   * ```js\n   * const json = root.toJSON()\n   * // save to file, send by network, etc\n   * const root2  = postcss.fromJSON(json)\n   * ```\n   */\n  export let fromJSON: JSONHydrator\n\n  /**\n   * Creates a new `Comment` node.\n   *\n   * @param defaults Properties for the new node.\n   * @return New comment node\n   */\n  export function comment(defaults?: CommentProps): Comment\n\n  /**\n   * Creates a new `AtRule` node.\n   *\n   * @param defaults Properties for the new node.\n   * @return New at-rule node.\n   */\n  export function atRule(defaults?: AtRuleProps): AtRule\n\n  /**\n   * Creates a new `Declaration` node.\n   *\n   * @param defaults Properties for the new node.\n   * @return New declaration node.\n   */\n  export function decl(defaults?: DeclarationProps): Declaration\n\n  /**\n   * Creates a new `Rule` node.\n   *\n   * @param default Properties for the new node.\n   * @return New rule node.\n   */\n  export function rule(defaults?: RuleProps): Rule\n\n  /**\n   * Creates a new `Root` node.\n   *\n   * @param defaults Properties for the new node.\n   * @return New root node.\n   */\n  export function root(defaults?: RootProps): Root\n\n  /**\n   * Creates a new `Document` node.\n   *\n   * @param defaults Properties for the new node.\n   * @return New document node.\n   */\n  export function document(defaults?: DocumentProps): Document\n\n  export { postcss as default }\n}\n\n/**\n * Create a new `Processor` instance that will apply `plugins`\n * as CSS processors.\n *\n * ```js\n * let postcss = require('postcss')\n *\n * postcss(plugins).process(css, { from, to }).then(result => {\n *   console.log(result.css)\n * })\n * ```\n *\n * @param plugins PostCSS plugins.\n * @return Processor to process multiple CSS.\n */\ndeclare function postcss(plugins?: postcss.AcceptedPlugin[]): Processor\ndeclare function postcss(...plugins: postcss.AcceptedPlugin[]): Processor\n\nexport = postcss\n"
        }
    ]
}