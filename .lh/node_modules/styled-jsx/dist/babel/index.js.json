{
    "sourceFile": "node_modules/styled-jsx/dist/babel/index.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746893042358,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "var require$$1 = require('path');\nvar require$$0 = require('fs');\nvar require$$0$1 = require('buffer');\n\nfunction _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }\n\nvar require$$1__default = /*#__PURE__*/_interopDefaultLegacy(require$$1);\nvar require$$0__default = /*#__PURE__*/_interopDefaultLegacy(require$$0);\nvar require$$0__default$1 = /*#__PURE__*/_interopDefaultLegacy(require$$0$1);\n\nvar lib$3 = {};\n\nvar lib$2 = {};\n\nfunction _createForOfIteratorHelperLoose$k(o, allowArrayLike) {\n    var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n    if (it) return (it = it.call(o)).next.bind(it);\n    if (Array.isArray(o) || (it = unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n        if (it) o = it;\n        var i = 0;\n        return function() {\n            if (i >= o.length) return {\n                done: true\n            };\n            return {\n                done: false,\n                value: o[i++]\n            };\n        };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nObject.defineProperty(lib$2, \"__esModule\", {\n    value: true\n});\nlib$2.declare = declare;\nlib$2.declarePreset = void 0;\nfunction declare(builder) {\n    return function(api, options, dirname) {\n        var _clonedApi2;\n        var clonedApi;\n        for(var _iterator = _createForOfIteratorHelperLoose$k(Object.keys(apiPolyfills)), _step; !(_step = _iterator()).done;){\n            var name = _step.value;\n            var _clonedApi;\n            if (api[name]) continue;\n            clonedApi = (_clonedApi = clonedApi) != null ? _clonedApi : copyApiObject(api);\n            clonedApi[name] = apiPolyfills[name](clonedApi);\n        }\n        return builder((_clonedApi2 = clonedApi) != null ? _clonedApi2 : api, options || {}, dirname);\n    };\n}\nvar declarePreset = declare;\nlib$2.declarePreset = declarePreset;\nvar apiPolyfills = {\n    assertVersion: function(api) {\n        return function(range) {\n            throwVersionError(range, api.version);\n        };\n    },\n    targets: function() {\n        return function() {\n            return {};\n        };\n    },\n    assumption: function() {\n        return function() {\n            return undefined;\n        };\n    }\n};\nfunction copyApiObject(api) {\n    var proto = null;\n    if (typeof api.version === \"string\" && /^7\\./.test(api.version)) {\n        proto = Object.getPrototypeOf(api);\n        if (proto && (!has$1(proto, \"version\") || !has$1(proto, \"transform\") || !has$1(proto, \"template\") || !has$1(proto, \"types\"))) {\n            proto = null;\n        }\n    }\n    return Object.assign({}, proto, api);\n}\nfunction has$1(obj, key) {\n    return Object.prototype.hasOwnProperty.call(obj, key);\n}\nfunction throwVersionError(range, version) {\n    if (typeof range === \"number\") {\n        if (!Number.isInteger(range)) {\n            throw new Error(\"Expected string or integer value.\");\n        }\n        range = \"^\" + range + \".0.0-0\";\n    }\n    if (typeof range !== \"string\") {\n        throw new Error(\"Expected string or integer value.\");\n    }\n    var limit = Error.stackTraceLimit;\n    if (typeof limit === \"number\" && limit < 25) {\n        Error.stackTraceLimit = 25;\n    }\n    var err;\n    if (version.slice(0, 2) === \"7.\") {\n        err = new Error('Requires Babel \"^7.0.0-beta.41\", but was loaded with \"' + version + '\". ' + \"You'll need to update your @babel/core version.\");\n    } else {\n        err = new Error('Requires Babel \"' + range + '\", but was loaded with \"' + version + '\". ' + \"If you are sure you have a compatible version of @babel/core, \" + \"it is likely that something in your build process is loading the \" + \"wrong version. Inspect the stack trace of this error to look for \" + 'the first entry that doesn\\'t mention \"@babel/core\" or \"babel-core\" ' + \"to see what is calling Babel.\");\n    }\n    if (typeof limit === \"number\") {\n        Error.stackTraceLimit = limit;\n    }\n    throw Object.assign(err, {\n        code: \"BABEL_VERSION_UNSUPPORTED\",\n        version: version,\n        range: range\n    });\n}\n\nObject.defineProperty(lib$3, \"__esModule\", {\n    value: true\n});\nvar default_1 = lib$3.default = void 0;\nvar _helperPluginUtils = lib$2;\nvar _default$5 = (0, _helperPluginUtils.declare)(function(api) {\n    api.assertVersion(7);\n    return {\n        name: \"syntax-jsx\",\n        manipulateOptions: function manipulateOptions(opts, parserOpts) {\n            if (parserOpts.plugins.some(function(p) {\n                return (Array.isArray(p) ? p[0] : p) === \"typescript\";\n            })) {\n                return;\n            }\n            parserOpts.plugins.push(\"jsx\");\n        }\n    };\n});\ndefault_1 = lib$3.default = _default$5;\n\nvar lib$1 = {};\n\nvar isReactComponent$1 = {};\n\nvar buildMatchMemberExpression$1 = {};\n\nvar matchesPattern$1 = {};\n\nvar generated$4 = {};\n\nvar shallowEqual$1 = {};\n\nfunction _createForOfIteratorHelperLoose$j(o, allowArrayLike) {\n    var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n    if (it) return (it = it.call(o)).next.bind(it);\n    if (Array.isArray(o) || (it = unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n        if (it) o = it;\n        var i = 0;\n        return function() {\n            if (i >= o.length) return {\n                done: true\n            };\n            return {\n                done: false,\n                value: o[i++]\n            };\n        };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nObject.defineProperty(shallowEqual$1, \"__esModule\", {\n    value: true\n});\nshallowEqual$1.default = shallowEqual;\nfunction shallowEqual(actual, expected) {\n    var keys = Object.keys(expected);\n    for(var _iterator = _createForOfIteratorHelperLoose$j(keys), _step; !(_step = _iterator()).done;){\n        var key = _step.value;\n        if (actual[key] !== expected[key]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nObject.defineProperty(generated$4, \"__esModule\", {\n    value: true\n});\ngenerated$4.isArrayExpression = isArrayExpression;\ngenerated$4.isAssignmentExpression = isAssignmentExpression;\ngenerated$4.isBinaryExpression = isBinaryExpression;\ngenerated$4.isInterpreterDirective = isInterpreterDirective;\ngenerated$4.isDirective = isDirective;\ngenerated$4.isDirectiveLiteral = isDirectiveLiteral;\ngenerated$4.isBlockStatement = isBlockStatement;\ngenerated$4.isBreakStatement = isBreakStatement;\ngenerated$4.isCallExpression = isCallExpression;\ngenerated$4.isCatchClause = isCatchClause;\ngenerated$4.isConditionalExpression = isConditionalExpression;\ngenerated$4.isContinueStatement = isContinueStatement;\ngenerated$4.isDebuggerStatement = isDebuggerStatement;\ngenerated$4.isDoWhileStatement = isDoWhileStatement;\ngenerated$4.isEmptyStatement = isEmptyStatement;\ngenerated$4.isExpressionStatement = isExpressionStatement;\ngenerated$4.isFile = isFile;\ngenerated$4.isForInStatement = isForInStatement;\ngenerated$4.isForStatement = isForStatement;\ngenerated$4.isFunctionDeclaration = isFunctionDeclaration;\ngenerated$4.isFunctionExpression = isFunctionExpression;\ngenerated$4.isIdentifier = isIdentifier;\ngenerated$4.isIfStatement = isIfStatement;\ngenerated$4.isLabeledStatement = isLabeledStatement;\ngenerated$4.isStringLiteral = isStringLiteral;\ngenerated$4.isNumericLiteral = isNumericLiteral;\ngenerated$4.isNullLiteral = isNullLiteral;\ngenerated$4.isBooleanLiteral = isBooleanLiteral;\ngenerated$4.isRegExpLiteral = isRegExpLiteral;\ngenerated$4.isLogicalExpression = isLogicalExpression;\ngenerated$4.isMemberExpression = isMemberExpression;\ngenerated$4.isNewExpression = isNewExpression;\ngenerated$4.isProgram = isProgram;\ngenerated$4.isObjectExpression = isObjectExpression;\ngenerated$4.isObjectMethod = isObjectMethod;\ngenerated$4.isObjectProperty = isObjectProperty;\ngenerated$4.isRestElement = isRestElement;\ngenerated$4.isReturnStatement = isReturnStatement;\ngenerated$4.isSequenceExpression = isSequenceExpression;\ngenerated$4.isParenthesizedExpression = isParenthesizedExpression;\ngenerated$4.isSwitchCase = isSwitchCase;\ngenerated$4.isSwitchStatement = isSwitchStatement;\ngenerated$4.isThisExpression = isThisExpression;\ngenerated$4.isThrowStatement = isThrowStatement;\ngenerated$4.isTryStatement = isTryStatement;\ngenerated$4.isUnaryExpression = isUnaryExpression;\ngenerated$4.isUpdateExpression = isUpdateExpression;\ngenerated$4.isVariableDeclaration = isVariableDeclaration;\ngenerated$4.isVariableDeclarator = isVariableDeclarator;\ngenerated$4.isWhileStatement = isWhileStatement;\ngenerated$4.isWithStatement = isWithStatement;\ngenerated$4.isAssignmentPattern = isAssignmentPattern;\ngenerated$4.isArrayPattern = isArrayPattern;\ngenerated$4.isArrowFunctionExpression = isArrowFunctionExpression;\ngenerated$4.isClassBody = isClassBody;\ngenerated$4.isClassExpression = isClassExpression;\ngenerated$4.isClassDeclaration = isClassDeclaration;\ngenerated$4.isExportAllDeclaration = isExportAllDeclaration;\ngenerated$4.isExportDefaultDeclaration = isExportDefaultDeclaration;\ngenerated$4.isExportNamedDeclaration = isExportNamedDeclaration;\ngenerated$4.isExportSpecifier = isExportSpecifier;\ngenerated$4.isForOfStatement = isForOfStatement;\ngenerated$4.isImportDeclaration = isImportDeclaration;\ngenerated$4.isImportDefaultSpecifier = isImportDefaultSpecifier;\ngenerated$4.isImportNamespaceSpecifier = isImportNamespaceSpecifier;\ngenerated$4.isImportSpecifier = isImportSpecifier;\ngenerated$4.isMetaProperty = isMetaProperty;\ngenerated$4.isClassMethod = isClassMethod;\ngenerated$4.isObjectPattern = isObjectPattern;\ngenerated$4.isSpreadElement = isSpreadElement;\ngenerated$4.isSuper = isSuper;\ngenerated$4.isTaggedTemplateExpression = isTaggedTemplateExpression;\ngenerated$4.isTemplateElement = isTemplateElement;\ngenerated$4.isTemplateLiteral = isTemplateLiteral;\ngenerated$4.isYieldExpression = isYieldExpression;\ngenerated$4.isAwaitExpression = isAwaitExpression;\ngenerated$4.isImport = isImport;\ngenerated$4.isBigIntLiteral = isBigIntLiteral;\ngenerated$4.isExportNamespaceSpecifier = isExportNamespaceSpecifier;\ngenerated$4.isOptionalMemberExpression = isOptionalMemberExpression;\ngenerated$4.isOptionalCallExpression = isOptionalCallExpression;\ngenerated$4.isClassProperty = isClassProperty;\ngenerated$4.isClassPrivateProperty = isClassPrivateProperty;\ngenerated$4.isClassPrivateMethod = isClassPrivateMethod;\ngenerated$4.isPrivateName = isPrivateName;\ngenerated$4.isAnyTypeAnnotation = isAnyTypeAnnotation;\ngenerated$4.isArrayTypeAnnotation = isArrayTypeAnnotation;\ngenerated$4.isBooleanTypeAnnotation = isBooleanTypeAnnotation;\ngenerated$4.isBooleanLiteralTypeAnnotation = isBooleanLiteralTypeAnnotation;\ngenerated$4.isNullLiteralTypeAnnotation = isNullLiteralTypeAnnotation;\ngenerated$4.isClassImplements = isClassImplements;\ngenerated$4.isDeclareClass = isDeclareClass;\ngenerated$4.isDeclareFunction = isDeclareFunction;\ngenerated$4.isDeclareInterface = isDeclareInterface;\ngenerated$4.isDeclareModule = isDeclareModule;\ngenerated$4.isDeclareModuleExports = isDeclareModuleExports;\ngenerated$4.isDeclareTypeAlias = isDeclareTypeAlias;\ngenerated$4.isDeclareOpaqueType = isDeclareOpaqueType;\ngenerated$4.isDeclareVariable = isDeclareVariable;\ngenerated$4.isDeclareExportDeclaration = isDeclareExportDeclaration;\ngenerated$4.isDeclareExportAllDeclaration = isDeclareExportAllDeclaration;\ngenerated$4.isDeclaredPredicate = isDeclaredPredicate;\ngenerated$4.isExistsTypeAnnotation = isExistsTypeAnnotation;\ngenerated$4.isFunctionTypeAnnotation = isFunctionTypeAnnotation;\ngenerated$4.isFunctionTypeParam = isFunctionTypeParam;\ngenerated$4.isGenericTypeAnnotation = isGenericTypeAnnotation;\ngenerated$4.isInferredPredicate = isInferredPredicate;\ngenerated$4.isInterfaceExtends = isInterfaceExtends;\ngenerated$4.isInterfaceDeclaration = isInterfaceDeclaration;\ngenerated$4.isInterfaceTypeAnnotation = isInterfaceTypeAnnotation;\ngenerated$4.isIntersectionTypeAnnotation = isIntersectionTypeAnnotation;\ngenerated$4.isMixedTypeAnnotation = isMixedTypeAnnotation;\ngenerated$4.isEmptyTypeAnnotation = isEmptyTypeAnnotation;\ngenerated$4.isNullableTypeAnnotation = isNullableTypeAnnotation;\ngenerated$4.isNumberLiteralTypeAnnotation = isNumberLiteralTypeAnnotation;\ngenerated$4.isNumberTypeAnnotation = isNumberTypeAnnotation;\ngenerated$4.isObjectTypeAnnotation = isObjectTypeAnnotation;\ngenerated$4.isObjectTypeInternalSlot = isObjectTypeInternalSlot;\ngenerated$4.isObjectTypeCallProperty = isObjectTypeCallProperty;\ngenerated$4.isObjectTypeIndexer = isObjectTypeIndexer;\ngenerated$4.isObjectTypeProperty = isObjectTypeProperty;\ngenerated$4.isObjectTypeSpreadProperty = isObjectTypeSpreadProperty;\ngenerated$4.isOpaqueType = isOpaqueType;\ngenerated$4.isQualifiedTypeIdentifier = isQualifiedTypeIdentifier;\ngenerated$4.isStringLiteralTypeAnnotation = isStringLiteralTypeAnnotation;\ngenerated$4.isStringTypeAnnotation = isStringTypeAnnotation;\ngenerated$4.isSymbolTypeAnnotation = isSymbolTypeAnnotation;\ngenerated$4.isThisTypeAnnotation = isThisTypeAnnotation;\ngenerated$4.isTupleTypeAnnotation = isTupleTypeAnnotation;\ngenerated$4.isTypeofTypeAnnotation = isTypeofTypeAnnotation;\ngenerated$4.isTypeAlias = isTypeAlias;\ngenerated$4.isTypeAnnotation = isTypeAnnotation;\ngenerated$4.isTypeCastExpression = isTypeCastExpression;\ngenerated$4.isTypeParameter = isTypeParameter;\ngenerated$4.isTypeParameterDeclaration = isTypeParameterDeclaration;\ngenerated$4.isTypeParameterInstantiation = isTypeParameterInstantiation;\ngenerated$4.isUnionTypeAnnotation = isUnionTypeAnnotation;\ngenerated$4.isVariance = isVariance;\ngenerated$4.isVoidTypeAnnotation = isVoidTypeAnnotation;\ngenerated$4.isEnumDeclaration = isEnumDeclaration;\ngenerated$4.isEnumBooleanBody = isEnumBooleanBody;\ngenerated$4.isEnumNumberBody = isEnumNumberBody;\ngenerated$4.isEnumStringBody = isEnumStringBody;\ngenerated$4.isEnumSymbolBody = isEnumSymbolBody;\ngenerated$4.isEnumBooleanMember = isEnumBooleanMember;\ngenerated$4.isEnumNumberMember = isEnumNumberMember;\ngenerated$4.isEnumStringMember = isEnumStringMember;\ngenerated$4.isEnumDefaultedMember = isEnumDefaultedMember;\ngenerated$4.isIndexedAccessType = isIndexedAccessType;\ngenerated$4.isOptionalIndexedAccessType = isOptionalIndexedAccessType;\ngenerated$4.isJSXAttribute = isJSXAttribute;\ngenerated$4.isJSXClosingElement = isJSXClosingElement;\ngenerated$4.isJSXElement = isJSXElement;\ngenerated$4.isJSXEmptyExpression = isJSXEmptyExpression;\ngenerated$4.isJSXExpressionContainer = isJSXExpressionContainer;\ngenerated$4.isJSXSpreadChild = isJSXSpreadChild;\ngenerated$4.isJSXIdentifier = isJSXIdentifier;\ngenerated$4.isJSXMemberExpression = isJSXMemberExpression;\ngenerated$4.isJSXNamespacedName = isJSXNamespacedName;\ngenerated$4.isJSXOpeningElement = isJSXOpeningElement;\ngenerated$4.isJSXSpreadAttribute = isJSXSpreadAttribute;\ngenerated$4.isJSXText = isJSXText;\ngenerated$4.isJSXFragment = isJSXFragment;\ngenerated$4.isJSXOpeningFragment = isJSXOpeningFragment;\ngenerated$4.isJSXClosingFragment = isJSXClosingFragment;\ngenerated$4.isNoop = isNoop;\ngenerated$4.isPlaceholder = isPlaceholder;\ngenerated$4.isV8IntrinsicIdentifier = isV8IntrinsicIdentifier;\ngenerated$4.isArgumentPlaceholder = isArgumentPlaceholder;\ngenerated$4.isBindExpression = isBindExpression;\ngenerated$4.isImportAttribute = isImportAttribute;\ngenerated$4.isDecorator = isDecorator;\ngenerated$4.isDoExpression = isDoExpression;\ngenerated$4.isExportDefaultSpecifier = isExportDefaultSpecifier;\ngenerated$4.isRecordExpression = isRecordExpression;\ngenerated$4.isTupleExpression = isTupleExpression;\ngenerated$4.isDecimalLiteral = isDecimalLiteral;\ngenerated$4.isStaticBlock = isStaticBlock;\ngenerated$4.isModuleExpression = isModuleExpression;\ngenerated$4.isTopicReference = isTopicReference;\ngenerated$4.isPipelineTopicExpression = isPipelineTopicExpression;\ngenerated$4.isPipelineBareFunction = isPipelineBareFunction;\ngenerated$4.isPipelinePrimaryTopicReference = isPipelinePrimaryTopicReference;\ngenerated$4.isTSParameterProperty = isTSParameterProperty;\ngenerated$4.isTSDeclareFunction = isTSDeclareFunction;\ngenerated$4.isTSDeclareMethod = isTSDeclareMethod;\ngenerated$4.isTSQualifiedName = isTSQualifiedName;\ngenerated$4.isTSCallSignatureDeclaration = isTSCallSignatureDeclaration;\ngenerated$4.isTSConstructSignatureDeclaration = isTSConstructSignatureDeclaration;\ngenerated$4.isTSPropertySignature = isTSPropertySignature;\ngenerated$4.isTSMethodSignature = isTSMethodSignature;\ngenerated$4.isTSIndexSignature = isTSIndexSignature;\ngenerated$4.isTSAnyKeyword = isTSAnyKeyword;\ngenerated$4.isTSBooleanKeyword = isTSBooleanKeyword;\ngenerated$4.isTSBigIntKeyword = isTSBigIntKeyword;\ngenerated$4.isTSIntrinsicKeyword = isTSIntrinsicKeyword;\ngenerated$4.isTSNeverKeyword = isTSNeverKeyword;\ngenerated$4.isTSNullKeyword = isTSNullKeyword;\ngenerated$4.isTSNumberKeyword = isTSNumberKeyword;\ngenerated$4.isTSObjectKeyword = isTSObjectKeyword;\ngenerated$4.isTSStringKeyword = isTSStringKeyword;\ngenerated$4.isTSSymbolKeyword = isTSSymbolKeyword;\ngenerated$4.isTSUndefinedKeyword = isTSUndefinedKeyword;\ngenerated$4.isTSUnknownKeyword = isTSUnknownKeyword;\ngenerated$4.isTSVoidKeyword = isTSVoidKeyword;\ngenerated$4.isTSThisType = isTSThisType;\ngenerated$4.isTSFunctionType = isTSFunctionType;\ngenerated$4.isTSConstructorType = isTSConstructorType;\ngenerated$4.isTSTypeReference = isTSTypeReference;\ngenerated$4.isTSTypePredicate = isTSTypePredicate;\ngenerated$4.isTSTypeQuery = isTSTypeQuery;\ngenerated$4.isTSTypeLiteral = isTSTypeLiteral;\ngenerated$4.isTSArrayType = isTSArrayType;\ngenerated$4.isTSTupleType = isTSTupleType;\ngenerated$4.isTSOptionalType = isTSOptionalType;\ngenerated$4.isTSRestType = isTSRestType;\ngenerated$4.isTSNamedTupleMember = isTSNamedTupleMember;\ngenerated$4.isTSUnionType = isTSUnionType;\ngenerated$4.isTSIntersectionType = isTSIntersectionType;\ngenerated$4.isTSConditionalType = isTSConditionalType;\ngenerated$4.isTSInferType = isTSInferType;\ngenerated$4.isTSParenthesizedType = isTSParenthesizedType;\ngenerated$4.isTSTypeOperator = isTSTypeOperator;\ngenerated$4.isTSIndexedAccessType = isTSIndexedAccessType;\ngenerated$4.isTSMappedType = isTSMappedType;\ngenerated$4.isTSLiteralType = isTSLiteralType;\ngenerated$4.isTSExpressionWithTypeArguments = isTSExpressionWithTypeArguments;\ngenerated$4.isTSInterfaceDeclaration = isTSInterfaceDeclaration;\ngenerated$4.isTSInterfaceBody = isTSInterfaceBody;\ngenerated$4.isTSTypeAliasDeclaration = isTSTypeAliasDeclaration;\ngenerated$4.isTSAsExpression = isTSAsExpression;\ngenerated$4.isTSTypeAssertion = isTSTypeAssertion;\ngenerated$4.isTSEnumDeclaration = isTSEnumDeclaration;\ngenerated$4.isTSEnumMember = isTSEnumMember;\ngenerated$4.isTSModuleDeclaration = isTSModuleDeclaration;\ngenerated$4.isTSModuleBlock = isTSModuleBlock;\ngenerated$4.isTSImportType = isTSImportType;\ngenerated$4.isTSImportEqualsDeclaration = isTSImportEqualsDeclaration;\ngenerated$4.isTSExternalModuleReference = isTSExternalModuleReference;\ngenerated$4.isTSNonNullExpression = isTSNonNullExpression;\ngenerated$4.isTSExportAssignment = isTSExportAssignment;\ngenerated$4.isTSNamespaceExportDeclaration = isTSNamespaceExportDeclaration;\ngenerated$4.isTSTypeAnnotation = isTSTypeAnnotation;\ngenerated$4.isTSTypeParameterInstantiation = isTSTypeParameterInstantiation;\ngenerated$4.isTSTypeParameterDeclaration = isTSTypeParameterDeclaration;\ngenerated$4.isTSTypeParameter = isTSTypeParameter;\ngenerated$4.isExpression = isExpression;\ngenerated$4.isBinary = isBinary;\ngenerated$4.isScopable = isScopable;\ngenerated$4.isBlockParent = isBlockParent;\ngenerated$4.isBlock = isBlock;\ngenerated$4.isStatement = isStatement;\ngenerated$4.isTerminatorless = isTerminatorless;\ngenerated$4.isCompletionStatement = isCompletionStatement;\ngenerated$4.isConditional = isConditional;\ngenerated$4.isLoop = isLoop;\ngenerated$4.isWhile = isWhile;\ngenerated$4.isExpressionWrapper = isExpressionWrapper;\ngenerated$4.isFor = isFor;\ngenerated$4.isForXStatement = isForXStatement;\ngenerated$4.isFunction = isFunction;\ngenerated$4.isFunctionParent = isFunctionParent;\ngenerated$4.isPureish = isPureish;\ngenerated$4.isDeclaration = isDeclaration;\ngenerated$4.isPatternLike = isPatternLike;\ngenerated$4.isLVal = isLVal;\ngenerated$4.isTSEntityName = isTSEntityName;\ngenerated$4.isLiteral = isLiteral;\ngenerated$4.isImmutable = isImmutable$2;\ngenerated$4.isUserWhitespacable = isUserWhitespacable;\ngenerated$4.isMethod = isMethod;\ngenerated$4.isObjectMember = isObjectMember;\ngenerated$4.isProperty = isProperty;\ngenerated$4.isUnaryLike = isUnaryLike;\ngenerated$4.isPattern = isPattern;\ngenerated$4.isClass = isClass;\ngenerated$4.isModuleDeclaration = isModuleDeclaration;\ngenerated$4.isExportDeclaration = isExportDeclaration;\ngenerated$4.isModuleSpecifier = isModuleSpecifier;\ngenerated$4.isPrivate = isPrivate;\ngenerated$4.isFlow = isFlow;\ngenerated$4.isFlowType = isFlowType;\ngenerated$4.isFlowBaseAnnotation = isFlowBaseAnnotation;\ngenerated$4.isFlowDeclaration = isFlowDeclaration;\ngenerated$4.isFlowPredicate = isFlowPredicate;\ngenerated$4.isEnumBody = isEnumBody;\ngenerated$4.isEnumMember = isEnumMember;\ngenerated$4.isJSX = isJSX;\ngenerated$4.isTSTypeElement = isTSTypeElement;\ngenerated$4.isTSType = isTSType;\ngenerated$4.isTSBaseType = isTSBaseType;\ngenerated$4.isNumberLiteral = isNumberLiteral;\ngenerated$4.isRegexLiteral = isRegexLiteral;\ngenerated$4.isRestProperty = isRestProperty;\ngenerated$4.isSpreadProperty = isSpreadProperty;\nvar _shallowEqual = shallowEqual$1;\nfunction isArrayExpression(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"ArrayExpression\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isAssignmentExpression(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"AssignmentExpression\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isBinaryExpression(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"BinaryExpression\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isInterpreterDirective(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"InterpreterDirective\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isDirective(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"Directive\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isDirectiveLiteral(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"DirectiveLiteral\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isBlockStatement(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"BlockStatement\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isBreakStatement(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"BreakStatement\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isCallExpression(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"CallExpression\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isCatchClause(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"CatchClause\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isConditionalExpression(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"ConditionalExpression\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isContinueStatement(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"ContinueStatement\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isDebuggerStatement(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"DebuggerStatement\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isDoWhileStatement(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"DoWhileStatement\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isEmptyStatement(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"EmptyStatement\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isExpressionStatement(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"ExpressionStatement\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isFile(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"File\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isForInStatement(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"ForInStatement\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isForStatement(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"ForStatement\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isFunctionDeclaration(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"FunctionDeclaration\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isFunctionExpression(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"FunctionExpression\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isIdentifier(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"Identifier\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isIfStatement(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"IfStatement\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isLabeledStatement(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"LabeledStatement\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isStringLiteral(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"StringLiteral\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isNumericLiteral(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"NumericLiteral\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isNullLiteral(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"NullLiteral\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isBooleanLiteral(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"BooleanLiteral\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isRegExpLiteral(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"RegExpLiteral\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isLogicalExpression(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"LogicalExpression\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isMemberExpression(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"MemberExpression\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isNewExpression(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"NewExpression\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isProgram(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"Program\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isObjectExpression(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"ObjectExpression\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isObjectMethod(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"ObjectMethod\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isObjectProperty(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"ObjectProperty\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isRestElement(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"RestElement\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isReturnStatement(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"ReturnStatement\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isSequenceExpression(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"SequenceExpression\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isParenthesizedExpression(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"ParenthesizedExpression\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isSwitchCase(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"SwitchCase\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isSwitchStatement(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"SwitchStatement\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isThisExpression(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"ThisExpression\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isThrowStatement(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"ThrowStatement\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isTryStatement(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"TryStatement\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isUnaryExpression(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"UnaryExpression\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isUpdateExpression(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"UpdateExpression\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isVariableDeclaration(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"VariableDeclaration\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isVariableDeclarator(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"VariableDeclarator\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isWhileStatement(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"WhileStatement\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isWithStatement(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"WithStatement\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isAssignmentPattern(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"AssignmentPattern\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isArrayPattern(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"ArrayPattern\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isArrowFunctionExpression(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"ArrowFunctionExpression\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isClassBody(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"ClassBody\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isClassExpression(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"ClassExpression\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isClassDeclaration(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"ClassDeclaration\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isExportAllDeclaration(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"ExportAllDeclaration\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isExportDefaultDeclaration(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"ExportDefaultDeclaration\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isExportNamedDeclaration(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"ExportNamedDeclaration\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isExportSpecifier(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"ExportSpecifier\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isForOfStatement(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"ForOfStatement\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isImportDeclaration(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"ImportDeclaration\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isImportDefaultSpecifier(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"ImportDefaultSpecifier\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isImportNamespaceSpecifier(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"ImportNamespaceSpecifier\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isImportSpecifier(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"ImportSpecifier\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isMetaProperty(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"MetaProperty\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isClassMethod(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"ClassMethod\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isObjectPattern(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"ObjectPattern\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isSpreadElement(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"SpreadElement\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isSuper(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"Super\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isTaggedTemplateExpression(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"TaggedTemplateExpression\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isTemplateElement(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"TemplateElement\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isTemplateLiteral(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"TemplateLiteral\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isYieldExpression(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"YieldExpression\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isAwaitExpression(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"AwaitExpression\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isImport(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"Import\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isBigIntLiteral(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"BigIntLiteral\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isExportNamespaceSpecifier(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"ExportNamespaceSpecifier\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isOptionalMemberExpression(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"OptionalMemberExpression\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isOptionalCallExpression(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"OptionalCallExpression\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isClassProperty(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"ClassProperty\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isClassPrivateProperty(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"ClassPrivateProperty\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isClassPrivateMethod(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"ClassPrivateMethod\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isPrivateName(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"PrivateName\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isAnyTypeAnnotation(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"AnyTypeAnnotation\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isArrayTypeAnnotation(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"ArrayTypeAnnotation\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isBooleanTypeAnnotation(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"BooleanTypeAnnotation\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isBooleanLiteralTypeAnnotation(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"BooleanLiteralTypeAnnotation\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isNullLiteralTypeAnnotation(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"NullLiteralTypeAnnotation\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isClassImplements(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"ClassImplements\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isDeclareClass(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"DeclareClass\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isDeclareFunction(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"DeclareFunction\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isDeclareInterface(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"DeclareInterface\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isDeclareModule(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"DeclareModule\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isDeclareModuleExports(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"DeclareModuleExports\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isDeclareTypeAlias(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"DeclareTypeAlias\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isDeclareOpaqueType(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"DeclareOpaqueType\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isDeclareVariable(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"DeclareVariable\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isDeclareExportDeclaration(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"DeclareExportDeclaration\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isDeclareExportAllDeclaration(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"DeclareExportAllDeclaration\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isDeclaredPredicate(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"DeclaredPredicate\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isExistsTypeAnnotation(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"ExistsTypeAnnotation\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isFunctionTypeAnnotation(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"FunctionTypeAnnotation\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isFunctionTypeParam(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"FunctionTypeParam\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isGenericTypeAnnotation(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"GenericTypeAnnotation\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isInferredPredicate(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"InferredPredicate\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isInterfaceExtends(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"InterfaceExtends\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isInterfaceDeclaration(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"InterfaceDeclaration\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isInterfaceTypeAnnotation(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"InterfaceTypeAnnotation\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isIntersectionTypeAnnotation(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"IntersectionTypeAnnotation\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isMixedTypeAnnotation(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"MixedTypeAnnotation\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isEmptyTypeAnnotation(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"EmptyTypeAnnotation\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isNullableTypeAnnotation(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"NullableTypeAnnotation\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isNumberLiteralTypeAnnotation(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"NumberLiteralTypeAnnotation\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isNumberTypeAnnotation(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"NumberTypeAnnotation\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isObjectTypeAnnotation(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"ObjectTypeAnnotation\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isObjectTypeInternalSlot(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"ObjectTypeInternalSlot\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isObjectTypeCallProperty(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"ObjectTypeCallProperty\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isObjectTypeIndexer(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"ObjectTypeIndexer\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isObjectTypeProperty(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"ObjectTypeProperty\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isObjectTypeSpreadProperty(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"ObjectTypeSpreadProperty\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isOpaqueType(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"OpaqueType\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isQualifiedTypeIdentifier(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"QualifiedTypeIdentifier\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isStringLiteralTypeAnnotation(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"StringLiteralTypeAnnotation\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isStringTypeAnnotation(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"StringTypeAnnotation\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isSymbolTypeAnnotation(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"SymbolTypeAnnotation\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isThisTypeAnnotation(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"ThisTypeAnnotation\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isTupleTypeAnnotation(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"TupleTypeAnnotation\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isTypeofTypeAnnotation(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"TypeofTypeAnnotation\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isTypeAlias(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"TypeAlias\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isTypeAnnotation(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"TypeAnnotation\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isTypeCastExpression(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"TypeCastExpression\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isTypeParameter(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"TypeParameter\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isTypeParameterDeclaration(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"TypeParameterDeclaration\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isTypeParameterInstantiation(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"TypeParameterInstantiation\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isUnionTypeAnnotation(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"UnionTypeAnnotation\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isVariance(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"Variance\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isVoidTypeAnnotation(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"VoidTypeAnnotation\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isEnumDeclaration(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"EnumDeclaration\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isEnumBooleanBody(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"EnumBooleanBody\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isEnumNumberBody(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"EnumNumberBody\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isEnumStringBody(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"EnumStringBody\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isEnumSymbolBody(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"EnumSymbolBody\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isEnumBooleanMember(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"EnumBooleanMember\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isEnumNumberMember(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"EnumNumberMember\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isEnumStringMember(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"EnumStringMember\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isEnumDefaultedMember(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"EnumDefaultedMember\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isIndexedAccessType(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"IndexedAccessType\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isOptionalIndexedAccessType(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"OptionalIndexedAccessType\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isJSXAttribute(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"JSXAttribute\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isJSXClosingElement(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"JSXClosingElement\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isJSXElement(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"JSXElement\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isJSXEmptyExpression(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"JSXEmptyExpression\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isJSXExpressionContainer(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"JSXExpressionContainer\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isJSXSpreadChild(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"JSXSpreadChild\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isJSXIdentifier(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"JSXIdentifier\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isJSXMemberExpression(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"JSXMemberExpression\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isJSXNamespacedName(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"JSXNamespacedName\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isJSXOpeningElement(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"JSXOpeningElement\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isJSXSpreadAttribute(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"JSXSpreadAttribute\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isJSXText(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"JSXText\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isJSXFragment(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"JSXFragment\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isJSXOpeningFragment(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"JSXOpeningFragment\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isJSXClosingFragment(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"JSXClosingFragment\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isNoop(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"Noop\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isPlaceholder(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"Placeholder\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isV8IntrinsicIdentifier(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"V8IntrinsicIdentifier\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isArgumentPlaceholder(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"ArgumentPlaceholder\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isBindExpression(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"BindExpression\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isImportAttribute(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"ImportAttribute\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isDecorator(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"Decorator\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isDoExpression(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"DoExpression\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isExportDefaultSpecifier(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"ExportDefaultSpecifier\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isRecordExpression(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"RecordExpression\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isTupleExpression(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"TupleExpression\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isDecimalLiteral(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"DecimalLiteral\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isStaticBlock(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"StaticBlock\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isModuleExpression(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"ModuleExpression\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isTopicReference(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"TopicReference\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isPipelineTopicExpression(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"PipelineTopicExpression\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isPipelineBareFunction(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"PipelineBareFunction\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isPipelinePrimaryTopicReference(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"PipelinePrimaryTopicReference\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isTSParameterProperty(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"TSParameterProperty\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isTSDeclareFunction(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"TSDeclareFunction\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isTSDeclareMethod(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"TSDeclareMethod\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isTSQualifiedName(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"TSQualifiedName\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isTSCallSignatureDeclaration(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"TSCallSignatureDeclaration\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isTSConstructSignatureDeclaration(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"TSConstructSignatureDeclaration\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isTSPropertySignature(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"TSPropertySignature\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isTSMethodSignature(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"TSMethodSignature\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isTSIndexSignature(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"TSIndexSignature\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isTSAnyKeyword(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"TSAnyKeyword\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isTSBooleanKeyword(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"TSBooleanKeyword\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isTSBigIntKeyword(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"TSBigIntKeyword\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isTSIntrinsicKeyword(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"TSIntrinsicKeyword\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isTSNeverKeyword(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"TSNeverKeyword\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isTSNullKeyword(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"TSNullKeyword\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isTSNumberKeyword(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"TSNumberKeyword\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isTSObjectKeyword(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"TSObjectKeyword\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isTSStringKeyword(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"TSStringKeyword\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isTSSymbolKeyword(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"TSSymbolKeyword\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isTSUndefinedKeyword(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"TSUndefinedKeyword\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isTSUnknownKeyword(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"TSUnknownKeyword\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isTSVoidKeyword(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"TSVoidKeyword\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isTSThisType(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"TSThisType\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isTSFunctionType(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"TSFunctionType\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isTSConstructorType(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"TSConstructorType\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isTSTypeReference(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"TSTypeReference\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isTSTypePredicate(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"TSTypePredicate\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isTSTypeQuery(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"TSTypeQuery\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isTSTypeLiteral(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"TSTypeLiteral\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isTSArrayType(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"TSArrayType\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isTSTupleType(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"TSTupleType\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isTSOptionalType(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"TSOptionalType\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isTSRestType(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"TSRestType\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isTSNamedTupleMember(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"TSNamedTupleMember\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isTSUnionType(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"TSUnionType\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isTSIntersectionType(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"TSIntersectionType\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isTSConditionalType(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"TSConditionalType\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isTSInferType(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"TSInferType\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isTSParenthesizedType(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"TSParenthesizedType\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isTSTypeOperator(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"TSTypeOperator\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isTSIndexedAccessType(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"TSIndexedAccessType\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isTSMappedType(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"TSMappedType\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isTSLiteralType(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"TSLiteralType\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isTSExpressionWithTypeArguments(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"TSExpressionWithTypeArguments\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isTSInterfaceDeclaration(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"TSInterfaceDeclaration\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isTSInterfaceBody(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"TSInterfaceBody\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isTSTypeAliasDeclaration(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"TSTypeAliasDeclaration\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isTSAsExpression(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"TSAsExpression\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isTSTypeAssertion(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"TSTypeAssertion\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isTSEnumDeclaration(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"TSEnumDeclaration\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isTSEnumMember(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"TSEnumMember\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isTSModuleDeclaration(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"TSModuleDeclaration\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isTSModuleBlock(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"TSModuleBlock\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isTSImportType(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"TSImportType\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isTSImportEqualsDeclaration(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"TSImportEqualsDeclaration\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isTSExternalModuleReference(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"TSExternalModuleReference\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isTSNonNullExpression(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"TSNonNullExpression\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isTSExportAssignment(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"TSExportAssignment\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isTSNamespaceExportDeclaration(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"TSNamespaceExportDeclaration\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isTSTypeAnnotation(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"TSTypeAnnotation\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isTSTypeParameterInstantiation(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"TSTypeParameterInstantiation\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isTSTypeParameterDeclaration(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"TSTypeParameterDeclaration\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isTSTypeParameter(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"TSTypeParameter\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isExpression(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (\"ArrayExpression\" === nodeType || \"AssignmentExpression\" === nodeType || \"BinaryExpression\" === nodeType || \"CallExpression\" === nodeType || \"ConditionalExpression\" === nodeType || \"FunctionExpression\" === nodeType || \"Identifier\" === nodeType || \"StringLiteral\" === nodeType || \"NumericLiteral\" === nodeType || \"NullLiteral\" === nodeType || \"BooleanLiteral\" === nodeType || \"RegExpLiteral\" === nodeType || \"LogicalExpression\" === nodeType || \"MemberExpression\" === nodeType || \"NewExpression\" === nodeType || \"ObjectExpression\" === nodeType || \"SequenceExpression\" === nodeType || \"ParenthesizedExpression\" === nodeType || \"ThisExpression\" === nodeType || \"UnaryExpression\" === nodeType || \"UpdateExpression\" === nodeType || \"ArrowFunctionExpression\" === nodeType || \"ClassExpression\" === nodeType || \"MetaProperty\" === nodeType || \"Super\" === nodeType || \"TaggedTemplateExpression\" === nodeType || \"TemplateLiteral\" === nodeType || \"YieldExpression\" === nodeType || \"AwaitExpression\" === nodeType || \"Import\" === nodeType || \"BigIntLiteral\" === nodeType || \"OptionalMemberExpression\" === nodeType || \"OptionalCallExpression\" === nodeType || \"TypeCastExpression\" === nodeType || \"JSXElement\" === nodeType || \"JSXFragment\" === nodeType || \"BindExpression\" === nodeType || \"DoExpression\" === nodeType || \"RecordExpression\" === nodeType || \"TupleExpression\" === nodeType || \"DecimalLiteral\" === nodeType || \"ModuleExpression\" === nodeType || \"TopicReference\" === nodeType || \"PipelineTopicExpression\" === nodeType || \"PipelineBareFunction\" === nodeType || \"PipelinePrimaryTopicReference\" === nodeType || \"TSAsExpression\" === nodeType || \"TSTypeAssertion\" === nodeType || \"TSNonNullExpression\" === nodeType || nodeType === \"Placeholder\" && (\"Expression\" === node.expectedNode || \"Identifier\" === node.expectedNode || \"StringLiteral\" === node.expectedNode)) {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isBinary(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (\"BinaryExpression\" === nodeType || \"LogicalExpression\" === nodeType) {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isScopable(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (\"BlockStatement\" === nodeType || \"CatchClause\" === nodeType || \"DoWhileStatement\" === nodeType || \"ForInStatement\" === nodeType || \"ForStatement\" === nodeType || \"FunctionDeclaration\" === nodeType || \"FunctionExpression\" === nodeType || \"Program\" === nodeType || \"ObjectMethod\" === nodeType || \"SwitchStatement\" === nodeType || \"WhileStatement\" === nodeType || \"ArrowFunctionExpression\" === nodeType || \"ClassExpression\" === nodeType || \"ClassDeclaration\" === nodeType || \"ForOfStatement\" === nodeType || \"ClassMethod\" === nodeType || \"ClassPrivateMethod\" === nodeType || \"StaticBlock\" === nodeType || \"TSModuleBlock\" === nodeType || nodeType === \"Placeholder\" && \"BlockStatement\" === node.expectedNode) {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isBlockParent(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (\"BlockStatement\" === nodeType || \"CatchClause\" === nodeType || \"DoWhileStatement\" === nodeType || \"ForInStatement\" === nodeType || \"ForStatement\" === nodeType || \"FunctionDeclaration\" === nodeType || \"FunctionExpression\" === nodeType || \"Program\" === nodeType || \"ObjectMethod\" === nodeType || \"SwitchStatement\" === nodeType || \"WhileStatement\" === nodeType || \"ArrowFunctionExpression\" === nodeType || \"ForOfStatement\" === nodeType || \"ClassMethod\" === nodeType || \"ClassPrivateMethod\" === nodeType || \"StaticBlock\" === nodeType || \"TSModuleBlock\" === nodeType || nodeType === \"Placeholder\" && \"BlockStatement\" === node.expectedNode) {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isBlock(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (\"BlockStatement\" === nodeType || \"Program\" === nodeType || \"TSModuleBlock\" === nodeType || nodeType === \"Placeholder\" && \"BlockStatement\" === node.expectedNode) {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isStatement(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (\"BlockStatement\" === nodeType || \"BreakStatement\" === nodeType || \"ContinueStatement\" === nodeType || \"DebuggerStatement\" === nodeType || \"DoWhileStatement\" === nodeType || \"EmptyStatement\" === nodeType || \"ExpressionStatement\" === nodeType || \"ForInStatement\" === nodeType || \"ForStatement\" === nodeType || \"FunctionDeclaration\" === nodeType || \"IfStatement\" === nodeType || \"LabeledStatement\" === nodeType || \"ReturnStatement\" === nodeType || \"SwitchStatement\" === nodeType || \"ThrowStatement\" === nodeType || \"TryStatement\" === nodeType || \"VariableDeclaration\" === nodeType || \"WhileStatement\" === nodeType || \"WithStatement\" === nodeType || \"ClassDeclaration\" === nodeType || \"ExportAllDeclaration\" === nodeType || \"ExportDefaultDeclaration\" === nodeType || \"ExportNamedDeclaration\" === nodeType || \"ForOfStatement\" === nodeType || \"ImportDeclaration\" === nodeType || \"DeclareClass\" === nodeType || \"DeclareFunction\" === nodeType || \"DeclareInterface\" === nodeType || \"DeclareModule\" === nodeType || \"DeclareModuleExports\" === nodeType || \"DeclareTypeAlias\" === nodeType || \"DeclareOpaqueType\" === nodeType || \"DeclareVariable\" === nodeType || \"DeclareExportDeclaration\" === nodeType || \"DeclareExportAllDeclaration\" === nodeType || \"InterfaceDeclaration\" === nodeType || \"OpaqueType\" === nodeType || \"TypeAlias\" === nodeType || \"EnumDeclaration\" === nodeType || \"TSDeclareFunction\" === nodeType || \"TSInterfaceDeclaration\" === nodeType || \"TSTypeAliasDeclaration\" === nodeType || \"TSEnumDeclaration\" === nodeType || \"TSModuleDeclaration\" === nodeType || \"TSImportEqualsDeclaration\" === nodeType || \"TSExportAssignment\" === nodeType || \"TSNamespaceExportDeclaration\" === nodeType || nodeType === \"Placeholder\" && (\"Statement\" === node.expectedNode || \"Declaration\" === node.expectedNode || \"BlockStatement\" === node.expectedNode)) {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isTerminatorless(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (\"BreakStatement\" === nodeType || \"ContinueStatement\" === nodeType || \"ReturnStatement\" === nodeType || \"ThrowStatement\" === nodeType || \"YieldExpression\" === nodeType || \"AwaitExpression\" === nodeType) {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isCompletionStatement(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (\"BreakStatement\" === nodeType || \"ContinueStatement\" === nodeType || \"ReturnStatement\" === nodeType || \"ThrowStatement\" === nodeType) {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isConditional(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (\"ConditionalExpression\" === nodeType || \"IfStatement\" === nodeType) {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isLoop(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (\"DoWhileStatement\" === nodeType || \"ForInStatement\" === nodeType || \"ForStatement\" === nodeType || \"WhileStatement\" === nodeType || \"ForOfStatement\" === nodeType) {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isWhile(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (\"DoWhileStatement\" === nodeType || \"WhileStatement\" === nodeType) {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isExpressionWrapper(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (\"ExpressionStatement\" === nodeType || \"ParenthesizedExpression\" === nodeType || \"TypeCastExpression\" === nodeType) {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isFor(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (\"ForInStatement\" === nodeType || \"ForStatement\" === nodeType || \"ForOfStatement\" === nodeType) {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isForXStatement(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (\"ForInStatement\" === nodeType || \"ForOfStatement\" === nodeType) {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isFunction(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (\"FunctionDeclaration\" === nodeType || \"FunctionExpression\" === nodeType || \"ObjectMethod\" === nodeType || \"ArrowFunctionExpression\" === nodeType || \"ClassMethod\" === nodeType || \"ClassPrivateMethod\" === nodeType) {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isFunctionParent(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (\"FunctionDeclaration\" === nodeType || \"FunctionExpression\" === nodeType || \"ObjectMethod\" === nodeType || \"ArrowFunctionExpression\" === nodeType || \"ClassMethod\" === nodeType || \"ClassPrivateMethod\" === nodeType) {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isPureish(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (\"FunctionDeclaration\" === nodeType || \"FunctionExpression\" === nodeType || \"StringLiteral\" === nodeType || \"NumericLiteral\" === nodeType || \"NullLiteral\" === nodeType || \"BooleanLiteral\" === nodeType || \"RegExpLiteral\" === nodeType || \"ArrowFunctionExpression\" === nodeType || \"BigIntLiteral\" === nodeType || \"DecimalLiteral\" === nodeType || nodeType === \"Placeholder\" && \"StringLiteral\" === node.expectedNode) {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isDeclaration(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (\"FunctionDeclaration\" === nodeType || \"VariableDeclaration\" === nodeType || \"ClassDeclaration\" === nodeType || \"ExportAllDeclaration\" === nodeType || \"ExportDefaultDeclaration\" === nodeType || \"ExportNamedDeclaration\" === nodeType || \"ImportDeclaration\" === nodeType || \"DeclareClass\" === nodeType || \"DeclareFunction\" === nodeType || \"DeclareInterface\" === nodeType || \"DeclareModule\" === nodeType || \"DeclareModuleExports\" === nodeType || \"DeclareTypeAlias\" === nodeType || \"DeclareOpaqueType\" === nodeType || \"DeclareVariable\" === nodeType || \"DeclareExportDeclaration\" === nodeType || \"DeclareExportAllDeclaration\" === nodeType || \"InterfaceDeclaration\" === nodeType || \"OpaqueType\" === nodeType || \"TypeAlias\" === nodeType || \"EnumDeclaration\" === nodeType || \"TSDeclareFunction\" === nodeType || \"TSInterfaceDeclaration\" === nodeType || \"TSTypeAliasDeclaration\" === nodeType || \"TSEnumDeclaration\" === nodeType || \"TSModuleDeclaration\" === nodeType || nodeType === \"Placeholder\" && \"Declaration\" === node.expectedNode) {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isPatternLike(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (\"Identifier\" === nodeType || \"RestElement\" === nodeType || \"AssignmentPattern\" === nodeType || \"ArrayPattern\" === nodeType || \"ObjectPattern\" === nodeType || nodeType === \"Placeholder\" && (\"Pattern\" === node.expectedNode || \"Identifier\" === node.expectedNode)) {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isLVal(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (\"Identifier\" === nodeType || \"MemberExpression\" === nodeType || \"RestElement\" === nodeType || \"AssignmentPattern\" === nodeType || \"ArrayPattern\" === nodeType || \"ObjectPattern\" === nodeType || \"TSParameterProperty\" === nodeType || nodeType === \"Placeholder\" && (\"Pattern\" === node.expectedNode || \"Identifier\" === node.expectedNode)) {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isTSEntityName(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (\"Identifier\" === nodeType || \"TSQualifiedName\" === nodeType || nodeType === \"Placeholder\" && \"Identifier\" === node.expectedNode) {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isLiteral(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (\"StringLiteral\" === nodeType || \"NumericLiteral\" === nodeType || \"NullLiteral\" === nodeType || \"BooleanLiteral\" === nodeType || \"RegExpLiteral\" === nodeType || \"TemplateLiteral\" === nodeType || \"BigIntLiteral\" === nodeType || \"DecimalLiteral\" === nodeType || nodeType === \"Placeholder\" && \"StringLiteral\" === node.expectedNode) {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isImmutable$2(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (\"StringLiteral\" === nodeType || \"NumericLiteral\" === nodeType || \"NullLiteral\" === nodeType || \"BooleanLiteral\" === nodeType || \"BigIntLiteral\" === nodeType || \"JSXAttribute\" === nodeType || \"JSXClosingElement\" === nodeType || \"JSXElement\" === nodeType || \"JSXExpressionContainer\" === nodeType || \"JSXSpreadChild\" === nodeType || \"JSXOpeningElement\" === nodeType || \"JSXText\" === nodeType || \"JSXFragment\" === nodeType || \"JSXOpeningFragment\" === nodeType || \"JSXClosingFragment\" === nodeType || \"DecimalLiteral\" === nodeType || nodeType === \"Placeholder\" && \"StringLiteral\" === node.expectedNode) {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isUserWhitespacable(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (\"ObjectMethod\" === nodeType || \"ObjectProperty\" === nodeType || \"ObjectTypeInternalSlot\" === nodeType || \"ObjectTypeCallProperty\" === nodeType || \"ObjectTypeIndexer\" === nodeType || \"ObjectTypeProperty\" === nodeType || \"ObjectTypeSpreadProperty\" === nodeType) {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isMethod(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (\"ObjectMethod\" === nodeType || \"ClassMethod\" === nodeType || \"ClassPrivateMethod\" === nodeType) {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isObjectMember(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (\"ObjectMethod\" === nodeType || \"ObjectProperty\" === nodeType) {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isProperty(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (\"ObjectProperty\" === nodeType || \"ClassProperty\" === nodeType || \"ClassPrivateProperty\" === nodeType) {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isUnaryLike(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (\"UnaryExpression\" === nodeType || \"SpreadElement\" === nodeType) {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isPattern(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (\"AssignmentPattern\" === nodeType || \"ArrayPattern\" === nodeType || \"ObjectPattern\" === nodeType || nodeType === \"Placeholder\" && \"Pattern\" === node.expectedNode) {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isClass(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (\"ClassExpression\" === nodeType || \"ClassDeclaration\" === nodeType) {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isModuleDeclaration(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (\"ExportAllDeclaration\" === nodeType || \"ExportDefaultDeclaration\" === nodeType || \"ExportNamedDeclaration\" === nodeType || \"ImportDeclaration\" === nodeType) {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isExportDeclaration(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (\"ExportAllDeclaration\" === nodeType || \"ExportDefaultDeclaration\" === nodeType || \"ExportNamedDeclaration\" === nodeType) {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isModuleSpecifier(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (\"ExportSpecifier\" === nodeType || \"ImportDefaultSpecifier\" === nodeType || \"ImportNamespaceSpecifier\" === nodeType || \"ImportSpecifier\" === nodeType || \"ExportNamespaceSpecifier\" === nodeType || \"ExportDefaultSpecifier\" === nodeType) {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isPrivate(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (\"ClassPrivateProperty\" === nodeType || \"ClassPrivateMethod\" === nodeType || \"PrivateName\" === nodeType) {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isFlow(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (\"AnyTypeAnnotation\" === nodeType || \"ArrayTypeAnnotation\" === nodeType || \"BooleanTypeAnnotation\" === nodeType || \"BooleanLiteralTypeAnnotation\" === nodeType || \"NullLiteralTypeAnnotation\" === nodeType || \"ClassImplements\" === nodeType || \"DeclareClass\" === nodeType || \"DeclareFunction\" === nodeType || \"DeclareInterface\" === nodeType || \"DeclareModule\" === nodeType || \"DeclareModuleExports\" === nodeType || \"DeclareTypeAlias\" === nodeType || \"DeclareOpaqueType\" === nodeType || \"DeclareVariable\" === nodeType || \"DeclareExportDeclaration\" === nodeType || \"DeclareExportAllDeclaration\" === nodeType || \"DeclaredPredicate\" === nodeType || \"ExistsTypeAnnotation\" === nodeType || \"FunctionTypeAnnotation\" === nodeType || \"FunctionTypeParam\" === nodeType || \"GenericTypeAnnotation\" === nodeType || \"InferredPredicate\" === nodeType || \"InterfaceExtends\" === nodeType || \"InterfaceDeclaration\" === nodeType || \"InterfaceTypeAnnotation\" === nodeType || \"IntersectionTypeAnnotation\" === nodeType || \"MixedTypeAnnotation\" === nodeType || \"EmptyTypeAnnotation\" === nodeType || \"NullableTypeAnnotation\" === nodeType || \"NumberLiteralTypeAnnotation\" === nodeType || \"NumberTypeAnnotation\" === nodeType || \"ObjectTypeAnnotation\" === nodeType || \"ObjectTypeInternalSlot\" === nodeType || \"ObjectTypeCallProperty\" === nodeType || \"ObjectTypeIndexer\" === nodeType || \"ObjectTypeProperty\" === nodeType || \"ObjectTypeSpreadProperty\" === nodeType || \"OpaqueType\" === nodeType || \"QualifiedTypeIdentifier\" === nodeType || \"StringLiteralTypeAnnotation\" === nodeType || \"StringTypeAnnotation\" === nodeType || \"SymbolTypeAnnotation\" === nodeType || \"ThisTypeAnnotation\" === nodeType || \"TupleTypeAnnotation\" === nodeType || \"TypeofTypeAnnotation\" === nodeType || \"TypeAlias\" === nodeType || \"TypeAnnotation\" === nodeType || \"TypeCastExpression\" === nodeType || \"TypeParameter\" === nodeType || \"TypeParameterDeclaration\" === nodeType || \"TypeParameterInstantiation\" === nodeType || \"UnionTypeAnnotation\" === nodeType || \"Variance\" === nodeType || \"VoidTypeAnnotation\" === nodeType || \"IndexedAccessType\" === nodeType || \"OptionalIndexedAccessType\" === nodeType) {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isFlowType(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (\"AnyTypeAnnotation\" === nodeType || \"ArrayTypeAnnotation\" === nodeType || \"BooleanTypeAnnotation\" === nodeType || \"BooleanLiteralTypeAnnotation\" === nodeType || \"NullLiteralTypeAnnotation\" === nodeType || \"ExistsTypeAnnotation\" === nodeType || \"FunctionTypeAnnotation\" === nodeType || \"GenericTypeAnnotation\" === nodeType || \"InterfaceTypeAnnotation\" === nodeType || \"IntersectionTypeAnnotation\" === nodeType || \"MixedTypeAnnotation\" === nodeType || \"EmptyTypeAnnotation\" === nodeType || \"NullableTypeAnnotation\" === nodeType || \"NumberLiteralTypeAnnotation\" === nodeType || \"NumberTypeAnnotation\" === nodeType || \"ObjectTypeAnnotation\" === nodeType || \"StringLiteralTypeAnnotation\" === nodeType || \"StringTypeAnnotation\" === nodeType || \"SymbolTypeAnnotation\" === nodeType || \"ThisTypeAnnotation\" === nodeType || \"TupleTypeAnnotation\" === nodeType || \"TypeofTypeAnnotation\" === nodeType || \"UnionTypeAnnotation\" === nodeType || \"VoidTypeAnnotation\" === nodeType || \"IndexedAccessType\" === nodeType || \"OptionalIndexedAccessType\" === nodeType) {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isFlowBaseAnnotation(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (\"AnyTypeAnnotation\" === nodeType || \"BooleanTypeAnnotation\" === nodeType || \"NullLiteralTypeAnnotation\" === nodeType || \"MixedTypeAnnotation\" === nodeType || \"EmptyTypeAnnotation\" === nodeType || \"NumberTypeAnnotation\" === nodeType || \"StringTypeAnnotation\" === nodeType || \"SymbolTypeAnnotation\" === nodeType || \"ThisTypeAnnotation\" === nodeType || \"VoidTypeAnnotation\" === nodeType) {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isFlowDeclaration(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (\"DeclareClass\" === nodeType || \"DeclareFunction\" === nodeType || \"DeclareInterface\" === nodeType || \"DeclareModule\" === nodeType || \"DeclareModuleExports\" === nodeType || \"DeclareTypeAlias\" === nodeType || \"DeclareOpaqueType\" === nodeType || \"DeclareVariable\" === nodeType || \"DeclareExportDeclaration\" === nodeType || \"DeclareExportAllDeclaration\" === nodeType || \"InterfaceDeclaration\" === nodeType || \"OpaqueType\" === nodeType || \"TypeAlias\" === nodeType) {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isFlowPredicate(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (\"DeclaredPredicate\" === nodeType || \"InferredPredicate\" === nodeType) {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isEnumBody(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (\"EnumBooleanBody\" === nodeType || \"EnumNumberBody\" === nodeType || \"EnumStringBody\" === nodeType || \"EnumSymbolBody\" === nodeType) {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isEnumMember(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (\"EnumBooleanMember\" === nodeType || \"EnumNumberMember\" === nodeType || \"EnumStringMember\" === nodeType || \"EnumDefaultedMember\" === nodeType) {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isJSX(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (\"JSXAttribute\" === nodeType || \"JSXClosingElement\" === nodeType || \"JSXElement\" === nodeType || \"JSXEmptyExpression\" === nodeType || \"JSXExpressionContainer\" === nodeType || \"JSXSpreadChild\" === nodeType || \"JSXIdentifier\" === nodeType || \"JSXMemberExpression\" === nodeType || \"JSXNamespacedName\" === nodeType || \"JSXOpeningElement\" === nodeType || \"JSXSpreadAttribute\" === nodeType || \"JSXText\" === nodeType || \"JSXFragment\" === nodeType || \"JSXOpeningFragment\" === nodeType || \"JSXClosingFragment\" === nodeType) {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isTSTypeElement(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (\"TSCallSignatureDeclaration\" === nodeType || \"TSConstructSignatureDeclaration\" === nodeType || \"TSPropertySignature\" === nodeType || \"TSMethodSignature\" === nodeType || \"TSIndexSignature\" === nodeType) {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isTSType(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (\"TSAnyKeyword\" === nodeType || \"TSBooleanKeyword\" === nodeType || \"TSBigIntKeyword\" === nodeType || \"TSIntrinsicKeyword\" === nodeType || \"TSNeverKeyword\" === nodeType || \"TSNullKeyword\" === nodeType || \"TSNumberKeyword\" === nodeType || \"TSObjectKeyword\" === nodeType || \"TSStringKeyword\" === nodeType || \"TSSymbolKeyword\" === nodeType || \"TSUndefinedKeyword\" === nodeType || \"TSUnknownKeyword\" === nodeType || \"TSVoidKeyword\" === nodeType || \"TSThisType\" === nodeType || \"TSFunctionType\" === nodeType || \"TSConstructorType\" === nodeType || \"TSTypeReference\" === nodeType || \"TSTypePredicate\" === nodeType || \"TSTypeQuery\" === nodeType || \"TSTypeLiteral\" === nodeType || \"TSArrayType\" === nodeType || \"TSTupleType\" === nodeType || \"TSOptionalType\" === nodeType || \"TSRestType\" === nodeType || \"TSUnionType\" === nodeType || \"TSIntersectionType\" === nodeType || \"TSConditionalType\" === nodeType || \"TSInferType\" === nodeType || \"TSParenthesizedType\" === nodeType || \"TSTypeOperator\" === nodeType || \"TSIndexedAccessType\" === nodeType || \"TSMappedType\" === nodeType || \"TSLiteralType\" === nodeType || \"TSExpressionWithTypeArguments\" === nodeType || \"TSImportType\" === nodeType) {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isTSBaseType(node, opts) {\n    if (!node) return false;\n    var nodeType = node.type;\n    if (\"TSAnyKeyword\" === nodeType || \"TSBooleanKeyword\" === nodeType || \"TSBigIntKeyword\" === nodeType || \"TSIntrinsicKeyword\" === nodeType || \"TSNeverKeyword\" === nodeType || \"TSNullKeyword\" === nodeType || \"TSNumberKeyword\" === nodeType || \"TSObjectKeyword\" === nodeType || \"TSStringKeyword\" === nodeType || \"TSSymbolKeyword\" === nodeType || \"TSUndefinedKeyword\" === nodeType || \"TSUnknownKeyword\" === nodeType || \"TSVoidKeyword\" === nodeType || \"TSThisType\" === nodeType || \"TSLiteralType\" === nodeType) {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isNumberLiteral(node, opts) {\n    console.trace(\"The node type NumberLiteral has been renamed to NumericLiteral\");\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"NumberLiteral\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isRegexLiteral(node, opts) {\n    console.trace(\"The node type RegexLiteral has been renamed to RegExpLiteral\");\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"RegexLiteral\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isRestProperty(node, opts) {\n    console.trace(\"The node type RestProperty has been renamed to RestElement\");\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"RestProperty\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\nfunction isSpreadProperty(node, opts) {\n    console.trace(\"The node type SpreadProperty has been renamed to SpreadElement\");\n    if (!node) return false;\n    var nodeType = node.type;\n    if (nodeType === \"SpreadProperty\") {\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    }\n    return false;\n}\n\nObject.defineProperty(matchesPattern$1, \"__esModule\", {\n    value: true\n});\nmatchesPattern$1.default = matchesPattern;\nvar _generated$o = generated$4;\nfunction matchesPattern(member, match, allowPartial) {\n    if (!(0, _generated$o.isMemberExpression)(member)) return false;\n    var parts = Array.isArray(match) ? match : match.split(\".\");\n    var nodes = [];\n    var node;\n    for(node = member; (0, _generated$o.isMemberExpression)(node); node = node.object){\n        nodes.push(node.property);\n    }\n    nodes.push(node);\n    if (nodes.length < parts.length) return false;\n    if (!allowPartial && nodes.length > parts.length) return false;\n    for(var i = 0, j = nodes.length - 1; i < parts.length; i++, j--){\n        var node1 = nodes[j];\n        var value = void 0;\n        if ((0, _generated$o.isIdentifier)(node1)) {\n            value = node1.name;\n        } else if ((0, _generated$o.isStringLiteral)(node1)) {\n            value = node1.value;\n        } else if ((0, _generated$o.isThisExpression)(node1)) {\n            value = \"this\";\n        } else {\n            return false;\n        }\n        if (parts[i] !== value) return false;\n    }\n    return true;\n}\n\nObject.defineProperty(buildMatchMemberExpression$1, \"__esModule\", {\n    value: true\n});\nbuildMatchMemberExpression$1.default = buildMatchMemberExpression;\nvar _matchesPattern = matchesPattern$1;\nfunction buildMatchMemberExpression(match, allowPartial) {\n    var parts = match.split(\".\");\n    return function(member) {\n        return (0, _matchesPattern.default)(member, parts, allowPartial);\n    };\n}\n\nObject.defineProperty(isReactComponent$1, \"__esModule\", {\n    value: true\n});\nisReactComponent$1.default = void 0;\nvar _buildMatchMemberExpression = buildMatchMemberExpression$1;\nvar isReactComponent = (0, _buildMatchMemberExpression.default)(\"React.Component\");\nvar _default$4 = isReactComponent;\nisReactComponent$1.default = _default$4;\n\nvar isCompatTag$1 = {};\n\nObject.defineProperty(isCompatTag$1, \"__esModule\", {\n    value: true\n});\nisCompatTag$1.default = isCompatTag;\nfunction isCompatTag(tagName) {\n    return !!tagName && /^[a-z]/.test(tagName);\n}\n\nvar buildChildren$1 = {};\n\nvar cleanJSXElementLiteralChild$1 = {};\n\nvar generated$3 = {};\n\nvar builder$1 = {};\n\nvar definitions = {};\n\nvar _typeof$4 = function(obj) {\n    \"@swc/helpers - typeof\";\n    return obj && typeof Symbol !== \"undefined\" && obj.constructor === Symbol ? \"symbol\" : typeof obj;\n};\nvar toFastProperties;\nvar hasRequiredToFastProperties;\nfunction requireToFastProperties() {\n    if (hasRequiredToFastProperties) return toFastProperties;\n    hasRequiredToFastProperties = 1;\n    var fastProto = null;\n    // Creates an object with permanently fast properties in V8. See Toon Verwaest's\n    // post https://medium.com/@tverwaes/setting-up-prototypes-in-v8-ec9c9491dfe2#5f62\n    // for more details. Use %HasFastProperties(object) and the Node.js flag\n    // --allow-natives-syntax to check whether an object has fast properties.\n    function FastObject(o) {\n        // A prototype object will have \"fast properties\" enabled once it is checked\n        // against the inline property cache of a function, e.g. fastProto.property:\n        // https://github.com/v8/v8/blob/6.0.122/test/mjsunit/fast-prototype.js#L48-L63\n        if (fastProto !== null && _typeof$4(fastProto.property)) {\n            var result = fastProto;\n            fastProto = FastObject.prototype = null;\n            return result;\n        }\n        fastProto = FastObject.prototype = o == null ? Object.create(null) : o;\n        return new FastObject;\n    }\n    // Initialize the inline property cache of FastObject\n    FastObject();\n    toFastProperties = function toFastproperties(o) {\n        return FastObject(o);\n    };\n    return toFastProperties;\n}\n\nvar core = {};\n\nvar is = {};\n\nvar isType = {};\n\nfunction _createForOfIteratorHelperLoose$i(o, allowArrayLike) {\n    var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n    if (it) return (it = it.call(o)).next.bind(it);\n    if (Array.isArray(o) || (it = unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n        if (it) o = it;\n        var i = 0;\n        return function() {\n            if (i >= o.length) return {\n                done: true\n            };\n            return {\n                done: false,\n                value: o[i++]\n            };\n        };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nvar hasRequiredIsType;\nfunction requireIsType() {\n    var isType$1 = function isType(nodeType, targetType) {\n        if (nodeType === targetType) return true;\n        if (_definitions.ALIAS_KEYS[targetType]) return false;\n        var aliases = _definitions.FLIPPED_ALIAS_KEYS[targetType];\n        if (aliases) {\n            if (aliases[0] === nodeType) return true;\n            for(var _iterator = _createForOfIteratorHelperLoose$i(aliases), _step; !(_step = _iterator()).done;){\n                var alias = _step.value;\n                if (nodeType === alias) return true;\n            }\n        }\n        return false;\n    };\n    if (hasRequiredIsType) return isType;\n    hasRequiredIsType = 1;\n    Object.defineProperty(isType, \"__esModule\", {\n        value: true\n    });\n    isType.default = isType$1;\n    var _definitions = requireDefinitions();\n    return isType;\n}\n\nvar isPlaceholderType = {};\n\nfunction _createForOfIteratorHelperLoose$h(o, allowArrayLike) {\n    var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n    if (it) return (it = it.call(o)).next.bind(it);\n    if (Array.isArray(o) || (it = unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n        if (it) o = it;\n        var i = 0;\n        return function() {\n            if (i >= o.length) return {\n                done: true\n            };\n            return {\n                done: false,\n                value: o[i++]\n            };\n        };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nvar hasRequiredIsPlaceholderType;\nfunction requireIsPlaceholderType() {\n    var isPlaceholderType$1 = function isPlaceholderType(placeholderType, targetType) {\n        if (placeholderType === targetType) return true;\n        var aliases = _definitions.PLACEHOLDERS_ALIAS[placeholderType];\n        if (aliases) {\n            for(var _iterator = _createForOfIteratorHelperLoose$h(aliases), _step; !(_step = _iterator()).done;){\n                var alias = _step.value;\n                if (targetType === alias) return true;\n            }\n        }\n        return false;\n    };\n    if (hasRequiredIsPlaceholderType) return isPlaceholderType;\n    hasRequiredIsPlaceholderType = 1;\n    Object.defineProperty(isPlaceholderType, \"__esModule\", {\n        value: true\n    });\n    isPlaceholderType.default = isPlaceholderType$1;\n    var _definitions = requireDefinitions();\n    return isPlaceholderType;\n}\n\nvar hasRequiredIs;\nfunction requireIs() {\n    var is$1 = function is(type, node, opts) {\n        if (!node) return false;\n        var matches = (0, _isType.default)(node.type, type);\n        if (!matches) {\n            if (!opts && node.type === \"Placeholder\" && type in _definitions.FLIPPED_ALIAS_KEYS) {\n                return (0, _isPlaceholderType.default)(node.expectedNode, type);\n            }\n            return false;\n        }\n        if (typeof opts === \"undefined\") {\n            return true;\n        } else {\n            return (0, _shallowEqual.default)(node, opts);\n        }\n    };\n    if (hasRequiredIs) return is;\n    hasRequiredIs = 1;\n    Object.defineProperty(is, \"__esModule\", {\n        value: true\n    });\n    is.default = is$1;\n    var _shallowEqual = shallowEqual$1;\n    var _isType = requireIsType();\n    var _isPlaceholderType = requireIsPlaceholderType();\n    var _definitions = requireDefinitions();\n    return is;\n}\n\nvar isValidIdentifier$1 = {};\n\nvar lib = {};\n\nvar identifier$1 = {};\n\nObject.defineProperty(identifier$1, \"__esModule\", {\n    value: true\n});\nidentifier$1.isIdentifierStart = isIdentifierStart;\nidentifier$1.isIdentifierChar = isIdentifierChar;\nidentifier$1.isIdentifierName = isIdentifierName;\nvar nonASCIIidentifierStartChars = \"\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\";\nvar nonASCIIidentifierChars = \"\\xb7----------------------------------------------------------------------------------------------------------------------------------------------------\";\nvar nonASCIIidentifierStart = new RegExp(\"[\" + nonASCIIidentifierStartChars + \"]\");\nvar nonASCIIidentifier = new RegExp(\"[\" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + \"]\");\nnonASCIIidentifierStartChars = nonASCIIidentifierChars = null;\nvar astralIdentifierStartCodes = [\n    0,\n    11,\n    2,\n    25,\n    2,\n    18,\n    2,\n    1,\n    2,\n    14,\n    3,\n    13,\n    35,\n    122,\n    70,\n    52,\n    268,\n    28,\n    4,\n    48,\n    48,\n    31,\n    14,\n    29,\n    6,\n    37,\n    11,\n    29,\n    3,\n    35,\n    5,\n    7,\n    2,\n    4,\n    43,\n    157,\n    19,\n    35,\n    5,\n    35,\n    5,\n    39,\n    9,\n    51,\n    157,\n    310,\n    10,\n    21,\n    11,\n    7,\n    153,\n    5,\n    3,\n    0,\n    2,\n    43,\n    2,\n    1,\n    4,\n    0,\n    3,\n    22,\n    11,\n    22,\n    10,\n    30,\n    66,\n    18,\n    2,\n    1,\n    11,\n    21,\n    11,\n    25,\n    71,\n    55,\n    7,\n    1,\n    65,\n    0,\n    16,\n    3,\n    2,\n    2,\n    2,\n    28,\n    43,\n    28,\n    4,\n    28,\n    36,\n    7,\n    2,\n    27,\n    28,\n    53,\n    11,\n    21,\n    11,\n    18,\n    14,\n    17,\n    111,\n    72,\n    56,\n    50,\n    14,\n    50,\n    14,\n    35,\n    349,\n    41,\n    7,\n    1,\n    79,\n    28,\n    11,\n    0,\n    9,\n    21,\n    107,\n    20,\n    28,\n    22,\n    13,\n    52,\n    76,\n    44,\n    33,\n    24,\n    27,\n    35,\n    30,\n    0,\n    3,\n    0,\n    9,\n    34,\n    4,\n    0,\n    13,\n    47,\n    15,\n    3,\n    22,\n    0,\n    2,\n    0,\n    36,\n    17,\n    2,\n    24,\n    85,\n    6,\n    2,\n    0,\n    2,\n    3,\n    2,\n    14,\n    2,\n    9,\n    8,\n    46,\n    39,\n    7,\n    3,\n    1,\n    3,\n    21,\n    2,\n    6,\n    2,\n    1,\n    2,\n    4,\n    4,\n    0,\n    19,\n    0,\n    13,\n    4,\n    159,\n    52,\n    19,\n    3,\n    21,\n    2,\n    31,\n    47,\n    21,\n    1,\n    2,\n    0,\n    185,\n    46,\n    42,\n    3,\n    37,\n    47,\n    21,\n    0,\n    60,\n    42,\n    14,\n    0,\n    72,\n    26,\n    230,\n    43,\n    117,\n    63,\n    32,\n    7,\n    3,\n    0,\n    3,\n    7,\n    2,\n    1,\n    2,\n    23,\n    16,\n    0,\n    2,\n    0,\n    95,\n    7,\n    3,\n    38,\n    17,\n    0,\n    2,\n    0,\n    29,\n    0,\n    11,\n    39,\n    8,\n    0,\n    22,\n    0,\n    12,\n    45,\n    20,\n    0,\n    35,\n    56,\n    264,\n    8,\n    2,\n    36,\n    18,\n    0,\n    50,\n    29,\n    113,\n    6,\n    2,\n    1,\n    2,\n    37,\n    22,\n    0,\n    26,\n    5,\n    2,\n    1,\n    2,\n    31,\n    15,\n    0,\n    328,\n    18,\n    190,\n    0,\n    80,\n    921,\n    103,\n    110,\n    18,\n    195,\n    2749,\n    1070,\n    4050,\n    582,\n    8634,\n    568,\n    8,\n    30,\n    114,\n    29,\n    19,\n    47,\n    17,\n    3,\n    32,\n    20,\n    6,\n    18,\n    689,\n    63,\n    129,\n    74,\n    6,\n    0,\n    67,\n    12,\n    65,\n    1,\n    2,\n    0,\n    29,\n    6135,\n    9,\n    1237,\n    43,\n    8,\n    8952,\n    286,\n    50,\n    2,\n    18,\n    3,\n    9,\n    395,\n    2309,\n    106,\n    6,\n    12,\n    4,\n    8,\n    8,\n    9,\n    5991,\n    84,\n    2,\n    70,\n    2,\n    1,\n    3,\n    0,\n    3,\n    1,\n    3,\n    3,\n    2,\n    11,\n    2,\n    0,\n    2,\n    6,\n    2,\n    64,\n    2,\n    3,\n    3,\n    7,\n    2,\n    6,\n    2,\n    27,\n    2,\n    3,\n    2,\n    4,\n    2,\n    0,\n    4,\n    6,\n    2,\n    339,\n    3,\n    24,\n    2,\n    24,\n    2,\n    30,\n    2,\n    24,\n    2,\n    30,\n    2,\n    24,\n    2,\n    30,\n    2,\n    24,\n    2,\n    30,\n    2,\n    24,\n    2,\n    7,\n    2357,\n    44,\n    11,\n    6,\n    17,\n    0,\n    370,\n    43,\n    1301,\n    196,\n    60,\n    67,\n    8,\n    0,\n    1205,\n    3,\n    2,\n    26,\n    2,\n    1,\n    2,\n    0,\n    3,\n    0,\n    2,\n    9,\n    2,\n    3,\n    2,\n    0,\n    2,\n    0,\n    7,\n    0,\n    5,\n    0,\n    2,\n    0,\n    2,\n    0,\n    2,\n    2,\n    2,\n    1,\n    2,\n    0,\n    3,\n    0,\n    2,\n    0,\n    2,\n    0,\n    2,\n    0,\n    2,\n    0,\n    2,\n    1,\n    2,\n    0,\n    3,\n    3,\n    2,\n    6,\n    2,\n    3,\n    2,\n    3,\n    2,\n    0,\n    2,\n    9,\n    2,\n    16,\n    6,\n    2,\n    2,\n    4,\n    2,\n    16,\n    4421,\n    42717,\n    35,\n    4148,\n    12,\n    221,\n    3,\n    5761,\n    15,\n    7472,\n    3104,\n    541,\n    1507,\n    4938\n];\nvar astralIdentifierCodes = [\n    509,\n    0,\n    227,\n    0,\n    150,\n    4,\n    294,\n    9,\n    1368,\n    2,\n    2,\n    1,\n    6,\n    3,\n    41,\n    2,\n    5,\n    0,\n    166,\n    1,\n    574,\n    3,\n    9,\n    9,\n    370,\n    1,\n    154,\n    10,\n    176,\n    2,\n    54,\n    14,\n    32,\n    9,\n    16,\n    3,\n    46,\n    10,\n    54,\n    9,\n    7,\n    2,\n    37,\n    13,\n    2,\n    9,\n    6,\n    1,\n    45,\n    0,\n    13,\n    2,\n    49,\n    13,\n    9,\n    3,\n    2,\n    11,\n    83,\n    11,\n    7,\n    0,\n    161,\n    11,\n    6,\n    9,\n    7,\n    3,\n    56,\n    1,\n    2,\n    6,\n    3,\n    1,\n    3,\n    2,\n    10,\n    0,\n    11,\n    1,\n    3,\n    6,\n    4,\n    4,\n    193,\n    17,\n    10,\n    9,\n    5,\n    0,\n    82,\n    19,\n    13,\n    9,\n    214,\n    6,\n    3,\n    8,\n    28,\n    1,\n    83,\n    16,\n    16,\n    9,\n    82,\n    12,\n    9,\n    9,\n    84,\n    14,\n    5,\n    9,\n    243,\n    14,\n    166,\n    9,\n    71,\n    5,\n    2,\n    1,\n    3,\n    3,\n    2,\n    0,\n    2,\n    1,\n    13,\n    9,\n    120,\n    6,\n    3,\n    6,\n    4,\n    0,\n    29,\n    9,\n    41,\n    6,\n    2,\n    3,\n    9,\n    0,\n    10,\n    10,\n    47,\n    15,\n    406,\n    7,\n    2,\n    7,\n    17,\n    9,\n    57,\n    21,\n    2,\n    13,\n    123,\n    5,\n    4,\n    0,\n    2,\n    1,\n    2,\n    6,\n    2,\n    0,\n    9,\n    9,\n    49,\n    4,\n    2,\n    1,\n    2,\n    4,\n    9,\n    9,\n    330,\n    3,\n    19306,\n    9,\n    135,\n    4,\n    60,\n    6,\n    26,\n    9,\n    1014,\n    0,\n    2,\n    54,\n    8,\n    3,\n    82,\n    0,\n    12,\n    1,\n    19628,\n    1,\n    5319,\n    4,\n    4,\n    5,\n    9,\n    7,\n    3,\n    6,\n    31,\n    3,\n    149,\n    2,\n    1418,\n    49,\n    513,\n    54,\n    5,\n    49,\n    9,\n    0,\n    15,\n    0,\n    23,\n    4,\n    2,\n    14,\n    1361,\n    6,\n    2,\n    16,\n    3,\n    6,\n    2,\n    1,\n    2,\n    4,\n    262,\n    6,\n    10,\n    9,\n    419,\n    13,\n    1495,\n    6,\n    110,\n    6,\n    6,\n    9,\n    4759,\n    9,\n    787719,\n    239\n];\nfunction isInAstralSet(code, set) {\n    var pos = 0x10000;\n    for(var i = 0, length = set.length; i < length; i += 2){\n        pos += set[i];\n        if (pos > code) return false;\n        pos += set[i + 1];\n        if (pos >= code) return true;\n    }\n    return false;\n}\nfunction isIdentifierStart(code) {\n    if (code < 65) return code === 36;\n    if (code <= 90) return true;\n    if (code < 97) return code === 95;\n    if (code <= 122) return true;\n    if (code <= 0xffff) {\n        return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code));\n    }\n    return isInAstralSet(code, astralIdentifierStartCodes);\n}\nfunction isIdentifierChar(code) {\n    if (code < 48) return code === 36;\n    if (code < 58) return true;\n    if (code < 65) return false;\n    if (code <= 90) return true;\n    if (code < 97) return code === 95;\n    if (code <= 122) return true;\n    if (code <= 0xffff) {\n        return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));\n    }\n    return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);\n}\nfunction isIdentifierName(name) {\n    var isFirst = true;\n    for(var i = 0; i < name.length; i++){\n        var cp = name.charCodeAt(i);\n        if ((cp & 0xfc00) === 0xd800 && i + 1 < name.length) {\n            var trail = name.charCodeAt(++i);\n            if ((trail & 0xfc00) === 0xdc00) {\n                cp = 0x10000 + ((cp & 0x3ff) << 10) + (trail & 0x3ff);\n            }\n        }\n        if (isFirst) {\n            isFirst = false;\n            if (!isIdentifierStart(cp)) {\n                return false;\n            }\n        } else if (!isIdentifierChar(cp)) {\n            return false;\n        }\n    }\n    return !isFirst;\n}\n\nvar keyword = {};\n\nObject.defineProperty(keyword, \"__esModule\", {\n    value: true\n});\nkeyword.isReservedWord = isReservedWord;\nkeyword.isStrictReservedWord = isStrictReservedWord;\nkeyword.isStrictBindOnlyReservedWord = isStrictBindOnlyReservedWord;\nkeyword.isStrictBindReservedWord = isStrictBindReservedWord;\nkeyword.isKeyword = isKeyword;\nvar reservedWords = {\n    keyword: [\n        \"break\",\n        \"case\",\n        \"catch\",\n        \"continue\",\n        \"debugger\",\n        \"default\",\n        \"do\",\n        \"else\",\n        \"finally\",\n        \"for\",\n        \"function\",\n        \"if\",\n        \"return\",\n        \"switch\",\n        \"throw\",\n        \"try\",\n        \"var\",\n        \"const\",\n        \"while\",\n        \"with\",\n        \"new\",\n        \"this\",\n        \"super\",\n        \"class\",\n        \"extends\",\n        \"export\",\n        \"import\",\n        \"null\",\n        \"true\",\n        \"false\",\n        \"in\",\n        \"instanceof\",\n        \"typeof\",\n        \"void\",\n        \"delete\"\n    ],\n    strict: [\n        \"implements\",\n        \"interface\",\n        \"let\",\n        \"package\",\n        \"private\",\n        \"protected\",\n        \"public\",\n        \"static\",\n        \"yield\"\n    ],\n    strictBind: [\n        \"eval\",\n        \"arguments\"\n    ]\n};\nvar keywords = new Set(reservedWords.keyword);\nvar reservedWordsStrictSet = new Set(reservedWords.strict);\nvar reservedWordsStrictBindSet = new Set(reservedWords.strictBind);\nfunction isReservedWord(word, inModule) {\n    return inModule && word === \"await\" || word === \"enum\";\n}\nfunction isStrictReservedWord(word, inModule) {\n    return isReservedWord(word, inModule) || reservedWordsStrictSet.has(word);\n}\nfunction isStrictBindOnlyReservedWord(word) {\n    return reservedWordsStrictBindSet.has(word);\n}\nfunction isStrictBindReservedWord(word, inModule) {\n    return isStrictReservedWord(word, inModule) || isStrictBindOnlyReservedWord(word);\n}\nfunction isKeyword(word) {\n    return keywords.has(word);\n}\n\n(function(exports) {\n    Object.defineProperty(exports, \"__esModule\", {\n        value: true\n    });\n    Object.defineProperty(exports, \"isIdentifierName\", {\n        enumerable: true,\n        get: function get() {\n            return _identifier.isIdentifierName;\n        }\n    });\n    Object.defineProperty(exports, \"isIdentifierChar\", {\n        enumerable: true,\n        get: function get() {\n            return _identifier.isIdentifierChar;\n        }\n    });\n    Object.defineProperty(exports, \"isIdentifierStart\", {\n        enumerable: true,\n        get: function get() {\n            return _identifier.isIdentifierStart;\n        }\n    });\n    Object.defineProperty(exports, \"isReservedWord\", {\n        enumerable: true,\n        get: function get() {\n            return _keyword.isReservedWord;\n        }\n    });\n    Object.defineProperty(exports, \"isStrictBindOnlyReservedWord\", {\n        enumerable: true,\n        get: function get() {\n            return _keyword.isStrictBindOnlyReservedWord;\n        }\n    });\n    Object.defineProperty(exports, \"isStrictBindReservedWord\", {\n        enumerable: true,\n        get: function get() {\n            return _keyword.isStrictBindReservedWord;\n        }\n    });\n    Object.defineProperty(exports, \"isStrictReservedWord\", {\n        enumerable: true,\n        get: function get() {\n            return _keyword.isStrictReservedWord;\n        }\n    });\n    Object.defineProperty(exports, \"isKeyword\", {\n        enumerable: true,\n        get: function get() {\n            return _keyword.isKeyword;\n        }\n    });\n    var _identifier = identifier$1;\n    var _keyword = keyword;\n})(lib);\n\nObject.defineProperty(isValidIdentifier$1, \"__esModule\", {\n    value: true\n});\nisValidIdentifier$1.default = isValidIdentifier;\nvar _helperValidatorIdentifier$1 = lib;\nfunction isValidIdentifier(name, reserved) {\n    if (reserved === void 0) reserved = true;\n    if (typeof name !== \"string\") return false;\n    if (reserved) {\n        if ((0, _helperValidatorIdentifier$1.isKeyword)(name) || (0, _helperValidatorIdentifier$1.isStrictReservedWord)(name, true)) {\n            return false;\n        }\n    }\n    return (0, _helperValidatorIdentifier$1.isIdentifierName)(name);\n}\n\nvar constants = {};\n\nfunction _arrayLikeToArray$3(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n    return arr2;\n}\nfunction _arrayWithoutHoles$3(arr) {\n    if (Array.isArray(arr)) return _arrayLikeToArray$3(arr);\n}\nfunction _iterableToArray$3(iter) {\n    if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\nfunction _nonIterableSpread$3() {\n    throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _toConsumableArray$3(arr) {\n    return _arrayWithoutHoles$3(arr) || _iterableToArray$3(arr) || _unsupportedIterableToArray$3(arr) || _nonIterableSpread$3();\n}\nfunction _unsupportedIterableToArray$3(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray$3(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(n);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$3(o, minLen);\n}\nObject.defineProperty(constants, \"__esModule\", {\n    value: true\n});\nconstants.NOT_LOCAL_BINDING = constants.BLOCK_SCOPED_SYMBOL = constants.INHERIT_KEYS = constants.UNARY_OPERATORS = constants.STRING_UNARY_OPERATORS = constants.NUMBER_UNARY_OPERATORS = constants.BOOLEAN_UNARY_OPERATORS = constants.ASSIGNMENT_OPERATORS = constants.BINARY_OPERATORS = constants.NUMBER_BINARY_OPERATORS = constants.BOOLEAN_BINARY_OPERATORS = constants.COMPARISON_BINARY_OPERATORS = constants.EQUALITY_BINARY_OPERATORS = constants.BOOLEAN_NUMBER_BINARY_OPERATORS = constants.UPDATE_OPERATORS = constants.LOGICAL_OPERATORS = constants.COMMENT_KEYS = constants.FOR_INIT_KEYS = constants.FLATTENABLE_KEYS = constants.STATEMENT_OR_BLOCK_KEYS = void 0;\nvar STATEMENT_OR_BLOCK_KEYS = [\n    \"consequent\",\n    \"body\",\n    \"alternate\"\n];\nconstants.STATEMENT_OR_BLOCK_KEYS = STATEMENT_OR_BLOCK_KEYS;\nvar FLATTENABLE_KEYS = [\n    \"body\",\n    \"expressions\"\n];\nconstants.FLATTENABLE_KEYS = FLATTENABLE_KEYS;\nvar FOR_INIT_KEYS = [\n    \"left\",\n    \"init\"\n];\nconstants.FOR_INIT_KEYS = FOR_INIT_KEYS;\nvar COMMENT_KEYS = [\n    \"leadingComments\",\n    \"trailingComments\",\n    \"innerComments\"\n];\nconstants.COMMENT_KEYS = COMMENT_KEYS;\nvar LOGICAL_OPERATORS = [\n    \"||\",\n    \"&&\",\n    \"??\"\n];\nconstants.LOGICAL_OPERATORS = LOGICAL_OPERATORS;\nvar UPDATE_OPERATORS = [\n    \"++\",\n    \"--\"\n];\nconstants.UPDATE_OPERATORS = UPDATE_OPERATORS;\nvar BOOLEAN_NUMBER_BINARY_OPERATORS = [\n    \">\",\n    \"<\",\n    \">=\",\n    \"<=\"\n];\nconstants.BOOLEAN_NUMBER_BINARY_OPERATORS = BOOLEAN_NUMBER_BINARY_OPERATORS;\nvar EQUALITY_BINARY_OPERATORS = [\n    \"==\",\n    \"===\",\n    \"!=\",\n    \"!==\"\n];\nconstants.EQUALITY_BINARY_OPERATORS = EQUALITY_BINARY_OPERATORS;\nvar COMPARISON_BINARY_OPERATORS = _toConsumableArray$3(EQUALITY_BINARY_OPERATORS).concat([\n    \"in\",\n    \"instanceof\"\n]);\nconstants.COMPARISON_BINARY_OPERATORS = COMPARISON_BINARY_OPERATORS;\nvar BOOLEAN_BINARY_OPERATORS = _toConsumableArray$3(COMPARISON_BINARY_OPERATORS).concat(_toConsumableArray$3(BOOLEAN_NUMBER_BINARY_OPERATORS));\nconstants.BOOLEAN_BINARY_OPERATORS = BOOLEAN_BINARY_OPERATORS;\nvar NUMBER_BINARY_OPERATORS = [\n    \"-\",\n    \"/\",\n    \"%\",\n    \"*\",\n    \"**\",\n    \"&\",\n    \"|\",\n    \">>\",\n    \">>>\",\n    \"<<\",\n    \"^\"\n];\nconstants.NUMBER_BINARY_OPERATORS = NUMBER_BINARY_OPERATORS;\nvar BINARY_OPERATORS = [\n    \"+\"\n].concat(_toConsumableArray$3(NUMBER_BINARY_OPERATORS), _toConsumableArray$3(BOOLEAN_BINARY_OPERATORS));\nconstants.BINARY_OPERATORS = BINARY_OPERATORS;\nvar ASSIGNMENT_OPERATORS = [\n    \"=\",\n    \"+=\"\n].concat(_toConsumableArray$3(NUMBER_BINARY_OPERATORS.map(function(op) {\n    return op + \"=\";\n})), _toConsumableArray$3(LOGICAL_OPERATORS.map(function(op) {\n    return op + \"=\";\n})));\nconstants.ASSIGNMENT_OPERATORS = ASSIGNMENT_OPERATORS;\nvar BOOLEAN_UNARY_OPERATORS = [\n    \"delete\",\n    \"!\"\n];\nconstants.BOOLEAN_UNARY_OPERATORS = BOOLEAN_UNARY_OPERATORS;\nvar NUMBER_UNARY_OPERATORS = [\n    \"+\",\n    \"-\",\n    \"~\"\n];\nconstants.NUMBER_UNARY_OPERATORS = NUMBER_UNARY_OPERATORS;\nvar STRING_UNARY_OPERATORS = [\n    \"typeof\"\n];\nconstants.STRING_UNARY_OPERATORS = STRING_UNARY_OPERATORS;\nvar UNARY_OPERATORS = [\n    \"void\",\n    \"throw\"\n].concat(_toConsumableArray$3(BOOLEAN_UNARY_OPERATORS), _toConsumableArray$3(NUMBER_UNARY_OPERATORS), _toConsumableArray$3(STRING_UNARY_OPERATORS));\nconstants.UNARY_OPERATORS = UNARY_OPERATORS;\nvar INHERIT_KEYS = {\n    optional: [\n        \"typeAnnotation\",\n        \"typeParameters\",\n        \"returnType\"\n    ],\n    force: [\n        \"start\",\n        \"loc\",\n        \"end\"\n    ]\n};\nconstants.INHERIT_KEYS = INHERIT_KEYS;\nvar BLOCK_SCOPED_SYMBOL = Symbol.for(\"var used to be block scoped\");\nconstants.BLOCK_SCOPED_SYMBOL = BLOCK_SCOPED_SYMBOL;\nvar NOT_LOCAL_BINDING = Symbol.for(\"should not be considered a local binding\");\nconstants.NOT_LOCAL_BINDING = NOT_LOCAL_BINDING;\n\nvar utils = {};\n\nvar validate = {};\n\nvar hasRequiredValidate;\nfunction requireValidate() {\n    var validate$1 = function validate(node, key, val) {\n        if (!node) return;\n        var fields = _definitions.NODE_FIELDS[node.type];\n        if (!fields) return;\n        var field = fields[key];\n        validateField(node, key, val, field);\n        validateChild(node, key, val);\n    };\n    var validateField = function validateField(node, key, val, field) {\n        if (!(field != null && field.validate)) return;\n        if (field.optional && val == null) return;\n        field.validate(node, key, val);\n    };\n    var validateChild = function validateChild(node, key, val) {\n        if (val == null) return;\n        var validate = _definitions.NODE_PARENT_VALIDATIONS[val.type];\n        if (!validate) return;\n        validate(node, key, val);\n    };\n    if (hasRequiredValidate) return validate;\n    hasRequiredValidate = 1;\n    Object.defineProperty(validate, \"__esModule\", {\n        value: true\n    });\n    validate.default = validate$1;\n    validate.validateField = validateField;\n    validate.validateChild = validateChild;\n    var _definitions = requireDefinitions();\n    return validate;\n}\n\nfunction _instanceof(left, right) {\n    if (right != null && typeof Symbol !== \"undefined\" && right[Symbol.hasInstance]) {\n        return !!right[Symbol.hasInstance](left);\n    } else {\n        return left instanceof right;\n    }\n}\nvar _typeof$3 = function(obj) {\n    \"@swc/helpers - typeof\";\n    return obj && typeof Symbol !== \"undefined\" && obj.constructor === Symbol ? \"symbol\" : typeof obj;\n};\nfunction _createForOfIteratorHelperLoose$g(o, allowArrayLike) {\n    var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n    if (it) return (it = it.call(o)).next.bind(it);\n    if (Array.isArray(o) || (it = unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n        if (it) o = it;\n        var i = 0;\n        return function() {\n            if (i >= o.length) return {\n                done: true\n            };\n            return {\n                done: false,\n                value: o[i++]\n            };\n        };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nvar hasRequiredUtils;\nfunction requireUtils() {\n    var getType = function getType(val) {\n        if (Array.isArray(val)) {\n            return \"array\";\n        } else if (val === null) {\n            return \"null\";\n        } else {\n            return typeof val === \"undefined\" ? \"undefined\" : _typeof$3(val);\n        }\n    };\n    var validate = function validate(validate) {\n        return {\n            validate: validate\n        };\n    };\n    var typeIs = function typeIs(typeName) {\n        return typeof typeName === \"string\" ? assertNodeType(typeName) : assertNodeType.apply(void 0, typeName);\n    };\n    var validateType = function validateType(typeName) {\n        return validate(typeIs(typeName));\n    };\n    var validateOptional = function validateOptional(validate) {\n        return {\n            validate: validate,\n            optional: true\n        };\n    };\n    var validateOptionalType = function validateOptionalType(typeName) {\n        return {\n            validate: typeIs(typeName),\n            optional: true\n        };\n    };\n    var arrayOf = function arrayOf(elementType) {\n        return chain(assertValueType(\"array\"), assertEach(elementType));\n    };\n    var arrayOfType = function arrayOfType(typeName) {\n        return arrayOf(typeIs(typeName));\n    };\n    var validateArrayOfType = function validateArrayOfType(typeName) {\n        return validate(arrayOfType(typeName));\n    };\n    var assertEach = function assertEach(callback) {\n        function validator(node, key, val) {\n            if (!Array.isArray(val)) return;\n            for(var i = 0; i < val.length; i++){\n                var subkey = key + \"[\" + i + \"]\";\n                var v = val[i];\n                callback(node, subkey, v);\n                if (process.env.BABEL_TYPES_8_BREAKING) (0, _validate.validateChild)(node, subkey, v);\n            }\n        }\n        validator.each = callback;\n        return validator;\n    };\n    var assertOneOf = function assertOneOf() {\n        for(var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++){\n            values[_key] = arguments[_key];\n        }\n        function validate(node, key, val) {\n            if (values.indexOf(val) < 0) {\n                throw new TypeError(\"Property \" + key + \" expected value to be one of \" + JSON.stringify(values) + \" but got \" + JSON.stringify(val));\n            }\n        }\n        validate.oneOf = values;\n        return validate;\n    };\n    var assertNodeType = function assertNodeType() {\n        for(var _len = arguments.length, types = new Array(_len), _key = 0; _key < _len; _key++){\n            types[_key] = arguments[_key];\n        }\n        function validate(node, key, val) {\n            for(var _iterator = _createForOfIteratorHelperLoose$g(types), _step; !(_step = _iterator()).done;){\n                var type = _step.value;\n                if ((0, _is.default)(type, val)) {\n                    (0, _validate.validateChild)(node, key, val);\n                    return;\n                }\n            }\n            throw new TypeError(\"Property \" + key + \" of \" + node.type + \" expected node to be of a type \" + JSON.stringify(types) + \" but instead got \" + JSON.stringify(val == null ? void 0 : val.type));\n        }\n        validate.oneOfNodeTypes = types;\n        return validate;\n    };\n    var assertNodeOrValueType = function assertNodeOrValueType() {\n        for(var _len = arguments.length, types = new Array(_len), _key = 0; _key < _len; _key++){\n            types[_key] = arguments[_key];\n        }\n        function validate(node, key, val) {\n            for(var _iterator = _createForOfIteratorHelperLoose$g(types), _step; !(_step = _iterator()).done;){\n                var type = _step.value;\n                if (getType(val) === type || (0, _is.default)(type, val)) {\n                    (0, _validate.validateChild)(node, key, val);\n                    return;\n                }\n            }\n            throw new TypeError(\"Property \" + key + \" of \" + node.type + \" expected node to be of a type \" + JSON.stringify(types) + \" but instead got \" + JSON.stringify(val == null ? void 0 : val.type));\n        }\n        validate.oneOfNodeOrValueTypes = types;\n        return validate;\n    };\n    var assertValueType = function assertValueType(type) {\n        function validate(node, key, val) {\n            var valid = getType(val) === type;\n            if (!valid) {\n                throw new TypeError(\"Property \" + key + \" expected type of \" + type + \" but got \" + getType(val));\n            }\n        }\n        validate.type = type;\n        return validate;\n    };\n    var assertShape = function assertShape(shape) {\n        function validate(node, key, val) {\n            var errors = [];\n            for(var _iterator = _createForOfIteratorHelperLoose$g(Object.keys(shape)), _step; !(_step = _iterator()).done;){\n                var property = _step.value;\n                try {\n                    (0, _validate.validateField)(node, property, val[property], shape[property]);\n                } catch (error) {\n                    if (_instanceof(error, TypeError)) {\n                        errors.push(error.message);\n                        continue;\n                    }\n                    throw error;\n                }\n            }\n            if (errors.length) {\n                throw new TypeError(\"Property \" + key + \" of \" + node.type + \" expected to have the following:\\n\" + errors.join(\"\\n\"));\n            }\n        }\n        validate.shapeOf = shape;\n        return validate;\n    };\n    var assertOptionalChainStart = function assertOptionalChainStart() {\n        function validate(node) {\n            var _current;\n            var current = node;\n            while(node){\n                var type = current.type;\n                if (type === \"OptionalCallExpression\") {\n                    if (current.optional) return;\n                    current = current.callee;\n                    continue;\n                }\n                if (type === \"OptionalMemberExpression\") {\n                    if (current.optional) return;\n                    current = current.object;\n                    continue;\n                }\n                break;\n            }\n            throw new TypeError(\"Non-optional \" + node.type + \" must chain from an optional OptionalMemberExpression or OptionalCallExpression. Found chain from \" + ((_current = current) == null ? void 0 : _current.type));\n        }\n        return validate;\n    };\n    var chain = function chain() {\n        for(var _len = arguments.length, fns = new Array(_len), _key = 0; _key < _len; _key++){\n            fns[_key] = arguments[_key];\n        }\n        function validate() {\n            for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n                args[_key] = arguments[_key];\n            }\n            for(var _iterator = _createForOfIteratorHelperLoose$g(fns), _step; !(_step = _iterator()).done;){\n                var fn = _step.value;\n                fn.apply(void 0, args);\n            }\n        }\n        validate.chainOf = fns;\n        if (fns.length >= 2 && \"type\" in fns[0] && fns[0].type === \"array\" && !(\"each\" in fns[1])) {\n            throw new Error('An assertValueType(\"array\") validator can only be followed by an assertEach(...) validator.');\n        }\n        return validate;\n    };\n    var defineType = function defineType(type, opts) {\n        if (opts === void 0) opts = {};\n        var inherits = opts.inherits && store[opts.inherits] || {};\n        var fields = opts.fields;\n        if (!fields) {\n            fields = {};\n            if (inherits.fields) {\n                var keys = Object.getOwnPropertyNames(inherits.fields);\n                for(var _iterator = _createForOfIteratorHelperLoose$g(keys), _step; !(_step = _iterator()).done;){\n                    var key = _step.value;\n                    var field = inherits.fields[key];\n                    var def = field.default;\n                    if (Array.isArray(def) ? def.length > 0 : def && typeof def === \"object\") {\n                        throw new Error(\"field defaults can only be primitives or empty arrays currently\");\n                    }\n                    fields[key] = {\n                        default: Array.isArray(def) ? [] : def,\n                        optional: field.optional,\n                        validate: field.validate\n                    };\n                }\n            }\n        }\n        var visitor = opts.visitor || inherits.visitor || [];\n        var aliases = opts.aliases || inherits.aliases || [];\n        var builder = opts.builder || inherits.builder || opts.visitor || [];\n        for(var _iterator1 = _createForOfIteratorHelperLoose$g(Object.keys(opts)), _step1; !(_step1 = _iterator1()).done;){\n            var k = _step1.value;\n            if (validTypeOpts.indexOf(k) === -1) {\n                throw new Error('Unknown type option \"' + k + '\" on ' + type);\n            }\n        }\n        if (opts.deprecatedAlias) {\n            DEPRECATED_KEYS[opts.deprecatedAlias] = type;\n        }\n        for(var _iterator2 = _createForOfIteratorHelperLoose$g(visitor.concat(builder)), _step2; !(_step2 = _iterator2()).done;){\n            var key1 = _step2.value;\n            fields[key1] = fields[key1] || {};\n        }\n        for(var _iterator3 = _createForOfIteratorHelperLoose$g(Object.keys(fields)), _step3; !(_step3 = _iterator3()).done;){\n            var key2 = _step3.value;\n            var field1 = fields[key2];\n            if (field1.default !== undefined && builder.indexOf(key2) === -1) {\n                field1.optional = true;\n            }\n            if (field1.default === undefined) {\n                field1.default = null;\n            } else if (!field1.validate && field1.default != null) {\n                field1.validate = assertValueType(getType(field1.default));\n            }\n            for(var _iterator4 = _createForOfIteratorHelperLoose$g(Object.keys(field1)), _step4; !(_step4 = _iterator4()).done;){\n                var k1 = _step4.value;\n                if (validFieldKeys.indexOf(k1) === -1) {\n                    throw new Error('Unknown field key \"' + k1 + '\" on ' + type + \".\" + key2);\n                }\n            }\n        }\n        VISITOR_KEYS[type] = opts.visitor = visitor;\n        BUILDER_KEYS[type] = opts.builder = builder;\n        NODE_FIELDS[type] = opts.fields = fields;\n        ALIAS_KEYS[type] = opts.aliases = aliases;\n        aliases.forEach(function(alias) {\n            FLIPPED_ALIAS_KEYS[alias] = FLIPPED_ALIAS_KEYS[alias] || [];\n            FLIPPED_ALIAS_KEYS[alias].push(type);\n        });\n        if (opts.validate) {\n            NODE_PARENT_VALIDATIONS[type] = opts.validate;\n        }\n        store[type] = opts;\n    };\n    if (hasRequiredUtils) return utils;\n    hasRequiredUtils = 1;\n    Object.defineProperty(utils, \"__esModule\", {\n        value: true\n    });\n    utils.validate = validate;\n    utils.typeIs = typeIs;\n    utils.validateType = validateType;\n    utils.validateOptional = validateOptional;\n    utils.validateOptionalType = validateOptionalType;\n    utils.arrayOf = arrayOf;\n    utils.arrayOfType = arrayOfType;\n    utils.validateArrayOfType = validateArrayOfType;\n    utils.assertEach = assertEach;\n    utils.assertOneOf = assertOneOf;\n    utils.assertNodeType = assertNodeType;\n    utils.assertNodeOrValueType = assertNodeOrValueType;\n    utils.assertValueType = assertValueType;\n    utils.assertShape = assertShape;\n    utils.assertOptionalChainStart = assertOptionalChainStart;\n    utils.chain = chain;\n    utils.default = defineType;\n    utils.NODE_PARENT_VALIDATIONS = utils.DEPRECATED_KEYS = utils.BUILDER_KEYS = utils.NODE_FIELDS = utils.FLIPPED_ALIAS_KEYS = utils.ALIAS_KEYS = utils.VISITOR_KEYS = void 0;\n    var _is = requireIs();\n    var _validate = requireValidate();\n    var VISITOR_KEYS = {};\n    utils.VISITOR_KEYS = VISITOR_KEYS;\n    var ALIAS_KEYS = {};\n    utils.ALIAS_KEYS = ALIAS_KEYS;\n    var FLIPPED_ALIAS_KEYS = {};\n    utils.FLIPPED_ALIAS_KEYS = FLIPPED_ALIAS_KEYS;\n    var NODE_FIELDS = {};\n    utils.NODE_FIELDS = NODE_FIELDS;\n    var BUILDER_KEYS = {};\n    utils.BUILDER_KEYS = BUILDER_KEYS;\n    var DEPRECATED_KEYS = {};\n    utils.DEPRECATED_KEYS = DEPRECATED_KEYS;\n    var NODE_PARENT_VALIDATIONS = {};\n    utils.NODE_PARENT_VALIDATIONS = NODE_PARENT_VALIDATIONS;\n    var validTypeOpts = [\n        \"aliases\",\n        \"builder\",\n        \"deprecatedAlias\",\n        \"fields\",\n        \"inherits\",\n        \"visitor\",\n        \"validate\"\n    ];\n    var validFieldKeys = [\n        \"default\",\n        \"optional\",\n        \"validate\"\n    ];\n    var store = {};\n    return utils;\n}\n\nfunction _arrayLikeToArray$2(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n    return arr2;\n}\nfunction _arrayWithoutHoles$2(arr) {\n    if (Array.isArray(arr)) return _arrayLikeToArray$2(arr);\n}\nfunction _iterableToArray$2(iter) {\n    if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\nfunction _nonIterableSpread$2() {\n    throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _toConsumableArray$2(arr) {\n    return _arrayWithoutHoles$2(arr) || _iterableToArray$2(arr) || _unsupportedIterableToArray$2(arr) || _nonIterableSpread$2();\n}\nfunction _unsupportedIterableToArray$2(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray$2(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(n);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$2(o, minLen);\n}\nvar hasRequiredCore;\nfunction requireCore() {\n    if (hasRequiredCore) return core;\n    hasRequiredCore = 1;\n    Object.defineProperty(core, \"__esModule\", {\n        value: true\n    });\n    core.classMethodOrDeclareMethodCommon = core.classMethodOrPropertyCommon = core.patternLikeCommon = core.functionDeclarationCommon = core.functionTypeAnnotationCommon = core.functionCommon = void 0;\n    var _is = requireIs();\n    var _isValidIdentifier = isValidIdentifier$1;\n    var _helperValidatorIdentifier = lib;\n    var _constants = constants;\n    var _utils = requireUtils();\n    (0, _utils.default)(\"ArrayExpression\", {\n        fields: {\n            elements: {\n                validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeOrValueType)(\"null\", \"Expression\", \"SpreadElement\"))),\n                default: !process.env.BABEL_TYPES_8_BREAKING ? [] : undefined\n            }\n        },\n        visitor: [\n            \"elements\"\n        ],\n        aliases: [\n            \"Expression\"\n        ]\n    });\n    (0, _utils.default)(\"AssignmentExpression\", {\n        fields: {\n            operator: {\n                validate: function() {\n                    if (!process.env.BABEL_TYPES_8_BREAKING) {\n                        return (0, _utils.assertValueType)(\"string\");\n                    }\n                    var identifier = (_utils.assertOneOf).apply(this, _constants.ASSIGNMENT_OPERATORS);\n                    var pattern = (0, _utils.assertOneOf)(\"=\");\n                    return function(node, key, val) {\n                        var validator = (0, _is.default)(\"Pattern\", node.left) ? pattern : identifier;\n                        validator(node, key, val);\n                    };\n                }()\n            },\n            left: {\n                validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)(\"LVal\") : (0, _utils.assertNodeType)(\"Identifier\", \"MemberExpression\", \"ArrayPattern\", \"ObjectPattern\")\n            },\n            right: {\n                validate: (0, _utils.assertNodeType)(\"Expression\")\n            }\n        },\n        builder: [\n            \"operator\",\n            \"left\",\n            \"right\"\n        ],\n        visitor: [\n            \"left\",\n            \"right\"\n        ],\n        aliases: [\n            \"Expression\"\n        ]\n    });\n    (0, _utils.default)(\"BinaryExpression\", {\n        builder: [\n            \"operator\",\n            \"left\",\n            \"right\"\n        ],\n        fields: {\n            operator: {\n                validate: (_utils.assertOneOf).apply(this, _constants.BINARY_OPERATORS)\n            },\n            left: {\n                validate: function() {\n                    var expression = (0, _utils.assertNodeType)(\"Expression\");\n                    var inOp = (0, _utils.assertNodeType)(\"Expression\", \"PrivateName\");\n                    var validator = function validator(node, key, val) {\n                        var validator = node.operator === \"in\" ? inOp : expression;\n                        validator(node, key, val);\n                    };\n                    validator.oneOfNodeTypes = [\n                        \"Expression\",\n                        \"PrivateName\"\n                    ];\n                    return validator;\n                }()\n            },\n            right: {\n                validate: (0, _utils.assertNodeType)(\"Expression\")\n            }\n        },\n        visitor: [\n            \"left\",\n            \"right\"\n        ],\n        aliases: [\n            \"Binary\",\n            \"Expression\"\n        ]\n    });\n    (0, _utils.default)(\"InterpreterDirective\", {\n        builder: [\n            \"value\"\n        ],\n        fields: {\n            value: {\n                validate: (0, _utils.assertValueType)(\"string\")\n            }\n        }\n    });\n    (0, _utils.default)(\"Directive\", {\n        visitor: [\n            \"value\"\n        ],\n        fields: {\n            value: {\n                validate: (0, _utils.assertNodeType)(\"DirectiveLiteral\")\n            }\n        }\n    });\n    (0, _utils.default)(\"DirectiveLiteral\", {\n        builder: [\n            \"value\"\n        ],\n        fields: {\n            value: {\n                validate: (0, _utils.assertValueType)(\"string\")\n            }\n        }\n    });\n    (0, _utils.default)(\"BlockStatement\", {\n        builder: [\n            \"body\",\n            \"directives\"\n        ],\n        visitor: [\n            \"directives\",\n            \"body\"\n        ],\n        fields: {\n            directives: {\n                validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Directive\"))),\n                default: []\n            },\n            body: {\n                validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Statement\")))\n            }\n        },\n        aliases: [\n            \"Scopable\",\n            \"BlockParent\",\n            \"Block\",\n            \"Statement\"\n        ]\n    });\n    (0, _utils.default)(\"BreakStatement\", {\n        visitor: [\n            \"label\"\n        ],\n        fields: {\n            label: {\n                validate: (0, _utils.assertNodeType)(\"Identifier\"),\n                optional: true\n            }\n        },\n        aliases: [\n            \"Statement\",\n            \"Terminatorless\",\n            \"CompletionStatement\"\n        ]\n    });\n    (0, _utils.default)(\"CallExpression\", {\n        visitor: [\n            \"callee\",\n            \"arguments\",\n            \"typeParameters\",\n            \"typeArguments\"\n        ],\n        builder: [\n            \"callee\",\n            \"arguments\"\n        ],\n        aliases: [\n            \"Expression\"\n        ],\n        fields: Object.assign({\n            callee: {\n                validate: (0, _utils.assertNodeType)(\"Expression\", \"V8IntrinsicIdentifier\")\n            },\n            arguments: {\n                validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Expression\", \"SpreadElement\", \"JSXNamespacedName\", \"ArgumentPlaceholder\")))\n            }\n        }, !process.env.BABEL_TYPES_8_BREAKING ? {\n            optional: {\n                validate: (0, _utils.assertOneOf)(true, false),\n                optional: true\n            }\n        } : {}, {\n            typeArguments: {\n                validate: (0, _utils.assertNodeType)(\"TypeParameterInstantiation\"),\n                optional: true\n            },\n            typeParameters: {\n                validate: (0, _utils.assertNodeType)(\"TSTypeParameterInstantiation\"),\n                optional: true\n            }\n        })\n    });\n    (0, _utils.default)(\"CatchClause\", {\n        visitor: [\n            \"param\",\n            \"body\"\n        ],\n        fields: {\n            param: {\n                validate: (0, _utils.assertNodeType)(\"Identifier\", \"ArrayPattern\", \"ObjectPattern\"),\n                optional: true\n            },\n            body: {\n                validate: (0, _utils.assertNodeType)(\"BlockStatement\")\n            }\n        },\n        aliases: [\n            \"Scopable\",\n            \"BlockParent\"\n        ]\n    });\n    (0, _utils.default)(\"ConditionalExpression\", {\n        visitor: [\n            \"test\",\n            \"consequent\",\n            \"alternate\"\n        ],\n        fields: {\n            test: {\n                validate: (0, _utils.assertNodeType)(\"Expression\")\n            },\n            consequent: {\n                validate: (0, _utils.assertNodeType)(\"Expression\")\n            },\n            alternate: {\n                validate: (0, _utils.assertNodeType)(\"Expression\")\n            }\n        },\n        aliases: [\n            \"Expression\",\n            \"Conditional\"\n        ]\n    });\n    (0, _utils.default)(\"ContinueStatement\", {\n        visitor: [\n            \"label\"\n        ],\n        fields: {\n            label: {\n                validate: (0, _utils.assertNodeType)(\"Identifier\"),\n                optional: true\n            }\n        },\n        aliases: [\n            \"Statement\",\n            \"Terminatorless\",\n            \"CompletionStatement\"\n        ]\n    });\n    (0, _utils.default)(\"DebuggerStatement\", {\n        aliases: [\n            \"Statement\"\n        ]\n    });\n    (0, _utils.default)(\"DoWhileStatement\", {\n        visitor: [\n            \"test\",\n            \"body\"\n        ],\n        fields: {\n            test: {\n                validate: (0, _utils.assertNodeType)(\"Expression\")\n            },\n            body: {\n                validate: (0, _utils.assertNodeType)(\"Statement\")\n            }\n        },\n        aliases: [\n            \"Statement\",\n            \"BlockParent\",\n            \"Loop\",\n            \"While\",\n            \"Scopable\"\n        ]\n    });\n    (0, _utils.default)(\"EmptyStatement\", {\n        aliases: [\n            \"Statement\"\n        ]\n    });\n    (0, _utils.default)(\"ExpressionStatement\", {\n        visitor: [\n            \"expression\"\n        ],\n        fields: {\n            expression: {\n                validate: (0, _utils.assertNodeType)(\"Expression\")\n            }\n        },\n        aliases: [\n            \"Statement\",\n            \"ExpressionWrapper\"\n        ]\n    });\n    (0, _utils.default)(\"File\", {\n        builder: [\n            \"program\",\n            \"comments\",\n            \"tokens\"\n        ],\n        visitor: [\n            \"program\"\n        ],\n        fields: {\n            program: {\n                validate: (0, _utils.assertNodeType)(\"Program\")\n            },\n            comments: {\n                validate: !process.env.BABEL_TYPES_8_BREAKING ? Object.assign(function() {}, {\n                    each: {\n                        oneOfNodeTypes: [\n                            \"CommentBlock\",\n                            \"CommentLine\"\n                        ]\n                    }\n                }) : (0, _utils.assertEach)((0, _utils.assertNodeType)(\"CommentBlock\", \"CommentLine\")),\n                optional: true\n            },\n            tokens: {\n                validate: (0, _utils.assertEach)(Object.assign(function() {}, {\n                    type: \"any\"\n                })),\n                optional: true\n            }\n        }\n    });\n    (0, _utils.default)(\"ForInStatement\", {\n        visitor: [\n            \"left\",\n            \"right\",\n            \"body\"\n        ],\n        aliases: [\n            \"Scopable\",\n            \"Statement\",\n            \"For\",\n            \"BlockParent\",\n            \"Loop\",\n            \"ForXStatement\"\n        ],\n        fields: {\n            left: {\n                validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)(\"VariableDeclaration\", \"LVal\") : (0, _utils.assertNodeType)(\"VariableDeclaration\", \"Identifier\", \"MemberExpression\", \"ArrayPattern\", \"ObjectPattern\")\n            },\n            right: {\n                validate: (0, _utils.assertNodeType)(\"Expression\")\n            },\n            body: {\n                validate: (0, _utils.assertNodeType)(\"Statement\")\n            }\n        }\n    });\n    (0, _utils.default)(\"ForStatement\", {\n        visitor: [\n            \"init\",\n            \"test\",\n            \"update\",\n            \"body\"\n        ],\n        aliases: [\n            \"Scopable\",\n            \"Statement\",\n            \"For\",\n            \"BlockParent\",\n            \"Loop\"\n        ],\n        fields: {\n            init: {\n                validate: (0, _utils.assertNodeType)(\"VariableDeclaration\", \"Expression\"),\n                optional: true\n            },\n            test: {\n                validate: (0, _utils.assertNodeType)(\"Expression\"),\n                optional: true\n            },\n            update: {\n                validate: (0, _utils.assertNodeType)(\"Expression\"),\n                optional: true\n            },\n            body: {\n                validate: (0, _utils.assertNodeType)(\"Statement\")\n            }\n        }\n    });\n    var functionCommon = {\n        params: {\n            validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Identifier\", \"Pattern\", \"RestElement\")))\n        },\n        generator: {\n            default: false\n        },\n        async: {\n            default: false\n        }\n    };\n    core.functionCommon = functionCommon;\n    var functionTypeAnnotationCommon = {\n        returnType: {\n            validate: (0, _utils.assertNodeType)(\"TypeAnnotation\", \"TSTypeAnnotation\", \"Noop\"),\n            optional: true\n        },\n        typeParameters: {\n            validate: (0, _utils.assertNodeType)(\"TypeParameterDeclaration\", \"TSTypeParameterDeclaration\", \"Noop\"),\n            optional: true\n        }\n    };\n    core.functionTypeAnnotationCommon = functionTypeAnnotationCommon;\n    var functionDeclarationCommon = Object.assign({}, functionCommon, {\n        declare: {\n            validate: (0, _utils.assertValueType)(\"boolean\"),\n            optional: true\n        },\n        id: {\n            validate: (0, _utils.assertNodeType)(\"Identifier\"),\n            optional: true\n        }\n    });\n    core.functionDeclarationCommon = functionDeclarationCommon;\n    (0, _utils.default)(\"FunctionDeclaration\", {\n        builder: [\n            \"id\",\n            \"params\",\n            \"body\",\n            \"generator\",\n            \"async\"\n        ],\n        visitor: [\n            \"id\",\n            \"params\",\n            \"body\",\n            \"returnType\",\n            \"typeParameters\"\n        ],\n        fields: Object.assign({}, functionDeclarationCommon, functionTypeAnnotationCommon, {\n            body: {\n                validate: (0, _utils.assertNodeType)(\"BlockStatement\")\n            }\n        }),\n        aliases: [\n            \"Scopable\",\n            \"Function\",\n            \"BlockParent\",\n            \"FunctionParent\",\n            \"Statement\",\n            \"Pureish\",\n            \"Declaration\"\n        ],\n        validate: function() {\n            if (!process.env.BABEL_TYPES_8_BREAKING) return function() {};\n            var identifier = (0, _utils.assertNodeType)(\"Identifier\");\n            return function(parent, key, node) {\n                if (!(0, _is.default)(\"ExportDefaultDeclaration\", parent)) {\n                    identifier(node, \"id\", node.id);\n                }\n            };\n        }()\n    });\n    (0, _utils.default)(\"FunctionExpression\", {\n        inherits: \"FunctionDeclaration\",\n        aliases: [\n            \"Scopable\",\n            \"Function\",\n            \"BlockParent\",\n            \"FunctionParent\",\n            \"Expression\",\n            \"Pureish\"\n        ],\n        fields: Object.assign({}, functionCommon, functionTypeAnnotationCommon, {\n            id: {\n                validate: (0, _utils.assertNodeType)(\"Identifier\"),\n                optional: true\n            },\n            body: {\n                validate: (0, _utils.assertNodeType)(\"BlockStatement\")\n            }\n        })\n    });\n    var patternLikeCommon = {\n        typeAnnotation: {\n            validate: (0, _utils.assertNodeType)(\"TypeAnnotation\", \"TSTypeAnnotation\", \"Noop\"),\n            optional: true\n        },\n        decorators: {\n            validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\")))\n        }\n    };\n    core.patternLikeCommon = patternLikeCommon;\n    (0, _utils.default)(\"Identifier\", {\n        builder: [\n            \"name\"\n        ],\n        visitor: [\n            \"typeAnnotation\",\n            \"decorators\"\n        ],\n        aliases: [\n            \"Expression\",\n            \"PatternLike\",\n            \"LVal\",\n            \"TSEntityName\"\n        ],\n        fields: Object.assign({}, patternLikeCommon, {\n            name: {\n                validate: (0, _utils.chain)((0, _utils.assertValueType)(\"string\"), Object.assign(function(node, key, val) {\n                    if (!process.env.BABEL_TYPES_8_BREAKING) return;\n                    if (!(0, _isValidIdentifier.default)(val, false)) {\n                        throw new TypeError('\"' + val + '\" is not a valid identifier name');\n                    }\n                }, {\n                    type: \"string\"\n                }))\n            },\n            optional: {\n                validate: (0, _utils.assertValueType)(\"boolean\"),\n                optional: true\n            }\n        }),\n        validate: function validate(parent, key, node) {\n            if (!process.env.BABEL_TYPES_8_BREAKING) return;\n            var match = /\\.(\\w+)$/.exec(key);\n            if (!match) return;\n            var parentKey = match[1];\n            var nonComp = {\n                computed: false\n            };\n            if (parentKey === \"property\") {\n                if ((0, _is.default)(\"MemberExpression\", parent, nonComp)) return;\n                if ((0, _is.default)(\"OptionalMemberExpression\", parent, nonComp)) return;\n            } else if (parentKey === \"key\") {\n                if ((0, _is.default)(\"Property\", parent, nonComp)) return;\n                if ((0, _is.default)(\"Method\", parent, nonComp)) return;\n            } else if (parentKey === \"exported\") {\n                if ((0, _is.default)(\"ExportSpecifier\", parent)) return;\n            } else if (parentKey === \"imported\") {\n                if ((0, _is.default)(\"ImportSpecifier\", parent, {\n                    imported: node\n                })) return;\n            } else if (parentKey === \"meta\") {\n                if ((0, _is.default)(\"MetaProperty\", parent, {\n                    meta: node\n                })) return;\n            }\n            if (((0, _helperValidatorIdentifier.isKeyword)(node.name) || (0, _helperValidatorIdentifier.isReservedWord)(node.name, false)) && node.name !== \"this\") {\n                throw new TypeError('\"' + node.name + '\" is not a valid identifier');\n            }\n        }\n    });\n    (0, _utils.default)(\"IfStatement\", {\n        visitor: [\n            \"test\",\n            \"consequent\",\n            \"alternate\"\n        ],\n        aliases: [\n            \"Statement\",\n            \"Conditional\"\n        ],\n        fields: {\n            test: {\n                validate: (0, _utils.assertNodeType)(\"Expression\")\n            },\n            consequent: {\n                validate: (0, _utils.assertNodeType)(\"Statement\")\n            },\n            alternate: {\n                optional: true,\n                validate: (0, _utils.assertNodeType)(\"Statement\")\n            }\n        }\n    });\n    (0, _utils.default)(\"LabeledStatement\", {\n        visitor: [\n            \"label\",\n            \"body\"\n        ],\n        aliases: [\n            \"Statement\"\n        ],\n        fields: {\n            label: {\n                validate: (0, _utils.assertNodeType)(\"Identifier\")\n            },\n            body: {\n                validate: (0, _utils.assertNodeType)(\"Statement\")\n            }\n        }\n    });\n    (0, _utils.default)(\"StringLiteral\", {\n        builder: [\n            \"value\"\n        ],\n        fields: {\n            value: {\n                validate: (0, _utils.assertValueType)(\"string\")\n            }\n        },\n        aliases: [\n            \"Expression\",\n            \"Pureish\",\n            \"Literal\",\n            \"Immutable\"\n        ]\n    });\n    (0, _utils.default)(\"NumericLiteral\", {\n        builder: [\n            \"value\"\n        ],\n        deprecatedAlias: \"NumberLiteral\",\n        fields: {\n            value: {\n                validate: (0, _utils.assertValueType)(\"number\")\n            }\n        },\n        aliases: [\n            \"Expression\",\n            \"Pureish\",\n            \"Literal\",\n            \"Immutable\"\n        ]\n    });\n    (0, _utils.default)(\"NullLiteral\", {\n        aliases: [\n            \"Expression\",\n            \"Pureish\",\n            \"Literal\",\n            \"Immutable\"\n        ]\n    });\n    (0, _utils.default)(\"BooleanLiteral\", {\n        builder: [\n            \"value\"\n        ],\n        fields: {\n            value: {\n                validate: (0, _utils.assertValueType)(\"boolean\")\n            }\n        },\n        aliases: [\n            \"Expression\",\n            \"Pureish\",\n            \"Literal\",\n            \"Immutable\"\n        ]\n    });\n    (0, _utils.default)(\"RegExpLiteral\", {\n        builder: [\n            \"pattern\",\n            \"flags\"\n        ],\n        deprecatedAlias: \"RegexLiteral\",\n        aliases: [\n            \"Expression\",\n            \"Pureish\",\n            \"Literal\"\n        ],\n        fields: {\n            pattern: {\n                validate: (0, _utils.assertValueType)(\"string\")\n            },\n            flags: {\n                validate: (0, _utils.chain)((0, _utils.assertValueType)(\"string\"), Object.assign(function(node, key, val) {\n                    if (!process.env.BABEL_TYPES_8_BREAKING) return;\n                    var invalid = /[^gimsuy]/.exec(val);\n                    if (invalid) {\n                        throw new TypeError('\"' + invalid[0] + '\" is not a valid RegExp flag');\n                    }\n                }, {\n                    type: \"string\"\n                })),\n                default: \"\"\n            }\n        }\n    });\n    (0, _utils.default)(\"LogicalExpression\", {\n        builder: [\n            \"operator\",\n            \"left\",\n            \"right\"\n        ],\n        visitor: [\n            \"left\",\n            \"right\"\n        ],\n        aliases: [\n            \"Binary\",\n            \"Expression\"\n        ],\n        fields: {\n            operator: {\n                validate: (_utils.assertOneOf).apply(this, _constants.LOGICAL_OPERATORS)\n            },\n            left: {\n                validate: (0, _utils.assertNodeType)(\"Expression\")\n            },\n            right: {\n                validate: (0, _utils.assertNodeType)(\"Expression\")\n            }\n        }\n    });\n    (0, _utils.default)(\"MemberExpression\", {\n        builder: [\n            \"object\",\n            \"property\",\n            \"computed\"\n        ].concat(_toConsumableArray$2(!process.env.BABEL_TYPES_8_BREAKING ? [\n            \"optional\"\n        ] : [])),\n        visitor: [\n            \"object\",\n            \"property\"\n        ],\n        aliases: [\n            \"Expression\",\n            \"LVal\"\n        ],\n        fields: Object.assign({\n            object: {\n                validate: (0, _utils.assertNodeType)(\"Expression\")\n            },\n            property: {\n                validate: function() {\n                    var normal = (0, _utils.assertNodeType)(\"Identifier\", \"PrivateName\");\n                    var computed = (0, _utils.assertNodeType)(\"Expression\");\n                    var validator = function validator(node, key, val) {\n                        var validator = node.computed ? computed : normal;\n                        validator(node, key, val);\n                    };\n                    validator.oneOfNodeTypes = [\n                        \"Expression\",\n                        \"Identifier\",\n                        \"PrivateName\"\n                    ];\n                    return validator;\n                }()\n            },\n            computed: {\n                default: false\n            }\n        }, !process.env.BABEL_TYPES_8_BREAKING ? {\n            optional: {\n                validate: (0, _utils.assertOneOf)(true, false),\n                optional: true\n            }\n        } : {})\n    });\n    (0, _utils.default)(\"NewExpression\", {\n        inherits: \"CallExpression\"\n    });\n    (0, _utils.default)(\"Program\", {\n        visitor: [\n            \"directives\",\n            \"body\"\n        ],\n        builder: [\n            \"body\",\n            \"directives\",\n            \"sourceType\",\n            \"interpreter\"\n        ],\n        fields: {\n            sourceFile: {\n                validate: (0, _utils.assertValueType)(\"string\")\n            },\n            sourceType: {\n                validate: (0, _utils.assertOneOf)(\"script\", \"module\"),\n                default: \"script\"\n            },\n            interpreter: {\n                validate: (0, _utils.assertNodeType)(\"InterpreterDirective\"),\n                default: null,\n                optional: true\n            },\n            directives: {\n                validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Directive\"))),\n                default: []\n            },\n            body: {\n                validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Statement\")))\n            }\n        },\n        aliases: [\n            \"Scopable\",\n            \"BlockParent\",\n            \"Block\"\n        ]\n    });\n    (0, _utils.default)(\"ObjectExpression\", {\n        visitor: [\n            \"properties\"\n        ],\n        aliases: [\n            \"Expression\"\n        ],\n        fields: {\n            properties: {\n                validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"ObjectMethod\", \"ObjectProperty\", \"SpreadElement\")))\n            }\n        }\n    });\n    (0, _utils.default)(\"ObjectMethod\", {\n        builder: [\n            \"kind\",\n            \"key\",\n            \"params\",\n            \"body\",\n            \"computed\",\n            \"generator\",\n            \"async\"\n        ],\n        fields: Object.assign({}, functionCommon, functionTypeAnnotationCommon, {\n            kind: Object.assign({\n                validate: (0, _utils.assertOneOf)(\"method\", \"get\", \"set\")\n            }, !process.env.BABEL_TYPES_8_BREAKING ? {\n                default: \"method\"\n            } : {}),\n            computed: {\n                default: false\n            },\n            key: {\n                validate: function() {\n                    var normal = (0, _utils.assertNodeType)(\"Identifier\", \"StringLiteral\", \"NumericLiteral\");\n                    var computed = (0, _utils.assertNodeType)(\"Expression\");\n                    var validator = function validator(node, key, val) {\n                        var validator = node.computed ? computed : normal;\n                        validator(node, key, val);\n                    };\n                    validator.oneOfNodeTypes = [\n                        \"Expression\",\n                        \"Identifier\",\n                        \"StringLiteral\",\n                        \"NumericLiteral\"\n                    ];\n                    return validator;\n                }()\n            },\n            decorators: {\n                validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n                optional: true\n            },\n            body: {\n                validate: (0, _utils.assertNodeType)(\"BlockStatement\")\n            }\n        }),\n        visitor: [\n            \"key\",\n            \"params\",\n            \"body\",\n            \"decorators\",\n            \"returnType\",\n            \"typeParameters\"\n        ],\n        aliases: [\n            \"UserWhitespacable\",\n            \"Function\",\n            \"Scopable\",\n            \"BlockParent\",\n            \"FunctionParent\",\n            \"Method\",\n            \"ObjectMember\"\n        ]\n    });\n    (0, _utils.default)(\"ObjectProperty\", {\n        builder: [\n            \"key\",\n            \"value\",\n            \"computed\",\n            \"shorthand\"\n        ].concat(_toConsumableArray$2(!process.env.BABEL_TYPES_8_BREAKING ? [\n            \"decorators\"\n        ] : [])),\n        fields: {\n            computed: {\n                default: false\n            },\n            key: {\n                validate: function() {\n                    var normal = (0, _utils.assertNodeType)(\"Identifier\", \"StringLiteral\", \"NumericLiteral\");\n                    var computed = (0, _utils.assertNodeType)(\"Expression\");\n                    var validator = function validator(node, key, val) {\n                        var validator = node.computed ? computed : normal;\n                        validator(node, key, val);\n                    };\n                    validator.oneOfNodeTypes = [\n                        \"Expression\",\n                        \"Identifier\",\n                        \"StringLiteral\",\n                        \"NumericLiteral\"\n                    ];\n                    return validator;\n                }()\n            },\n            value: {\n                validate: (0, _utils.assertNodeType)(\"Expression\", \"PatternLike\")\n            },\n            shorthand: {\n                validate: (0, _utils.chain)((0, _utils.assertValueType)(\"boolean\"), Object.assign(function(node, key, val) {\n                    if (!process.env.BABEL_TYPES_8_BREAKING) return;\n                    if (val && node.computed) {\n                        throw new TypeError(\"Property shorthand of ObjectProperty cannot be true if computed is true\");\n                    }\n                }, {\n                    type: \"boolean\"\n                }), function(node, key, val) {\n                    if (!process.env.BABEL_TYPES_8_BREAKING) return;\n                    if (val && !(0, _is.default)(\"Identifier\", node.key)) {\n                        throw new TypeError(\"Property shorthand of ObjectProperty cannot be true if key is not an Identifier\");\n                    }\n                }),\n                default: false\n            },\n            decorators: {\n                validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n                optional: true\n            }\n        },\n        visitor: [\n            \"key\",\n            \"value\",\n            \"decorators\"\n        ],\n        aliases: [\n            \"UserWhitespacable\",\n            \"Property\",\n            \"ObjectMember\"\n        ],\n        validate: function() {\n            var pattern = (0, _utils.assertNodeType)(\"Identifier\", \"Pattern\");\n            var expression = (0, _utils.assertNodeType)(\"Expression\");\n            return function(parent, key, node) {\n                if (!process.env.BABEL_TYPES_8_BREAKING) return;\n                var validator = (0, _is.default)(\"ObjectPattern\", parent) ? pattern : expression;\n                validator(node, \"value\", node.value);\n            };\n        }()\n    });\n    (0, _utils.default)(\"RestElement\", {\n        visitor: [\n            \"argument\",\n            \"typeAnnotation\"\n        ],\n        builder: [\n            \"argument\"\n        ],\n        aliases: [\n            \"LVal\",\n            \"PatternLike\"\n        ],\n        deprecatedAlias: \"RestProperty\",\n        fields: Object.assign({}, patternLikeCommon, {\n            argument: {\n                validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)(\"LVal\") : (0, _utils.assertNodeType)(\"Identifier\", \"Pattern\", \"MemberExpression\")\n            },\n            optional: {\n                validate: (0, _utils.assertValueType)(\"boolean\"),\n                optional: true\n            }\n        }),\n        validate: function validate(parent, key) {\n            if (!process.env.BABEL_TYPES_8_BREAKING) return;\n            var match = /(\\w+)\\[(\\d+)\\]/.exec(key);\n            if (!match) throw new Error(\"Internal Babel error: malformed key.\");\n            var listKey = match[1], index = match[2];\n            if (parent[listKey].length > index + 1) {\n                throw new TypeError(\"RestElement must be last element of \" + listKey);\n            }\n        }\n    });\n    (0, _utils.default)(\"ReturnStatement\", {\n        visitor: [\n            \"argument\"\n        ],\n        aliases: [\n            \"Statement\",\n            \"Terminatorless\",\n            \"CompletionStatement\"\n        ],\n        fields: {\n            argument: {\n                validate: (0, _utils.assertNodeType)(\"Expression\"),\n                optional: true\n            }\n        }\n    });\n    (0, _utils.default)(\"SequenceExpression\", {\n        visitor: [\n            \"expressions\"\n        ],\n        fields: {\n            expressions: {\n                validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Expression\")))\n            }\n        },\n        aliases: [\n            \"Expression\"\n        ]\n    });\n    (0, _utils.default)(\"ParenthesizedExpression\", {\n        visitor: [\n            \"expression\"\n        ],\n        aliases: [\n            \"Expression\",\n            \"ExpressionWrapper\"\n        ],\n        fields: {\n            expression: {\n                validate: (0, _utils.assertNodeType)(\"Expression\")\n            }\n        }\n    });\n    (0, _utils.default)(\"SwitchCase\", {\n        visitor: [\n            \"test\",\n            \"consequent\"\n        ],\n        fields: {\n            test: {\n                validate: (0, _utils.assertNodeType)(\"Expression\"),\n                optional: true\n            },\n            consequent: {\n                validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Statement\")))\n            }\n        }\n    });\n    (0, _utils.default)(\"SwitchStatement\", {\n        visitor: [\n            \"discriminant\",\n            \"cases\"\n        ],\n        aliases: [\n            \"Statement\",\n            \"BlockParent\",\n            \"Scopable\"\n        ],\n        fields: {\n            discriminant: {\n                validate: (0, _utils.assertNodeType)(\"Expression\")\n            },\n            cases: {\n                validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"SwitchCase\")))\n            }\n        }\n    });\n    (0, _utils.default)(\"ThisExpression\", {\n        aliases: [\n            \"Expression\"\n        ]\n    });\n    (0, _utils.default)(\"ThrowStatement\", {\n        visitor: [\n            \"argument\"\n        ],\n        aliases: [\n            \"Statement\",\n            \"Terminatorless\",\n            \"CompletionStatement\"\n        ],\n        fields: {\n            argument: {\n                validate: (0, _utils.assertNodeType)(\"Expression\")\n            }\n        }\n    });\n    (0, _utils.default)(\"TryStatement\", {\n        visitor: [\n            \"block\",\n            \"handler\",\n            \"finalizer\"\n        ],\n        aliases: [\n            \"Statement\"\n        ],\n        fields: {\n            block: {\n                validate: (0, _utils.chain)((0, _utils.assertNodeType)(\"BlockStatement\"), Object.assign(function(node) {\n                    if (!process.env.BABEL_TYPES_8_BREAKING) return;\n                    if (!node.handler && !node.finalizer) {\n                        throw new TypeError(\"TryStatement expects either a handler or finalizer, or both\");\n                    }\n                }, {\n                    oneOfNodeTypes: [\n                        \"BlockStatement\"\n                    ]\n                }))\n            },\n            handler: {\n                optional: true,\n                validate: (0, _utils.assertNodeType)(\"CatchClause\")\n            },\n            finalizer: {\n                optional: true,\n                validate: (0, _utils.assertNodeType)(\"BlockStatement\")\n            }\n        }\n    });\n    (0, _utils.default)(\"UnaryExpression\", {\n        builder: [\n            \"operator\",\n            \"argument\",\n            \"prefix\"\n        ],\n        fields: {\n            prefix: {\n                default: true\n            },\n            argument: {\n                validate: (0, _utils.assertNodeType)(\"Expression\")\n            },\n            operator: {\n                validate: (_utils.assertOneOf).apply(this, _constants.UNARY_OPERATORS)\n            }\n        },\n        visitor: [\n            \"argument\"\n        ],\n        aliases: [\n            \"UnaryLike\",\n            \"Expression\"\n        ]\n    });\n    (0, _utils.default)(\"UpdateExpression\", {\n        builder: [\n            \"operator\",\n            \"argument\",\n            \"prefix\"\n        ],\n        fields: {\n            prefix: {\n                default: false\n            },\n            argument: {\n                validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)(\"Expression\") : (0, _utils.assertNodeType)(\"Identifier\", \"MemberExpression\")\n            },\n            operator: {\n                validate: (_utils.assertOneOf).apply(this, _constants.UPDATE_OPERATORS)\n            }\n        },\n        visitor: [\n            \"argument\"\n        ],\n        aliases: [\n            \"Expression\"\n        ]\n    });\n    (0, _utils.default)(\"VariableDeclaration\", {\n        builder: [\n            \"kind\",\n            \"declarations\"\n        ],\n        visitor: [\n            \"declarations\"\n        ],\n        aliases: [\n            \"Statement\",\n            \"Declaration\"\n        ],\n        fields: {\n            declare: {\n                validate: (0, _utils.assertValueType)(\"boolean\"),\n                optional: true\n            },\n            kind: {\n                validate: (0, _utils.assertOneOf)(\"var\", \"let\", \"const\")\n            },\n            declarations: {\n                validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"VariableDeclarator\")))\n            }\n        },\n        validate: function validate(parent, key, node) {\n            if (!process.env.BABEL_TYPES_8_BREAKING) return;\n            if (!(0, _is.default)(\"ForXStatement\", parent, {\n                left: node\n            })) return;\n            if (node.declarations.length !== 1) {\n                throw new TypeError(\"Exactly one VariableDeclarator is required in the VariableDeclaration of a \" + parent.type);\n            }\n        }\n    });\n    (0, _utils.default)(\"VariableDeclarator\", {\n        visitor: [\n            \"id\",\n            \"init\"\n        ],\n        fields: {\n            id: {\n                validate: function() {\n                    if (!process.env.BABEL_TYPES_8_BREAKING) {\n                        return (0, _utils.assertNodeType)(\"LVal\");\n                    }\n                    var normal = (0, _utils.assertNodeType)(\"Identifier\", \"ArrayPattern\", \"ObjectPattern\");\n                    var without = (0, _utils.assertNodeType)(\"Identifier\");\n                    return function(node, key, val) {\n                        var validator = node.init ? normal : without;\n                        validator(node, key, val);\n                    };\n                }()\n            },\n            definite: {\n                optional: true,\n                validate: (0, _utils.assertValueType)(\"boolean\")\n            },\n            init: {\n                optional: true,\n                validate: (0, _utils.assertNodeType)(\"Expression\")\n            }\n        }\n    });\n    (0, _utils.default)(\"WhileStatement\", {\n        visitor: [\n            \"test\",\n            \"body\"\n        ],\n        aliases: [\n            \"Statement\",\n            \"BlockParent\",\n            \"Loop\",\n            \"While\",\n            \"Scopable\"\n        ],\n        fields: {\n            test: {\n                validate: (0, _utils.assertNodeType)(\"Expression\")\n            },\n            body: {\n                validate: (0, _utils.assertNodeType)(\"Statement\")\n            }\n        }\n    });\n    (0, _utils.default)(\"WithStatement\", {\n        visitor: [\n            \"object\",\n            \"body\"\n        ],\n        aliases: [\n            \"Statement\"\n        ],\n        fields: {\n            object: {\n                validate: (0, _utils.assertNodeType)(\"Expression\")\n            },\n            body: {\n                validate: (0, _utils.assertNodeType)(\"Statement\")\n            }\n        }\n    });\n    (0, _utils.default)(\"AssignmentPattern\", {\n        visitor: [\n            \"left\",\n            \"right\",\n            \"decorators\"\n        ],\n        builder: [\n            \"left\",\n            \"right\"\n        ],\n        aliases: [\n            \"Pattern\",\n            \"PatternLike\",\n            \"LVal\"\n        ],\n        fields: Object.assign({}, patternLikeCommon, {\n            left: {\n                validate: (0, _utils.assertNodeType)(\"Identifier\", \"ObjectPattern\", \"ArrayPattern\", \"MemberExpression\")\n            },\n            right: {\n                validate: (0, _utils.assertNodeType)(\"Expression\")\n            },\n            decorators: {\n                validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n                optional: true\n            }\n        })\n    });\n    (0, _utils.default)(\"ArrayPattern\", {\n        visitor: [\n            \"elements\",\n            \"typeAnnotation\"\n        ],\n        builder: [\n            \"elements\"\n        ],\n        aliases: [\n            \"Pattern\",\n            \"PatternLike\",\n            \"LVal\"\n        ],\n        fields: Object.assign({}, patternLikeCommon, {\n            elements: {\n                validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeOrValueType)(\"null\", \"PatternLike\")))\n            },\n            decorators: {\n                validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n                optional: true\n            },\n            optional: {\n                validate: (0, _utils.assertValueType)(\"boolean\"),\n                optional: true\n            }\n        })\n    });\n    (0, _utils.default)(\"ArrowFunctionExpression\", {\n        builder: [\n            \"params\",\n            \"body\",\n            \"async\"\n        ],\n        visitor: [\n            \"params\",\n            \"body\",\n            \"returnType\",\n            \"typeParameters\"\n        ],\n        aliases: [\n            \"Scopable\",\n            \"Function\",\n            \"BlockParent\",\n            \"FunctionParent\",\n            \"Expression\",\n            \"Pureish\"\n        ],\n        fields: Object.assign({}, functionCommon, functionTypeAnnotationCommon, {\n            expression: {\n                validate: (0, _utils.assertValueType)(\"boolean\")\n            },\n            body: {\n                validate: (0, _utils.assertNodeType)(\"BlockStatement\", \"Expression\")\n            }\n        })\n    });\n    (0, _utils.default)(\"ClassBody\", {\n        visitor: [\n            \"body\"\n        ],\n        fields: {\n            body: {\n                validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"ClassMethod\", \"ClassPrivateMethod\", \"ClassProperty\", \"ClassPrivateProperty\", \"TSDeclareMethod\", \"TSIndexSignature\")))\n            }\n        }\n    });\n    (0, _utils.default)(\"ClassExpression\", {\n        builder: [\n            \"id\",\n            \"superClass\",\n            \"body\",\n            \"decorators\"\n        ],\n        visitor: [\n            \"id\",\n            \"body\",\n            \"superClass\",\n            \"mixins\",\n            \"typeParameters\",\n            \"superTypeParameters\",\n            \"implements\",\n            \"decorators\"\n        ],\n        aliases: [\n            \"Scopable\",\n            \"Class\",\n            \"Expression\"\n        ],\n        fields: {\n            id: {\n                validate: (0, _utils.assertNodeType)(\"Identifier\"),\n                optional: true\n            },\n            typeParameters: {\n                validate: (0, _utils.assertNodeType)(\"TypeParameterDeclaration\", \"TSTypeParameterDeclaration\", \"Noop\"),\n                optional: true\n            },\n            body: {\n                validate: (0, _utils.assertNodeType)(\"ClassBody\")\n            },\n            superClass: {\n                optional: true,\n                validate: (0, _utils.assertNodeType)(\"Expression\")\n            },\n            superTypeParameters: {\n                validate: (0, _utils.assertNodeType)(\"TypeParameterInstantiation\", \"TSTypeParameterInstantiation\"),\n                optional: true\n            },\n            implements: {\n                validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"TSExpressionWithTypeArguments\", \"ClassImplements\"))),\n                optional: true\n            },\n            decorators: {\n                validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n                optional: true\n            },\n            mixins: {\n                validate: (0, _utils.assertNodeType)(\"InterfaceExtends\"),\n                optional: true\n            }\n        }\n    });\n    (0, _utils.default)(\"ClassDeclaration\", {\n        inherits: \"ClassExpression\",\n        aliases: [\n            \"Scopable\",\n            \"Class\",\n            \"Statement\",\n            \"Declaration\"\n        ],\n        fields: {\n            id: {\n                validate: (0, _utils.assertNodeType)(\"Identifier\")\n            },\n            typeParameters: {\n                validate: (0, _utils.assertNodeType)(\"TypeParameterDeclaration\", \"TSTypeParameterDeclaration\", \"Noop\"),\n                optional: true\n            },\n            body: {\n                validate: (0, _utils.assertNodeType)(\"ClassBody\")\n            },\n            superClass: {\n                optional: true,\n                validate: (0, _utils.assertNodeType)(\"Expression\")\n            },\n            superTypeParameters: {\n                validate: (0, _utils.assertNodeType)(\"TypeParameterInstantiation\", \"TSTypeParameterInstantiation\"),\n                optional: true\n            },\n            implements: {\n                validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"TSExpressionWithTypeArguments\", \"ClassImplements\"))),\n                optional: true\n            },\n            decorators: {\n                validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n                optional: true\n            },\n            mixins: {\n                validate: (0, _utils.assertNodeType)(\"InterfaceExtends\"),\n                optional: true\n            },\n            declare: {\n                validate: (0, _utils.assertValueType)(\"boolean\"),\n                optional: true\n            },\n            abstract: {\n                validate: (0, _utils.assertValueType)(\"boolean\"),\n                optional: true\n            }\n        },\n        validate: function() {\n            var identifier = (0, _utils.assertNodeType)(\"Identifier\");\n            return function(parent, key, node) {\n                if (!process.env.BABEL_TYPES_8_BREAKING) return;\n                if (!(0, _is.default)(\"ExportDefaultDeclaration\", parent)) {\n                    identifier(node, \"id\", node.id);\n                }\n            };\n        }()\n    });\n    (0, _utils.default)(\"ExportAllDeclaration\", {\n        visitor: [\n            \"source\"\n        ],\n        aliases: [\n            \"Statement\",\n            \"Declaration\",\n            \"ModuleDeclaration\",\n            \"ExportDeclaration\"\n        ],\n        fields: {\n            source: {\n                validate: (0, _utils.assertNodeType)(\"StringLiteral\")\n            },\n            exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)(\"type\", \"value\")),\n            assertions: {\n                optional: true,\n                validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"ImportAttribute\")))\n            }\n        }\n    });\n    (0, _utils.default)(\"ExportDefaultDeclaration\", {\n        visitor: [\n            \"declaration\"\n        ],\n        aliases: [\n            \"Statement\",\n            \"Declaration\",\n            \"ModuleDeclaration\",\n            \"ExportDeclaration\"\n        ],\n        fields: {\n            declaration: {\n                validate: (0, _utils.assertNodeType)(\"FunctionDeclaration\", \"TSDeclareFunction\", \"ClassDeclaration\", \"Expression\")\n            },\n            exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)(\"value\"))\n        }\n    });\n    (0, _utils.default)(\"ExportNamedDeclaration\", {\n        visitor: [\n            \"declaration\",\n            \"specifiers\",\n            \"source\"\n        ],\n        aliases: [\n            \"Statement\",\n            \"Declaration\",\n            \"ModuleDeclaration\",\n            \"ExportDeclaration\"\n        ],\n        fields: {\n            declaration: {\n                optional: true,\n                validate: (0, _utils.chain)((0, _utils.assertNodeType)(\"Declaration\"), Object.assign(function(node, key, val) {\n                    if (!process.env.BABEL_TYPES_8_BREAKING) return;\n                    if (val && node.specifiers.length) {\n                        throw new TypeError(\"Only declaration or specifiers is allowed on ExportNamedDeclaration\");\n                    }\n                }, {\n                    oneOfNodeTypes: [\n                        \"Declaration\"\n                    ]\n                }), function(node, key, val) {\n                    if (!process.env.BABEL_TYPES_8_BREAKING) return;\n                    if (val && node.source) {\n                        throw new TypeError(\"Cannot export a declaration from a source\");\n                    }\n                })\n            },\n            assertions: {\n                optional: true,\n                validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"ImportAttribute\")))\n            },\n            specifiers: {\n                default: [],\n                validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)(function() {\n                    var sourced = (0, _utils.assertNodeType)(\"ExportSpecifier\", \"ExportDefaultSpecifier\", \"ExportNamespaceSpecifier\");\n                    var sourceless = (0, _utils.assertNodeType)(\"ExportSpecifier\");\n                    if (!process.env.BABEL_TYPES_8_BREAKING) return sourced;\n                    return function(node, key, val) {\n                        var validator = node.source ? sourced : sourceless;\n                        validator(node, key, val);\n                    };\n                }()))\n            },\n            source: {\n                validate: (0, _utils.assertNodeType)(\"StringLiteral\"),\n                optional: true\n            },\n            exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)(\"type\", \"value\"))\n        }\n    });\n    (0, _utils.default)(\"ExportSpecifier\", {\n        visitor: [\n            \"local\",\n            \"exported\"\n        ],\n        aliases: [\n            \"ModuleSpecifier\"\n        ],\n        fields: {\n            local: {\n                validate: (0, _utils.assertNodeType)(\"Identifier\")\n            },\n            exported: {\n                validate: (0, _utils.assertNodeType)(\"Identifier\", \"StringLiteral\")\n            }\n        }\n    });\n    (0, _utils.default)(\"ForOfStatement\", {\n        visitor: [\n            \"left\",\n            \"right\",\n            \"body\"\n        ],\n        builder: [\n            \"left\",\n            \"right\",\n            \"body\",\n            \"await\"\n        ],\n        aliases: [\n            \"Scopable\",\n            \"Statement\",\n            \"For\",\n            \"BlockParent\",\n            \"Loop\",\n            \"ForXStatement\"\n        ],\n        fields: {\n            left: {\n                validate: function() {\n                    if (!process.env.BABEL_TYPES_8_BREAKING) {\n                        return (0, _utils.assertNodeType)(\"VariableDeclaration\", \"LVal\");\n                    }\n                    var declaration = (0, _utils.assertNodeType)(\"VariableDeclaration\");\n                    var lval = (0, _utils.assertNodeType)(\"Identifier\", \"MemberExpression\", \"ArrayPattern\", \"ObjectPattern\");\n                    return function(node, key, val) {\n                        if ((0, _is.default)(\"VariableDeclaration\", val)) {\n                            declaration(node, key, val);\n                        } else {\n                            lval(node, key, val);\n                        }\n                    };\n                }()\n            },\n            right: {\n                validate: (0, _utils.assertNodeType)(\"Expression\")\n            },\n            body: {\n                validate: (0, _utils.assertNodeType)(\"Statement\")\n            },\n            await: {\n                default: false\n            }\n        }\n    });\n    (0, _utils.default)(\"ImportDeclaration\", {\n        visitor: [\n            \"specifiers\",\n            \"source\"\n        ],\n        aliases: [\n            \"Statement\",\n            \"Declaration\",\n            \"ModuleDeclaration\"\n        ],\n        fields: {\n            assertions: {\n                optional: true,\n                validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"ImportAttribute\")))\n            },\n            specifiers: {\n                validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"ImportSpecifier\", \"ImportDefaultSpecifier\", \"ImportNamespaceSpecifier\")))\n            },\n            source: {\n                validate: (0, _utils.assertNodeType)(\"StringLiteral\")\n            },\n            importKind: {\n                validate: (0, _utils.assertOneOf)(\"type\", \"typeof\", \"value\"),\n                optional: true\n            }\n        }\n    });\n    (0, _utils.default)(\"ImportDefaultSpecifier\", {\n        visitor: [\n            \"local\"\n        ],\n        aliases: [\n            \"ModuleSpecifier\"\n        ],\n        fields: {\n            local: {\n                validate: (0, _utils.assertNodeType)(\"Identifier\")\n            }\n        }\n    });\n    (0, _utils.default)(\"ImportNamespaceSpecifier\", {\n        visitor: [\n            \"local\"\n        ],\n        aliases: [\n            \"ModuleSpecifier\"\n        ],\n        fields: {\n            local: {\n                validate: (0, _utils.assertNodeType)(\"Identifier\")\n            }\n        }\n    });\n    (0, _utils.default)(\"ImportSpecifier\", {\n        visitor: [\n            \"local\",\n            \"imported\"\n        ],\n        aliases: [\n            \"ModuleSpecifier\"\n        ],\n        fields: {\n            local: {\n                validate: (0, _utils.assertNodeType)(\"Identifier\")\n            },\n            imported: {\n                validate: (0, _utils.assertNodeType)(\"Identifier\", \"StringLiteral\")\n            },\n            importKind: {\n                validate: (0, _utils.assertOneOf)(\"type\", \"typeof\"),\n                optional: true\n            }\n        }\n    });\n    (0, _utils.default)(\"MetaProperty\", {\n        visitor: [\n            \"meta\",\n            \"property\"\n        ],\n        aliases: [\n            \"Expression\"\n        ],\n        fields: {\n            meta: {\n                validate: (0, _utils.chain)((0, _utils.assertNodeType)(\"Identifier\"), Object.assign(function(node, key, val) {\n                    if (!process.env.BABEL_TYPES_8_BREAKING) return;\n                    var property;\n                    switch(val.name){\n                        case \"function\":\n                            property = \"sent\";\n                            break;\n                        case \"new\":\n                            property = \"target\";\n                            break;\n                        case \"import\":\n                            property = \"meta\";\n                            break;\n                    }\n                    if (!(0, _is.default)(\"Identifier\", node.property, {\n                        name: property\n                    })) {\n                        throw new TypeError(\"Unrecognised MetaProperty\");\n                    }\n                }, {\n                    oneOfNodeTypes: [\n                        \"Identifier\"\n                    ]\n                }))\n            },\n            property: {\n                validate: (0, _utils.assertNodeType)(\"Identifier\")\n            }\n        }\n    });\n    var classMethodOrPropertyCommon = {\n        abstract: {\n            validate: (0, _utils.assertValueType)(\"boolean\"),\n            optional: true\n        },\n        accessibility: {\n            validate: (0, _utils.assertOneOf)(\"public\", \"private\", \"protected\"),\n            optional: true\n        },\n        static: {\n            default: false\n        },\n        override: {\n            default: false\n        },\n        computed: {\n            default: false\n        },\n        optional: {\n            validate: (0, _utils.assertValueType)(\"boolean\"),\n            optional: true\n        },\n        key: {\n            validate: (0, _utils.chain)(function() {\n                var normal = (0, _utils.assertNodeType)(\"Identifier\", \"StringLiteral\", \"NumericLiteral\");\n                var computed = (0, _utils.assertNodeType)(\"Expression\");\n                return function(node, key, val) {\n                    var validator = node.computed ? computed : normal;\n                    validator(node, key, val);\n                };\n            }(), (0, _utils.assertNodeType)(\"Identifier\", \"StringLiteral\", \"NumericLiteral\", \"Expression\"))\n        }\n    };\n    core.classMethodOrPropertyCommon = classMethodOrPropertyCommon;\n    var classMethodOrDeclareMethodCommon = Object.assign({}, functionCommon, classMethodOrPropertyCommon, {\n        params: {\n            validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Identifier\", \"Pattern\", \"RestElement\", \"TSParameterProperty\")))\n        },\n        kind: {\n            validate: (0, _utils.assertOneOf)(\"get\", \"set\", \"method\", \"constructor\"),\n            default: \"method\"\n        },\n        access: {\n            validate: (0, _utils.chain)((0, _utils.assertValueType)(\"string\"), (0, _utils.assertOneOf)(\"public\", \"private\", \"protected\")),\n            optional: true\n        },\n        decorators: {\n            validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n            optional: true\n        }\n    });\n    core.classMethodOrDeclareMethodCommon = classMethodOrDeclareMethodCommon;\n    (0, _utils.default)(\"ClassMethod\", {\n        aliases: [\n            \"Function\",\n            \"Scopable\",\n            \"BlockParent\",\n            \"FunctionParent\",\n            \"Method\"\n        ],\n        builder: [\n            \"kind\",\n            \"key\",\n            \"params\",\n            \"body\",\n            \"computed\",\n            \"static\",\n            \"generator\",\n            \"async\"\n        ],\n        visitor: [\n            \"key\",\n            \"params\",\n            \"body\",\n            \"decorators\",\n            \"returnType\",\n            \"typeParameters\"\n        ],\n        fields: Object.assign({}, classMethodOrDeclareMethodCommon, functionTypeAnnotationCommon, {\n            body: {\n                validate: (0, _utils.assertNodeType)(\"BlockStatement\")\n            }\n        })\n    });\n    (0, _utils.default)(\"ObjectPattern\", {\n        visitor: [\n            \"properties\",\n            \"typeAnnotation\",\n            \"decorators\"\n        ],\n        builder: [\n            \"properties\"\n        ],\n        aliases: [\n            \"Pattern\",\n            \"PatternLike\",\n            \"LVal\"\n        ],\n        fields: Object.assign({}, patternLikeCommon, {\n            properties: {\n                validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"RestElement\", \"ObjectProperty\")))\n            }\n        })\n    });\n    (0, _utils.default)(\"SpreadElement\", {\n        visitor: [\n            \"argument\"\n        ],\n        aliases: [\n            \"UnaryLike\"\n        ],\n        deprecatedAlias: \"SpreadProperty\",\n        fields: {\n            argument: {\n                validate: (0, _utils.assertNodeType)(\"Expression\")\n            }\n        }\n    });\n    (0, _utils.default)(\"Super\", {\n        aliases: [\n            \"Expression\"\n        ]\n    });\n    (0, _utils.default)(\"TaggedTemplateExpression\", {\n        visitor: [\n            \"tag\",\n            \"quasi\",\n            \"typeParameters\"\n        ],\n        builder: [\n            \"tag\",\n            \"quasi\"\n        ],\n        aliases: [\n            \"Expression\"\n        ],\n        fields: {\n            tag: {\n                validate: (0, _utils.assertNodeType)(\"Expression\")\n            },\n            quasi: {\n                validate: (0, _utils.assertNodeType)(\"TemplateLiteral\")\n            },\n            typeParameters: {\n                validate: (0, _utils.assertNodeType)(\"TypeParameterInstantiation\", \"TSTypeParameterInstantiation\"),\n                optional: true\n            }\n        }\n    });\n    (0, _utils.default)(\"TemplateElement\", {\n        builder: [\n            \"value\",\n            \"tail\"\n        ],\n        fields: {\n            value: {\n                validate: (0, _utils.assertShape)({\n                    raw: {\n                        validate: (0, _utils.assertValueType)(\"string\")\n                    },\n                    cooked: {\n                        validate: (0, _utils.assertValueType)(\"string\"),\n                        optional: true\n                    }\n                })\n            },\n            tail: {\n                default: false\n            }\n        }\n    });\n    (0, _utils.default)(\"TemplateLiteral\", {\n        visitor: [\n            \"quasis\",\n            \"expressions\"\n        ],\n        aliases: [\n            \"Expression\",\n            \"Literal\"\n        ],\n        fields: {\n            quasis: {\n                validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"TemplateElement\")))\n            },\n            expressions: {\n                validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Expression\", \"TSType\")), function(node, key, val) {\n                    if (node.quasis.length !== val.length + 1) {\n                        throw new TypeError(\"Number of \" + node.type + \" quasis should be exactly one more than the number of expressions.\\nExpected \" + (val.length + 1) + \" quasis but got \" + node.quasis.length);\n                    }\n                })\n            }\n        }\n    });\n    (0, _utils.default)(\"YieldExpression\", {\n        builder: [\n            \"argument\",\n            \"delegate\"\n        ],\n        visitor: [\n            \"argument\"\n        ],\n        aliases: [\n            \"Expression\",\n            \"Terminatorless\"\n        ],\n        fields: {\n            delegate: {\n                validate: (0, _utils.chain)((0, _utils.assertValueType)(\"boolean\"), Object.assign(function(node, key, val) {\n                    if (!process.env.BABEL_TYPES_8_BREAKING) return;\n                    if (val && !node.argument) {\n                        throw new TypeError(\"Property delegate of YieldExpression cannot be true if there is no argument\");\n                    }\n                }, {\n                    type: \"boolean\"\n                })),\n                default: false\n            },\n            argument: {\n                optional: true,\n                validate: (0, _utils.assertNodeType)(\"Expression\")\n            }\n        }\n    });\n    (0, _utils.default)(\"AwaitExpression\", {\n        builder: [\n            \"argument\"\n        ],\n        visitor: [\n            \"argument\"\n        ],\n        aliases: [\n            \"Expression\",\n            \"Terminatorless\"\n        ],\n        fields: {\n            argument: {\n                validate: (0, _utils.assertNodeType)(\"Expression\")\n            }\n        }\n    });\n    (0, _utils.default)(\"Import\", {\n        aliases: [\n            \"Expression\"\n        ]\n    });\n    (0, _utils.default)(\"BigIntLiteral\", {\n        builder: [\n            \"value\"\n        ],\n        fields: {\n            value: {\n                validate: (0, _utils.assertValueType)(\"string\")\n            }\n        },\n        aliases: [\n            \"Expression\",\n            \"Pureish\",\n            \"Literal\",\n            \"Immutable\"\n        ]\n    });\n    (0, _utils.default)(\"ExportNamespaceSpecifier\", {\n        visitor: [\n            \"exported\"\n        ],\n        aliases: [\n            \"ModuleSpecifier\"\n        ],\n        fields: {\n            exported: {\n                validate: (0, _utils.assertNodeType)(\"Identifier\")\n            }\n        }\n    });\n    (0, _utils.default)(\"OptionalMemberExpression\", {\n        builder: [\n            \"object\",\n            \"property\",\n            \"computed\",\n            \"optional\"\n        ],\n        visitor: [\n            \"object\",\n            \"property\"\n        ],\n        aliases: [\n            \"Expression\"\n        ],\n        fields: {\n            object: {\n                validate: (0, _utils.assertNodeType)(\"Expression\")\n            },\n            property: {\n                validate: function() {\n                    var normal = (0, _utils.assertNodeType)(\"Identifier\");\n                    var computed = (0, _utils.assertNodeType)(\"Expression\");\n                    var validator = function validator(node, key, val) {\n                        var validator = node.computed ? computed : normal;\n                        validator(node, key, val);\n                    };\n                    validator.oneOfNodeTypes = [\n                        \"Expression\",\n                        \"Identifier\"\n                    ];\n                    return validator;\n                }()\n            },\n            computed: {\n                default: false\n            },\n            optional: {\n                validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertValueType)(\"boolean\") : (0, _utils.chain)((0, _utils.assertValueType)(\"boolean\"), (0, _utils.assertOptionalChainStart)())\n            }\n        }\n    });\n    (0, _utils.default)(\"OptionalCallExpression\", {\n        visitor: [\n            \"callee\",\n            \"arguments\",\n            \"typeParameters\",\n            \"typeArguments\"\n        ],\n        builder: [\n            \"callee\",\n            \"arguments\",\n            \"optional\"\n        ],\n        aliases: [\n            \"Expression\"\n        ],\n        fields: {\n            callee: {\n                validate: (0, _utils.assertNodeType)(\"Expression\")\n            },\n            arguments: {\n                validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Expression\", \"SpreadElement\", \"JSXNamespacedName\", \"ArgumentPlaceholder\")))\n            },\n            optional: {\n                validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertValueType)(\"boolean\") : (0, _utils.chain)((0, _utils.assertValueType)(\"boolean\"), (0, _utils.assertOptionalChainStart)())\n            },\n            typeArguments: {\n                validate: (0, _utils.assertNodeType)(\"TypeParameterInstantiation\"),\n                optional: true\n            },\n            typeParameters: {\n                validate: (0, _utils.assertNodeType)(\"TSTypeParameterInstantiation\"),\n                optional: true\n            }\n        }\n    });\n    (0, _utils.default)(\"ClassProperty\", {\n        visitor: [\n            \"key\",\n            \"value\",\n            \"typeAnnotation\",\n            \"decorators\"\n        ],\n        builder: [\n            \"key\",\n            \"value\",\n            \"typeAnnotation\",\n            \"decorators\",\n            \"computed\",\n            \"static\"\n        ],\n        aliases: [\n            \"Property\"\n        ],\n        fields: Object.assign({}, classMethodOrPropertyCommon, {\n            value: {\n                validate: (0, _utils.assertNodeType)(\"Expression\"),\n                optional: true\n            },\n            definite: {\n                validate: (0, _utils.assertValueType)(\"boolean\"),\n                optional: true\n            },\n            typeAnnotation: {\n                validate: (0, _utils.assertNodeType)(\"TypeAnnotation\", \"TSTypeAnnotation\", \"Noop\"),\n                optional: true\n            },\n            decorators: {\n                validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n                optional: true\n            },\n            readonly: {\n                validate: (0, _utils.assertValueType)(\"boolean\"),\n                optional: true\n            },\n            declare: {\n                validate: (0, _utils.assertValueType)(\"boolean\"),\n                optional: true\n            },\n            variance: {\n                validate: (0, _utils.assertNodeType)(\"Variance\"),\n                optional: true\n            }\n        })\n    });\n    (0, _utils.default)(\"ClassPrivateProperty\", {\n        visitor: [\n            \"key\",\n            \"value\",\n            \"decorators\",\n            \"typeAnnotation\"\n        ],\n        builder: [\n            \"key\",\n            \"value\",\n            \"decorators\",\n            \"static\"\n        ],\n        aliases: [\n            \"Property\",\n            \"Private\"\n        ],\n        fields: {\n            key: {\n                validate: (0, _utils.assertNodeType)(\"PrivateName\")\n            },\n            value: {\n                validate: (0, _utils.assertNodeType)(\"Expression\"),\n                optional: true\n            },\n            typeAnnotation: {\n                validate: (0, _utils.assertNodeType)(\"TypeAnnotation\", \"TSTypeAnnotation\", \"Noop\"),\n                optional: true\n            },\n            decorators: {\n                validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n                optional: true\n            },\n            readonly: {\n                validate: (0, _utils.assertValueType)(\"boolean\"),\n                optional: true\n            },\n            definite: {\n                validate: (0, _utils.assertValueType)(\"boolean\"),\n                optional: true\n            },\n            variance: {\n                validate: (0, _utils.assertNodeType)(\"Variance\"),\n                optional: true\n            }\n        }\n    });\n    (0, _utils.default)(\"ClassPrivateMethod\", {\n        builder: [\n            \"kind\",\n            \"key\",\n            \"params\",\n            \"body\",\n            \"static\"\n        ],\n        visitor: [\n            \"key\",\n            \"params\",\n            \"body\",\n            \"decorators\",\n            \"returnType\",\n            \"typeParameters\"\n        ],\n        aliases: [\n            \"Function\",\n            \"Scopable\",\n            \"BlockParent\",\n            \"FunctionParent\",\n            \"Method\",\n            \"Private\"\n        ],\n        fields: Object.assign({}, classMethodOrDeclareMethodCommon, functionTypeAnnotationCommon, {\n            key: {\n                validate: (0, _utils.assertNodeType)(\"PrivateName\")\n            },\n            body: {\n                validate: (0, _utils.assertNodeType)(\"BlockStatement\")\n            }\n        })\n    });\n    (0, _utils.default)(\"PrivateName\", {\n        visitor: [\n            \"id\"\n        ],\n        aliases: [\n            \"Private\"\n        ],\n        fields: {\n            id: {\n                validate: (0, _utils.assertNodeType)(\"Identifier\")\n            }\n        }\n    });\n    return core;\n}\n\nvar flow = {};\n\nvar hasRequiredFlow;\nfunction requireFlow() {\n    if (hasRequiredFlow) return flow;\n    hasRequiredFlow = 1;\n    var _utils = requireUtils();\n    var defineInterfaceishType = function(name, typeParameterType) {\n        if (typeParameterType === void 0) typeParameterType = \"TypeParameterDeclaration\";\n        (0, _utils.default)(name, {\n            builder: [\n                \"id\",\n                \"typeParameters\",\n                \"extends\",\n                \"body\"\n            ],\n            visitor: [\n                \"id\",\n                \"typeParameters\",\n                \"extends\",\n                \"mixins\",\n                \"implements\",\n                \"body\"\n            ],\n            aliases: [\n                \"Flow\",\n                \"FlowDeclaration\",\n                \"Statement\",\n                \"Declaration\"\n            ],\n            fields: {\n                id: (0, _utils.validateType)(\"Identifier\"),\n                typeParameters: (0, _utils.validateOptionalType)(typeParameterType),\n                extends: (0, _utils.validateOptional)((0, _utils.arrayOfType)(\"InterfaceExtends\")),\n                mixins: (0, _utils.validateOptional)((0, _utils.arrayOfType)(\"InterfaceExtends\")),\n                implements: (0, _utils.validateOptional)((0, _utils.arrayOfType)(\"ClassImplements\")),\n                body: (0, _utils.validateType)(\"ObjectTypeAnnotation\")\n            }\n        });\n    };\n    (0, _utils.default)(\"AnyTypeAnnotation\", {\n        aliases: [\n            \"Flow\",\n            \"FlowType\",\n            \"FlowBaseAnnotation\"\n        ]\n    });\n    (0, _utils.default)(\"ArrayTypeAnnotation\", {\n        visitor: [\n            \"elementType\"\n        ],\n        aliases: [\n            \"Flow\",\n            \"FlowType\"\n        ],\n        fields: {\n            elementType: (0, _utils.validateType)(\"FlowType\")\n        }\n    });\n    (0, _utils.default)(\"BooleanTypeAnnotation\", {\n        aliases: [\n            \"Flow\",\n            \"FlowType\",\n            \"FlowBaseAnnotation\"\n        ]\n    });\n    (0, _utils.default)(\"BooleanLiteralTypeAnnotation\", {\n        builder: [\n            \"value\"\n        ],\n        aliases: [\n            \"Flow\",\n            \"FlowType\"\n        ],\n        fields: {\n            value: (0, _utils.validate)((0, _utils.assertValueType)(\"boolean\"))\n        }\n    });\n    (0, _utils.default)(\"NullLiteralTypeAnnotation\", {\n        aliases: [\n            \"Flow\",\n            \"FlowType\",\n            \"FlowBaseAnnotation\"\n        ]\n    });\n    (0, _utils.default)(\"ClassImplements\", {\n        visitor: [\n            \"id\",\n            \"typeParameters\"\n        ],\n        aliases: [\n            \"Flow\"\n        ],\n        fields: {\n            id: (0, _utils.validateType)(\"Identifier\"),\n            typeParameters: (0, _utils.validateOptionalType)(\"TypeParameterInstantiation\")\n        }\n    });\n    defineInterfaceishType(\"DeclareClass\");\n    (0, _utils.default)(\"DeclareFunction\", {\n        visitor: [\n            \"id\"\n        ],\n        aliases: [\n            \"Flow\",\n            \"FlowDeclaration\",\n            \"Statement\",\n            \"Declaration\"\n        ],\n        fields: {\n            id: (0, _utils.validateType)(\"Identifier\"),\n            predicate: (0, _utils.validateOptionalType)(\"DeclaredPredicate\")\n        }\n    });\n    defineInterfaceishType(\"DeclareInterface\");\n    (0, _utils.default)(\"DeclareModule\", {\n        builder: [\n            \"id\",\n            \"body\",\n            \"kind\"\n        ],\n        visitor: [\n            \"id\",\n            \"body\"\n        ],\n        aliases: [\n            \"Flow\",\n            \"FlowDeclaration\",\n            \"Statement\",\n            \"Declaration\"\n        ],\n        fields: {\n            id: (0, _utils.validateType)([\n                \"Identifier\",\n                \"StringLiteral\"\n            ]),\n            body: (0, _utils.validateType)(\"BlockStatement\"),\n            kind: (0, _utils.validateOptional)((0, _utils.assertOneOf)(\"CommonJS\", \"ES\"))\n        }\n    });\n    (0, _utils.default)(\"DeclareModuleExports\", {\n        visitor: [\n            \"typeAnnotation\"\n        ],\n        aliases: [\n            \"Flow\",\n            \"FlowDeclaration\",\n            \"Statement\",\n            \"Declaration\"\n        ],\n        fields: {\n            typeAnnotation: (0, _utils.validateType)(\"TypeAnnotation\")\n        }\n    });\n    (0, _utils.default)(\"DeclareTypeAlias\", {\n        visitor: [\n            \"id\",\n            \"typeParameters\",\n            \"right\"\n        ],\n        aliases: [\n            \"Flow\",\n            \"FlowDeclaration\",\n            \"Statement\",\n            \"Declaration\"\n        ],\n        fields: {\n            id: (0, _utils.validateType)(\"Identifier\"),\n            typeParameters: (0, _utils.validateOptionalType)(\"TypeParameterDeclaration\"),\n            right: (0, _utils.validateType)(\"FlowType\")\n        }\n    });\n    (0, _utils.default)(\"DeclareOpaqueType\", {\n        visitor: [\n            \"id\",\n            \"typeParameters\",\n            \"supertype\"\n        ],\n        aliases: [\n            \"Flow\",\n            \"FlowDeclaration\",\n            \"Statement\",\n            \"Declaration\"\n        ],\n        fields: {\n            id: (0, _utils.validateType)(\"Identifier\"),\n            typeParameters: (0, _utils.validateOptionalType)(\"TypeParameterDeclaration\"),\n            supertype: (0, _utils.validateOptionalType)(\"FlowType\"),\n            impltype: (0, _utils.validateOptionalType)(\"FlowType\")\n        }\n    });\n    (0, _utils.default)(\"DeclareVariable\", {\n        visitor: [\n            \"id\"\n        ],\n        aliases: [\n            \"Flow\",\n            \"FlowDeclaration\",\n            \"Statement\",\n            \"Declaration\"\n        ],\n        fields: {\n            id: (0, _utils.validateType)(\"Identifier\")\n        }\n    });\n    (0, _utils.default)(\"DeclareExportDeclaration\", {\n        visitor: [\n            \"declaration\",\n            \"specifiers\",\n            \"source\"\n        ],\n        aliases: [\n            \"Flow\",\n            \"FlowDeclaration\",\n            \"Statement\",\n            \"Declaration\"\n        ],\n        fields: {\n            declaration: (0, _utils.validateOptionalType)(\"Flow\"),\n            specifiers: (0, _utils.validateOptional)((0, _utils.arrayOfType)([\n                \"ExportSpecifier\",\n                \"ExportNamespaceSpecifier\"\n            ])),\n            source: (0, _utils.validateOptionalType)(\"StringLiteral\"),\n            default: (0, _utils.validateOptional)((0, _utils.assertValueType)(\"boolean\"))\n        }\n    });\n    (0, _utils.default)(\"DeclareExportAllDeclaration\", {\n        visitor: [\n            \"source\"\n        ],\n        aliases: [\n            \"Flow\",\n            \"FlowDeclaration\",\n            \"Statement\",\n            \"Declaration\"\n        ],\n        fields: {\n            source: (0, _utils.validateType)(\"StringLiteral\"),\n            exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)(\"type\", \"value\"))\n        }\n    });\n    (0, _utils.default)(\"DeclaredPredicate\", {\n        visitor: [\n            \"value\"\n        ],\n        aliases: [\n            \"Flow\",\n            \"FlowPredicate\"\n        ],\n        fields: {\n            value: (0, _utils.validateType)(\"Flow\")\n        }\n    });\n    (0, _utils.default)(\"ExistsTypeAnnotation\", {\n        aliases: [\n            \"Flow\",\n            \"FlowType\"\n        ]\n    });\n    (0, _utils.default)(\"FunctionTypeAnnotation\", {\n        visitor: [\n            \"typeParameters\",\n            \"params\",\n            \"rest\",\n            \"returnType\"\n        ],\n        aliases: [\n            \"Flow\",\n            \"FlowType\"\n        ],\n        fields: {\n            typeParameters: (0, _utils.validateOptionalType)(\"TypeParameterDeclaration\"),\n            params: (0, _utils.validate)((0, _utils.arrayOfType)(\"FunctionTypeParam\")),\n            rest: (0, _utils.validateOptionalType)(\"FunctionTypeParam\"),\n            this: (0, _utils.validateOptionalType)(\"FunctionTypeParam\"),\n            returnType: (0, _utils.validateType)(\"FlowType\")\n        }\n    });\n    (0, _utils.default)(\"FunctionTypeParam\", {\n        visitor: [\n            \"name\",\n            \"typeAnnotation\"\n        ],\n        aliases: [\n            \"Flow\"\n        ],\n        fields: {\n            name: (0, _utils.validateOptionalType)(\"Identifier\"),\n            typeAnnotation: (0, _utils.validateType)(\"FlowType\"),\n            optional: (0, _utils.validateOptional)((0, _utils.assertValueType)(\"boolean\"))\n        }\n    });\n    (0, _utils.default)(\"GenericTypeAnnotation\", {\n        visitor: [\n            \"id\",\n            \"typeParameters\"\n        ],\n        aliases: [\n            \"Flow\",\n            \"FlowType\"\n        ],\n        fields: {\n            id: (0, _utils.validateType)([\n                \"Identifier\",\n                \"QualifiedTypeIdentifier\"\n            ]),\n            typeParameters: (0, _utils.validateOptionalType)(\"TypeParameterInstantiation\")\n        }\n    });\n    (0, _utils.default)(\"InferredPredicate\", {\n        aliases: [\n            \"Flow\",\n            \"FlowPredicate\"\n        ]\n    });\n    (0, _utils.default)(\"InterfaceExtends\", {\n        visitor: [\n            \"id\",\n            \"typeParameters\"\n        ],\n        aliases: [\n            \"Flow\"\n        ],\n        fields: {\n            id: (0, _utils.validateType)([\n                \"Identifier\",\n                \"QualifiedTypeIdentifier\"\n            ]),\n            typeParameters: (0, _utils.validateOptionalType)(\"TypeParameterInstantiation\")\n        }\n    });\n    defineInterfaceishType(\"InterfaceDeclaration\");\n    (0, _utils.default)(\"InterfaceTypeAnnotation\", {\n        visitor: [\n            \"extends\",\n            \"body\"\n        ],\n        aliases: [\n            \"Flow\",\n            \"FlowType\"\n        ],\n        fields: {\n            extends: (0, _utils.validateOptional)((0, _utils.arrayOfType)(\"InterfaceExtends\")),\n            body: (0, _utils.validateType)(\"ObjectTypeAnnotation\")\n        }\n    });\n    (0, _utils.default)(\"IntersectionTypeAnnotation\", {\n        visitor: [\n            \"types\"\n        ],\n        aliases: [\n            \"Flow\",\n            \"FlowType\"\n        ],\n        fields: {\n            types: (0, _utils.validate)((0, _utils.arrayOfType)(\"FlowType\"))\n        }\n    });\n    (0, _utils.default)(\"MixedTypeAnnotation\", {\n        aliases: [\n            \"Flow\",\n            \"FlowType\",\n            \"FlowBaseAnnotation\"\n        ]\n    });\n    (0, _utils.default)(\"EmptyTypeAnnotation\", {\n        aliases: [\n            \"Flow\",\n            \"FlowType\",\n            \"FlowBaseAnnotation\"\n        ]\n    });\n    (0, _utils.default)(\"NullableTypeAnnotation\", {\n        visitor: [\n            \"typeAnnotation\"\n        ],\n        aliases: [\n            \"Flow\",\n            \"FlowType\"\n        ],\n        fields: {\n            typeAnnotation: (0, _utils.validateType)(\"FlowType\")\n        }\n    });\n    (0, _utils.default)(\"NumberLiteralTypeAnnotation\", {\n        builder: [\n            \"value\"\n        ],\n        aliases: [\n            \"Flow\",\n            \"FlowType\"\n        ],\n        fields: {\n            value: (0, _utils.validate)((0, _utils.assertValueType)(\"number\"))\n        }\n    });\n    (0, _utils.default)(\"NumberTypeAnnotation\", {\n        aliases: [\n            \"Flow\",\n            \"FlowType\",\n            \"FlowBaseAnnotation\"\n        ]\n    });\n    (0, _utils.default)(\"ObjectTypeAnnotation\", {\n        visitor: [\n            \"properties\",\n            \"indexers\",\n            \"callProperties\",\n            \"internalSlots\"\n        ],\n        aliases: [\n            \"Flow\",\n            \"FlowType\"\n        ],\n        builder: [\n            \"properties\",\n            \"indexers\",\n            \"callProperties\",\n            \"internalSlots\",\n            \"exact\"\n        ],\n        fields: {\n            properties: (0, _utils.validate)((0, _utils.arrayOfType)([\n                \"ObjectTypeProperty\",\n                \"ObjectTypeSpreadProperty\"\n            ])),\n            indexers: (0, _utils.validateOptional)((0, _utils.arrayOfType)(\"ObjectTypeIndexer\")),\n            callProperties: (0, _utils.validateOptional)((0, _utils.arrayOfType)(\"ObjectTypeCallProperty\")),\n            internalSlots: (0, _utils.validateOptional)((0, _utils.arrayOfType)(\"ObjectTypeInternalSlot\")),\n            exact: {\n                validate: (0, _utils.assertValueType)(\"boolean\"),\n                default: false\n            },\n            inexact: (0, _utils.validateOptional)((0, _utils.assertValueType)(\"boolean\"))\n        }\n    });\n    (0, _utils.default)(\"ObjectTypeInternalSlot\", {\n        visitor: [\n            \"id\",\n            \"value\",\n            \"optional\",\n            \"static\",\n            \"method\"\n        ],\n        aliases: [\n            \"Flow\",\n            \"UserWhitespacable\"\n        ],\n        fields: {\n            id: (0, _utils.validateType)(\"Identifier\"),\n            value: (0, _utils.validateType)(\"FlowType\"),\n            optional: (0, _utils.validate)((0, _utils.assertValueType)(\"boolean\")),\n            static: (0, _utils.validate)((0, _utils.assertValueType)(\"boolean\")),\n            method: (0, _utils.validate)((0, _utils.assertValueType)(\"boolean\"))\n        }\n    });\n    (0, _utils.default)(\"ObjectTypeCallProperty\", {\n        visitor: [\n            \"value\"\n        ],\n        aliases: [\n            \"Flow\",\n            \"UserWhitespacable\"\n        ],\n        fields: {\n            value: (0, _utils.validateType)(\"FlowType\"),\n            static: (0, _utils.validate)((0, _utils.assertValueType)(\"boolean\"))\n        }\n    });\n    (0, _utils.default)(\"ObjectTypeIndexer\", {\n        visitor: [\n            \"id\",\n            \"key\",\n            \"value\",\n            \"variance\"\n        ],\n        aliases: [\n            \"Flow\",\n            \"UserWhitespacable\"\n        ],\n        fields: {\n            id: (0, _utils.validateOptionalType)(\"Identifier\"),\n            key: (0, _utils.validateType)(\"FlowType\"),\n            value: (0, _utils.validateType)(\"FlowType\"),\n            static: (0, _utils.validate)((0, _utils.assertValueType)(\"boolean\")),\n            variance: (0, _utils.validateOptionalType)(\"Variance\")\n        }\n    });\n    (0, _utils.default)(\"ObjectTypeProperty\", {\n        visitor: [\n            \"key\",\n            \"value\",\n            \"variance\"\n        ],\n        aliases: [\n            \"Flow\",\n            \"UserWhitespacable\"\n        ],\n        fields: {\n            key: (0, _utils.validateType)([\n                \"Identifier\",\n                \"StringLiteral\"\n            ]),\n            value: (0, _utils.validateType)(\"FlowType\"),\n            kind: (0, _utils.validate)((0, _utils.assertOneOf)(\"init\", \"get\", \"set\")),\n            static: (0, _utils.validate)((0, _utils.assertValueType)(\"boolean\")),\n            proto: (0, _utils.validate)((0, _utils.assertValueType)(\"boolean\")),\n            optional: (0, _utils.validate)((0, _utils.assertValueType)(\"boolean\")),\n            variance: (0, _utils.validateOptionalType)(\"Variance\"),\n            method: (0, _utils.validate)((0, _utils.assertValueType)(\"boolean\"))\n        }\n    });\n    (0, _utils.default)(\"ObjectTypeSpreadProperty\", {\n        visitor: [\n            \"argument\"\n        ],\n        aliases: [\n            \"Flow\",\n            \"UserWhitespacable\"\n        ],\n        fields: {\n            argument: (0, _utils.validateType)(\"FlowType\")\n        }\n    });\n    (0, _utils.default)(\"OpaqueType\", {\n        visitor: [\n            \"id\",\n            \"typeParameters\",\n            \"supertype\",\n            \"impltype\"\n        ],\n        aliases: [\n            \"Flow\",\n            \"FlowDeclaration\",\n            \"Statement\",\n            \"Declaration\"\n        ],\n        fields: {\n            id: (0, _utils.validateType)(\"Identifier\"),\n            typeParameters: (0, _utils.validateOptionalType)(\"TypeParameterDeclaration\"),\n            supertype: (0, _utils.validateOptionalType)(\"FlowType\"),\n            impltype: (0, _utils.validateType)(\"FlowType\")\n        }\n    });\n    (0, _utils.default)(\"QualifiedTypeIdentifier\", {\n        visitor: [\n            \"id\",\n            \"qualification\"\n        ],\n        aliases: [\n            \"Flow\"\n        ],\n        fields: {\n            id: (0, _utils.validateType)(\"Identifier\"),\n            qualification: (0, _utils.validateType)([\n                \"Identifier\",\n                \"QualifiedTypeIdentifier\"\n            ])\n        }\n    });\n    (0, _utils.default)(\"StringLiteralTypeAnnotation\", {\n        builder: [\n            \"value\"\n        ],\n        aliases: [\n            \"Flow\",\n            \"FlowType\"\n        ],\n        fields: {\n            value: (0, _utils.validate)((0, _utils.assertValueType)(\"string\"))\n        }\n    });\n    (0, _utils.default)(\"StringTypeAnnotation\", {\n        aliases: [\n            \"Flow\",\n            \"FlowType\",\n            \"FlowBaseAnnotation\"\n        ]\n    });\n    (0, _utils.default)(\"SymbolTypeAnnotation\", {\n        aliases: [\n            \"Flow\",\n            \"FlowType\",\n            \"FlowBaseAnnotation\"\n        ]\n    });\n    (0, _utils.default)(\"ThisTypeAnnotation\", {\n        aliases: [\n            \"Flow\",\n            \"FlowType\",\n            \"FlowBaseAnnotation\"\n        ]\n    });\n    (0, _utils.default)(\"TupleTypeAnnotation\", {\n        visitor: [\n            \"types\"\n        ],\n        aliases: [\n            \"Flow\",\n            \"FlowType\"\n        ],\n        fields: {\n            types: (0, _utils.validate)((0, _utils.arrayOfType)(\"FlowType\"))\n        }\n    });\n    (0, _utils.default)(\"TypeofTypeAnnotation\", {\n        visitor: [\n            \"argument\"\n        ],\n        aliases: [\n            \"Flow\",\n            \"FlowType\"\n        ],\n        fields: {\n            argument: (0, _utils.validateType)(\"FlowType\")\n        }\n    });\n    (0, _utils.default)(\"TypeAlias\", {\n        visitor: [\n            \"id\",\n            \"typeParameters\",\n            \"right\"\n        ],\n        aliases: [\n            \"Flow\",\n            \"FlowDeclaration\",\n            \"Statement\",\n            \"Declaration\"\n        ],\n        fields: {\n            id: (0, _utils.validateType)(\"Identifier\"),\n            typeParameters: (0, _utils.validateOptionalType)(\"TypeParameterDeclaration\"),\n            right: (0, _utils.validateType)(\"FlowType\")\n        }\n    });\n    (0, _utils.default)(\"TypeAnnotation\", {\n        aliases: [\n            \"Flow\"\n        ],\n        visitor: [\n            \"typeAnnotation\"\n        ],\n        fields: {\n            typeAnnotation: (0, _utils.validateType)(\"FlowType\")\n        }\n    });\n    (0, _utils.default)(\"TypeCastExpression\", {\n        visitor: [\n            \"expression\",\n            \"typeAnnotation\"\n        ],\n        aliases: [\n            \"Flow\",\n            \"ExpressionWrapper\",\n            \"Expression\"\n        ],\n        fields: {\n            expression: (0, _utils.validateType)(\"Expression\"),\n            typeAnnotation: (0, _utils.validateType)(\"TypeAnnotation\")\n        }\n    });\n    (0, _utils.default)(\"TypeParameter\", {\n        aliases: [\n            \"Flow\"\n        ],\n        visitor: [\n            \"bound\",\n            \"default\",\n            \"variance\"\n        ],\n        fields: {\n            name: (0, _utils.validate)((0, _utils.assertValueType)(\"string\")),\n            bound: (0, _utils.validateOptionalType)(\"TypeAnnotation\"),\n            default: (0, _utils.validateOptionalType)(\"FlowType\"),\n            variance: (0, _utils.validateOptionalType)(\"Variance\")\n        }\n    });\n    (0, _utils.default)(\"TypeParameterDeclaration\", {\n        aliases: [\n            \"Flow\"\n        ],\n        visitor: [\n            \"params\"\n        ],\n        fields: {\n            params: (0, _utils.validate)((0, _utils.arrayOfType)(\"TypeParameter\"))\n        }\n    });\n    (0, _utils.default)(\"TypeParameterInstantiation\", {\n        aliases: [\n            \"Flow\"\n        ],\n        visitor: [\n            \"params\"\n        ],\n        fields: {\n            params: (0, _utils.validate)((0, _utils.arrayOfType)(\"FlowType\"))\n        }\n    });\n    (0, _utils.default)(\"UnionTypeAnnotation\", {\n        visitor: [\n            \"types\"\n        ],\n        aliases: [\n            \"Flow\",\n            \"FlowType\"\n        ],\n        fields: {\n            types: (0, _utils.validate)((0, _utils.arrayOfType)(\"FlowType\"))\n        }\n    });\n    (0, _utils.default)(\"Variance\", {\n        aliases: [\n            \"Flow\"\n        ],\n        builder: [\n            \"kind\"\n        ],\n        fields: {\n            kind: (0, _utils.validate)((0, _utils.assertOneOf)(\"minus\", \"plus\"))\n        }\n    });\n    (0, _utils.default)(\"VoidTypeAnnotation\", {\n        aliases: [\n            \"Flow\",\n            \"FlowType\",\n            \"FlowBaseAnnotation\"\n        ]\n    });\n    (0, _utils.default)(\"EnumDeclaration\", {\n        aliases: [\n            \"Statement\",\n            \"Declaration\"\n        ],\n        visitor: [\n            \"id\",\n            \"body\"\n        ],\n        fields: {\n            id: (0, _utils.validateType)(\"Identifier\"),\n            body: (0, _utils.validateType)([\n                \"EnumBooleanBody\",\n                \"EnumNumberBody\",\n                \"EnumStringBody\",\n                \"EnumSymbolBody\"\n            ])\n        }\n    });\n    (0, _utils.default)(\"EnumBooleanBody\", {\n        aliases: [\n            \"EnumBody\"\n        ],\n        visitor: [\n            \"members\"\n        ],\n        fields: {\n            explicitType: (0, _utils.validate)((0, _utils.assertValueType)(\"boolean\")),\n            members: (0, _utils.validateArrayOfType)(\"EnumBooleanMember\"),\n            hasUnknownMembers: (0, _utils.validate)((0, _utils.assertValueType)(\"boolean\"))\n        }\n    });\n    (0, _utils.default)(\"EnumNumberBody\", {\n        aliases: [\n            \"EnumBody\"\n        ],\n        visitor: [\n            \"members\"\n        ],\n        fields: {\n            explicitType: (0, _utils.validate)((0, _utils.assertValueType)(\"boolean\")),\n            members: (0, _utils.validateArrayOfType)(\"EnumNumberMember\"),\n            hasUnknownMembers: (0, _utils.validate)((0, _utils.assertValueType)(\"boolean\"))\n        }\n    });\n    (0, _utils.default)(\"EnumStringBody\", {\n        aliases: [\n            \"EnumBody\"\n        ],\n        visitor: [\n            \"members\"\n        ],\n        fields: {\n            explicitType: (0, _utils.validate)((0, _utils.assertValueType)(\"boolean\")),\n            members: (0, _utils.validateArrayOfType)([\n                \"EnumStringMember\",\n                \"EnumDefaultedMember\"\n            ]),\n            hasUnknownMembers: (0, _utils.validate)((0, _utils.assertValueType)(\"boolean\"))\n        }\n    });\n    (0, _utils.default)(\"EnumSymbolBody\", {\n        aliases: [\n            \"EnumBody\"\n        ],\n        visitor: [\n            \"members\"\n        ],\n        fields: {\n            members: (0, _utils.validateArrayOfType)(\"EnumDefaultedMember\"),\n            hasUnknownMembers: (0, _utils.validate)((0, _utils.assertValueType)(\"boolean\"))\n        }\n    });\n    (0, _utils.default)(\"EnumBooleanMember\", {\n        aliases: [\n            \"EnumMember\"\n        ],\n        visitor: [\n            \"id\"\n        ],\n        fields: {\n            id: (0, _utils.validateType)(\"Identifier\"),\n            init: (0, _utils.validateType)(\"BooleanLiteral\")\n        }\n    });\n    (0, _utils.default)(\"EnumNumberMember\", {\n        aliases: [\n            \"EnumMember\"\n        ],\n        visitor: [\n            \"id\",\n            \"init\"\n        ],\n        fields: {\n            id: (0, _utils.validateType)(\"Identifier\"),\n            init: (0, _utils.validateType)(\"NumericLiteral\")\n        }\n    });\n    (0, _utils.default)(\"EnumStringMember\", {\n        aliases: [\n            \"EnumMember\"\n        ],\n        visitor: [\n            \"id\",\n            \"init\"\n        ],\n        fields: {\n            id: (0, _utils.validateType)(\"Identifier\"),\n            init: (0, _utils.validateType)(\"StringLiteral\")\n        }\n    });\n    (0, _utils.default)(\"EnumDefaultedMember\", {\n        aliases: [\n            \"EnumMember\"\n        ],\n        visitor: [\n            \"id\"\n        ],\n        fields: {\n            id: (0, _utils.validateType)(\"Identifier\")\n        }\n    });\n    (0, _utils.default)(\"IndexedAccessType\", {\n        visitor: [\n            \"objectType\",\n            \"indexType\"\n        ],\n        aliases: [\n            \"Flow\",\n            \"FlowType\"\n        ],\n        fields: {\n            objectType: (0, _utils.validateType)(\"FlowType\"),\n            indexType: (0, _utils.validateType)(\"FlowType\")\n        }\n    });\n    (0, _utils.default)(\"OptionalIndexedAccessType\", {\n        visitor: [\n            \"objectType\",\n            \"indexType\"\n        ],\n        aliases: [\n            \"Flow\",\n            \"FlowType\"\n        ],\n        fields: {\n            objectType: (0, _utils.validateType)(\"FlowType\"),\n            indexType: (0, _utils.validateType)(\"FlowType\"),\n            optional: (0, _utils.validate)((0, _utils.assertValueType)(\"boolean\"))\n        }\n    });\n    return flow;\n}\n\nvar jsx = {};\n\nvar hasRequiredJsx;\nfunction requireJsx() {\n    if (hasRequiredJsx) return jsx;\n    hasRequiredJsx = 1;\n    var _utils = requireUtils();\n    (0, _utils.default)(\"JSXAttribute\", {\n        visitor: [\n            \"name\",\n            \"value\"\n        ],\n        aliases: [\n            \"JSX\",\n            \"Immutable\"\n        ],\n        fields: {\n            name: {\n                validate: (0, _utils.assertNodeType)(\"JSXIdentifier\", \"JSXNamespacedName\")\n            },\n            value: {\n                optional: true,\n                validate: (0, _utils.assertNodeType)(\"JSXElement\", \"JSXFragment\", \"StringLiteral\", \"JSXExpressionContainer\")\n            }\n        }\n    });\n    (0, _utils.default)(\"JSXClosingElement\", {\n        visitor: [\n            \"name\"\n        ],\n        aliases: [\n            \"JSX\",\n            \"Immutable\"\n        ],\n        fields: {\n            name: {\n                validate: (0, _utils.assertNodeType)(\"JSXIdentifier\", \"JSXMemberExpression\", \"JSXNamespacedName\")\n            }\n        }\n    });\n    (0, _utils.default)(\"JSXElement\", {\n        builder: [\n            \"openingElement\",\n            \"closingElement\",\n            \"children\",\n            \"selfClosing\"\n        ],\n        visitor: [\n            \"openingElement\",\n            \"children\",\n            \"closingElement\"\n        ],\n        aliases: [\n            \"JSX\",\n            \"Immutable\",\n            \"Expression\"\n        ],\n        fields: {\n            openingElement: {\n                validate: (0, _utils.assertNodeType)(\"JSXOpeningElement\")\n            },\n            closingElement: {\n                optional: true,\n                validate: (0, _utils.assertNodeType)(\"JSXClosingElement\")\n            },\n            children: {\n                validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"JSXText\", \"JSXExpressionContainer\", \"JSXSpreadChild\", \"JSXElement\", \"JSXFragment\")))\n            },\n            selfClosing: {\n                validate: (0, _utils.assertValueType)(\"boolean\"),\n                optional: true\n            }\n        }\n    });\n    (0, _utils.default)(\"JSXEmptyExpression\", {\n        aliases: [\n            \"JSX\"\n        ]\n    });\n    (0, _utils.default)(\"JSXExpressionContainer\", {\n        visitor: [\n            \"expression\"\n        ],\n        aliases: [\n            \"JSX\",\n            \"Immutable\"\n        ],\n        fields: {\n            expression: {\n                validate: (0, _utils.assertNodeType)(\"Expression\", \"JSXEmptyExpression\")\n            }\n        }\n    });\n    (0, _utils.default)(\"JSXSpreadChild\", {\n        visitor: [\n            \"expression\"\n        ],\n        aliases: [\n            \"JSX\",\n            \"Immutable\"\n        ],\n        fields: {\n            expression: {\n                validate: (0, _utils.assertNodeType)(\"Expression\")\n            }\n        }\n    });\n    (0, _utils.default)(\"JSXIdentifier\", {\n        builder: [\n            \"name\"\n        ],\n        aliases: [\n            \"JSX\"\n        ],\n        fields: {\n            name: {\n                validate: (0, _utils.assertValueType)(\"string\")\n            }\n        }\n    });\n    (0, _utils.default)(\"JSXMemberExpression\", {\n        visitor: [\n            \"object\",\n            \"property\"\n        ],\n        aliases: [\n            \"JSX\"\n        ],\n        fields: {\n            object: {\n                validate: (0, _utils.assertNodeType)(\"JSXMemberExpression\", \"JSXIdentifier\")\n            },\n            property: {\n                validate: (0, _utils.assertNodeType)(\"JSXIdentifier\")\n            }\n        }\n    });\n    (0, _utils.default)(\"JSXNamespacedName\", {\n        visitor: [\n            \"namespace\",\n            \"name\"\n        ],\n        aliases: [\n            \"JSX\"\n        ],\n        fields: {\n            namespace: {\n                validate: (0, _utils.assertNodeType)(\"JSXIdentifier\")\n            },\n            name: {\n                validate: (0, _utils.assertNodeType)(\"JSXIdentifier\")\n            }\n        }\n    });\n    (0, _utils.default)(\"JSXOpeningElement\", {\n        builder: [\n            \"name\",\n            \"attributes\",\n            \"selfClosing\"\n        ],\n        visitor: [\n            \"name\",\n            \"attributes\"\n        ],\n        aliases: [\n            \"JSX\",\n            \"Immutable\"\n        ],\n        fields: {\n            name: {\n                validate: (0, _utils.assertNodeType)(\"JSXIdentifier\", \"JSXMemberExpression\", \"JSXNamespacedName\")\n            },\n            selfClosing: {\n                default: false\n            },\n            attributes: {\n                validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"JSXAttribute\", \"JSXSpreadAttribute\")))\n            },\n            typeParameters: {\n                validate: (0, _utils.assertNodeType)(\"TypeParameterInstantiation\", \"TSTypeParameterInstantiation\"),\n                optional: true\n            }\n        }\n    });\n    (0, _utils.default)(\"JSXSpreadAttribute\", {\n        visitor: [\n            \"argument\"\n        ],\n        aliases: [\n            \"JSX\"\n        ],\n        fields: {\n            argument: {\n                validate: (0, _utils.assertNodeType)(\"Expression\")\n            }\n        }\n    });\n    (0, _utils.default)(\"JSXText\", {\n        aliases: [\n            \"JSX\",\n            \"Immutable\"\n        ],\n        builder: [\n            \"value\"\n        ],\n        fields: {\n            value: {\n                validate: (0, _utils.assertValueType)(\"string\")\n            }\n        }\n    });\n    (0, _utils.default)(\"JSXFragment\", {\n        builder: [\n            \"openingFragment\",\n            \"closingFragment\",\n            \"children\"\n        ],\n        visitor: [\n            \"openingFragment\",\n            \"children\",\n            \"closingFragment\"\n        ],\n        aliases: [\n            \"JSX\",\n            \"Immutable\",\n            \"Expression\"\n        ],\n        fields: {\n            openingFragment: {\n                validate: (0, _utils.assertNodeType)(\"JSXOpeningFragment\")\n            },\n            closingFragment: {\n                validate: (0, _utils.assertNodeType)(\"JSXClosingFragment\")\n            },\n            children: {\n                validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"JSXText\", \"JSXExpressionContainer\", \"JSXSpreadChild\", \"JSXElement\", \"JSXFragment\")))\n            }\n        }\n    });\n    (0, _utils.default)(\"JSXOpeningFragment\", {\n        aliases: [\n            \"JSX\",\n            \"Immutable\"\n        ]\n    });\n    (0, _utils.default)(\"JSXClosingFragment\", {\n        aliases: [\n            \"JSX\",\n            \"Immutable\"\n        ]\n    });\n    return jsx;\n}\n\nvar misc = {};\n\nvar placeholders = {};\n\nfunction _createForOfIteratorHelperLoose$f(o, allowArrayLike) {\n    var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n    if (it) return (it = it.call(o)).next.bind(it);\n    if (Array.isArray(o) || (it = unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n        if (it) o = it;\n        var i = 0;\n        return function() {\n            if (i >= o.length) return {\n                done: true\n            };\n            return {\n                done: false,\n                value: o[i++]\n            };\n        };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nvar hasRequiredPlaceholders;\nfunction requirePlaceholders() {\n    if (hasRequiredPlaceholders) return placeholders;\n    hasRequiredPlaceholders = 1;\n    Object.defineProperty(placeholders, \"__esModule\", {\n        value: true\n    });\n    placeholders.PLACEHOLDERS_FLIPPED_ALIAS = placeholders.PLACEHOLDERS_ALIAS = placeholders.PLACEHOLDERS = void 0;\n    var _utils = requireUtils();\n    var PLACEHOLDERS = [\n        \"Identifier\",\n        \"StringLiteral\",\n        \"Expression\",\n        \"Statement\",\n        \"Declaration\",\n        \"BlockStatement\",\n        \"ClassBody\",\n        \"Pattern\"\n    ];\n    placeholders.PLACEHOLDERS = PLACEHOLDERS;\n    var PLACEHOLDERS_ALIAS = {\n        Declaration: [\n            \"Statement\"\n        ],\n        Pattern: [\n            \"PatternLike\",\n            \"LVal\"\n        ]\n    };\n    placeholders.PLACEHOLDERS_ALIAS = PLACEHOLDERS_ALIAS;\n    for(var _iterator = _createForOfIteratorHelperLoose$f(PLACEHOLDERS), _step; !(_step = _iterator()).done;){\n        var type = _step.value;\n        var alias = _utils.ALIAS_KEYS[type];\n        if (alias != null && alias.length) PLACEHOLDERS_ALIAS[type] = alias;\n    }\n    var PLACEHOLDERS_FLIPPED_ALIAS = {};\n    placeholders.PLACEHOLDERS_FLIPPED_ALIAS = PLACEHOLDERS_FLIPPED_ALIAS;\n    Object.keys(PLACEHOLDERS_ALIAS).forEach(function(type) {\n        PLACEHOLDERS_ALIAS[type].forEach(function(alias) {\n            if (!Object.hasOwnProperty.call(PLACEHOLDERS_FLIPPED_ALIAS, alias)) {\n                PLACEHOLDERS_FLIPPED_ALIAS[alias] = [];\n            }\n            PLACEHOLDERS_FLIPPED_ALIAS[alias].push(type);\n        });\n    });\n    return placeholders;\n}\n\nvar hasRequiredMisc;\nfunction requireMisc() {\n    if (hasRequiredMisc) return misc;\n    hasRequiredMisc = 1;\n    var _utils = requireUtils();\n    var _placeholders = requirePlaceholders();\n    {\n        (0, _utils.default)(\"Noop\", {\n            visitor: []\n        });\n    }\n    (0, _utils.default)(\"Placeholder\", {\n        visitor: [],\n        builder: [\n            \"expectedNode\",\n            \"name\"\n        ],\n        fields: {\n            name: {\n                validate: (0, _utils.assertNodeType)(\"Identifier\")\n            },\n            expectedNode: {\n                validate: (_utils.assertOneOf).apply(this, _placeholders.PLACEHOLDERS)\n            }\n        }\n    });\n    (0, _utils.default)(\"V8IntrinsicIdentifier\", {\n        builder: [\n            \"name\"\n        ],\n        fields: {\n            name: {\n                validate: (0, _utils.assertValueType)(\"string\")\n            }\n        }\n    });\n    return misc;\n}\n\nvar experimental = {};\n\nvar hasRequiredExperimental;\nfunction requireExperimental() {\n    if (hasRequiredExperimental) return experimental;\n    hasRequiredExperimental = 1;\n    var _utils = requireUtils();\n    (0, _utils.default)(\"ArgumentPlaceholder\", {});\n    (0, _utils.default)(\"BindExpression\", {\n        visitor: [\n            \"object\",\n            \"callee\"\n        ],\n        aliases: [\n            \"Expression\"\n        ],\n        fields: !process.env.BABEL_TYPES_8_BREAKING ? {\n            object: {\n                validate: Object.assign(function() {}, {\n                    oneOfNodeTypes: [\n                        \"Expression\"\n                    ]\n                })\n            },\n            callee: {\n                validate: Object.assign(function() {}, {\n                    oneOfNodeTypes: [\n                        \"Expression\"\n                    ]\n                })\n            }\n        } : {\n            object: {\n                validate: (0, _utils.assertNodeType)(\"Expression\")\n            },\n            callee: {\n                validate: (0, _utils.assertNodeType)(\"Expression\")\n            }\n        }\n    });\n    (0, _utils.default)(\"ImportAttribute\", {\n        visitor: [\n            \"key\",\n            \"value\"\n        ],\n        fields: {\n            key: {\n                validate: (0, _utils.assertNodeType)(\"Identifier\", \"StringLiteral\")\n            },\n            value: {\n                validate: (0, _utils.assertNodeType)(\"StringLiteral\")\n            }\n        }\n    });\n    (0, _utils.default)(\"Decorator\", {\n        visitor: [\n            \"expression\"\n        ],\n        fields: {\n            expression: {\n                validate: (0, _utils.assertNodeType)(\"Expression\")\n            }\n        }\n    });\n    (0, _utils.default)(\"DoExpression\", {\n        visitor: [\n            \"body\"\n        ],\n        builder: [\n            \"body\",\n            \"async\"\n        ],\n        aliases: [\n            \"Expression\"\n        ],\n        fields: {\n            body: {\n                validate: (0, _utils.assertNodeType)(\"BlockStatement\")\n            },\n            async: {\n                validate: (0, _utils.assertValueType)(\"boolean\"),\n                default: false\n            }\n        }\n    });\n    (0, _utils.default)(\"ExportDefaultSpecifier\", {\n        visitor: [\n            \"exported\"\n        ],\n        aliases: [\n            \"ModuleSpecifier\"\n        ],\n        fields: {\n            exported: {\n                validate: (0, _utils.assertNodeType)(\"Identifier\")\n            }\n        }\n    });\n    (0, _utils.default)(\"RecordExpression\", {\n        visitor: [\n            \"properties\"\n        ],\n        aliases: [\n            \"Expression\"\n        ],\n        fields: {\n            properties: {\n                validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"ObjectProperty\", \"SpreadElement\")))\n            }\n        }\n    });\n    (0, _utils.default)(\"TupleExpression\", {\n        fields: {\n            elements: {\n                validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Expression\", \"SpreadElement\"))),\n                default: []\n            }\n        },\n        visitor: [\n            \"elements\"\n        ],\n        aliases: [\n            \"Expression\"\n        ]\n    });\n    (0, _utils.default)(\"DecimalLiteral\", {\n        builder: [\n            \"value\"\n        ],\n        fields: {\n            value: {\n                validate: (0, _utils.assertValueType)(\"string\")\n            }\n        },\n        aliases: [\n            \"Expression\",\n            \"Pureish\",\n            \"Literal\",\n            \"Immutable\"\n        ]\n    });\n    (0, _utils.default)(\"StaticBlock\", {\n        visitor: [\n            \"body\"\n        ],\n        fields: {\n            body: {\n                validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Statement\")))\n            }\n        },\n        aliases: [\n            \"Scopable\",\n            \"BlockParent\"\n        ]\n    });\n    (0, _utils.default)(\"ModuleExpression\", {\n        visitor: [\n            \"body\"\n        ],\n        fields: {\n            body: {\n                validate: (0, _utils.assertNodeType)(\"Program\")\n            }\n        },\n        aliases: [\n            \"Expression\"\n        ]\n    });\n    (0, _utils.default)(\"TopicReference\", {\n        aliases: [\n            \"Expression\"\n        ]\n    });\n    (0, _utils.default)(\"PipelineTopicExpression\", {\n        builder: [\n            \"expression\"\n        ],\n        visitor: [\n            \"expression\"\n        ],\n        fields: {\n            expression: {\n                validate: (0, _utils.assertNodeType)(\"Expression\")\n            }\n        },\n        aliases: [\n            \"Expression\"\n        ]\n    });\n    (0, _utils.default)(\"PipelineBareFunction\", {\n        builder: [\n            \"callee\"\n        ],\n        visitor: [\n            \"callee\"\n        ],\n        fields: {\n            callee: {\n                validate: (0, _utils.assertNodeType)(\"Expression\")\n            }\n        },\n        aliases: [\n            \"Expression\"\n        ]\n    });\n    (0, _utils.default)(\"PipelinePrimaryTopicReference\", {\n        aliases: [\n            \"Expression\"\n        ]\n    });\n    return experimental;\n}\n\nvar typescript = {};\n\nfunction _createForOfIteratorHelperLoose$e(o, allowArrayLike) {\n    var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n    if (it) return (it = it.call(o)).next.bind(it);\n    if (Array.isArray(o) || (it = unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n        if (it) o = it;\n        var i = 0;\n        return function() {\n            if (i >= o.length) return {\n                done: true\n            };\n            return {\n                done: false,\n                value: o[i++]\n            };\n        };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nvar hasRequiredTypescript;\nfunction requireTypescript() {\n    if (hasRequiredTypescript) return typescript;\n    hasRequiredTypescript = 1;\n    var _utils = requireUtils();\n    var _core = requireCore();\n    var _is = requireIs();\n    var bool = (0, _utils.assertValueType)(\"boolean\");\n    var tSFunctionTypeAnnotationCommon = {\n        returnType: {\n            validate: (0, _utils.assertNodeType)(\"TSTypeAnnotation\", \"Noop\"),\n            optional: true\n        },\n        typeParameters: {\n            validate: (0, _utils.assertNodeType)(\"TSTypeParameterDeclaration\", \"Noop\"),\n            optional: true\n        }\n    };\n    (0, _utils.default)(\"TSParameterProperty\", {\n        aliases: [\n            \"LVal\"\n        ],\n        visitor: [\n            \"parameter\"\n        ],\n        fields: {\n            accessibility: {\n                validate: (0, _utils.assertOneOf)(\"public\", \"private\", \"protected\"),\n                optional: true\n            },\n            readonly: {\n                validate: (0, _utils.assertValueType)(\"boolean\"),\n                optional: true\n            },\n            parameter: {\n                validate: (0, _utils.assertNodeType)(\"Identifier\", \"AssignmentPattern\")\n            },\n            override: {\n                validate: (0, _utils.assertValueType)(\"boolean\"),\n                optional: true\n            },\n            decorators: {\n                validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n                optional: true\n            }\n        }\n    });\n    (0, _utils.default)(\"TSDeclareFunction\", {\n        aliases: [\n            \"Statement\",\n            \"Declaration\"\n        ],\n        visitor: [\n            \"id\",\n            \"typeParameters\",\n            \"params\",\n            \"returnType\"\n        ],\n        fields: Object.assign({}, _core.functionDeclarationCommon, tSFunctionTypeAnnotationCommon)\n    });\n    (0, _utils.default)(\"TSDeclareMethod\", {\n        visitor: [\n            \"decorators\",\n            \"key\",\n            \"typeParameters\",\n            \"params\",\n            \"returnType\"\n        ],\n        fields: Object.assign({}, _core.classMethodOrDeclareMethodCommon, tSFunctionTypeAnnotationCommon)\n    });\n    (0, _utils.default)(\"TSQualifiedName\", {\n        aliases: [\n            \"TSEntityName\"\n        ],\n        visitor: [\n            \"left\",\n            \"right\"\n        ],\n        fields: {\n            left: (0, _utils.validateType)(\"TSEntityName\"),\n            right: (0, _utils.validateType)(\"Identifier\")\n        }\n    });\n    var signatureDeclarationCommon = {\n        typeParameters: (0, _utils.validateOptionalType)(\"TSTypeParameterDeclaration\"),\n        parameters: (0, _utils.validateArrayOfType)([\n            \"Identifier\",\n            \"RestElement\"\n        ]),\n        typeAnnotation: (0, _utils.validateOptionalType)(\"TSTypeAnnotation\")\n    };\n    var callConstructSignatureDeclaration = {\n        aliases: [\n            \"TSTypeElement\"\n        ],\n        visitor: [\n            \"typeParameters\",\n            \"parameters\",\n            \"typeAnnotation\"\n        ],\n        fields: signatureDeclarationCommon\n    };\n    (0, _utils.default)(\"TSCallSignatureDeclaration\", callConstructSignatureDeclaration);\n    (0, _utils.default)(\"TSConstructSignatureDeclaration\", callConstructSignatureDeclaration);\n    var namedTypeElementCommon = {\n        key: (0, _utils.validateType)(\"Expression\"),\n        computed: (0, _utils.validate)(bool),\n        optional: (0, _utils.validateOptional)(bool)\n    };\n    (0, _utils.default)(\"TSPropertySignature\", {\n        aliases: [\n            \"TSTypeElement\"\n        ],\n        visitor: [\n            \"key\",\n            \"typeAnnotation\",\n            \"initializer\"\n        ],\n        fields: Object.assign({}, namedTypeElementCommon, {\n            readonly: (0, _utils.validateOptional)(bool),\n            typeAnnotation: (0, _utils.validateOptionalType)(\"TSTypeAnnotation\"),\n            initializer: (0, _utils.validateOptionalType)(\"Expression\"),\n            kind: {\n                validate: (0, _utils.assertOneOf)(\"get\", \"set\")\n            }\n        })\n    });\n    (0, _utils.default)(\"TSMethodSignature\", {\n        aliases: [\n            \"TSTypeElement\"\n        ],\n        visitor: [\n            \"key\",\n            \"typeParameters\",\n            \"parameters\",\n            \"typeAnnotation\"\n        ],\n        fields: Object.assign({}, signatureDeclarationCommon, namedTypeElementCommon, {\n            kind: {\n                validate: (0, _utils.assertOneOf)(\"method\", \"get\", \"set\")\n            }\n        })\n    });\n    (0, _utils.default)(\"TSIndexSignature\", {\n        aliases: [\n            \"TSTypeElement\"\n        ],\n        visitor: [\n            \"parameters\",\n            \"typeAnnotation\"\n        ],\n        fields: {\n            readonly: (0, _utils.validateOptional)(bool),\n            static: (0, _utils.validateOptional)(bool),\n            parameters: (0, _utils.validateArrayOfType)(\"Identifier\"),\n            typeAnnotation: (0, _utils.validateOptionalType)(\"TSTypeAnnotation\")\n        }\n    });\n    var tsKeywordTypes = [\n        \"TSAnyKeyword\",\n        \"TSBooleanKeyword\",\n        \"TSBigIntKeyword\",\n        \"TSIntrinsicKeyword\",\n        \"TSNeverKeyword\",\n        \"TSNullKeyword\",\n        \"TSNumberKeyword\",\n        \"TSObjectKeyword\",\n        \"TSStringKeyword\",\n        \"TSSymbolKeyword\",\n        \"TSUndefinedKeyword\",\n        \"TSUnknownKeyword\",\n        \"TSVoidKeyword\"\n    ];\n    for(var _iterator = _createForOfIteratorHelperLoose$e(tsKeywordTypes), _step; !(_step = _iterator()).done;){\n        var type = _step.value;\n        (0, _utils.default)(type, {\n            aliases: [\n                \"TSType\",\n                \"TSBaseType\"\n            ],\n            visitor: [],\n            fields: {}\n        });\n    }\n    (0, _utils.default)(\"TSThisType\", {\n        aliases: [\n            \"TSType\",\n            \"TSBaseType\"\n        ],\n        visitor: [],\n        fields: {}\n    });\n    var fnOrCtrBase = {\n        aliases: [\n            \"TSType\"\n        ],\n        visitor: [\n            \"typeParameters\",\n            \"parameters\",\n            \"typeAnnotation\"\n        ]\n    };\n    (0, _utils.default)(\"TSFunctionType\", Object.assign({}, fnOrCtrBase, {\n        fields: signatureDeclarationCommon\n    }));\n    (0, _utils.default)(\"TSConstructorType\", Object.assign({}, fnOrCtrBase, {\n        fields: Object.assign({}, signatureDeclarationCommon, {\n            abstract: (0, _utils.validateOptional)(bool)\n        })\n    }));\n    (0, _utils.default)(\"TSTypeReference\", {\n        aliases: [\n            \"TSType\"\n        ],\n        visitor: [\n            \"typeName\",\n            \"typeParameters\"\n        ],\n        fields: {\n            typeName: (0, _utils.validateType)(\"TSEntityName\"),\n            typeParameters: (0, _utils.validateOptionalType)(\"TSTypeParameterInstantiation\")\n        }\n    });\n    (0, _utils.default)(\"TSTypePredicate\", {\n        aliases: [\n            \"TSType\"\n        ],\n        visitor: [\n            \"parameterName\",\n            \"typeAnnotation\"\n        ],\n        builder: [\n            \"parameterName\",\n            \"typeAnnotation\",\n            \"asserts\"\n        ],\n        fields: {\n            parameterName: (0, _utils.validateType)([\n                \"Identifier\",\n                \"TSThisType\"\n            ]),\n            typeAnnotation: (0, _utils.validateOptionalType)(\"TSTypeAnnotation\"),\n            asserts: (0, _utils.validateOptional)(bool)\n        }\n    });\n    (0, _utils.default)(\"TSTypeQuery\", {\n        aliases: [\n            \"TSType\"\n        ],\n        visitor: [\n            \"exprName\"\n        ],\n        fields: {\n            exprName: (0, _utils.validateType)([\n                \"TSEntityName\",\n                \"TSImportType\"\n            ])\n        }\n    });\n    (0, _utils.default)(\"TSTypeLiteral\", {\n        aliases: [\n            \"TSType\"\n        ],\n        visitor: [\n            \"members\"\n        ],\n        fields: {\n            members: (0, _utils.validateArrayOfType)(\"TSTypeElement\")\n        }\n    });\n    (0, _utils.default)(\"TSArrayType\", {\n        aliases: [\n            \"TSType\"\n        ],\n        visitor: [\n            \"elementType\"\n        ],\n        fields: {\n            elementType: (0, _utils.validateType)(\"TSType\")\n        }\n    });\n    (0, _utils.default)(\"TSTupleType\", {\n        aliases: [\n            \"TSType\"\n        ],\n        visitor: [\n            \"elementTypes\"\n        ],\n        fields: {\n            elementTypes: (0, _utils.validateArrayOfType)([\n                \"TSType\",\n                \"TSNamedTupleMember\"\n            ])\n        }\n    });\n    (0, _utils.default)(\"TSOptionalType\", {\n        aliases: [\n            \"TSType\"\n        ],\n        visitor: [\n            \"typeAnnotation\"\n        ],\n        fields: {\n            typeAnnotation: (0, _utils.validateType)(\"TSType\")\n        }\n    });\n    (0, _utils.default)(\"TSRestType\", {\n        aliases: [\n            \"TSType\"\n        ],\n        visitor: [\n            \"typeAnnotation\"\n        ],\n        fields: {\n            typeAnnotation: (0, _utils.validateType)(\"TSType\")\n        }\n    });\n    (0, _utils.default)(\"TSNamedTupleMember\", {\n        visitor: [\n            \"label\",\n            \"elementType\"\n        ],\n        builder: [\n            \"label\",\n            \"elementType\",\n            \"optional\"\n        ],\n        fields: {\n            label: (0, _utils.validateType)(\"Identifier\"),\n            optional: {\n                validate: bool,\n                default: false\n            },\n            elementType: (0, _utils.validateType)(\"TSType\")\n        }\n    });\n    var unionOrIntersection = {\n        aliases: [\n            \"TSType\"\n        ],\n        visitor: [\n            \"types\"\n        ],\n        fields: {\n            types: (0, _utils.validateArrayOfType)(\"TSType\")\n        }\n    };\n    (0, _utils.default)(\"TSUnionType\", unionOrIntersection);\n    (0, _utils.default)(\"TSIntersectionType\", unionOrIntersection);\n    (0, _utils.default)(\"TSConditionalType\", {\n        aliases: [\n            \"TSType\"\n        ],\n        visitor: [\n            \"checkType\",\n            \"extendsType\",\n            \"trueType\",\n            \"falseType\"\n        ],\n        fields: {\n            checkType: (0, _utils.validateType)(\"TSType\"),\n            extendsType: (0, _utils.validateType)(\"TSType\"),\n            trueType: (0, _utils.validateType)(\"TSType\"),\n            falseType: (0, _utils.validateType)(\"TSType\")\n        }\n    });\n    (0, _utils.default)(\"TSInferType\", {\n        aliases: [\n            \"TSType\"\n        ],\n        visitor: [\n            \"typeParameter\"\n        ],\n        fields: {\n            typeParameter: (0, _utils.validateType)(\"TSTypeParameter\")\n        }\n    });\n    (0, _utils.default)(\"TSParenthesizedType\", {\n        aliases: [\n            \"TSType\"\n        ],\n        visitor: [\n            \"typeAnnotation\"\n        ],\n        fields: {\n            typeAnnotation: (0, _utils.validateType)(\"TSType\")\n        }\n    });\n    (0, _utils.default)(\"TSTypeOperator\", {\n        aliases: [\n            \"TSType\"\n        ],\n        visitor: [\n            \"typeAnnotation\"\n        ],\n        fields: {\n            operator: (0, _utils.validate)((0, _utils.assertValueType)(\"string\")),\n            typeAnnotation: (0, _utils.validateType)(\"TSType\")\n        }\n    });\n    (0, _utils.default)(\"TSIndexedAccessType\", {\n        aliases: [\n            \"TSType\"\n        ],\n        visitor: [\n            \"objectType\",\n            \"indexType\"\n        ],\n        fields: {\n            objectType: (0, _utils.validateType)(\"TSType\"),\n            indexType: (0, _utils.validateType)(\"TSType\")\n        }\n    });\n    (0, _utils.default)(\"TSMappedType\", {\n        aliases: [\n            \"TSType\"\n        ],\n        visitor: [\n            \"typeParameter\",\n            \"typeAnnotation\",\n            \"nameType\"\n        ],\n        fields: {\n            readonly: (0, _utils.validateOptional)(bool),\n            typeParameter: (0, _utils.validateType)(\"TSTypeParameter\"),\n            optional: (0, _utils.validateOptional)(bool),\n            typeAnnotation: (0, _utils.validateOptionalType)(\"TSType\"),\n            nameType: (0, _utils.validateOptionalType)(\"TSType\")\n        }\n    });\n    (0, _utils.default)(\"TSLiteralType\", {\n        aliases: [\n            \"TSType\",\n            \"TSBaseType\"\n        ],\n        visitor: [\n            \"literal\"\n        ],\n        fields: {\n            literal: {\n                validate: function() {\n                    var validator = function validator(parent, key, node) {\n                        if ((0, _is.default)(\"UnaryExpression\", node)) {\n                            unaryOperator(node, \"operator\", node.operator);\n                            unaryExpression(node, \"argument\", node.argument);\n                        } else {\n                            literal(parent, key, node);\n                        }\n                    };\n                    var unaryExpression = (0, _utils.assertNodeType)(\"NumericLiteral\", \"BigIntLiteral\");\n                    var unaryOperator = (0, _utils.assertOneOf)(\"-\");\n                    var literal = (0, _utils.assertNodeType)(\"NumericLiteral\", \"StringLiteral\", \"BooleanLiteral\", \"BigIntLiteral\");\n                    validator.oneOfNodeTypes = [\n                        \"NumericLiteral\",\n                        \"StringLiteral\",\n                        \"BooleanLiteral\",\n                        \"BigIntLiteral\",\n                        \"UnaryExpression\"\n                    ];\n                    return validator;\n                }()\n            }\n        }\n    });\n    (0, _utils.default)(\"TSExpressionWithTypeArguments\", {\n        aliases: [\n            \"TSType\"\n        ],\n        visitor: [\n            \"expression\",\n            \"typeParameters\"\n        ],\n        fields: {\n            expression: (0, _utils.validateType)(\"TSEntityName\"),\n            typeParameters: (0, _utils.validateOptionalType)(\"TSTypeParameterInstantiation\")\n        }\n    });\n    (0, _utils.default)(\"TSInterfaceDeclaration\", {\n        aliases: [\n            \"Statement\",\n            \"Declaration\"\n        ],\n        visitor: [\n            \"id\",\n            \"typeParameters\",\n            \"extends\",\n            \"body\"\n        ],\n        fields: {\n            declare: (0, _utils.validateOptional)(bool),\n            id: (0, _utils.validateType)(\"Identifier\"),\n            typeParameters: (0, _utils.validateOptionalType)(\"TSTypeParameterDeclaration\"),\n            extends: (0, _utils.validateOptional)((0, _utils.arrayOfType)(\"TSExpressionWithTypeArguments\")),\n            body: (0, _utils.validateType)(\"TSInterfaceBody\")\n        }\n    });\n    (0, _utils.default)(\"TSInterfaceBody\", {\n        visitor: [\n            \"body\"\n        ],\n        fields: {\n            body: (0, _utils.validateArrayOfType)(\"TSTypeElement\")\n        }\n    });\n    (0, _utils.default)(\"TSTypeAliasDeclaration\", {\n        aliases: [\n            \"Statement\",\n            \"Declaration\"\n        ],\n        visitor: [\n            \"id\",\n            \"typeParameters\",\n            \"typeAnnotation\"\n        ],\n        fields: {\n            declare: (0, _utils.validateOptional)(bool),\n            id: (0, _utils.validateType)(\"Identifier\"),\n            typeParameters: (0, _utils.validateOptionalType)(\"TSTypeParameterDeclaration\"),\n            typeAnnotation: (0, _utils.validateType)(\"TSType\")\n        }\n    });\n    (0, _utils.default)(\"TSAsExpression\", {\n        aliases: [\n            \"Expression\"\n        ],\n        visitor: [\n            \"expression\",\n            \"typeAnnotation\"\n        ],\n        fields: {\n            expression: (0, _utils.validateType)(\"Expression\"),\n            typeAnnotation: (0, _utils.validateType)(\"TSType\")\n        }\n    });\n    (0, _utils.default)(\"TSTypeAssertion\", {\n        aliases: [\n            \"Expression\"\n        ],\n        visitor: [\n            \"typeAnnotation\",\n            \"expression\"\n        ],\n        fields: {\n            typeAnnotation: (0, _utils.validateType)(\"TSType\"),\n            expression: (0, _utils.validateType)(\"Expression\")\n        }\n    });\n    (0, _utils.default)(\"TSEnumDeclaration\", {\n        aliases: [\n            \"Statement\",\n            \"Declaration\"\n        ],\n        visitor: [\n            \"id\",\n            \"members\"\n        ],\n        fields: {\n            declare: (0, _utils.validateOptional)(bool),\n            const: (0, _utils.validateOptional)(bool),\n            id: (0, _utils.validateType)(\"Identifier\"),\n            members: (0, _utils.validateArrayOfType)(\"TSEnumMember\"),\n            initializer: (0, _utils.validateOptionalType)(\"Expression\")\n        }\n    });\n    (0, _utils.default)(\"TSEnumMember\", {\n        visitor: [\n            \"id\",\n            \"initializer\"\n        ],\n        fields: {\n            id: (0, _utils.validateType)([\n                \"Identifier\",\n                \"StringLiteral\"\n            ]),\n            initializer: (0, _utils.validateOptionalType)(\"Expression\")\n        }\n    });\n    (0, _utils.default)(\"TSModuleDeclaration\", {\n        aliases: [\n            \"Statement\",\n            \"Declaration\"\n        ],\n        visitor: [\n            \"id\",\n            \"body\"\n        ],\n        fields: {\n            declare: (0, _utils.validateOptional)(bool),\n            global: (0, _utils.validateOptional)(bool),\n            id: (0, _utils.validateType)([\n                \"Identifier\",\n                \"StringLiteral\"\n            ]),\n            body: (0, _utils.validateType)([\n                \"TSModuleBlock\",\n                \"TSModuleDeclaration\"\n            ])\n        }\n    });\n    (0, _utils.default)(\"TSModuleBlock\", {\n        aliases: [\n            \"Scopable\",\n            \"Block\",\n            \"BlockParent\"\n        ],\n        visitor: [\n            \"body\"\n        ],\n        fields: {\n            body: (0, _utils.validateArrayOfType)(\"Statement\")\n        }\n    });\n    (0, _utils.default)(\"TSImportType\", {\n        aliases: [\n            \"TSType\"\n        ],\n        visitor: [\n            \"argument\",\n            \"qualifier\",\n            \"typeParameters\"\n        ],\n        fields: {\n            argument: (0, _utils.validateType)(\"StringLiteral\"),\n            qualifier: (0, _utils.validateOptionalType)(\"TSEntityName\"),\n            typeParameters: (0, _utils.validateOptionalType)(\"TSTypeParameterInstantiation\")\n        }\n    });\n    (0, _utils.default)(\"TSImportEqualsDeclaration\", {\n        aliases: [\n            \"Statement\"\n        ],\n        visitor: [\n            \"id\",\n            \"moduleReference\"\n        ],\n        fields: {\n            isExport: (0, _utils.validate)(bool),\n            id: (0, _utils.validateType)(\"Identifier\"),\n            moduleReference: (0, _utils.validateType)([\n                \"TSEntityName\",\n                \"TSExternalModuleReference\"\n            ]),\n            importKind: {\n                validate: (0, _utils.assertOneOf)(\"type\", \"value\"),\n                optional: true\n            }\n        }\n    });\n    (0, _utils.default)(\"TSExternalModuleReference\", {\n        visitor: [\n            \"expression\"\n        ],\n        fields: {\n            expression: (0, _utils.validateType)(\"StringLiteral\")\n        }\n    });\n    (0, _utils.default)(\"TSNonNullExpression\", {\n        aliases: [\n            \"Expression\"\n        ],\n        visitor: [\n            \"expression\"\n        ],\n        fields: {\n            expression: (0, _utils.validateType)(\"Expression\")\n        }\n    });\n    (0, _utils.default)(\"TSExportAssignment\", {\n        aliases: [\n            \"Statement\"\n        ],\n        visitor: [\n            \"expression\"\n        ],\n        fields: {\n            expression: (0, _utils.validateType)(\"Expression\")\n        }\n    });\n    (0, _utils.default)(\"TSNamespaceExportDeclaration\", {\n        aliases: [\n            \"Statement\"\n        ],\n        visitor: [\n            \"id\"\n        ],\n        fields: {\n            id: (0, _utils.validateType)(\"Identifier\")\n        }\n    });\n    (0, _utils.default)(\"TSTypeAnnotation\", {\n        visitor: [\n            \"typeAnnotation\"\n        ],\n        fields: {\n            typeAnnotation: {\n                validate: (0, _utils.assertNodeType)(\"TSType\")\n            }\n        }\n    });\n    (0, _utils.default)(\"TSTypeParameterInstantiation\", {\n        visitor: [\n            \"params\"\n        ],\n        fields: {\n            params: {\n                validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"TSType\")))\n            }\n        }\n    });\n    (0, _utils.default)(\"TSTypeParameterDeclaration\", {\n        visitor: [\n            \"params\"\n        ],\n        fields: {\n            params: {\n                validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"TSTypeParameter\")))\n            }\n        }\n    });\n    (0, _utils.default)(\"TSTypeParameter\", {\n        builder: [\n            \"constraint\",\n            \"default\",\n            \"name\"\n        ],\n        visitor: [\n            \"constraint\",\n            \"default\"\n        ],\n        fields: {\n            name: {\n                validate: (0, _utils.assertValueType)(\"string\")\n            },\n            constraint: {\n                validate: (0, _utils.assertNodeType)(\"TSType\"),\n                optional: true\n            },\n            default: {\n                validate: (0, _utils.assertNodeType)(\"TSType\"),\n                optional: true\n            }\n        }\n    });\n    return typescript;\n}\n\nvar hasRequiredDefinitions;\nfunction requireDefinitions() {\n    if (hasRequiredDefinitions) return definitions;\n    hasRequiredDefinitions = 1;\n    (function(exports) {\n        Object.defineProperty(exports, \"__esModule\", {\n            value: true\n        });\n        Object.defineProperty(exports, \"VISITOR_KEYS\", {\n            enumerable: true,\n            get: function get() {\n                return _utils.VISITOR_KEYS;\n            }\n        });\n        Object.defineProperty(exports, \"ALIAS_KEYS\", {\n            enumerable: true,\n            get: function get() {\n                return _utils.ALIAS_KEYS;\n            }\n        });\n        Object.defineProperty(exports, \"FLIPPED_ALIAS_KEYS\", {\n            enumerable: true,\n            get: function get() {\n                return _utils.FLIPPED_ALIAS_KEYS;\n            }\n        });\n        Object.defineProperty(exports, \"NODE_FIELDS\", {\n            enumerable: true,\n            get: function get() {\n                return _utils.NODE_FIELDS;\n            }\n        });\n        Object.defineProperty(exports, \"BUILDER_KEYS\", {\n            enumerable: true,\n            get: function get() {\n                return _utils.BUILDER_KEYS;\n            }\n        });\n        Object.defineProperty(exports, \"DEPRECATED_KEYS\", {\n            enumerable: true,\n            get: function get() {\n                return _utils.DEPRECATED_KEYS;\n            }\n        });\n        Object.defineProperty(exports, \"NODE_PARENT_VALIDATIONS\", {\n            enumerable: true,\n            get: function get() {\n                return _utils.NODE_PARENT_VALIDATIONS;\n            }\n        });\n        Object.defineProperty(exports, \"PLACEHOLDERS\", {\n            enumerable: true,\n            get: function get() {\n                return _placeholders.PLACEHOLDERS;\n            }\n        });\n        Object.defineProperty(exports, \"PLACEHOLDERS_ALIAS\", {\n            enumerable: true,\n            get: function get() {\n                return _placeholders.PLACEHOLDERS_ALIAS;\n            }\n        });\n        Object.defineProperty(exports, \"PLACEHOLDERS_FLIPPED_ALIAS\", {\n            enumerable: true,\n            get: function get() {\n                return _placeholders.PLACEHOLDERS_FLIPPED_ALIAS;\n            }\n        });\n        exports.TYPES = void 0;\n        var _toFastProperties = requireToFastProperties();\n        requireCore();\n        requireFlow();\n        requireJsx();\n        requireMisc();\n        requireExperimental();\n        requireTypescript();\n        var _utils = requireUtils();\n        var _placeholders = requirePlaceholders();\n        _toFastProperties(_utils.VISITOR_KEYS);\n        _toFastProperties(_utils.ALIAS_KEYS);\n        _toFastProperties(_utils.FLIPPED_ALIAS_KEYS);\n        _toFastProperties(_utils.NODE_FIELDS);\n        _toFastProperties(_utils.BUILDER_KEYS);\n        _toFastProperties(_utils.DEPRECATED_KEYS);\n        _toFastProperties(_placeholders.PLACEHOLDERS_ALIAS);\n        _toFastProperties(_placeholders.PLACEHOLDERS_FLIPPED_ALIAS);\n        var TYPES = Object.keys(_utils.VISITOR_KEYS).concat(Object.keys(_utils.FLIPPED_ALIAS_KEYS)).concat(Object.keys(_utils.DEPRECATED_KEYS));\n        exports.TYPES = TYPES;\n    })(definitions);\n    return definitions;\n}\n\nfunction _createForOfIteratorHelperLoose$d(o, allowArrayLike) {\n    var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n    if (it) return (it = it.call(o)).next.bind(it);\n    if (Array.isArray(o) || (it = unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n        if (it) o = it;\n        var i = 0;\n        return function() {\n            if (i >= o.length) return {\n                done: true\n            };\n            return {\n                done: false,\n                value: o[i++]\n            };\n        };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nObject.defineProperty(builder$1, \"__esModule\", {\n    value: true\n});\nbuilder$1.default = builder;\nvar _definitions$6 = requireDefinitions();\nvar _validate = requireValidate();\nfunction builder(type) {\n    for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n        args[_key - 1] = arguments[_key];\n    }\n    var keys = _definitions$6.BUILDER_KEYS[type];\n    var countArgs = args.length;\n    if (countArgs > keys.length) {\n        throw new Error(type + \": Too many arguments passed. Received \" + countArgs + \" but can receive no more than \" + keys.length);\n    }\n    var node = {\n        type: type\n    };\n    var i = 0;\n    keys.forEach(function(key) {\n        var field = _definitions$6.NODE_FIELDS[type][key];\n        var arg;\n        if (i < countArgs) arg = args[i];\n        if (arg === undefined) {\n            arg = Array.isArray(field.default) ? [] : field.default;\n        }\n        node[key] = arg;\n        i++;\n    });\n    for(var _iterator = _createForOfIteratorHelperLoose$d(Object.keys(node)), _step; !(_step = _iterator()).done;){\n        var key = _step.value;\n        (0, _validate.default)(node, key, node[key]);\n    }\n    return node;\n}\n\nfunction _arrayLikeToArray$1(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n    return arr2;\n}\nfunction _arrayWithoutHoles$1(arr) {\n    if (Array.isArray(arr)) return _arrayLikeToArray$1(arr);\n}\nfunction _iterableToArray$1(iter) {\n    if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\nfunction _nonIterableSpread$1() {\n    throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _toConsumableArray$1(arr) {\n    return _arrayWithoutHoles$1(arr) || _iterableToArray$1(arr) || _unsupportedIterableToArray$1(arr) || _nonIterableSpread$1();\n}\nfunction _unsupportedIterableToArray$1(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray$1(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(n);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$1(o, minLen);\n}\nObject.defineProperty(generated$3, \"__esModule\", {\n    value: true\n});\ngenerated$3.arrayExpression = arrayExpression;\ngenerated$3.assignmentExpression = assignmentExpression;\ngenerated$3.binaryExpression = binaryExpression;\ngenerated$3.interpreterDirective = interpreterDirective;\ngenerated$3.directive = directive;\ngenerated$3.directiveLiteral = directiveLiteral;\ngenerated$3.blockStatement = blockStatement;\ngenerated$3.breakStatement = breakStatement;\ngenerated$3.callExpression = callExpression;\ngenerated$3.catchClause = catchClause;\ngenerated$3.conditionalExpression = conditionalExpression;\ngenerated$3.continueStatement = continueStatement;\ngenerated$3.debuggerStatement = debuggerStatement;\ngenerated$3.doWhileStatement = doWhileStatement;\ngenerated$3.emptyStatement = emptyStatement;\ngenerated$3.expressionStatement = expressionStatement;\ngenerated$3.file = file;\ngenerated$3.forInStatement = forInStatement;\ngenerated$3.forStatement = forStatement;\ngenerated$3.functionDeclaration = functionDeclaration;\ngenerated$3.functionExpression = functionExpression;\ngenerated$3.identifier = identifier;\ngenerated$3.ifStatement = ifStatement;\ngenerated$3.labeledStatement = labeledStatement;\ngenerated$3.stringLiteral = stringLiteral;\ngenerated$3.numericLiteral = numericLiteral;\ngenerated$3.nullLiteral = nullLiteral;\ngenerated$3.booleanLiteral = booleanLiteral;\ngenerated$3.regExpLiteral = regExpLiteral;\ngenerated$3.logicalExpression = logicalExpression;\ngenerated$3.memberExpression = memberExpression;\ngenerated$3.newExpression = newExpression;\ngenerated$3.program = program;\ngenerated$3.objectExpression = objectExpression;\ngenerated$3.objectMethod = objectMethod;\ngenerated$3.objectProperty = objectProperty;\ngenerated$3.restElement = restElement;\ngenerated$3.returnStatement = returnStatement;\ngenerated$3.sequenceExpression = sequenceExpression;\ngenerated$3.parenthesizedExpression = parenthesizedExpression;\ngenerated$3.switchCase = switchCase;\ngenerated$3.switchStatement = switchStatement;\ngenerated$3.thisExpression = thisExpression;\ngenerated$3.throwStatement = throwStatement;\ngenerated$3.tryStatement = tryStatement;\ngenerated$3.unaryExpression = unaryExpression;\ngenerated$3.updateExpression = updateExpression;\ngenerated$3.variableDeclaration = variableDeclaration;\ngenerated$3.variableDeclarator = variableDeclarator;\ngenerated$3.whileStatement = whileStatement;\ngenerated$3.withStatement = withStatement;\ngenerated$3.assignmentPattern = assignmentPattern;\ngenerated$3.arrayPattern = arrayPattern;\ngenerated$3.arrowFunctionExpression = arrowFunctionExpression;\ngenerated$3.classBody = classBody;\ngenerated$3.classExpression = classExpression;\ngenerated$3.classDeclaration = classDeclaration;\ngenerated$3.exportAllDeclaration = exportAllDeclaration;\ngenerated$3.exportDefaultDeclaration = exportDefaultDeclaration;\ngenerated$3.exportNamedDeclaration = exportNamedDeclaration;\ngenerated$3.exportSpecifier = exportSpecifier;\ngenerated$3.forOfStatement = forOfStatement;\ngenerated$3.importDeclaration = importDeclaration;\ngenerated$3.importDefaultSpecifier = importDefaultSpecifier;\ngenerated$3.importNamespaceSpecifier = importNamespaceSpecifier;\ngenerated$3.importSpecifier = importSpecifier;\ngenerated$3.metaProperty = metaProperty;\ngenerated$3.classMethod = classMethod;\ngenerated$3.objectPattern = objectPattern;\ngenerated$3.spreadElement = spreadElement;\ngenerated$3.super = _super;\ngenerated$3.taggedTemplateExpression = taggedTemplateExpression;\ngenerated$3.templateElement = templateElement;\ngenerated$3.templateLiteral = templateLiteral;\ngenerated$3.yieldExpression = yieldExpression;\ngenerated$3.awaitExpression = awaitExpression;\ngenerated$3.import = _import;\ngenerated$3.bigIntLiteral = bigIntLiteral;\ngenerated$3.exportNamespaceSpecifier = exportNamespaceSpecifier;\ngenerated$3.optionalMemberExpression = optionalMemberExpression;\ngenerated$3.optionalCallExpression = optionalCallExpression;\ngenerated$3.classProperty = classProperty;\ngenerated$3.classPrivateProperty = classPrivateProperty;\ngenerated$3.classPrivateMethod = classPrivateMethod;\ngenerated$3.privateName = privateName;\ngenerated$3.anyTypeAnnotation = anyTypeAnnotation;\ngenerated$3.arrayTypeAnnotation = arrayTypeAnnotation;\ngenerated$3.booleanTypeAnnotation = booleanTypeAnnotation;\ngenerated$3.booleanLiteralTypeAnnotation = booleanLiteralTypeAnnotation;\ngenerated$3.nullLiteralTypeAnnotation = nullLiteralTypeAnnotation;\ngenerated$3.classImplements = classImplements;\ngenerated$3.declareClass = declareClass;\ngenerated$3.declareFunction = declareFunction;\ngenerated$3.declareInterface = declareInterface;\ngenerated$3.declareModule = declareModule;\ngenerated$3.declareModuleExports = declareModuleExports;\ngenerated$3.declareTypeAlias = declareTypeAlias;\ngenerated$3.declareOpaqueType = declareOpaqueType;\ngenerated$3.declareVariable = declareVariable;\ngenerated$3.declareExportDeclaration = declareExportDeclaration;\ngenerated$3.declareExportAllDeclaration = declareExportAllDeclaration;\ngenerated$3.declaredPredicate = declaredPredicate;\ngenerated$3.existsTypeAnnotation = existsTypeAnnotation;\ngenerated$3.functionTypeAnnotation = functionTypeAnnotation;\ngenerated$3.functionTypeParam = functionTypeParam;\ngenerated$3.genericTypeAnnotation = genericTypeAnnotation;\ngenerated$3.inferredPredicate = inferredPredicate;\ngenerated$3.interfaceExtends = interfaceExtends;\ngenerated$3.interfaceDeclaration = interfaceDeclaration;\ngenerated$3.interfaceTypeAnnotation = interfaceTypeAnnotation;\ngenerated$3.intersectionTypeAnnotation = intersectionTypeAnnotation;\ngenerated$3.mixedTypeAnnotation = mixedTypeAnnotation;\ngenerated$3.emptyTypeAnnotation = emptyTypeAnnotation;\ngenerated$3.nullableTypeAnnotation = nullableTypeAnnotation;\ngenerated$3.numberLiteralTypeAnnotation = numberLiteralTypeAnnotation;\ngenerated$3.numberTypeAnnotation = numberTypeAnnotation;\ngenerated$3.objectTypeAnnotation = objectTypeAnnotation;\ngenerated$3.objectTypeInternalSlot = objectTypeInternalSlot;\ngenerated$3.objectTypeCallProperty = objectTypeCallProperty;\ngenerated$3.objectTypeIndexer = objectTypeIndexer;\ngenerated$3.objectTypeProperty = objectTypeProperty;\ngenerated$3.objectTypeSpreadProperty = objectTypeSpreadProperty;\ngenerated$3.opaqueType = opaqueType;\ngenerated$3.qualifiedTypeIdentifier = qualifiedTypeIdentifier;\ngenerated$3.stringLiteralTypeAnnotation = stringLiteralTypeAnnotation;\ngenerated$3.stringTypeAnnotation = stringTypeAnnotation;\ngenerated$3.symbolTypeAnnotation = symbolTypeAnnotation;\ngenerated$3.thisTypeAnnotation = thisTypeAnnotation;\ngenerated$3.tupleTypeAnnotation = tupleTypeAnnotation;\ngenerated$3.typeofTypeAnnotation = typeofTypeAnnotation;\ngenerated$3.typeAlias = typeAlias;\ngenerated$3.typeAnnotation = typeAnnotation;\ngenerated$3.typeCastExpression = typeCastExpression;\ngenerated$3.typeParameter = typeParameter;\ngenerated$3.typeParameterDeclaration = typeParameterDeclaration;\ngenerated$3.typeParameterInstantiation = typeParameterInstantiation;\ngenerated$3.unionTypeAnnotation = unionTypeAnnotation;\ngenerated$3.variance = variance;\ngenerated$3.voidTypeAnnotation = voidTypeAnnotation;\ngenerated$3.enumDeclaration = enumDeclaration;\ngenerated$3.enumBooleanBody = enumBooleanBody;\ngenerated$3.enumNumberBody = enumNumberBody;\ngenerated$3.enumStringBody = enumStringBody;\ngenerated$3.enumSymbolBody = enumSymbolBody;\ngenerated$3.enumBooleanMember = enumBooleanMember;\ngenerated$3.enumNumberMember = enumNumberMember;\ngenerated$3.enumStringMember = enumStringMember;\ngenerated$3.enumDefaultedMember = enumDefaultedMember;\ngenerated$3.indexedAccessType = indexedAccessType;\ngenerated$3.optionalIndexedAccessType = optionalIndexedAccessType;\ngenerated$3.jSXAttribute = generated$3.jsxAttribute = jsxAttribute;\ngenerated$3.jSXClosingElement = generated$3.jsxClosingElement = jsxClosingElement;\ngenerated$3.jSXElement = generated$3.jsxElement = jsxElement;\ngenerated$3.jSXEmptyExpression = generated$3.jsxEmptyExpression = jsxEmptyExpression;\ngenerated$3.jSXExpressionContainer = generated$3.jsxExpressionContainer = jsxExpressionContainer;\ngenerated$3.jSXSpreadChild = generated$3.jsxSpreadChild = jsxSpreadChild;\ngenerated$3.jSXIdentifier = generated$3.jsxIdentifier = jsxIdentifier;\ngenerated$3.jSXMemberExpression = generated$3.jsxMemberExpression = jsxMemberExpression;\ngenerated$3.jSXNamespacedName = generated$3.jsxNamespacedName = jsxNamespacedName;\ngenerated$3.jSXOpeningElement = generated$3.jsxOpeningElement = jsxOpeningElement;\ngenerated$3.jSXSpreadAttribute = generated$3.jsxSpreadAttribute = jsxSpreadAttribute;\ngenerated$3.jSXText = generated$3.jsxText = jsxText;\ngenerated$3.jSXFragment = generated$3.jsxFragment = jsxFragment;\ngenerated$3.jSXOpeningFragment = generated$3.jsxOpeningFragment = jsxOpeningFragment;\ngenerated$3.jSXClosingFragment = generated$3.jsxClosingFragment = jsxClosingFragment;\ngenerated$3.noop = noop;\ngenerated$3.placeholder = placeholder;\ngenerated$3.v8IntrinsicIdentifier = v8IntrinsicIdentifier;\ngenerated$3.argumentPlaceholder = argumentPlaceholder;\ngenerated$3.bindExpression = bindExpression;\ngenerated$3.importAttribute = importAttribute;\ngenerated$3.decorator = decorator;\ngenerated$3.doExpression = doExpression;\ngenerated$3.exportDefaultSpecifier = exportDefaultSpecifier;\ngenerated$3.recordExpression = recordExpression;\ngenerated$3.tupleExpression = tupleExpression;\ngenerated$3.decimalLiteral = decimalLiteral;\ngenerated$3.staticBlock = staticBlock;\ngenerated$3.moduleExpression = moduleExpression;\ngenerated$3.topicReference = topicReference;\ngenerated$3.pipelineTopicExpression = pipelineTopicExpression;\ngenerated$3.pipelineBareFunction = pipelineBareFunction;\ngenerated$3.pipelinePrimaryTopicReference = pipelinePrimaryTopicReference;\ngenerated$3.tSParameterProperty = generated$3.tsParameterProperty = tsParameterProperty;\ngenerated$3.tSDeclareFunction = generated$3.tsDeclareFunction = tsDeclareFunction;\ngenerated$3.tSDeclareMethod = generated$3.tsDeclareMethod = tsDeclareMethod;\ngenerated$3.tSQualifiedName = generated$3.tsQualifiedName = tsQualifiedName;\ngenerated$3.tSCallSignatureDeclaration = generated$3.tsCallSignatureDeclaration = tsCallSignatureDeclaration;\ngenerated$3.tSConstructSignatureDeclaration = generated$3.tsConstructSignatureDeclaration = tsConstructSignatureDeclaration;\ngenerated$3.tSPropertySignature = generated$3.tsPropertySignature = tsPropertySignature;\ngenerated$3.tSMethodSignature = generated$3.tsMethodSignature = tsMethodSignature;\ngenerated$3.tSIndexSignature = generated$3.tsIndexSignature = tsIndexSignature;\ngenerated$3.tSAnyKeyword = generated$3.tsAnyKeyword = tsAnyKeyword;\ngenerated$3.tSBooleanKeyword = generated$3.tsBooleanKeyword = tsBooleanKeyword;\ngenerated$3.tSBigIntKeyword = generated$3.tsBigIntKeyword = tsBigIntKeyword;\ngenerated$3.tSIntrinsicKeyword = generated$3.tsIntrinsicKeyword = tsIntrinsicKeyword;\ngenerated$3.tSNeverKeyword = generated$3.tsNeverKeyword = tsNeverKeyword;\ngenerated$3.tSNullKeyword = generated$3.tsNullKeyword = tsNullKeyword;\ngenerated$3.tSNumberKeyword = generated$3.tsNumberKeyword = tsNumberKeyword;\ngenerated$3.tSObjectKeyword = generated$3.tsObjectKeyword = tsObjectKeyword;\ngenerated$3.tSStringKeyword = generated$3.tsStringKeyword = tsStringKeyword;\ngenerated$3.tSSymbolKeyword = generated$3.tsSymbolKeyword = tsSymbolKeyword;\ngenerated$3.tSUndefinedKeyword = generated$3.tsUndefinedKeyword = tsUndefinedKeyword;\ngenerated$3.tSUnknownKeyword = generated$3.tsUnknownKeyword = tsUnknownKeyword;\ngenerated$3.tSVoidKeyword = generated$3.tsVoidKeyword = tsVoidKeyword;\ngenerated$3.tSThisType = generated$3.tsThisType = tsThisType;\ngenerated$3.tSFunctionType = generated$3.tsFunctionType = tsFunctionType;\ngenerated$3.tSConstructorType = generated$3.tsConstructorType = tsConstructorType;\ngenerated$3.tSTypeReference = generated$3.tsTypeReference = tsTypeReference;\ngenerated$3.tSTypePredicate = generated$3.tsTypePredicate = tsTypePredicate;\ngenerated$3.tSTypeQuery = generated$3.tsTypeQuery = tsTypeQuery;\ngenerated$3.tSTypeLiteral = generated$3.tsTypeLiteral = tsTypeLiteral;\ngenerated$3.tSArrayType = generated$3.tsArrayType = tsArrayType;\ngenerated$3.tSTupleType = generated$3.tsTupleType = tsTupleType;\ngenerated$3.tSOptionalType = generated$3.tsOptionalType = tsOptionalType;\ngenerated$3.tSRestType = generated$3.tsRestType = tsRestType;\ngenerated$3.tSNamedTupleMember = generated$3.tsNamedTupleMember = tsNamedTupleMember;\ngenerated$3.tSUnionType = generated$3.tsUnionType = tsUnionType;\ngenerated$3.tSIntersectionType = generated$3.tsIntersectionType = tsIntersectionType;\ngenerated$3.tSConditionalType = generated$3.tsConditionalType = tsConditionalType;\ngenerated$3.tSInferType = generated$3.tsInferType = tsInferType;\ngenerated$3.tSParenthesizedType = generated$3.tsParenthesizedType = tsParenthesizedType;\ngenerated$3.tSTypeOperator = generated$3.tsTypeOperator = tsTypeOperator;\ngenerated$3.tSIndexedAccessType = generated$3.tsIndexedAccessType = tsIndexedAccessType;\ngenerated$3.tSMappedType = generated$3.tsMappedType = tsMappedType;\ngenerated$3.tSLiteralType = generated$3.tsLiteralType = tsLiteralType;\ngenerated$3.tSExpressionWithTypeArguments = generated$3.tsExpressionWithTypeArguments = tsExpressionWithTypeArguments;\ngenerated$3.tSInterfaceDeclaration = generated$3.tsInterfaceDeclaration = tsInterfaceDeclaration;\ngenerated$3.tSInterfaceBody = generated$3.tsInterfaceBody = tsInterfaceBody;\ngenerated$3.tSTypeAliasDeclaration = generated$3.tsTypeAliasDeclaration = tsTypeAliasDeclaration;\ngenerated$3.tSAsExpression = generated$3.tsAsExpression = tsAsExpression;\ngenerated$3.tSTypeAssertion = generated$3.tsTypeAssertion = tsTypeAssertion;\ngenerated$3.tSEnumDeclaration = generated$3.tsEnumDeclaration = tsEnumDeclaration;\ngenerated$3.tSEnumMember = generated$3.tsEnumMember = tsEnumMember;\ngenerated$3.tSModuleDeclaration = generated$3.tsModuleDeclaration = tsModuleDeclaration;\ngenerated$3.tSModuleBlock = generated$3.tsModuleBlock = tsModuleBlock;\ngenerated$3.tSImportType = generated$3.tsImportType = tsImportType;\ngenerated$3.tSImportEqualsDeclaration = generated$3.tsImportEqualsDeclaration = tsImportEqualsDeclaration;\ngenerated$3.tSExternalModuleReference = generated$3.tsExternalModuleReference = tsExternalModuleReference;\ngenerated$3.tSNonNullExpression = generated$3.tsNonNullExpression = tsNonNullExpression;\ngenerated$3.tSExportAssignment = generated$3.tsExportAssignment = tsExportAssignment;\ngenerated$3.tSNamespaceExportDeclaration = generated$3.tsNamespaceExportDeclaration = tsNamespaceExportDeclaration;\ngenerated$3.tSTypeAnnotation = generated$3.tsTypeAnnotation = tsTypeAnnotation;\ngenerated$3.tSTypeParameterInstantiation = generated$3.tsTypeParameterInstantiation = tsTypeParameterInstantiation;\ngenerated$3.tSTypeParameterDeclaration = generated$3.tsTypeParameterDeclaration = tsTypeParameterDeclaration;\ngenerated$3.tSTypeParameter = generated$3.tsTypeParameter = tsTypeParameter;\ngenerated$3.numberLiteral = NumberLiteral;\ngenerated$3.regexLiteral = RegexLiteral;\ngenerated$3.restProperty = RestProperty;\ngenerated$3.spreadProperty = SpreadProperty;\nvar _builder = builder$1;\nfunction arrayExpression(elements) {\n    return (_builder.default).apply(this, [\n        \"ArrayExpression\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction assignmentExpression(operator, left, right) {\n    return (_builder.default).apply(this, [\n        \"AssignmentExpression\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction binaryExpression(operator, left, right) {\n    return (_builder.default).apply(this, [\n        \"BinaryExpression\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction interpreterDirective(value) {\n    return (_builder.default).apply(this, [\n        \"InterpreterDirective\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction directive(value) {\n    return (_builder.default).apply(this, [\n        \"Directive\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction directiveLiteral(value) {\n    return (_builder.default).apply(this, [\n        \"DirectiveLiteral\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction blockStatement(body, directives) {\n    return (_builder.default).apply(this, [\n        \"BlockStatement\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction breakStatement(label) {\n    return (_builder.default).apply(this, [\n        \"BreakStatement\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction callExpression(callee, _arguments) {\n    return (_builder.default).apply(this, [\n        \"CallExpression\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction catchClause(param, body) {\n    return (_builder.default).apply(this, [\n        \"CatchClause\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction conditionalExpression(test, consequent, alternate) {\n    return (_builder.default).apply(this, [\n        \"ConditionalExpression\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction continueStatement(label) {\n    return (_builder.default).apply(this, [\n        \"ContinueStatement\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction debuggerStatement() {\n    return (_builder.default).apply(this, [\n        \"DebuggerStatement\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction doWhileStatement(test, body) {\n    return (_builder.default).apply(this, [\n        \"DoWhileStatement\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction emptyStatement() {\n    return (_builder.default).apply(this, [\n        \"EmptyStatement\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction expressionStatement(expression) {\n    return (_builder.default).apply(this, [\n        \"ExpressionStatement\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction file(program, comments, tokens) {\n    return (_builder.default).apply(this, [\n        \"File\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction forInStatement(left, right, body) {\n    return (_builder.default).apply(this, [\n        \"ForInStatement\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction forStatement(init, test, update, body) {\n    return (_builder.default).apply(this, [\n        \"ForStatement\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction functionDeclaration(id, params, body, generator, async) {\n    return (_builder.default).apply(this, [\n        \"FunctionDeclaration\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction functionExpression(id, params, body, generator, async) {\n    return (_builder.default).apply(this, [\n        \"FunctionExpression\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction identifier(name) {\n    return (_builder.default).apply(this, [\n        \"Identifier\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction ifStatement(test, consequent, alternate) {\n    return (_builder.default).apply(this, [\n        \"IfStatement\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction labeledStatement(label, body) {\n    return (_builder.default).apply(this, [\n        \"LabeledStatement\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction stringLiteral(value) {\n    return (_builder.default).apply(this, [\n        \"StringLiteral\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction numericLiteral(value) {\n    return (_builder.default).apply(this, [\n        \"NumericLiteral\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction nullLiteral() {\n    return (_builder.default).apply(this, [\n        \"NullLiteral\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction booleanLiteral(value) {\n    return (_builder.default).apply(this, [\n        \"BooleanLiteral\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction regExpLiteral(pattern, flags) {\n    return (_builder.default).apply(this, [\n        \"RegExpLiteral\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction logicalExpression(operator, left, right) {\n    return (_builder.default).apply(this, [\n        \"LogicalExpression\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction memberExpression(object, property, computed, optional) {\n    return (_builder.default).apply(this, [\n        \"MemberExpression\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction newExpression(callee, _arguments) {\n    return (_builder.default).apply(this, [\n        \"NewExpression\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction program(body, directives, sourceType, interpreter) {\n    return (_builder.default).apply(this, [\n        \"Program\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction objectExpression(properties) {\n    return (_builder.default).apply(this, [\n        \"ObjectExpression\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction objectMethod(kind, key, params, body, computed, generator, async) {\n    return (_builder.default).apply(this, [\n        \"ObjectMethod\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction objectProperty(key, value, computed, shorthand, decorators) {\n    return (_builder.default).apply(this, [\n        \"ObjectProperty\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction restElement(argument) {\n    return (_builder.default).apply(this, [\n        \"RestElement\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction returnStatement(argument) {\n    return (_builder.default).apply(this, [\n        \"ReturnStatement\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction sequenceExpression(expressions) {\n    return (_builder.default).apply(this, [\n        \"SequenceExpression\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction parenthesizedExpression(expression) {\n    return (_builder.default).apply(this, [\n        \"ParenthesizedExpression\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction switchCase(test, consequent) {\n    return (_builder.default).apply(this, [\n        \"SwitchCase\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction switchStatement(discriminant, cases) {\n    return (_builder.default).apply(this, [\n        \"SwitchStatement\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction thisExpression() {\n    return (_builder.default).apply(this, [\n        \"ThisExpression\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction throwStatement(argument) {\n    return (_builder.default).apply(this, [\n        \"ThrowStatement\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction tryStatement(block, handler, finalizer) {\n    return (_builder.default).apply(this, [\n        \"TryStatement\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction unaryExpression(operator, argument, prefix) {\n    return (_builder.default).apply(this, [\n        \"UnaryExpression\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction updateExpression(operator, argument, prefix) {\n    return (_builder.default).apply(this, [\n        \"UpdateExpression\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction variableDeclaration(kind, declarations) {\n    return (_builder.default).apply(this, [\n        \"VariableDeclaration\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction variableDeclarator(id, init) {\n    return (_builder.default).apply(this, [\n        \"VariableDeclarator\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction whileStatement(test, body) {\n    return (_builder.default).apply(this, [\n        \"WhileStatement\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction withStatement(object, body) {\n    return (_builder.default).apply(this, [\n        \"WithStatement\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction assignmentPattern(left, right) {\n    return (_builder.default).apply(this, [\n        \"AssignmentPattern\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction arrayPattern(elements) {\n    return (_builder.default).apply(this, [\n        \"ArrayPattern\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction arrowFunctionExpression(params, body, async) {\n    return (_builder.default).apply(this, [\n        \"ArrowFunctionExpression\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction classBody(body) {\n    return (_builder.default).apply(this, [\n        \"ClassBody\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction classExpression(id, superClass, body, decorators) {\n    return (_builder.default).apply(this, [\n        \"ClassExpression\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction classDeclaration(id, superClass, body, decorators) {\n    return (_builder.default).apply(this, [\n        \"ClassDeclaration\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction exportAllDeclaration(source) {\n    return (_builder.default).apply(this, [\n        \"ExportAllDeclaration\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction exportDefaultDeclaration(declaration) {\n    return (_builder.default).apply(this, [\n        \"ExportDefaultDeclaration\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction exportNamedDeclaration(declaration, specifiers, source) {\n    return (_builder.default).apply(this, [\n        \"ExportNamedDeclaration\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction exportSpecifier(local, exported) {\n    return (_builder.default).apply(this, [\n        \"ExportSpecifier\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction forOfStatement(left, right, body, _await) {\n    return (_builder.default).apply(this, [\n        \"ForOfStatement\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction importDeclaration(specifiers, source) {\n    return (_builder.default).apply(this, [\n        \"ImportDeclaration\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction importDefaultSpecifier(local) {\n    return (_builder.default).apply(this, [\n        \"ImportDefaultSpecifier\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction importNamespaceSpecifier(local) {\n    return (_builder.default).apply(this, [\n        \"ImportNamespaceSpecifier\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction importSpecifier(local, imported) {\n    return (_builder.default).apply(this, [\n        \"ImportSpecifier\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction metaProperty(meta, property) {\n    return (_builder.default).apply(this, [\n        \"MetaProperty\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction classMethod(kind, key, params, body, computed, _static, generator, async) {\n    return (_builder.default).apply(this, [\n        \"ClassMethod\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction objectPattern(properties) {\n    return (_builder.default).apply(this, [\n        \"ObjectPattern\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction spreadElement(argument) {\n    return (_builder.default).apply(this, [\n        \"SpreadElement\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction _super() {\n    return (_builder.default).apply(this, [\n        \"Super\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction taggedTemplateExpression(tag, quasi) {\n    return (_builder.default).apply(this, [\n        \"TaggedTemplateExpression\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction templateElement(value, tail) {\n    return (_builder.default).apply(this, [\n        \"TemplateElement\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction templateLiteral(quasis, expressions) {\n    return (_builder.default).apply(this, [\n        \"TemplateLiteral\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction yieldExpression(argument, delegate) {\n    return (_builder.default).apply(this, [\n        \"YieldExpression\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction awaitExpression(argument) {\n    return (_builder.default).apply(this, [\n        \"AwaitExpression\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction _import() {\n    return (_builder.default).apply(this, [\n        \"Import\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction bigIntLiteral(value) {\n    return (_builder.default).apply(this, [\n        \"BigIntLiteral\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction exportNamespaceSpecifier(exported) {\n    return (_builder.default).apply(this, [\n        \"ExportNamespaceSpecifier\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction optionalMemberExpression(object, property, computed, optional) {\n    return (_builder.default).apply(this, [\n        \"OptionalMemberExpression\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction optionalCallExpression(callee, _arguments, optional) {\n    return (_builder.default).apply(this, [\n        \"OptionalCallExpression\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction classProperty(key, value, typeAnnotation, decorators, computed, _static) {\n    return (_builder.default).apply(this, [\n        \"ClassProperty\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction classPrivateProperty(key, value, decorators, _static) {\n    return (_builder.default).apply(this, [\n        \"ClassPrivateProperty\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction classPrivateMethod(kind, key, params, body, _static) {\n    return (_builder.default).apply(this, [\n        \"ClassPrivateMethod\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction privateName(id) {\n    return (_builder.default).apply(this, [\n        \"PrivateName\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction anyTypeAnnotation() {\n    return (_builder.default).apply(this, [\n        \"AnyTypeAnnotation\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction arrayTypeAnnotation(elementType) {\n    return (_builder.default).apply(this, [\n        \"ArrayTypeAnnotation\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction booleanTypeAnnotation() {\n    return (_builder.default).apply(this, [\n        \"BooleanTypeAnnotation\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction booleanLiteralTypeAnnotation(value) {\n    return (_builder.default).apply(this, [\n        \"BooleanLiteralTypeAnnotation\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction nullLiteralTypeAnnotation() {\n    return (_builder.default).apply(this, [\n        \"NullLiteralTypeAnnotation\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction classImplements(id, typeParameters) {\n    return (_builder.default).apply(this, [\n        \"ClassImplements\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction declareClass(id, typeParameters, _extends, body) {\n    return (_builder.default).apply(this, [\n        \"DeclareClass\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction declareFunction(id) {\n    return (_builder.default).apply(this, [\n        \"DeclareFunction\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction declareInterface(id, typeParameters, _extends, body) {\n    return (_builder.default).apply(this, [\n        \"DeclareInterface\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction declareModule(id, body, kind) {\n    return (_builder.default).apply(this, [\n        \"DeclareModule\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction declareModuleExports(typeAnnotation) {\n    return (_builder.default).apply(this, [\n        \"DeclareModuleExports\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction declareTypeAlias(id, typeParameters, right) {\n    return (_builder.default).apply(this, [\n        \"DeclareTypeAlias\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction declareOpaqueType(id, typeParameters, supertype) {\n    return (_builder.default).apply(this, [\n        \"DeclareOpaqueType\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction declareVariable(id) {\n    return (_builder.default).apply(this, [\n        \"DeclareVariable\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction declareExportDeclaration(declaration, specifiers, source) {\n    return (_builder.default).apply(this, [\n        \"DeclareExportDeclaration\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction declareExportAllDeclaration(source) {\n    return (_builder.default).apply(this, [\n        \"DeclareExportAllDeclaration\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction declaredPredicate(value) {\n    return (_builder.default).apply(this, [\n        \"DeclaredPredicate\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction existsTypeAnnotation() {\n    return (_builder.default).apply(this, [\n        \"ExistsTypeAnnotation\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction functionTypeAnnotation(typeParameters, params, rest, returnType) {\n    return (_builder.default).apply(this, [\n        \"FunctionTypeAnnotation\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction functionTypeParam(name, typeAnnotation) {\n    return (_builder.default).apply(this, [\n        \"FunctionTypeParam\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction genericTypeAnnotation(id, typeParameters) {\n    return (_builder.default).apply(this, [\n        \"GenericTypeAnnotation\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction inferredPredicate() {\n    return (_builder.default).apply(this, [\n        \"InferredPredicate\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction interfaceExtends(id, typeParameters) {\n    return (_builder.default).apply(this, [\n        \"InterfaceExtends\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction interfaceDeclaration(id, typeParameters, _extends, body) {\n    return (_builder.default).apply(this, [\n        \"InterfaceDeclaration\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction interfaceTypeAnnotation(_extends, body) {\n    return (_builder.default).apply(this, [\n        \"InterfaceTypeAnnotation\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction intersectionTypeAnnotation(types) {\n    return (_builder.default).apply(this, [\n        \"IntersectionTypeAnnotation\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction mixedTypeAnnotation() {\n    return (_builder.default).apply(this, [\n        \"MixedTypeAnnotation\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction emptyTypeAnnotation() {\n    return (_builder.default).apply(this, [\n        \"EmptyTypeAnnotation\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction nullableTypeAnnotation(typeAnnotation) {\n    return (_builder.default).apply(this, [\n        \"NullableTypeAnnotation\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction numberLiteralTypeAnnotation(value) {\n    return (_builder.default).apply(this, [\n        \"NumberLiteralTypeAnnotation\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction numberTypeAnnotation() {\n    return (_builder.default).apply(this, [\n        \"NumberTypeAnnotation\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction objectTypeAnnotation(properties, indexers, callProperties, internalSlots, exact) {\n    return (_builder.default).apply(this, [\n        \"ObjectTypeAnnotation\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction objectTypeInternalSlot(id, value, optional, _static, method) {\n    return (_builder.default).apply(this, [\n        \"ObjectTypeInternalSlot\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction objectTypeCallProperty(value) {\n    return (_builder.default).apply(this, [\n        \"ObjectTypeCallProperty\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction objectTypeIndexer(id, key, value, variance) {\n    return (_builder.default).apply(this, [\n        \"ObjectTypeIndexer\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction objectTypeProperty(key, value, variance) {\n    return (_builder.default).apply(this, [\n        \"ObjectTypeProperty\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction objectTypeSpreadProperty(argument) {\n    return (_builder.default).apply(this, [\n        \"ObjectTypeSpreadProperty\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction opaqueType(id, typeParameters, supertype, impltype) {\n    return (_builder.default).apply(this, [\n        \"OpaqueType\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction qualifiedTypeIdentifier(id, qualification) {\n    return (_builder.default).apply(this, [\n        \"QualifiedTypeIdentifier\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction stringLiteralTypeAnnotation(value) {\n    return (_builder.default).apply(this, [\n        \"StringLiteralTypeAnnotation\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction stringTypeAnnotation() {\n    return (_builder.default).apply(this, [\n        \"StringTypeAnnotation\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction symbolTypeAnnotation() {\n    return (_builder.default).apply(this, [\n        \"SymbolTypeAnnotation\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction thisTypeAnnotation() {\n    return (_builder.default).apply(this, [\n        \"ThisTypeAnnotation\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction tupleTypeAnnotation(types) {\n    return (_builder.default).apply(this, [\n        \"TupleTypeAnnotation\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction typeofTypeAnnotation(argument) {\n    return (_builder.default).apply(this, [\n        \"TypeofTypeAnnotation\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction typeAlias(id, typeParameters, right) {\n    return (_builder.default).apply(this, [\n        \"TypeAlias\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction typeAnnotation(typeAnnotation) {\n    return (_builder.default).apply(this, [\n        \"TypeAnnotation\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction typeCastExpression(expression, typeAnnotation) {\n    return (_builder.default).apply(this, [\n        \"TypeCastExpression\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction typeParameter(bound, _default, variance) {\n    return (_builder.default).apply(this, [\n        \"TypeParameter\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction typeParameterDeclaration(params) {\n    return (_builder.default).apply(this, [\n        \"TypeParameterDeclaration\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction typeParameterInstantiation(params) {\n    return (_builder.default).apply(this, [\n        \"TypeParameterInstantiation\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction unionTypeAnnotation(types) {\n    return (_builder.default).apply(this, [\n        \"UnionTypeAnnotation\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction variance(kind) {\n    return (_builder.default).apply(this, [\n        \"Variance\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction voidTypeAnnotation() {\n    return (_builder.default).apply(this, [\n        \"VoidTypeAnnotation\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction enumDeclaration(id, body) {\n    return (_builder.default).apply(this, [\n        \"EnumDeclaration\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction enumBooleanBody(members) {\n    return (_builder.default).apply(this, [\n        \"EnumBooleanBody\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction enumNumberBody(members) {\n    return (_builder.default).apply(this, [\n        \"EnumNumberBody\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction enumStringBody(members) {\n    return (_builder.default).apply(this, [\n        \"EnumStringBody\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction enumSymbolBody(members) {\n    return (_builder.default).apply(this, [\n        \"EnumSymbolBody\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction enumBooleanMember(id) {\n    return (_builder.default).apply(this, [\n        \"EnumBooleanMember\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction enumNumberMember(id, init) {\n    return (_builder.default).apply(this, [\n        \"EnumNumberMember\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction enumStringMember(id, init) {\n    return (_builder.default).apply(this, [\n        \"EnumStringMember\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction enumDefaultedMember(id) {\n    return (_builder.default).apply(this, [\n        \"EnumDefaultedMember\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction indexedAccessType(objectType, indexType) {\n    return (_builder.default).apply(this, [\n        \"IndexedAccessType\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction optionalIndexedAccessType(objectType, indexType) {\n    return (_builder.default).apply(this, [\n        \"OptionalIndexedAccessType\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction jsxAttribute(name, value) {\n    return (_builder.default).apply(this, [\n        \"JSXAttribute\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction jsxClosingElement(name) {\n    return (_builder.default).apply(this, [\n        \"JSXClosingElement\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction jsxElement(openingElement, closingElement, children, selfClosing) {\n    return (_builder.default).apply(this, [\n        \"JSXElement\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction jsxEmptyExpression() {\n    return (_builder.default).apply(this, [\n        \"JSXEmptyExpression\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction jsxExpressionContainer(expression) {\n    return (_builder.default).apply(this, [\n        \"JSXExpressionContainer\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction jsxSpreadChild(expression) {\n    return (_builder.default).apply(this, [\n        \"JSXSpreadChild\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction jsxIdentifier(name) {\n    return (_builder.default).apply(this, [\n        \"JSXIdentifier\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction jsxMemberExpression(object, property) {\n    return (_builder.default).apply(this, [\n        \"JSXMemberExpression\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction jsxNamespacedName(namespace, name) {\n    return (_builder.default).apply(this, [\n        \"JSXNamespacedName\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction jsxOpeningElement(name, attributes, selfClosing) {\n    return (_builder.default).apply(this, [\n        \"JSXOpeningElement\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction jsxSpreadAttribute(argument) {\n    return (_builder.default).apply(this, [\n        \"JSXSpreadAttribute\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction jsxText(value) {\n    return (_builder.default).apply(this, [\n        \"JSXText\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction jsxFragment(openingFragment, closingFragment, children) {\n    return (_builder.default).apply(this, [\n        \"JSXFragment\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction jsxOpeningFragment() {\n    return (_builder.default).apply(this, [\n        \"JSXOpeningFragment\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction jsxClosingFragment() {\n    return (_builder.default).apply(this, [\n        \"JSXClosingFragment\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction noop() {\n    return (_builder.default).apply(this, [\n        \"Noop\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction placeholder(expectedNode, name) {\n    return (_builder.default).apply(this, [\n        \"Placeholder\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction v8IntrinsicIdentifier(name) {\n    return (_builder.default).apply(this, [\n        \"V8IntrinsicIdentifier\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction argumentPlaceholder() {\n    return (_builder.default).apply(this, [\n        \"ArgumentPlaceholder\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction bindExpression(object, callee) {\n    return (_builder.default).apply(this, [\n        \"BindExpression\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction importAttribute(key, value) {\n    return (_builder.default).apply(this, [\n        \"ImportAttribute\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction decorator(expression) {\n    return (_builder.default).apply(this, [\n        \"Decorator\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction doExpression(body, async) {\n    return (_builder.default).apply(this, [\n        \"DoExpression\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction exportDefaultSpecifier(exported) {\n    return (_builder.default).apply(this, [\n        \"ExportDefaultSpecifier\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction recordExpression(properties) {\n    return (_builder.default).apply(this, [\n        \"RecordExpression\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction tupleExpression(elements) {\n    return (_builder.default).apply(this, [\n        \"TupleExpression\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction decimalLiteral(value) {\n    return (_builder.default).apply(this, [\n        \"DecimalLiteral\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction staticBlock(body) {\n    return (_builder.default).apply(this, [\n        \"StaticBlock\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction moduleExpression(body) {\n    return (_builder.default).apply(this, [\n        \"ModuleExpression\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction topicReference() {\n    return (_builder.default).apply(this, [\n        \"TopicReference\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction pipelineTopicExpression(expression) {\n    return (_builder.default).apply(this, [\n        \"PipelineTopicExpression\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction pipelineBareFunction(callee) {\n    return (_builder.default).apply(this, [\n        \"PipelineBareFunction\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction pipelinePrimaryTopicReference() {\n    return (_builder.default).apply(this, [\n        \"PipelinePrimaryTopicReference\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction tsParameterProperty(parameter) {\n    return (_builder.default).apply(this, [\n        \"TSParameterProperty\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction tsDeclareFunction(id, typeParameters, params, returnType) {\n    return (_builder.default).apply(this, [\n        \"TSDeclareFunction\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction tsDeclareMethod(decorators, key, typeParameters, params, returnType) {\n    return (_builder.default).apply(this, [\n        \"TSDeclareMethod\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction tsQualifiedName(left, right) {\n    return (_builder.default).apply(this, [\n        \"TSQualifiedName\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction tsCallSignatureDeclaration(typeParameters, parameters, typeAnnotation) {\n    return (_builder.default).apply(this, [\n        \"TSCallSignatureDeclaration\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction tsConstructSignatureDeclaration(typeParameters, parameters, typeAnnotation) {\n    return (_builder.default).apply(this, [\n        \"TSConstructSignatureDeclaration\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction tsPropertySignature(key, typeAnnotation, initializer) {\n    return (_builder.default).apply(this, [\n        \"TSPropertySignature\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction tsMethodSignature(key, typeParameters, parameters, typeAnnotation) {\n    return (_builder.default).apply(this, [\n        \"TSMethodSignature\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction tsIndexSignature(parameters, typeAnnotation) {\n    return (_builder.default).apply(this, [\n        \"TSIndexSignature\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction tsAnyKeyword() {\n    return (_builder.default).apply(this, [\n        \"TSAnyKeyword\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction tsBooleanKeyword() {\n    return (_builder.default).apply(this, [\n        \"TSBooleanKeyword\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction tsBigIntKeyword() {\n    return (_builder.default).apply(this, [\n        \"TSBigIntKeyword\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction tsIntrinsicKeyword() {\n    return (_builder.default).apply(this, [\n        \"TSIntrinsicKeyword\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction tsNeverKeyword() {\n    return (_builder.default).apply(this, [\n        \"TSNeverKeyword\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction tsNullKeyword() {\n    return (_builder.default).apply(this, [\n        \"TSNullKeyword\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction tsNumberKeyword() {\n    return (_builder.default).apply(this, [\n        \"TSNumberKeyword\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction tsObjectKeyword() {\n    return (_builder.default).apply(this, [\n        \"TSObjectKeyword\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction tsStringKeyword() {\n    return (_builder.default).apply(this, [\n        \"TSStringKeyword\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction tsSymbolKeyword() {\n    return (_builder.default).apply(this, [\n        \"TSSymbolKeyword\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction tsUndefinedKeyword() {\n    return (_builder.default).apply(this, [\n        \"TSUndefinedKeyword\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction tsUnknownKeyword() {\n    return (_builder.default).apply(this, [\n        \"TSUnknownKeyword\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction tsVoidKeyword() {\n    return (_builder.default).apply(this, [\n        \"TSVoidKeyword\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction tsThisType() {\n    return (_builder.default).apply(this, [\n        \"TSThisType\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction tsFunctionType(typeParameters, parameters, typeAnnotation) {\n    return (_builder.default).apply(this, [\n        \"TSFunctionType\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction tsConstructorType(typeParameters, parameters, typeAnnotation) {\n    return (_builder.default).apply(this, [\n        \"TSConstructorType\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction tsTypeReference(typeName, typeParameters) {\n    return (_builder.default).apply(this, [\n        \"TSTypeReference\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction tsTypePredicate(parameterName, typeAnnotation, asserts) {\n    return (_builder.default).apply(this, [\n        \"TSTypePredicate\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction tsTypeQuery(exprName) {\n    return (_builder.default).apply(this, [\n        \"TSTypeQuery\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction tsTypeLiteral(members) {\n    return (_builder.default).apply(this, [\n        \"TSTypeLiteral\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction tsArrayType(elementType) {\n    return (_builder.default).apply(this, [\n        \"TSArrayType\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction tsTupleType(elementTypes) {\n    return (_builder.default).apply(this, [\n        \"TSTupleType\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction tsOptionalType(typeAnnotation) {\n    return (_builder.default).apply(this, [\n        \"TSOptionalType\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction tsRestType(typeAnnotation) {\n    return (_builder.default).apply(this, [\n        \"TSRestType\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction tsNamedTupleMember(label, elementType, optional) {\n    return (_builder.default).apply(this, [\n        \"TSNamedTupleMember\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction tsUnionType(types) {\n    return (_builder.default).apply(this, [\n        \"TSUnionType\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction tsIntersectionType(types) {\n    return (_builder.default).apply(this, [\n        \"TSIntersectionType\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction tsConditionalType(checkType, extendsType, trueType, falseType) {\n    return (_builder.default).apply(this, [\n        \"TSConditionalType\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction tsInferType(typeParameter) {\n    return (_builder.default).apply(this, [\n        \"TSInferType\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction tsParenthesizedType(typeAnnotation) {\n    return (_builder.default).apply(this, [\n        \"TSParenthesizedType\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction tsTypeOperator(typeAnnotation) {\n    return (_builder.default).apply(this, [\n        \"TSTypeOperator\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction tsIndexedAccessType(objectType, indexType) {\n    return (_builder.default).apply(this, [\n        \"TSIndexedAccessType\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction tsMappedType(typeParameter, typeAnnotation, nameType) {\n    return (_builder.default).apply(this, [\n        \"TSMappedType\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction tsLiteralType(literal) {\n    return (_builder.default).apply(this, [\n        \"TSLiteralType\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction tsExpressionWithTypeArguments(expression, typeParameters) {\n    return (_builder.default).apply(this, [\n        \"TSExpressionWithTypeArguments\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction tsInterfaceDeclaration(id, typeParameters, _extends, body) {\n    return (_builder.default).apply(this, [\n        \"TSInterfaceDeclaration\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction tsInterfaceBody(body) {\n    return (_builder.default).apply(this, [\n        \"TSInterfaceBody\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction tsTypeAliasDeclaration(id, typeParameters, typeAnnotation) {\n    return (_builder.default).apply(this, [\n        \"TSTypeAliasDeclaration\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction tsAsExpression(expression, typeAnnotation) {\n    return (_builder.default).apply(this, [\n        \"TSAsExpression\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction tsTypeAssertion(typeAnnotation, expression) {\n    return (_builder.default).apply(this, [\n        \"TSTypeAssertion\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction tsEnumDeclaration(id, members) {\n    return (_builder.default).apply(this, [\n        \"TSEnumDeclaration\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction tsEnumMember(id, initializer) {\n    return (_builder.default).apply(this, [\n        \"TSEnumMember\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction tsModuleDeclaration(id, body) {\n    return (_builder.default).apply(this, [\n        \"TSModuleDeclaration\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction tsModuleBlock(body) {\n    return (_builder.default).apply(this, [\n        \"TSModuleBlock\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction tsImportType(argument, qualifier, typeParameters) {\n    return (_builder.default).apply(this, [\n        \"TSImportType\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction tsImportEqualsDeclaration(id, moduleReference) {\n    return (_builder.default).apply(this, [\n        \"TSImportEqualsDeclaration\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction tsExternalModuleReference(expression) {\n    return (_builder.default).apply(this, [\n        \"TSExternalModuleReference\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction tsNonNullExpression(expression) {\n    return (_builder.default).apply(this, [\n        \"TSNonNullExpression\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction tsExportAssignment(expression) {\n    return (_builder.default).apply(this, [\n        \"TSExportAssignment\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction tsNamespaceExportDeclaration(id) {\n    return (_builder.default).apply(this, [\n        \"TSNamespaceExportDeclaration\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction tsTypeAnnotation(typeAnnotation) {\n    return (_builder.default).apply(this, [\n        \"TSTypeAnnotation\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction tsTypeParameterInstantiation(params) {\n    return (_builder.default).apply(this, [\n        \"TSTypeParameterInstantiation\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction tsTypeParameterDeclaration(params) {\n    return (_builder.default).apply(this, [\n        \"TSTypeParameterDeclaration\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction tsTypeParameter(constraint, _default, name) {\n    return (_builder.default).apply(this, [\n        \"TSTypeParameter\"\n    ].concat(Array.prototype.slice.call(arguments)));\n}\nfunction NumberLiteral() {\n    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n        args[_key] = arguments[_key];\n    }\n    console.trace(\"The node type NumberLiteral has been renamed to NumericLiteral\");\n    return (_builder.default).apply(this, [\n        \"NumberLiteral\"\n    ].concat(_toConsumableArray$1(args)));\n}\nfunction RegexLiteral() {\n    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n        args[_key] = arguments[_key];\n    }\n    console.trace(\"The node type RegexLiteral has been renamed to RegExpLiteral\");\n    return (_builder.default).apply(this, [\n        \"RegexLiteral\"\n    ].concat(_toConsumableArray$1(args)));\n}\nfunction RestProperty() {\n    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n        args[_key] = arguments[_key];\n    }\n    console.trace(\"The node type RestProperty has been renamed to RestElement\");\n    return (_builder.default).apply(this, [\n        \"RestProperty\"\n    ].concat(_toConsumableArray$1(args)));\n}\nfunction SpreadProperty() {\n    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n        args[_key] = arguments[_key];\n    }\n    console.trace(\"The node type SpreadProperty has been renamed to SpreadElement\");\n    return (_builder.default).apply(this, [\n        \"SpreadProperty\"\n    ].concat(_toConsumableArray$1(args)));\n}\n\nObject.defineProperty(cleanJSXElementLiteralChild$1, \"__esModule\", {\n    value: true\n});\ncleanJSXElementLiteralChild$1.default = cleanJSXElementLiteralChild;\nvar _generated$n = generated$3;\nfunction cleanJSXElementLiteralChild(child, args) {\n    var lines = child.value.split(/\\r\\n|\\n|\\r/);\n    var lastNonEmptyLine = 0;\n    for(var i = 0; i < lines.length; i++){\n        if (lines[i].match(/[^ \\t]/)) {\n            lastNonEmptyLine = i;\n        }\n    }\n    var str = \"\";\n    for(var i1 = 0; i1 < lines.length; i1++){\n        var line = lines[i1];\n        var isFirstLine = i1 === 0;\n        var isLastLine = i1 === lines.length - 1;\n        var isLastNonEmptyLine = i1 === lastNonEmptyLine;\n        var trimmedLine = line.replace(/\\t/g, \" \");\n        if (!isFirstLine) {\n            trimmedLine = trimmedLine.replace(/^[ ]+/, \"\");\n        }\n        if (!isLastLine) {\n            trimmedLine = trimmedLine.replace(/[ ]+$/, \"\");\n        }\n        if (trimmedLine) {\n            if (!isLastNonEmptyLine) {\n                trimmedLine += \" \";\n            }\n            str += trimmedLine;\n        }\n    }\n    if (str) args.push((0, _generated$n.stringLiteral)(str));\n}\n\nObject.defineProperty(buildChildren$1, \"__esModule\", {\n    value: true\n});\nbuildChildren$1.default = buildChildren;\nvar _generated$m = generated$4;\nvar _cleanJSXElementLiteralChild = cleanJSXElementLiteralChild$1;\nfunction buildChildren(node) {\n    var elements = [];\n    for(var i = 0; i < node.children.length; i++){\n        var child = node.children[i];\n        if ((0, _generated$m.isJSXText)(child)) {\n            (0, _cleanJSXElementLiteralChild.default)(child, elements);\n            continue;\n        }\n        if ((0, _generated$m.isJSXExpressionContainer)(child)) child = child.expression;\n        if ((0, _generated$m.isJSXEmptyExpression)(child)) continue;\n        elements.push(child);\n    }\n    return elements;\n}\n\nvar assertNode$1 = {};\n\nvar isNode$1 = {};\n\nObject.defineProperty(isNode$1, \"__esModule\", {\n    value: true\n});\nisNode$1.default = isNode;\nvar _definitions$5 = requireDefinitions();\nfunction isNode(node) {\n    return !!(node && _definitions$5.VISITOR_KEYS[node.type]);\n}\n\nObject.defineProperty(assertNode$1, \"__esModule\", {\n    value: true\n});\nassertNode$1.default = assertNode;\nvar _isNode = isNode$1;\nfunction assertNode(node) {\n    if (!(0, _isNode.default)(node)) {\n        var _node$type;\n        var type = (_node$type = node == null ? void 0 : node.type) != null ? _node$type : JSON.stringify(node);\n        throw new TypeError('Not a valid node of type \"' + type + '\"');\n    }\n}\n\nvar generated$2 = {};\n\nObject.defineProperty(generated$2, \"__esModule\", {\n    value: true\n});\ngenerated$2.assertArrayExpression = assertArrayExpression;\ngenerated$2.assertAssignmentExpression = assertAssignmentExpression;\ngenerated$2.assertBinaryExpression = assertBinaryExpression;\ngenerated$2.assertInterpreterDirective = assertInterpreterDirective;\ngenerated$2.assertDirective = assertDirective;\ngenerated$2.assertDirectiveLiteral = assertDirectiveLiteral;\ngenerated$2.assertBlockStatement = assertBlockStatement;\ngenerated$2.assertBreakStatement = assertBreakStatement;\ngenerated$2.assertCallExpression = assertCallExpression;\ngenerated$2.assertCatchClause = assertCatchClause;\ngenerated$2.assertConditionalExpression = assertConditionalExpression;\ngenerated$2.assertContinueStatement = assertContinueStatement;\ngenerated$2.assertDebuggerStatement = assertDebuggerStatement;\ngenerated$2.assertDoWhileStatement = assertDoWhileStatement;\ngenerated$2.assertEmptyStatement = assertEmptyStatement;\ngenerated$2.assertExpressionStatement = assertExpressionStatement;\ngenerated$2.assertFile = assertFile;\ngenerated$2.assertForInStatement = assertForInStatement;\ngenerated$2.assertForStatement = assertForStatement;\ngenerated$2.assertFunctionDeclaration = assertFunctionDeclaration;\ngenerated$2.assertFunctionExpression = assertFunctionExpression;\ngenerated$2.assertIdentifier = assertIdentifier;\ngenerated$2.assertIfStatement = assertIfStatement;\ngenerated$2.assertLabeledStatement = assertLabeledStatement;\ngenerated$2.assertStringLiteral = assertStringLiteral;\ngenerated$2.assertNumericLiteral = assertNumericLiteral;\ngenerated$2.assertNullLiteral = assertNullLiteral;\ngenerated$2.assertBooleanLiteral = assertBooleanLiteral;\ngenerated$2.assertRegExpLiteral = assertRegExpLiteral;\ngenerated$2.assertLogicalExpression = assertLogicalExpression;\ngenerated$2.assertMemberExpression = assertMemberExpression;\ngenerated$2.assertNewExpression = assertNewExpression;\ngenerated$2.assertProgram = assertProgram;\ngenerated$2.assertObjectExpression = assertObjectExpression;\ngenerated$2.assertObjectMethod = assertObjectMethod;\ngenerated$2.assertObjectProperty = assertObjectProperty;\ngenerated$2.assertRestElement = assertRestElement;\ngenerated$2.assertReturnStatement = assertReturnStatement;\ngenerated$2.assertSequenceExpression = assertSequenceExpression;\ngenerated$2.assertParenthesizedExpression = assertParenthesizedExpression;\ngenerated$2.assertSwitchCase = assertSwitchCase;\ngenerated$2.assertSwitchStatement = assertSwitchStatement;\ngenerated$2.assertThisExpression = assertThisExpression;\ngenerated$2.assertThrowStatement = assertThrowStatement;\ngenerated$2.assertTryStatement = assertTryStatement;\ngenerated$2.assertUnaryExpression = assertUnaryExpression;\ngenerated$2.assertUpdateExpression = assertUpdateExpression;\ngenerated$2.assertVariableDeclaration = assertVariableDeclaration;\ngenerated$2.assertVariableDeclarator = assertVariableDeclarator;\ngenerated$2.assertWhileStatement = assertWhileStatement;\ngenerated$2.assertWithStatement = assertWithStatement;\ngenerated$2.assertAssignmentPattern = assertAssignmentPattern;\ngenerated$2.assertArrayPattern = assertArrayPattern;\ngenerated$2.assertArrowFunctionExpression = assertArrowFunctionExpression;\ngenerated$2.assertClassBody = assertClassBody;\ngenerated$2.assertClassExpression = assertClassExpression;\ngenerated$2.assertClassDeclaration = assertClassDeclaration;\ngenerated$2.assertExportAllDeclaration = assertExportAllDeclaration;\ngenerated$2.assertExportDefaultDeclaration = assertExportDefaultDeclaration;\ngenerated$2.assertExportNamedDeclaration = assertExportNamedDeclaration;\ngenerated$2.assertExportSpecifier = assertExportSpecifier;\ngenerated$2.assertForOfStatement = assertForOfStatement;\ngenerated$2.assertImportDeclaration = assertImportDeclaration;\ngenerated$2.assertImportDefaultSpecifier = assertImportDefaultSpecifier;\ngenerated$2.assertImportNamespaceSpecifier = assertImportNamespaceSpecifier;\ngenerated$2.assertImportSpecifier = assertImportSpecifier;\ngenerated$2.assertMetaProperty = assertMetaProperty;\ngenerated$2.assertClassMethod = assertClassMethod;\ngenerated$2.assertObjectPattern = assertObjectPattern;\ngenerated$2.assertSpreadElement = assertSpreadElement;\ngenerated$2.assertSuper = assertSuper;\ngenerated$2.assertTaggedTemplateExpression = assertTaggedTemplateExpression;\ngenerated$2.assertTemplateElement = assertTemplateElement;\ngenerated$2.assertTemplateLiteral = assertTemplateLiteral;\ngenerated$2.assertYieldExpression = assertYieldExpression;\ngenerated$2.assertAwaitExpression = assertAwaitExpression;\ngenerated$2.assertImport = assertImport;\ngenerated$2.assertBigIntLiteral = assertBigIntLiteral;\ngenerated$2.assertExportNamespaceSpecifier = assertExportNamespaceSpecifier;\ngenerated$2.assertOptionalMemberExpression = assertOptionalMemberExpression;\ngenerated$2.assertOptionalCallExpression = assertOptionalCallExpression;\ngenerated$2.assertClassProperty = assertClassProperty;\ngenerated$2.assertClassPrivateProperty = assertClassPrivateProperty;\ngenerated$2.assertClassPrivateMethod = assertClassPrivateMethod;\ngenerated$2.assertPrivateName = assertPrivateName;\ngenerated$2.assertAnyTypeAnnotation = assertAnyTypeAnnotation;\ngenerated$2.assertArrayTypeAnnotation = assertArrayTypeAnnotation;\ngenerated$2.assertBooleanTypeAnnotation = assertBooleanTypeAnnotation;\ngenerated$2.assertBooleanLiteralTypeAnnotation = assertBooleanLiteralTypeAnnotation;\ngenerated$2.assertNullLiteralTypeAnnotation = assertNullLiteralTypeAnnotation;\ngenerated$2.assertClassImplements = assertClassImplements;\ngenerated$2.assertDeclareClass = assertDeclareClass;\ngenerated$2.assertDeclareFunction = assertDeclareFunction;\ngenerated$2.assertDeclareInterface = assertDeclareInterface;\ngenerated$2.assertDeclareModule = assertDeclareModule;\ngenerated$2.assertDeclareModuleExports = assertDeclareModuleExports;\ngenerated$2.assertDeclareTypeAlias = assertDeclareTypeAlias;\ngenerated$2.assertDeclareOpaqueType = assertDeclareOpaqueType;\ngenerated$2.assertDeclareVariable = assertDeclareVariable;\ngenerated$2.assertDeclareExportDeclaration = assertDeclareExportDeclaration;\ngenerated$2.assertDeclareExportAllDeclaration = assertDeclareExportAllDeclaration;\ngenerated$2.assertDeclaredPredicate = assertDeclaredPredicate;\ngenerated$2.assertExistsTypeAnnotation = assertExistsTypeAnnotation;\ngenerated$2.assertFunctionTypeAnnotation = assertFunctionTypeAnnotation;\ngenerated$2.assertFunctionTypeParam = assertFunctionTypeParam;\ngenerated$2.assertGenericTypeAnnotation = assertGenericTypeAnnotation;\ngenerated$2.assertInferredPredicate = assertInferredPredicate;\ngenerated$2.assertInterfaceExtends = assertInterfaceExtends;\ngenerated$2.assertInterfaceDeclaration = assertInterfaceDeclaration;\ngenerated$2.assertInterfaceTypeAnnotation = assertInterfaceTypeAnnotation;\ngenerated$2.assertIntersectionTypeAnnotation = assertIntersectionTypeAnnotation;\ngenerated$2.assertMixedTypeAnnotation = assertMixedTypeAnnotation;\ngenerated$2.assertEmptyTypeAnnotation = assertEmptyTypeAnnotation;\ngenerated$2.assertNullableTypeAnnotation = assertNullableTypeAnnotation;\ngenerated$2.assertNumberLiteralTypeAnnotation = assertNumberLiteralTypeAnnotation;\ngenerated$2.assertNumberTypeAnnotation = assertNumberTypeAnnotation;\ngenerated$2.assertObjectTypeAnnotation = assertObjectTypeAnnotation;\ngenerated$2.assertObjectTypeInternalSlot = assertObjectTypeInternalSlot;\ngenerated$2.assertObjectTypeCallProperty = assertObjectTypeCallProperty;\ngenerated$2.assertObjectTypeIndexer = assertObjectTypeIndexer;\ngenerated$2.assertObjectTypeProperty = assertObjectTypeProperty;\ngenerated$2.assertObjectTypeSpreadProperty = assertObjectTypeSpreadProperty;\ngenerated$2.assertOpaqueType = assertOpaqueType;\ngenerated$2.assertQualifiedTypeIdentifier = assertQualifiedTypeIdentifier;\ngenerated$2.assertStringLiteralTypeAnnotation = assertStringLiteralTypeAnnotation;\ngenerated$2.assertStringTypeAnnotation = assertStringTypeAnnotation;\ngenerated$2.assertSymbolTypeAnnotation = assertSymbolTypeAnnotation;\ngenerated$2.assertThisTypeAnnotation = assertThisTypeAnnotation;\ngenerated$2.assertTupleTypeAnnotation = assertTupleTypeAnnotation;\ngenerated$2.assertTypeofTypeAnnotation = assertTypeofTypeAnnotation;\ngenerated$2.assertTypeAlias = assertTypeAlias;\ngenerated$2.assertTypeAnnotation = assertTypeAnnotation;\ngenerated$2.assertTypeCastExpression = assertTypeCastExpression;\ngenerated$2.assertTypeParameter = assertTypeParameter;\ngenerated$2.assertTypeParameterDeclaration = assertTypeParameterDeclaration;\ngenerated$2.assertTypeParameterInstantiation = assertTypeParameterInstantiation;\ngenerated$2.assertUnionTypeAnnotation = assertUnionTypeAnnotation;\ngenerated$2.assertVariance = assertVariance;\ngenerated$2.assertVoidTypeAnnotation = assertVoidTypeAnnotation;\ngenerated$2.assertEnumDeclaration = assertEnumDeclaration;\ngenerated$2.assertEnumBooleanBody = assertEnumBooleanBody;\ngenerated$2.assertEnumNumberBody = assertEnumNumberBody;\ngenerated$2.assertEnumStringBody = assertEnumStringBody;\ngenerated$2.assertEnumSymbolBody = assertEnumSymbolBody;\ngenerated$2.assertEnumBooleanMember = assertEnumBooleanMember;\ngenerated$2.assertEnumNumberMember = assertEnumNumberMember;\ngenerated$2.assertEnumStringMember = assertEnumStringMember;\ngenerated$2.assertEnumDefaultedMember = assertEnumDefaultedMember;\ngenerated$2.assertIndexedAccessType = assertIndexedAccessType;\ngenerated$2.assertOptionalIndexedAccessType = assertOptionalIndexedAccessType;\ngenerated$2.assertJSXAttribute = assertJSXAttribute;\ngenerated$2.assertJSXClosingElement = assertJSXClosingElement;\ngenerated$2.assertJSXElement = assertJSXElement;\ngenerated$2.assertJSXEmptyExpression = assertJSXEmptyExpression;\ngenerated$2.assertJSXExpressionContainer = assertJSXExpressionContainer;\ngenerated$2.assertJSXSpreadChild = assertJSXSpreadChild;\ngenerated$2.assertJSXIdentifier = assertJSXIdentifier;\ngenerated$2.assertJSXMemberExpression = assertJSXMemberExpression;\ngenerated$2.assertJSXNamespacedName = assertJSXNamespacedName;\ngenerated$2.assertJSXOpeningElement = assertJSXOpeningElement;\ngenerated$2.assertJSXSpreadAttribute = assertJSXSpreadAttribute;\ngenerated$2.assertJSXText = assertJSXText;\ngenerated$2.assertJSXFragment = assertJSXFragment;\ngenerated$2.assertJSXOpeningFragment = assertJSXOpeningFragment;\ngenerated$2.assertJSXClosingFragment = assertJSXClosingFragment;\ngenerated$2.assertNoop = assertNoop;\ngenerated$2.assertPlaceholder = assertPlaceholder;\ngenerated$2.assertV8IntrinsicIdentifier = assertV8IntrinsicIdentifier;\ngenerated$2.assertArgumentPlaceholder = assertArgumentPlaceholder;\ngenerated$2.assertBindExpression = assertBindExpression;\ngenerated$2.assertImportAttribute = assertImportAttribute;\ngenerated$2.assertDecorator = assertDecorator;\ngenerated$2.assertDoExpression = assertDoExpression;\ngenerated$2.assertExportDefaultSpecifier = assertExportDefaultSpecifier;\ngenerated$2.assertRecordExpression = assertRecordExpression;\ngenerated$2.assertTupleExpression = assertTupleExpression;\ngenerated$2.assertDecimalLiteral = assertDecimalLiteral;\ngenerated$2.assertStaticBlock = assertStaticBlock;\ngenerated$2.assertModuleExpression = assertModuleExpression;\ngenerated$2.assertTopicReference = assertTopicReference;\ngenerated$2.assertPipelineTopicExpression = assertPipelineTopicExpression;\ngenerated$2.assertPipelineBareFunction = assertPipelineBareFunction;\ngenerated$2.assertPipelinePrimaryTopicReference = assertPipelinePrimaryTopicReference;\ngenerated$2.assertTSParameterProperty = assertTSParameterProperty;\ngenerated$2.assertTSDeclareFunction = assertTSDeclareFunction;\ngenerated$2.assertTSDeclareMethod = assertTSDeclareMethod;\ngenerated$2.assertTSQualifiedName = assertTSQualifiedName;\ngenerated$2.assertTSCallSignatureDeclaration = assertTSCallSignatureDeclaration;\ngenerated$2.assertTSConstructSignatureDeclaration = assertTSConstructSignatureDeclaration;\ngenerated$2.assertTSPropertySignature = assertTSPropertySignature;\ngenerated$2.assertTSMethodSignature = assertTSMethodSignature;\ngenerated$2.assertTSIndexSignature = assertTSIndexSignature;\ngenerated$2.assertTSAnyKeyword = assertTSAnyKeyword;\ngenerated$2.assertTSBooleanKeyword = assertTSBooleanKeyword;\ngenerated$2.assertTSBigIntKeyword = assertTSBigIntKeyword;\ngenerated$2.assertTSIntrinsicKeyword = assertTSIntrinsicKeyword;\ngenerated$2.assertTSNeverKeyword = assertTSNeverKeyword;\ngenerated$2.assertTSNullKeyword = assertTSNullKeyword;\ngenerated$2.assertTSNumberKeyword = assertTSNumberKeyword;\ngenerated$2.assertTSObjectKeyword = assertTSObjectKeyword;\ngenerated$2.assertTSStringKeyword = assertTSStringKeyword;\ngenerated$2.assertTSSymbolKeyword = assertTSSymbolKeyword;\ngenerated$2.assertTSUndefinedKeyword = assertTSUndefinedKeyword;\ngenerated$2.assertTSUnknownKeyword = assertTSUnknownKeyword;\ngenerated$2.assertTSVoidKeyword = assertTSVoidKeyword;\ngenerated$2.assertTSThisType = assertTSThisType;\ngenerated$2.assertTSFunctionType = assertTSFunctionType;\ngenerated$2.assertTSConstructorType = assertTSConstructorType;\ngenerated$2.assertTSTypeReference = assertTSTypeReference;\ngenerated$2.assertTSTypePredicate = assertTSTypePredicate;\ngenerated$2.assertTSTypeQuery = assertTSTypeQuery;\ngenerated$2.assertTSTypeLiteral = assertTSTypeLiteral;\ngenerated$2.assertTSArrayType = assertTSArrayType;\ngenerated$2.assertTSTupleType = assertTSTupleType;\ngenerated$2.assertTSOptionalType = assertTSOptionalType;\ngenerated$2.assertTSRestType = assertTSRestType;\ngenerated$2.assertTSNamedTupleMember = assertTSNamedTupleMember;\ngenerated$2.assertTSUnionType = assertTSUnionType;\ngenerated$2.assertTSIntersectionType = assertTSIntersectionType;\ngenerated$2.assertTSConditionalType = assertTSConditionalType;\ngenerated$2.assertTSInferType = assertTSInferType;\ngenerated$2.assertTSParenthesizedType = assertTSParenthesizedType;\ngenerated$2.assertTSTypeOperator = assertTSTypeOperator;\ngenerated$2.assertTSIndexedAccessType = assertTSIndexedAccessType;\ngenerated$2.assertTSMappedType = assertTSMappedType;\ngenerated$2.assertTSLiteralType = assertTSLiteralType;\ngenerated$2.assertTSExpressionWithTypeArguments = assertTSExpressionWithTypeArguments;\ngenerated$2.assertTSInterfaceDeclaration = assertTSInterfaceDeclaration;\ngenerated$2.assertTSInterfaceBody = assertTSInterfaceBody;\ngenerated$2.assertTSTypeAliasDeclaration = assertTSTypeAliasDeclaration;\ngenerated$2.assertTSAsExpression = assertTSAsExpression;\ngenerated$2.assertTSTypeAssertion = assertTSTypeAssertion;\ngenerated$2.assertTSEnumDeclaration = assertTSEnumDeclaration;\ngenerated$2.assertTSEnumMember = assertTSEnumMember;\ngenerated$2.assertTSModuleDeclaration = assertTSModuleDeclaration;\ngenerated$2.assertTSModuleBlock = assertTSModuleBlock;\ngenerated$2.assertTSImportType = assertTSImportType;\ngenerated$2.assertTSImportEqualsDeclaration = assertTSImportEqualsDeclaration;\ngenerated$2.assertTSExternalModuleReference = assertTSExternalModuleReference;\ngenerated$2.assertTSNonNullExpression = assertTSNonNullExpression;\ngenerated$2.assertTSExportAssignment = assertTSExportAssignment;\ngenerated$2.assertTSNamespaceExportDeclaration = assertTSNamespaceExportDeclaration;\ngenerated$2.assertTSTypeAnnotation = assertTSTypeAnnotation;\ngenerated$2.assertTSTypeParameterInstantiation = assertTSTypeParameterInstantiation;\ngenerated$2.assertTSTypeParameterDeclaration = assertTSTypeParameterDeclaration;\ngenerated$2.assertTSTypeParameter = assertTSTypeParameter;\ngenerated$2.assertExpression = assertExpression;\ngenerated$2.assertBinary = assertBinary;\ngenerated$2.assertScopable = assertScopable;\ngenerated$2.assertBlockParent = assertBlockParent;\ngenerated$2.assertBlock = assertBlock;\ngenerated$2.assertStatement = assertStatement;\ngenerated$2.assertTerminatorless = assertTerminatorless;\ngenerated$2.assertCompletionStatement = assertCompletionStatement;\ngenerated$2.assertConditional = assertConditional;\ngenerated$2.assertLoop = assertLoop;\ngenerated$2.assertWhile = assertWhile;\ngenerated$2.assertExpressionWrapper = assertExpressionWrapper;\ngenerated$2.assertFor = assertFor;\ngenerated$2.assertForXStatement = assertForXStatement;\ngenerated$2.assertFunction = assertFunction;\ngenerated$2.assertFunctionParent = assertFunctionParent;\ngenerated$2.assertPureish = assertPureish;\ngenerated$2.assertDeclaration = assertDeclaration;\ngenerated$2.assertPatternLike = assertPatternLike;\ngenerated$2.assertLVal = assertLVal;\ngenerated$2.assertTSEntityName = assertTSEntityName;\ngenerated$2.assertLiteral = assertLiteral;\ngenerated$2.assertImmutable = assertImmutable;\ngenerated$2.assertUserWhitespacable = assertUserWhitespacable;\ngenerated$2.assertMethod = assertMethod;\ngenerated$2.assertObjectMember = assertObjectMember;\ngenerated$2.assertProperty = assertProperty;\ngenerated$2.assertUnaryLike = assertUnaryLike;\ngenerated$2.assertPattern = assertPattern;\ngenerated$2.assertClass = assertClass;\ngenerated$2.assertModuleDeclaration = assertModuleDeclaration;\ngenerated$2.assertExportDeclaration = assertExportDeclaration;\ngenerated$2.assertModuleSpecifier = assertModuleSpecifier;\ngenerated$2.assertPrivate = assertPrivate;\ngenerated$2.assertFlow = assertFlow;\ngenerated$2.assertFlowType = assertFlowType;\ngenerated$2.assertFlowBaseAnnotation = assertFlowBaseAnnotation;\ngenerated$2.assertFlowDeclaration = assertFlowDeclaration;\ngenerated$2.assertFlowPredicate = assertFlowPredicate;\ngenerated$2.assertEnumBody = assertEnumBody;\ngenerated$2.assertEnumMember = assertEnumMember;\ngenerated$2.assertJSX = assertJSX;\ngenerated$2.assertTSTypeElement = assertTSTypeElement;\ngenerated$2.assertTSType = assertTSType;\ngenerated$2.assertTSBaseType = assertTSBaseType;\ngenerated$2.assertNumberLiteral = assertNumberLiteral;\ngenerated$2.assertRegexLiteral = assertRegexLiteral;\ngenerated$2.assertRestProperty = assertRestProperty;\ngenerated$2.assertSpreadProperty = assertSpreadProperty;\nvar _is = requireIs();\nfunction assert(type, node, opts) {\n    if (!(0, _is.default)(type, node, opts)) {\n        throw new Error('Expected type \"' + type + '\" with option ' + JSON.stringify(opts) + \", \" + ('but instead got \"' + node.type + '\".'));\n    }\n}\nfunction assertArrayExpression(node, opts) {\n    assert(\"ArrayExpression\", node, opts);\n}\nfunction assertAssignmentExpression(node, opts) {\n    assert(\"AssignmentExpression\", node, opts);\n}\nfunction assertBinaryExpression(node, opts) {\n    assert(\"BinaryExpression\", node, opts);\n}\nfunction assertInterpreterDirective(node, opts) {\n    assert(\"InterpreterDirective\", node, opts);\n}\nfunction assertDirective(node, opts) {\n    assert(\"Directive\", node, opts);\n}\nfunction assertDirectiveLiteral(node, opts) {\n    assert(\"DirectiveLiteral\", node, opts);\n}\nfunction assertBlockStatement(node, opts) {\n    assert(\"BlockStatement\", node, opts);\n}\nfunction assertBreakStatement(node, opts) {\n    assert(\"BreakStatement\", node, opts);\n}\nfunction assertCallExpression(node, opts) {\n    assert(\"CallExpression\", node, opts);\n}\nfunction assertCatchClause(node, opts) {\n    assert(\"CatchClause\", node, opts);\n}\nfunction assertConditionalExpression(node, opts) {\n    assert(\"ConditionalExpression\", node, opts);\n}\nfunction assertContinueStatement(node, opts) {\n    assert(\"ContinueStatement\", node, opts);\n}\nfunction assertDebuggerStatement(node, opts) {\n    assert(\"DebuggerStatement\", node, opts);\n}\nfunction assertDoWhileStatement(node, opts) {\n    assert(\"DoWhileStatement\", node, opts);\n}\nfunction assertEmptyStatement(node, opts) {\n    assert(\"EmptyStatement\", node, opts);\n}\nfunction assertExpressionStatement(node, opts) {\n    assert(\"ExpressionStatement\", node, opts);\n}\nfunction assertFile(node, opts) {\n    assert(\"File\", node, opts);\n}\nfunction assertForInStatement(node, opts) {\n    assert(\"ForInStatement\", node, opts);\n}\nfunction assertForStatement(node, opts) {\n    assert(\"ForStatement\", node, opts);\n}\nfunction assertFunctionDeclaration(node, opts) {\n    assert(\"FunctionDeclaration\", node, opts);\n}\nfunction assertFunctionExpression(node, opts) {\n    assert(\"FunctionExpression\", node, opts);\n}\nfunction assertIdentifier(node, opts) {\n    assert(\"Identifier\", node, opts);\n}\nfunction assertIfStatement(node, opts) {\n    assert(\"IfStatement\", node, opts);\n}\nfunction assertLabeledStatement(node, opts) {\n    assert(\"LabeledStatement\", node, opts);\n}\nfunction assertStringLiteral(node, opts) {\n    assert(\"StringLiteral\", node, opts);\n}\nfunction assertNumericLiteral(node, opts) {\n    assert(\"NumericLiteral\", node, opts);\n}\nfunction assertNullLiteral(node, opts) {\n    assert(\"NullLiteral\", node, opts);\n}\nfunction assertBooleanLiteral(node, opts) {\n    assert(\"BooleanLiteral\", node, opts);\n}\nfunction assertRegExpLiteral(node, opts) {\n    assert(\"RegExpLiteral\", node, opts);\n}\nfunction assertLogicalExpression(node, opts) {\n    assert(\"LogicalExpression\", node, opts);\n}\nfunction assertMemberExpression(node, opts) {\n    assert(\"MemberExpression\", node, opts);\n}\nfunction assertNewExpression(node, opts) {\n    assert(\"NewExpression\", node, opts);\n}\nfunction assertProgram(node, opts) {\n    assert(\"Program\", node, opts);\n}\nfunction assertObjectExpression(node, opts) {\n    assert(\"ObjectExpression\", node, opts);\n}\nfunction assertObjectMethod(node, opts) {\n    assert(\"ObjectMethod\", node, opts);\n}\nfunction assertObjectProperty(node, opts) {\n    assert(\"ObjectProperty\", node, opts);\n}\nfunction assertRestElement(node, opts) {\n    assert(\"RestElement\", node, opts);\n}\nfunction assertReturnStatement(node, opts) {\n    assert(\"ReturnStatement\", node, opts);\n}\nfunction assertSequenceExpression(node, opts) {\n    assert(\"SequenceExpression\", node, opts);\n}\nfunction assertParenthesizedExpression(node, opts) {\n    assert(\"ParenthesizedExpression\", node, opts);\n}\nfunction assertSwitchCase(node, opts) {\n    assert(\"SwitchCase\", node, opts);\n}\nfunction assertSwitchStatement(node, opts) {\n    assert(\"SwitchStatement\", node, opts);\n}\nfunction assertThisExpression(node, opts) {\n    assert(\"ThisExpression\", node, opts);\n}\nfunction assertThrowStatement(node, opts) {\n    assert(\"ThrowStatement\", node, opts);\n}\nfunction assertTryStatement(node, opts) {\n    assert(\"TryStatement\", node, opts);\n}\nfunction assertUnaryExpression(node, opts) {\n    assert(\"UnaryExpression\", node, opts);\n}\nfunction assertUpdateExpression(node, opts) {\n    assert(\"UpdateExpression\", node, opts);\n}\nfunction assertVariableDeclaration(node, opts) {\n    assert(\"VariableDeclaration\", node, opts);\n}\nfunction assertVariableDeclarator(node, opts) {\n    assert(\"VariableDeclarator\", node, opts);\n}\nfunction assertWhileStatement(node, opts) {\n    assert(\"WhileStatement\", node, opts);\n}\nfunction assertWithStatement(node, opts) {\n    assert(\"WithStatement\", node, opts);\n}\nfunction assertAssignmentPattern(node, opts) {\n    assert(\"AssignmentPattern\", node, opts);\n}\nfunction assertArrayPattern(node, opts) {\n    assert(\"ArrayPattern\", node, opts);\n}\nfunction assertArrowFunctionExpression(node, opts) {\n    assert(\"ArrowFunctionExpression\", node, opts);\n}\nfunction assertClassBody(node, opts) {\n    assert(\"ClassBody\", node, opts);\n}\nfunction assertClassExpression(node, opts) {\n    assert(\"ClassExpression\", node, opts);\n}\nfunction assertClassDeclaration(node, opts) {\n    assert(\"ClassDeclaration\", node, opts);\n}\nfunction assertExportAllDeclaration(node, opts) {\n    assert(\"ExportAllDeclaration\", node, opts);\n}\nfunction assertExportDefaultDeclaration(node, opts) {\n    assert(\"ExportDefaultDeclaration\", node, opts);\n}\nfunction assertExportNamedDeclaration(node, opts) {\n    assert(\"ExportNamedDeclaration\", node, opts);\n}\nfunction assertExportSpecifier(node, opts) {\n    assert(\"ExportSpecifier\", node, opts);\n}\nfunction assertForOfStatement(node, opts) {\n    assert(\"ForOfStatement\", node, opts);\n}\nfunction assertImportDeclaration(node, opts) {\n    assert(\"ImportDeclaration\", node, opts);\n}\nfunction assertImportDefaultSpecifier(node, opts) {\n    assert(\"ImportDefaultSpecifier\", node, opts);\n}\nfunction assertImportNamespaceSpecifier(node, opts) {\n    assert(\"ImportNamespaceSpecifier\", node, opts);\n}\nfunction assertImportSpecifier(node, opts) {\n    assert(\"ImportSpecifier\", node, opts);\n}\nfunction assertMetaProperty(node, opts) {\n    assert(\"MetaProperty\", node, opts);\n}\nfunction assertClassMethod(node, opts) {\n    assert(\"ClassMethod\", node, opts);\n}\nfunction assertObjectPattern(node, opts) {\n    assert(\"ObjectPattern\", node, opts);\n}\nfunction assertSpreadElement(node, opts) {\n    assert(\"SpreadElement\", node, opts);\n}\nfunction assertSuper(node, opts) {\n    assert(\"Super\", node, opts);\n}\nfunction assertTaggedTemplateExpression(node, opts) {\n    assert(\"TaggedTemplateExpression\", node, opts);\n}\nfunction assertTemplateElement(node, opts) {\n    assert(\"TemplateElement\", node, opts);\n}\nfunction assertTemplateLiteral(node, opts) {\n    assert(\"TemplateLiteral\", node, opts);\n}\nfunction assertYieldExpression(node, opts) {\n    assert(\"YieldExpression\", node, opts);\n}\nfunction assertAwaitExpression(node, opts) {\n    assert(\"AwaitExpression\", node, opts);\n}\nfunction assertImport(node, opts) {\n    assert(\"Import\", node, opts);\n}\nfunction assertBigIntLiteral(node, opts) {\n    assert(\"BigIntLiteral\", node, opts);\n}\nfunction assertExportNamespaceSpecifier(node, opts) {\n    assert(\"ExportNamespaceSpecifier\", node, opts);\n}\nfunction assertOptionalMemberExpression(node, opts) {\n    assert(\"OptionalMemberExpression\", node, opts);\n}\nfunction assertOptionalCallExpression(node, opts) {\n    assert(\"OptionalCallExpression\", node, opts);\n}\nfunction assertClassProperty(node, opts) {\n    assert(\"ClassProperty\", node, opts);\n}\nfunction assertClassPrivateProperty(node, opts) {\n    assert(\"ClassPrivateProperty\", node, opts);\n}\nfunction assertClassPrivateMethod(node, opts) {\n    assert(\"ClassPrivateMethod\", node, opts);\n}\nfunction assertPrivateName(node, opts) {\n    assert(\"PrivateName\", node, opts);\n}\nfunction assertAnyTypeAnnotation(node, opts) {\n    assert(\"AnyTypeAnnotation\", node, opts);\n}\nfunction assertArrayTypeAnnotation(node, opts) {\n    assert(\"ArrayTypeAnnotation\", node, opts);\n}\nfunction assertBooleanTypeAnnotation(node, opts) {\n    assert(\"BooleanTypeAnnotation\", node, opts);\n}\nfunction assertBooleanLiteralTypeAnnotation(node, opts) {\n    assert(\"BooleanLiteralTypeAnnotation\", node, opts);\n}\nfunction assertNullLiteralTypeAnnotation(node, opts) {\n    assert(\"NullLiteralTypeAnnotation\", node, opts);\n}\nfunction assertClassImplements(node, opts) {\n    assert(\"ClassImplements\", node, opts);\n}\nfunction assertDeclareClass(node, opts) {\n    assert(\"DeclareClass\", node, opts);\n}\nfunction assertDeclareFunction(node, opts) {\n    assert(\"DeclareFunction\", node, opts);\n}\nfunction assertDeclareInterface(node, opts) {\n    assert(\"DeclareInterface\", node, opts);\n}\nfunction assertDeclareModule(node, opts) {\n    assert(\"DeclareModule\", node, opts);\n}\nfunction assertDeclareModuleExports(node, opts) {\n    assert(\"DeclareModuleExports\", node, opts);\n}\nfunction assertDeclareTypeAlias(node, opts) {\n    assert(\"DeclareTypeAlias\", node, opts);\n}\nfunction assertDeclareOpaqueType(node, opts) {\n    assert(\"DeclareOpaqueType\", node, opts);\n}\nfunction assertDeclareVariable(node, opts) {\n    assert(\"DeclareVariable\", node, opts);\n}\nfunction assertDeclareExportDeclaration(node, opts) {\n    assert(\"DeclareExportDeclaration\", node, opts);\n}\nfunction assertDeclareExportAllDeclaration(node, opts) {\n    assert(\"DeclareExportAllDeclaration\", node, opts);\n}\nfunction assertDeclaredPredicate(node, opts) {\n    assert(\"DeclaredPredicate\", node, opts);\n}\nfunction assertExistsTypeAnnotation(node, opts) {\n    assert(\"ExistsTypeAnnotation\", node, opts);\n}\nfunction assertFunctionTypeAnnotation(node, opts) {\n    assert(\"FunctionTypeAnnotation\", node, opts);\n}\nfunction assertFunctionTypeParam(node, opts) {\n    assert(\"FunctionTypeParam\", node, opts);\n}\nfunction assertGenericTypeAnnotation(node, opts) {\n    assert(\"GenericTypeAnnotation\", node, opts);\n}\nfunction assertInferredPredicate(node, opts) {\n    assert(\"InferredPredicate\", node, opts);\n}\nfunction assertInterfaceExtends(node, opts) {\n    assert(\"InterfaceExtends\", node, opts);\n}\nfunction assertInterfaceDeclaration(node, opts) {\n    assert(\"InterfaceDeclaration\", node, opts);\n}\nfunction assertInterfaceTypeAnnotation(node, opts) {\n    assert(\"InterfaceTypeAnnotation\", node, opts);\n}\nfunction assertIntersectionTypeAnnotation(node, opts) {\n    assert(\"IntersectionTypeAnnotation\", node, opts);\n}\nfunction assertMixedTypeAnnotation(node, opts) {\n    assert(\"MixedTypeAnnotation\", node, opts);\n}\nfunction assertEmptyTypeAnnotation(node, opts) {\n    assert(\"EmptyTypeAnnotation\", node, opts);\n}\nfunction assertNullableTypeAnnotation(node, opts) {\n    assert(\"NullableTypeAnnotation\", node, opts);\n}\nfunction assertNumberLiteralTypeAnnotation(node, opts) {\n    assert(\"NumberLiteralTypeAnnotation\", node, opts);\n}\nfunction assertNumberTypeAnnotation(node, opts) {\n    assert(\"NumberTypeAnnotation\", node, opts);\n}\nfunction assertObjectTypeAnnotation(node, opts) {\n    assert(\"ObjectTypeAnnotation\", node, opts);\n}\nfunction assertObjectTypeInternalSlot(node, opts) {\n    assert(\"ObjectTypeInternalSlot\", node, opts);\n}\nfunction assertObjectTypeCallProperty(node, opts) {\n    assert(\"ObjectTypeCallProperty\", node, opts);\n}\nfunction assertObjectTypeIndexer(node, opts) {\n    assert(\"ObjectTypeIndexer\", node, opts);\n}\nfunction assertObjectTypeProperty(node, opts) {\n    assert(\"ObjectTypeProperty\", node, opts);\n}\nfunction assertObjectTypeSpreadProperty(node, opts) {\n    assert(\"ObjectTypeSpreadProperty\", node, opts);\n}\nfunction assertOpaqueType(node, opts) {\n    assert(\"OpaqueType\", node, opts);\n}\nfunction assertQualifiedTypeIdentifier(node, opts) {\n    assert(\"QualifiedTypeIdentifier\", node, opts);\n}\nfunction assertStringLiteralTypeAnnotation(node, opts) {\n    assert(\"StringLiteralTypeAnnotation\", node, opts);\n}\nfunction assertStringTypeAnnotation(node, opts) {\n    assert(\"StringTypeAnnotation\", node, opts);\n}\nfunction assertSymbolTypeAnnotation(node, opts) {\n    assert(\"SymbolTypeAnnotation\", node, opts);\n}\nfunction assertThisTypeAnnotation(node, opts) {\n    assert(\"ThisTypeAnnotation\", node, opts);\n}\nfunction assertTupleTypeAnnotation(node, opts) {\n    assert(\"TupleTypeAnnotation\", node, opts);\n}\nfunction assertTypeofTypeAnnotation(node, opts) {\n    assert(\"TypeofTypeAnnotation\", node, opts);\n}\nfunction assertTypeAlias(node, opts) {\n    assert(\"TypeAlias\", node, opts);\n}\nfunction assertTypeAnnotation(node, opts) {\n    assert(\"TypeAnnotation\", node, opts);\n}\nfunction assertTypeCastExpression(node, opts) {\n    assert(\"TypeCastExpression\", node, opts);\n}\nfunction assertTypeParameter(node, opts) {\n    assert(\"TypeParameter\", node, opts);\n}\nfunction assertTypeParameterDeclaration(node, opts) {\n    assert(\"TypeParameterDeclaration\", node, opts);\n}\nfunction assertTypeParameterInstantiation(node, opts) {\n    assert(\"TypeParameterInstantiation\", node, opts);\n}\nfunction assertUnionTypeAnnotation(node, opts) {\n    assert(\"UnionTypeAnnotation\", node, opts);\n}\nfunction assertVariance(node, opts) {\n    assert(\"Variance\", node, opts);\n}\nfunction assertVoidTypeAnnotation(node, opts) {\n    assert(\"VoidTypeAnnotation\", node, opts);\n}\nfunction assertEnumDeclaration(node, opts) {\n    assert(\"EnumDeclaration\", node, opts);\n}\nfunction assertEnumBooleanBody(node, opts) {\n    assert(\"EnumBooleanBody\", node, opts);\n}\nfunction assertEnumNumberBody(node, opts) {\n    assert(\"EnumNumberBody\", node, opts);\n}\nfunction assertEnumStringBody(node, opts) {\n    assert(\"EnumStringBody\", node, opts);\n}\nfunction assertEnumSymbolBody(node, opts) {\n    assert(\"EnumSymbolBody\", node, opts);\n}\nfunction assertEnumBooleanMember(node, opts) {\n    assert(\"EnumBooleanMember\", node, opts);\n}\nfunction assertEnumNumberMember(node, opts) {\n    assert(\"EnumNumberMember\", node, opts);\n}\nfunction assertEnumStringMember(node, opts) {\n    assert(\"EnumStringMember\", node, opts);\n}\nfunction assertEnumDefaultedMember(node, opts) {\n    assert(\"EnumDefaultedMember\", node, opts);\n}\nfunction assertIndexedAccessType(node, opts) {\n    assert(\"IndexedAccessType\", node, opts);\n}\nfunction assertOptionalIndexedAccessType(node, opts) {\n    assert(\"OptionalIndexedAccessType\", node, opts);\n}\nfunction assertJSXAttribute(node, opts) {\n    assert(\"JSXAttribute\", node, opts);\n}\nfunction assertJSXClosingElement(node, opts) {\n    assert(\"JSXClosingElement\", node, opts);\n}\nfunction assertJSXElement(node, opts) {\n    assert(\"JSXElement\", node, opts);\n}\nfunction assertJSXEmptyExpression(node, opts) {\n    assert(\"JSXEmptyExpression\", node, opts);\n}\nfunction assertJSXExpressionContainer(node, opts) {\n    assert(\"JSXExpressionContainer\", node, opts);\n}\nfunction assertJSXSpreadChild(node, opts) {\n    assert(\"JSXSpreadChild\", node, opts);\n}\nfunction assertJSXIdentifier(node, opts) {\n    assert(\"JSXIdentifier\", node, opts);\n}\nfunction assertJSXMemberExpression(node, opts) {\n    assert(\"JSXMemberExpression\", node, opts);\n}\nfunction assertJSXNamespacedName(node, opts) {\n    assert(\"JSXNamespacedName\", node, opts);\n}\nfunction assertJSXOpeningElement(node, opts) {\n    assert(\"JSXOpeningElement\", node, opts);\n}\nfunction assertJSXSpreadAttribute(node, opts) {\n    assert(\"JSXSpreadAttribute\", node, opts);\n}\nfunction assertJSXText(node, opts) {\n    assert(\"JSXText\", node, opts);\n}\nfunction assertJSXFragment(node, opts) {\n    assert(\"JSXFragment\", node, opts);\n}\nfunction assertJSXOpeningFragment(node, opts) {\n    assert(\"JSXOpeningFragment\", node, opts);\n}\nfunction assertJSXClosingFragment(node, opts) {\n    assert(\"JSXClosingFragment\", node, opts);\n}\nfunction assertNoop(node, opts) {\n    assert(\"Noop\", node, opts);\n}\nfunction assertPlaceholder(node, opts) {\n    assert(\"Placeholder\", node, opts);\n}\nfunction assertV8IntrinsicIdentifier(node, opts) {\n    assert(\"V8IntrinsicIdentifier\", node, opts);\n}\nfunction assertArgumentPlaceholder(node, opts) {\n    assert(\"ArgumentPlaceholder\", node, opts);\n}\nfunction assertBindExpression(node, opts) {\n    assert(\"BindExpression\", node, opts);\n}\nfunction assertImportAttribute(node, opts) {\n    assert(\"ImportAttribute\", node, opts);\n}\nfunction assertDecorator(node, opts) {\n    assert(\"Decorator\", node, opts);\n}\nfunction assertDoExpression(node, opts) {\n    assert(\"DoExpression\", node, opts);\n}\nfunction assertExportDefaultSpecifier(node, opts) {\n    assert(\"ExportDefaultSpecifier\", node, opts);\n}\nfunction assertRecordExpression(node, opts) {\n    assert(\"RecordExpression\", node, opts);\n}\nfunction assertTupleExpression(node, opts) {\n    assert(\"TupleExpression\", node, opts);\n}\nfunction assertDecimalLiteral(node, opts) {\n    assert(\"DecimalLiteral\", node, opts);\n}\nfunction assertStaticBlock(node, opts) {\n    assert(\"StaticBlock\", node, opts);\n}\nfunction assertModuleExpression(node, opts) {\n    assert(\"ModuleExpression\", node, opts);\n}\nfunction assertTopicReference(node, opts) {\n    assert(\"TopicReference\", node, opts);\n}\nfunction assertPipelineTopicExpression(node, opts) {\n    assert(\"PipelineTopicExpression\", node, opts);\n}\nfunction assertPipelineBareFunction(node, opts) {\n    assert(\"PipelineBareFunction\", node, opts);\n}\nfunction assertPipelinePrimaryTopicReference(node, opts) {\n    assert(\"PipelinePrimaryTopicReference\", node, opts);\n}\nfunction assertTSParameterProperty(node, opts) {\n    assert(\"TSParameterProperty\", node, opts);\n}\nfunction assertTSDeclareFunction(node, opts) {\n    assert(\"TSDeclareFunction\", node, opts);\n}\nfunction assertTSDeclareMethod(node, opts) {\n    assert(\"TSDeclareMethod\", node, opts);\n}\nfunction assertTSQualifiedName(node, opts) {\n    assert(\"TSQualifiedName\", node, opts);\n}\nfunction assertTSCallSignatureDeclaration(node, opts) {\n    assert(\"TSCallSignatureDeclaration\", node, opts);\n}\nfunction assertTSConstructSignatureDeclaration(node, opts) {\n    assert(\"TSConstructSignatureDeclaration\", node, opts);\n}\nfunction assertTSPropertySignature(node, opts) {\n    assert(\"TSPropertySignature\", node, opts);\n}\nfunction assertTSMethodSignature(node, opts) {\n    assert(\"TSMethodSignature\", node, opts);\n}\nfunction assertTSIndexSignature(node, opts) {\n    assert(\"TSIndexSignature\", node, opts);\n}\nfunction assertTSAnyKeyword(node, opts) {\n    assert(\"TSAnyKeyword\", node, opts);\n}\nfunction assertTSBooleanKeyword(node, opts) {\n    assert(\"TSBooleanKeyword\", node, opts);\n}\nfunction assertTSBigIntKeyword(node, opts) {\n    assert(\"TSBigIntKeyword\", node, opts);\n}\nfunction assertTSIntrinsicKeyword(node, opts) {\n    assert(\"TSIntrinsicKeyword\", node, opts);\n}\nfunction assertTSNeverKeyword(node, opts) {\n    assert(\"TSNeverKeyword\", node, opts);\n}\nfunction assertTSNullKeyword(node, opts) {\n    assert(\"TSNullKeyword\", node, opts);\n}\nfunction assertTSNumberKeyword(node, opts) {\n    assert(\"TSNumberKeyword\", node, opts);\n}\nfunction assertTSObjectKeyword(node, opts) {\n    assert(\"TSObjectKeyword\", node, opts);\n}\nfunction assertTSStringKeyword(node, opts) {\n    assert(\"TSStringKeyword\", node, opts);\n}\nfunction assertTSSymbolKeyword(node, opts) {\n    assert(\"TSSymbolKeyword\", node, opts);\n}\nfunction assertTSUndefinedKeyword(node, opts) {\n    assert(\"TSUndefinedKeyword\", node, opts);\n}\nfunction assertTSUnknownKeyword(node, opts) {\n    assert(\"TSUnknownKeyword\", node, opts);\n}\nfunction assertTSVoidKeyword(node, opts) {\n    assert(\"TSVoidKeyword\", node, opts);\n}\nfunction assertTSThisType(node, opts) {\n    assert(\"TSThisType\", node, opts);\n}\nfunction assertTSFunctionType(node, opts) {\n    assert(\"TSFunctionType\", node, opts);\n}\nfunction assertTSConstructorType(node, opts) {\n    assert(\"TSConstructorType\", node, opts);\n}\nfunction assertTSTypeReference(node, opts) {\n    assert(\"TSTypeReference\", node, opts);\n}\nfunction assertTSTypePredicate(node, opts) {\n    assert(\"TSTypePredicate\", node, opts);\n}\nfunction assertTSTypeQuery(node, opts) {\n    assert(\"TSTypeQuery\", node, opts);\n}\nfunction assertTSTypeLiteral(node, opts) {\n    assert(\"TSTypeLiteral\", node, opts);\n}\nfunction assertTSArrayType(node, opts) {\n    assert(\"TSArrayType\", node, opts);\n}\nfunction assertTSTupleType(node, opts) {\n    assert(\"TSTupleType\", node, opts);\n}\nfunction assertTSOptionalType(node, opts) {\n    assert(\"TSOptionalType\", node, opts);\n}\nfunction assertTSRestType(node, opts) {\n    assert(\"TSRestType\", node, opts);\n}\nfunction assertTSNamedTupleMember(node, opts) {\n    assert(\"TSNamedTupleMember\", node, opts);\n}\nfunction assertTSUnionType(node, opts) {\n    assert(\"TSUnionType\", node, opts);\n}\nfunction assertTSIntersectionType(node, opts) {\n    assert(\"TSIntersectionType\", node, opts);\n}\nfunction assertTSConditionalType(node, opts) {\n    assert(\"TSConditionalType\", node, opts);\n}\nfunction assertTSInferType(node, opts) {\n    assert(\"TSInferType\", node, opts);\n}\nfunction assertTSParenthesizedType(node, opts) {\n    assert(\"TSParenthesizedType\", node, opts);\n}\nfunction assertTSTypeOperator(node, opts) {\n    assert(\"TSTypeOperator\", node, opts);\n}\nfunction assertTSIndexedAccessType(node, opts) {\n    assert(\"TSIndexedAccessType\", node, opts);\n}\nfunction assertTSMappedType(node, opts) {\n    assert(\"TSMappedType\", node, opts);\n}\nfunction assertTSLiteralType(node, opts) {\n    assert(\"TSLiteralType\", node, opts);\n}\nfunction assertTSExpressionWithTypeArguments(node, opts) {\n    assert(\"TSExpressionWithTypeArguments\", node, opts);\n}\nfunction assertTSInterfaceDeclaration(node, opts) {\n    assert(\"TSInterfaceDeclaration\", node, opts);\n}\nfunction assertTSInterfaceBody(node, opts) {\n    assert(\"TSInterfaceBody\", node, opts);\n}\nfunction assertTSTypeAliasDeclaration(node, opts) {\n    assert(\"TSTypeAliasDeclaration\", node, opts);\n}\nfunction assertTSAsExpression(node, opts) {\n    assert(\"TSAsExpression\", node, opts);\n}\nfunction assertTSTypeAssertion(node, opts) {\n    assert(\"TSTypeAssertion\", node, opts);\n}\nfunction assertTSEnumDeclaration(node, opts) {\n    assert(\"TSEnumDeclaration\", node, opts);\n}\nfunction assertTSEnumMember(node, opts) {\n    assert(\"TSEnumMember\", node, opts);\n}\nfunction assertTSModuleDeclaration(node, opts) {\n    assert(\"TSModuleDeclaration\", node, opts);\n}\nfunction assertTSModuleBlock(node, opts) {\n    assert(\"TSModuleBlock\", node, opts);\n}\nfunction assertTSImportType(node, opts) {\n    assert(\"TSImportType\", node, opts);\n}\nfunction assertTSImportEqualsDeclaration(node, opts) {\n    assert(\"TSImportEqualsDeclaration\", node, opts);\n}\nfunction assertTSExternalModuleReference(node, opts) {\n    assert(\"TSExternalModuleReference\", node, opts);\n}\nfunction assertTSNonNullExpression(node, opts) {\n    assert(\"TSNonNullExpression\", node, opts);\n}\nfunction assertTSExportAssignment(node, opts) {\n    assert(\"TSExportAssignment\", node, opts);\n}\nfunction assertTSNamespaceExportDeclaration(node, opts) {\n    assert(\"TSNamespaceExportDeclaration\", node, opts);\n}\nfunction assertTSTypeAnnotation(node, opts) {\n    assert(\"TSTypeAnnotation\", node, opts);\n}\nfunction assertTSTypeParameterInstantiation(node, opts) {\n    assert(\"TSTypeParameterInstantiation\", node, opts);\n}\nfunction assertTSTypeParameterDeclaration(node, opts) {\n    assert(\"TSTypeParameterDeclaration\", node, opts);\n}\nfunction assertTSTypeParameter(node, opts) {\n    assert(\"TSTypeParameter\", node, opts);\n}\nfunction assertExpression(node, opts) {\n    assert(\"Expression\", node, opts);\n}\nfunction assertBinary(node, opts) {\n    assert(\"Binary\", node, opts);\n}\nfunction assertScopable(node, opts) {\n    assert(\"Scopable\", node, opts);\n}\nfunction assertBlockParent(node, opts) {\n    assert(\"BlockParent\", node, opts);\n}\nfunction assertBlock(node, opts) {\n    assert(\"Block\", node, opts);\n}\nfunction assertStatement(node, opts) {\n    assert(\"Statement\", node, opts);\n}\nfunction assertTerminatorless(node, opts) {\n    assert(\"Terminatorless\", node, opts);\n}\nfunction assertCompletionStatement(node, opts) {\n    assert(\"CompletionStatement\", node, opts);\n}\nfunction assertConditional(node, opts) {\n    assert(\"Conditional\", node, opts);\n}\nfunction assertLoop(node, opts) {\n    assert(\"Loop\", node, opts);\n}\nfunction assertWhile(node, opts) {\n    assert(\"While\", node, opts);\n}\nfunction assertExpressionWrapper(node, opts) {\n    assert(\"ExpressionWrapper\", node, opts);\n}\nfunction assertFor(node, opts) {\n    assert(\"For\", node, opts);\n}\nfunction assertForXStatement(node, opts) {\n    assert(\"ForXStatement\", node, opts);\n}\nfunction assertFunction(node, opts) {\n    assert(\"Function\", node, opts);\n}\nfunction assertFunctionParent(node, opts) {\n    assert(\"FunctionParent\", node, opts);\n}\nfunction assertPureish(node, opts) {\n    assert(\"Pureish\", node, opts);\n}\nfunction assertDeclaration(node, opts) {\n    assert(\"Declaration\", node, opts);\n}\nfunction assertPatternLike(node, opts) {\n    assert(\"PatternLike\", node, opts);\n}\nfunction assertLVal(node, opts) {\n    assert(\"LVal\", node, opts);\n}\nfunction assertTSEntityName(node, opts) {\n    assert(\"TSEntityName\", node, opts);\n}\nfunction assertLiteral(node, opts) {\n    assert(\"Literal\", node, opts);\n}\nfunction assertImmutable(node, opts) {\n    assert(\"Immutable\", node, opts);\n}\nfunction assertUserWhitespacable(node, opts) {\n    assert(\"UserWhitespacable\", node, opts);\n}\nfunction assertMethod(node, opts) {\n    assert(\"Method\", node, opts);\n}\nfunction assertObjectMember(node, opts) {\n    assert(\"ObjectMember\", node, opts);\n}\nfunction assertProperty(node, opts) {\n    assert(\"Property\", node, opts);\n}\nfunction assertUnaryLike(node, opts) {\n    assert(\"UnaryLike\", node, opts);\n}\nfunction assertPattern(node, opts) {\n    assert(\"Pattern\", node, opts);\n}\nfunction assertClass(node, opts) {\n    assert(\"Class\", node, opts);\n}\nfunction assertModuleDeclaration(node, opts) {\n    assert(\"ModuleDeclaration\", node, opts);\n}\nfunction assertExportDeclaration(node, opts) {\n    assert(\"ExportDeclaration\", node, opts);\n}\nfunction assertModuleSpecifier(node, opts) {\n    assert(\"ModuleSpecifier\", node, opts);\n}\nfunction assertPrivate(node, opts) {\n    assert(\"Private\", node, opts);\n}\nfunction assertFlow(node, opts) {\n    assert(\"Flow\", node, opts);\n}\nfunction assertFlowType(node, opts) {\n    assert(\"FlowType\", node, opts);\n}\nfunction assertFlowBaseAnnotation(node, opts) {\n    assert(\"FlowBaseAnnotation\", node, opts);\n}\nfunction assertFlowDeclaration(node, opts) {\n    assert(\"FlowDeclaration\", node, opts);\n}\nfunction assertFlowPredicate(node, opts) {\n    assert(\"FlowPredicate\", node, opts);\n}\nfunction assertEnumBody(node, opts) {\n    assert(\"EnumBody\", node, opts);\n}\nfunction assertEnumMember(node, opts) {\n    assert(\"EnumMember\", node, opts);\n}\nfunction assertJSX(node, opts) {\n    assert(\"JSX\", node, opts);\n}\nfunction assertTSTypeElement(node, opts) {\n    assert(\"TSTypeElement\", node, opts);\n}\nfunction assertTSType(node, opts) {\n    assert(\"TSType\", node, opts);\n}\nfunction assertTSBaseType(node, opts) {\n    assert(\"TSBaseType\", node, opts);\n}\nfunction assertNumberLiteral(node, opts) {\n    console.trace(\"The node type NumberLiteral has been renamed to NumericLiteral\");\n    assert(\"NumberLiteral\", node, opts);\n}\nfunction assertRegexLiteral(node, opts) {\n    console.trace(\"The node type RegexLiteral has been renamed to RegExpLiteral\");\n    assert(\"RegexLiteral\", node, opts);\n}\nfunction assertRestProperty(node, opts) {\n    console.trace(\"The node type RestProperty has been renamed to RestElement\");\n    assert(\"RestProperty\", node, opts);\n}\nfunction assertSpreadProperty(node, opts) {\n    console.trace(\"The node type SpreadProperty has been renamed to SpreadElement\");\n    assert(\"SpreadProperty\", node, opts);\n}\n\nvar createTypeAnnotationBasedOnTypeof$1 = {};\n\nObject.defineProperty(createTypeAnnotationBasedOnTypeof$1, \"__esModule\", {\n    value: true\n});\ncreateTypeAnnotationBasedOnTypeof$1.default = createTypeAnnotationBasedOnTypeof;\nvar _generated$l = generated$3;\nfunction createTypeAnnotationBasedOnTypeof(type) {\n    if (type === \"string\") {\n        return (0, _generated$l.stringTypeAnnotation)();\n    } else if (type === \"number\") {\n        return (0, _generated$l.numberTypeAnnotation)();\n    } else if (type === \"undefined\") {\n        return (0, _generated$l.voidTypeAnnotation)();\n    } else if (type === \"boolean\") {\n        return (0, _generated$l.booleanTypeAnnotation)();\n    } else if (type === \"function\") {\n        return (0, _generated$l.genericTypeAnnotation)((0, _generated$l.identifier)(\"Function\"));\n    } else if (type === \"object\") {\n        return (0, _generated$l.genericTypeAnnotation)((0, _generated$l.identifier)(\"Object\"));\n    } else if (type === \"symbol\") {\n        return (0, _generated$l.genericTypeAnnotation)((0, _generated$l.identifier)(\"Symbol\"));\n    } else if (type === \"bigint\") {\n        return (0, _generated$l.anyTypeAnnotation)();\n    } else {\n        throw new Error(\"Invalid typeof value: \" + type);\n    }\n}\n\nvar createFlowUnionType$1 = {};\n\nvar removeTypeDuplicates$3 = {};\n\nfunction _createForOfIteratorHelperLoose$c(o, allowArrayLike) {\n    var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n    if (it) return (it = it.call(o)).next.bind(it);\n    if (Array.isArray(o) || (it = unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n        if (it) o = it;\n        var i = 0;\n        return function() {\n            if (i >= o.length) return {\n                done: true\n            };\n            return {\n                done: false,\n                value: o[i++]\n            };\n        };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nObject.defineProperty(removeTypeDuplicates$3, \"__esModule\", {\n    value: true\n});\nremoveTypeDuplicates$3.default = removeTypeDuplicates$2;\nvar _generated$k = generated$4;\nfunction getQualifiedName(node) {\n    return (0, _generated$k.isIdentifier)(node) ? node.name : node.id.name + \".\" + getQualifiedName(node.qualification);\n}\nfunction removeTypeDuplicates$2(nodes) {\n    var generics = {};\n    var bases = {};\n    var typeGroups = [];\n    var types = [];\n    for(var i = 0; i < nodes.length; i++){\n        var node = nodes[i];\n        if (!node) continue;\n        if (types.indexOf(node) >= 0) {\n            continue;\n        }\n        if ((0, _generated$k.isAnyTypeAnnotation)(node)) {\n            return [\n                node\n            ];\n        }\n        if ((0, _generated$k.isFlowBaseAnnotation)(node)) {\n            bases[node.type] = node;\n            continue;\n        }\n        if ((0, _generated$k.isUnionTypeAnnotation)(node)) {\n            if (typeGroups.indexOf(node.types) < 0) {\n                nodes = nodes.concat(node.types);\n                typeGroups.push(node.types);\n            }\n            continue;\n        }\n        if ((0, _generated$k.isGenericTypeAnnotation)(node)) {\n            var name = getQualifiedName(node.id);\n            if (generics[name]) {\n                var existing = generics[name];\n                if (existing.typeParameters) {\n                    if (node.typeParameters) {\n                        existing.typeParameters.params = removeTypeDuplicates$2(existing.typeParameters.params.concat(node.typeParameters.params));\n                    }\n                } else {\n                    existing = node.typeParameters;\n                }\n            } else {\n                generics[name] = node;\n            }\n            continue;\n        }\n        types.push(node);\n    }\n    for(var _iterator = _createForOfIteratorHelperLoose$c(Object.keys(bases)), _step; !(_step = _iterator()).done;){\n        var type = _step.value;\n        types.push(bases[type]);\n    }\n    for(var _iterator1 = _createForOfIteratorHelperLoose$c(Object.keys(generics)), _step1; !(_step1 = _iterator1()).done;){\n        var name1 = _step1.value;\n        types.push(generics[name1]);\n    }\n    return types;\n}\n\nObject.defineProperty(createFlowUnionType$1, \"__esModule\", {\n    value: true\n});\ncreateFlowUnionType$1.default = createFlowUnionType;\nvar _generated$j = generated$3;\nvar _removeTypeDuplicates$1 = removeTypeDuplicates$3;\nfunction createFlowUnionType(types) {\n    var flattened = (0, _removeTypeDuplicates$1.default)(types);\n    if (flattened.length === 1) {\n        return flattened[0];\n    } else {\n        return (0, _generated$j.unionTypeAnnotation)(flattened);\n    }\n}\n\nvar createTSUnionType$1 = {};\n\nvar removeTypeDuplicates$1 = {};\n\nfunction _createForOfIteratorHelperLoose$b(o, allowArrayLike) {\n    var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n    if (it) return (it = it.call(o)).next.bind(it);\n    if (Array.isArray(o) || (it = unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n        if (it) o = it;\n        var i = 0;\n        return function() {\n            if (i >= o.length) return {\n                done: true\n            };\n            return {\n                done: false,\n                value: o[i++]\n            };\n        };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nObject.defineProperty(removeTypeDuplicates$1, \"__esModule\", {\n    value: true\n});\nremoveTypeDuplicates$1.default = removeTypeDuplicates;\nvar _generated$i = generated$4;\nfunction removeTypeDuplicates(nodes) {\n    var generics = {};\n    var bases = {};\n    var typeGroups = [];\n    var types = [];\n    for(var i = 0; i < nodes.length; i++){\n        var node = nodes[i];\n        if (!node) continue;\n        if (types.indexOf(node) >= 0) {\n            continue;\n        }\n        if ((0, _generated$i.isTSAnyKeyword)(node)) {\n            return [\n                node\n            ];\n        }\n        if ((0, _generated$i.isTSBaseType)(node)) {\n            bases[node.type] = node;\n            continue;\n        }\n        if ((0, _generated$i.isTSUnionType)(node)) {\n            if (typeGroups.indexOf(node.types) < 0) {\n                nodes = nodes.concat(node.types);\n                typeGroups.push(node.types);\n            }\n            continue;\n        }\n        types.push(node);\n    }\n    for(var _iterator = _createForOfIteratorHelperLoose$b(Object.keys(bases)), _step; !(_step = _iterator()).done;){\n        var type = _step.value;\n        types.push(bases[type]);\n    }\n    for(var _iterator1 = _createForOfIteratorHelperLoose$b(Object.keys(generics)), _step1; !(_step1 = _iterator1()).done;){\n        var name = _step1.value;\n        types.push(generics[name]);\n    }\n    return types;\n}\n\nObject.defineProperty(createTSUnionType$1, \"__esModule\", {\n    value: true\n});\ncreateTSUnionType$1.default = createTSUnionType;\nvar _generated$h = generated$3;\nvar _removeTypeDuplicates = removeTypeDuplicates$1;\nfunction createTSUnionType(typeAnnotations) {\n    var types = typeAnnotations.map(function(type) {\n        return type.typeAnnotation;\n    });\n    var flattened = (0, _removeTypeDuplicates.default)(types);\n    if (flattened.length === 1) {\n        return flattened[0];\n    } else {\n        return (0, _generated$h.tsUnionType)(flattened);\n    }\n}\n\nvar uppercase = {};\n\n(function(exports) {\n    Object.defineProperty(exports, \"__esModule\", {\n        value: true\n    });\n    Object.defineProperty(exports, \"ArrayExpression\", {\n        enumerable: true,\n        get: function get() {\n            return _index.arrayExpression;\n        }\n    });\n    Object.defineProperty(exports, \"AssignmentExpression\", {\n        enumerable: true,\n        get: function get() {\n            return _index.assignmentExpression;\n        }\n    });\n    Object.defineProperty(exports, \"BinaryExpression\", {\n        enumerable: true,\n        get: function get() {\n            return _index.binaryExpression;\n        }\n    });\n    Object.defineProperty(exports, \"InterpreterDirective\", {\n        enumerable: true,\n        get: function get() {\n            return _index.interpreterDirective;\n        }\n    });\n    Object.defineProperty(exports, \"Directive\", {\n        enumerable: true,\n        get: function get() {\n            return _index.directive;\n        }\n    });\n    Object.defineProperty(exports, \"DirectiveLiteral\", {\n        enumerable: true,\n        get: function get() {\n            return _index.directiveLiteral;\n        }\n    });\n    Object.defineProperty(exports, \"BlockStatement\", {\n        enumerable: true,\n        get: function get() {\n            return _index.blockStatement;\n        }\n    });\n    Object.defineProperty(exports, \"BreakStatement\", {\n        enumerable: true,\n        get: function get() {\n            return _index.breakStatement;\n        }\n    });\n    Object.defineProperty(exports, \"CallExpression\", {\n        enumerable: true,\n        get: function get() {\n            return _index.callExpression;\n        }\n    });\n    Object.defineProperty(exports, \"CatchClause\", {\n        enumerable: true,\n        get: function get() {\n            return _index.catchClause;\n        }\n    });\n    Object.defineProperty(exports, \"ConditionalExpression\", {\n        enumerable: true,\n        get: function get() {\n            return _index.conditionalExpression;\n        }\n    });\n    Object.defineProperty(exports, \"ContinueStatement\", {\n        enumerable: true,\n        get: function get() {\n            return _index.continueStatement;\n        }\n    });\n    Object.defineProperty(exports, \"DebuggerStatement\", {\n        enumerable: true,\n        get: function get() {\n            return _index.debuggerStatement;\n        }\n    });\n    Object.defineProperty(exports, \"DoWhileStatement\", {\n        enumerable: true,\n        get: function get() {\n            return _index.doWhileStatement;\n        }\n    });\n    Object.defineProperty(exports, \"EmptyStatement\", {\n        enumerable: true,\n        get: function get() {\n            return _index.emptyStatement;\n        }\n    });\n    Object.defineProperty(exports, \"ExpressionStatement\", {\n        enumerable: true,\n        get: function get() {\n            return _index.expressionStatement;\n        }\n    });\n    Object.defineProperty(exports, \"File\", {\n        enumerable: true,\n        get: function get() {\n            return _index.file;\n        }\n    });\n    Object.defineProperty(exports, \"ForInStatement\", {\n        enumerable: true,\n        get: function get() {\n            return _index.forInStatement;\n        }\n    });\n    Object.defineProperty(exports, \"ForStatement\", {\n        enumerable: true,\n        get: function get() {\n            return _index.forStatement;\n        }\n    });\n    Object.defineProperty(exports, \"FunctionDeclaration\", {\n        enumerable: true,\n        get: function get() {\n            return _index.functionDeclaration;\n        }\n    });\n    Object.defineProperty(exports, \"FunctionExpression\", {\n        enumerable: true,\n        get: function get() {\n            return _index.functionExpression;\n        }\n    });\n    Object.defineProperty(exports, \"Identifier\", {\n        enumerable: true,\n        get: function get() {\n            return _index.identifier;\n        }\n    });\n    Object.defineProperty(exports, \"IfStatement\", {\n        enumerable: true,\n        get: function get() {\n            return _index.ifStatement;\n        }\n    });\n    Object.defineProperty(exports, \"LabeledStatement\", {\n        enumerable: true,\n        get: function get() {\n            return _index.labeledStatement;\n        }\n    });\n    Object.defineProperty(exports, \"StringLiteral\", {\n        enumerable: true,\n        get: function get() {\n            return _index.stringLiteral;\n        }\n    });\n    Object.defineProperty(exports, \"NumericLiteral\", {\n        enumerable: true,\n        get: function get() {\n            return _index.numericLiteral;\n        }\n    });\n    Object.defineProperty(exports, \"NullLiteral\", {\n        enumerable: true,\n        get: function get() {\n            return _index.nullLiteral;\n        }\n    });\n    Object.defineProperty(exports, \"BooleanLiteral\", {\n        enumerable: true,\n        get: function get() {\n            return _index.booleanLiteral;\n        }\n    });\n    Object.defineProperty(exports, \"RegExpLiteral\", {\n        enumerable: true,\n        get: function get() {\n            return _index.regExpLiteral;\n        }\n    });\n    Object.defineProperty(exports, \"LogicalExpression\", {\n        enumerable: true,\n        get: function get() {\n            return _index.logicalExpression;\n        }\n    });\n    Object.defineProperty(exports, \"MemberExpression\", {\n        enumerable: true,\n        get: function get() {\n            return _index.memberExpression;\n        }\n    });\n    Object.defineProperty(exports, \"NewExpression\", {\n        enumerable: true,\n        get: function get() {\n            return _index.newExpression;\n        }\n    });\n    Object.defineProperty(exports, \"Program\", {\n        enumerable: true,\n        get: function get() {\n            return _index.program;\n        }\n    });\n    Object.defineProperty(exports, \"ObjectExpression\", {\n        enumerable: true,\n        get: function get() {\n            return _index.objectExpression;\n        }\n    });\n    Object.defineProperty(exports, \"ObjectMethod\", {\n        enumerable: true,\n        get: function get() {\n            return _index.objectMethod;\n        }\n    });\n    Object.defineProperty(exports, \"ObjectProperty\", {\n        enumerable: true,\n        get: function get() {\n            return _index.objectProperty;\n        }\n    });\n    Object.defineProperty(exports, \"RestElement\", {\n        enumerable: true,\n        get: function get() {\n            return _index.restElement;\n        }\n    });\n    Object.defineProperty(exports, \"ReturnStatement\", {\n        enumerable: true,\n        get: function get() {\n            return _index.returnStatement;\n        }\n    });\n    Object.defineProperty(exports, \"SequenceExpression\", {\n        enumerable: true,\n        get: function get() {\n            return _index.sequenceExpression;\n        }\n    });\n    Object.defineProperty(exports, \"ParenthesizedExpression\", {\n        enumerable: true,\n        get: function get() {\n            return _index.parenthesizedExpression;\n        }\n    });\n    Object.defineProperty(exports, \"SwitchCase\", {\n        enumerable: true,\n        get: function get() {\n            return _index.switchCase;\n        }\n    });\n    Object.defineProperty(exports, \"SwitchStatement\", {\n        enumerable: true,\n        get: function get() {\n            return _index.switchStatement;\n        }\n    });\n    Object.defineProperty(exports, \"ThisExpression\", {\n        enumerable: true,\n        get: function get() {\n            return _index.thisExpression;\n        }\n    });\n    Object.defineProperty(exports, \"ThrowStatement\", {\n        enumerable: true,\n        get: function get() {\n            return _index.throwStatement;\n        }\n    });\n    Object.defineProperty(exports, \"TryStatement\", {\n        enumerable: true,\n        get: function get() {\n            return _index.tryStatement;\n        }\n    });\n    Object.defineProperty(exports, \"UnaryExpression\", {\n        enumerable: true,\n        get: function get() {\n            return _index.unaryExpression;\n        }\n    });\n    Object.defineProperty(exports, \"UpdateExpression\", {\n        enumerable: true,\n        get: function get() {\n            return _index.updateExpression;\n        }\n    });\n    Object.defineProperty(exports, \"VariableDeclaration\", {\n        enumerable: true,\n        get: function get() {\n            return _index.variableDeclaration;\n        }\n    });\n    Object.defineProperty(exports, \"VariableDeclarator\", {\n        enumerable: true,\n        get: function get() {\n            return _index.variableDeclarator;\n        }\n    });\n    Object.defineProperty(exports, \"WhileStatement\", {\n        enumerable: true,\n        get: function get() {\n            return _index.whileStatement;\n        }\n    });\n    Object.defineProperty(exports, \"WithStatement\", {\n        enumerable: true,\n        get: function get() {\n            return _index.withStatement;\n        }\n    });\n    Object.defineProperty(exports, \"AssignmentPattern\", {\n        enumerable: true,\n        get: function get() {\n            return _index.assignmentPattern;\n        }\n    });\n    Object.defineProperty(exports, \"ArrayPattern\", {\n        enumerable: true,\n        get: function get() {\n            return _index.arrayPattern;\n        }\n    });\n    Object.defineProperty(exports, \"ArrowFunctionExpression\", {\n        enumerable: true,\n        get: function get() {\n            return _index.arrowFunctionExpression;\n        }\n    });\n    Object.defineProperty(exports, \"ClassBody\", {\n        enumerable: true,\n        get: function get() {\n            return _index.classBody;\n        }\n    });\n    Object.defineProperty(exports, \"ClassExpression\", {\n        enumerable: true,\n        get: function get() {\n            return _index.classExpression;\n        }\n    });\n    Object.defineProperty(exports, \"ClassDeclaration\", {\n        enumerable: true,\n        get: function get() {\n            return _index.classDeclaration;\n        }\n    });\n    Object.defineProperty(exports, \"ExportAllDeclaration\", {\n        enumerable: true,\n        get: function get() {\n            return _index.exportAllDeclaration;\n        }\n    });\n    Object.defineProperty(exports, \"ExportDefaultDeclaration\", {\n        enumerable: true,\n        get: function get() {\n            return _index.exportDefaultDeclaration;\n        }\n    });\n    Object.defineProperty(exports, \"ExportNamedDeclaration\", {\n        enumerable: true,\n        get: function get() {\n            return _index.exportNamedDeclaration;\n        }\n    });\n    Object.defineProperty(exports, \"ExportSpecifier\", {\n        enumerable: true,\n        get: function get() {\n            return _index.exportSpecifier;\n        }\n    });\n    Object.defineProperty(exports, \"ForOfStatement\", {\n        enumerable: true,\n        get: function get() {\n            return _index.forOfStatement;\n        }\n    });\n    Object.defineProperty(exports, \"ImportDeclaration\", {\n        enumerable: true,\n        get: function get() {\n            return _index.importDeclaration;\n        }\n    });\n    Object.defineProperty(exports, \"ImportDefaultSpecifier\", {\n        enumerable: true,\n        get: function get() {\n            return _index.importDefaultSpecifier;\n        }\n    });\n    Object.defineProperty(exports, \"ImportNamespaceSpecifier\", {\n        enumerable: true,\n        get: function get() {\n            return _index.importNamespaceSpecifier;\n        }\n    });\n    Object.defineProperty(exports, \"ImportSpecifier\", {\n        enumerable: true,\n        get: function get() {\n            return _index.importSpecifier;\n        }\n    });\n    Object.defineProperty(exports, \"MetaProperty\", {\n        enumerable: true,\n        get: function get() {\n            return _index.metaProperty;\n        }\n    });\n    Object.defineProperty(exports, \"ClassMethod\", {\n        enumerable: true,\n        get: function get() {\n            return _index.classMethod;\n        }\n    });\n    Object.defineProperty(exports, \"ObjectPattern\", {\n        enumerable: true,\n        get: function get() {\n            return _index.objectPattern;\n        }\n    });\n    Object.defineProperty(exports, \"SpreadElement\", {\n        enumerable: true,\n        get: function get() {\n            return _index.spreadElement;\n        }\n    });\n    Object.defineProperty(exports, \"Super\", {\n        enumerable: true,\n        get: function get() {\n            return _index.super;\n        }\n    });\n    Object.defineProperty(exports, \"TaggedTemplateExpression\", {\n        enumerable: true,\n        get: function get() {\n            return _index.taggedTemplateExpression;\n        }\n    });\n    Object.defineProperty(exports, \"TemplateElement\", {\n        enumerable: true,\n        get: function get() {\n            return _index.templateElement;\n        }\n    });\n    Object.defineProperty(exports, \"TemplateLiteral\", {\n        enumerable: true,\n        get: function get() {\n            return _index.templateLiteral;\n        }\n    });\n    Object.defineProperty(exports, \"YieldExpression\", {\n        enumerable: true,\n        get: function get() {\n            return _index.yieldExpression;\n        }\n    });\n    Object.defineProperty(exports, \"AwaitExpression\", {\n        enumerable: true,\n        get: function get() {\n            return _index.awaitExpression;\n        }\n    });\n    Object.defineProperty(exports, \"Import\", {\n        enumerable: true,\n        get: function get() {\n            return _index.import;\n        }\n    });\n    Object.defineProperty(exports, \"BigIntLiteral\", {\n        enumerable: true,\n        get: function get() {\n            return _index.bigIntLiteral;\n        }\n    });\n    Object.defineProperty(exports, \"ExportNamespaceSpecifier\", {\n        enumerable: true,\n        get: function get() {\n            return _index.exportNamespaceSpecifier;\n        }\n    });\n    Object.defineProperty(exports, \"OptionalMemberExpression\", {\n        enumerable: true,\n        get: function get() {\n            return _index.optionalMemberExpression;\n        }\n    });\n    Object.defineProperty(exports, \"OptionalCallExpression\", {\n        enumerable: true,\n        get: function get() {\n            return _index.optionalCallExpression;\n        }\n    });\n    Object.defineProperty(exports, \"ClassProperty\", {\n        enumerable: true,\n        get: function get() {\n            return _index.classProperty;\n        }\n    });\n    Object.defineProperty(exports, \"ClassPrivateProperty\", {\n        enumerable: true,\n        get: function get() {\n            return _index.classPrivateProperty;\n        }\n    });\n    Object.defineProperty(exports, \"ClassPrivateMethod\", {\n        enumerable: true,\n        get: function get() {\n            return _index.classPrivateMethod;\n        }\n    });\n    Object.defineProperty(exports, \"PrivateName\", {\n        enumerable: true,\n        get: function get() {\n            return _index.privateName;\n        }\n    });\n    Object.defineProperty(exports, \"AnyTypeAnnotation\", {\n        enumerable: true,\n        get: function get() {\n            return _index.anyTypeAnnotation;\n        }\n    });\n    Object.defineProperty(exports, \"ArrayTypeAnnotation\", {\n        enumerable: true,\n        get: function get() {\n            return _index.arrayTypeAnnotation;\n        }\n    });\n    Object.defineProperty(exports, \"BooleanTypeAnnotation\", {\n        enumerable: true,\n        get: function get() {\n            return _index.booleanTypeAnnotation;\n        }\n    });\n    Object.defineProperty(exports, \"BooleanLiteralTypeAnnotation\", {\n        enumerable: true,\n        get: function get() {\n            return _index.booleanLiteralTypeAnnotation;\n        }\n    });\n    Object.defineProperty(exports, \"NullLiteralTypeAnnotation\", {\n        enumerable: true,\n        get: function get() {\n            return _index.nullLiteralTypeAnnotation;\n        }\n    });\n    Object.defineProperty(exports, \"ClassImplements\", {\n        enumerable: true,\n        get: function get() {\n            return _index.classImplements;\n        }\n    });\n    Object.defineProperty(exports, \"DeclareClass\", {\n        enumerable: true,\n        get: function get() {\n            return _index.declareClass;\n        }\n    });\n    Object.defineProperty(exports, \"DeclareFunction\", {\n        enumerable: true,\n        get: function get() {\n            return _index.declareFunction;\n        }\n    });\n    Object.defineProperty(exports, \"DeclareInterface\", {\n        enumerable: true,\n        get: function get() {\n            return _index.declareInterface;\n        }\n    });\n    Object.defineProperty(exports, \"DeclareModule\", {\n        enumerable: true,\n        get: function get() {\n            return _index.declareModule;\n        }\n    });\n    Object.defineProperty(exports, \"DeclareModuleExports\", {\n        enumerable: true,\n        get: function get() {\n            return _index.declareModuleExports;\n        }\n    });\n    Object.defineProperty(exports, \"DeclareTypeAlias\", {\n        enumerable: true,\n        get: function get() {\n            return _index.declareTypeAlias;\n        }\n    });\n    Object.defineProperty(exports, \"DeclareOpaqueType\", {\n        enumerable: true,\n        get: function get() {\n            return _index.declareOpaqueType;\n        }\n    });\n    Object.defineProperty(exports, \"DeclareVariable\", {\n        enumerable: true,\n        get: function get() {\n            return _index.declareVariable;\n        }\n    });\n    Object.defineProperty(exports, \"DeclareExportDeclaration\", {\n        enumerable: true,\n        get: function get() {\n            return _index.declareExportDeclaration;\n        }\n    });\n    Object.defineProperty(exports, \"DeclareExportAllDeclaration\", {\n        enumerable: true,\n        get: function get() {\n            return _index.declareExportAllDeclaration;\n        }\n    });\n    Object.defineProperty(exports, \"DeclaredPredicate\", {\n        enumerable: true,\n        get: function get() {\n            return _index.declaredPredicate;\n        }\n    });\n    Object.defineProperty(exports, \"ExistsTypeAnnotation\", {\n        enumerable: true,\n        get: function get() {\n            return _index.existsTypeAnnotation;\n        }\n    });\n    Object.defineProperty(exports, \"FunctionTypeAnnotation\", {\n        enumerable: true,\n        get: function get() {\n            return _index.functionTypeAnnotation;\n        }\n    });\n    Object.defineProperty(exports, \"FunctionTypeParam\", {\n        enumerable: true,\n        get: function get() {\n            return _index.functionTypeParam;\n        }\n    });\n    Object.defineProperty(exports, \"GenericTypeAnnotation\", {\n        enumerable: true,\n        get: function get() {\n            return _index.genericTypeAnnotation;\n        }\n    });\n    Object.defineProperty(exports, \"InferredPredicate\", {\n        enumerable: true,\n        get: function get() {\n            return _index.inferredPredicate;\n        }\n    });\n    Object.defineProperty(exports, \"InterfaceExtends\", {\n        enumerable: true,\n        get: function get() {\n            return _index.interfaceExtends;\n        }\n    });\n    Object.defineProperty(exports, \"InterfaceDeclaration\", {\n        enumerable: true,\n        get: function get() {\n            return _index.interfaceDeclaration;\n        }\n    });\n    Object.defineProperty(exports, \"InterfaceTypeAnnotation\", {\n        enumerable: true,\n        get: function get() {\n            return _index.interfaceTypeAnnotation;\n        }\n    });\n    Object.defineProperty(exports, \"IntersectionTypeAnnotation\", {\n        enumerable: true,\n        get: function get() {\n            return _index.intersectionTypeAnnotation;\n        }\n    });\n    Object.defineProperty(exports, \"MixedTypeAnnotation\", {\n        enumerable: true,\n        get: function get() {\n            return _index.mixedTypeAnnotation;\n        }\n    });\n    Object.defineProperty(exports, \"EmptyTypeAnnotation\", {\n        enumerable: true,\n        get: function get() {\n            return _index.emptyTypeAnnotation;\n        }\n    });\n    Object.defineProperty(exports, \"NullableTypeAnnotation\", {\n        enumerable: true,\n        get: function get() {\n            return _index.nullableTypeAnnotation;\n        }\n    });\n    Object.defineProperty(exports, \"NumberLiteralTypeAnnotation\", {\n        enumerable: true,\n        get: function get() {\n            return _index.numberLiteralTypeAnnotation;\n        }\n    });\n    Object.defineProperty(exports, \"NumberTypeAnnotation\", {\n        enumerable: true,\n        get: function get() {\n            return _index.numberTypeAnnotation;\n        }\n    });\n    Object.defineProperty(exports, \"ObjectTypeAnnotation\", {\n        enumerable: true,\n        get: function get() {\n            return _index.objectTypeAnnotation;\n        }\n    });\n    Object.defineProperty(exports, \"ObjectTypeInternalSlot\", {\n        enumerable: true,\n        get: function get() {\n            return _index.objectTypeInternalSlot;\n        }\n    });\n    Object.defineProperty(exports, \"ObjectTypeCallProperty\", {\n        enumerable: true,\n        get: function get() {\n            return _index.objectTypeCallProperty;\n        }\n    });\n    Object.defineProperty(exports, \"ObjectTypeIndexer\", {\n        enumerable: true,\n        get: function get() {\n            return _index.objectTypeIndexer;\n        }\n    });\n    Object.defineProperty(exports, \"ObjectTypeProperty\", {\n        enumerable: true,\n        get: function get() {\n            return _index.objectTypeProperty;\n        }\n    });\n    Object.defineProperty(exports, \"ObjectTypeSpreadProperty\", {\n        enumerable: true,\n        get: function get() {\n            return _index.objectTypeSpreadProperty;\n        }\n    });\n    Object.defineProperty(exports, \"OpaqueType\", {\n        enumerable: true,\n        get: function get() {\n            return _index.opaqueType;\n        }\n    });\n    Object.defineProperty(exports, \"QualifiedTypeIdentifier\", {\n        enumerable: true,\n        get: function get() {\n            return _index.qualifiedTypeIdentifier;\n        }\n    });\n    Object.defineProperty(exports, \"StringLiteralTypeAnnotation\", {\n        enumerable: true,\n        get: function get() {\n            return _index.stringLiteralTypeAnnotation;\n        }\n    });\n    Object.defineProperty(exports, \"StringTypeAnnotation\", {\n        enumerable: true,\n        get: function get() {\n            return _index.stringTypeAnnotation;\n        }\n    });\n    Object.defineProperty(exports, \"SymbolTypeAnnotation\", {\n        enumerable: true,\n        get: function get() {\n            return _index.symbolTypeAnnotation;\n        }\n    });\n    Object.defineProperty(exports, \"ThisTypeAnnotation\", {\n        enumerable: true,\n        get: function get() {\n            return _index.thisTypeAnnotation;\n        }\n    });\n    Object.defineProperty(exports, \"TupleTypeAnnotation\", {\n        enumerable: true,\n        get: function get() {\n            return _index.tupleTypeAnnotation;\n        }\n    });\n    Object.defineProperty(exports, \"TypeofTypeAnnotation\", {\n        enumerable: true,\n        get: function get() {\n            return _index.typeofTypeAnnotation;\n        }\n    });\n    Object.defineProperty(exports, \"TypeAlias\", {\n        enumerable: true,\n        get: function get() {\n            return _index.typeAlias;\n        }\n    });\n    Object.defineProperty(exports, \"TypeAnnotation\", {\n        enumerable: true,\n        get: function get() {\n            return _index.typeAnnotation;\n        }\n    });\n    Object.defineProperty(exports, \"TypeCastExpression\", {\n        enumerable: true,\n        get: function get() {\n            return _index.typeCastExpression;\n        }\n    });\n    Object.defineProperty(exports, \"TypeParameter\", {\n        enumerable: true,\n        get: function get() {\n            return _index.typeParameter;\n        }\n    });\n    Object.defineProperty(exports, \"TypeParameterDeclaration\", {\n        enumerable: true,\n        get: function get() {\n            return _index.typeParameterDeclaration;\n        }\n    });\n    Object.defineProperty(exports, \"TypeParameterInstantiation\", {\n        enumerable: true,\n        get: function get() {\n            return _index.typeParameterInstantiation;\n        }\n    });\n    Object.defineProperty(exports, \"UnionTypeAnnotation\", {\n        enumerable: true,\n        get: function get() {\n            return _index.unionTypeAnnotation;\n        }\n    });\n    Object.defineProperty(exports, \"Variance\", {\n        enumerable: true,\n        get: function get() {\n            return _index.variance;\n        }\n    });\n    Object.defineProperty(exports, \"VoidTypeAnnotation\", {\n        enumerable: true,\n        get: function get() {\n            return _index.voidTypeAnnotation;\n        }\n    });\n    Object.defineProperty(exports, \"EnumDeclaration\", {\n        enumerable: true,\n        get: function get() {\n            return _index.enumDeclaration;\n        }\n    });\n    Object.defineProperty(exports, \"EnumBooleanBody\", {\n        enumerable: true,\n        get: function get() {\n            return _index.enumBooleanBody;\n        }\n    });\n    Object.defineProperty(exports, \"EnumNumberBody\", {\n        enumerable: true,\n        get: function get() {\n            return _index.enumNumberBody;\n        }\n    });\n    Object.defineProperty(exports, \"EnumStringBody\", {\n        enumerable: true,\n        get: function get() {\n            return _index.enumStringBody;\n        }\n    });\n    Object.defineProperty(exports, \"EnumSymbolBody\", {\n        enumerable: true,\n        get: function get() {\n            return _index.enumSymbolBody;\n        }\n    });\n    Object.defineProperty(exports, \"EnumBooleanMember\", {\n        enumerable: true,\n        get: function get() {\n            return _index.enumBooleanMember;\n        }\n    });\n    Object.defineProperty(exports, \"EnumNumberMember\", {\n        enumerable: true,\n        get: function get() {\n            return _index.enumNumberMember;\n        }\n    });\n    Object.defineProperty(exports, \"EnumStringMember\", {\n        enumerable: true,\n        get: function get() {\n            return _index.enumStringMember;\n        }\n    });\n    Object.defineProperty(exports, \"EnumDefaultedMember\", {\n        enumerable: true,\n        get: function get() {\n            return _index.enumDefaultedMember;\n        }\n    });\n    Object.defineProperty(exports, \"IndexedAccessType\", {\n        enumerable: true,\n        get: function get() {\n            return _index.indexedAccessType;\n        }\n    });\n    Object.defineProperty(exports, \"OptionalIndexedAccessType\", {\n        enumerable: true,\n        get: function get() {\n            return _index.optionalIndexedAccessType;\n        }\n    });\n    Object.defineProperty(exports, \"JSXAttribute\", {\n        enumerable: true,\n        get: function get() {\n            return _index.jsxAttribute;\n        }\n    });\n    Object.defineProperty(exports, \"JSXClosingElement\", {\n        enumerable: true,\n        get: function get() {\n            return _index.jsxClosingElement;\n        }\n    });\n    Object.defineProperty(exports, \"JSXElement\", {\n        enumerable: true,\n        get: function get() {\n            return _index.jsxElement;\n        }\n    });\n    Object.defineProperty(exports, \"JSXEmptyExpression\", {\n        enumerable: true,\n        get: function get() {\n            return _index.jsxEmptyExpression;\n        }\n    });\n    Object.defineProperty(exports, \"JSXExpressionContainer\", {\n        enumerable: true,\n        get: function get() {\n            return _index.jsxExpressionContainer;\n        }\n    });\n    Object.defineProperty(exports, \"JSXSpreadChild\", {\n        enumerable: true,\n        get: function get() {\n            return _index.jsxSpreadChild;\n        }\n    });\n    Object.defineProperty(exports, \"JSXIdentifier\", {\n        enumerable: true,\n        get: function get() {\n            return _index.jsxIdentifier;\n        }\n    });\n    Object.defineProperty(exports, \"JSXMemberExpression\", {\n        enumerable: true,\n        get: function get() {\n            return _index.jsxMemberExpression;\n        }\n    });\n    Object.defineProperty(exports, \"JSXNamespacedName\", {\n        enumerable: true,\n        get: function get() {\n            return _index.jsxNamespacedName;\n        }\n    });\n    Object.defineProperty(exports, \"JSXOpeningElement\", {\n        enumerable: true,\n        get: function get() {\n            return _index.jsxOpeningElement;\n        }\n    });\n    Object.defineProperty(exports, \"JSXSpreadAttribute\", {\n        enumerable: true,\n        get: function get() {\n            return _index.jsxSpreadAttribute;\n        }\n    });\n    Object.defineProperty(exports, \"JSXText\", {\n        enumerable: true,\n        get: function get() {\n            return _index.jsxText;\n        }\n    });\n    Object.defineProperty(exports, \"JSXFragment\", {\n        enumerable: true,\n        get: function get() {\n            return _index.jsxFragment;\n        }\n    });\n    Object.defineProperty(exports, \"JSXOpeningFragment\", {\n        enumerable: true,\n        get: function get() {\n            return _index.jsxOpeningFragment;\n        }\n    });\n    Object.defineProperty(exports, \"JSXClosingFragment\", {\n        enumerable: true,\n        get: function get() {\n            return _index.jsxClosingFragment;\n        }\n    });\n    Object.defineProperty(exports, \"Noop\", {\n        enumerable: true,\n        get: function get() {\n            return _index.noop;\n        }\n    });\n    Object.defineProperty(exports, \"Placeholder\", {\n        enumerable: true,\n        get: function get() {\n            return _index.placeholder;\n        }\n    });\n    Object.defineProperty(exports, \"V8IntrinsicIdentifier\", {\n        enumerable: true,\n        get: function get() {\n            return _index.v8IntrinsicIdentifier;\n        }\n    });\n    Object.defineProperty(exports, \"ArgumentPlaceholder\", {\n        enumerable: true,\n        get: function get() {\n            return _index.argumentPlaceholder;\n        }\n    });\n    Object.defineProperty(exports, \"BindExpression\", {\n        enumerable: true,\n        get: function get() {\n            return _index.bindExpression;\n        }\n    });\n    Object.defineProperty(exports, \"ImportAttribute\", {\n        enumerable: true,\n        get: function get() {\n            return _index.importAttribute;\n        }\n    });\n    Object.defineProperty(exports, \"Decorator\", {\n        enumerable: true,\n        get: function get() {\n            return _index.decorator;\n        }\n    });\n    Object.defineProperty(exports, \"DoExpression\", {\n        enumerable: true,\n        get: function get() {\n            return _index.doExpression;\n        }\n    });\n    Object.defineProperty(exports, \"ExportDefaultSpecifier\", {\n        enumerable: true,\n        get: function get() {\n            return _index.exportDefaultSpecifier;\n        }\n    });\n    Object.defineProperty(exports, \"RecordExpression\", {\n        enumerable: true,\n        get: function get() {\n            return _index.recordExpression;\n        }\n    });\n    Object.defineProperty(exports, \"TupleExpression\", {\n        enumerable: true,\n        get: function get() {\n            return _index.tupleExpression;\n        }\n    });\n    Object.defineProperty(exports, \"DecimalLiteral\", {\n        enumerable: true,\n        get: function get() {\n            return _index.decimalLiteral;\n        }\n    });\n    Object.defineProperty(exports, \"StaticBlock\", {\n        enumerable: true,\n        get: function get() {\n            return _index.staticBlock;\n        }\n    });\n    Object.defineProperty(exports, \"ModuleExpression\", {\n        enumerable: true,\n        get: function get() {\n            return _index.moduleExpression;\n        }\n    });\n    Object.defineProperty(exports, \"TopicReference\", {\n        enumerable: true,\n        get: function get() {\n            return _index.topicReference;\n        }\n    });\n    Object.defineProperty(exports, \"PipelineTopicExpression\", {\n        enumerable: true,\n        get: function get() {\n            return _index.pipelineTopicExpression;\n        }\n    });\n    Object.defineProperty(exports, \"PipelineBareFunction\", {\n        enumerable: true,\n        get: function get() {\n            return _index.pipelineBareFunction;\n        }\n    });\n    Object.defineProperty(exports, \"PipelinePrimaryTopicReference\", {\n        enumerable: true,\n        get: function get() {\n            return _index.pipelinePrimaryTopicReference;\n        }\n    });\n    Object.defineProperty(exports, \"TSParameterProperty\", {\n        enumerable: true,\n        get: function get() {\n            return _index.tsParameterProperty;\n        }\n    });\n    Object.defineProperty(exports, \"TSDeclareFunction\", {\n        enumerable: true,\n        get: function get() {\n            return _index.tsDeclareFunction;\n        }\n    });\n    Object.defineProperty(exports, \"TSDeclareMethod\", {\n        enumerable: true,\n        get: function get() {\n            return _index.tsDeclareMethod;\n        }\n    });\n    Object.defineProperty(exports, \"TSQualifiedName\", {\n        enumerable: true,\n        get: function get() {\n            return _index.tsQualifiedName;\n        }\n    });\n    Object.defineProperty(exports, \"TSCallSignatureDeclaration\", {\n        enumerable: true,\n        get: function get() {\n            return _index.tsCallSignatureDeclaration;\n        }\n    });\n    Object.defineProperty(exports, \"TSConstructSignatureDeclaration\", {\n        enumerable: true,\n        get: function get() {\n            return _index.tsConstructSignatureDeclaration;\n        }\n    });\n    Object.defineProperty(exports, \"TSPropertySignature\", {\n        enumerable: true,\n        get: function get() {\n            return _index.tsPropertySignature;\n        }\n    });\n    Object.defineProperty(exports, \"TSMethodSignature\", {\n        enumerable: true,\n        get: function get() {\n            return _index.tsMethodSignature;\n        }\n    });\n    Object.defineProperty(exports, \"TSIndexSignature\", {\n        enumerable: true,\n        get: function get() {\n            return _index.tsIndexSignature;\n        }\n    });\n    Object.defineProperty(exports, \"TSAnyKeyword\", {\n        enumerable: true,\n        get: function get() {\n            return _index.tsAnyKeyword;\n        }\n    });\n    Object.defineProperty(exports, \"TSBooleanKeyword\", {\n        enumerable: true,\n        get: function get() {\n            return _index.tsBooleanKeyword;\n        }\n    });\n    Object.defineProperty(exports, \"TSBigIntKeyword\", {\n        enumerable: true,\n        get: function get() {\n            return _index.tsBigIntKeyword;\n        }\n    });\n    Object.defineProperty(exports, \"TSIntrinsicKeyword\", {\n        enumerable: true,\n        get: function get() {\n            return _index.tsIntrinsicKeyword;\n        }\n    });\n    Object.defineProperty(exports, \"TSNeverKeyword\", {\n        enumerable: true,\n        get: function get() {\n            return _index.tsNeverKeyword;\n        }\n    });\n    Object.defineProperty(exports, \"TSNullKeyword\", {\n        enumerable: true,\n        get: function get() {\n            return _index.tsNullKeyword;\n        }\n    });\n    Object.defineProperty(exports, \"TSNumberKeyword\", {\n        enumerable: true,\n        get: function get() {\n            return _index.tsNumberKeyword;\n        }\n    });\n    Object.defineProperty(exports, \"TSObjectKeyword\", {\n        enumerable: true,\n        get: function get() {\n            return _index.tsObjectKeyword;\n        }\n    });\n    Object.defineProperty(exports, \"TSStringKeyword\", {\n        enumerable: true,\n        get: function get() {\n            return _index.tsStringKeyword;\n        }\n    });\n    Object.defineProperty(exports, \"TSSymbolKeyword\", {\n        enumerable: true,\n        get: function get() {\n            return _index.tsSymbolKeyword;\n        }\n    });\n    Object.defineProperty(exports, \"TSUndefinedKeyword\", {\n        enumerable: true,\n        get: function get() {\n            return _index.tsUndefinedKeyword;\n        }\n    });\n    Object.defineProperty(exports, \"TSUnknownKeyword\", {\n        enumerable: true,\n        get: function get() {\n            return _index.tsUnknownKeyword;\n        }\n    });\n    Object.defineProperty(exports, \"TSVoidKeyword\", {\n        enumerable: true,\n        get: function get() {\n            return _index.tsVoidKeyword;\n        }\n    });\n    Object.defineProperty(exports, \"TSThisType\", {\n        enumerable: true,\n        get: function get() {\n            return _index.tsThisType;\n        }\n    });\n    Object.defineProperty(exports, \"TSFunctionType\", {\n        enumerable: true,\n        get: function get() {\n            return _index.tsFunctionType;\n        }\n    });\n    Object.defineProperty(exports, \"TSConstructorType\", {\n        enumerable: true,\n        get: function get() {\n            return _index.tsConstructorType;\n        }\n    });\n    Object.defineProperty(exports, \"TSTypeReference\", {\n        enumerable: true,\n        get: function get() {\n            return _index.tsTypeReference;\n        }\n    });\n    Object.defineProperty(exports, \"TSTypePredicate\", {\n        enumerable: true,\n        get: function get() {\n            return _index.tsTypePredicate;\n        }\n    });\n    Object.defineProperty(exports, \"TSTypeQuery\", {\n        enumerable: true,\n        get: function get() {\n            return _index.tsTypeQuery;\n        }\n    });\n    Object.defineProperty(exports, \"TSTypeLiteral\", {\n        enumerable: true,\n        get: function get() {\n            return _index.tsTypeLiteral;\n        }\n    });\n    Object.defineProperty(exports, \"TSArrayType\", {\n        enumerable: true,\n        get: function get() {\n            return _index.tsArrayType;\n        }\n    });\n    Object.defineProperty(exports, \"TSTupleType\", {\n        enumerable: true,\n        get: function get() {\n            return _index.tsTupleType;\n        }\n    });\n    Object.defineProperty(exports, \"TSOptionalType\", {\n        enumerable: true,\n        get: function get() {\n            return _index.tsOptionalType;\n        }\n    });\n    Object.defineProperty(exports, \"TSRestType\", {\n        enumerable: true,\n        get: function get() {\n            return _index.tsRestType;\n        }\n    });\n    Object.defineProperty(exports, \"TSNamedTupleMember\", {\n        enumerable: true,\n        get: function get() {\n            return _index.tsNamedTupleMember;\n        }\n    });\n    Object.defineProperty(exports, \"TSUnionType\", {\n        enumerable: true,\n        get: function get() {\n            return _index.tsUnionType;\n        }\n    });\n    Object.defineProperty(exports, \"TSIntersectionType\", {\n        enumerable: true,\n        get: function get() {\n            return _index.tsIntersectionType;\n        }\n    });\n    Object.defineProperty(exports, \"TSConditionalType\", {\n        enumerable: true,\n        get: function get() {\n            return _index.tsConditionalType;\n        }\n    });\n    Object.defineProperty(exports, \"TSInferType\", {\n        enumerable: true,\n        get: function get() {\n            return _index.tsInferType;\n        }\n    });\n    Object.defineProperty(exports, \"TSParenthesizedType\", {\n        enumerable: true,\n        get: function get() {\n            return _index.tsParenthesizedType;\n        }\n    });\n    Object.defineProperty(exports, \"TSTypeOperator\", {\n        enumerable: true,\n        get: function get() {\n            return _index.tsTypeOperator;\n        }\n    });\n    Object.defineProperty(exports, \"TSIndexedAccessType\", {\n        enumerable: true,\n        get: function get() {\n            return _index.tsIndexedAccessType;\n        }\n    });\n    Object.defineProperty(exports, \"TSMappedType\", {\n        enumerable: true,\n        get: function get() {\n            return _index.tsMappedType;\n        }\n    });\n    Object.defineProperty(exports, \"TSLiteralType\", {\n        enumerable: true,\n        get: function get() {\n            return _index.tsLiteralType;\n        }\n    });\n    Object.defineProperty(exports, \"TSExpressionWithTypeArguments\", {\n        enumerable: true,\n        get: function get() {\n            return _index.tsExpressionWithTypeArguments;\n        }\n    });\n    Object.defineProperty(exports, \"TSInterfaceDeclaration\", {\n        enumerable: true,\n        get: function get() {\n            return _index.tsInterfaceDeclaration;\n        }\n    });\n    Object.defineProperty(exports, \"TSInterfaceBody\", {\n        enumerable: true,\n        get: function get() {\n            return _index.tsInterfaceBody;\n        }\n    });\n    Object.defineProperty(exports, \"TSTypeAliasDeclaration\", {\n        enumerable: true,\n        get: function get() {\n            return _index.tsTypeAliasDeclaration;\n        }\n    });\n    Object.defineProperty(exports, \"TSAsExpression\", {\n        enumerable: true,\n        get: function get() {\n            return _index.tsAsExpression;\n        }\n    });\n    Object.defineProperty(exports, \"TSTypeAssertion\", {\n        enumerable: true,\n        get: function get() {\n            return _index.tsTypeAssertion;\n        }\n    });\n    Object.defineProperty(exports, \"TSEnumDeclaration\", {\n        enumerable: true,\n        get: function get() {\n            return _index.tsEnumDeclaration;\n        }\n    });\n    Object.defineProperty(exports, \"TSEnumMember\", {\n        enumerable: true,\n        get: function get() {\n            return _index.tsEnumMember;\n        }\n    });\n    Object.defineProperty(exports, \"TSModuleDeclaration\", {\n        enumerable: true,\n        get: function get() {\n            return _index.tsModuleDeclaration;\n        }\n    });\n    Object.defineProperty(exports, \"TSModuleBlock\", {\n        enumerable: true,\n        get: function get() {\n            return _index.tsModuleBlock;\n        }\n    });\n    Object.defineProperty(exports, \"TSImportType\", {\n        enumerable: true,\n        get: function get() {\n            return _index.tsImportType;\n        }\n    });\n    Object.defineProperty(exports, \"TSImportEqualsDeclaration\", {\n        enumerable: true,\n        get: function get() {\n            return _index.tsImportEqualsDeclaration;\n        }\n    });\n    Object.defineProperty(exports, \"TSExternalModuleReference\", {\n        enumerable: true,\n        get: function get() {\n            return _index.tsExternalModuleReference;\n        }\n    });\n    Object.defineProperty(exports, \"TSNonNullExpression\", {\n        enumerable: true,\n        get: function get() {\n            return _index.tsNonNullExpression;\n        }\n    });\n    Object.defineProperty(exports, \"TSExportAssignment\", {\n        enumerable: true,\n        get: function get() {\n            return _index.tsExportAssignment;\n        }\n    });\n    Object.defineProperty(exports, \"TSNamespaceExportDeclaration\", {\n        enumerable: true,\n        get: function get() {\n            return _index.tsNamespaceExportDeclaration;\n        }\n    });\n    Object.defineProperty(exports, \"TSTypeAnnotation\", {\n        enumerable: true,\n        get: function get() {\n            return _index.tsTypeAnnotation;\n        }\n    });\n    Object.defineProperty(exports, \"TSTypeParameterInstantiation\", {\n        enumerable: true,\n        get: function get() {\n            return _index.tsTypeParameterInstantiation;\n        }\n    });\n    Object.defineProperty(exports, \"TSTypeParameterDeclaration\", {\n        enumerable: true,\n        get: function get() {\n            return _index.tsTypeParameterDeclaration;\n        }\n    });\n    Object.defineProperty(exports, \"TSTypeParameter\", {\n        enumerable: true,\n        get: function get() {\n            return _index.tsTypeParameter;\n        }\n    });\n    Object.defineProperty(exports, \"NumberLiteral\", {\n        enumerable: true,\n        get: function get() {\n            return _index.numberLiteral;\n        }\n    });\n    Object.defineProperty(exports, \"RegexLiteral\", {\n        enumerable: true,\n        get: function get() {\n            return _index.regexLiteral;\n        }\n    });\n    Object.defineProperty(exports, \"RestProperty\", {\n        enumerable: true,\n        get: function get() {\n            return _index.restProperty;\n        }\n    });\n    Object.defineProperty(exports, \"SpreadProperty\", {\n        enumerable: true,\n        get: function get() {\n            return _index.spreadProperty;\n        }\n    });\n    var _index = generated$3;\n})(uppercase);\n\nvar cloneNode$1 = {};\n\nfunction _createForOfIteratorHelperLoose$a(o, allowArrayLike) {\n    var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n    if (it) return (it = it.call(o)).next.bind(it);\n    if (Array.isArray(o) || (it = unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n        if (it) o = it;\n        var i = 0;\n        return function() {\n            if (i >= o.length) return {\n                done: true\n            };\n            return {\n                done: false,\n                value: o[i++]\n            };\n        };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nObject.defineProperty(cloneNode$1, \"__esModule\", {\n    value: true\n});\ncloneNode$1.default = cloneNode;\nvar _definitions$4 = requireDefinitions();\nvar _generated$g = generated$4;\nvar has = Function.call.bind(Object.prototype.hasOwnProperty);\nfunction cloneIfNode(obj, deep, withoutLoc) {\n    if (obj && typeof obj.type === \"string\") {\n        return cloneNode(obj, deep, withoutLoc);\n    }\n    return obj;\n}\nfunction cloneIfNodeOrArray(obj, deep, withoutLoc) {\n    if (Array.isArray(obj)) {\n        return obj.map(function(node) {\n            return cloneIfNode(node, deep, withoutLoc);\n        });\n    }\n    return cloneIfNode(obj, deep, withoutLoc);\n}\nfunction cloneNode(node, deep, withoutLoc) {\n    if (deep === void 0) deep = true;\n    if (withoutLoc === void 0) withoutLoc = false;\n    if (!node) return node;\n    var type = node.type;\n    var newNode = {\n        type: node.type\n    };\n    if ((0, _generated$g.isIdentifier)(node)) {\n        newNode.name = node.name;\n        if (has(node, \"optional\") && typeof node.optional === \"boolean\") {\n            newNode.optional = node.optional;\n        }\n        if (has(node, \"typeAnnotation\")) {\n            newNode.typeAnnotation = deep ? cloneIfNodeOrArray(node.typeAnnotation, true, withoutLoc) : node.typeAnnotation;\n        }\n    } else if (!has(_definitions$4.NODE_FIELDS, type)) {\n        throw new Error('Unknown node type: \"' + type + '\"');\n    } else {\n        for(var _iterator = _createForOfIteratorHelperLoose$a(Object.keys(_definitions$4.NODE_FIELDS[type])), _step; !(_step = _iterator()).done;){\n            var field = _step.value;\n            if (has(node, field)) {\n                if (deep) {\n                    newNode[field] = (0, _generated$g.isFile)(node) && field === \"comments\" ? maybeCloneComments(node.comments, deep, withoutLoc) : cloneIfNodeOrArray(node[field], true, withoutLoc);\n                } else {\n                    newNode[field] = node[field];\n                }\n            }\n        }\n    }\n    if (has(node, \"loc\")) {\n        if (withoutLoc) {\n            newNode.loc = null;\n        } else {\n            newNode.loc = node.loc;\n        }\n    }\n    if (has(node, \"leadingComments\")) {\n        newNode.leadingComments = maybeCloneComments(node.leadingComments, deep, withoutLoc);\n    }\n    if (has(node, \"innerComments\")) {\n        newNode.innerComments = maybeCloneComments(node.innerComments, deep, withoutLoc);\n    }\n    if (has(node, \"trailingComments\")) {\n        newNode.trailingComments = maybeCloneComments(node.trailingComments, deep, withoutLoc);\n    }\n    if (has(node, \"extra\")) {\n        newNode.extra = Object.assign({}, node.extra);\n    }\n    return newNode;\n}\nfunction maybeCloneComments(comments, deep, withoutLoc) {\n    if (!comments || !deep) {\n        return comments;\n    }\n    return comments.map(function(param) {\n        var type = param.type, value = param.value, loc = param.loc;\n        if (withoutLoc) {\n            return {\n                type: type,\n                value: value,\n                loc: null\n            };\n        }\n        return {\n            type: type,\n            value: value,\n            loc: loc\n        };\n    });\n}\n\nvar clone$1 = {};\n\nObject.defineProperty(clone$1, \"__esModule\", {\n    value: true\n});\nclone$1.default = clone;\nvar _cloneNode$5 = cloneNode$1;\nfunction clone(node) {\n    return (0, _cloneNode$5.default)(node, false);\n}\n\nvar cloneDeep$1 = {};\n\nObject.defineProperty(cloneDeep$1, \"__esModule\", {\n    value: true\n});\ncloneDeep$1.default = cloneDeep;\nvar _cloneNode$4 = cloneNode$1;\nfunction cloneDeep(node) {\n    return (0, _cloneNode$4.default)(node);\n}\n\nvar cloneDeepWithoutLoc$1 = {};\n\nObject.defineProperty(cloneDeepWithoutLoc$1, \"__esModule\", {\n    value: true\n});\ncloneDeepWithoutLoc$1.default = cloneDeepWithoutLoc;\nvar _cloneNode$3 = cloneNode$1;\nfunction cloneDeepWithoutLoc(node) {\n    return (0, _cloneNode$3.default)(node, true, true);\n}\n\nvar cloneWithoutLoc$1 = {};\n\nObject.defineProperty(cloneWithoutLoc$1, \"__esModule\", {\n    value: true\n});\ncloneWithoutLoc$1.default = cloneWithoutLoc;\nvar _cloneNode$2 = cloneNode$1;\nfunction cloneWithoutLoc(node) {\n    return (0, _cloneNode$2.default)(node, false, true);\n}\n\nvar addComment$1 = {};\n\nvar addComments$1 = {};\n\nObject.defineProperty(addComments$1, \"__esModule\", {\n    value: true\n});\naddComments$1.default = addComments;\nfunction addComments(node, type, comments) {\n    if (!comments || !node) return node;\n    var key = \"\" + type + \"Comments\";\n    if (node[key]) {\n        if (type === \"leading\") {\n            node[key] = comments.concat(node[key]);\n        } else {\n            node[key] = node[key].concat(comments);\n        }\n    } else {\n        node[key] = comments;\n    }\n    return node;\n}\n\nObject.defineProperty(addComment$1, \"__esModule\", {\n    value: true\n});\naddComment$1.default = addComment;\nvar _addComments = addComments$1;\nfunction addComment(node, type, content, line) {\n    return (0, _addComments.default)(node, type, [\n        {\n            type: line ? \"CommentLine\" : \"CommentBlock\",\n            value: content\n        }\n    ]);\n}\n\nvar inheritInnerComments$1 = {};\n\nvar inherit$1 = {};\n\nObject.defineProperty(inherit$1, \"__esModule\", {\n    value: true\n});\ninherit$1.default = inherit;\nfunction inherit(key, child, parent) {\n    if (child && parent) {\n        child[key] = Array.from(new Set([].concat(child[key], parent[key]).filter(Boolean)));\n    }\n}\n\nObject.defineProperty(inheritInnerComments$1, \"__esModule\", {\n    value: true\n});\ninheritInnerComments$1.default = inheritInnerComments;\nvar _inherit$2 = inherit$1;\nfunction inheritInnerComments(child, parent) {\n    (0, _inherit$2.default)(\"innerComments\", child, parent);\n}\n\nvar inheritLeadingComments$1 = {};\n\nObject.defineProperty(inheritLeadingComments$1, \"__esModule\", {\n    value: true\n});\ninheritLeadingComments$1.default = inheritLeadingComments;\nvar _inherit$1 = inherit$1;\nfunction inheritLeadingComments(child, parent) {\n    (0, _inherit$1.default)(\"leadingComments\", child, parent);\n}\n\nvar inheritsComments$1 = {};\n\nvar inheritTrailingComments$1 = {};\n\nObject.defineProperty(inheritTrailingComments$1, \"__esModule\", {\n    value: true\n});\ninheritTrailingComments$1.default = inheritTrailingComments;\nvar _inherit = inherit$1;\nfunction inheritTrailingComments(child, parent) {\n    (0, _inherit.default)(\"trailingComments\", child, parent);\n}\n\nObject.defineProperty(inheritsComments$1, \"__esModule\", {\n    value: true\n});\ninheritsComments$1.default = inheritsComments;\nvar _inheritTrailingComments = inheritTrailingComments$1;\nvar _inheritLeadingComments = inheritLeadingComments$1;\nvar _inheritInnerComments = inheritInnerComments$1;\nfunction inheritsComments(child, parent) {\n    (0, _inheritTrailingComments.default)(child, parent);\n    (0, _inheritLeadingComments.default)(child, parent);\n    (0, _inheritInnerComments.default)(child, parent);\n    return child;\n}\n\nvar removeComments$1 = {};\n\nObject.defineProperty(removeComments$1, \"__esModule\", {\n    value: true\n});\nremoveComments$1.default = removeComments;\nvar _constants$4 = constants;\nfunction removeComments(node) {\n    _constants$4.COMMENT_KEYS.forEach(function(key) {\n        node[key] = null;\n    });\n    return node;\n}\n\nvar generated$1 = {};\n\nObject.defineProperty(generated$1, \"__esModule\", {\n    value: true\n});\ngenerated$1.TSBASETYPE_TYPES = generated$1.TSTYPE_TYPES = generated$1.TSTYPEELEMENT_TYPES = generated$1.JSX_TYPES = generated$1.ENUMMEMBER_TYPES = generated$1.ENUMBODY_TYPES = generated$1.FLOWPREDICATE_TYPES = generated$1.FLOWDECLARATION_TYPES = generated$1.FLOWBASEANNOTATION_TYPES = generated$1.FLOWTYPE_TYPES = generated$1.FLOW_TYPES = generated$1.PRIVATE_TYPES = generated$1.MODULESPECIFIER_TYPES = generated$1.EXPORTDECLARATION_TYPES = generated$1.MODULEDECLARATION_TYPES = generated$1.CLASS_TYPES = generated$1.PATTERN_TYPES = generated$1.UNARYLIKE_TYPES = generated$1.PROPERTY_TYPES = generated$1.OBJECTMEMBER_TYPES = generated$1.METHOD_TYPES = generated$1.USERWHITESPACABLE_TYPES = generated$1.IMMUTABLE_TYPES = generated$1.LITERAL_TYPES = generated$1.TSENTITYNAME_TYPES = generated$1.LVAL_TYPES = generated$1.PATTERNLIKE_TYPES = generated$1.DECLARATION_TYPES = generated$1.PUREISH_TYPES = generated$1.FUNCTIONPARENT_TYPES = generated$1.FUNCTION_TYPES = generated$1.FORXSTATEMENT_TYPES = generated$1.FOR_TYPES = generated$1.EXPRESSIONWRAPPER_TYPES = generated$1.WHILE_TYPES = generated$1.LOOP_TYPES = generated$1.CONDITIONAL_TYPES = generated$1.COMPLETIONSTATEMENT_TYPES = generated$1.TERMINATORLESS_TYPES = generated$1.STATEMENT_TYPES = generated$1.BLOCK_TYPES = generated$1.BLOCKPARENT_TYPES = generated$1.SCOPABLE_TYPES = generated$1.BINARY_TYPES = generated$1.EXPRESSION_TYPES = void 0;\nvar _definitions$3 = requireDefinitions();\nvar EXPRESSION_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS[\"Expression\"];\ngenerated$1.EXPRESSION_TYPES = EXPRESSION_TYPES;\nvar BINARY_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS[\"Binary\"];\ngenerated$1.BINARY_TYPES = BINARY_TYPES;\nvar SCOPABLE_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS[\"Scopable\"];\ngenerated$1.SCOPABLE_TYPES = SCOPABLE_TYPES;\nvar BLOCKPARENT_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS[\"BlockParent\"];\ngenerated$1.BLOCKPARENT_TYPES = BLOCKPARENT_TYPES;\nvar BLOCK_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS[\"Block\"];\ngenerated$1.BLOCK_TYPES = BLOCK_TYPES;\nvar STATEMENT_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS[\"Statement\"];\ngenerated$1.STATEMENT_TYPES = STATEMENT_TYPES;\nvar TERMINATORLESS_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS[\"Terminatorless\"];\ngenerated$1.TERMINATORLESS_TYPES = TERMINATORLESS_TYPES;\nvar COMPLETIONSTATEMENT_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS[\"CompletionStatement\"];\ngenerated$1.COMPLETIONSTATEMENT_TYPES = COMPLETIONSTATEMENT_TYPES;\nvar CONDITIONAL_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS[\"Conditional\"];\ngenerated$1.CONDITIONAL_TYPES = CONDITIONAL_TYPES;\nvar LOOP_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS[\"Loop\"];\ngenerated$1.LOOP_TYPES = LOOP_TYPES;\nvar WHILE_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS[\"While\"];\ngenerated$1.WHILE_TYPES = WHILE_TYPES;\nvar EXPRESSIONWRAPPER_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS[\"ExpressionWrapper\"];\ngenerated$1.EXPRESSIONWRAPPER_TYPES = EXPRESSIONWRAPPER_TYPES;\nvar FOR_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS[\"For\"];\ngenerated$1.FOR_TYPES = FOR_TYPES;\nvar FORXSTATEMENT_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS[\"ForXStatement\"];\ngenerated$1.FORXSTATEMENT_TYPES = FORXSTATEMENT_TYPES;\nvar FUNCTION_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS[\"Function\"];\ngenerated$1.FUNCTION_TYPES = FUNCTION_TYPES;\nvar FUNCTIONPARENT_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS[\"FunctionParent\"];\ngenerated$1.FUNCTIONPARENT_TYPES = FUNCTIONPARENT_TYPES;\nvar PUREISH_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS[\"Pureish\"];\ngenerated$1.PUREISH_TYPES = PUREISH_TYPES;\nvar DECLARATION_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS[\"Declaration\"];\ngenerated$1.DECLARATION_TYPES = DECLARATION_TYPES;\nvar PATTERNLIKE_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS[\"PatternLike\"];\ngenerated$1.PATTERNLIKE_TYPES = PATTERNLIKE_TYPES;\nvar LVAL_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS[\"LVal\"];\ngenerated$1.LVAL_TYPES = LVAL_TYPES;\nvar TSENTITYNAME_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS[\"TSEntityName\"];\ngenerated$1.TSENTITYNAME_TYPES = TSENTITYNAME_TYPES;\nvar LITERAL_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS[\"Literal\"];\ngenerated$1.LITERAL_TYPES = LITERAL_TYPES;\nvar IMMUTABLE_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS[\"Immutable\"];\ngenerated$1.IMMUTABLE_TYPES = IMMUTABLE_TYPES;\nvar USERWHITESPACABLE_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS[\"UserWhitespacable\"];\ngenerated$1.USERWHITESPACABLE_TYPES = USERWHITESPACABLE_TYPES;\nvar METHOD_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS[\"Method\"];\ngenerated$1.METHOD_TYPES = METHOD_TYPES;\nvar OBJECTMEMBER_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS[\"ObjectMember\"];\ngenerated$1.OBJECTMEMBER_TYPES = OBJECTMEMBER_TYPES;\nvar PROPERTY_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS[\"Property\"];\ngenerated$1.PROPERTY_TYPES = PROPERTY_TYPES;\nvar UNARYLIKE_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS[\"UnaryLike\"];\ngenerated$1.UNARYLIKE_TYPES = UNARYLIKE_TYPES;\nvar PATTERN_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS[\"Pattern\"];\ngenerated$1.PATTERN_TYPES = PATTERN_TYPES;\nvar CLASS_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS[\"Class\"];\ngenerated$1.CLASS_TYPES = CLASS_TYPES;\nvar MODULEDECLARATION_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS[\"ModuleDeclaration\"];\ngenerated$1.MODULEDECLARATION_TYPES = MODULEDECLARATION_TYPES;\nvar EXPORTDECLARATION_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS[\"ExportDeclaration\"];\ngenerated$1.EXPORTDECLARATION_TYPES = EXPORTDECLARATION_TYPES;\nvar MODULESPECIFIER_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS[\"ModuleSpecifier\"];\ngenerated$1.MODULESPECIFIER_TYPES = MODULESPECIFIER_TYPES;\nvar PRIVATE_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS[\"Private\"];\ngenerated$1.PRIVATE_TYPES = PRIVATE_TYPES;\nvar FLOW_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS[\"Flow\"];\ngenerated$1.FLOW_TYPES = FLOW_TYPES;\nvar FLOWTYPE_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS[\"FlowType\"];\ngenerated$1.FLOWTYPE_TYPES = FLOWTYPE_TYPES;\nvar FLOWBASEANNOTATION_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS[\"FlowBaseAnnotation\"];\ngenerated$1.FLOWBASEANNOTATION_TYPES = FLOWBASEANNOTATION_TYPES;\nvar FLOWDECLARATION_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS[\"FlowDeclaration\"];\ngenerated$1.FLOWDECLARATION_TYPES = FLOWDECLARATION_TYPES;\nvar FLOWPREDICATE_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS[\"FlowPredicate\"];\ngenerated$1.FLOWPREDICATE_TYPES = FLOWPREDICATE_TYPES;\nvar ENUMBODY_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS[\"EnumBody\"];\ngenerated$1.ENUMBODY_TYPES = ENUMBODY_TYPES;\nvar ENUMMEMBER_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS[\"EnumMember\"];\ngenerated$1.ENUMMEMBER_TYPES = ENUMMEMBER_TYPES;\nvar JSX_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS[\"JSX\"];\ngenerated$1.JSX_TYPES = JSX_TYPES;\nvar TSTYPEELEMENT_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS[\"TSTypeElement\"];\ngenerated$1.TSTYPEELEMENT_TYPES = TSTYPEELEMENT_TYPES;\nvar TSTYPE_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS[\"TSType\"];\ngenerated$1.TSTYPE_TYPES = TSTYPE_TYPES;\nvar TSBASETYPE_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS[\"TSBaseType\"];\ngenerated$1.TSBASETYPE_TYPES = TSBASETYPE_TYPES;\n\nvar ensureBlock$1 = {};\n\nvar toBlock$1 = {};\n\nObject.defineProperty(toBlock$1, \"__esModule\", {\n    value: true\n});\ntoBlock$1.default = toBlock;\nvar _generated$f = generated$4;\nvar _generated2$3 = generated$3;\nfunction toBlock(node, parent) {\n    if ((0, _generated$f.isBlockStatement)(node)) {\n        return node;\n    }\n    var blockNodes = [];\n    if ((0, _generated$f.isEmptyStatement)(node)) {\n        blockNodes = [];\n    } else {\n        if (!(0, _generated$f.isStatement)(node)) {\n            if ((0, _generated$f.isFunction)(parent)) {\n                node = (0, _generated2$3.returnStatement)(node);\n            } else {\n                node = (0, _generated2$3.expressionStatement)(node);\n            }\n        }\n        blockNodes = [\n            node\n        ];\n    }\n    return (0, _generated2$3.blockStatement)(blockNodes);\n}\n\nObject.defineProperty(ensureBlock$1, \"__esModule\", {\n    value: true\n});\nensureBlock$1.default = ensureBlock;\nvar _toBlock = toBlock$1;\nfunction ensureBlock(node, key) {\n    if (key === void 0) key = \"body\";\n    return node[key] = (0, _toBlock.default)(node[key], node);\n}\n\nvar toBindingIdentifierName$1 = {};\n\nvar toIdentifier$1 = {};\n\nfunction _createForOfIteratorHelperLoose$9(o, allowArrayLike) {\n    var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n    if (it) return (it = it.call(o)).next.bind(it);\n    if (Array.isArray(o) || (it = unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n        if (it) o = it;\n        var i = 0;\n        return function() {\n            if (i >= o.length) return {\n                done: true\n            };\n            return {\n                done: false,\n                value: o[i++]\n            };\n        };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nObject.defineProperty(toIdentifier$1, \"__esModule\", {\n    value: true\n});\ntoIdentifier$1.default = toIdentifier;\nvar _isValidIdentifier$2 = isValidIdentifier$1;\nvar _helperValidatorIdentifier = lib;\nfunction toIdentifier(input) {\n    input = input + \"\";\n    var name = \"\";\n    for(var _iterator = _createForOfIteratorHelperLoose$9(input), _step; !(_step = _iterator()).done;){\n        var c = _step.value;\n        name += (0, _helperValidatorIdentifier.isIdentifierChar)(c.codePointAt(0)) ? c : \"-\";\n    }\n    name = name.replace(/^[-0-9]+/, \"\");\n    name = name.replace(/[-\\s]+(.)?/g, function(match, c) {\n        return c ? c.toUpperCase() : \"\";\n    });\n    if (!(0, _isValidIdentifier$2.default)(name)) {\n        name = \"_\" + name;\n    }\n    return name || \"_\";\n}\n\nObject.defineProperty(toBindingIdentifierName$1, \"__esModule\", {\n    value: true\n});\ntoBindingIdentifierName$1.default = toBindingIdentifierName;\nvar _toIdentifier = toIdentifier$1;\nfunction toBindingIdentifierName(name) {\n    name = (0, _toIdentifier.default)(name);\n    if (name === \"eval\" || name === \"arguments\") name = \"_\" + name;\n    return name;\n}\n\nvar toComputedKey$1 = {};\n\nObject.defineProperty(toComputedKey$1, \"__esModule\", {\n    value: true\n});\ntoComputedKey$1.default = toComputedKey;\nvar _generated$e = generated$4;\nvar _generated2$2 = generated$3;\nfunction toComputedKey(node, key) {\n    if (key === void 0) key = node.key || node.property;\n    if (!node.computed && (0, _generated$e.isIdentifier)(key)) key = (0, _generated2$2.stringLiteral)(key.name);\n    return key;\n}\n\nvar toExpression$1 = {};\n\nObject.defineProperty(toExpression$1, \"__esModule\", {\n    value: true\n});\ntoExpression$1.default = void 0;\nvar _generated$d = generated$4;\nvar _default$3 = toExpression;\ntoExpression$1.default = _default$3;\nfunction toExpression(node) {\n    if ((0, _generated$d.isExpressionStatement)(node)) {\n        node = node.expression;\n    }\n    if ((0, _generated$d.isExpression)(node)) {\n        return node;\n    }\n    if ((0, _generated$d.isClass)(node)) {\n        node.type = \"ClassExpression\";\n    } else if ((0, _generated$d.isFunction)(node)) {\n        node.type = \"FunctionExpression\";\n    }\n    if (!(0, _generated$d.isExpression)(node)) {\n        throw new Error(\"cannot turn \" + node.type + \" to an expression\");\n    }\n    return node;\n}\n\nvar toKeyAlias$1 = {};\n\nvar removePropertiesDeep$1 = {};\n\nvar traverseFast$1 = {};\n\nfunction _createForOfIteratorHelperLoose$8(o, allowArrayLike) {\n    var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n    if (it) return (it = it.call(o)).next.bind(it);\n    if (Array.isArray(o) || (it = unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n        if (it) o = it;\n        var i = 0;\n        return function() {\n            if (i >= o.length) return {\n                done: true\n            };\n            return {\n                done: false,\n                value: o[i++]\n            };\n        };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nObject.defineProperty(traverseFast$1, \"__esModule\", {\n    value: true\n});\ntraverseFast$1.default = traverseFast;\nvar _definitions$2 = requireDefinitions();\nfunction traverseFast(node, enter, opts) {\n    if (!node) return;\n    var keys = _definitions$2.VISITOR_KEYS[node.type];\n    if (!keys) return;\n    opts = opts || {};\n    enter(node, opts);\n    for(var _iterator = _createForOfIteratorHelperLoose$8(keys), _step; !(_step = _iterator()).done;){\n        var key = _step.value;\n        var subNode = node[key];\n        if (Array.isArray(subNode)) {\n            for(var _iterator1 = _createForOfIteratorHelperLoose$8(subNode), _step1; !(_step1 = _iterator1()).done;){\n                var _$node = _step1.value;\n                traverseFast(_$node, enter, opts);\n            }\n        } else {\n            traverseFast(subNode, enter, opts);\n        }\n    }\n}\n\nvar removeProperties$1 = {};\n\nfunction _createForOfIteratorHelperLoose$7(o, allowArrayLike) {\n    var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n    if (it) return (it = it.call(o)).next.bind(it);\n    if (Array.isArray(o) || (it = unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n        if (it) o = it;\n        var i = 0;\n        return function() {\n            if (i >= o.length) return {\n                done: true\n            };\n            return {\n                done: false,\n                value: o[i++]\n            };\n        };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nObject.defineProperty(removeProperties$1, \"__esModule\", {\n    value: true\n});\nremoveProperties$1.default = removeProperties;\nvar _constants$3 = constants;\nvar CLEAR_KEYS = [\n    \"tokens\",\n    \"start\",\n    \"end\",\n    \"loc\",\n    \"raw\",\n    \"rawValue\"\n];\nvar CLEAR_KEYS_PLUS_COMMENTS = _constants$3.COMMENT_KEYS.concat([\n    \"comments\"\n]).concat(CLEAR_KEYS);\nfunction removeProperties(node, opts) {\n    if (opts === void 0) opts = {};\n    var map = opts.preserveComments ? CLEAR_KEYS : CLEAR_KEYS_PLUS_COMMENTS;\n    for(var _iterator = _createForOfIteratorHelperLoose$7(map), _step; !(_step = _iterator()).done;){\n        var key = _step.value;\n        if (node[key] != null) node[key] = undefined;\n    }\n    for(var _iterator1 = _createForOfIteratorHelperLoose$7(Object.keys(node)), _step1; !(_step1 = _iterator1()).done;){\n        var key1 = _step1.value;\n        if (key1[0] === \"_\" && node[key1] != null) node[key1] = undefined;\n    }\n    var symbols = Object.getOwnPropertySymbols(node);\n    for(var _iterator2 = _createForOfIteratorHelperLoose$7(symbols), _step2; !(_step2 = _iterator2()).done;){\n        var sym = _step2.value;\n        node[sym] = null;\n    }\n}\n\nObject.defineProperty(removePropertiesDeep$1, \"__esModule\", {\n    value: true\n});\nremovePropertiesDeep$1.default = removePropertiesDeep;\nvar _traverseFast = traverseFast$1;\nvar _removeProperties = removeProperties$1;\nfunction removePropertiesDeep(tree, opts) {\n    (0, _traverseFast.default)(tree, _removeProperties.default, opts);\n    return tree;\n}\n\nObject.defineProperty(toKeyAlias$1, \"__esModule\", {\n    value: true\n});\ntoKeyAlias$1.default = toKeyAlias;\nvar _generated$c = generated$4;\nvar _cloneNode$1 = cloneNode$1;\nvar _removePropertiesDeep = removePropertiesDeep$1;\nfunction toKeyAlias(node, key) {\n    if (key === void 0) key = node.key;\n    var alias;\n    if (node.kind === \"method\") {\n        return toKeyAlias.increment() + \"\";\n    } else if ((0, _generated$c.isIdentifier)(key)) {\n        alias = key.name;\n    } else if ((0, _generated$c.isStringLiteral)(key)) {\n        alias = JSON.stringify(key.value);\n    } else {\n        alias = JSON.stringify((0, _removePropertiesDeep.default)((0, _cloneNode$1.default)(key)));\n    }\n    if (node.computed) {\n        alias = \"[\" + alias + \"]\";\n    }\n    if (node.static) {\n        alias = \"static:\" + alias;\n    }\n    return alias;\n}\ntoKeyAlias.uid = 0;\ntoKeyAlias.increment = function() {\n    if (toKeyAlias.uid >= Number.MAX_SAFE_INTEGER) {\n        return toKeyAlias.uid = 0;\n    } else {\n        return toKeyAlias.uid++;\n    }\n};\n\nvar toSequenceExpression$1 = {};\n\nvar gatherSequenceExpressions$1 = {};\n\nvar getBindingIdentifiers$1 = {};\n\nObject.defineProperty(getBindingIdentifiers$1, \"__esModule\", {\n    value: true\n});\ngetBindingIdentifiers$1.default = getBindingIdentifiers;\nvar _generated$b = generated$4;\nfunction getBindingIdentifiers(node, duplicates, outerOnly) {\n    var search = [].concat(node);\n    var ids = Object.create(null);\n    while(search.length){\n        var id = search.shift();\n        if (!id) continue;\n        var keys = getBindingIdentifiers.keys[id.type];\n        if ((0, _generated$b.isIdentifier)(id)) {\n            if (duplicates) {\n                var _ids = ids[id.name] = ids[id.name] || [];\n                _ids.push(id);\n            } else {\n                ids[id.name] = id;\n            }\n            continue;\n        }\n        if ((0, _generated$b.isExportDeclaration)(id) && !(0, _generated$b.isExportAllDeclaration)(id)) {\n            if ((0, _generated$b.isDeclaration)(id.declaration)) {\n                search.push(id.declaration);\n            }\n            continue;\n        }\n        if (outerOnly) {\n            if ((0, _generated$b.isFunctionDeclaration)(id)) {\n                search.push(id.id);\n                continue;\n            }\n            if ((0, _generated$b.isFunctionExpression)(id)) {\n                continue;\n            }\n        }\n        if (keys) {\n            for(var i = 0; i < keys.length; i++){\n                var key = keys[i];\n                if (id[key]) {\n                    search = search.concat(id[key]);\n                }\n            }\n        }\n    }\n    return ids;\n}\ngetBindingIdentifiers.keys = {\n    DeclareClass: [\n        \"id\"\n    ],\n    DeclareFunction: [\n        \"id\"\n    ],\n    DeclareModule: [\n        \"id\"\n    ],\n    DeclareVariable: [\n        \"id\"\n    ],\n    DeclareInterface: [\n        \"id\"\n    ],\n    DeclareTypeAlias: [\n        \"id\"\n    ],\n    DeclareOpaqueType: [\n        \"id\"\n    ],\n    InterfaceDeclaration: [\n        \"id\"\n    ],\n    TypeAlias: [\n        \"id\"\n    ],\n    OpaqueType: [\n        \"id\"\n    ],\n    CatchClause: [\n        \"param\"\n    ],\n    LabeledStatement: [\n        \"label\"\n    ],\n    UnaryExpression: [\n        \"argument\"\n    ],\n    AssignmentExpression: [\n        \"left\"\n    ],\n    ImportSpecifier: [\n        \"local\"\n    ],\n    ImportNamespaceSpecifier: [\n        \"local\"\n    ],\n    ImportDefaultSpecifier: [\n        \"local\"\n    ],\n    ImportDeclaration: [\n        \"specifiers\"\n    ],\n    ExportSpecifier: [\n        \"exported\"\n    ],\n    ExportNamespaceSpecifier: [\n        \"exported\"\n    ],\n    ExportDefaultSpecifier: [\n        \"exported\"\n    ],\n    FunctionDeclaration: [\n        \"id\",\n        \"params\"\n    ],\n    FunctionExpression: [\n        \"id\",\n        \"params\"\n    ],\n    ArrowFunctionExpression: [\n        \"params\"\n    ],\n    ObjectMethod: [\n        \"params\"\n    ],\n    ClassMethod: [\n        \"params\"\n    ],\n    ForInStatement: [\n        \"left\"\n    ],\n    ForOfStatement: [\n        \"left\"\n    ],\n    ClassDeclaration: [\n        \"id\"\n    ],\n    ClassExpression: [\n        \"id\"\n    ],\n    RestElement: [\n        \"argument\"\n    ],\n    UpdateExpression: [\n        \"argument\"\n    ],\n    ObjectProperty: [\n        \"value\"\n    ],\n    AssignmentPattern: [\n        \"left\"\n    ],\n    ArrayPattern: [\n        \"elements\"\n    ],\n    ObjectPattern: [\n        \"properties\"\n    ],\n    VariableDeclaration: [\n        \"declarations\"\n    ],\n    VariableDeclarator: [\n        \"id\"\n    ]\n};\n\nfunction _createForOfIteratorHelperLoose$6(o, allowArrayLike) {\n    var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n    if (it) return (it = it.call(o)).next.bind(it);\n    if (Array.isArray(o) || (it = unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n        if (it) o = it;\n        var i = 0;\n        return function() {\n            if (i >= o.length) return {\n                done: true\n            };\n            return {\n                done: false,\n                value: o[i++]\n            };\n        };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nObject.defineProperty(gatherSequenceExpressions$1, \"__esModule\", {\n    value: true\n});\ngatherSequenceExpressions$1.default = gatherSequenceExpressions;\nvar _getBindingIdentifiers$2 = getBindingIdentifiers$1;\nvar _generated$a = generated$4;\nvar _generated2$1 = generated$3;\nvar _cloneNode = cloneNode$1;\nfunction gatherSequenceExpressions(nodes, scope, declars) {\n    var exprs = [];\n    var ensureLastUndefined = true;\n    for(var _iterator = _createForOfIteratorHelperLoose$6(nodes), _step; !(_step = _iterator()).done;){\n        var node = _step.value;\n        if (!(0, _generated$a.isEmptyStatement)(node)) {\n            ensureLastUndefined = false;\n        }\n        if ((0, _generated$a.isExpression)(node)) {\n            exprs.push(node);\n        } else if ((0, _generated$a.isExpressionStatement)(node)) {\n            exprs.push(node.expression);\n        } else if ((0, _generated$a.isVariableDeclaration)(node)) {\n            if (node.kind !== \"var\") return;\n            for(var _iterator1 = _createForOfIteratorHelperLoose$6(node.declarations), _step1; !(_step1 = _iterator1()).done;){\n                var declar = _step1.value;\n                var bindings = (0, _getBindingIdentifiers$2.default)(declar);\n                for(var _iterator2 = _createForOfIteratorHelperLoose$6(Object.keys(bindings)), _step2; !(_step2 = _iterator2()).done;){\n                    var key = _step2.value;\n                    declars.push({\n                        kind: node.kind,\n                        id: (0, _cloneNode.default)(bindings[key])\n                    });\n                }\n                if (declar.init) {\n                    exprs.push((0, _generated2$1.assignmentExpression)(\"=\", declar.id, declar.init));\n                }\n            }\n            ensureLastUndefined = true;\n        } else if ((0, _generated$a.isIfStatement)(node)) {\n            var consequent = node.consequent ? gatherSequenceExpressions([\n                node.consequent\n            ], scope, declars) : scope.buildUndefinedNode();\n            var alternate = node.alternate ? gatherSequenceExpressions([\n                node.alternate\n            ], scope, declars) : scope.buildUndefinedNode();\n            if (!consequent || !alternate) return;\n            exprs.push((0, _generated2$1.conditionalExpression)(node.test, consequent, alternate));\n        } else if ((0, _generated$a.isBlockStatement)(node)) {\n            var body = gatherSequenceExpressions(node.body, scope, declars);\n            if (!body) return;\n            exprs.push(body);\n        } else if ((0, _generated$a.isEmptyStatement)(node)) {\n            if (nodes.indexOf(node) === 0) {\n                ensureLastUndefined = true;\n            }\n        } else {\n            return;\n        }\n    }\n    if (ensureLastUndefined) {\n        exprs.push(scope.buildUndefinedNode());\n    }\n    if (exprs.length === 1) {\n        return exprs[0];\n    } else {\n        return (0, _generated2$1.sequenceExpression)(exprs);\n    }\n}\n\nfunction _createForOfIteratorHelperLoose$5(o, allowArrayLike) {\n    var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n    if (it) return (it = it.call(o)).next.bind(it);\n    if (Array.isArray(o) || (it = unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n        if (it) o = it;\n        var i = 0;\n        return function() {\n            if (i >= o.length) return {\n                done: true\n            };\n            return {\n                done: false,\n                value: o[i++]\n            };\n        };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nObject.defineProperty(toSequenceExpression$1, \"__esModule\", {\n    value: true\n});\ntoSequenceExpression$1.default = toSequenceExpression;\nvar _gatherSequenceExpressions = gatherSequenceExpressions$1;\nfunction toSequenceExpression(nodes, scope) {\n    if (!(nodes != null && nodes.length)) return;\n    var declars = [];\n    var result = (0, _gatherSequenceExpressions.default)(nodes, scope, declars);\n    if (!result) return;\n    for(var _iterator = _createForOfIteratorHelperLoose$5(declars), _step; !(_step = _iterator()).done;){\n        var declar = _step.value;\n        scope.push(declar);\n    }\n    return result;\n}\n\nvar toStatement$1 = {};\n\nObject.defineProperty(toStatement$1, \"__esModule\", {\n    value: true\n});\ntoStatement$1.default = void 0;\nvar _generated$9 = generated$4;\nvar _generated2 = generated$3;\nvar _default$2 = toStatement;\ntoStatement$1.default = _default$2;\nfunction toStatement(node, ignore) {\n    if ((0, _generated$9.isStatement)(node)) {\n        return node;\n    }\n    var mustHaveId = false;\n    var newType;\n    if ((0, _generated$9.isClass)(node)) {\n        mustHaveId = true;\n        newType = \"ClassDeclaration\";\n    } else if ((0, _generated$9.isFunction)(node)) {\n        mustHaveId = true;\n        newType = \"FunctionDeclaration\";\n    } else if ((0, _generated$9.isAssignmentExpression)(node)) {\n        return (0, _generated2.expressionStatement)(node);\n    }\n    if (mustHaveId && !node.id) {\n        newType = false;\n    }\n    if (!newType) {\n        if (ignore) {\n            return false;\n        } else {\n            throw new Error(\"cannot turn \" + node.type + \" to a statement\");\n        }\n    }\n    node.type = newType;\n    return node;\n}\n\nvar valueToNode$1 = {};\n\nfunction _createForOfIteratorHelperLoose$4(o, allowArrayLike) {\n    var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n    if (it) return (it = it.call(o)).next.bind(it);\n    if (Array.isArray(o) || (it = unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n        if (it) o = it;\n        var i = 0;\n        return function() {\n            if (i >= o.length) return {\n                done: true\n            };\n            return {\n                done: false,\n                value: o[i++]\n            };\n        };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nObject.defineProperty(valueToNode$1, \"__esModule\", {\n    value: true\n});\nvalueToNode$1.default = void 0;\nvar _isValidIdentifier$1 = isValidIdentifier$1;\nvar _generated$8 = generated$3;\nvar _default$1 = valueToNode;\nvalueToNode$1.default = _default$1;\nvar objectToString = Function.call.bind(Object.prototype.toString);\nfunction isRegExp(value) {\n    return objectToString(value) === \"[object RegExp]\";\n}\nfunction isPlainObject(value) {\n    if (typeof value !== \"object\" || value === null || Object.prototype.toString.call(value) !== \"[object Object]\") {\n        return false;\n    }\n    var proto = Object.getPrototypeOf(value);\n    return proto === null || Object.getPrototypeOf(proto) === null;\n}\nfunction valueToNode(value) {\n    if (value === undefined) {\n        return (0, _generated$8.identifier)(\"undefined\");\n    }\n    if (value === true || value === false) {\n        return (0, _generated$8.booleanLiteral)(value);\n    }\n    if (value === null) {\n        return (0, _generated$8.nullLiteral)();\n    }\n    if (typeof value === \"string\") {\n        return (0, _generated$8.stringLiteral)(value);\n    }\n    if (typeof value === \"number\") {\n        var result;\n        if (Number.isFinite(value)) {\n            result = (0, _generated$8.numericLiteral)(Math.abs(value));\n        } else {\n            var numerator;\n            if (Number.isNaN(value)) {\n                numerator = (0, _generated$8.numericLiteral)(0);\n            } else {\n                numerator = (0, _generated$8.numericLiteral)(1);\n            }\n            result = (0, _generated$8.binaryExpression)(\"/\", numerator, (0, _generated$8.numericLiteral)(0));\n        }\n        if (value < 0 || Object.is(value, -0)) {\n            result = (0, _generated$8.unaryExpression)(\"-\", result);\n        }\n        return result;\n    }\n    if (isRegExp(value)) {\n        var pattern = value.source;\n        var flags = value.toString().match(/\\/([a-z]+|)$/)[1];\n        return (0, _generated$8.regExpLiteral)(pattern, flags);\n    }\n    if (Array.isArray(value)) {\n        return (0, _generated$8.arrayExpression)(value.map(valueToNode));\n    }\n    if (isPlainObject(value)) {\n        var props = [];\n        for(var _iterator = _createForOfIteratorHelperLoose$4(Object.keys(value)), _step; !(_step = _iterator()).done;){\n            var key = _step.value;\n            var nodeKey = void 0;\n            if ((0, _isValidIdentifier$1.default)(key)) {\n                nodeKey = (0, _generated$8.identifier)(key);\n            } else {\n                nodeKey = (0, _generated$8.stringLiteral)(key);\n            }\n            props.push((0, _generated$8.objectProperty)(nodeKey, valueToNode(value[key])));\n        }\n        return (0, _generated$8.objectExpression)(props);\n    }\n    throw new Error(\"don't know how to turn this value into a node\");\n}\n\nvar appendToMemberExpression$1 = {};\n\nObject.defineProperty(appendToMemberExpression$1, \"__esModule\", {\n    value: true\n});\nappendToMemberExpression$1.default = appendToMemberExpression;\nvar _generated$7 = generated$3;\nfunction appendToMemberExpression(member, append, computed) {\n    if (computed === void 0) computed = false;\n    member.object = (0, _generated$7.memberExpression)(member.object, member.property, member.computed);\n    member.property = append;\n    member.computed = !!computed;\n    return member;\n}\n\nvar inherits$1 = {};\n\nfunction _createForOfIteratorHelperLoose$3(o, allowArrayLike) {\n    var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n    if (it) return (it = it.call(o)).next.bind(it);\n    if (Array.isArray(o) || (it = unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n        if (it) o = it;\n        var i = 0;\n        return function() {\n            if (i >= o.length) return {\n                done: true\n            };\n            return {\n                done: false,\n                value: o[i++]\n            };\n        };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nObject.defineProperty(inherits$1, \"__esModule\", {\n    value: true\n});\ninherits$1.default = inherits;\nvar _constants$2 = constants;\nvar _inheritsComments = inheritsComments$1;\nfunction inherits(child, parent) {\n    if (!child || !parent) return child;\n    for(var _iterator = _createForOfIteratorHelperLoose$3(_constants$2.INHERIT_KEYS.optional), _step; !(_step = _iterator()).done;){\n        var key = _step.value;\n        if (child[key] == null) {\n            child[key] = parent[key];\n        }\n    }\n    for(var _iterator1 = _createForOfIteratorHelperLoose$3(Object.keys(parent)), _step1; !(_step1 = _iterator1()).done;){\n        var key1 = _step1.value;\n        if (key1[0] === \"_\" && key1 !== \"__clone\") child[key1] = parent[key1];\n    }\n    for(var _iterator2 = _createForOfIteratorHelperLoose$3(_constants$2.INHERIT_KEYS.force), _step2; !(_step2 = _iterator2()).done;){\n        var key2 = _step2.value;\n        child[key2] = parent[key2];\n    }\n    (0, _inheritsComments.default)(child, parent);\n    return child;\n}\n\nvar prependToMemberExpression$1 = {};\n\nObject.defineProperty(prependToMemberExpression$1, \"__esModule\", {\n    value: true\n});\nprependToMemberExpression$1.default = prependToMemberExpression;\nvar _generated$6 = generated$3;\nfunction prependToMemberExpression(member, prepend) {\n    member.object = (0, _generated$6.memberExpression)(prepend, member.object);\n    return member;\n}\n\nvar getOuterBindingIdentifiers$1 = {};\n\nObject.defineProperty(getOuterBindingIdentifiers$1, \"__esModule\", {\n    value: true\n});\ngetOuterBindingIdentifiers$1.default = void 0;\nvar _getBindingIdentifiers$1 = getBindingIdentifiers$1;\nvar _default = getOuterBindingIdentifiers;\ngetOuterBindingIdentifiers$1.default = _default;\nfunction getOuterBindingIdentifiers(node, duplicates) {\n    return (0, _getBindingIdentifiers$1.default)(node, duplicates, true);\n}\n\nvar traverse$1 = {};\n\nfunction _createForOfIteratorHelperLoose$2(o, allowArrayLike) {\n    var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n    if (it) return (it = it.call(o)).next.bind(it);\n    if (Array.isArray(o) || (it = unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n        if (it) o = it;\n        var i = 0;\n        return function() {\n            if (i >= o.length) return {\n                done: true\n            };\n            return {\n                done: false,\n                value: o[i++]\n            };\n        };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nObject.defineProperty(traverse$1, \"__esModule\", {\n    value: true\n});\ntraverse$1.default = traverse;\nvar _definitions$1 = requireDefinitions();\nfunction traverse(node, handlers, state) {\n    if (typeof handlers === \"function\") {\n        handlers = {\n            enter: handlers\n        };\n    }\n    var enter = handlers.enter, exit = handlers.exit;\n    traverseSimpleImpl(node, enter, exit, state, []);\n}\nfunction traverseSimpleImpl(node, enter, exit, state, ancestors) {\n    var keys = _definitions$1.VISITOR_KEYS[node.type];\n    if (!keys) return;\n    if (enter) enter(node, ancestors, state);\n    for(var _iterator = _createForOfIteratorHelperLoose$2(keys), _step; !(_step = _iterator()).done;){\n        var key = _step.value;\n        var subNode = node[key];\n        if (Array.isArray(subNode)) {\n            for(var i = 0; i < subNode.length; i++){\n                var child = subNode[i];\n                if (!child) continue;\n                ancestors.push({\n                    node: node,\n                    key: key,\n                    index: i\n                });\n                traverseSimpleImpl(child, enter, exit, state, ancestors);\n                ancestors.pop();\n            }\n        } else if (subNode) {\n            ancestors.push({\n                node: node,\n                key: key\n            });\n            traverseSimpleImpl(subNode, enter, exit, state, ancestors);\n            ancestors.pop();\n        }\n    }\n    if (exit) exit(node, ancestors, state);\n}\n\nvar isBinding$1 = {};\n\nObject.defineProperty(isBinding$1, \"__esModule\", {\n    value: true\n});\nisBinding$1.default = isBinding;\nvar _getBindingIdentifiers = getBindingIdentifiers$1;\nfunction isBinding(node, parent, grandparent) {\n    if (grandparent && node.type === \"Identifier\" && parent.type === \"ObjectProperty\" && grandparent.type === \"ObjectExpression\") {\n        return false;\n    }\n    var keys = _getBindingIdentifiers.default.keys[parent.type];\n    if (keys) {\n        for(var i = 0; i < keys.length; i++){\n            var key = keys[i];\n            var val = parent[key];\n            if (Array.isArray(val)) {\n                if (val.indexOf(node) >= 0) return true;\n            } else {\n                if (val === node) return true;\n            }\n        }\n    }\n    return false;\n}\n\nvar isBlockScoped$1 = {};\n\nvar isLet$1 = {};\n\nObject.defineProperty(isLet$1, \"__esModule\", {\n    value: true\n});\nisLet$1.default = isLet;\nvar _generated$5 = generated$4;\nvar _constants$1 = constants;\nfunction isLet(node) {\n    return (0, _generated$5.isVariableDeclaration)(node) && (node.kind !== \"var\" || node[_constants$1.BLOCK_SCOPED_SYMBOL]);\n}\n\nObject.defineProperty(isBlockScoped$1, \"__esModule\", {\n    value: true\n});\nisBlockScoped$1.default = isBlockScoped;\nvar _generated$4 = generated$4;\nvar _isLet = isLet$1;\nfunction isBlockScoped(node) {\n    return (0, _generated$4.isFunctionDeclaration)(node) || (0, _generated$4.isClassDeclaration)(node) || (0, _isLet.default)(node);\n}\n\nvar isImmutable$1 = {};\n\nObject.defineProperty(isImmutable$1, \"__esModule\", {\n    value: true\n});\nisImmutable$1.default = isImmutable;\nvar _isType = requireIsType();\nvar _generated$3 = generated$4;\nfunction isImmutable(node) {\n    if ((0, _isType.default)(node.type, \"Immutable\")) return true;\n    if ((0, _generated$3.isIdentifier)(node)) {\n        if (node.name === \"undefined\") {\n            return true;\n        } else {\n            return false;\n        }\n    }\n    return false;\n}\n\nvar isNodesEquivalent$1 = {};\n\nvar _typeof$2 = function(obj) {\n    \"@swc/helpers - typeof\";\n    return obj && typeof Symbol !== \"undefined\" && obj.constructor === Symbol ? \"symbol\" : typeof obj;\n};\nfunction _createForOfIteratorHelperLoose$1(o, allowArrayLike) {\n    var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n    if (it) return (it = it.call(o)).next.bind(it);\n    if (Array.isArray(o) || (it = unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n        if (it) o = it;\n        var i = 0;\n        return function() {\n            if (i >= o.length) return {\n                done: true\n            };\n            return {\n                done: false,\n                value: o[i++]\n            };\n        };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nObject.defineProperty(isNodesEquivalent$1, \"__esModule\", {\n    value: true\n});\nisNodesEquivalent$1.default = isNodesEquivalent;\nvar _definitions = requireDefinitions();\nfunction isNodesEquivalent(a, b) {\n    if (typeof a !== \"object\" || typeof b !== \"object\" || a == null || b == null) {\n        return a === b;\n    }\n    if (a.type !== b.type) {\n        return false;\n    }\n    var fields = Object.keys(_definitions.NODE_FIELDS[a.type] || a.type);\n    var visitorKeys = _definitions.VISITOR_KEYS[a.type];\n    for(var _iterator = _createForOfIteratorHelperLoose$1(fields), _step; !(_step = _iterator()).done;){\n        var field = _step.value;\n        if (_typeof$2(a[field]) !== _typeof$2(b[field])) {\n            return false;\n        }\n        if (a[field] == null && b[field] == null) {\n            continue;\n        } else if (a[field] == null || b[field] == null) {\n            return false;\n        }\n        if (Array.isArray(a[field])) {\n            if (!Array.isArray(b[field])) {\n                return false;\n            }\n            if (a[field].length !== b[field].length) {\n                return false;\n            }\n            for(var i = 0; i < a[field].length; i++){\n                if (!isNodesEquivalent(a[field][i], b[field][i])) {\n                    return false;\n                }\n            }\n            continue;\n        }\n        if (typeof a[field] === \"object\" && !(visitorKeys != null && visitorKeys.includes(field))) {\n            for(var _iterator1 = _createForOfIteratorHelperLoose$1(Object.keys(a[field])), _step1; !(_step1 = _iterator1()).done;){\n                var key = _step1.value;\n                if (a[field][key] !== b[field][key]) {\n                    return false;\n                }\n            }\n            continue;\n        }\n        if (!isNodesEquivalent(a[field], b[field])) {\n            return false;\n        }\n    }\n    return true;\n}\n\nvar isReferenced$1 = {};\n\nObject.defineProperty(isReferenced$1, \"__esModule\", {\n    value: true\n});\nisReferenced$1.default = isReferenced;\nfunction isReferenced(node, parent, grandparent) {\n    switch(parent.type){\n        case \"MemberExpression\":\n        case \"JSXMemberExpression\":\n        case \"OptionalMemberExpression\":\n            if (parent.property === node) {\n                return !!parent.computed;\n            }\n            return parent.object === node;\n        case \"VariableDeclarator\":\n            return parent.init === node;\n        case \"ArrowFunctionExpression\":\n            return parent.body === node;\n        case \"PrivateName\":\n            return false;\n        case \"ClassMethod\":\n        case \"ClassPrivateMethod\":\n        case \"ObjectMethod\":\n            if (parent.params.includes(node)) {\n                return false;\n            }\n        case \"ObjectProperty\":\n        case \"ClassProperty\":\n        case \"ClassPrivateProperty\":\n            if (parent.key === node) {\n                return !!parent.computed;\n            }\n            if (parent.value === node) {\n                return !grandparent || grandparent.type !== \"ObjectPattern\";\n            }\n            return true;\n        case \"ClassDeclaration\":\n        case \"ClassExpression\":\n            return parent.superClass === node;\n        case \"AssignmentExpression\":\n            return parent.right === node;\n        case \"AssignmentPattern\":\n            return parent.right === node;\n        case \"LabeledStatement\":\n            return false;\n        case \"CatchClause\":\n            return false;\n        case \"RestElement\":\n            return false;\n        case \"BreakStatement\":\n        case \"ContinueStatement\":\n            return false;\n        case \"FunctionDeclaration\":\n        case \"FunctionExpression\":\n            return false;\n        case \"ExportNamespaceSpecifier\":\n        case \"ExportDefaultSpecifier\":\n            return false;\n        case \"ExportSpecifier\":\n            if (grandparent != null && grandparent.source) {\n                return false;\n            }\n            return parent.local === node;\n        case \"ImportDefaultSpecifier\":\n        case \"ImportNamespaceSpecifier\":\n        case \"ImportSpecifier\":\n            return false;\n        case \"JSXAttribute\":\n            return false;\n        case \"ObjectPattern\":\n        case \"ArrayPattern\":\n            return false;\n        case \"MetaProperty\":\n            return false;\n        case \"ObjectTypeProperty\":\n            return parent.key !== node;\n        case \"TSEnumMember\":\n            return parent.id !== node;\n        case \"TSPropertySignature\":\n            if (parent.key === node) {\n                return !!parent.computed;\n            }\n            return true;\n    }\n    return true;\n}\n\nvar isScope$1 = {};\n\nObject.defineProperty(isScope$1, \"__esModule\", {\n    value: true\n});\nisScope$1.default = isScope;\nvar _generated$2 = generated$4;\nfunction isScope(node, parent) {\n    if ((0, _generated$2.isBlockStatement)(node) && ((0, _generated$2.isFunction)(parent) || (0, _generated$2.isCatchClause)(parent))) {\n        return false;\n    }\n    if ((0, _generated$2.isPattern)(node) && ((0, _generated$2.isFunction)(parent) || (0, _generated$2.isCatchClause)(parent))) {\n        return true;\n    }\n    return (0, _generated$2.isScopable)(node);\n}\n\nvar isSpecifierDefault$1 = {};\n\nObject.defineProperty(isSpecifierDefault$1, \"__esModule\", {\n    value: true\n});\nisSpecifierDefault$1.default = isSpecifierDefault;\nvar _generated$1 = generated$4;\nfunction isSpecifierDefault(specifier) {\n    return (0, _generated$1.isImportDefaultSpecifier)(specifier) || (0, _generated$1.isIdentifier)(specifier.imported || specifier.exported, {\n        name: \"default\"\n    });\n}\n\nvar isValidES3Identifier$1 = {};\n\nObject.defineProperty(isValidES3Identifier$1, \"__esModule\", {\n    value: true\n});\nisValidES3Identifier$1.default = isValidES3Identifier;\nvar _isValidIdentifier = isValidIdentifier$1;\nvar RESERVED_WORDS_ES3_ONLY = new Set([\n    \"abstract\",\n    \"boolean\",\n    \"byte\",\n    \"char\",\n    \"double\",\n    \"enum\",\n    \"final\",\n    \"float\",\n    \"goto\",\n    \"implements\",\n    \"int\",\n    \"interface\",\n    \"long\",\n    \"native\",\n    \"package\",\n    \"private\",\n    \"protected\",\n    \"public\",\n    \"short\",\n    \"static\",\n    \"synchronized\",\n    \"throws\",\n    \"transient\",\n    \"volatile\"\n]);\nfunction isValidES3Identifier(name) {\n    return (0, _isValidIdentifier.default)(name) && !RESERVED_WORDS_ES3_ONLY.has(name);\n}\n\nvar isVar$1 = {};\n\nObject.defineProperty(isVar$1, \"__esModule\", {\n    value: true\n});\nisVar$1.default = isVar;\nvar _generated = generated$4;\nvar _constants = constants;\nfunction isVar(node) {\n    return (0, _generated.isVariableDeclaration)(node, {\n        kind: \"var\"\n    }) && !node[_constants.BLOCK_SCOPED_SYMBOL];\n}\n\nvar generated = {};\n\n(function(exports) {\n    Object.defineProperty(exports, \"__esModule\", {\n        value: true\n    });\n    var _exportNames = {\n        react: true,\n        assertNode: true,\n        createTypeAnnotationBasedOnTypeof: true,\n        createUnionTypeAnnotation: true,\n        createFlowUnionType: true,\n        createTSUnionType: true,\n        cloneNode: true,\n        clone: true,\n        cloneDeep: true,\n        cloneDeepWithoutLoc: true,\n        cloneWithoutLoc: true,\n        addComment: true,\n        addComments: true,\n        inheritInnerComments: true,\n        inheritLeadingComments: true,\n        inheritsComments: true,\n        inheritTrailingComments: true,\n        removeComments: true,\n        ensureBlock: true,\n        toBindingIdentifierName: true,\n        toBlock: true,\n        toComputedKey: true,\n        toExpression: true,\n        toIdentifier: true,\n        toKeyAlias: true,\n        toSequenceExpression: true,\n        toStatement: true,\n        valueToNode: true,\n        appendToMemberExpression: true,\n        inherits: true,\n        prependToMemberExpression: true,\n        removeProperties: true,\n        removePropertiesDeep: true,\n        removeTypeDuplicates: true,\n        getBindingIdentifiers: true,\n        getOuterBindingIdentifiers: true,\n        traverse: true,\n        traverseFast: true,\n        shallowEqual: true,\n        is: true,\n        isBinding: true,\n        isBlockScoped: true,\n        isImmutable: true,\n        isLet: true,\n        isNode: true,\n        isNodesEquivalent: true,\n        isPlaceholderType: true,\n        isReferenced: true,\n        isScope: true,\n        isSpecifierDefault: true,\n        isType: true,\n        isValidES3Identifier: true,\n        isValidIdentifier: true,\n        isVar: true,\n        matchesPattern: true,\n        validate: true,\n        buildMatchMemberExpression: true\n    };\n    Object.defineProperty(exports, \"assertNode\", {\n        enumerable: true,\n        get: function get() {\n            return _assertNode.default;\n        }\n    });\n    Object.defineProperty(exports, \"createTypeAnnotationBasedOnTypeof\", {\n        enumerable: true,\n        get: function get() {\n            return _createTypeAnnotationBasedOnTypeof.default;\n        }\n    });\n    Object.defineProperty(exports, \"createUnionTypeAnnotation\", {\n        enumerable: true,\n        get: function get() {\n            return _createFlowUnionType.default;\n        }\n    });\n    Object.defineProperty(exports, \"createFlowUnionType\", {\n        enumerable: true,\n        get: function get() {\n            return _createFlowUnionType.default;\n        }\n    });\n    Object.defineProperty(exports, \"createTSUnionType\", {\n        enumerable: true,\n        get: function get() {\n            return _createTSUnionType.default;\n        }\n    });\n    Object.defineProperty(exports, \"cloneNode\", {\n        enumerable: true,\n        get: function get() {\n            return _cloneNode.default;\n        }\n    });\n    Object.defineProperty(exports, \"clone\", {\n        enumerable: true,\n        get: function get() {\n            return _clone.default;\n        }\n    });\n    Object.defineProperty(exports, \"cloneDeep\", {\n        enumerable: true,\n        get: function get() {\n            return _cloneDeep.default;\n        }\n    });\n    Object.defineProperty(exports, \"cloneDeepWithoutLoc\", {\n        enumerable: true,\n        get: function get() {\n            return _cloneDeepWithoutLoc.default;\n        }\n    });\n    Object.defineProperty(exports, \"cloneWithoutLoc\", {\n        enumerable: true,\n        get: function get() {\n            return _cloneWithoutLoc.default;\n        }\n    });\n    Object.defineProperty(exports, \"addComment\", {\n        enumerable: true,\n        get: function get() {\n            return _addComment.default;\n        }\n    });\n    Object.defineProperty(exports, \"addComments\", {\n        enumerable: true,\n        get: function get() {\n            return _addComments.default;\n        }\n    });\n    Object.defineProperty(exports, \"inheritInnerComments\", {\n        enumerable: true,\n        get: function get() {\n            return _inheritInnerComments.default;\n        }\n    });\n    Object.defineProperty(exports, \"inheritLeadingComments\", {\n        enumerable: true,\n        get: function get() {\n            return _inheritLeadingComments.default;\n        }\n    });\n    Object.defineProperty(exports, \"inheritsComments\", {\n        enumerable: true,\n        get: function get() {\n            return _inheritsComments.default;\n        }\n    });\n    Object.defineProperty(exports, \"inheritTrailingComments\", {\n        enumerable: true,\n        get: function get() {\n            return _inheritTrailingComments.default;\n        }\n    });\n    Object.defineProperty(exports, \"removeComments\", {\n        enumerable: true,\n        get: function get() {\n            return _removeComments.default;\n        }\n    });\n    Object.defineProperty(exports, \"ensureBlock\", {\n        enumerable: true,\n        get: function get() {\n            return _ensureBlock.default;\n        }\n    });\n    Object.defineProperty(exports, \"toBindingIdentifierName\", {\n        enumerable: true,\n        get: function get() {\n            return _toBindingIdentifierName.default;\n        }\n    });\n    Object.defineProperty(exports, \"toBlock\", {\n        enumerable: true,\n        get: function get() {\n            return _toBlock.default;\n        }\n    });\n    Object.defineProperty(exports, \"toComputedKey\", {\n        enumerable: true,\n        get: function get() {\n            return _toComputedKey.default;\n        }\n    });\n    Object.defineProperty(exports, \"toExpression\", {\n        enumerable: true,\n        get: function get() {\n            return _toExpression.default;\n        }\n    });\n    Object.defineProperty(exports, \"toIdentifier\", {\n        enumerable: true,\n        get: function get() {\n            return _toIdentifier.default;\n        }\n    });\n    Object.defineProperty(exports, \"toKeyAlias\", {\n        enumerable: true,\n        get: function get() {\n            return _toKeyAlias.default;\n        }\n    });\n    Object.defineProperty(exports, \"toSequenceExpression\", {\n        enumerable: true,\n        get: function get() {\n            return _toSequenceExpression.default;\n        }\n    });\n    Object.defineProperty(exports, \"toStatement\", {\n        enumerable: true,\n        get: function get() {\n            return _toStatement.default;\n        }\n    });\n    Object.defineProperty(exports, \"valueToNode\", {\n        enumerable: true,\n        get: function get() {\n            return _valueToNode.default;\n        }\n    });\n    Object.defineProperty(exports, \"appendToMemberExpression\", {\n        enumerable: true,\n        get: function get() {\n            return _appendToMemberExpression.default;\n        }\n    });\n    Object.defineProperty(exports, \"inherits\", {\n        enumerable: true,\n        get: function get() {\n            return _inherits.default;\n        }\n    });\n    Object.defineProperty(exports, \"prependToMemberExpression\", {\n        enumerable: true,\n        get: function get() {\n            return _prependToMemberExpression.default;\n        }\n    });\n    Object.defineProperty(exports, \"removeProperties\", {\n        enumerable: true,\n        get: function get() {\n            return _removeProperties.default;\n        }\n    });\n    Object.defineProperty(exports, \"removePropertiesDeep\", {\n        enumerable: true,\n        get: function get() {\n            return _removePropertiesDeep.default;\n        }\n    });\n    Object.defineProperty(exports, \"removeTypeDuplicates\", {\n        enumerable: true,\n        get: function get() {\n            return _removeTypeDuplicates.default;\n        }\n    });\n    Object.defineProperty(exports, \"getBindingIdentifiers\", {\n        enumerable: true,\n        get: function get() {\n            return _getBindingIdentifiers.default;\n        }\n    });\n    Object.defineProperty(exports, \"getOuterBindingIdentifiers\", {\n        enumerable: true,\n        get: function get() {\n            return _getOuterBindingIdentifiers.default;\n        }\n    });\n    Object.defineProperty(exports, \"traverse\", {\n        enumerable: true,\n        get: function get() {\n            return _traverse.default;\n        }\n    });\n    Object.defineProperty(exports, \"traverseFast\", {\n        enumerable: true,\n        get: function get() {\n            return _traverseFast.default;\n        }\n    });\n    Object.defineProperty(exports, \"shallowEqual\", {\n        enumerable: true,\n        get: function get() {\n            return _shallowEqual.default;\n        }\n    });\n    Object.defineProperty(exports, \"is\", {\n        enumerable: true,\n        get: function get() {\n            return _is.default;\n        }\n    });\n    Object.defineProperty(exports, \"isBinding\", {\n        enumerable: true,\n        get: function get() {\n            return _isBinding.default;\n        }\n    });\n    Object.defineProperty(exports, \"isBlockScoped\", {\n        enumerable: true,\n        get: function get() {\n            return _isBlockScoped.default;\n        }\n    });\n    Object.defineProperty(exports, \"isImmutable\", {\n        enumerable: true,\n        get: function get() {\n            return _isImmutable.default;\n        }\n    });\n    Object.defineProperty(exports, \"isLet\", {\n        enumerable: true,\n        get: function get() {\n            return _isLet.default;\n        }\n    });\n    Object.defineProperty(exports, \"isNode\", {\n        enumerable: true,\n        get: function get() {\n            return _isNode.default;\n        }\n    });\n    Object.defineProperty(exports, \"isNodesEquivalent\", {\n        enumerable: true,\n        get: function get() {\n            return _isNodesEquivalent.default;\n        }\n    });\n    Object.defineProperty(exports, \"isPlaceholderType\", {\n        enumerable: true,\n        get: function get() {\n            return _isPlaceholderType.default;\n        }\n    });\n    Object.defineProperty(exports, \"isReferenced\", {\n        enumerable: true,\n        get: function get() {\n            return _isReferenced.default;\n        }\n    });\n    Object.defineProperty(exports, \"isScope\", {\n        enumerable: true,\n        get: function get() {\n            return _isScope.default;\n        }\n    });\n    Object.defineProperty(exports, \"isSpecifierDefault\", {\n        enumerable: true,\n        get: function get() {\n            return _isSpecifierDefault.default;\n        }\n    });\n    Object.defineProperty(exports, \"isType\", {\n        enumerable: true,\n        get: function get() {\n            return _isType.default;\n        }\n    });\n    Object.defineProperty(exports, \"isValidES3Identifier\", {\n        enumerable: true,\n        get: function get() {\n            return _isValidES3Identifier.default;\n        }\n    });\n    Object.defineProperty(exports, \"isValidIdentifier\", {\n        enumerable: true,\n        get: function get() {\n            return _isValidIdentifier.default;\n        }\n    });\n    Object.defineProperty(exports, \"isVar\", {\n        enumerable: true,\n        get: function get() {\n            return _isVar.default;\n        }\n    });\n    Object.defineProperty(exports, \"matchesPattern\", {\n        enumerable: true,\n        get: function get() {\n            return _matchesPattern.default;\n        }\n    });\n    Object.defineProperty(exports, \"validate\", {\n        enumerable: true,\n        get: function get() {\n            return _validate.default;\n        }\n    });\n    Object.defineProperty(exports, \"buildMatchMemberExpression\", {\n        enumerable: true,\n        get: function get() {\n            return _buildMatchMemberExpression.default;\n        }\n    });\n    exports.react = void 0;\n    var _isReactComponent = isReactComponent$1;\n    var _isCompatTag = isCompatTag$1;\n    var _buildChildren = buildChildren$1;\n    var _assertNode = assertNode$1;\n    var _generated = generated$2;\n    Object.keys(_generated).forEach(function(key) {\n        if (key === \"default\" || key === \"__esModule\") return;\n        if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;\n        if (key in exports && exports[key] === _generated[key]) return;\n        Object.defineProperty(exports, key, {\n            enumerable: true,\n            get: function get() {\n                return _generated[key];\n            }\n        });\n    });\n    var _createTypeAnnotationBasedOnTypeof = createTypeAnnotationBasedOnTypeof$1;\n    var _createFlowUnionType = createFlowUnionType$1;\n    var _createTSUnionType = createTSUnionType$1;\n    var _generated2 = generated$3;\n    Object.keys(_generated2).forEach(function(key) {\n        if (key === \"default\" || key === \"__esModule\") return;\n        if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;\n        if (key in exports && exports[key] === _generated2[key]) return;\n        Object.defineProperty(exports, key, {\n            enumerable: true,\n            get: function get() {\n                return _generated2[key];\n            }\n        });\n    });\n    var _uppercase = uppercase;\n    Object.keys(_uppercase).forEach(function(key) {\n        if (key === \"default\" || key === \"__esModule\") return;\n        if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;\n        if (key in exports && exports[key] === _uppercase[key]) return;\n        Object.defineProperty(exports, key, {\n            enumerable: true,\n            get: function get() {\n                return _uppercase[key];\n            }\n        });\n    });\n    var _cloneNode = cloneNode$1;\n    var _clone = clone$1;\n    var _cloneDeep = cloneDeep$1;\n    var _cloneDeepWithoutLoc = cloneDeepWithoutLoc$1;\n    var _cloneWithoutLoc = cloneWithoutLoc$1;\n    var _addComment = addComment$1;\n    var _addComments = addComments$1;\n    var _inheritInnerComments = inheritInnerComments$1;\n    var _inheritLeadingComments = inheritLeadingComments$1;\n    var _inheritsComments = inheritsComments$1;\n    var _inheritTrailingComments = inheritTrailingComments$1;\n    var _removeComments = removeComments$1;\n    var _generated3 = generated$1;\n    Object.keys(_generated3).forEach(function(key) {\n        if (key === \"default\" || key === \"__esModule\") return;\n        if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;\n        if (key in exports && exports[key] === _generated3[key]) return;\n        Object.defineProperty(exports, key, {\n            enumerable: true,\n            get: function get() {\n                return _generated3[key];\n            }\n        });\n    });\n    var _constants = constants;\n    Object.keys(_constants).forEach(function(key) {\n        if (key === \"default\" || key === \"__esModule\") return;\n        if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;\n        if (key in exports && exports[key] === _constants[key]) return;\n        Object.defineProperty(exports, key, {\n            enumerable: true,\n            get: function get() {\n                return _constants[key];\n            }\n        });\n    });\n    var _ensureBlock = ensureBlock$1;\n    var _toBindingIdentifierName = toBindingIdentifierName$1;\n    var _toBlock = toBlock$1;\n    var _toComputedKey = toComputedKey$1;\n    var _toExpression = toExpression$1;\n    var _toIdentifier = toIdentifier$1;\n    var _toKeyAlias = toKeyAlias$1;\n    var _toSequenceExpression = toSequenceExpression$1;\n    var _toStatement = toStatement$1;\n    var _valueToNode = valueToNode$1;\n    var _definitions = requireDefinitions();\n    Object.keys(_definitions).forEach(function(key) {\n        if (key === \"default\" || key === \"__esModule\") return;\n        if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;\n        if (key in exports && exports[key] === _definitions[key]) return;\n        Object.defineProperty(exports, key, {\n            enumerable: true,\n            get: function get() {\n                return _definitions[key];\n            }\n        });\n    });\n    var _appendToMemberExpression = appendToMemberExpression$1;\n    var _inherits = inherits$1;\n    var _prependToMemberExpression = prependToMemberExpression$1;\n    var _removeProperties = removeProperties$1;\n    var _removePropertiesDeep = removePropertiesDeep$1;\n    var _removeTypeDuplicates = removeTypeDuplicates$3;\n    var _getBindingIdentifiers = getBindingIdentifiers$1;\n    var _getOuterBindingIdentifiers = getOuterBindingIdentifiers$1;\n    var _traverse = traverse$1;\n    Object.keys(_traverse).forEach(function(key) {\n        if (key === \"default\" || key === \"__esModule\") return;\n        if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;\n        if (key in exports && exports[key] === _traverse[key]) return;\n        Object.defineProperty(exports, key, {\n            enumerable: true,\n            get: function get() {\n                return _traverse[key];\n            }\n        });\n    });\n    var _traverseFast = traverseFast$1;\n    var _shallowEqual = shallowEqual$1;\n    var _is = requireIs();\n    var _isBinding = isBinding$1;\n    var _isBlockScoped = isBlockScoped$1;\n    var _isImmutable = isImmutable$1;\n    var _isLet = isLet$1;\n    var _isNode = isNode$1;\n    var _isNodesEquivalent = isNodesEquivalent$1;\n    var _isPlaceholderType = requireIsPlaceholderType();\n    var _isReferenced = isReferenced$1;\n    var _isScope = isScope$1;\n    var _isSpecifierDefault = isSpecifierDefault$1;\n    var _isType = requireIsType();\n    var _isValidES3Identifier = isValidES3Identifier$1;\n    var _isValidIdentifier = isValidIdentifier$1;\n    var _isVar = isVar$1;\n    var _matchesPattern = matchesPattern$1;\n    var _validate = requireValidate();\n    var _buildMatchMemberExpression = buildMatchMemberExpression$1;\n    var _generated4 = generated$4;\n    Object.keys(_generated4).forEach(function(key) {\n        if (key === \"default\" || key === \"__esModule\") return;\n        if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;\n        if (key in exports && exports[key] === _generated4[key]) return;\n        Object.defineProperty(exports, key, {\n            enumerable: true,\n            get: function get() {\n                return _generated4[key];\n            }\n        });\n    });\n    var _generated5 = generated;\n    Object.keys(_generated5).forEach(function(key) {\n        if (key === \"default\" || key === \"__esModule\") return;\n        if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;\n        if (key in exports && exports[key] === _generated5[key]) return;\n        Object.defineProperty(exports, key, {\n            enumerable: true,\n            get: function get() {\n                return _generated5[key];\n            }\n        });\n    });\n    var react = {\n        isReactComponent: _isReactComponent.default,\n        isCompatTag: _isCompatTag.default,\n        buildChildren: _buildChildren.default\n    };\n    exports.react = react;\n})(lib$1);\n\nfunction hash(str) {\n    var _$hash = 5381, i = str.length;\n    while(i){\n        _$hash = _$hash * 33 ^ str.charCodeAt(--i);\n    }\n    /* JavaScript does bitwise operations (like XOR, above) on 32-bit signed\n   * integers. Since we want the results to be always positive, convert the\n   * signed int to an unsigned by doing an unsigned bitshift. */ return _$hash >>> 0;\n}\nvar stringHash = hash;\n\nvar sourceMapGenerator = {};\n\nvar base64Vlq = {};\n\nvar base64$1 = {};\n\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */ var intToCharMap = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\".split(\"\");\n/**\n * Encode an integer in the range of 0 to 63 to a single base 64 digit.\n */ base64$1.encode = function encode(number) {\n    if (0 <= number && number < intToCharMap.length) {\n        return intToCharMap[number];\n    }\n    throw new TypeError(\"Must be between 0 and 63: \" + number);\n};\n\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n *\n * Based on the Base 64 VLQ implementation in Closure Compiler:\n * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java\n *\n * Copyright 2011 The Closure Compiler Authors. All rights reserved.\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *  * Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above\n *    copyright notice, this list of conditions and the following\n *    disclaimer in the documentation and/or other materials provided\n *    with the distribution.\n *  * Neither the name of Google Inc. nor the names of its\n *    contributors may be used to endorse or promote products derived\n *    from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */ var base64 = base64$1;\n// A single base 64 digit can contain 6 bits of data. For the base 64 variable\n// length quantities we use in the source map spec, the first bit is the sign,\n// the next four bits are the actual value, and the 6th bit is the\n// continuation bit. The continuation bit tells us whether there are more\n// digits in this value following this digit.\n//\n//   Continuation\n//   |    Sign\n//   |    |\n//   V    V\n//   101011\nvar VLQ_BASE_SHIFT = 5;\n// binary: 100000\nvar VLQ_BASE = 1 << VLQ_BASE_SHIFT;\n// binary: 011111\nvar VLQ_BASE_MASK = VLQ_BASE - 1;\n// binary: 100000\nvar VLQ_CONTINUATION_BIT = VLQ_BASE;\n/**\n * Converts from a two-complement value to a value where the sign bit is\n * placed in the least significant bit.  For example, as decimals:\n *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)\n *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)\n */ function toVLQSigned(aValue) {\n    return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;\n}\n/**\n * Returns the base 64 VLQ encoded value.\n */ base64Vlq.encode = function base64VLQ_encode(aValue) {\n    var encoded = \"\";\n    var digit;\n    var vlq = toVLQSigned(aValue);\n    do {\n        digit = vlq & VLQ_BASE_MASK;\n        vlq >>>= VLQ_BASE_SHIFT;\n        if (vlq > 0) {\n            // There are still more digits in this value, so we must make sure the\n            // continuation bit is marked.\n            digit |= VLQ_CONTINUATION_BIT;\n        }\n        encoded += base64.encode(digit);\n    }while (vlq > 0);\n    return encoded;\n};\n\nvar util$3 = {};\n\n(function(exports) {\n    var getArg = /*\n\t * Copyright 2011 Mozilla Foundation and contributors\n\t * Licensed under the New BSD license. See LICENSE or:\n\t * http://opensource.org/licenses/BSD-3-Clause\n\t */ /**\n\t * This is a helper function for getting values from parameter/options\n\t * objects.\n\t *\n\t * @param args The object we are extracting values from\n\t * @param name The name of the property we are getting.\n\t * @param defaultValue An optional value to return if the property is missing\n\t * from the object. If this is not specified and the property is missing, an\n\t * error will be thrown.\n\t */ function getArg(aArgs, aName, aDefaultValue) {\n        if (aName in aArgs) {\n            return aArgs[aName];\n        } else if (arguments.length === 3) {\n            return aDefaultValue;\n        }\n        throw new Error('\"' + aName + '\" is a required argument.');\n    };\n    var urlParse = function urlParse(aUrl) {\n        var match = aUrl.match(urlRegexp);\n        if (!match) {\n            return null;\n        }\n        return {\n            scheme: match[1],\n            auth: match[2],\n            host: match[3],\n            port: match[4],\n            path: match[5]\n        };\n    };\n    var urlGenerate = function urlGenerate(aParsedUrl) {\n        var url = \"\";\n        if (aParsedUrl.scheme) {\n            url += aParsedUrl.scheme + \":\";\n        }\n        url += \"//\";\n        if (aParsedUrl.auth) {\n            url += aParsedUrl.auth + \"@\";\n        }\n        if (aParsedUrl.host) {\n            url += aParsedUrl.host;\n        }\n        if (aParsedUrl.port) {\n            url += \":\" + aParsedUrl.port;\n        }\n        if (aParsedUrl.path) {\n            url += aParsedUrl.path;\n        }\n        return url;\n    };\n    var lruMemoize = /**\n\t * Takes some function `f(input) -> result` and returns a memoized version of\n\t * `f`.\n\t *\n\t * We keep at most `MAX_CACHED_INPUTS` memoized results of `f` alive. The\n\t * memoization is a dumb-simple, linear least-recently-used cache.\n\t */ function lruMemoize(f) {\n        var cache = [];\n        return function(input) {\n            for(var i = 0; i < cache.length; i++){\n                if (cache[i].input === input) {\n                    var temp = cache[0];\n                    cache[0] = cache[i];\n                    cache[i] = temp;\n                    return cache[0].result;\n                }\n            }\n            var result = f(input);\n            cache.unshift({\n                input: input,\n                result: result\n            });\n            if (cache.length > MAX_CACHED_INPUTS) {\n                cache.pop();\n            }\n            return result;\n        };\n    };\n    var join = /**\n\t * Joins two paths/URLs.\n\t *\n\t * @param aRoot The root path or URL.\n\t * @param aPath The path or URL to be joined with the root.\n\t *\n\t * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a\n\t *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended\n\t *   first.\n\t * - Otherwise aPath is a path. If aRoot is a URL, then its path portion\n\t *   is updated with the result and aRoot is returned. Otherwise the result\n\t *   is returned.\n\t *   - If aPath is absolute, the result is aPath.\n\t *   - Otherwise the two paths are joined with a slash.\n\t * - Joining for example 'http://' and 'www.example.com' is also supported.\n\t */ function join(aRoot, aPath) {\n        if (aRoot === \"\") {\n            aRoot = \".\";\n        }\n        if (aPath === \"\") {\n            aPath = \".\";\n        }\n        var aPathUrl = urlParse(aPath);\n        var aRootUrl = urlParse(aRoot);\n        if (aRootUrl) {\n            aRoot = aRootUrl.path || \"/\";\n        }\n        // `join(foo, '//www.example.org')`\n        if (aPathUrl && !aPathUrl.scheme) {\n            if (aRootUrl) {\n                aPathUrl.scheme = aRootUrl.scheme;\n            }\n            return urlGenerate(aPathUrl);\n        }\n        if (aPathUrl || aPath.match(dataUrlRegexp)) {\n            return aPath;\n        }\n        // `join('http://', 'www.example.com')`\n        if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {\n            aRootUrl.host = aPath;\n            return urlGenerate(aRootUrl);\n        }\n        var joined = aPath.charAt(0) === \"/\" ? aPath : normalize(aRoot.replace(/\\/+$/, \"\") + \"/\" + aPath);\n        if (aRootUrl) {\n            aRootUrl.path = joined;\n            return urlGenerate(aRootUrl);\n        }\n        return joined;\n    };\n    var relative = /**\n\t * Make a path relative to a URL or another path.\n\t *\n\t * @param aRoot The root path or URL.\n\t * @param aPath The path or URL to be made relative to aRoot.\n\t */ function relative(aRoot, aPath) {\n        if (aRoot === \"\") {\n            aRoot = \".\";\n        }\n        aRoot = aRoot.replace(/\\/$/, \"\");\n        // It is possible for the path to be above the root. In this case, simply\n        // checking whether the root is a prefix of the path won't work. Instead, we\n        // need to remove components from the root one by one, until either we find\n        // a prefix that fits, or we run out of components to remove.\n        var level = 0;\n        while(aPath.indexOf(aRoot + \"/\") !== 0){\n            var index = aRoot.lastIndexOf(\"/\");\n            if (index < 0) {\n                return aPath;\n            }\n            // If the only part of the root that is left is the scheme (i.e. http://,\n            // file:///, etc.), one or more slashes (/), or simply nothing at all, we\n            // have exhausted all components, so the path is not relative to the root.\n            aRoot = aRoot.slice(0, index);\n            if (aRoot.match(/^([^\\/]+:\\/)?\\/*$/)) {\n                return aPath;\n            }\n            ++level;\n        }\n        // Make sure we add a \"../\" for each component we removed from the root.\n        return Array(level + 1).join(\"../\") + aPath.substr(aRoot.length + 1);\n    };\n    var identity = function identity(s) {\n        return s;\n    };\n    var toSetString = /**\n\t * Because behavior goes wacky when you set `__proto__` on objects, we\n\t * have to prefix all the strings in our set with an arbitrary character.\n\t *\n\t * See https://github.com/mozilla/source-map/pull/31 and\n\t * https://github.com/mozilla/source-map/issues/30\n\t *\n\t * @param String aStr\n\t */ function toSetString(aStr) {\n        if (isProtoString(aStr)) {\n            return \"$\" + aStr;\n        }\n        return aStr;\n    };\n    var fromSetString = function fromSetString(aStr) {\n        if (isProtoString(aStr)) {\n            return aStr.slice(1);\n        }\n        return aStr;\n    };\n    var isProtoString = function isProtoString(s) {\n        if (!s) {\n            return false;\n        }\n        var length = s.length;\n        if (length < 9 /* \"__proto__\".length */ ) {\n            return false;\n        }\n        /* eslint-disable no-multi-spaces */ if (s.charCodeAt(length - 1) !== 95 /* '_' */  || s.charCodeAt(length - 2) !== 95 /* '_' */  || s.charCodeAt(length - 3) !== 111 /* 'o' */  || s.charCodeAt(length - 4) !== 116 /* 't' */  || s.charCodeAt(length - 5) !== 111 /* 'o' */  || s.charCodeAt(length - 6) !== 114 /* 'r' */  || s.charCodeAt(length - 7) !== 112 /* 'p' */  || s.charCodeAt(length - 8) !== 95 /* '_' */  || s.charCodeAt(length - 9) !== 95 /* '_' */ ) {\n            return false;\n        }\n        /* eslint-enable no-multi-spaces */ for(var i = length - 10; i >= 0; i--){\n            if (s.charCodeAt(i) !== 36 /* '$' */ ) {\n                return false;\n            }\n        }\n        return true;\n    };\n    var compareByOriginalPositions = /**\n\t * Comparator between two mappings where the original positions are compared.\n\t *\n\t * Optionally pass in `true` as `onlyCompareGenerated` to consider two\n\t * mappings with the same original source/line/column, but different generated\n\t * line and column the same. Useful when searching for a mapping with a\n\t * stubbed out mapping.\n\t */ function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {\n        var cmp = strcmp(mappingA.source, mappingB.source);\n        if (cmp !== 0) {\n            return cmp;\n        }\n        cmp = mappingA.originalLine - mappingB.originalLine;\n        if (cmp !== 0) {\n            return cmp;\n        }\n        cmp = mappingA.originalColumn - mappingB.originalColumn;\n        if (cmp !== 0 || onlyCompareOriginal) {\n            return cmp;\n        }\n        cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n        if (cmp !== 0) {\n            return cmp;\n        }\n        cmp = mappingA.generatedLine - mappingB.generatedLine;\n        if (cmp !== 0) {\n            return cmp;\n        }\n        return strcmp(mappingA.name, mappingB.name);\n    };\n    var compareByGeneratedPositionsDeflated = /**\n\t * Comparator between two mappings with deflated source and name indices where\n\t * the generated positions are compared.\n\t *\n\t * Optionally pass in `true` as `onlyCompareGenerated` to consider two\n\t * mappings with the same generated line and column, but different\n\t * source/name/original line and column the same. Useful when searching for a\n\t * mapping with a stubbed out mapping.\n\t */ function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {\n        var cmp = mappingA.generatedLine - mappingB.generatedLine;\n        if (cmp !== 0) {\n            return cmp;\n        }\n        cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n        if (cmp !== 0 || onlyCompareGenerated) {\n            return cmp;\n        }\n        cmp = strcmp(mappingA.source, mappingB.source);\n        if (cmp !== 0) {\n            return cmp;\n        }\n        cmp = mappingA.originalLine - mappingB.originalLine;\n        if (cmp !== 0) {\n            return cmp;\n        }\n        cmp = mappingA.originalColumn - mappingB.originalColumn;\n        if (cmp !== 0) {\n            return cmp;\n        }\n        return strcmp(mappingA.name, mappingB.name);\n    };\n    var strcmp = function strcmp(aStr1, aStr2) {\n        if (aStr1 === aStr2) {\n            return 0;\n        }\n        if (aStr1 === null) {\n            return 1; // aStr2 !== null\n        }\n        if (aStr2 === null) {\n            return -1; // aStr1 !== null\n        }\n        if (aStr1 > aStr2) {\n            return 1;\n        }\n        return -1;\n    };\n    var compareByGeneratedPositionsInflated = /**\n\t * Comparator between two mappings with inflated source and name strings where\n\t * the generated positions are compared.\n\t */ function compareByGeneratedPositionsInflated(mappingA, mappingB) {\n        var cmp = mappingA.generatedLine - mappingB.generatedLine;\n        if (cmp !== 0) {\n            return cmp;\n        }\n        cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n        if (cmp !== 0) {\n            return cmp;\n        }\n        cmp = strcmp(mappingA.source, mappingB.source);\n        if (cmp !== 0) {\n            return cmp;\n        }\n        cmp = mappingA.originalLine - mappingB.originalLine;\n        if (cmp !== 0) {\n            return cmp;\n        }\n        cmp = mappingA.originalColumn - mappingB.originalColumn;\n        if (cmp !== 0) {\n            return cmp;\n        }\n        return strcmp(mappingA.name, mappingB.name);\n    };\n    var parseSourceMapInput = /**\n\t * Strip any JSON XSSI avoidance prefix from the string (as documented\n\t * in the source maps specification), and then parse the string as\n\t * JSON.\n\t */ function parseSourceMapInput(str) {\n        return JSON.parse(str.replace(/^\\)]}'[^\\n]*\\n/, \"\"));\n    };\n    var computeSourceURL = /**\n\t * Compute the URL of a source given the the source root, the source's\n\t * URL, and the source map's URL.\n\t */ function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {\n        sourceURL = sourceURL || \"\";\n        if (sourceRoot) {\n            // This follows what Chrome does.\n            if (sourceRoot[sourceRoot.length - 1] !== \"/\" && sourceURL[0] !== \"/\") {\n                sourceRoot += \"/\";\n            }\n            // The spec says:\n            //   Line 4: An optional source root, useful for relocating source\n            //   files on a server or removing repeated values in the\n            //   sources entry.  This value is prepended to the individual\n            //   entries in the source field.\n            sourceURL = sourceRoot + sourceURL;\n        }\n        // Historically, SourceMapConsumer did not take the sourceMapURL as\n        // a parameter.  This mode is still somewhat supported, which is why\n        // this code block is conditional.  However, it's preferable to pass\n        // the source map URL to SourceMapConsumer, so that this function\n        // can implement the source URL resolution algorithm as outlined in\n        // the spec.  This block is basically the equivalent of:\n        //    new URL(sourceURL, sourceMapURL).toString()\n        // ... except it avoids using URL, which wasn't available in the\n        // older releases of node still supported by this library.\n        //\n        // The spec says:\n        //   If the sources are not absolute URLs after prepending of the\n        //   sourceRoot, the sources are resolved relative to the\n        //   SourceMap (like resolving script src in a html document).\n        if (sourceMapURL) {\n            var parsed = urlParse(sourceMapURL);\n            if (!parsed) {\n                throw new Error(\"sourceMapURL could not be parsed\");\n            }\n            if (parsed.path) {\n                // Strip the last path component, but keep the \"/\".\n                var index = parsed.path.lastIndexOf(\"/\");\n                if (index >= 0) {\n                    parsed.path = parsed.path.substring(0, index + 1);\n                }\n            }\n            sourceURL = join(urlGenerate(parsed), sourceURL);\n        }\n        return normalize(sourceURL);\n    };\n    exports.getArg = getArg;\n    var urlRegexp = /^(?:([\\w+\\-.]+):)?\\/\\/(?:(\\w+:\\w+)@)?([\\w.-]*)(?::(\\d+))?(.*)$/;\n    var dataUrlRegexp = /^data:.+\\,.+$/;\n    exports.urlParse = urlParse;\n    exports.urlGenerate = urlGenerate;\n    var MAX_CACHED_INPUTS = 32;\n    /**\n\t * Normalizes a path, or the path portion of a URL:\n\t *\n\t * - Replaces consecutive slashes with one slash.\n\t * - Removes unnecessary '.' parts.\n\t * - Removes unnecessary '<dir>/..' parts.\n\t *\n\t * Based on code in the Node.js 'path' core module.\n\t *\n\t * @param aPath The path or url to normalize.\n\t */ var normalize = lruMemoize(function normalize(aPath) {\n        var path = aPath;\n        var url = urlParse(aPath);\n        if (url) {\n            if (!url.path) {\n                return aPath;\n            }\n            path = url.path;\n        }\n        var isAbsolute = exports.isAbsolute(path);\n        // Split the path into parts between `/` characters. This is much faster than\n        // using `.split(/\\/+/g)`.\n        var parts = [];\n        var start = 0;\n        var i = 0;\n        while(true){\n            start = i;\n            i = path.indexOf(\"/\", start);\n            if (i === -1) {\n                parts.push(path.slice(start));\n                break;\n            } else {\n                parts.push(path.slice(start, i));\n                while(i < path.length && path[i] === \"/\"){\n                    i++;\n                }\n            }\n        }\n        var up = 0;\n        for(i = parts.length - 1; i >= 0; i--){\n            var part = parts[i];\n            if (part === \".\") {\n                parts.splice(i, 1);\n            } else if (part === \"..\") {\n                up++;\n            } else if (up > 0) {\n                if (part === \"\") {\n                    // The first part is blank if the path is absolute. Trying to go\n                    // above the root is a no-op. Therefore we can remove all '..' parts\n                    // directly after the root.\n                    parts.splice(i + 1, up);\n                    up = 0;\n                } else {\n                    parts.splice(i, 2);\n                    up--;\n                }\n            }\n        }\n        path = parts.join(\"/\");\n        if (path === \"\") {\n            path = isAbsolute ? \"/\" : \".\";\n        }\n        if (url) {\n            url.path = path;\n            return urlGenerate(url);\n        }\n        return path;\n    });\n    exports.normalize = normalize;\n    exports.join = join;\n    exports.isAbsolute = function(aPath) {\n        return aPath.charAt(0) === \"/\" || urlRegexp.test(aPath);\n    };\n    exports.relative = relative;\n    var supportsNullProto = function() {\n        var obj = Object.create(null);\n        return !(\"__proto__\" in obj);\n    }();\n    exports.toSetString = supportsNullProto ? identity : toSetString;\n    exports.fromSetString = supportsNullProto ? identity : fromSetString;\n    exports.compareByOriginalPositions = compareByOriginalPositions;\n    exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;\n    exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;\n    exports.parseSourceMapInput = parseSourceMapInput;\n    exports.computeSourceURL = computeSourceURL;\n})(util$3);\n\nvar arraySet = {};\n\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */ /**\n * A data structure which is a combination of an array and a set. Adding a new\n * member is O(1), testing for membership is O(1), and finding the index of an\n * element is O(1). Removing elements from the set is not supported. Only\n * strings are supported for membership.\n */ var ArraySet$2 = /*#__PURE__*/ function() {\n    function ArraySet() {\n        this._array = [];\n        this._set = new Map();\n    }\n    var _proto = ArraySet.prototype;\n    /**\n   * Return how many unique items are in this ArraySet. If duplicates have been\n   * added, than those do not count towards the size.\n   *\n   * @returns Number\n   */ _proto.size = function size() {\n        return this._set.size;\n    };\n    /**\n   * Add the given string to this set.\n   *\n   * @param String aStr\n   */ _proto.add = function add(aStr, aAllowDuplicates) {\n        var isDuplicate = this.has(aStr);\n        var idx = this._array.length;\n        if (!isDuplicate || aAllowDuplicates) {\n            this._array.push(aStr);\n        }\n        if (!isDuplicate) {\n            this._set.set(aStr, idx);\n        }\n    };\n    /**\n   * Is the given string a member of this set?\n   *\n   * @param String aStr\n   */ _proto.has = function has(aStr) {\n        return this._set.has(aStr);\n    };\n    /**\n   * What is the index of the given string in the array?\n   *\n   * @param String aStr\n   */ _proto.indexOf = function indexOf(aStr) {\n        var idx = this._set.get(aStr);\n        if (idx >= 0) {\n            return idx;\n        }\n        throw new Error('\"' + aStr + '\" is not in the set.');\n    };\n    /**\n   * What is the element at the given index?\n   *\n   * @param Number aIdx\n   */ _proto.at = function at(aIdx) {\n        if (aIdx >= 0 && aIdx < this._array.length) {\n            return this._array[aIdx];\n        }\n        throw new Error(\"No element indexed by \" + aIdx);\n    };\n    /**\n   * Returns the array representation of this set (which has the proper indices\n   * indicated by indexOf). Note that this is a copy of the internal array used\n   * for storing the members so that no one can mess with internal state.\n   */ _proto.toArray = function toArray() {\n        return this._array.slice();\n    };\n    /**\n   * Static method for creating ArraySet instances from an existing array.\n   */ ArraySet.fromArray = function fromArray(aArray, aAllowDuplicates) {\n        var set = new ArraySet();\n        for(var i = 0, len = aArray.length; i < len; i++){\n            set.add(aArray[i], aAllowDuplicates);\n        }\n        return set;\n    };\n    return ArraySet;\n}();\narraySet.ArraySet = ArraySet$2;\n\nvar mappingList = {};\n\n/*\n * Copyright 2014 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */ var util$2 = util$3;\n/**\n * Determine whether mappingB is after mappingA with respect to generated\n * position.\n */ function generatedPositionAfter(mappingA, mappingB) {\n    // Optimized for most common case\n    var lineA = mappingA.generatedLine;\n    var lineB = mappingB.generatedLine;\n    var columnA = mappingA.generatedColumn;\n    var columnB = mappingB.generatedColumn;\n    return lineB > lineA || lineB == lineA && columnB >= columnA || util$2.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;\n}\n/**\n * A data structure to provide a sorted view of accumulated mappings in a\n * performance conscious manner. It trades a negligible overhead in general\n * case for a large speedup in case of mappings being added in order.\n */ var MappingList$1 = /*#__PURE__*/ function() {\n    function MappingList() {\n        this._array = [];\n        this._sorted = true;\n        // Serves as infimum\n        this._last = {\n            generatedLine: -1,\n            generatedColumn: 0\n        };\n    }\n    var _proto = MappingList.prototype;\n    /**\n   * Iterate through internal items. This method takes the same arguments that\n   * `Array.prototype.forEach` takes.\n   *\n   * NOTE: The order of the mappings is NOT guaranteed.\n   */ _proto.unsortedForEach = function unsortedForEach(aCallback, aThisArg) {\n        this._array.forEach(aCallback, aThisArg);\n    };\n    /**\n   * Add the given source mapping.\n   *\n   * @param Object aMapping\n   */ _proto.add = function add(aMapping) {\n        if (generatedPositionAfter(this._last, aMapping)) {\n            this._last = aMapping;\n            this._array.push(aMapping);\n        } else {\n            this._sorted = false;\n            this._array.push(aMapping);\n        }\n    };\n    /**\n   * Returns the flat, sorted array of mappings. The mappings are sorted by\n   * generated position.\n   *\n   * WARNING: This method returns internal data without copying, for\n   * performance. The return value must NOT be mutated, and should be treated as\n   * an immutable borrow. If you want to take ownership, you must make your own\n   * copy.\n   */ _proto.toArray = function toArray() {\n        if (!this._sorted) {\n            this._array.sort(util$2.compareByGeneratedPositionsInflated);\n            this._sorted = true;\n        }\n        return this._array;\n    };\n    return MappingList;\n}();\nmappingList.MappingList = MappingList$1;\n\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */ var base64VLQ = base64Vlq;\nvar util$1 = util$3;\nvar ArraySet$1 = arraySet.ArraySet;\nvar MappingList = mappingList.MappingList;\n/**\n * An instance of the SourceMapGenerator represents a source map which is\n * being built incrementally. You may pass an object with the following\n * properties:\n *\n *   - file: The filename of the generated source.\n *   - sourceRoot: A root for all relative URLs in this source map.\n */ var SourceMapGenerator$1 = /*#__PURE__*/ function() {\n    function SourceMapGenerator(aArgs) {\n        if (!aArgs) {\n            aArgs = {};\n        }\n        this._file = util$1.getArg(aArgs, \"file\", null);\n        this._sourceRoot = util$1.getArg(aArgs, \"sourceRoot\", null);\n        this._skipValidation = util$1.getArg(aArgs, \"skipValidation\", false);\n        this._sources = new ArraySet$1();\n        this._names = new ArraySet$1();\n        this._mappings = new MappingList();\n        this._sourcesContents = null;\n    }\n    var _proto = SourceMapGenerator.prototype;\n    /**\n   * Add a single mapping from original source line and column to the generated\n   * source's line and column for this source map being created. The mapping\n   * object should have the following properties:\n   *\n   *   - generated: An object with the generated line and column positions.\n   *   - original: An object with the original line and column positions.\n   *   - source: The original source file (relative to the sourceRoot).\n   *   - name: An optional original token name for this mapping.\n   */ _proto.addMapping = function addMapping(aArgs) {\n        var generated = util$1.getArg(aArgs, \"generated\");\n        var original = util$1.getArg(aArgs, \"original\", null);\n        var source = util$1.getArg(aArgs, \"source\", null);\n        var name = util$1.getArg(aArgs, \"name\", null);\n        if (!this._skipValidation) {\n            this._validateMapping(generated, original, source, name);\n        }\n        if (source != null) {\n            source = String(source);\n            if (!this._sources.has(source)) {\n                this._sources.add(source);\n            }\n        }\n        if (name != null) {\n            name = String(name);\n            if (!this._names.has(name)) {\n                this._names.add(name);\n            }\n        }\n        this._mappings.add({\n            generatedLine: generated.line,\n            generatedColumn: generated.column,\n            originalLine: original != null && original.line,\n            originalColumn: original != null && original.column,\n            source: source,\n            name: name\n        });\n    };\n    /**\n   * Set the source content for a source file.\n   */ _proto.setSourceContent = function setSourceContent(aSourceFile, aSourceContent) {\n        var source = aSourceFile;\n        if (this._sourceRoot != null) {\n            source = util$1.relative(this._sourceRoot, source);\n        }\n        if (aSourceContent != null) {\n            // Add the source content to the _sourcesContents map.\n            // Create a new _sourcesContents map if the property is null.\n            if (!this._sourcesContents) {\n                this._sourcesContents = Object.create(null);\n            }\n            this._sourcesContents[util$1.toSetString(source)] = aSourceContent;\n        } else if (this._sourcesContents) {\n            // Remove the source file from the _sourcesContents map.\n            // If the _sourcesContents map is empty, set the property to null.\n            delete this._sourcesContents[util$1.toSetString(source)];\n            if (Object.keys(this._sourcesContents).length === 0) {\n                this._sourcesContents = null;\n            }\n        }\n    };\n    /**\n   * Applies the mappings of a sub-source-map for a specific source file to the\n   * source map being generated. Each mapping to the supplied source file is\n   * rewritten using the supplied source map. Note: The resolution for the\n   * resulting mappings is the minimium of this map and the supplied map.\n   *\n   * @param aSourceMapConsumer The source map to be applied.\n   * @param aSourceFile Optional. The filename of the source file.\n   *        If omitted, SourceMapConsumer's file property will be used.\n   * @param aSourceMapPath Optional. The dirname of the path to the source map\n   *        to be applied. If relative, it is relative to the SourceMapConsumer.\n   *        This parameter is needed when the two source maps aren't in the same\n   *        directory, and the source map to be applied contains relative source\n   *        paths. If so, those relative source paths need to be rewritten\n   *        relative to the SourceMapGenerator.\n   */ _proto.applySourceMap = function applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {\n        var sourceFile = aSourceFile;\n        // If aSourceFile is omitted, we will use the file property of the SourceMap\n        if (aSourceFile == null) {\n            if (aSourceMapConsumer.file == null) {\n                throw new Error(\"SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, \" + 'or the source map\\'s \"file\" property. Both were omitted.');\n            }\n            sourceFile = aSourceMapConsumer.file;\n        }\n        var sourceRoot = this._sourceRoot;\n        // Make \"sourceFile\" relative if an absolute Url is passed.\n        if (sourceRoot != null) {\n            sourceFile = util$1.relative(sourceRoot, sourceFile);\n        }\n        // Applying the SourceMap can add and remove items from the sources and\n        // the names array.\n        var newSources = this._mappings.toArray().length > 0 ? new ArraySet$1() : this._sources;\n        var newNames = new ArraySet$1();\n        // Find mappings for the \"sourceFile\"\n        this._mappings.unsortedForEach(function(mapping) {\n            if (mapping.source === sourceFile && mapping.originalLine != null) {\n                // Check if it can be mapped by the source map, then update the mapping.\n                var original = aSourceMapConsumer.originalPositionFor({\n                    line: mapping.originalLine,\n                    column: mapping.originalColumn\n                });\n                if (original.source != null) {\n                    // Copy mapping\n                    mapping.source = original.source;\n                    if (aSourceMapPath != null) {\n                        mapping.source = util$1.join(aSourceMapPath, mapping.source);\n                    }\n                    if (sourceRoot != null) {\n                        mapping.source = util$1.relative(sourceRoot, mapping.source);\n                    }\n                    mapping.originalLine = original.line;\n                    mapping.originalColumn = original.column;\n                    if (original.name != null) {\n                        mapping.name = original.name;\n                    }\n                }\n            }\n            var source = mapping.source;\n            if (source != null && !newSources.has(source)) {\n                newSources.add(source);\n            }\n            var name = mapping.name;\n            if (name != null && !newNames.has(name)) {\n                newNames.add(name);\n            }\n        }, this);\n        this._sources = newSources;\n        this._names = newNames;\n        // Copy sourcesContents of applied map.\n        aSourceMapConsumer.sources.forEach(function(srcFile) {\n            var content = aSourceMapConsumer.sourceContentFor(srcFile);\n            if (content != null) {\n                if (aSourceMapPath != null) {\n                    srcFile = util$1.join(aSourceMapPath, srcFile);\n                }\n                if (sourceRoot != null) {\n                    srcFile = util$1.relative(sourceRoot, srcFile);\n                }\n                this.setSourceContent(srcFile, content);\n            }\n        }, this);\n    };\n    /**\n   * A mapping can have one of the three levels of data:\n   *\n   *   1. Just the generated position.\n   *   2. The Generated position, original position, and original source.\n   *   3. Generated and original position, original source, as well as a name\n   *      token.\n   *\n   * To maintain consistency, we validate that any new mapping being added falls\n   * in to one of these categories.\n   */ _proto._validateMapping = function _validateMapping(aGenerated, aOriginal, aSource, aName) {\n        // When aOriginal is truthy but has empty values for .line and .column,\n        // it is most likely a programmer error. In this case we throw a very\n        // specific error message to try to guide them the right way.\n        // For example: https://github.com/Polymer/polymer-bundler/pull/519\n        if (aOriginal && typeof aOriginal.line !== \"number\" && typeof aOriginal.column !== \"number\") {\n            throw new Error(\"original.line and original.column are not numbers -- you probably meant to omit \" + \"the original mapping entirely and only map the generated position. If so, pass \" + \"null for the original mapping instead of an object with empty or null values.\");\n        }\n        if (aGenerated && \"line\" in aGenerated && \"column\" in aGenerated && aGenerated.line > 0 && aGenerated.column >= 0 && !aOriginal && !aSource && !aName) ; else if (aGenerated && \"line\" in aGenerated && \"column\" in aGenerated && aOriginal && \"line\" in aOriginal && \"column\" in aOriginal && aGenerated.line > 0 && aGenerated.column >= 0 && aOriginal.line > 0 && aOriginal.column >= 0 && aSource) ; else {\n            throw new Error(\"Invalid mapping: \" + JSON.stringify({\n                generated: aGenerated,\n                source: aSource,\n                original: aOriginal,\n                name: aName\n            }));\n        }\n    };\n    /**\n   * Serialize the accumulated mappings in to the stream of base 64 VLQs\n   * specified by the source map format.\n   */ _proto._serializeMappings = function _serializeMappings() {\n        var previousGeneratedColumn = 0;\n        var previousGeneratedLine = 1;\n        var previousOriginalColumn = 0;\n        var previousOriginalLine = 0;\n        var previousName = 0;\n        var previousSource = 0;\n        var result = \"\";\n        var next;\n        var mapping;\n        var nameIdx;\n        var sourceIdx;\n        var mappings = this._mappings.toArray();\n        for(var i = 0, len = mappings.length; i < len; i++){\n            mapping = mappings[i];\n            next = \"\";\n            if (mapping.generatedLine !== previousGeneratedLine) {\n                previousGeneratedColumn = 0;\n                while(mapping.generatedLine !== previousGeneratedLine){\n                    next += \";\";\n                    previousGeneratedLine++;\n                }\n            } else if (i > 0) {\n                if (!util$1.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {\n                    continue;\n                }\n                next += \",\";\n            }\n            next += base64VLQ.encode(mapping.generatedColumn - previousGeneratedColumn);\n            previousGeneratedColumn = mapping.generatedColumn;\n            if (mapping.source != null) {\n                sourceIdx = this._sources.indexOf(mapping.source);\n                next += base64VLQ.encode(sourceIdx - previousSource);\n                previousSource = sourceIdx;\n                // lines are stored 0-based in SourceMap spec version 3\n                next += base64VLQ.encode(mapping.originalLine - 1 - previousOriginalLine);\n                previousOriginalLine = mapping.originalLine - 1;\n                next += base64VLQ.encode(mapping.originalColumn - previousOriginalColumn);\n                previousOriginalColumn = mapping.originalColumn;\n                if (mapping.name != null) {\n                    nameIdx = this._names.indexOf(mapping.name);\n                    next += base64VLQ.encode(nameIdx - previousName);\n                    previousName = nameIdx;\n                }\n            }\n            result += next;\n        }\n        return result;\n    };\n    _proto._generateSourcesContent = function _generateSourcesContent(aSources, aSourceRoot) {\n        return aSources.map(function(source) {\n            if (!this._sourcesContents) {\n                return null;\n            }\n            if (aSourceRoot != null) {\n                source = util$1.relative(aSourceRoot, source);\n            }\n            var key = util$1.toSetString(source);\n            return Object.prototype.hasOwnProperty.call(this._sourcesContents, key) ? this._sourcesContents[key] : null;\n        }, this);\n    };\n    /**\n   * Externalize the source map.\n   */ _proto.toJSON = function toJSON() {\n        var map = {\n            version: this._version,\n            sources: this._sources.toArray(),\n            names: this._names.toArray(),\n            mappings: this._serializeMappings()\n        };\n        if (this._file != null) {\n            map.file = this._file;\n        }\n        if (this._sourceRoot != null) {\n            map.sourceRoot = this._sourceRoot;\n        }\n        if (this._sourcesContents) {\n            map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);\n        }\n        return map;\n    };\n    /**\n   * Render the source map being generated to a string.\n   */ _proto.toString = function toString() {\n        return JSON.stringify(this.toJSON());\n    };\n    /**\n   * Creates a new SourceMapGenerator based on a SourceMapConsumer\n   *\n   * @param aSourceMapConsumer The SourceMap.\n   */ SourceMapGenerator.fromSourceMap = function fromSourceMap(aSourceMapConsumer) {\n        var sourceRoot = aSourceMapConsumer.sourceRoot;\n        var generator = new SourceMapGenerator({\n            file: aSourceMapConsumer.file,\n            sourceRoot: sourceRoot\n        });\n        aSourceMapConsumer.eachMapping(function(mapping) {\n            var newMapping = {\n                generated: {\n                    line: mapping.generatedLine,\n                    column: mapping.generatedColumn\n                }\n            };\n            if (mapping.source != null) {\n                newMapping.source = mapping.source;\n                if (sourceRoot != null) {\n                    newMapping.source = util$1.relative(sourceRoot, newMapping.source);\n                }\n                newMapping.original = {\n                    line: mapping.originalLine,\n                    column: mapping.originalColumn\n                };\n                if (mapping.name != null) {\n                    newMapping.name = mapping.name;\n                }\n            }\n            generator.addMapping(newMapping);\n        });\n        aSourceMapConsumer.sources.forEach(function(sourceFile) {\n            var sourceRelative = sourceFile;\n            if (sourceRoot !== null) {\n                sourceRelative = util$1.relative(sourceRoot, sourceFile);\n            }\n            if (!generator._sources.has(sourceRelative)) {\n                generator._sources.add(sourceRelative);\n            }\n            var content = aSourceMapConsumer.sourceContentFor(sourceFile);\n            if (content != null) {\n                generator.setSourceContent(sourceFile, content);\n            }\n        });\n        return generator;\n    };\n    return SourceMapGenerator;\n}();\nSourceMapGenerator$1.prototype._version = 3;\nsourceMapGenerator.SourceMapGenerator = SourceMapGenerator$1;\n\nvar binarySearch$1 = {};\n\n(function(exports) {\n    /*\n\t * Copyright 2011 Mozilla Foundation and contributors\n\t * Licensed under the New BSD license. See LICENSE or:\n\t * http://opensource.org/licenses/BSD-3-Clause\n\t */ exports.GREATEST_LOWER_BOUND = 1;\n    exports.LEAST_UPPER_BOUND = 2;\n    /**\n\t * Recursive implementation of binary search.\n\t *\n\t * @param aLow Indices here and lower do not contain the needle.\n\t * @param aHigh Indices here and higher do not contain the needle.\n\t * @param aNeedle The element being searched for.\n\t * @param aHaystack The non-empty array being searched.\n\t * @param aCompare Function which takes two elements and returns -1, 0, or 1.\n\t * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or\n\t *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the\n\t *     closest element that is smaller than or greater than the one we are\n\t *     searching for, respectively, if the exact element cannot be found.\n\t */ function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {\n        // This function terminates when one of the following is true:\n        //\n        //   1. We find the exact element we are looking for.\n        //\n        //   2. We did not find the exact element, but we can return the index of\n        //      the next-closest element.\n        //\n        //   3. We did not find the exact element, and there is no next-closest\n        //      element than the one we are searching for, so we return -1.\n        var mid = Math.floor((aHigh - aLow) / 2) + aLow;\n        var cmp = aCompare(aNeedle, aHaystack[mid], true);\n        if (cmp === 0) {\n            // Found the element we are looking for.\n            return mid;\n        } else if (cmp > 0) {\n            // Our needle is greater than aHaystack[mid].\n            if (aHigh - mid > 1) {\n                // The element is in the upper half.\n                return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);\n            }\n            // The exact needle element was not found in this haystack. Determine if\n            // we are in termination case (3) or (2) and return the appropriate thing.\n            if (aBias == exports.LEAST_UPPER_BOUND) {\n                return aHigh < aHaystack.length ? aHigh : -1;\n            }\n            return mid;\n        }\n        // Our needle is less than aHaystack[mid].\n        if (mid - aLow > 1) {\n            // The element is in the lower half.\n            return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);\n        }\n        // we are in termination case (3) or (2) and return the appropriate thing.\n        if (aBias == exports.LEAST_UPPER_BOUND) {\n            return mid;\n        }\n        return aLow < 0 ? -1 : aLow;\n    }\n    /**\n\t * This is an implementation of binary search which will always try and return\n\t * the index of the closest element if there is no exact hit. This is because\n\t * mappings between original and generated line/col pairs are single points,\n\t * and there is an implicit region between each of them, so a miss just means\n\t * that you aren't on the very start of a region.\n\t *\n\t * @param aNeedle The element you are looking for.\n\t * @param aHaystack The array that is being searched.\n\t * @param aCompare A function which takes the needle and an element in the\n\t *     array and returns -1, 0, or 1 depending on whether the needle is less\n\t *     than, equal to, or greater than the element, respectively.\n\t * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or\n\t *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the\n\t *     closest element that is smaller than or greater than the one we are\n\t *     searching for, respectively, if the exact element cannot be found.\n\t *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.\n\t */ exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {\n        if (aHaystack.length === 0) {\n            return -1;\n        }\n        var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack, aCompare, aBias || exports.GREATEST_LOWER_BOUND);\n        if (index < 0) {\n            return -1;\n        }\n        // We have found either the exact element, or the next-closest element than\n        // the one we are searching for. However, there may be more than one such\n        // element. Make sure we always return the smallest of these.\n        while(index - 1 >= 0){\n            if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {\n                break;\n            }\n            --index;\n        }\n        return index;\n    };\n})(binarySearch$1);\n\nvar readWasm$2 = {exports: {}};\n\nif (typeof fetch === \"function\") {\n    // Web version of reading a wasm file into an array buffer.\n    var mappingsWasmUrl = null;\n    readWasm$2.exports = function readWasm() {\n        if (typeof mappingsWasmUrl !== \"string\") {\n            throw new Error(\"You must provide the URL of lib/mappings.wasm by calling \" + \"SourceMapConsumer.initialize({ 'lib/mappings.wasm': ... }) \" + \"before using SourceMapConsumer\");\n        }\n        return fetch(mappingsWasmUrl).then(function(response) {\n            return response.arrayBuffer();\n        });\n    };\n    readWasm$2.exports.initialize = function(url) {\n        return mappingsWasmUrl = url;\n    };\n} else {\n    // Node version of reading a wasm file into an array buffer.\n    var fs = require$$0__default[\"default\"];\n    var path = require$$1__default[\"default\"];\n    readWasm$2.exports = function readWasm() {\n        return new Promise(function(resolve, reject) {\n            var wasmPath = path.join(__dirname, \"mappings.wasm\");\n            fs.readFile(wasmPath, null, function(error, data) {\n                if (error) {\n                    reject(error);\n                    return;\n                }\n                resolve(data.buffer);\n            });\n        });\n    };\n    readWasm$2.exports.initialize = function(_) {\n        console.debug(\"SourceMapConsumer.initialize is a no-op when running in node.js\");\n    };\n}\n\nvar readWasm$1 = readWasm$2.exports;\n/**\n * Provide the JIT with a nice shape / hidden class.\n */ function Mapping() {\n    this.generatedLine = 0;\n    this.generatedColumn = 0;\n    this.lastGeneratedColumn = null;\n    this.source = null;\n    this.originalLine = null;\n    this.originalColumn = null;\n    this.name = null;\n}\nvar cachedWasm = null;\nvar wasm$1 = function wasm() {\n    if (cachedWasm) {\n        return cachedWasm;\n    }\n    var callbackStack = [];\n    cachedWasm = readWasm$1().then(function(buffer) {\n        return WebAssembly.instantiate(buffer, {\n            env: {\n                mapping_callback: function mapping_callback(generatedLine, generatedColumn, hasLastGeneratedColumn, lastGeneratedColumn, hasOriginal, source, originalLine, originalColumn, hasName, name) {\n                    var mapping = new Mapping();\n                    // JS uses 1-based line numbers, wasm uses 0-based.\n                    mapping.generatedLine = generatedLine + 1;\n                    mapping.generatedColumn = generatedColumn;\n                    if (hasLastGeneratedColumn) {\n                        // JS uses inclusive last generated column, wasm uses exclusive.\n                        mapping.lastGeneratedColumn = lastGeneratedColumn - 1;\n                    }\n                    if (hasOriginal) {\n                        mapping.source = source;\n                        // JS uses 1-based line numbers, wasm uses 0-based.\n                        mapping.originalLine = originalLine + 1;\n                        mapping.originalColumn = originalColumn;\n                        if (hasName) {\n                            mapping.name = name;\n                        }\n                    }\n                    callbackStack[callbackStack.length - 1](mapping);\n                },\n                start_all_generated_locations_for: function start_all_generated_locations_for() {\n                    console.time(\"all_generated_locations_for\");\n                },\n                end_all_generated_locations_for: function end_all_generated_locations_for() {\n                    console.timeEnd(\"all_generated_locations_for\");\n                },\n                start_compute_column_spans: function start_compute_column_spans() {\n                    console.time(\"compute_column_spans\");\n                },\n                end_compute_column_spans: function end_compute_column_spans() {\n                    console.timeEnd(\"compute_column_spans\");\n                },\n                start_generated_location_for: function start_generated_location_for() {\n                    console.time(\"generated_location_for\");\n                },\n                end_generated_location_for: function end_generated_location_for() {\n                    console.timeEnd(\"generated_location_for\");\n                },\n                start_original_location_for: function start_original_location_for() {\n                    console.time(\"original_location_for\");\n                },\n                end_original_location_for: function end_original_location_for() {\n                    console.timeEnd(\"original_location_for\");\n                },\n                start_parse_mappings: function start_parse_mappings() {\n                    console.time(\"parse_mappings\");\n                },\n                end_parse_mappings: function end_parse_mappings() {\n                    console.timeEnd(\"parse_mappings\");\n                },\n                start_sort_by_generated_location: function start_sort_by_generated_location() {\n                    console.time(\"sort_by_generated_location\");\n                },\n                end_sort_by_generated_location: function end_sort_by_generated_location() {\n                    console.timeEnd(\"sort_by_generated_location\");\n                },\n                start_sort_by_original_location: function start_sort_by_original_location() {\n                    console.time(\"sort_by_original_location\");\n                },\n                end_sort_by_original_location: function end_sort_by_original_location() {\n                    console.timeEnd(\"sort_by_original_location\");\n                }\n            }\n        });\n    }).then(function(Wasm) {\n        return {\n            exports: Wasm.instance.exports,\n            withMappingCallback: function(mappingCallback, f) {\n                callbackStack.push(mappingCallback);\n                try {\n                    f();\n                } finally{\n                    callbackStack.pop();\n                }\n            }\n        };\n    }).then(null, function(e) {\n        cachedWasm = null;\n        throw e;\n    });\n    return cachedWasm;\n};\n\n/* -*- Mode: js; js-indent-level: 2; -*- */ function _assertThisInitialized(self) {\n    if (self === void 0) {\n        throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n    return self;\n}\nfunction _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n    }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    return Constructor;\n}\nfunction _inherits(subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n        throw new TypeError(\"Super expression must either be null or a function\");\n    }\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n        constructor: {\n            value: subClass,\n            writable: true,\n            configurable: true\n        }\n    });\n    if (superClass) _setPrototypeOf(subClass, superClass);\n}\nfunction _possibleConstructorReturn(self, call) {\n    if (call && (_typeof$1(call) === \"object\" || typeof call === \"function\")) {\n        return call;\n    }\n    return _assertThisInitialized(self);\n}\nfunction _setPrototypeOf(o, p) {\n    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n        o.__proto__ = p;\n        return o;\n    };\n    return _setPrototypeOf(o, p);\n}\nvar _typeof$1 = function(obj) {\n    \"@swc/helpers - typeof\";\n    return obj && typeof Symbol !== \"undefined\" && obj.constructor === Symbol ? \"symbol\" : typeof obj;\n};\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */ var util = util$3;\nvar binarySearch = binarySearch$1;\nvar ArraySet = arraySet.ArraySet;\nvar readWasm = readWasm$2.exports;\nvar wasm = wasm$1;\nvar INTERNAL = Symbol(\"smcInternal\");\nvar SourceMapConsumer = /*#__PURE__*/ function() {\n    function SourceMapConsumer(aSourceMap, aSourceMapURL) {\n        // If the constructor was called by super(), just return Promise<this>.\n        // Yes, this is a hack to retain the pre-existing API of the base-class\n        // constructor also being an async factory function.\n        if (aSourceMap == INTERNAL) {\n            return Promise.resolve(this);\n        }\n        return _factory(aSourceMap, aSourceMapURL);\n    }\n    var _proto = SourceMapConsumer.prototype;\n    /**\n   * Parse the mappings in a string in to a data structure which we can easily\n   * query (the ordered arrays in the `this.__generatedMappings` and\n   * `this.__originalMappings` properties).\n   */ _proto._parseMappings = function _parseMappings(aStr, aSourceRoot) {\n        throw new Error(\"Subclasses must implement _parseMappings\");\n    };\n    /**\n   * Iterate over each mapping between an original source/line/column and a\n   * generated line/column in this source map.\n   *\n   * @param Function aCallback\n   *        The function that is called with each mapping.\n   * @param Object aContext\n   *        Optional. If specified, this object will be the value of `this` every\n   *        time that `aCallback` is called.\n   * @param aOrder\n   *        Either `SourceMapConsumer.GENERATED_ORDER` or\n   *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to\n   *        iterate over the mappings sorted by the generated file's line/column\n   *        order or the original's source/line/column order, respectively. Defaults to\n   *        `SourceMapConsumer.GENERATED_ORDER`.\n   */ _proto.eachMapping = function eachMapping(aCallback, aContext, aOrder) {\n        throw new Error(\"Subclasses must implement eachMapping\");\n    };\n    /**\n   * Returns all generated line and column information for the original source,\n   * line, and column provided. If no column is provided, returns all mappings\n   * corresponding to a either the line we are searching for or the next\n   * closest line that has any mappings. Otherwise, returns all mappings\n   * corresponding to the given line and either the column we are searching for\n   * or the next closest column that has any offsets.\n   *\n   * The only argument is an object with the following properties:\n   *\n   *   - source: The filename of the original source.\n   *   - line: The line number in the original source.  The line number is 1-based.\n   *   - column: Optional. the column number in the original source.\n   *    The column number is 0-based.\n   *\n   * and an array of objects is returned, each with the following properties:\n   *\n   *   - line: The line number in the generated source, or null.  The\n   *    line number is 1-based.\n   *   - column: The column number in the generated source, or null.\n   *    The column number is 0-based.\n   */ _proto.allGeneratedPositionsFor = function allGeneratedPositionsFor(aArgs) {\n        throw new Error(\"Subclasses must implement allGeneratedPositionsFor\");\n    };\n    _proto.destroy = function destroy() {\n        throw new Error(\"Subclasses must implement destroy\");\n    };\n    SourceMapConsumer.initialize = function initialize(opts) {\n        readWasm.initialize(opts[\"lib/mappings.wasm\"]);\n    };\n    SourceMapConsumer.fromSourceMap = function fromSourceMap(aSourceMap, aSourceMapURL) {\n        return _factoryBSM(aSourceMap, aSourceMapURL);\n    };\n    /**\n   * Construct a new `SourceMapConsumer` from `rawSourceMap` and `sourceMapUrl`\n   * (see the `SourceMapConsumer` constructor for details. Then, invoke the `async\n   * function f(SourceMapConsumer) -> T` with the newly constructed consumer, wait\n   * for `f` to complete, call `destroy` on the consumer, and return `f`'s return\n   * value.\n   *\n   * You must not use the consumer after `f` completes!\n   *\n   * By using `with`, you do not have to remember to manually call `destroy` on\n   * the consumer, since it will be called automatically once `f` completes.\n   *\n   * ```js\n   * const xSquared = await SourceMapConsumer.with(\n   *   myRawSourceMap,\n   *   null,\n   *   async function (consumer) {\n   *     // Use `consumer` inside here and don't worry about remembering\n   *     // to call `destroy`.\n   *\n   *     const x = await whatever(consumer);\n   *     return x * x;\n   *   }\n   * );\n   *\n   * // You may not use that `consumer` anymore out here; it has\n   * // been destroyed. But you can use `xSquared`.\n   * console.log(xSquared);\n   * ```\n   */ SourceMapConsumer.with = function _with(rawSourceMap, sourceMapUrl, f) {\n        // Note: The `acorn` version that `webpack` currently depends on doesn't\n        // support `async` functions, and the nodes that we support don't all have\n        // `.finally`. Therefore, this is written a bit more convolutedly than it\n        // should really be.\n        var consumer = null;\n        var promise = new SourceMapConsumer(rawSourceMap, sourceMapUrl);\n        return promise.then(function(c) {\n            consumer = c;\n            return f(c);\n        }).then(function(x) {\n            if (consumer) {\n                consumer.destroy();\n            }\n            return x;\n        }, function(e) {\n            if (consumer) {\n                consumer.destroy();\n            }\n            throw e;\n        });\n    };\n    return SourceMapConsumer;\n}();\n/**\n * The version of the source mapping spec that we are consuming.\n */ SourceMapConsumer.prototype._version = 3;\nSourceMapConsumer.GENERATED_ORDER = 1;\nSourceMapConsumer.ORIGINAL_ORDER = 2;\nSourceMapConsumer.GREATEST_LOWER_BOUND = 1;\nSourceMapConsumer.LEAST_UPPER_BOUND = 2;\n/**\n * A BasicSourceMapConsumer instance represents a parsed source map which we can\n * query for information about the original file positions by giving it a file\n * position in the generated source.\n *\n * The first parameter is the raw source map (either as a JSON string, or\n * already parsed to an object). According to the spec, source maps have the\n * following attributes:\n *\n *   - version: Which version of the source map spec this map is following.\n *   - sources: An array of URLs to the original source files.\n *   - names: An array of identifiers which can be referenced by individual mappings.\n *   - sourceRoot: Optional. The URL root from which all sources are relative.\n *   - sourcesContent: Optional. An array of contents of the original source files.\n *   - mappings: A string of base64 VLQs which contain the actual mappings.\n *   - file: Optional. The generated file this source map is associated with.\n *\n * Here is an example source map, taken from the source map spec[0]:\n *\n *     {\n *       version : 3,\n *       file: \"out.js\",\n *       sourceRoot : \"\",\n *       sources: [\"foo.js\", \"bar.js\"],\n *       names: [\"src\", \"maps\", \"are\", \"fun\"],\n *       mappings: \"AA,AB;;ABCDE;\"\n *     }\n *\n * The second parameter, if given, is a string whose value is the URL\n * at which the source map was found.  This URL is used to compute the\n * sources array.\n *\n * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#\n */ var BasicSourceMapConsumer = /*#__PURE__*/ function(SourceMapConsumer1) {\n    _inherits(BasicSourceMapConsumer, SourceMapConsumer1);\n    function BasicSourceMapConsumer(aSourceMap, aSourceMapURL) {\n        var _this;\n        return _possibleConstructorReturn(_this, (_this = SourceMapConsumer1.call(this, INTERNAL) || this).then(function(that) {\n            var sourceMap = aSourceMap;\n            if (typeof aSourceMap === \"string\") {\n                sourceMap = util.parseSourceMapInput(aSourceMap);\n            }\n            var version = util.getArg(sourceMap, \"version\");\n            var sources = util.getArg(sourceMap, \"sources\");\n            // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which\n            // requires the array) to play nice here.\n            var names = util.getArg(sourceMap, \"names\", []);\n            var sourceRoot = util.getArg(sourceMap, \"sourceRoot\", null);\n            var sourcesContent = util.getArg(sourceMap, \"sourcesContent\", null);\n            var mappings = util.getArg(sourceMap, \"mappings\");\n            var file = util.getArg(sourceMap, \"file\", null);\n            // Once again, Sass deviates from the spec and supplies the version as a\n            // string rather than a number, so we use loose equality checking here.\n            if (version != that._version) {\n                throw new Error(\"Unsupported version: \" + version);\n            }\n            if (sourceRoot) {\n                sourceRoot = util.normalize(sourceRoot);\n            }\n            sources = sources.map(String)// Some source maps produce relative source paths like \"./foo.js\" instead of\n            // \"foo.js\".  Normalize these first so that future comparisons will succeed.\n            // See bugzil.la/1090768.\n            .map(util.normalize)// Always ensure that absolute sources are internally stored relative to\n            // the source root, if the source root is absolute. Not doing this would\n            // be particularly problematic when the source root is a prefix of the\n            // source (valid, but why??). See github issue #199 and bugzil.la/1188982.\n            .map(function(source) {\n                return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source) ? util.relative(sourceRoot, source) : source;\n            });\n            // Pass `true` below to allow duplicate names and sources. While source maps\n            // are intended to be compressed and deduplicated, the TypeScript compiler\n            // sometimes generates source maps with duplicates in them. See Github issue\n            // #72 and bugzil.la/889492.\n            that._names = ArraySet.fromArray(names.map(String), true);\n            that._sources = ArraySet.fromArray(sources, true);\n            that._absoluteSources = that._sources.toArray().map(function(s) {\n                return util.computeSourceURL(sourceRoot, s, aSourceMapURL);\n            });\n            that.sourceRoot = sourceRoot;\n            that.sourcesContent = sourcesContent;\n            that._mappings = mappings;\n            that._sourceMapURL = aSourceMapURL;\n            that.file = file;\n            that._computedColumnSpans = false;\n            that._mappingsPtr = 0;\n            that._wasm = null;\n            return wasm().then(function(w) {\n                that._wasm = w;\n                return that;\n            });\n        }));\n    }\n    var _proto = BasicSourceMapConsumer.prototype;\n    /**\n   * Utility function to find the index of a source.  Returns -1 if not\n   * found.\n   */ _proto._findSourceIndex = function _findSourceIndex(aSource) {\n        var relativeSource = aSource;\n        if (this.sourceRoot != null) {\n            relativeSource = util.relative(this.sourceRoot, relativeSource);\n        }\n        if (this._sources.has(relativeSource)) {\n            return this._sources.indexOf(relativeSource);\n        }\n        // Maybe aSource is an absolute URL as returned by |sources|.  In\n        // this case we can't simply undo the transform.\n        for(var i = 0; i < this._absoluteSources.length; ++i){\n            if (this._absoluteSources[i] == aSource) {\n                return i;\n            }\n        }\n        return -1;\n    };\n    _proto._getMappingsPtr = function _getMappingsPtr() {\n        if (this._mappingsPtr === 0) {\n            this._parseMappings(this._mappings, this.sourceRoot);\n        }\n        return this._mappingsPtr;\n    };\n    /**\n   * Parse the mappings in a string in to a data structure which we can easily\n   * query (the ordered arrays in the `this.__generatedMappings` and\n   * `this.__originalMappings` properties).\n   */ _proto._parseMappings = function _parseMappings(aStr, aSourceRoot) {\n        var size = aStr.length;\n        var mappingsBufPtr = this._wasm.exports.allocate_mappings(size);\n        var mappingsBuf = new Uint8Array(this._wasm.exports.memory.buffer, mappingsBufPtr, size);\n        for(var i = 0; i < size; i++){\n            mappingsBuf[i] = aStr.charCodeAt(i);\n        }\n        var mappingsPtr = this._wasm.exports.parse_mappings(mappingsBufPtr);\n        if (!mappingsPtr) {\n            var error = this._wasm.exports.get_last_error();\n            var msg = \"Error parsing mappings (code \" + error + \"): \";\n            // XXX: keep these error codes in sync with `fitzgen/source-map-mappings`.\n            switch(error){\n                case 1:\n                    msg += \"the mappings contained a negative line, column, source index, or name index\";\n                    break;\n                case 2:\n                    msg += \"the mappings contained a number larger than 2**32\";\n                    break;\n                case 3:\n                    msg += \"reached EOF while in the middle of parsing a VLQ\";\n                    break;\n                case 4:\n                    msg += \"invalid base 64 character while parsing a VLQ\";\n                    break;\n                default:\n                    msg += \"unknown error code\";\n                    break;\n            }\n            throw new Error(msg);\n        }\n        this._mappingsPtr = mappingsPtr;\n    };\n    _proto.eachMapping = function eachMapping(aCallback, aContext, aOrder) {\n        var _this = this;\n        var context = aContext || null;\n        var order = aOrder || SourceMapConsumer.GENERATED_ORDER;\n        var sourceRoot = this.sourceRoot;\n        this._wasm.withMappingCallback(function(mapping) {\n            if (mapping.source !== null) {\n                mapping.source = _this._sources.at(mapping.source);\n                mapping.source = util.computeSourceURL(sourceRoot, mapping.source, _this._sourceMapURL);\n                if (mapping.name !== null) {\n                    mapping.name = _this._names.at(mapping.name);\n                }\n            }\n            aCallback.call(context, mapping);\n        }, function() {\n            switch(order){\n                case SourceMapConsumer.GENERATED_ORDER:\n                    _this._wasm.exports.by_generated_location(_this._getMappingsPtr());\n                    break;\n                case SourceMapConsumer.ORIGINAL_ORDER:\n                    _this._wasm.exports.by_original_location(_this._getMappingsPtr());\n                    break;\n                default:\n                    throw new Error(\"Unknown order of iteration.\");\n            }\n        });\n    };\n    _proto.allGeneratedPositionsFor = function allGeneratedPositionsFor(aArgs) {\n        var _this = this;\n        var source = util.getArg(aArgs, \"source\");\n        var originalLine = util.getArg(aArgs, \"line\");\n        var originalColumn = aArgs.column || 0;\n        source = this._findSourceIndex(source);\n        if (source < 0) {\n            return [];\n        }\n        if (originalLine < 1) {\n            throw new Error(\"Line numbers must be >= 1\");\n        }\n        if (originalColumn < 0) {\n            throw new Error(\"Column numbers must be >= 0\");\n        }\n        var mappings = [];\n        this._wasm.withMappingCallback(function(m) {\n            var lastColumn = m.lastGeneratedColumn;\n            if (_this._computedColumnSpans && lastColumn === null) {\n                lastColumn = Infinity;\n            }\n            mappings.push({\n                line: m.generatedLine,\n                column: m.generatedColumn,\n                lastColumn: lastColumn\n            });\n        }, function() {\n            _this._wasm.exports.all_generated_locations_for(_this._getMappingsPtr(), source, originalLine - 1, \"column\" in aArgs, originalColumn);\n        });\n        return mappings;\n    };\n    _proto.destroy = function destroy() {\n        if (this._mappingsPtr !== 0) {\n            this._wasm.exports.free_mappings(this._mappingsPtr);\n            this._mappingsPtr = 0;\n        }\n    };\n    /**\n   * Compute the last column for each generated mapping. The last column is\n   * inclusive.\n   */ _proto.computeColumnSpans = function computeColumnSpans() {\n        if (this._computedColumnSpans) {\n            return;\n        }\n        this._wasm.exports.compute_column_spans(this._getMappingsPtr());\n        this._computedColumnSpans = true;\n    };\n    /**\n   * Returns the original source, line, and column information for the generated\n   * source's line and column positions provided. The only argument is an object\n   * with the following properties:\n   *\n   *   - line: The line number in the generated source.  The line number\n   *     is 1-based.\n   *   - column: The column number in the generated source.  The column\n   *     number is 0-based.\n   *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or\n   *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the\n   *     closest element that is smaller than or greater than the one we are\n   *     searching for, respectively, if the exact element cannot be found.\n   *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.\n   *\n   * and an object is returned with the following properties:\n   *\n   *   - source: The original source file, or null.\n   *   - line: The line number in the original source, or null.  The\n   *     line number is 1-based.\n   *   - column: The column number in the original source, or null.  The\n   *     column number is 0-based.\n   *   - name: The original identifier, or null.\n   */ _proto.originalPositionFor = function originalPositionFor(aArgs) {\n        var _this = this;\n        var needle = {\n            generatedLine: util.getArg(aArgs, \"line\"),\n            generatedColumn: util.getArg(aArgs, \"column\")\n        };\n        if (needle.generatedLine < 1) {\n            throw new Error(\"Line numbers must be >= 1\");\n        }\n        if (needle.generatedColumn < 0) {\n            throw new Error(\"Column numbers must be >= 0\");\n        }\n        var bias = util.getArg(aArgs, \"bias\", SourceMapConsumer.GREATEST_LOWER_BOUND);\n        if (bias == null) {\n            bias = SourceMapConsumer.GREATEST_LOWER_BOUND;\n        }\n        var mapping;\n        this._wasm.withMappingCallback(function(m) {\n            return mapping = m;\n        }, function() {\n            _this._wasm.exports.original_location_for(_this._getMappingsPtr(), needle.generatedLine - 1, needle.generatedColumn, bias);\n        });\n        if (mapping) {\n            if (mapping.generatedLine === needle.generatedLine) {\n                var source = util.getArg(mapping, \"source\", null);\n                if (source !== null) {\n                    source = this._sources.at(source);\n                    source = util.computeSourceURL(this.sourceRoot, source, this._sourceMapURL);\n                }\n                var name = util.getArg(mapping, \"name\", null);\n                if (name !== null) {\n                    name = this._names.at(name);\n                }\n                return {\n                    source: source,\n                    line: util.getArg(mapping, \"originalLine\", null),\n                    column: util.getArg(mapping, \"originalColumn\", null),\n                    name: name\n                };\n            }\n        }\n        return {\n            source: null,\n            line: null,\n            column: null,\n            name: null\n        };\n    };\n    /**\n   * Return true if we have the source content for every source in the source\n   * map, false otherwise.\n   */ _proto.hasContentsOfAllSources = function hasContentsOfAllSources() {\n        if (!this.sourcesContent) {\n            return false;\n        }\n        return this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function(sc) {\n            return sc == null;\n        });\n    };\n    /**\n   * Returns the original source content. The only argument is the url of the\n   * original source file. Returns null if no original source content is\n   * available.\n   */ _proto.sourceContentFor = function sourceContentFor(aSource, nullOnMissing) {\n        if (!this.sourcesContent) {\n            return null;\n        }\n        var index = this._findSourceIndex(aSource);\n        if (index >= 0) {\n            return this.sourcesContent[index];\n        }\n        var relativeSource = aSource;\n        if (this.sourceRoot != null) {\n            relativeSource = util.relative(this.sourceRoot, relativeSource);\n        }\n        var url;\n        if (this.sourceRoot != null && (url = util.urlParse(this.sourceRoot))) {\n            // XXX: file:// URIs and absolute paths lead to unexpected behavior for\n            // many users. We can help them out when they expect file:// URIs to\n            // behave like it would if they were running a local HTTP server. See\n            // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.\n            var fileUriAbsPath = relativeSource.replace(/^file:\\/\\//, \"\");\n            if (url.scheme == \"file\" && this._sources.has(fileUriAbsPath)) {\n                return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];\n            }\n            if ((!url.path || url.path == \"/\") && this._sources.has(\"/\" + relativeSource)) {\n                return this.sourcesContent[this._sources.indexOf(\"/\" + relativeSource)];\n            }\n        }\n        // This function is used recursively from\n        // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we\n        // don't want to throw if we can't find the source - we just want to\n        // return null, so we provide a flag to exit gracefully.\n        if (nullOnMissing) {\n            return null;\n        }\n        throw new Error('\"' + relativeSource + '\" is not in the SourceMap.');\n    };\n    /**\n   * Returns the generated line and column information for the original source,\n   * line, and column positions provided. The only argument is an object with\n   * the following properties:\n   *\n   *   - source: The filename of the original source.\n   *   - line: The line number in the original source.  The line number\n   *     is 1-based.\n   *   - column: The column number in the original source.  The column\n   *     number is 0-based.\n   *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or\n   *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the\n   *     closest element that is smaller than or greater than the one we are\n   *     searching for, respectively, if the exact element cannot be found.\n   *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.\n   *\n   * and an object is returned with the following properties:\n   *\n   *   - line: The line number in the generated source, or null.  The\n   *     line number is 1-based.\n   *   - column: The column number in the generated source, or null.\n   *     The column number is 0-based.\n   */ _proto.generatedPositionFor = function generatedPositionFor(aArgs) {\n        var _this = this;\n        var source = util.getArg(aArgs, \"source\");\n        source = this._findSourceIndex(source);\n        if (source < 0) {\n            return {\n                line: null,\n                column: null,\n                lastColumn: null\n            };\n        }\n        var needle = {\n            source: source,\n            originalLine: util.getArg(aArgs, \"line\"),\n            originalColumn: util.getArg(aArgs, \"column\")\n        };\n        if (needle.originalLine < 1) {\n            throw new Error(\"Line numbers must be >= 1\");\n        }\n        if (needle.originalColumn < 0) {\n            throw new Error(\"Column numbers must be >= 0\");\n        }\n        var bias = util.getArg(aArgs, \"bias\", SourceMapConsumer.GREATEST_LOWER_BOUND);\n        if (bias == null) {\n            bias = SourceMapConsumer.GREATEST_LOWER_BOUND;\n        }\n        var mapping;\n        this._wasm.withMappingCallback(function(m) {\n            return mapping = m;\n        }, function() {\n            _this._wasm.exports.generated_location_for(_this._getMappingsPtr(), needle.source, needle.originalLine - 1, needle.originalColumn, bias);\n        });\n        if (mapping) {\n            if (mapping.source === needle.source) {\n                var lastColumn = mapping.lastGeneratedColumn;\n                if (this._computedColumnSpans && lastColumn === null) {\n                    lastColumn = Infinity;\n                }\n                return {\n                    line: util.getArg(mapping, \"generatedLine\", null),\n                    column: util.getArg(mapping, \"generatedColumn\", null),\n                    lastColumn: lastColumn\n                };\n            }\n        }\n        return {\n            line: null,\n            column: null,\n            lastColumn: null\n        };\n    };\n    /**\n   * Create a BasicSourceMapConsumer from a SourceMapGenerator.\n   *\n   * @param SourceMapGenerator aSourceMap\n   *        The source map that will be consumed.\n   * @param String aSourceMapURL\n   *        The URL at which the source map can be found (optional)\n   * @returns BasicSourceMapConsumer\n   */ BasicSourceMapConsumer.fromSourceMap = function fromSourceMap(aSourceMap, aSourceMapURL) {\n        return new BasicSourceMapConsumer(aSourceMap.toString());\n    };\n    _createClass(BasicSourceMapConsumer, [\n        {\n            key: \"sources\",\n            get: function get() {\n                return this._absoluteSources.slice();\n            }\n        }\n    ]);\n    return BasicSourceMapConsumer;\n}(SourceMapConsumer);\nBasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;\n/**\n * An IndexedSourceMapConsumer instance represents a parsed source map which\n * we can query for information. It differs from BasicSourceMapConsumer in\n * that it takes \"indexed\" source maps (i.e. ones with a \"sections\" field) as\n * input.\n *\n * The first parameter is a raw source map (either as a JSON string, or already\n * parsed to an object). According to the spec for indexed source maps, they\n * have the following attributes:\n *\n *   - version: Which version of the source map spec this map is following.\n *   - file: Optional. The generated file this source map is associated with.\n *   - sections: A list of section definitions.\n *\n * Each value under the \"sections\" field has two fields:\n *   - offset: The offset into the original specified at which this section\n *       begins to apply, defined as an object with a \"line\" and \"column\"\n *       field.\n *   - map: A source map definition. This source map could also be indexed,\n *       but doesn't have to be.\n *\n * Instead of the \"map\" field, it's also possible to have a \"url\" field\n * specifying a URL to retrieve a source map from, but that's currently\n * unsupported.\n *\n * Here's an example source map, taken from the source map spec[0], but\n * modified to omit a section which uses the \"url\" field.\n *\n *  {\n *    version : 3,\n *    file: \"app.js\",\n *    sections: [{\n *      offset: {line:100, column:10},\n *      map: {\n *        version : 3,\n *        file: \"section.js\",\n *        sources: [\"foo.js\", \"bar.js\"],\n *        names: [\"src\", \"maps\", \"are\", \"fun\"],\n *        mappings: \"AAAA,E;;ABCDE;\"\n *      }\n *    }],\n *  }\n *\n * The second parameter, if given, is a string whose value is the URL\n * at which the source map was found.  This URL is used to compute the\n * sources array.\n *\n * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt\n */ var IndexedSourceMapConsumer = /*#__PURE__*/ function(SourceMapConsumer1) {\n    _inherits(IndexedSourceMapConsumer, SourceMapConsumer1);\n    function IndexedSourceMapConsumer(aSourceMap, aSourceMapURL) {\n        var _this;\n        return _possibleConstructorReturn(_this, (_this = SourceMapConsumer1.call(this, INTERNAL) || this).then(function(that) {\n            var sourceMap = aSourceMap;\n            if (typeof aSourceMap === \"string\") {\n                sourceMap = util.parseSourceMapInput(aSourceMap);\n            }\n            var version = util.getArg(sourceMap, \"version\");\n            var sections = util.getArg(sourceMap, \"sections\");\n            if (version != that._version) {\n                throw new Error(\"Unsupported version: \" + version);\n            }\n            that._sources = new ArraySet();\n            that._names = new ArraySet();\n            that.__generatedMappings = null;\n            that.__originalMappings = null;\n            that.__generatedMappingsUnsorted = null;\n            that.__originalMappingsUnsorted = null;\n            var lastOffset = {\n                line: -1,\n                column: 0\n            };\n            return Promise.all(sections.map(function(s) {\n                if (s.url) {\n                    // The url field will require support for asynchronicity.\n                    // See https://github.com/mozilla/source-map/issues/16\n                    throw new Error(\"Support for url field in sections not implemented.\");\n                }\n                var offset = util.getArg(s, \"offset\");\n                var offsetLine = util.getArg(offset, \"line\");\n                var offsetColumn = util.getArg(offset, \"column\");\n                if (offsetLine < lastOffset.line || offsetLine === lastOffset.line && offsetColumn < lastOffset.column) {\n                    throw new Error(\"Section offsets must be ordered and non-overlapping.\");\n                }\n                lastOffset = offset;\n                var cons = new SourceMapConsumer(util.getArg(s, \"map\"), aSourceMapURL);\n                return cons.then(function(consumer) {\n                    return {\n                        generatedOffset: {\n                            // The offset fields are 0-based, but we use 1-based indices when\n                            // encoding/decoding from VLQ.\n                            generatedLine: offsetLine + 1,\n                            generatedColumn: offsetColumn + 1\n                        },\n                        consumer: consumer\n                    };\n                });\n            })).then(function(s) {\n                that._sections = s;\n                return that;\n            });\n        }));\n    }\n    var _proto = IndexedSourceMapConsumer.prototype;\n    _proto._sortGeneratedMappings = function _sortGeneratedMappings() {\n        var mappings = this._generatedMappingsUnsorted;\n        mappings.sort(util.compareByGeneratedPositionsDeflated);\n        this.__generatedMappings = mappings;\n    };\n    _proto._sortOriginalMappings = function _sortOriginalMappings() {\n        var mappings = this._originalMappingsUnsorted;\n        mappings.sort(util.compareByOriginalPositions);\n        this.__originalMappings = mappings;\n    };\n    /**\n   * Returns the original source, line, and column information for the generated\n   * source's line and column positions provided. The only argument is an object\n   * with the following properties:\n   *\n   *   - line: The line number in the generated source.  The line number\n   *     is 1-based.\n   *   - column: The column number in the generated source.  The column\n   *     number is 0-based.\n   *\n   * and an object is returned with the following properties:\n   *\n   *   - source: The original source file, or null.\n   *   - line: The line number in the original source, or null.  The\n   *     line number is 1-based.\n   *   - column: The column number in the original source, or null.  The\n   *     column number is 0-based.\n   *   - name: The original identifier, or null.\n   */ _proto.originalPositionFor = function originalPositionFor(aArgs) {\n        var needle = {\n            generatedLine: util.getArg(aArgs, \"line\"),\n            generatedColumn: util.getArg(aArgs, \"column\")\n        };\n        // Find the section containing the generated position we're trying to map\n        // to an original position.\n        var sectionIndex = binarySearch.search(needle, this._sections, function(aNeedle, section) {\n            var cmp = aNeedle.generatedLine - section.generatedOffset.generatedLine;\n            if (cmp) {\n                return cmp;\n            }\n            return aNeedle.generatedColumn - section.generatedOffset.generatedColumn;\n        });\n        var section = this._sections[sectionIndex];\n        if (!section) {\n            return {\n                source: null,\n                line: null,\n                column: null,\n                name: null\n            };\n        }\n        return section.consumer.originalPositionFor({\n            line: needle.generatedLine - (section.generatedOffset.generatedLine - 1),\n            column: needle.generatedColumn - (section.generatedOffset.generatedLine === needle.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),\n            bias: aArgs.bias\n        });\n    };\n    /**\n   * Return true if we have the source content for every source in the source\n   * map, false otherwise.\n   */ _proto.hasContentsOfAllSources = function hasContentsOfAllSources() {\n        return this._sections.every(function(s) {\n            return s.consumer.hasContentsOfAllSources();\n        });\n    };\n    /**\n   * Returns the original source content. The only argument is the url of the\n   * original source file. Returns null if no original source content is\n   * available.\n   */ _proto.sourceContentFor = function sourceContentFor(aSource, nullOnMissing) {\n        for(var i = 0; i < this._sections.length; i++){\n            var section = this._sections[i];\n            var content = section.consumer.sourceContentFor(aSource, true);\n            if (content) {\n                return content;\n            }\n        }\n        if (nullOnMissing) {\n            return null;\n        }\n        throw new Error('\"' + aSource + '\" is not in the SourceMap.');\n    };\n    /**\n   * Returns the generated line and column information for the original source,\n   * line, and column positions provided. The only argument is an object with\n   * the following properties:\n   *\n   *   - source: The filename of the original source.\n   *   - line: The line number in the original source.  The line number\n   *     is 1-based.\n   *   - column: The column number in the original source.  The column\n   *     number is 0-based.\n   *\n   * and an object is returned with the following properties:\n   *\n   *   - line: The line number in the generated source, or null.  The\n   *     line number is 1-based.\n   *   - column: The column number in the generated source, or null.\n   *     The column number is 0-based.\n   */ _proto.generatedPositionFor = function generatedPositionFor(aArgs) {\n        for(var i = 0; i < this._sections.length; i++){\n            var section = this._sections[i];\n            // Only consider this section if the requested source is in the list of\n            // sources of the consumer.\n            if (section.consumer._findSourceIndex(util.getArg(aArgs, \"source\")) === -1) {\n                continue;\n            }\n            var generatedPosition = section.consumer.generatedPositionFor(aArgs);\n            if (generatedPosition) {\n                var ret = {\n                    line: generatedPosition.line + (section.generatedOffset.generatedLine - 1),\n                    column: generatedPosition.column + (section.generatedOffset.generatedLine === generatedPosition.line ? section.generatedOffset.generatedColumn - 1 : 0)\n                };\n                return ret;\n            }\n        }\n        return {\n            line: null,\n            column: null\n        };\n    };\n    /**\n   * Parse the mappings in a string in to a data structure which we can easily\n   * query (the ordered arrays in the `this.__generatedMappings` and\n   * `this.__originalMappings` properties).\n   */ _proto._parseMappings = function _parseMappings(aStr, aSourceRoot) {\n        var _this = this, _loop = function(i) {\n            var section = _this._sections[i];\n            var sectionMappings = [];\n            section.consumer.eachMapping(function(m) {\n                return sectionMappings.push(m);\n            });\n            for(var j = 0; j < sectionMappings.length; j++){\n                var mapping = sectionMappings[j];\n                // TODO: test if null is correct here.  The original code used\n                // `source`, which would actually have gotten used as null because\n                // var's get hoisted.\n                // See: https://github.com/mozilla/source-map/issues/333\n                var source = util.computeSourceURL(section.consumer.sourceRoot, null, _this._sourceMapURL);\n                _this._sources.add(source);\n                source = _this._sources.indexOf(source);\n                var name = null;\n                if (mapping.name) {\n                    _this._names.add(mapping.name);\n                    name = _this._names.indexOf(mapping.name);\n                }\n                // The mappings coming from the consumer for the section have\n                // generated positions relative to the start of the section, so we\n                // need to offset them to be relative to the start of the concatenated\n                // generated file.\n                var adjustedMapping = {\n                    source: source,\n                    generatedLine: mapping.generatedLine + (section.generatedOffset.generatedLine - 1),\n                    generatedColumn: mapping.generatedColumn + (section.generatedOffset.generatedLine === mapping.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),\n                    originalLine: mapping.originalLine,\n                    originalColumn: mapping.originalColumn,\n                    name: name\n                };\n                generatedMappings.push(adjustedMapping);\n                if (typeof adjustedMapping.originalLine === \"number\") {\n                    originalMappings.push(adjustedMapping);\n                }\n            }\n        };\n        var generatedMappings = this.__generatedMappingsUnsorted = [];\n        var originalMappings = this.__originalMappingsUnsorted = [];\n        for(var i = 0; i < this._sections.length; i++)_loop(i);\n    };\n    _proto.eachMapping = function eachMapping(aCallback, aContext, aOrder) {\n        var context = aContext || null;\n        var order = aOrder || SourceMapConsumer.GENERATED_ORDER;\n        var mappings;\n        switch(order){\n            case SourceMapConsumer.GENERATED_ORDER:\n                mappings = this._generatedMappings;\n                break;\n            case SourceMapConsumer.ORIGINAL_ORDER:\n                mappings = this._originalMappings;\n                break;\n            default:\n                throw new Error(\"Unknown order of iteration.\");\n        }\n        var sourceRoot = this.sourceRoot;\n        mappings.map(function(mapping) {\n            var source = null;\n            if (mapping.source !== null) {\n                source = this._sources.at(mapping.source);\n                source = util.computeSourceURL(sourceRoot, source, this._sourceMapURL);\n            }\n            return {\n                source: source,\n                generatedLine: mapping.generatedLine,\n                generatedColumn: mapping.generatedColumn,\n                originalLine: mapping.originalLine,\n                originalColumn: mapping.originalColumn,\n                name: mapping.name === null ? null : this._names.at(mapping.name)\n            };\n        }, this).forEach(aCallback, context);\n    };\n    /**\n   * Find the mapping that best matches the hypothetical \"needle\" mapping that\n   * we are searching for in the given \"haystack\" of mappings.\n   */ _proto._findMapping = function _findMapping(aNeedle, aMappings, aLineName, aColumnName, aComparator, aBias) {\n        // To return the position we are searching for, we must first find the\n        // mapping for the given position and then return the opposite position it\n        // points to. Because the mappings are sorted, we can use binary search to\n        // find the best mapping.\n        if (aNeedle[aLineName] <= 0) {\n            throw new TypeError(\"Line must be greater than or equal to 1, got \" + aNeedle[aLineName]);\n        }\n        if (aNeedle[aColumnName] < 0) {\n            throw new TypeError(\"Column must be greater than or equal to 0, got \" + aNeedle[aColumnName]);\n        }\n        return binarySearch.search(aNeedle, aMappings, aComparator, aBias);\n    };\n    _proto.allGeneratedPositionsFor = function allGeneratedPositionsFor(aArgs) {\n        var line = util.getArg(aArgs, \"line\");\n        // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping\n        // returns the index of the closest mapping less than the needle. By\n        // setting needle.originalColumn to 0, we thus find the last mapping for\n        // the given line, provided such a mapping exists.\n        var needle = {\n            source: util.getArg(aArgs, \"source\"),\n            originalLine: line,\n            originalColumn: util.getArg(aArgs, \"column\", 0)\n        };\n        needle.source = this._findSourceIndex(needle.source);\n        if (needle.source < 0) {\n            return [];\n        }\n        if (needle.originalLine < 1) {\n            throw new Error(\"Line numbers must be >= 1\");\n        }\n        if (needle.originalColumn < 0) {\n            throw new Error(\"Column numbers must be >= 0\");\n        }\n        var mappings = [];\n        var index = this._findMapping(needle, this._originalMappings, \"originalLine\", \"originalColumn\", util.compareByOriginalPositions, binarySearch.LEAST_UPPER_BOUND);\n        if (index >= 0) {\n            var mapping = this._originalMappings[index];\n            if (aArgs.column === undefined) {\n                var originalLine = mapping.originalLine;\n                // Iterate until either we run out of mappings, or we run into\n                // a mapping for a different line than the one we found. Since\n                // mappings are sorted, this is guaranteed to find all mappings for\n                // the line we found.\n                while(mapping && mapping.originalLine === originalLine){\n                    var lastColumn = mapping.lastGeneratedColumn;\n                    if (this._computedColumnSpans && lastColumn === null) {\n                        lastColumn = Infinity;\n                    }\n                    mappings.push({\n                        line: util.getArg(mapping, \"generatedLine\", null),\n                        column: util.getArg(mapping, \"generatedColumn\", null),\n                        lastColumn: lastColumn\n                    });\n                    mapping = this._originalMappings[++index];\n                }\n            } else {\n                var originalColumn = mapping.originalColumn;\n                // Iterate until either we run out of mappings, or we run into\n                // a mapping for a different line than the one we were searching for.\n                // Since mappings are sorted, this is guaranteed to find all mappings for\n                // the line we are searching for.\n                while(mapping && mapping.originalLine === line && mapping.originalColumn == originalColumn){\n                    var lastColumn1 = mapping.lastGeneratedColumn;\n                    if (this._computedColumnSpans && lastColumn1 === null) {\n                        lastColumn1 = Infinity;\n                    }\n                    mappings.push({\n                        line: util.getArg(mapping, \"generatedLine\", null),\n                        column: util.getArg(mapping, \"generatedColumn\", null),\n                        lastColumn: lastColumn1\n                    });\n                    mapping = this._originalMappings[++index];\n                }\n            }\n        }\n        return mappings;\n    };\n    _proto.destroy = function destroy() {\n        for(var i = 0; i < this._sections.length; i++){\n            this._sections[i].consumer.destroy();\n        }\n    };\n    _createClass(IndexedSourceMapConsumer, [\n        {\n            key: \"_generatedMappings\",\n            get: // `__generatedMappings` and `__originalMappings` are arrays that hold the\n            // parsed mapping coordinates from the source map's \"mappings\" attribute. They\n            // are lazily instantiated, accessed via the `_generatedMappings` and\n            // `_originalMappings` getters respectively, and we only parse the mappings\n            // and create these arrays once queried for a source location. We jump through\n            // these hoops because there can be many thousands of mappings, and parsing\n            // them is expensive, so we only want to do it if we must.\n            //\n            // Each object in the arrays is of the form:\n            //\n            //     {\n            //       generatedLine: The line number in the generated code,\n            //       generatedColumn: The column number in the generated code,\n            //       source: The path to the original source file that generated this\n            //               chunk of code,\n            //       originalLine: The line number in the original source that\n            //                     corresponds to this chunk of generated code,\n            //       originalColumn: The column number in the original source that\n            //                       corresponds to this chunk of generated code,\n            //       name: The name of the original symbol which generated this chunk of\n            //             code.\n            //     }\n            //\n            // All properties except for `generatedLine` and `generatedColumn` can be\n            // `null`.\n            //\n            // `_generatedMappings` is ordered by the generated positions.\n            //\n            // `_originalMappings` is ordered by the original positions.\n            function get() {\n                if (!this.__generatedMappings) {\n                    this._sortGeneratedMappings();\n                }\n                return this.__generatedMappings;\n            }\n        },\n        {\n            key: \"_originalMappings\",\n            get: function get() {\n                if (!this.__originalMappings) {\n                    this._sortOriginalMappings();\n                }\n                return this.__originalMappings;\n            }\n        },\n        {\n            key: \"_generatedMappingsUnsorted\",\n            get: function get() {\n                if (!this.__generatedMappingsUnsorted) {\n                    this._parseMappings(this._mappings, this.sourceRoot);\n                }\n                return this.__generatedMappingsUnsorted;\n            }\n        },\n        {\n            key: \"_originalMappingsUnsorted\",\n            get: function get() {\n                if (!this.__originalMappingsUnsorted) {\n                    this._parseMappings(this._mappings, this.sourceRoot);\n                }\n                return this.__originalMappingsUnsorted;\n            }\n        },\n        {\n            key: \"sources\",\n            get: /**\n   * The list of original sources.\n   */ function get() {\n                var sources = [];\n                for(var i = 0; i < this._sections.length; i++){\n                    for(var j = 0; j < this._sections[i].consumer.sources.length; j++){\n                        sources.push(this._sections[i].consumer.sources[j]);\n                    }\n                }\n                return sources;\n            }\n        }\n    ]);\n    return IndexedSourceMapConsumer;\n}(SourceMapConsumer);\n/*\n * Cheat to get around inter-twingled classes.  `factory()` can be at the end\n * where it has access to non-hoisted classes, but it gets hoisted itself.\n */ function _factory(aSourceMap, aSourceMapURL) {\n    var sourceMap = aSourceMap;\n    if (typeof aSourceMap === \"string\") {\n        sourceMap = util.parseSourceMapInput(aSourceMap);\n    }\n    var consumer = sourceMap.sections != null ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL) : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);\n    return Promise.resolve(consumer);\n}\nfunction _factoryBSM(aSourceMap, aSourceMapURL) {\n    return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);\n}\n\nvar SourceMapGenerator = sourceMapGenerator.SourceMapGenerator;\n\nvar convertSourceMap = {};\n\nvar safeBuffer = {exports: {}};\n\n(function(module, exports) {\n    var copyProps = // alternative to using Object.keys for old browsers\n    function copyProps(src, dst) {\n        for(var key in src){\n            dst[key] = src[key];\n        }\n    };\n    var SafeBuffer = function SafeBuffer(arg, encodingOrOffset, length) {\n        return Buffer(arg, encodingOrOffset, length);\n    };\n    var buffer = require$$0__default$1[\"default\"];\n    var Buffer = buffer.Buffer;\n    if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {\n        module.exports = buffer;\n    } else {\n        // Copy properties from require('buffer')\n        copyProps(buffer, exports);\n        exports.Buffer = SafeBuffer;\n    }\n    // Copy static methods from Buffer\n    copyProps(Buffer, SafeBuffer);\n    SafeBuffer.from = function(arg, encodingOrOffset, length) {\n        if (typeof arg === \"number\") {\n            throw new TypeError(\"Argument must not be a number\");\n        }\n        return Buffer(arg, encodingOrOffset, length);\n    };\n    SafeBuffer.alloc = function(size, fill, encoding) {\n        if (typeof size !== \"number\") {\n            throw new TypeError(\"Argument must be a number\");\n        }\n        var buf = Buffer(size);\n        if (fill !== undefined) {\n            if (typeof encoding === \"string\") {\n                buf.fill(fill, encoding);\n            } else {\n                buf.fill(fill);\n            }\n        } else {\n            buf.fill(0);\n        }\n        return buf;\n    };\n    SafeBuffer.allocUnsafe = function(size) {\n        if (typeof size !== \"number\") {\n            throw new TypeError(\"Argument must be a number\");\n        }\n        return Buffer(size);\n    };\n    SafeBuffer.allocUnsafeSlow = function(size) {\n        if (typeof size !== \"number\") {\n            throw new TypeError(\"Argument must be a number\");\n        }\n        return buffer.SlowBuffer(size);\n    };\n})(safeBuffer, safeBuffer.exports);\n\n(function(exports) {\n    var decodeBase64 = function decodeBase64(base64) {\n        return SafeBuffer.Buffer.from(base64, \"base64\").toString();\n    };\n    var stripComment = function stripComment(sm) {\n        return sm.split(\",\").pop();\n    };\n    var readFromFileMap = function readFromFileMap(sm, dir) {\n        // NOTE: this will only work on the server since it attempts to read the map file\n        var r = exports.mapFileCommentRegex.exec(sm);\n        // for some odd reason //# .. captures in 1 and /* .. */ in 2\n        var filename = r[1] || r[2];\n        var filepath = path.resolve(dir, filename);\n        try {\n            return fs.readFileSync(filepath, \"utf8\");\n        } catch (e) {\n            throw new Error(\"An error occurred while trying to read the map file at \" + filepath + \"\\n\" + e);\n        }\n    };\n    var Converter = function Converter(sm, opts) {\n        opts = opts || {};\n        if (opts.isFileComment) sm = readFromFileMap(sm, opts.commentFileDir);\n        if (opts.hasComment) sm = stripComment(sm);\n        if (opts.isEncoded) sm = decodeBase64(sm);\n        if (opts.isJSON || opts.isEncoded) sm = JSON.parse(sm);\n        this.sourcemap = sm;\n    };\n    var fs = require$$0__default[\"default\"];\n    var path = require$$1__default[\"default\"];\n    var SafeBuffer = safeBuffer.exports;\n    Object.defineProperty(exports, \"commentRegex\", {\n        get: function getCommentRegex() {\n            return /^\\s*\\/(?:\\/|\\*)[@#]\\s+sourceMappingURL=data:(?:application|text)\\/json;(?:charset[:=]\\S+?;)?base64,(?:.*)$/mg;\n        }\n    });\n    Object.defineProperty(exports, \"mapFileCommentRegex\", {\n        get: function getMapFileCommentRegex() {\n            // Matches sourceMappingURL in either // or /* comment styles.\n            return /(?:\\/\\/[@#][ \\t]+sourceMappingURL=([^\\s'\"`]+?)[ \\t]*$)|(?:\\/\\*[@#][ \\t]+sourceMappingURL=([^\\*]+?)[ \\t]*(?:\\*\\/){1}[ \\t]*$)/mg;\n        }\n    });\n    Converter.prototype.toJSON = function(space) {\n        return JSON.stringify(this.sourcemap, null, space);\n    };\n    Converter.prototype.toBase64 = function() {\n        var json = this.toJSON();\n        return SafeBuffer.Buffer.from(json, \"utf8\").toString(\"base64\");\n    };\n    Converter.prototype.toComment = function(options) {\n        var base64 = this.toBase64();\n        var data = \"sourceMappingURL=data:application/json;charset=utf-8;base64,\" + base64;\n        return options && options.multiline ? \"/*# \" + data + \" */\" : \"//# \" + data;\n    };\n    // returns copy instead of original\n    Converter.prototype.toObject = function() {\n        return JSON.parse(this.toJSON());\n    };\n    Converter.prototype.addProperty = function(key, value) {\n        if (this.sourcemap.hasOwnProperty(key)) throw new Error('property \"' + key + '\" already exists on the sourcemap, use set property instead');\n        return this.setProperty(key, value);\n    };\n    Converter.prototype.setProperty = function(key, value) {\n        this.sourcemap[key] = value;\n        return this;\n    };\n    Converter.prototype.getProperty = function(key) {\n        return this.sourcemap[key];\n    };\n    exports.fromObject = function(obj) {\n        return new Converter(obj);\n    };\n    exports.fromJSON = function(json) {\n        return new Converter(json, {\n            isJSON: true\n        });\n    };\n    exports.fromBase64 = function(base64) {\n        return new Converter(base64, {\n            isEncoded: true\n        });\n    };\n    exports.fromComment = function(comment) {\n        comment = comment.replace(/^\\/\\*/g, \"//\").replace(/\\*\\/$/g, \"\");\n        return new Converter(comment, {\n            isEncoded: true,\n            hasComment: true\n        });\n    };\n    exports.fromMapFileComment = function(comment, dir) {\n        return new Converter(comment, {\n            commentFileDir: dir,\n            isFileComment: true,\n            isJSON: true\n        });\n    };\n    // Finds last sourcemap comment in file or returns null if none was found\n    exports.fromSource = function(content) {\n        var m = content.match(exports.commentRegex);\n        return m ? exports.fromComment(m.pop()) : null;\n    };\n    // Finds last sourcemap comment in file or returns null if none was found\n    exports.fromMapFileSource = function(content, dir) {\n        var m = content.match(exports.mapFileCommentRegex);\n        return m ? exports.fromMapFileComment(m.pop(), dir) : null;\n    };\n    exports.removeComments = function(src) {\n        return src.replace(exports.commentRegex, \"\");\n    };\n    exports.removeMapFileComments = function(src) {\n        return src.replace(exports.mapFileCommentRegex, \"\");\n    };\n    exports.generateMapFileComment = function(file, options) {\n        var data = \"sourceMappingURL=\" + file;\n        return options && options.multiline ? \"/*# \" + data + \" */\" : \"//# \" + data;\n    };\n})(convertSourceMap);\n\nvar stylis$1 = {exports: {}};\n\n(function(module, exports) {\n    (function(factory) {\n        module[\"exports\"] = factory(null) ;\n    })(/** @param {*=} options */ function factory(options) {\n        var select = /**\n\t\t * Select\n\t\t *\n\t\t * @param {Array<string>} parent\n\t\t * @param {string} current\n\t\t * @param {number} invert\n\t\t * @return {Array<string>}\n\t\t */ function select(parent, current, invert) {\n            var selectors = current.trim().split(selectorptn);\n            var out = selectors;\n            var length = selectors.length;\n            var l = parent.length;\n            switch(l){\n                // 0-1 parent selectors\n                case 0:\n                case 1:\n                    {\n                        for(var i = 0, selector = l === 0 ? \"\" : parent[0] + \" \"; i < length; ++i){\n                            out[i] = scope(selector, out[i], invert, l).trim();\n                        }\n                        break;\n                    }\n                // >2 parent selectors, nested\n                default:\n                    {\n                        for(var i = 0, j = 0, out = []; i < length; ++i){\n                            for(var k = 0; k < l; ++k){\n                                out[j++] = scope(parent[k] + \" \", selectors[i], invert, l).trim();\n                            }\n                        }\n                    }\n            }\n            return out;\n        };\n        var scope = /**\n\t\t * Scope\n\t\t *\n\t\t * @param {string} parent\n\t\t * @param {string} current\n\t\t * @param {number} invert\n\t\t * @param {number} level\n\t\t * @return {string}\n\t\t */ function scope(parent, current, invert, level) {\n            var selector = current;\n            var code = selector.charCodeAt(0);\n            // trim leading whitespace\n            if (code < 33) {\n                code = (selector = selector.trim()).charCodeAt(0);\n            }\n            switch(code){\n                // &\n                case AND:\n                    {\n                        switch(cascade + level){\n                            case 0:\n                            case 1:\n                                {\n                                    if (parent.trim().length === 0) {\n                                        break;\n                                    }\n                                }\n                            default:\n                                {\n                                    return selector.replace(andptn, \"$1\" + parent.trim());\n                                }\n                        }\n                        break;\n                    }\n                // :\n                case COLON:\n                    {\n                        switch(selector.charCodeAt(1)){\n                            // g in :global\n                            case 103:\n                                {\n                                    if (escape > 0 && cascade > 0) {\n                                        return selector.replace(escapeptn, \"$1\").replace(andptn, \"$1\" + nscope);\n                                    }\n                                    break;\n                                }\n                            default:\n                                {\n                                    // :hover\n                                    return parent.trim() + selector.replace(andptn, \"$1\" + parent.trim());\n                                }\n                        }\n                    }\n                default:\n                    {\n                        // html &\n                        if (invert * cascade > 0 && selector.indexOf(\"\\f\") > 0) {\n                            return selector.replace(andptn, (parent.charCodeAt(0) === COLON ? \"\" : \"$1\") + parent.trim());\n                        }\n                    }\n            }\n            return parent + selector;\n        };\n        var vendor = /**\n\t\t * Vendor\n\t\t *\n\t\t * @param {string} content\n\t\t * @param {number} context\n\t\t * @return {boolean}\n\t\t */ function vendor(content, context) {\n            var index = content.indexOf(context === 1 ? \":\" : \"{\");\n            var key = content.substring(0, context !== 3 ? index : 10);\n            var value = content.substring(index + 1, content.length - 1);\n            return should(context !== 2 ? key : key.replace(pseudofmt, \"$1\"), value, context);\n        };\n        var supports = /**\n\t\t * Supports\n\t\t *\n\t\t * @param {string} match\n\t\t * @param {string} group\n\t\t * @return {string}\n\t\t */ function supports(match, group) {\n            var out = property(group, group.charCodeAt(0), group.charCodeAt(1), group.charCodeAt(2));\n            return out !== group + \";\" ? out.replace(propertyptn, \" or ($1)\").substring(4) : \"(\" + group + \")\";\n        };\n        var animation = /**\n\t\t * Animation\n\t\t *\n\t\t * @param {string} input\n\t\t * @return {string}\n\t\t */ function animation(input) {\n            var length = input.length;\n            var index = input.indexOf(\":\", 9) + 1;\n            var declare = input.substring(0, index).trim();\n            var out = input.substring(index, length - 1).trim();\n            switch(input.charCodeAt(9) * keyed){\n                case 0:\n                    {\n                        break;\n                    }\n                // animation-*, -\n                case DASH:\n                    {\n                        // animation-name, n\n                        if (input.charCodeAt(10) !== 110) {\n                            break;\n                        }\n                    }\n                // animation/animation-name\n                default:\n                    {\n                        // split in case of multiple animations\n                        var list = out.split((out = \"\", animationptn));\n                        for(var i = 0, index = 0, length = list.length; i < length; index = 0, ++i){\n                            var value = list[i];\n                            var items = value.split(propertiesptn);\n                            while(value = items[index]){\n                                var peak = value.charCodeAt(0);\n                                if (keyed === 1 && (// letters\n                                peak > AT && peak < 90 || peak > 96 && peak < 123 || peak === UNDERSCORE || // dash but not in sequence i.e --\n                                peak === DASH && value.charCodeAt(1) !== DASH)) {\n                                    // not a number/function\n                                    switch(isNaN(parseFloat(value)) + (value.indexOf(\"(\") !== -1)){\n                                        case 1:\n                                            {\n                                                switch(value){\n                                                    // not a valid reserved keyword\n                                                    case \"infinite\":\n                                                    case \"alternate\":\n                                                    case \"backwards\":\n                                                    case \"running\":\n                                                    case \"normal\":\n                                                    case \"forwards\":\n                                                    case \"both\":\n                                                    case \"none\":\n                                                    case \"linear\":\n                                                    case \"ease\":\n                                                    case \"ease-in\":\n                                                    case \"ease-out\":\n                                                    case \"ease-in-out\":\n                                                    case \"paused\":\n                                                    case \"reverse\":\n                                                    case \"alternate-reverse\":\n                                                    case \"inherit\":\n                                                    case \"initial\":\n                                                    case \"unset\":\n                                                    case \"step-start\":\n                                                    case \"step-end\":\n                                                        {\n                                                            break;\n                                                        }\n                                                    default:\n                                                        {\n                                                            value += key;\n                                                        }\n                                                }\n                                            }\n                                    }\n                                }\n                                items[index++] = value;\n                            }\n                            out += (i === 0 ? \"\" : \",\") + items.join(\" \");\n                        }\n                    }\n            }\n            out = declare + out + \";\";\n            if (prefix === 1 || prefix === 2 && vendor(out, 1)) return webkit + out + out;\n            return out;\n        };\n        var isolate = /**\n\t\t * Isolate\n\t\t *\n\t\t * @param {Array<string>} current\n\t\t */ function isolate(current) {\n            for(var i = 0, length = current.length, selector = Array(length), padding, element; i < length; ++i){\n                // split individual elements in a selector i.e h1 h2 === [h1, h2]\n                var elements = current[i].split(elementptn);\n                var out = \"\";\n                for(var j = 0, size = 0, tail = 0, code = 0, l = elements.length; j < l; ++j){\n                    // empty element\n                    if ((size = (element = elements[j]).length) === 0 && l > 1) {\n                        continue;\n                    }\n                    tail = out.charCodeAt(out.length - 1);\n                    code = element.charCodeAt(0);\n                    padding = \"\";\n                    if (j !== 0) {\n                        // determine if we need padding\n                        switch(tail){\n                            case STAR:\n                            case TILDE:\n                            case GREATERTHAN:\n                            case PLUS:\n                            case SPACE:\n                            case OPENPARENTHESES:\n                                {\n                                    break;\n                                }\n                            default:\n                                {\n                                    padding = \" \";\n                                }\n                        }\n                    }\n                    switch(code){\n                        case AND:\n                            {\n                                element = padding + nscopealt;\n                            }\n                        case TILDE:\n                        case GREATERTHAN:\n                        case PLUS:\n                        case SPACE:\n                        case CLOSEPARENTHESES:\n                        case OPENPARENTHESES:\n                            {\n                                break;\n                            }\n                        case OPENBRACKET:\n                            {\n                                element = padding + element + nscopealt;\n                                break;\n                            }\n                        case COLON:\n                            {\n                                switch(element.charCodeAt(1) * 2 + element.charCodeAt(2) * 3){\n                                    // :global\n                                    case 530:\n                                        {\n                                            if (escape > 0) {\n                                                element = padding + element.substring(8, size - 1);\n                                                break;\n                                            }\n                                        }\n                                    // :hover, :nth-child(), ...\n                                    default:\n                                        {\n                                            if (j < 1 || elements[j - 1].length < 1) {\n                                                element = padding + nscopealt + element;\n                                            }\n                                        }\n                                }\n                                break;\n                            }\n                        case COMMA:\n                            {\n                                padding = \"\";\n                            }\n                        default:\n                            {\n                                if (size > 1 && element.indexOf(\":\") > 0) {\n                                    element = padding + element.replace(pseudoptn, \"$1\" + nscopealt + \"$2\");\n                                } else {\n                                    element = padding + element + nscopealt;\n                                }\n                            }\n                    }\n                    out += element;\n                }\n                selector[i] = out.replace(formatptn, \"\").trim();\n            }\n            return selector;\n        };\n        var proxy = /**\n\t\t * Proxy\n\t\t *\n\t\t * @param {number} context\n\t\t * @param {string} content\n\t\t * @param {Array<string>} selectors\n\t\t * @param {Array<string>} parents\n\t\t * @param {number} line\n\t\t * @param {number} column\n\t\t * @param {number} length\n\t\t * @param {number} id\n\t\t * @param {number} depth\n\t\t * @param {number} at\n\t\t * @return {(string|void|*)}\n\t\t */ function proxy(context, content, selectors, parents, line, column, length, id, depth, at) {\n            for(var i = 0, out = content, next; i < plugged; ++i){\n                switch(next = plugins[i].call(stylis, context, out, selectors, parents, line, column, length, id, depth, at)){\n                    case void 0:\n                    case false:\n                    case true:\n                    case null:\n                        {\n                            break;\n                        }\n                    default:\n                        {\n                            out = next;\n                        }\n                }\n            }\n            if (out !== content) {\n                return out;\n            }\n        };\n        var delimited = /**\n\t\t * @param {number} code\n\t\t * @param {number} index\n\t\t * @param {number} length\n\t\t * @param {string} body\n\t\t * @return {number}\n\t\t */ function delimited(code, index, length, body) {\n            for(var i = index + 1; i < length; ++i){\n                switch(body.charCodeAt(i)){\n                    // /*\n                    case FOWARDSLASH:\n                        {\n                            if (code === STAR) {\n                                if (body.charCodeAt(i - 1) === STAR && index + 2 !== i) {\n                                    return i + 1;\n                                }\n                            }\n                            break;\n                        }\n                    // //\n                    case NEWLINE:\n                        {\n                            if (code === FOWARDSLASH) {\n                                return i + 1;\n                            }\n                        }\n                }\n            }\n            return i;\n        };\n        var minify = /**\n\t\t * Minify\n\t\t *\n\t\t * @param {(string|*)} output\n\t\t * @return {string}\n\t\t */ function minify(output) {\n            return output.replace(formatptn, \"\").replace(beforeptn, \"\").replace(afterptn, \"$1\").replace(tailptn, \"$1\").replace(whiteptn, \" \");\n        };\n        /**\n\t\t * Notes\n\t\t *\n\t\t * The ['<method name>'] pattern is used to support closure compiler\n\t\t * the jsdoc signatures are also used to the same effect\n\t\t *\n\t\t * ----\n\t\t *\n\t\t * int + int + int === n4 [faster]\n\t\t *\n\t\t * vs\n\t\t *\n\t\t * int === n1 && int === n2 && int === n3\n\t\t *\n\t\t * ----\n\t\t *\n\t\t * switch (int) { case ints...} [faster]\n\t\t *\n\t\t * vs\n\t\t *\n\t\t * if (int == 1 && int === 2 ...)\n\t\t *\n\t\t * ----\n\t\t *\n\t\t * The (first*n1 + second*n2 + third*n3) format used in the property parser\n\t\t * is a simple way to hash the sequence of characters\n\t\t * taking into account the index they occur in\n\t\t * since any number of 3 character sequences could produce duplicates.\n\t\t *\n\t\t * On the other hand sequences that are directly tied to the index of the character\n\t\t * resolve a far more accurate measure, it's also faster\n\t\t * to evaluate one condition in a switch statement\n\t\t * than three in an if statement regardless of the added math.\n\t\t *\n\t\t * This allows the vendor prefixer to be both small and fast.\n\t\t */ var nullptn = /^\\0+/g /* matches leading null characters */ ;\n        var formatptn = /[\\0\\r\\f]/g /* matches new line, null and formfeed characters */ ;\n        var colonptn = /: */g /* splits animation rules */ ;\n        var cursorptn = /zoo|gra/ /* assert cursor varient */ ;\n        var transformptn = /([,: ])(transform)/g /* vendor prefix transform, older webkit */ ;\n        var animationptn = /,+\\s*(?![^(]*[)])/g /* splits multiple shorthand notation animations */ ;\n        var propertiesptn = / +\\s*(?![^(]*[)])/g /* animation properties */ ;\n        var elementptn = / *[\\0] */g /* selector elements */ ;\n        var selectorptn = /,\\r+?/g /* splits selectors */ ;\n        var andptn = /([\\t\\r\\n ])*\\f?&/g /* match & */ ;\n        var escapeptn = /:global\\(((?:[^\\(\\)\\[\\]]*|\\[.*\\]|\\([^\\(\\)]*\\))*)\\)/g /* matches :global(.*) */ ;\n        var invalidptn = /\\W+/g /* removes invalid characters from keyframes */ ;\n        var keyframeptn = /@(k\\w+)\\s*(\\S*)\\s*/ /* matches @keyframes $1 */ ;\n        var plcholdrptn = /::(place)/g /* match ::placeholder varient */ ;\n        var readonlyptn = /:(read-only)/g /* match :read-only varient */ ;\n        var beforeptn = /\\s+(?=[{\\];=:>])/g /* matches \\s before ] ; = : */ ;\n        var afterptn = /([[}=:>])\\s+/g /* matches \\s after characters [ } = : */ ;\n        var tailptn = /(\\{[^{]+?);(?=\\})/g /* matches tail semi-colons ;} */ ;\n        var whiteptn = /\\s{2,}/g /* matches repeating whitespace */ ;\n        var pseudoptn = /([^\\(])(:+) */g /* pseudo element */ ;\n        var writingptn = /[svh]\\w+-[tblr]{2}/ /* match writing mode property values */ ;\n        var supportsptn = /\\(\\s*(.*)\\s*\\)/g /* match supports (groups) */ ;\n        var propertyptn = /([\\s\\S]*?);/g /* match properties leading semicolon */ ;\n        var selfptn = /-self|flex-/g /* match flex- and -self in align-self: flex-*; */ ;\n        var pseudofmt = /[^]*?(:[rp][el]a[\\w-]+)[^]*/ /* extrats :readonly or :placholder from selector */ ;\n        var dimensionptn = /stretch|:\\s*\\w+\\-(?:conte|avail)/ /* match max/min/fit-content, fill-available */ ;\n        var imgsrcptn = /([^-])(image-set\\()/;\n        /* vendors */ var webkit = \"-webkit-\";\n        var moz = \"-moz-\";\n        var ms = \"-ms-\";\n        /* character codes */ var SEMICOLON = 59 /* ; */ ;\n        var CLOSEBRACES = 125 /* } */ ;\n        var OPENBRACES = 123 /* { */ ;\n        var OPENPARENTHESES = 40 /* ( */ ;\n        var CLOSEPARENTHESES = 41 /* ) */ ;\n        var OPENBRACKET = 91 /* [ */ ;\n        var CLOSEBRACKET = 93 /* ] */ ;\n        var NEWLINE = 10 /* \\n */ ;\n        var CARRIAGE = 13 /* \\r */ ;\n        var TAB = 9 /* \\t */ ;\n        var AT = 64 /* @ */ ;\n        var SPACE = 32 /*   */ ;\n        var AND = 38 /* & */ ;\n        var DASH = 45 /* - */ ;\n        var UNDERSCORE = 95 /* _ */ ;\n        var STAR = 42 /* * */ ;\n        var COMMA = 44 /* , */ ;\n        var COLON = 58 /* : */ ;\n        var SINGLEQUOTE = 39 /* ' */ ;\n        var DOUBLEQUOTE = 34 /* \" */ ;\n        var FOWARDSLASH = 47 /* / */ ;\n        var GREATERTHAN = 62 /* > */ ;\n        var PLUS = 43 /* + */ ;\n        var TILDE = 126 /* ~ */ ;\n        var NULL = 0 /* \\0 */ ;\n        var FORMFEED = 12 /* \\f */ ;\n        var VERTICALTAB = 11 /* \\v */ ;\n        /* special identifiers */ var KEYFRAME = 107 /* k */ ;\n        var MEDIA = 109 /* m */ ;\n        var SUPPORTS = 115 /* s */ ;\n        var PLACEHOLDER = 112 /* p */ ;\n        var READONLY = 111 /* o */ ;\n        var IMPORT = 105 /* <at>i */ ;\n        var CHARSET = 99 /* <at>c */ ;\n        var DOCUMENT = 100 /* <at>d */ ;\n        var PAGE = 112 /* <at>p */ ;\n        var column = 1 /* current column */ ;\n        var line = 1 /* current line numebr */ ;\n        var pattern = 0 /* :pattern */ ;\n        var cascade = 1 /* #id h1 h2 vs h1#id h2#id  */ ;\n        var prefix = 1 /* vendor prefix */ ;\n        var escape = 1 /* escape :global() pattern */ ;\n        var compress = 0 /* compress output */ ;\n        var semicolon = 0 /* no/semicolon option */ ;\n        var preserve = 0 /* preserve empty selectors */ ;\n        /* empty reference */ var array = [];\n        /* plugins */ var plugins = [];\n        var plugged = 0;\n        var should = null;\n        /* plugin context */ var POSTS = -2;\n        var PREPS = -1;\n        var UNKWN = 0;\n        var PROPS = 1;\n        var BLCKS = 2;\n        var ATRUL = 3;\n        /* plugin newline context */ var unkwn = 0;\n        /* keyframe animation */ var keyed = 1;\n        var key = \"\";\n        /* selector namespace */ var nscopealt = \"\";\n        var nscope = \"\";\n        /**\n\t\t * Compile\n\t\t *\n\t\t * @param {Array<string>} parent\n\t\t * @param {Array<string>} current\n\t\t * @param {string} body\n\t\t * @param {number} id\n\t\t * @param {number} depth\n\t\t * @return {string}\n\t\t */ function compile(parent, current, body, id, depth) {\n            var bracket = 0 /* brackets [] */ ;\n            var comment = 0 /* comments /* // or /* */ ;\n            var parentheses = 0 /* functions () */ ;\n            var quote = 0 /* quotes '', \"\" */ ;\n            var first = 0 /* first character code */ ;\n            var second = 0 /* second character code */ ;\n            var code = 0 /* current character code */ ;\n            var tail = 0 /* previous character code */ ;\n            var trail = 0 /* character before previous code */ ;\n            var peak = 0 /* previous non-whitespace code */ ;\n            var counter = 0 /* count sequence termination */ ;\n            var context = 0 /* track current context */ ;\n            var atrule = 0 /* track @at-rule context */ ;\n            var pseudo = 0 /* track pseudo token index */ ;\n            var caret = 0 /* current character index */ ;\n            var format = 0 /* control character formating context */ ;\n            var insert = 0 /* auto semicolon insertion */ ;\n            var invert = 0 /* inverted selector pattern */ ;\n            var length = 0 /* generic length address */ ;\n            var eof = body.length /* end of file(length) */ ;\n            var eol = eof - 1 /* end of file(characters) */ ;\n            var char = \"\" /* current character */ ;\n            var chars = \"\" /* current buffer of characters */ ;\n            var child = \"\" /* next buffer of characters */ ;\n            var out = \"\" /* compiled body */ ;\n            var children = \"\" /* compiled children */ ;\n            var flat = \"\" /* compiled leafs */ ;\n            var selector /* generic selector address */ ;\n            var result /* generic address */ ;\n            // ...build body\n            while(caret < eof){\n                code = body.charCodeAt(caret);\n                // eof varient\n                if (caret === eol) {\n                    // last character + noop context, add synthetic padding for noop context to terminate\n                    if (comment + quote + parentheses + bracket !== 0) {\n                        if (comment !== 0) {\n                            code = comment === FOWARDSLASH ? NEWLINE : FOWARDSLASH;\n                        }\n                        quote = parentheses = bracket = 0;\n                        eof++;\n                        eol++;\n                    }\n                }\n                if (comment + quote + parentheses + bracket === 0) {\n                    // eof varient\n                    if (caret === eol) {\n                        if (format > 0) {\n                            chars = chars.replace(formatptn, \"\");\n                        }\n                        if (chars.trim().length > 0) {\n                            switch(code){\n                                case SPACE:\n                                case TAB:\n                                case SEMICOLON:\n                                case CARRIAGE:\n                                case NEWLINE:\n                                    {\n                                        break;\n                                    }\n                                default:\n                                    {\n                                        chars += body.charAt(caret);\n                                    }\n                            }\n                            code = SEMICOLON;\n                        }\n                    }\n                    // auto semicolon insertion\n                    if (insert === 1) {\n                        switch(code){\n                            // false flags\n                            case OPENBRACES:\n                            case CLOSEBRACES:\n                            case SEMICOLON:\n                            case DOUBLEQUOTE:\n                            case SINGLEQUOTE:\n                            case OPENPARENTHESES:\n                            case CLOSEPARENTHESES:\n                            case COMMA:\n                                {\n                                    insert = 0;\n                                }\n                            // ignore\n                            case TAB:\n                            case CARRIAGE:\n                            case NEWLINE:\n                            case SPACE:\n                                {\n                                    break;\n                                }\n                            // valid\n                            default:\n                                {\n                                    insert = 0;\n                                    length = caret;\n                                    first = code;\n                                    caret--;\n                                    code = SEMICOLON;\n                                    while(length < eof){\n                                        switch(body.charCodeAt(length++)){\n                                            case NEWLINE:\n                                            case CARRIAGE:\n                                            case SEMICOLON:\n                                                {\n                                                    ++caret;\n                                                    code = first;\n                                                    length = eof;\n                                                    break;\n                                                }\n                                            case COLON:\n                                                {\n                                                    if (format > 0) {\n                                                        ++caret;\n                                                        code = first;\n                                                    }\n                                                }\n                                            case OPENBRACES:\n                                                {\n                                                    length = eof;\n                                                }\n                                        }\n                                    }\n                                }\n                        }\n                    }\n                    // token varient\n                    switch(code){\n                        case OPENBRACES:\n                            {\n                                chars = chars.trim();\n                                first = chars.charCodeAt(0);\n                                counter = 1;\n                                length = ++caret;\n                                while(caret < eof){\n                                    switch(code = body.charCodeAt(caret)){\n                                        case OPENBRACES:\n                                            {\n                                                counter++;\n                                                break;\n                                            }\n                                        case CLOSEBRACES:\n                                            {\n                                                counter--;\n                                                break;\n                                            }\n                                        case FOWARDSLASH:\n                                            {\n                                                switch(second = body.charCodeAt(caret + 1)){\n                                                    // /*, //\n                                                    case STAR:\n                                                    case FOWARDSLASH:\n                                                        {\n                                                            caret = delimited(second, caret, eol, body);\n                                                        }\n                                                }\n                                                break;\n                                            }\n                                        // given \"[\" === 91 & \"]\" === 93 hence forth 91 + 1 + 1 === 93\n                                        case OPENBRACKET:\n                                            {\n                                                code++;\n                                            }\n                                        // given \"(\" === 40 & \")\" === 41 hence forth 40 + 1 === 41\n                                        case OPENPARENTHESES:\n                                            {\n                                                code++;\n                                            }\n                                        // quote tail delimiter is identical to the head delimiter hence noop,\n                                        // fallthrough clauses have been shifted to the correct tail delimiter\n                                        case DOUBLEQUOTE:\n                                        case SINGLEQUOTE:\n                                            {\n                                                while(caret++ < eol){\n                                                    if (body.charCodeAt(caret) === code) {\n                                                        break;\n                                                    }\n                                                }\n                                            }\n                                    }\n                                    if (counter === 0) {\n                                        break;\n                                    }\n                                    caret++;\n                                }\n                                child = body.substring(length, caret);\n                                if (first === NULL) {\n                                    first = (chars = chars.replace(nullptn, \"\").trim()).charCodeAt(0);\n                                }\n                                switch(first){\n                                    // @at-rule\n                                    case AT:\n                                        {\n                                            if (format > 0) {\n                                                chars = chars.replace(formatptn, \"\");\n                                            }\n                                            second = chars.charCodeAt(1);\n                                            switch(second){\n                                                case DOCUMENT:\n                                                case MEDIA:\n                                                case SUPPORTS:\n                                                case DASH:\n                                                    {\n                                                        selector = current;\n                                                        break;\n                                                    }\n                                                default:\n                                                    {\n                                                        selector = array;\n                                                    }\n                                            }\n                                            child = compile(current, selector, child, second, depth + 1);\n                                            length = child.length;\n                                            // preserve empty @at-rule\n                                            if (preserve > 0 && length === 0) {\n                                                length = chars.length;\n                                            }\n                                            // execute plugins, @at-rule context\n                                            if (plugged > 0) {\n                                                selector = select(array, chars, invert);\n                                                result = proxy(ATRUL, child, selector, current, line, column, length, second, depth, id);\n                                                chars = selector.join(\"\");\n                                                if (result !== void 0) {\n                                                    if ((length = (child = result.trim()).length) === 0) {\n                                                        second = 0;\n                                                        child = \"\";\n                                                    }\n                                                }\n                                            }\n                                            if (length > 0) {\n                                                switch(second){\n                                                    case SUPPORTS:\n                                                        {\n                                                            chars = chars.replace(supportsptn, supports);\n                                                        }\n                                                    case DOCUMENT:\n                                                    case MEDIA:\n                                                    case DASH:\n                                                        {\n                                                            child = chars + \"{\" + child + \"}\";\n                                                            break;\n                                                        }\n                                                    case KEYFRAME:\n                                                        {\n                                                            chars = chars.replace(keyframeptn, \"$1 $2\" + (keyed > 0 ? key : \"\"));\n                                                            child = chars + \"{\" + child + \"}\";\n                                                            if (prefix === 1 || prefix === 2 && vendor(\"@\" + child, 3)) {\n                                                                child = \"@\" + webkit + child + \"@\" + child;\n                                                            } else {\n                                                                child = \"@\" + child;\n                                                            }\n                                                            break;\n                                                        }\n                                                    default:\n                                                        {\n                                                            child = chars + child;\n                                                            if (id === PAGE) {\n                                                                child = (out += child, \"\");\n                                                            }\n                                                        }\n                                                }\n                                            } else {\n                                                child = \"\";\n                                            }\n                                            break;\n                                        }\n                                    // selector\n                                    default:\n                                        {\n                                            child = compile(current, select(current, chars, invert), child, id, depth + 1);\n                                        }\n                                }\n                                children += child;\n                                // reset\n                                context = 0;\n                                insert = 0;\n                                pseudo = 0;\n                                format = 0;\n                                invert = 0;\n                                atrule = 0;\n                                chars = \"\";\n                                child = \"\";\n                                code = body.charCodeAt(++caret);\n                                break;\n                            }\n                        case CLOSEBRACES:\n                        case SEMICOLON:\n                            {\n                                chars = (format > 0 ? chars.replace(formatptn, \"\") : chars).trim();\n                                if ((length = chars.length) > 1) {\n                                    // monkey-patch missing colon\n                                    if (pseudo === 0) {\n                                        first = chars.charCodeAt(0);\n                                        // first character is a letter or dash, buffer has a space character\n                                        if (first === DASH || first > 96 && first < 123) {\n                                            length = (chars = chars.replace(\" \", \":\")).length;\n                                        }\n                                    }\n                                    // execute plugins, property context\n                                    if (plugged > 0) {\n                                        if ((result = proxy(PROPS, chars, current, parent, line, column, out.length, id, depth, id)) !== void 0) {\n                                            if ((length = (chars = result.trim()).length) === 0) {\n                                                chars = \"\\0\\0\";\n                                            }\n                                        }\n                                    }\n                                    first = chars.charCodeAt(0);\n                                    second = chars.charCodeAt(1);\n                                    switch(first){\n                                        case NULL:\n                                            {\n                                                break;\n                                            }\n                                        case AT:\n                                            {\n                                                if (second === IMPORT || second === CHARSET) {\n                                                    flat += chars + body.charAt(caret);\n                                                    break;\n                                                }\n                                            }\n                                        default:\n                                            {\n                                                if (chars.charCodeAt(length - 1) === COLON) {\n                                                    break;\n                                                }\n                                                out += property(chars, first, second, chars.charCodeAt(2));\n                                            }\n                                    }\n                                }\n                                // reset\n                                context = 0;\n                                insert = 0;\n                                pseudo = 0;\n                                format = 0;\n                                invert = 0;\n                                chars = \"\";\n                                code = body.charCodeAt(++caret);\n                                break;\n                            }\n                    }\n                }\n                // parse characters\n                switch(code){\n                    case CARRIAGE:\n                    case NEWLINE:\n                        {\n                            // auto insert semicolon\n                            if (comment + quote + parentheses + bracket + semicolon === 0) {\n                                // valid non-whitespace characters that\n                                // may precede a newline\n                                switch(peak){\n                                    case CLOSEPARENTHESES:\n                                    case SINGLEQUOTE:\n                                    case DOUBLEQUOTE:\n                                    case AT:\n                                    case TILDE:\n                                    case GREATERTHAN:\n                                    case STAR:\n                                    case PLUS:\n                                    case FOWARDSLASH:\n                                    case DASH:\n                                    case COLON:\n                                    case COMMA:\n                                    case SEMICOLON:\n                                    case OPENBRACES:\n                                    case CLOSEBRACES:\n                                        {\n                                            break;\n                                        }\n                                    default:\n                                        {\n                                            // current buffer has a colon\n                                            if (pseudo > 0) {\n                                                insert = 1;\n                                            }\n                                        }\n                                }\n                            }\n                            // terminate line comment\n                            if (comment === FOWARDSLASH) {\n                                comment = 0;\n                            } else if (cascade + context === 0 && id !== KEYFRAME && chars.length > 0) {\n                                format = 1;\n                                chars += \"\\0\";\n                            }\n                            // execute plugins, newline context\n                            if (plugged * unkwn > 0) {\n                                proxy(UNKWN, chars, current, parent, line, column, out.length, id, depth, id);\n                            }\n                            // next line, reset column position\n                            column = 1;\n                            line++;\n                            break;\n                        }\n                    case SEMICOLON:\n                    case CLOSEBRACES:\n                        {\n                            if (comment + quote + parentheses + bracket === 0) {\n                                column++;\n                                break;\n                            }\n                        }\n                    default:\n                        {\n                            // increment column position\n                            column++;\n                            // current character\n                            char = body.charAt(caret);\n                            // remove comments, escape functions, strings, attributes and prepare selectors\n                            switch(code){\n                                case TAB:\n                                case SPACE:\n                                    {\n                                        if (quote + bracket + comment === 0) {\n                                            switch(tail){\n                                                case COMMA:\n                                                case COLON:\n                                                case TAB:\n                                                case SPACE:\n                                                    {\n                                                        char = \"\";\n                                                        break;\n                                                    }\n                                                default:\n                                                    {\n                                                        if (code !== SPACE) {\n                                                            char = \" \";\n                                                        }\n                                                    }\n                                            }\n                                        }\n                                        break;\n                                    }\n                                // escape breaking control characters\n                                case NULL:\n                                    {\n                                        char = \"\\\\0\";\n                                        break;\n                                    }\n                                case FORMFEED:\n                                    {\n                                        char = \"\\\\f\";\n                                        break;\n                                    }\n                                case VERTICALTAB:\n                                    {\n                                        char = \"\\\\v\";\n                                        break;\n                                    }\n                                // &\n                                case AND:\n                                    {\n                                        // inverted selector pattern i.e html &\n                                        if (quote + comment + bracket === 0 && cascade > 0) {\n                                            invert = 1;\n                                            format = 1;\n                                            char = \"\\f\" + char;\n                                        }\n                                        break;\n                                    }\n                                // ::p<l>aceholder, l\n                                // :read-on<l>y, l\n                                case 108:\n                                    {\n                                        if (quote + comment + bracket + pattern === 0 && pseudo > 0) {\n                                            switch(caret - pseudo){\n                                                // ::placeholder\n                                                case 2:\n                                                    {\n                                                        if (tail === PLACEHOLDER && body.charCodeAt(caret - 3) === COLON) {\n                                                            pattern = tail;\n                                                        }\n                                                    }\n                                                // :read-only\n                                                case 8:\n                                                    {\n                                                        if (trail === READONLY) {\n                                                            pattern = trail;\n                                                        }\n                                                    }\n                                            }\n                                        }\n                                        break;\n                                    }\n                                // :<pattern>\n                                case COLON:\n                                    {\n                                        if (quote + comment + bracket === 0) {\n                                            pseudo = caret;\n                                        }\n                                        break;\n                                    }\n                                // selectors\n                                case COMMA:\n                                    {\n                                        if (comment + parentheses + quote + bracket === 0) {\n                                            format = 1;\n                                            char += \"\\r\";\n                                        }\n                                        break;\n                                    }\n                                // quotes\n                                case DOUBLEQUOTE:\n                                case SINGLEQUOTE:\n                                    {\n                                        if (comment === 0) {\n                                            quote = quote === code ? 0 : quote === 0 ? code : quote;\n                                        }\n                                        break;\n                                    }\n                                // attributes\n                                case OPENBRACKET:\n                                    {\n                                        if (quote + comment + parentheses === 0) {\n                                            bracket++;\n                                        }\n                                        break;\n                                    }\n                                case CLOSEBRACKET:\n                                    {\n                                        if (quote + comment + parentheses === 0) {\n                                            bracket--;\n                                        }\n                                        break;\n                                    }\n                                // functions\n                                case CLOSEPARENTHESES:\n                                    {\n                                        if (quote + comment + bracket === 0) {\n                                            parentheses--;\n                                        }\n                                        break;\n                                    }\n                                case OPENPARENTHESES:\n                                    {\n                                        if (quote + comment + bracket === 0) {\n                                            if (context === 0) {\n                                                switch(tail * 2 + trail * 3){\n                                                    // :matches\n                                                    case 533:\n                                                        {\n                                                            break;\n                                                        }\n                                                    // :global, :not, :nth-child etc...\n                                                    default:\n                                                        {\n                                                            counter = 0;\n                                                            context = 1;\n                                                        }\n                                                }\n                                            }\n                                            parentheses++;\n                                        }\n                                        break;\n                                    }\n                                case AT:\n                                    {\n                                        if (comment + parentheses + quote + bracket + pseudo + atrule === 0) {\n                                            atrule = 1;\n                                        }\n                                        break;\n                                    }\n                                // block/line comments\n                                case STAR:\n                                case FOWARDSLASH:\n                                    {\n                                        if (quote + bracket + parentheses > 0) {\n                                            break;\n                                        }\n                                        switch(comment){\n                                            // initialize line/block comment context\n                                            case 0:\n                                                {\n                                                    switch(code * 2 + body.charCodeAt(caret + 1) * 3){\n                                                        // //\n                                                        case 235:\n                                                            {\n                                                                comment = FOWARDSLASH;\n                                                                break;\n                                                            }\n                                                        // /*\n                                                        case 220:\n                                                            {\n                                                                length = caret;\n                                                                comment = STAR;\n                                                                break;\n                                                            }\n                                                    }\n                                                    break;\n                                                }\n                                            // end block comment context\n                                            case STAR:\n                                                {\n                                                    if (code === FOWARDSLASH && tail === STAR && length + 2 !== caret) {\n                                                        // /*<!> ... */, !\n                                                        if (body.charCodeAt(length + 2) === 33) {\n                                                            out += body.substring(length, caret + 1);\n                                                        }\n                                                        char = \"\";\n                                                        comment = 0;\n                                                    }\n                                                }\n                                        }\n                                    }\n                            }\n                            // ignore comment blocks\n                            if (comment === 0) {\n                                // aggressive isolation mode, divide each individual selector\n                                // including selectors in :not function but excluding selectors in :global function\n                                if (cascade + quote + bracket + atrule === 0 && id !== KEYFRAME && code !== SEMICOLON) {\n                                    switch(code){\n                                        case COMMA:\n                                        case TILDE:\n                                        case GREATERTHAN:\n                                        case PLUS:\n                                        case CLOSEPARENTHESES:\n                                        case OPENPARENTHESES:\n                                            {\n                                                if (context === 0) {\n                                                    // outside of an isolated context i.e nth-child(<...>)\n                                                    switch(tail){\n                                                        case TAB:\n                                                        case SPACE:\n                                                        case NEWLINE:\n                                                        case CARRIAGE:\n                                                            {\n                                                                char = char + \"\\0\";\n                                                                break;\n                                                            }\n                                                        default:\n                                                            {\n                                                                char = \"\\0\" + char + (code === COMMA ? \"\" : \"\\0\");\n                                                            }\n                                                    }\n                                                    format = 1;\n                                                } else {\n                                                    // within an isolated context, sleep untill it's terminated\n                                                    switch(code){\n                                                        case OPENPARENTHESES:\n                                                            {\n                                                                // :globa<l>(\n                                                                if (pseudo + 7 === caret && tail === 108) {\n                                                                    pseudo = 0;\n                                                                }\n                                                                context = ++counter;\n                                                                break;\n                                                            }\n                                                        case CLOSEPARENTHESES:\n                                                            {\n                                                                if ((context = --counter) === 0) {\n                                                                    format = 1;\n                                                                    char += \"\\0\";\n                                                                }\n                                                                break;\n                                                            }\n                                                    }\n                                                }\n                                                break;\n                                            }\n                                        case TAB:\n                                        case SPACE:\n                                            {\n                                                switch(tail){\n                                                    case NULL:\n                                                    case OPENBRACES:\n                                                    case CLOSEBRACES:\n                                                    case SEMICOLON:\n                                                    case COMMA:\n                                                    case FORMFEED:\n                                                    case TAB:\n                                                    case SPACE:\n                                                    case NEWLINE:\n                                                    case CARRIAGE:\n                                                        {\n                                                            break;\n                                                        }\n                                                    default:\n                                                        {\n                                                            // ignore in isolated contexts\n                                                            if (context === 0) {\n                                                                format = 1;\n                                                                char += \"\\0\";\n                                                            }\n                                                        }\n                                                }\n                                            }\n                                    }\n                                }\n                                // concat buffer of characters\n                                chars += char;\n                                // previous non-whitespace character code\n                                if (code !== SPACE && code !== TAB) {\n                                    peak = code;\n                                }\n                            }\n                        }\n                }\n                // tail character codes\n                trail = tail;\n                tail = code;\n                // visit every character\n                caret++;\n            }\n            length = out.length;\n            // preserve empty selector\n            if (preserve > 0) {\n                if (length === 0 && children.length === 0 && current[0].length === 0 === false) {\n                    if (id !== MEDIA || current.length === 1 && (cascade > 0 ? nscopealt : nscope) === current[0]) {\n                        length = current.join(\",\").length + 2;\n                    }\n                }\n            }\n            if (length > 0) {\n                // cascade isolation mode?\n                selector = cascade === 0 && id !== KEYFRAME ? isolate(current) : current;\n                // execute plugins, block context\n                if (plugged > 0) {\n                    result = proxy(BLCKS, out, selector, parent, line, column, length, id, depth, id);\n                    if (result !== void 0 && (out = result).length === 0) {\n                        return flat + out + children;\n                    }\n                }\n                out = selector.join(\",\") + \"{\" + out + \"}\";\n                if (prefix * pattern !== 0) {\n                    if (prefix === 2 && !vendor(out, 2)) pattern = 0;\n                    switch(pattern){\n                        // ::read-only\n                        case READONLY:\n                            {\n                                out = out.replace(readonlyptn, \":\" + moz + \"$1\") + out;\n                                break;\n                            }\n                        // ::placeholder\n                        case PLACEHOLDER:\n                            {\n                                out = out.replace(plcholdrptn, \"::\" + webkit + \"input-$1\") + out.replace(plcholdrptn, \"::\" + moz + \"$1\") + out.replace(plcholdrptn, \":\" + ms + \"input-$1\") + out;\n                                break;\n                            }\n                    }\n                    pattern = 0;\n                }\n            }\n            return flat + out + children;\n        }\n        /**\n\t\t * Property\n\t\t *\n\t\t * @param {string} input\n\t\t * @param {number} first\n\t\t * @param {number} second\n\t\t * @param {number} third\n\t\t * @return {string}\n\t\t */ function property(input, first, second, third) {\n            var index = 0;\n            var out = input + \";\";\n            var hash = first * 2 + second * 3 + third * 4;\n            var cache;\n            // animation: a, n, i characters\n            if (hash === 944) {\n                return animation(out);\n            } else if (prefix === 0 || prefix === 2 && !vendor(out, 1)) {\n                return out;\n            }\n            // vendor prefix\n            switch(hash){\n                // text-decoration/text-size-adjust/text-shadow/text-align/text-transform: t, e, x\n                case 1015:\n                    {\n                        // text-shadow/text-align/text-transform, a\n                        return out.charCodeAt(10) === 97 ? webkit + out + out : out;\n                    }\n                // filter/fill f, i, l\n                case 951:\n                    {\n                        // filter, t\n                        return out.charCodeAt(3) === 116 ? webkit + out + out : out;\n                    }\n                // color/column, c, o, l\n                case 963:\n                    {\n                        // column, n\n                        return out.charCodeAt(5) === 110 ? webkit + out + out : out;\n                    }\n                // box-decoration-break, b, o, x\n                case 1009:\n                    {\n                        if (out.charCodeAt(4) !== 100) {\n                            break;\n                        }\n                    }\n                // mask, m, a, s\n                // clip-path, c, l, i\n                case 969:\n                case 942:\n                    {\n                        return webkit + out + out;\n                    }\n                // appearance: a, p, p\n                case 978:\n                    {\n                        return webkit + out + moz + out + out;\n                    }\n                // hyphens: h, y, p\n                // user-select: u, s, e\n                case 1019:\n                case 983:\n                    {\n                        return webkit + out + moz + out + ms + out + out;\n                    }\n                // background/backface-visibility, b, a, c\n                case 883:\n                    {\n                        // backface-visibility, -\n                        if (out.charCodeAt(8) === DASH) {\n                            return webkit + out + out;\n                        }\n                        // image-set(...)\n                        if (out.indexOf(\"image-set(\", 11) > 0) {\n                            return out.replace(imgsrcptn, \"$1\" + webkit + \"$2\") + out;\n                        }\n                        return out;\n                    }\n                // flex: f, l, e\n                case 932:\n                    {\n                        if (out.charCodeAt(4) === DASH) {\n                            switch(out.charCodeAt(5)){\n                                // flex-grow, g\n                                case 103:\n                                    {\n                                        return webkit + \"box-\" + out.replace(\"-grow\", \"\") + webkit + out + ms + out.replace(\"grow\", \"positive\") + out;\n                                    }\n                                // flex-shrink, s\n                                case 115:\n                                    {\n                                        return webkit + out + ms + out.replace(\"shrink\", \"negative\") + out;\n                                    }\n                                // flex-basis, b\n                                case 98:\n                                    {\n                                        return webkit + out + ms + out.replace(\"basis\", \"preferred-size\") + out;\n                                    }\n                            }\n                        }\n                        return webkit + out + ms + out + out;\n                    }\n                // order: o, r, d\n                case 964:\n                    {\n                        return webkit + out + ms + \"flex\" + \"-\" + out + out;\n                    }\n                // justify-items/justify-content, j, u, s\n                case 1023:\n                    {\n                        // justify-content, c\n                        if (out.charCodeAt(8) !== 99) {\n                            break;\n                        }\n                        cache = out.substring(out.indexOf(\":\", 15)).replace(\"flex-\", \"\").replace(\"space-between\", \"justify\");\n                        return webkit + \"box-pack\" + cache + webkit + out + ms + \"flex-pack\" + cache + out;\n                    }\n                // cursor, c, u, r\n                case 1005:\n                    {\n                        return cursorptn.test(out) ? out.replace(colonptn, \":\" + webkit) + out.replace(colonptn, \":\" + moz) + out : out;\n                    }\n                // writing-mode, w, r, i\n                case 1000:\n                    {\n                        cache = out.substring(13).trim();\n                        index = cache.indexOf(\"-\") + 1;\n                        switch(cache.charCodeAt(0) + cache.charCodeAt(index)){\n                            // vertical-lr\n                            case 226:\n                                {\n                                    cache = out.replace(writingptn, \"tb\");\n                                    break;\n                                }\n                            // vertical-rl\n                            case 232:\n                                {\n                                    cache = out.replace(writingptn, \"tb-rl\");\n                                    break;\n                                }\n                            // horizontal-tb\n                            case 220:\n                                {\n                                    cache = out.replace(writingptn, \"lr\");\n                                    break;\n                                }\n                            default:\n                                {\n                                    return out;\n                                }\n                        }\n                        return webkit + out + ms + cache + out;\n                    }\n                // position: sticky\n                case 1017:\n                    {\n                        if (out.indexOf(\"sticky\", 9) === -1) {\n                            return out;\n                        }\n                    }\n                // display(flex/inline-flex/inline-box): d, i, s\n                case 975:\n                    {\n                        index = (out = input).length - 10;\n                        cache = (out.charCodeAt(index) === 33 ? out.substring(0, index) : out).substring(input.indexOf(\":\", 7) + 1).trim();\n                        switch(hash = cache.charCodeAt(0) + (cache.charCodeAt(7) | 0)){\n                            // inline-\n                            case 203:\n                                {\n                                    // inline-box\n                                    if (cache.charCodeAt(8) < 111) {\n                                        break;\n                                    }\n                                }\n                            // inline-box/sticky\n                            case 115:\n                                {\n                                    out = out.replace(cache, webkit + cache) + \";\" + out;\n                                    break;\n                                }\n                            // inline-flex\n                            // flex\n                            case 207:\n                            case 102:\n                                {\n                                    out = out.replace(cache, webkit + (hash > 102 ? \"inline-\" : \"\") + \"box\") + \";\" + out.replace(cache, webkit + cache) + \";\" + out.replace(cache, ms + cache + \"box\") + \";\" + out;\n                                }\n                        }\n                        return out + \";\";\n                    }\n                // align-items, align-center, align-self: a, l, i, -\n                case 938:\n                    {\n                        if (out.charCodeAt(5) === DASH) {\n                            switch(out.charCodeAt(6)){\n                                // align-items, i\n                                case 105:\n                                    {\n                                        cache = out.replace(\"-items\", \"\");\n                                        return webkit + out + webkit + \"box-\" + cache + ms + \"flex-\" + cache + out;\n                                    }\n                                // align-self, s\n                                case 115:\n                                    {\n                                        return webkit + out + ms + \"flex-item-\" + out.replace(selfptn, \"\") + out;\n                                    }\n                                // align-content\n                                default:\n                                    {\n                                        return webkit + out + ms + \"flex-line-pack\" + out.replace(\"align-content\", \"\").replace(selfptn, \"\") + out;\n                                    }\n                            }\n                        }\n                        break;\n                    }\n                // min/max\n                case 973:\n                case 989:\n                    {\n                        // min-/max- height/width/block-size/inline-size\n                        if (out.charCodeAt(3) !== DASH || out.charCodeAt(4) === 122) {\n                            break;\n                        }\n                    }\n                // height/width: min-content / width: max-content\n                case 931:\n                case 953:\n                    {\n                        if (dimensionptn.test(input) === true) {\n                            // stretch\n                            if ((cache = input.substring(input.indexOf(\":\") + 1)).charCodeAt(0) === 115) return property(input.replace(\"stretch\", \"fill-available\"), first, second, third).replace(\":fill-available\", \":stretch\");\n                            else return out.replace(cache, webkit + cache) + out.replace(cache, moz + cache.replace(\"fill-\", \"\")) + out;\n                        }\n                        break;\n                    }\n                // transform, transition: t, r, a\n                case 962:\n                    {\n                        out = webkit + out + (out.charCodeAt(5) === 102 ? ms + out : \"\") + out;\n                        // transitions\n                        if (second + third === 211 && out.charCodeAt(13) === 105 && out.indexOf(\"transform\", 10) > 0) {\n                            return out.substring(0, out.indexOf(\";\", 27) + 1).replace(transformptn, \"$1\" + webkit + \"$2\") + out;\n                        }\n                        break;\n                    }\n            }\n            return out;\n        }\n        /**\n\t\t * Use\n\t\t *\n\t\t * @param {(Array<function(...?)>|function(...?)|number|void)?} plugin\n\t\t */ function use(plugin) {\n            switch(plugin){\n                case void 0:\n                case null:\n                    {\n                        plugged = plugins.length = 0;\n                        break;\n                    }\n                default:\n                    {\n                        if (typeof plugin === \"function\") {\n                            plugins[plugged++] = plugin;\n                        } else if (typeof plugin === \"object\") {\n                            for(var i = 0, length = plugin.length; i < length; ++i){\n                                use(plugin[i]);\n                            }\n                        } else {\n                            unkwn = !!plugin | 0;\n                        }\n                    }\n            }\n            return use;\n        }\n        /**\n\t\t * Set\n\t\t *\n\t\t * @param {*} options\n\t\t */ function set(options) {\n            for(var name in options){\n                var value = options[name];\n                switch(name){\n                    case \"keyframe\":\n                        keyed = value | 0;\n                        break;\n                    case \"global\":\n                        escape = value | 0;\n                        break;\n                    case \"cascade\":\n                        cascade = value | 0;\n                        break;\n                    case \"compress\":\n                        compress = value | 0;\n                        break;\n                    case \"semicolon\":\n                        semicolon = value | 0;\n                        break;\n                    case \"preserve\":\n                        preserve = value | 0;\n                        break;\n                    case \"prefix\":\n                        should = null;\n                        if (!value) {\n                            prefix = 0;\n                        } else if (typeof value !== \"function\") {\n                            prefix = 1;\n                        } else {\n                            prefix = 2;\n                            should = value;\n                        }\n                }\n            }\n            return set;\n        }\n        /**\n\t\t * Stylis\n\t\t *\n\t\t * @param {string} selector\n\t\t * @param {string} input\n\t\t * @return {*}\n\t\t */ function stylis(selector, input) {\n            if (this !== void 0 && this.constructor === stylis) {\n                return factory(selector);\n            }\n            // setup\n            var ns = selector;\n            var code = ns.charCodeAt(0);\n            // trim leading whitespace\n            if (code < 33) {\n                code = (ns = ns.trim()).charCodeAt(0);\n            }\n            // keyframe/animation namespace\n            if (keyed > 0) {\n                key = ns.replace(invalidptn, code === OPENBRACKET ? \"\" : \"-\");\n            }\n            // reset, used to assert if a plugin is moneky-patching the return value\n            code = 1;\n            // cascade/isolate\n            if (cascade === 1) {\n                nscope = ns;\n            } else {\n                nscopealt = ns;\n            }\n            var selectors = [\n                nscope\n            ];\n            var result;\n            // execute plugins, pre-process context\n            if (plugged > 0) {\n                result = proxy(PREPS, input, selectors, selectors, line, column, 0, 0, 0, 0);\n                if (result !== void 0 && typeof result === \"string\") {\n                    input = result;\n                }\n            }\n            // build\n            var output = compile(array, selectors, input, 0, 0);\n            // execute plugins, post-process context\n            if (plugged > 0) {\n                result = proxy(POSTS, output, selectors, selectors, line, column, output.length, 0, 0, 0);\n                // bypass minification\n                if (result !== void 0 && typeof (output = result) !== \"string\") {\n                    code = 0;\n                }\n            }\n            // reset\n            key = \"\";\n            nscope = \"\";\n            nscopealt = \"\";\n            pattern = 0;\n            line = 1;\n            column = 1;\n            return compress * code === 0 ? output : minify(output);\n        }\n        stylis[\"use\"] = use;\n        stylis[\"set\"] = set;\n        if (options !== void 0) {\n            set(options);\n        }\n        return stylis;\n    });\n})(stylis$1);\nvar Stylis = stylis$1.exports;\n\nvar stylisRuleSheet$1 = {exports: {}};\n\n(function(module, exports) {\n    (function(factory) {\n        module[\"exports\"] = factory() ;\n    })(function() {\n        return function(insertRule) {\n            var toSheet = function toSheet(block) {\n                if (block) try {\n                    insertRule(block + \"}\");\n                } catch (e) {}\n            };\n            var delimiter = \"/*|*/\";\n            var needle = delimiter + \"}\";\n            return function ruleSheet(context, content, selectors, parents, line, column, length, ns, depth, at) {\n                switch(context){\n                    // property\n                    case 1:\n                        // @import\n                        if (depth === 0 && content.charCodeAt(0) === 64) return insertRule(content + \";\"), \"\";\n                        break;\n                    // selector\n                    case 2:\n                        if (ns === 0) return content + delimiter;\n                        break;\n                    // at-rule\n                    case 3:\n                        switch(ns){\n                            // @font-face, @page\n                            case 102:\n                            case 112:\n                                return insertRule(selectors[0] + content), \"\";\n                            default:\n                                return content + (at === 0 ? delimiter : \"\");\n                        }\n                    case -2:\n                        content.split(needle).forEach(toSheet);\n                }\n            };\n        };\n    });\n})(stylisRuleSheet$1);\nvar stylisRuleSheet = stylisRuleSheet$1.exports;\n\nvar stylis = new Stylis();\nfunction disableNestingPlugin() {\n    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n        args[_key] = arguments[_key];\n    }\n    var context = args[0], tmp = args[3], parent = tmp === void 0 ? [] : tmp, line = args[4], column = args[5];\n    if (context === 2) {\n        // replace null characters and trim\n        // eslint-disable-next-line no-control-regex\n        parent = (parent[0] || \"\").replace(/\\u0000/g, \"\").trim();\n        if (parent.length > 0 && parent.charAt(0) !== \"@\") {\n            throw new Error(\"Nesting detected at \" + line + \":\" + column + \". \" + \"Unfortunately nesting is not supported by styled-jsx.\");\n        }\n    }\n}\nvar generator;\nvar filename;\nvar offset;\nfunction sourceMapsPlugin() {\n    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n        args[_key] = arguments[_key];\n    }\n    var context = args[0], line = args[4], column = args[5], length = args[6];\n    // Pre-processed, init source map\n    if (context === -1 && generator !== undefined) {\n        generator.addMapping({\n            generated: {\n                line: 1,\n                column: 0\n            },\n            source: filename,\n            original: offset\n        });\n        return;\n    }\n    // Post-processed\n    if (context === -2 && generator !== undefined) {\n        generator = undefined;\n        offset = undefined;\n        filename = undefined;\n        return;\n    }\n    // Selector/property, update source map\n    if ((context === 1 || context === 2) && generator !== undefined) {\n        generator.addMapping({\n            generated: {\n                line: 1,\n                column: length\n            },\n            source: filename,\n            original: {\n                line: line + offset.line,\n                column: column + offset.column\n            }\n        });\n    }\n}\n/**\n * splitRulesPlugin\n * Used to split a blob of css into an array of rules\n * that can inserted via sheet.insertRule\n */ var splitRules = [];\nvar splitRulesPlugin = stylisRuleSheet(function(rule) {\n    splitRules.push(rule);\n});\nstylis.use(disableNestingPlugin);\nstylis.use(sourceMapsPlugin);\nstylis.use(splitRulesPlugin);\nstylis.set({\n    cascade: false,\n    compress: true\n});\n/**\n * Public transform function\n *\n * @param {String} hash\n * @param {String} styles\n * @param {Object} settings\n * @return {string}\n */ function transform(hash, styles, settings) {\n    if (settings === void 0) settings = {};\n    generator = settings.generator;\n    offset = settings.offset;\n    filename = settings.filename;\n    splitRules = [];\n    stylis.set({\n        prefix: typeof settings.vendorPrefixes === \"boolean\" ? settings.vendorPrefixes : true\n    });\n    stylis(hash, styles);\n    if (settings.splitRules) {\n        return splitRules;\n    }\n    return splitRules.join(\"\");\n}\n\nvar GLOBAL_ATTRIBUTE = \"global\";\nvar STYLE_ATTRIBUTE = \"jsx\";\nvar STYLE_COMPONENT = \"_JSXStyle\";\nvar STYLE_COMPONENT_DYNAMIC = \"dynamic\";\nvar STYLE_COMPONENT_ID = \"id\";\n\nfunction _extends$2() {\n    _extends$2 = Object.assign || function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends$2.apply(this, arguments);\n}\nvar _typeof = function(obj) {\n    \"@swc/helpers - typeof\";\n    return obj && typeof Symbol !== \"undefined\" && obj.constructor === Symbol ? \"symbol\" : typeof obj;\n};\nvar concat = function(a, b) {\n    return lib$1.binaryExpression(\"+\", a, b);\n};\nvar and = function(a, b) {\n    return lib$1.logicalExpression(\"&&\", a, b);\n};\nvar or = function(a, b) {\n    return lib$1.logicalExpression(\"||\", a, b);\n};\nvar joinSpreads = function(spreads) {\n    return spreads.reduce(function(acc, curr) {\n        return or(acc, curr);\n    });\n};\nvar hashString = function(str) {\n    return String(stringHash(str));\n};\nvar addClassName = function(path, jsxId) {\n    var jsxIdWithSpace = concat(jsxId, lib$1.stringLiteral(\" \"));\n    var attributes = path.get(\"attributes\");\n    var spreads = [];\n    var className = null;\n    // Find className and collect spreads\n    for(var i = attributes.length - 1, attr; attr = attributes[i]; i--){\n        var node = attr.node;\n        if (lib$1.isJSXSpreadAttribute(attr)) {\n            if (lib$1.isObjectExpression(node.argument)) {\n                var properties = node.argument.properties;\n                var index = properties.findIndex(function(property) {\n                    return property.key.name === \"className\";\n                });\n                if (~index) {\n                    className = attr.get(\"argument\").get(\"properties.\" + index);\n                    // Remove jsx spread attribute if there is only className property\n                    if (properties.length === 1) {\n                        attr.remove();\n                    }\n                    break;\n                }\n            }\n            if (lib$1.isMemberExpression(node.argument) || lib$1.isIdentifier(node.argument)) {\n                var name = node.argument.name;\n                var spreadObj = lib$1.isMemberExpression(node.argument) ? node.argument : lib$1.identifier(name);\n                var attrNameDotClassName = lib$1.memberExpression(spreadObj, lib$1.identifier(\"className\"));\n                spreads.push(// `${name} && ${name}.className != null && ${name}.className`\n                and(spreadObj, and(lib$1.binaryExpression(\"!=\", attrNameDotClassName, lib$1.nullLiteral()), attrNameDotClassName)));\n            }\n            continue;\n        }\n        if (lib$1.isJSXAttribute(attr) && node.name.name === \"className\") {\n            className = attributes[i];\n            break;\n        }\n    }\n    if (className) {\n        var newClassName = className.node.value.expression || className.node.value;\n        newClassName = lib$1.isStringLiteral(newClassName) || lib$1.isTemplateLiteral(newClassName) ? newClassName : or(newClassName, lib$1.stringLiteral(\"\"));\n        className.remove();\n        className = lib$1.jSXExpressionContainer(spreads.length === 0 ? concat(jsxIdWithSpace, newClassName) : concat(jsxIdWithSpace, or(joinSpreads(spreads), newClassName)));\n    } else {\n        className = lib$1.jSXExpressionContainer(spreads.length === 0 ? jsxId : concat(jsxIdWithSpace, or(joinSpreads(spreads), lib$1.stringLiteral(\"\"))));\n    }\n    path.node.attributes.push(lib$1.jSXAttribute(lib$1.jSXIdentifier(\"className\"), className));\n};\nvar getScope = function(path) {\n    return (path.findParent(function(path) {\n        return path.isFunctionDeclaration() || path.isArrowFunctionExpression() || path.isClassMethod();\n    }) || path).scope;\n};\nvar isGlobalEl = function(el) {\n    return el && el.attributes.some(function(param) {\n        var name = param.name;\n        return name && name.name === GLOBAL_ATTRIBUTE;\n    });\n};\nvar isStyledJsx = function(param) {\n    var el = param.node;\n    return lib$1.isJSXElement(el) && el.openingElement.name.name === \"style\" && el.openingElement.attributes.some(function(attr) {\n        return attr.name.name === STYLE_ATTRIBUTE;\n    });\n};\nvar findStyles = function(path) {\n    if (isStyledJsx(path)) {\n        var node = path.node;\n        return isGlobalEl(node.openingElement) ? [\n            path\n        ] : [];\n    }\n    return path.get(\"children\").filter(isStyledJsx);\n};\nvar validateExternalExpressionsVisitor = {\n    Identifier: function Identifier(path) {\n        if (lib$1.isMemberExpression(path.parentPath)) {\n            return;\n        }\n        var name = path.node.name;\n        if (!path.scope.hasBinding(name)) {\n            throw path.buildCodeFrameError(path.getSource());\n        }\n    },\n    MemberExpression: function MemberExpression(path) {\n        var node = path.node;\n        if (!lib$1.isIdentifier(node.object)) {\n            return;\n        }\n        if (!path.scope.hasBinding(node.object.name)) {\n            throw path.buildCodeFrameError(path.getSource());\n        }\n    },\n    ThisExpression: function ThisExpression(path) {\n        throw new Error(path.parentPath.getSource());\n    }\n};\nvar validateExternalExpressions = function(path) {\n    try {\n        path.traverse(validateExternalExpressionsVisitor);\n    } catch (error) {\n        throw path.buildCodeFrameError(\"\\n      Found an `undefined` or invalid value in your styles: `\" + error.message + \"`.\\n\\n      If you are trying to use dynamic styles in external files this is unfortunately not possible yet.\\n      Please put the dynamic parts alongside the component. E.g.\\n\\n      <button>\\n        <style jsx>{externalStylesReference}</style>\\n        <style jsx>{`\\n          button { background-color: ${\" + error.message + \"} }\\n        `}</style>\\n      </button>\\n    \");\n    }\n};\nvar getJSXStyleInfo = function(expr, scope) {\n    var node = expr.node;\n    var location = node.loc;\n    // Assume string literal\n    if (lib$1.isStringLiteral(node)) {\n        return {\n            hash: hashString(node.value),\n            css: node.value,\n            expressions: [],\n            dynamic: false,\n            location: location\n        };\n    }\n    // Simple template literal without expressions\n    if (node.expressions.length === 0) {\n        return {\n            hash: hashString(node.quasis[0].value.raw),\n            css: node.quasis[0].value.raw,\n            expressions: [],\n            dynamic: false,\n            location: location\n        };\n    }\n    // Special treatment for template literals that contain expressions:\n    //\n    // Expressions are replaced with a placeholder\n    // so that the CSS compiler can parse and\n    // transform the css source string\n    // without having to know about js literal expressions.\n    // Later expressions are restored.\n    //\n    // e.g.\n    // p { color: ${myConstant}; }\n    // becomes\n    // p { color: %%styled-jsx-placeholder-${id}%%; }\n    var quasis = node.quasis, expressions = node.expressions;\n    var hash = hashString(expr.getSource().slice(1, -1));\n    var dynamic = Boolean(scope);\n    if (dynamic) {\n        try {\n            var val = expr.evaluate();\n            if (val.confident) {\n                dynamic = false;\n            } else if (val.deopt) {\n                var computedObject = val.deopt.get(\"object\").resolve().evaluate();\n                dynamic = !computedObject.confident;\n            }\n        } catch (_) {}\n    }\n    var css = quasis.reduce(function(css, quasi, index) {\n        return \"\" + css + quasi.value.raw + (quasis.length === index + 1 ? \"\" : \"%%styled-jsx-placeholder-\" + index + \"%%\");\n    }, \"\");\n    return {\n        hash: hash,\n        css: css,\n        expressions: expressions,\n        dynamic: dynamic,\n        location: location\n    };\n};\nvar computeClassNames = function(styles, externalJsxId, styleComponentImportName) {\n    if (styles.length === 0) {\n        return {\n            className: externalJsxId\n        };\n    }\n    var hashes = styles.reduce(function(acc, styles) {\n        if (styles.dynamic === false) {\n            acc.static.push(styles.hash);\n        } else {\n            acc.dynamic.push(styles);\n        }\n        return acc;\n    }, {\n        static: [],\n        dynamic: []\n    });\n    var staticClassName = \"jsx-\" + hashString(hashes.static.join(\",\"));\n    // Static and optionally external classes. E.g.\n    // '[jsx-externalClasses] jsx-staticClasses'\n    if (hashes.dynamic.length === 0) {\n        return {\n            staticClassName: staticClassName,\n            className: externalJsxId ? concat(lib$1.stringLiteral(staticClassName + \" \"), externalJsxId) : lib$1.stringLiteral(staticClassName)\n        };\n    }\n    // _JSXStyle.dynamic([ ['1234', [props.foo, bar, fn(props)]], ... ])\n    var dynamic = lib$1.callExpression(// Callee: _JSXStyle.dynamic\n    lib$1.memberExpression(lib$1.identifier(styleComponentImportName), lib$1.identifier(STYLE_COMPONENT_DYNAMIC)), // Arguments\n    [\n        lib$1.arrayExpression(hashes.dynamic.map(function(styles) {\n            return lib$1.arrayExpression([\n                lib$1.stringLiteral(hashString(styles.hash + staticClassName)),\n                lib$1.arrayExpression(styles.expressions)\n            ]);\n        }))\n    ]);\n    // Dynamic and optionally external classes. E.g.\n    // '[jsx-externalClasses] ' + _JSXStyle.dynamic([ ['1234', [props.foo, bar, fn(props)]], ... ])\n    if (hashes.static.length === 0) {\n        return {\n            staticClassName: staticClassName,\n            className: externalJsxId ? concat(concat(externalJsxId, lib$1.stringLiteral(\" \")), dynamic) : dynamic\n        };\n    }\n    // Static, dynamic and optionally external classes. E.g.\n    // '[jsx-externalClasses] jsx-staticClasses ' + _JSXStyle.dynamic([ ['5678', [props.foo, bar, fn(props)]], ... ])\n    return {\n        staticClassName: staticClassName,\n        className: externalJsxId ? concat(concat(externalJsxId, lib$1.stringLiteral(\" \" + staticClassName + \" \")), dynamic) : concat(lib$1.stringLiteral(\"\" + staticClassName + \" \"), dynamic)\n    };\n};\nvar templateLiteralFromPreprocessedCss = function(css, expressions) {\n    var quasis = [];\n    var finalExpressions = [];\n    var parts = css.split(/(?:%%styled-jsx-placeholder-(\\d+)%%)/g);\n    if (parts.length === 1) {\n        return lib$1.stringLiteral(css);\n    }\n    parts.forEach(function(part, index) {\n        if (index % 2 > 0) {\n            // This is necessary because, after preprocessing, declarations might have been alterate.\n            // eg. properties are auto prefixed and therefore expressions need to match.\n            finalExpressions.push(expressions[part]);\n        } else {\n            quasis.push(part);\n        }\n    });\n    return lib$1.templateLiteral(quasis.map(function(quasi, index) {\n        return lib$1.templateElement({\n            raw: quasi,\n            cooked: quasi\n        }, quasis.length === index + 1);\n    }), finalExpressions);\n};\nvar cssToBabelType = function(css) {\n    if (typeof css === \"string\") {\n        return lib$1.stringLiteral(css);\n    }\n    if (Array.isArray(css)) {\n        return lib$1.arrayExpression(css);\n    }\n    return lib$1.cloneDeep(css);\n};\nvar makeStyledJsxTag = function(id, transformedCss, expressions, styleComponentImportName) {\n    if (expressions === void 0) expressions = [];\n    var css = cssToBabelType(transformedCss);\n    var attributes = [\n        lib$1.jSXAttribute(lib$1.jSXIdentifier(STYLE_COMPONENT_ID), lib$1.jSXExpressionContainer(typeof id === \"string\" ? lib$1.stringLiteral(id) : id))\n    ];\n    if (expressions.length > 0) {\n        attributes.push(lib$1.jSXAttribute(lib$1.jSXIdentifier(STYLE_COMPONENT_DYNAMIC), lib$1.jSXExpressionContainer(lib$1.arrayExpression(expressions))));\n    }\n    return lib$1.jSXElement(lib$1.jSXOpeningElement(lib$1.jSXIdentifier(styleComponentImportName), attributes), lib$1.jSXClosingElement(lib$1.jSXIdentifier(styleComponentImportName)), [\n        lib$1.jSXExpressionContainer(css)\n    ]);\n};\nvar makeSourceMapGenerator = function(file) {\n    var filename = file.sourceFileName;\n    var generator = new SourceMapGenerator({\n        file: filename,\n        sourceRoot: file.sourceRoot\n    });\n    generator.setSourceContent(filename, file.code);\n    return generator;\n};\nvar addSourceMaps = function(code, generator, filename) {\n    var sourceMaps = [\n        convertSourceMap.fromObject(generator).toComment({\n            multiline: true\n        }),\n        \"/*@ sourceURL=\" + filename.replace(/\\\\/g, \"\\\\\\\\\") + \" */\"\n    ];\n    if (Array.isArray(code)) {\n        return code.concat(sourceMaps);\n    }\n    return [\n        code\n    ].concat(sourceMaps).join(\"\\n\");\n};\nvar combinedPluginsCache = {\n    plugins: null,\n    combined: null\n};\nvar combinePlugins = function(plugins) {\n    if (!plugins) {\n        return function(css) {\n            return css;\n        };\n    }\n    var pluginsToString = JSON.stringify(plugins);\n    if (combinedPluginsCache.plugins === pluginsToString) {\n        return combinedPluginsCache.combined;\n    }\n    if (!Array.isArray(plugins) || plugins.some(function(p) {\n        return !Array.isArray(p) && typeof p !== \"string\";\n    })) {\n        throw new Error(\"`plugins` must be an array of plugins names (string) or an array `[plugin-name, {options}]`\");\n    }\n    combinedPluginsCache.plugins = pluginsToString;\n    combinedPluginsCache.combined = plugins.map(function(plugin, i) {\n        var options = {};\n        if (Array.isArray(plugin)) {\n            options = plugin[1] || {};\n            plugin = plugin[0];\n            if (Object.prototype.hasOwnProperty.call(options, \"babel\")) {\n                throw new Error(\"\\n            Error while trying to register the styled-jsx plugin: \" + plugin + \"\\n            The option name `babel` is reserved.\\n          \");\n            }\n        }\n        log(\"Loading plugin from path: \" + plugin);\n        var p = require(plugin);\n        if (p.default) {\n            p = p.default;\n        }\n        var type = typeof p === \"undefined\" ? \"undefined\" : _typeof(p);\n        if (type !== \"function\") {\n            throw new Error(\"Expected plugin \" + plugins[i] + \" to be a function but instead got \" + type);\n        }\n        return {\n            plugin: p,\n            options: options\n        };\n    }).reduce(function(previous, param) {\n        var plugin = param.plugin, options = param.options;\n        return function(css, babelOptions) {\n            return plugin(previous ? previous(css, babelOptions) : css, _extends$2({}, options, {\n                babel: babelOptions\n            }));\n        };\n    }, null);\n    return combinedPluginsCache.combined;\n};\nvar getPrefix = function(isDynamic, id) {\n    return isDynamic ? \".__jsx-style-dynamic-selector\" : \".\" + id;\n};\nvar processCss = function(stylesInfo, options) {\n    var hash = stylesInfo.hash, css = stylesInfo.css, expressions = stylesInfo.expressions, dynamic = stylesInfo.dynamic, location = stylesInfo.location, file = stylesInfo.file, isGlobal = stylesInfo.isGlobal, plugins = stylesInfo.plugins, vendorPrefixes = stylesInfo.vendorPrefixes, sourceMaps = stylesInfo.sourceMaps;\n    var fileInfo = {\n        code: file.code,\n        sourceRoot: file.opts.sourceRoot,\n        filename: file.opts.filename || file.filename\n    };\n    fileInfo.sourceFileName = file.opts.sourceFileName || file.sourceFileName || // According to https://babeljs.io/docs/en/options#source-map-options\n    // filenameRelative = path.relative(file.opts.cwd, file.opts.filename)\n    // sourceFileName = path.basename(filenameRelative)\n    // or simply\n    // sourceFileName = path.basename(file.opts.filename)\n    fileInfo.filename && require$$1__default[\"default\"].basename(fileInfo.filename);\n    var staticClassName = stylesInfo.staticClassName || \"jsx-\" + hashString(hash);\n    var splitRules = options.splitRules;\n    var useSourceMaps = Boolean(sourceMaps) && !splitRules;\n    var pluginsOptions = {\n        location: {\n            start: _extends$2({}, location.start),\n            end: _extends$2({}, location.end)\n        },\n        vendorPrefixes: vendorPrefixes,\n        sourceMaps: useSourceMaps,\n        isGlobal: isGlobal,\n        filename: fileInfo.filename\n    };\n    var transformedCss;\n    if (useSourceMaps) {\n        var generator = makeSourceMapGenerator(fileInfo);\n        var filename = fileInfo.sourceFileName;\n        transformedCss = addSourceMaps(transform(isGlobal ? \"\" : getPrefix(dynamic, staticClassName), plugins(css, pluginsOptions), {\n            generator: generator,\n            offset: location.start,\n            filename: filename,\n            splitRules: splitRules,\n            vendorPrefixes: vendorPrefixes\n        }), generator, filename);\n    } else {\n        transformedCss = transform(isGlobal ? \"\" : getPrefix(dynamic, staticClassName), plugins(css, pluginsOptions), {\n            splitRules: splitRules,\n            vendorPrefixes: vendorPrefixes\n        });\n    }\n    if (expressions.length > 0) {\n        if (typeof transformedCss === \"string\") {\n            transformedCss = templateLiteralFromPreprocessedCss(transformedCss, expressions);\n        } else {\n            transformedCss = transformedCss.map(function(transformedCss) {\n                return templateLiteralFromPreprocessedCss(transformedCss, expressions);\n            });\n        }\n    } else if (Array.isArray(transformedCss)) {\n        transformedCss = transformedCss.map(function(transformedCss) {\n            return lib$1.stringLiteral(transformedCss);\n        });\n    }\n    return {\n        hash: dynamic ? hashString(hash + staticClassName) : hashString(hash),\n        css: transformedCss,\n        expressions: dynamic && expressions\n    };\n};\nvar booleanOption = function(opts) {\n    var ret;\n    opts.some(function(opt) {\n        if (typeof opt === \"boolean\") {\n            ret = opt;\n            return true;\n        }\n        return false;\n    });\n    return ret;\n};\nvar createReactComponentImportDeclaration = function(state) {\n    return lib$1.importDeclaration([\n        lib$1.importDefaultSpecifier(lib$1.identifier(state.styleComponentImportName))\n    ], lib$1.stringLiteral(state.styleModule));\n};\nvar setStateOptions = function(state) {\n    var vendorPrefixes = booleanOption([\n        state.opts.vendorPrefixes,\n        state.file.opts.vendorPrefixes\n    ]);\n    state.opts.vendorPrefixes = typeof vendorPrefixes === \"boolean\" ? vendorPrefixes : true;\n    var sourceMaps = booleanOption([\n        state.opts.sourceMaps,\n        state.file.opts.sourceMaps\n    ]);\n    state.opts.sourceMaps = Boolean(sourceMaps);\n    if (!state.plugins) {\n        state.plugins = combinePlugins(state.opts.plugins);\n    }\n    state.styleModule = typeof state.opts.styleModule === \"string\" ? state.opts.styleModule : \"styled-jsx/style\";\n};\nfunction log(message) {\n    console.log(\"[styled-jsx] \" + message);\n}\n\nfunction _extends$1() {\n    _extends$1 = Object.assign || function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends$1.apply(this, arguments);\n}\nvar isModuleExports = lib$1.buildMatchMemberExpression(\"module.exports\");\nfunction processTaggedTemplateExpression(param) {\n    var type = param.type, path = param.path, file = param.file, splitRules = param.splitRules, plugins = param.plugins, vendorPrefixes = param.vendorPrefixes, sourceMaps = param.sourceMaps, styleComponentImportName = param.styleComponentImportName;\n    var templateLiteral = path.get(\"quasi\");\n    var scope;\n    // Check whether there are undefined references or\n    // references to this.something (e.g. props or state).\n    // We allow dynamic styles only when resolving styles.\n    if (type !== \"resolve\") {\n        validateExternalExpressions(templateLiteral);\n    } else if (!path.scope.path.isProgram()) {\n        scope = getScope(path);\n    }\n    var stylesInfo = getJSXStyleInfo(templateLiteral, scope);\n    var ref = computeClassNames([\n        stylesInfo\n    ], undefined, styleComponentImportName), staticClassName = ref.staticClassName, className = ref.className;\n    var styles = processCss(_extends$1({}, stylesInfo, {\n        staticClassName: staticClassName,\n        file: file,\n        isGlobal: type === \"global\",\n        plugins: plugins,\n        vendorPrefixes: vendorPrefixes,\n        sourceMaps: sourceMaps\n    }), {\n        splitRules: splitRules\n    });\n    if (type === \"resolve\") {\n        var hash = styles.hash, css = styles.css, expressions = styles.expressions;\n        path.replaceWith(// {\n        //   styles: <_JSXStyle ... />,\n        //   className: 'jsx-123'\n        // }\n        lib$1.objectExpression([\n            lib$1.objectProperty(lib$1.identifier(\"styles\"), makeStyledJsxTag(hash, css, expressions, styleComponentImportName)),\n            lib$1.objectProperty(lib$1.identifier(\"className\"), className)\n        ]));\n        return;\n    }\n    var id = path.parentPath.node.id;\n    var baseExportName = id ? id.name : \"default\";\n    var parentPath = baseExportName === \"default\" ? path.parentPath : path.findParent(function(path) {\n        return path.isVariableDeclaration() || path.isAssignmentExpression() && isModuleExports(path.get(\"left\").node);\n    });\n    if (baseExportName !== \"default\" && !parentPath.parentPath.isProgram()) {\n        parentPath = parentPath.parentPath;\n    }\n    var css1 = cssToBabelType(styles.css);\n    var newPath = lib$1.isArrayExpression(css1) ? css1 : lib$1.newExpression(lib$1.identifier(\"String\"), [\n        css1\n    ]);\n    // default exports\n    if (baseExportName === \"default\") {\n        var defaultExportIdentifier = path.scope.generateUidIdentifier(\"defaultExport\");\n        parentPath.insertBefore(lib$1.variableDeclaration(\"const\", [\n            lib$1.variableDeclarator(defaultExportIdentifier, newPath)\n        ]));\n        parentPath.insertBefore(addHash(defaultExportIdentifier, styles.hash));\n        path.replaceWith(defaultExportIdentifier);\n        return;\n    }\n    // local and named exports\n    parentPath.insertAfter(addHash(lib$1.identifier(baseExportName), styles.hash));\n    path.replaceWith(newPath);\n}\nfunction addHash(exportIdentifier, hash) {\n    var value = typeof hash === \"string\" ? lib$1.stringLiteral(hash) : hash;\n    return lib$1.expressionStatement(lib$1.assignmentExpression(\"=\", lib$1.memberExpression(exportIdentifier, lib$1.identifier(\"__hash\")), value));\n}\nvar visitor = {\n    ImportDeclaration: function ImportDeclaration(path, state) {\n        // import css from 'styled-jsx/css'\n        if (path.node.source.value !== \"styled-jsx/css\") {\n            return;\n        }\n        // Find all the imported specifiers.\n        // e.g import css, { global, resolve } from 'styled-jsx/css'\n        // -> ['css', 'global', 'resolve']\n        var specifiersNames = path.node.specifiers.map(function(specifier) {\n            return specifier.local.name;\n        });\n        specifiersNames.forEach(function(tagName) {\n            // Get all the reference paths i.e. the places that use the tagName above\n            // eg.\n            // css`div { color: red }`\n            // css.global`div { color: red }`\n            // global`div { color: red `\n            var binding = path.scope.getBinding(tagName);\n            if (!binding || !Array.isArray(binding.referencePaths)) {\n                return;\n            }\n            // Produces an object containing all the TaggedTemplateExpression paths detected.\n            // The object contains { scoped, global, resolve }\n            var taggedTemplateExpressions = binding.referencePaths.map(function(ref) {\n                return ref.parentPath;\n            }).reduce(function(result, path) {\n                var taggedTemplateExpression;\n                if (path.isTaggedTemplateExpression()) {\n                    // css`` global`` resolve``\n                    taggedTemplateExpression = path;\n                } else if (path.parentPath && path.isMemberExpression() && path.parentPath.isTaggedTemplateExpression()) {\n                    // This part is for css.global`` or css.resolve``\n                    // using the default import css\n                    taggedTemplateExpression = path.parentPath;\n                } else {\n                    return result;\n                }\n                var tag = taggedTemplateExpression.get(\"tag\");\n                var id = tag.isIdentifier() ? tag.node.name : tag.get(\"property\").node.name;\n                if (result[id]) {\n                    result[id].push(taggedTemplateExpression);\n                } else {\n                    result.scoped.push(taggedTemplateExpression);\n                }\n                return result;\n            }, {\n                scoped: [],\n                global: [],\n                resolve: []\n            });\n            var hasJSXStyle = false;\n            var _opts = state.opts, vendorPrefixes = _opts.vendorPrefixes, sourceMaps = _opts.sourceMaps;\n            Object.keys(taggedTemplateExpressions).forEach(function(type) {\n                return taggedTemplateExpressions[type].forEach(function(path) {\n                    hasJSXStyle = true;\n                    // Process each css block\n                    processTaggedTemplateExpression({\n                        type: type,\n                        path: path,\n                        file: state.file,\n                        splitRules: typeof state.opts.optimizeForSpeed === \"boolean\" ? state.opts.optimizeForSpeed : process.env.NODE_ENV === \"production\",\n                        plugins: state.plugins,\n                        vendorPrefixes: vendorPrefixes,\n                        sourceMaps: sourceMaps,\n                        styleComponentImportName: state.styleComponentImportName\n                    });\n                });\n            });\n            var hasCssResolve = hasJSXStyle && taggedTemplateExpressions.resolve.length > 0;\n            // When using the `resolve` helper we need to add an import\n            // for the _JSXStyle component `styled-jsx/style`\n            if (hasCssResolve) {\n                state.file.hasCssResolve = true;\n            }\n        });\n        // Finally remove the import\n        path.remove();\n    }\n};\n\nfunction babelMacro(param) {\n    var createMacro = param.createMacro, MacroError = param.MacroError;\n    var styledJsxMacro = function styledJsxMacro(param) {\n        var references = param.references, state = param.state;\n        setStateOptions(state);\n        // Holds a reference to all the lines where strings are tagged using the `css` tag name.\n        // We print a warning at the end of the macro in case there is any reference to css,\n        // because `css` is generally used as default import name for 'styled-jsx/css'.\n        // People who want to migrate from this macro to pure styled-jsx might have name conflicts issues.\n        var cssReferences = [];\n        // references looks like this\n        // {\n        //    default: [path, path],\n        //    resolve: [path],\n        // }\n        Object.keys(references).forEach(function(refName) {\n            // Enforce `resolve` as named import so people\n            // can only import { resolve } from 'styled-jsx/macro'\n            // or an alias of it eg. { resolve as foo }\n            if (refName !== \"default\" && refName !== \"resolve\") {\n                throw new MacroError(\"Imported an invalid named import: \" + refName + \". Please import: resolve\");\n            }\n            // Start processing the references for refName\n            references[refName].forEach(function(path) {\n                // We grab the parent path. Eg.\n                // path -> css\n                // path.parenPath -> css`div { color: red }`\n                var templateExpression = path.parentPath;\n                // templateExpression member expression?\n                // path -> css\n                // path.parentPath -> css.resolve\n                if (templateExpression.isMemberExpression()) {\n                    // grab .resolve\n                    var tagPropertyName = templateExpression.get(\"property\").node.name;\n                    // Member expressions are only valid on default imports\n                    // eg. import css from 'styled-jsx/macro'\n                    if (refName !== \"default\") {\n                        throw new MacroError(\"Can't use named import \" + path.node.name + \" as a member expression: \" + path.node.name + \".\" + tagPropertyName + \"`div { color: red }` Please use it directly: \" + path.node.name + \"`div { color: red }`\");\n                    }\n                    // Otherwise enforce `css.resolve`\n                    if (tagPropertyName !== \"resolve\") {\n                        throw new MacroError(\"Using an invalid tag: \" + tagPropertyName + \". Please use \" + templateExpression.get(\"object\").node.name + \".resolve\");\n                    }\n                    // Grab the TaggedTemplateExpression\n                    // i.e. css.resolve`div { color: red }`\n                    templateExpression = templateExpression.parentPath;\n                } else {\n                    if (refName === \"default\") {\n                        var name = path.node.name;\n                        throw new MacroError(\"Can't use default import directly eg. \" + name + \"`div { color: red }`. Please use \" + name + \".resolve`div { color: red }` instead.\");\n                    }\n                    if (path.node.name === \"css\") {\n                        // If the path node name is `css` we push it to the references above to emit a warning later.\n                        cssReferences.push(path.node.loc.start.line);\n                    }\n                }\n                if (!state.styleComponentImportName) {\n                    var programPath = path.findParent(function(p) {\n                        return p.isProgram();\n                    });\n                    state.styleComponentImportName = programPath.scope.generateUidIdentifier(STYLE_COMPONENT).name;\n                    var importDeclaration = createReactComponentImportDeclaration(state);\n                    programPath.unshiftContainer(\"body\", importDeclaration);\n                }\n                // Finally transform the path :)\n                processTaggedTemplateExpression({\n                    type: \"resolve\",\n                    path: templateExpression,\n                    file: state.file,\n                    splitRules: typeof state.opts.optimizeForSpeed === \"boolean\" ? state.opts.optimizeForSpeed : process.env.NODE_ENV === \"production\",\n                    plugins: state.plugins,\n                    vendorPrefixes: state.opts.vendorPrefixes,\n                    sourceMaps: state.opts.sourceMaps,\n                    styleComponentImportName: state.styleComponentImportName\n                });\n            });\n        });\n        if (cssReferences.length > 0) {\n            console.warn(\"styled-jsx - Warning - We detected that you named your tag as `css` at lines: \" + cssReferences.join(\", \") + \".\\n\" + \"This tag name is usually used as default import name for `styled-jsx/css`.\\n\" + \"Porting macro code to pure styled-jsx in the future might be a bit problematic.\");\n        }\n    };\n    return createMacro(styledJsxMacro);\n}\n\nfunction babelTest() {\n    return {\n        inherits: default_1,\n        visitor: {\n            JSXOpeningElement: function JSXOpeningElement(path) {\n                var el = path.node;\n                var name = (el.name || {}).name;\n                if (name !== \"style\") {\n                    return;\n                }\n                el.attributes = el.attributes.filter(function(a) {\n                    var name = a.name.name;\n                    return name !== \"jsx\" && name !== \"global\";\n                });\n            }\n        }\n    };\n}\n\nfunction _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n    return arr2;\n}\nfunction _arrayWithoutHoles(arr) {\n    if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\nfunction _extends() {\n    _extends = Object.assign || function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\nfunction _iterableToArray(iter) {\n    if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\nfunction _nonIterableSpread() {\n    throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _toConsumableArray(arr) {\n    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(n);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) {\n    var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n    if (it) return (it = it.call(o)).next.bind(it);\n    if (Array.isArray(o) || (it = unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n        if (it) o = it;\n        var i = 0;\n        return function() {\n            if (i >= o.length) return {\n                done: true\n            };\n            return {\n                done: false,\n                value: o[i++]\n            };\n        };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction macro() {\n    return babelMacro(require(\"babel-plugin-macros\"));\n}\nfunction test() {\n    return babelTest;\n}\nfunction babel(param) {\n    var t = param.types;\n    var jsxVisitors = {\n        JSXOpeningElement: function JSXOpeningElement(path, state) {\n            var el = path.node;\n            var name = (el.name || {}).name;\n            if (!state.hasJSXStyle) {\n                return;\n            }\n            if (state.ignoreClosing === null) {\n                // We keep a counter of elements inside so that we\n                // can keep track of when we exit the parent to reset state\n                // note: if we wished to add an option to turn off\n                // selectors to reach parent elements, it would suffice to\n                // set this to `1` and do an early return instead\n                state.ignoreClosing = 0;\n            }\n            var tag = path.get(\"name\");\n            if (name && name !== \"style\" && name !== state.styleComponentImportName && (name.charAt(0) !== name.charAt(0).toUpperCase() || Object.values(path.scope.bindings).some(function(binding) {\n                return binding.referencePaths.some(function(r) {\n                    return r === tag;\n                });\n            }))) {\n                if (state.className) {\n                    addClassName(path, state.className);\n                }\n            }\n            state.ignoreClosing++;\n        // Next visit will be: JSXElement exit()\n        },\n        JSXElement: {\n            enter: function enter(path, state) {\n                if (state.hasJSXStyle !== null) {\n                    return;\n                }\n                var styles = findStyles(path);\n                if (styles.length === 0) {\n                    return;\n                }\n                state.styles = [];\n                state.externalStyles = [];\n                var scope = getScope(path);\n                for(var _iterator = _createForOfIteratorHelperLoose(styles), _step; !(_step = _iterator()).done;){\n                    var style = _step.value;\n                    // Compute children excluding whitespace\n                    var children = style.get(\"children\").filter(function(c) {\n                        return t.isJSXExpressionContainer(c.node) || // Ignore whitespace around the expression container\n                        t.isJSXText(c.node) && c.node.value.trim() !== \"\";\n                    });\n                    if (children.length !== 1) {\n                        throw path.buildCodeFrameError(\"Expected one child under \" + (\"JSX Style tag, but got \" + children.length + \" \") + \"(eg: <style jsx>{`hi`}</style>)\");\n                    }\n                    var child = children[0];\n                    if (!t.isJSXExpressionContainer(child)) {\n                        throw path.buildCodeFrameError(\"Expected a child of \" + \"type JSXExpressionContainer under JSX Style tag \" + (\"(eg: <style jsx>{`hi`}</style>), got \" + child.type));\n                    }\n                    var expression = child.get(\"expression\");\n                    if (t.isIdentifier(expression)) {\n                        var idName = expression.node.name;\n                        if (expression.scope.hasBinding(idName)) {\n                            var externalStylesIdentifier = t.identifier(idName);\n                            var isGlobal = isGlobalEl(style.get(\"openingElement\").node);\n                            state.externalStyles.push([\n                                t.memberExpression(externalStylesIdentifier, t.identifier(\"__hash\")),\n                                externalStylesIdentifier,\n                                isGlobal\n                            ]);\n                            continue;\n                        }\n                        throw path.buildCodeFrameError(\"The Identifier \" + (\"`\" + expression.getSource() + \"` is either `undefined` or \") + \"it is not an external StyleSheet reference i.e. \" + \"it doesn't come from an `import` or `require` statement\");\n                    }\n                    if (!t.isTemplateLiteral(expression) && !t.isStringLiteral(expression)) {\n                        throw path.buildCodeFrameError(\"Expected a template \" + \"literal or String literal as the child of the \" + \"JSX Style tag (eg: <style jsx>{`some css`}</style>),\" + (\" but got \" + expression.type));\n                    }\n                    state.styles.push(getJSXStyleInfo(expression, scope));\n                }\n                var externalJsxId;\n                if (state.externalStyles.length > 0) {\n                    var expressions = state.externalStyles// Remove globals\n                    .filter(function(s) {\n                        return !s[2];\n                    }).map(function(s) {\n                        return s[0];\n                    });\n                    var expressionsLength = expressions.length;\n                    if (expressionsLength === 0) {\n                        externalJsxId = null;\n                    } else {\n                        // Construct a template literal of this form:\n                        // `jsx-${styles.__scopedHash} jsx-${otherStyles.__scopedHash}`\n                        externalJsxId = t.templateLiteral([\n                            t.templateElement({\n                                raw: \"jsx-\",\n                                cooked: \"jsx-\"\n                            })\n                        ].concat(_toConsumableArray([].concat(new Array(expressionsLength - 1).fill(null)).map(function() {\n                            return t.templateElement({\n                                raw: \" jsx-\",\n                                cooked: \" jsx-\"\n                            });\n                        })), [\n                            t.templateElement({\n                                raw: \"\",\n                                cooked: \"\"\n                            }, true)\n                        ]), expressions);\n                    }\n                }\n                if (state.styles.length > 0 || externalJsxId) {\n                    var ref = computeClassNames(state.styles, externalJsxId, state.styleComponentImportName), staticClassName = ref.staticClassName, className = ref.className;\n                    state.className = className;\n                    state.staticClassName = staticClassName;\n                }\n                state.hasJSXStyle = true;\n                state.file.hasJSXStyle = true;\n            // Next visit will be: JSXOpeningElement\n            },\n            exit: function exit(path, state) {\n                var isGlobal = isGlobalEl(path.node.openingElement);\n                if (state.hasJSXStyle && !--state.ignoreClosing && !isGlobal) {\n                    state.hasJSXStyle = null;\n                    state.className = null;\n                    state.externalJsxId = null;\n                }\n                if (!state.hasJSXStyle || !isStyledJsx(path)) {\n                    return;\n                }\n                if (state.ignoreClosing > 1) {\n                    var styleTagSrc;\n                    try {\n                        styleTagSrc = path.getSource();\n                    } catch (error) {}\n                    throw path.buildCodeFrameError(\"Detected nested style tag\" + (styleTagSrc ? \": \\n\\n\" + styleTagSrc + \"\\n\\n\" : \" \") + \"styled-jsx only allows style tags \" + \"to be direct descendants (children) of the outermost \" + \"JSX element i.e. the subtree root.\");\n                }\n                if (state.externalStyles.length > 0 && path.get(\"children\").filter(function(child) {\n                    if (!t.isJSXExpressionContainer(child)) {\n                        return false;\n                    }\n                    var expression = child.get(\"expression\");\n                    return expression && expression.isIdentifier();\n                }).length === 1) {\n                    var ref = state.externalStyles.shift(), id = ref[0], css = ref[1];\n                    path.replaceWith(makeStyledJsxTag(id, css, [], state.styleComponentImportName));\n                    return;\n                }\n                var _opts = state.opts, vendorPrefixes = _opts.vendorPrefixes, sourceMaps = _opts.sourceMaps;\n                var stylesInfo = _extends({}, state.styles.shift(), {\n                    file: state.file,\n                    staticClassName: state.staticClassName,\n                    isGlobal: isGlobal,\n                    plugins: state.plugins,\n                    vendorPrefixes: vendorPrefixes,\n                    sourceMaps: sourceMaps\n                });\n                var splitRules = typeof state.opts.optimizeForSpeed === \"boolean\" ? state.opts.optimizeForSpeed : process.env.NODE_ENV === \"production\";\n                var ref1 = processCss(stylesInfo, {\n                    splitRules: splitRules\n                }), hash = ref1.hash, css1 = ref1.css, expressions = ref1.expressions;\n                path.replaceWith(makeStyledJsxTag(hash, css1, expressions, state.styleComponentImportName));\n            }\n        }\n    };\n    // only apply JSXFragment visitor if supported\n    if (t.isJSXFragment) {\n        jsxVisitors.JSXFragment = jsxVisitors.JSXElement;\n        jsxVisitors.JSXOpeningFragment = {\n            enter: function enter(path, state) {\n                if (!state.hasJSXStyle) {\n                    return;\n                }\n                if (state.ignoreClosing === null) {\n                    // We keep a counter of elements inside so that we\n                    // can keep track of when we exit the parent to reset state\n                    // note: if we wished to add an option to turn off\n                    // selectors to reach parent elements, it would suffice to\n                    // set this to `1` and do an early return instead\n                    state.ignoreClosing = 0;\n                }\n                state.ignoreClosing++;\n            }\n        };\n    }\n    var visitors = {\n        inherits: default_1,\n        visitor: {\n            Program: {\n                enter: function enter(path, state) {\n                    setStateOptions(state);\n                    state.hasJSXStyle = null;\n                    state.ignoreClosing = null;\n                    state.file.hasJSXStyle = false;\n                    state.file.hasCssResolve = false;\n                    // create unique identifier for _JSXStyle component\n                    state.styleComponentImportName = path.scope.generateUidIdentifier(STYLE_COMPONENT).name;\n                    // we need to beat the arrow function transform and\n                    // possibly others so we traverse from here or else\n                    // dynamic values in classNames could be incorrect\n                    path.traverse(jsxVisitors, state);\n                    // Transpile external styles\n                    path.traverse(visitor, state);\n                },\n                exit: function exit(path, state) {\n                    if (!state.file.hasJSXStyle && !state.file.hasCssResolve) {\n                        return;\n                    }\n                    state.file.hasJSXStyle = true;\n                    var importDeclaration = createReactComponentImportDeclaration(state);\n                    path.unshiftContainer(\"body\", importDeclaration);\n                }\n            }\n        }\n    };\n    return visitors;\n}\n\nexports[\"default\"] = babel;\nexports.macro = macro;\nexports.test = test;\n"
        }
    ]
}