{
    "sourceFile": "src/app/api/orders/route.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 87,
            "patches": [
                {
                    "date": 1747807963741,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1747808107319,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,10 +4,39 @@\n \r\n export async function POST(request: Request) {\r\n   try {\r\n     const orderData = await request.json();\r\n+\r\n+    // Validate required fields\r\n+    const requiredFields = ['orderCode', 'fullName', 'email', 'phone', 'address', 'items', 'total', 'paymentMethod'];\r\n+    const missingFields = requiredFields.filter(field => !orderData[field]);\r\n+    \r\n+    if (missingFields.length > 0) {\r\n+      return NextResponse.json(\r\n+        { ok: false, message: `Missing required fields: ${missingFields.join(', ')}` },\r\n+        { status: 400 }\r\n+      );\r\n+    }\r\n+\r\n+    // Validate items array\r\n+    if (!Array.isArray(orderData.items) || orderData.items.length === 0) {\r\n+      return NextResponse.json(\r\n+        { ok: false, message: 'Order must have at least one item' },\r\n+        { status: 400 }\r\n+      );\r\n+    }\r\n+\r\n     const { db } = await connectToDatabase();\r\n \r\n+    // Check if order code already exists\r\n+    const existingOrder = await db.collection('orders').findOne({ orderCode: orderData.orderCode });\r\n+    if (existingOrder) {\r\n+      return NextResponse.json(\r\n+        { ok: false, message: 'Order code already exists' },\r\n+        { status: 400 }\r\n+      );\r\n+    }\r\n+\r\n     // Tạo đơn hàng mới\r\n     const order = {\r\n       ...orderData,\r\n       _id: new ObjectId(),\r\n@@ -34,9 +63,9 @@\n     });\r\n   } catch (error) {\r\n     console.error('Error creating order:', error);\r\n     return NextResponse.json(\r\n-      { ok: false, message: 'Failed to create order' },\r\n+      { ok: false, message: error instanceof Error ? error.message : 'Failed to create order' },\r\n       { status: 500 }\r\n     );\r\n   }\r\n }\r\n@@ -72,9 +101,9 @@\n     });\r\n   } catch (error) {\r\n     console.error('Error fetching order:', error);\r\n     return NextResponse.json(\r\n-      { ok: false, message: 'Failed to fetch order' },\r\n+      { ok: false, message: error instanceof Error ? error.message : 'Failed to fetch order' },\r\n       { status: 500 }\r\n     );\r\n   }\r\n } \n\\ No newline at end of file\n"
                },
                {
                    "date": 1747887533662,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,7 +1,8 @@\n import { NextResponse } from 'next/server';\r\n import { connectToDatabase } from '@/lib/mongodb';\r\n import { ObjectId } from 'mongodb';\r\n+import { revalidatePath } from 'next/cache';\r\n \r\n export async function POST(request: Request) {\r\n   try {\r\n     const orderData = await request.json();\r\n@@ -35,8 +36,49 @@\n         { status: 400 }\r\n       );\r\n     }\r\n \r\n+    // Cập nhật số lượng sản phẩm\r\n+    for (const item of orderData.items) {\r\n+      const product = await db.collection(\"products\").findOne({ _id: new ObjectId(item.id) });\r\n+      if (!product) {\r\n+        throw new Error(`Product not found: ${item.id}`);\r\n+      }\r\n+\r\n+      // Kiểm tra số lượng tồn kho\r\n+      const size = item.size?.toLowerCase();\r\n+      const quantityField = `quantity${size?.toUpperCase()}`;\r\n+      if (product[quantityField] < item.quantity) {\r\n+        throw new Error(`Insufficient stock for product: ${product.name} (${size})`);\r\n+      }\r\n+\r\n+      // Cập nhật số lượng\r\n+      const updateResult = await db.collection(\"products\").updateOne(\r\n+        { _id: new ObjectId(item.id) },\r\n+        { $inc: { [quantityField]: -item.quantity } }\r\n+      );\r\n+\r\n+      if (updateResult.modifiedCount === 0) {\r\n+        throw new Error(`Failed to update stock for product: ${product.name}`);\r\n+      }\r\n+\r\n+      // Kiểm tra nếu tất cả các size đều hết hàng\r\n+      const updatedProduct = await db.collection(\"products\").findOne({ _id: new ObjectId(item.id) });\r\n+      const allSizesOutOfStock = ['M', 'L', 'XL', 'Hat'].every(size => \r\n+        (updatedProduct[`quantity${size}`] || 0) === 0\r\n+      );\r\n+\r\n+      if (allSizesOutOfStock) {\r\n+        await db.collection(\"products\").updateOne(\r\n+          { _id: new ObjectId(item.id) },\r\n+          { $set: { outOfStock: true } }\r\n+        );\r\n+      }\r\n+\r\n+      // Revalidate trang chi tiết sản phẩm\r\n+      revalidatePath(`/${product.slug}`);\r\n+    }\r\n+\r\n     // Tạo đơn hàng mới\r\n     const order = {\r\n       ...orderData,\r\n       _id: new ObjectId(),\r\n@@ -53,8 +95,11 @@\n     if (!result.acknowledged) {\r\n       throw new Error('Failed to create order');\r\n     }\r\n \r\n+    // Revalidate trang admin products\r\n+    revalidatePath('/admin/products');\r\n+\r\n     return NextResponse.json({\r\n       ok: true,\r\n       order: {\r\n         ...order,\r\n"
                },
                {
                    "date": 1747887625622,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -62,8 +62,12 @@\n       }\r\n \r\n       // Kiểm tra nếu tất cả các size đều hết hàng\r\n       const updatedProduct = await db.collection(\"products\").findOne({ _id: new ObjectId(item.id) });\r\n+      if (!updatedProduct) {\r\n+        throw new Error(`Failed to fetch updated product: ${item.id}`);\r\n+      }\r\n+\r\n       const allSizesOutOfStock = ['M', 'L', 'XL', 'Hat'].every(size => \r\n         (updatedProduct[`quantity${size}`] || 0) === 0\r\n       );\r\n \r\n"
                },
                {
                    "date": 1747889183263,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,11 +1,14 @@\n import { NextResponse } from 'next/server';\r\n import { connectToDatabase } from '@/lib/mongodb';\r\n import { ObjectId } from 'mongodb';\r\n import { revalidatePath } from 'next/cache';\r\n+import { getServerSession } from 'next-auth';\r\n+import { authOptions } from '../auth/[...nextauth]/route';\r\n \r\n export async function POST(request: Request) {\r\n   try {\r\n+    const session = await getServerSession(authOptions);\r\n     const orderData = await request.json();\r\n \r\n     // Validate required fields\r\n     const requiredFields = ['orderCode', 'fullName', 'email', 'phone', 'address', 'items', 'total', 'paymentMethod'];\r\n@@ -81,17 +84,18 @@\n       // Revalidate trang chi tiết sản phẩm\r\n       revalidatePath(`/${product.slug}`);\r\n     }\r\n \r\n-    // Tạo đơn hàng mới\r\n+    // Tạo đơn hàng mới với thông tin người dùng\r\n     const order = {\r\n       ...orderData,\r\n       _id: new ObjectId(),\r\n       createdAt: new Date(),\r\n       updatedAt: new Date(),\r\n       status: 'pending',\r\n       paymentStatus: 'pending',\r\n-      shippingStatus: 'pending'\r\n+      shippingStatus: 'pending',\r\n+      userId: session?.user?.email ? new ObjectId(session.user.email) : null // Thêm userId nếu người dùng đã đăng nhập\r\n     };\r\n \r\n     // Lưu vào database\r\n     const result = await db.collection('orders').insertOne(order);\r\n@@ -99,10 +103,11 @@\n     if (!result.acknowledged) {\r\n       throw new Error('Failed to create order');\r\n     }\r\n \r\n-    // Revalidate trang admin products\r\n+    // Revalidate trang admin products và my-orders\r\n     revalidatePath('/admin/products');\r\n+    revalidatePath('/my-orders');\r\n \r\n     return NextResponse.json({\r\n       ok: true,\r\n       order: {\r\n"
                },
                {
                    "date": 1747889213049,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -93,9 +93,9 @@\n       updatedAt: new Date(),\r\n       status: 'pending',\r\n       paymentStatus: 'pending',\r\n       shippingStatus: 'pending',\r\n-      userId: session?.user?.email ? new ObjectId(session.user.email) : null // Thêm userId nếu người dùng đã đăng nhập\r\n+      userId: session?.user?.email || null // Lưu email của người dùng thay vì ObjectId\r\n     };\r\n \r\n     // Lưu vào database\r\n     const result = await db.collection('orders').insertOne(order);\r\n"
                },
                {
                    "date": 1747889247002,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -126,38 +126,34 @@\n \r\n export async function GET(request: Request) {\r\n   try {\r\n     const { searchParams } = new URL(request.url);\r\n-    const orderCode = searchParams.get('orderCode');\r\n+    const userId = searchParams.get('userId');\r\n \r\n-    if (!orderCode) {\r\n-      return NextResponse.json(\r\n-        { ok: false, message: 'Order code is required' },\r\n-        { status: 400 }\r\n-      );\r\n-    }\r\n-\r\n     const { db } = await connectToDatabase();\r\n-    const order = await db.collection('orders').findOne({ orderCode });\r\n+    let query = {};\r\n \r\n-    if (!order) {\r\n-      return NextResponse.json(\r\n-        { ok: false, message: 'Order not found' },\r\n-        { status: 404 }\r\n-      );\r\n+    // Nếu có userId, lọc theo email của người dùng\r\n+    if (userId) {\r\n+      query = { email: userId };\r\n     }\r\n \r\n+    const orders = await db.collection('orders')\r\n+      .find(query)\r\n+      .sort({ createdAt: -1 })\r\n+      .toArray();\r\n+\r\n     return NextResponse.json({\r\n       ok: true,\r\n-      order: {\r\n+      orders: orders.map(order => ({\r\n         ...order,\r\n         _id: order._id.toString()\r\n-      }\r\n+      }))\r\n     });\r\n   } catch (error) {\r\n-    console.error('Error fetching order:', error);\r\n+    console.error('Error fetching orders:', error);\r\n     return NextResponse.json(\r\n-      { ok: false, message: error instanceof Error ? error.message : 'Failed to fetch order' },\r\n+      { ok: false, message: error instanceof Error ? error.message : 'Failed to fetch orders' },\r\n       { status: 500 }\r\n     );\r\n   }\r\n } \n\\ No newline at end of file\n"
                },
                {
                    "date": 1747889922715,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -2,9 +2,9 @@\n import { connectToDatabase } from '@/lib/mongodb';\r\n import { ObjectId } from 'mongodb';\r\n import { revalidatePath } from 'next/cache';\r\n import { getServerSession } from 'next-auth';\r\n-import { authOptions } from '../auth/[...nextauth]/route';\r\n+import { authOptions } from '@/lib/auth';\r\n \r\n export async function POST(request: Request) {\r\n   try {\r\n     const session = await getServerSession(authOptions);\r\n"
                },
                {
                    "date": 1747890307345,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -126,16 +126,16 @@\n \r\n export async function GET(request: Request) {\r\n   try {\r\n     const { searchParams } = new URL(request.url);\r\n-    const userId = searchParams.get('userId');\r\n+    const email = searchParams.get('userId');\r\n \r\n     const { db } = await connectToDatabase();\r\n     let query = {};\r\n \r\n-    // Nếu có userId, lọc theo email của người dùng\r\n-    if (userId) {\r\n-      query = { email: userId };\r\n+    // Nếu có email, lọc theo email của người dùng\r\n+    if (email) {\r\n+      query = { email };\r\n     }\r\n \r\n     const orders = await db.collection('orders')\r\n       .find(query)\r\n"
                },
                {
                    "date": 1747904631070,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,159 +1,95 @@\n import { NextResponse } from 'next/server';\r\n import { connectToDatabase } from '@/lib/mongodb';\r\n-import { ObjectId } from 'mongodb';\r\n-import { revalidatePath } from 'next/cache';\r\n import { getServerSession } from 'next-auth';\r\n import { authOptions } from '@/lib/auth';\r\n+import { generateOrderCode } from '@/lib/utils';\r\n \r\n-export async function POST(request: Request) {\r\n+export async function POST(req: Request) {\r\n   try {\r\n     const session = await getServerSession(authOptions);\r\n-    const orderData = await request.json();\r\n+    const { items, shippingInfo, totalAmount, email } = await req.json();\r\n \r\n-    // Validate required fields\r\n-    const requiredFields = ['orderCode', 'fullName', 'email', 'phone', 'address', 'items', 'total', 'paymentMethod'];\r\n-    const missingFields = requiredFields.filter(field => !orderData[field]);\r\n-    \r\n-    if (missingFields.length > 0) {\r\n+    if (!items || !shippingInfo || !totalAmount) {\r\n       return NextResponse.json(\r\n-        { ok: false, message: `Missing required fields: ${missingFields.join(', ')}` },\r\n+        { error: 'Missing required fields' },\r\n         { status: 400 }\r\n       );\r\n     }\r\n \r\n-    // Validate items array\r\n-    if (!Array.isArray(orderData.items) || orderData.items.length === 0) {\r\n-      return NextResponse.json(\r\n-        { ok: false, message: 'Order must have at least one item' },\r\n-        { status: 400 }\r\n-      );\r\n-    }\r\n-\r\n     const { db } = await connectToDatabase();\r\n+    const orderCode = generateOrderCode();\r\n \r\n-    // Check if order code already exists\r\n-    const existingOrder = await db.collection('orders').findOne({ orderCode: orderData.orderCode });\r\n-    if (existingOrder) {\r\n-      return NextResponse.json(\r\n-        { ok: false, message: 'Order code already exists' },\r\n-        { status: 400 }\r\n-      );\r\n-    }\r\n-\r\n-    // Cập nhật số lượng sản phẩm\r\n-    for (const item of orderData.items) {\r\n-      const product = await db.collection(\"products\").findOne({ _id: new ObjectId(item.id) });\r\n-      if (!product) {\r\n-        throw new Error(`Product not found: ${item.id}`);\r\n-      }\r\n-\r\n-      // Kiểm tra số lượng tồn kho\r\n-      const size = item.size?.toLowerCase();\r\n-      const quantityField = `quantity${size?.toUpperCase()}`;\r\n-      if (product[quantityField] < item.quantity) {\r\n-        throw new Error(`Insufficient stock for product: ${product.name} (${size})`);\r\n-      }\r\n-\r\n-      // Cập nhật số lượng\r\n-      const updateResult = await db.collection(\"products\").updateOne(\r\n-        { _id: new ObjectId(item.id) },\r\n-        { $inc: { [quantityField]: -item.quantity } }\r\n-      );\r\n-\r\n-      if (updateResult.modifiedCount === 0) {\r\n-        throw new Error(`Failed to update stock for product: ${product.name}`);\r\n-      }\r\n-\r\n-      // Kiểm tra nếu tất cả các size đều hết hàng\r\n-      const updatedProduct = await db.collection(\"products\").findOne({ _id: new ObjectId(item.id) });\r\n-      if (!updatedProduct) {\r\n-        throw new Error(`Failed to fetch updated product: ${item.id}`);\r\n-      }\r\n-\r\n-      const allSizesOutOfStock = ['M', 'L', 'XL', 'Hat'].every(size => \r\n-        (updatedProduct[`quantity${size}`] || 0) === 0\r\n-      );\r\n-\r\n-      if (allSizesOutOfStock) {\r\n-        await db.collection(\"products\").updateOne(\r\n-          { _id: new ObjectId(item.id) },\r\n-          { $set: { outOfStock: true } }\r\n-        );\r\n-      }\r\n-\r\n-      // Revalidate trang chi tiết sản phẩm\r\n-      revalidatePath(`/${product.slug}`);\r\n-    }\r\n-\r\n-    // Tạo đơn hàng mới với thông tin người dùng\r\n+    // Tạo đơn hàng mới\r\n     const order = {\r\n-      ...orderData,\r\n-      _id: new ObjectId(),\r\n+      orderCode,\r\n+      items,\r\n+      shippingInfo,\r\n+      totalAmount,\r\n+      status: 'pending',\r\n       createdAt: new Date(),\r\n-      updatedAt: new Date(),\r\n-      status: 'pending',\r\n+      email: email || (session?.user?.email || 'guest'),\r\n+      userId: session?.user?.id || null,\r\n       paymentStatus: 'pending',\r\n-      shippingStatus: 'pending',\r\n-      userId: session?.user?.email || null // Lưu email của người dùng thay vì ObjectId\r\n+      paymentMethod: 'cod'\r\n     };\r\n \r\n-    // Lưu vào database\r\n     const result = await db.collection('orders').insertOne(order);\r\n \r\n     if (!result.acknowledged) {\r\n       throw new Error('Failed to create order');\r\n     }\r\n \r\n-    // Revalidate trang admin products và my-orders\r\n-    revalidatePath('/admin/products');\r\n-    revalidatePath('/my-orders');\r\n-\r\n     return NextResponse.json({\r\n       ok: true,\r\n+      orderCode,\r\n       order: {\r\n         ...order,\r\n-        _id: order._id.toString()\r\n+        _id: result.insertedId\r\n       }\r\n     });\r\n+\r\n   } catch (error) {\r\n     console.error('Error creating order:', error);\r\n     return NextResponse.json(\r\n-      { ok: false, message: error instanceof Error ? error.message : 'Failed to create order' },\r\n+      { error: 'Failed to create order' },\r\n       { status: 500 }\r\n     );\r\n   }\r\n }\r\n \r\n-export async function GET(request: Request) {\r\n+export async function GET(req: Request) {\r\n   try {\r\n-    const { searchParams } = new URL(request.url);\r\n-    const email = searchParams.get('userId');\r\n+    const session = await getServerSession(authOptions);\r\n+    const { searchParams } = new URL(req.url);\r\n+    const email = searchParams.get('email');\r\n \r\n+    if (!session?.user?.email && !email) {\r\n+      return NextResponse.json(\r\n+        { error: 'Unauthorized' },\r\n+        { status: 401 }\r\n+      );\r\n+    }\r\n+\r\n     const { db } = await connectToDatabase();\r\n-    let query = {};\r\n+    const query = session?.user?.email \r\n+      ? { $or: [{ userId: session.user.id }, { email: session.user.email }] }\r\n+      : { email };\r\n \r\n-    // Nếu có email, lọc theo email của người dùng\r\n-    if (email) {\r\n-      query = { email };\r\n-    }\r\n-\r\n     const orders = await db.collection('orders')\r\n       .find(query)\r\n       .sort({ createdAt: -1 })\r\n       .toArray();\r\n \r\n     return NextResponse.json({\r\n       ok: true,\r\n-      orders: orders.map(order => ({\r\n-        ...order,\r\n-        _id: order._id.toString()\r\n-      }))\r\n+      orders\r\n     });\r\n+\r\n   } catch (error) {\r\n     console.error('Error fetching orders:', error);\r\n     return NextResponse.json(\r\n-      { ok: false, message: error instanceof Error ? error.message : 'Failed to fetch orders' },\r\n+      { error: 'Failed to fetch orders' },\r\n       { status: 500 }\r\n     );\r\n   }\r\n } \n\\ No newline at end of file\n"
                },
                {
                    "date": 1747904657094,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -27,9 +27,9 @@\n       totalAmount,\r\n       status: 'pending',\r\n       createdAt: new Date(),\r\n       email: email || (session?.user?.email || 'guest'),\r\n-      userId: session?.user?.id || null,\r\n+      userId: session?.user?.email || null,\r\n       paymentStatus: 'pending',\r\n       paymentMethod: 'cod'\r\n     };\r\n \r\n@@ -71,9 +71,9 @@\n     }\r\n \r\n     const { db } = await connectToDatabase();\r\n     const query = session?.user?.email \r\n-      ? { $or: [{ userId: session.user.id }, { email: session.user.email }] }\r\n+      ? { $or: [{ userId: session.user.email }, { email: session.user.email }] }\r\n       : { email };\r\n \r\n     const orders = await db.collection('orders')\r\n       .find(query)\r\n"
                },
                {
                    "date": 1747904870439,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,95 +1,159 @@\n import { NextResponse } from 'next/server';\r\n import { connectToDatabase } from '@/lib/mongodb';\r\n+import { ObjectId } from 'mongodb';\r\n+import { revalidatePath } from 'next/cache';\r\n import { getServerSession } from 'next-auth';\r\n import { authOptions } from '@/lib/auth';\r\n-import { generateOrderCode } from '@/lib/utils';\r\n \r\n-export async function POST(req: Request) {\r\n+export async function POST(request: Request) {\r\n   try {\r\n     const session = await getServerSession(authOptions);\r\n-    const { items, shippingInfo, totalAmount, email } = await req.json();\r\n+    const orderData = await request.json();\r\n \r\n-    if (!items || !shippingInfo || !totalAmount) {\r\n+    // Validate required fields\r\n+    const requiredFields = ['orderCode', 'fullName', 'email', 'phone', 'address', 'items', 'total', 'paymentMethod'];\r\n+    const missingFields = requiredFields.filter(field => !orderData[field]);\r\n+    \r\n+    if (missingFields.length > 0) {\r\n       return NextResponse.json(\r\n-        { error: 'Missing required fields' },\r\n+        { ok: false, message: `Missing required fields: ${missingFields.join(', ')}` },\r\n         { status: 400 }\r\n       );\r\n     }\r\n \r\n+    // Validate items array\r\n+    if (!Array.isArray(orderData.items) || orderData.items.length === 0) {\r\n+      return NextResponse.json(\r\n+        { ok: false, message: 'Order must have at least one item' },\r\n+        { status: 400 }\r\n+      );\r\n+    }\r\n+\r\n     const { db } = await connectToDatabase();\r\n-    const orderCode = generateOrderCode();\r\n \r\n-    // Tạo đơn hàng mới\r\n+    // Check if order code already exists\r\n+    const existingOrder = await db.collection('orders').findOne({ orderCode: orderData.orderCode });\r\n+    if (existingOrder) {\r\n+      return NextResponse.json(\r\n+        { ok: false, message: 'Order code already exists' },\r\n+        { status: 400 }\r\n+      );\r\n+    }\r\n+\r\n+    // Cập nhật số lượng sản phẩm\r\n+    for (const item of orderData.items) {\r\n+      const product = await db.collection(\"products\").findOne({ _id: new ObjectId(item.id) });\r\n+      if (!product) {\r\n+        throw new Error(`Product not found: ${item.id}`);\r\n+      }\r\n+\r\n+      // Kiểm tra số lượng tồn kho\r\n+      const size = item.size?.toLowerCase();\r\n+      const quantityField = `quantity${size?.toUpperCase()}`;\r\n+      if (product[quantityField] < item.quantity) {\r\n+        throw new Error(`Insufficient stock for product: ${product.name} (${size})`);\r\n+      }\r\n+\r\n+      // Cập nhật số lượng\r\n+      const updateResult = await db.collection(\"products\").updateOne(\r\n+        { _id: new ObjectId(item.id) },\r\n+        { $inc: { [quantityField]: -item.quantity } }\r\n+      );\r\n+\r\n+      if (updateResult.modifiedCount === 0) {\r\n+        throw new Error(`Failed to update stock for product: ${product.name}`);\r\n+      }\r\n+\r\n+      // Kiểm tra nếu tất cả các size đều hết hàng\r\n+      const updatedProduct = await db.collection(\"products\").findOne({ _id: new ObjectId(item.id) });\r\n+      if (!updatedProduct) {\r\n+        throw new Error(`Failed to fetch updated product: ${item.id}`);\r\n+      }\r\n+\r\n+      const allSizesOutOfStock = ['M', 'L', 'XL', 'Hat'].every(size => \r\n+        (updatedProduct[`quantity${size}`] || 0) === 0\r\n+      );\r\n+\r\n+      if (allSizesOutOfStock) {\r\n+        await db.collection(\"products\").updateOne(\r\n+          { _id: new ObjectId(item.id) },\r\n+          { $set: { outOfStock: true } }\r\n+        );\r\n+      }\r\n+\r\n+      // Revalidate trang chi tiết sản phẩm\r\n+      revalidatePath(`/${product.slug}`);\r\n+    }\r\n+\r\n+    // Tạo đơn hàng mới với thông tin người dùng\r\n     const order = {\r\n-      orderCode,\r\n-      items,\r\n-      shippingInfo,\r\n-      totalAmount,\r\n+      ...orderData,\r\n+      _id: new ObjectId(),\r\n+      createdAt: new Date(),\r\n+      updatedAt: new Date(),\r\n       status: 'pending',\r\n-      createdAt: new Date(),\r\n-      email: email || (session?.user?.email || 'guest'),\r\n-      userId: session?.user?.email || null,\r\n       paymentStatus: 'pending',\r\n-      paymentMethod: 'cod'\r\n+      shippingStatus: 'pending',\r\n+      userId: session?.user?.email || null // Lưu email của người dùng thay vì ObjectId\r\n     };\r\n \r\n+    // Lưu vào database\r\n     const result = await db.collection('orders').insertOne(order);\r\n \r\n     if (!result.acknowledged) {\r\n       throw new Error('Failed to create order');\r\n     }\r\n \r\n+    // Revalidate trang admin products và my-orders\r\n+    revalidatePath('/admin/products');\r\n+    revalidatePath('/my-orders');\r\n+\r\n     return NextResponse.json({\r\n       ok: true,\r\n-      orderCode,\r\n       order: {\r\n         ...order,\r\n-        _id: result.insertedId\r\n+        _id: order._id.toString()\r\n       }\r\n     });\r\n-\r\n   } catch (error) {\r\n     console.error('Error creating order:', error);\r\n     return NextResponse.json(\r\n-      { error: 'Failed to create order' },\r\n+      { ok: false, message: error instanceof Error ? error.message : 'Failed to create order' },\r\n       { status: 500 }\r\n     );\r\n   }\r\n }\r\n \r\n-export async function GET(req: Request) {\r\n+export async function GET(request: Request) {\r\n   try {\r\n-    const session = await getServerSession(authOptions);\r\n-    const { searchParams } = new URL(req.url);\r\n-    const email = searchParams.get('email');\r\n+    const { searchParams } = new URL(request.url);\r\n+    const email = searchParams.get('userId');\r\n \r\n-    if (!session?.user?.email && !email) {\r\n-      return NextResponse.json(\r\n-        { error: 'Unauthorized' },\r\n-        { status: 401 }\r\n-      );\r\n+    const { db } = await connectToDatabase();\r\n+    let query = {};\r\n+\r\n+    // Nếu có email, lọc theo email của người dùng\r\n+    if (email) {\r\n+      query = { email };\r\n     }\r\n \r\n-    const { db } = await connectToDatabase();\r\n-    const query = session?.user?.email \r\n-      ? { $or: [{ userId: session.user.email }, { email: session.user.email }] }\r\n-      : { email };\r\n-\r\n     const orders = await db.collection('orders')\r\n       .find(query)\r\n       .sort({ createdAt: -1 })\r\n       .toArray();\r\n \r\n     return NextResponse.json({\r\n       ok: true,\r\n-      orders\r\n+      orders: orders.map(order => ({\r\n+        ...order,\r\n+        _id: order._id.toString()\r\n+      }))\r\n     });\r\n-\r\n   } catch (error) {\r\n     console.error('Error fetching orders:', error);\r\n     return NextResponse.json(\r\n-      { error: 'Failed to fetch orders' },\r\n+      { ok: false, message: error instanceof Error ? error.message : 'Failed to fetch orders' },\r\n       { status: 500 }\r\n     );\r\n   }\r\n } \n\\ No newline at end of file\n"
                },
                {
                    "date": 1747904962075,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -3,25 +3,15 @@\n import { ObjectId } from 'mongodb';\r\n import { revalidatePath } from 'next/cache';\r\n import { getServerSession } from 'next-auth';\r\n import { authOptions } from '@/lib/auth';\r\n+import { generateOrderCode } from '@/lib/utils';\r\n \r\n export async function POST(request: Request) {\r\n   try {\r\n     const session = await getServerSession(authOptions);\r\n     const orderData = await request.json();\r\n \r\n-    // Validate required fields\r\n-    const requiredFields = ['orderCode', 'fullName', 'email', 'phone', 'address', 'items', 'total', 'paymentMethod'];\r\n-    const missingFields = requiredFields.filter(field => !orderData[field]);\r\n-    \r\n-    if (missingFields.length > 0) {\r\n-      return NextResponse.json(\r\n-        { ok: false, message: `Missing required fields: ${missingFields.join(', ')}` },\r\n-        { status: 400 }\r\n-      );\r\n-    }\r\n-\r\n     // Validate items array\r\n     if (!Array.isArray(orderData.items) || orderData.items.length === 0) {\r\n       return NextResponse.json(\r\n         { ok: false, message: 'Order must have at least one item' },\r\n@@ -29,18 +19,10 @@\n       );\r\n     }\r\n \r\n     const { db } = await connectToDatabase();\r\n+    const orderCode = generateOrderCode();\r\n \r\n-    // Check if order code already exists\r\n-    const existingOrder = await db.collection('orders').findOne({ orderCode: orderData.orderCode });\r\n-    if (existingOrder) {\r\n-      return NextResponse.json(\r\n-        { ok: false, message: 'Order code already exists' },\r\n-        { status: 400 }\r\n-      );\r\n-    }\r\n-\r\n     // Cập nhật số lượng sản phẩm\r\n     for (const item of orderData.items) {\r\n       const product = await db.collection(\"products\").findOne({ _id: new ObjectId(item.id) });\r\n       if (!product) {\r\n@@ -86,16 +68,23 @@\n     }\r\n \r\n     // Tạo đơn hàng mới với thông tin người dùng\r\n     const order = {\r\n-      ...orderData,\r\n-      _id: new ObjectId(),\r\n+      orderCode,\r\n+      items: orderData.items,\r\n+      total: orderData.total,\r\n+      status: 'pending',\r\n       createdAt: new Date(),\r\n       updatedAt: new Date(),\r\n-      status: 'pending',\r\n       paymentStatus: 'pending',\r\n       shippingStatus: 'pending',\r\n-      userId: session?.user?.email || null // Lưu email của người dùng thay vì ObjectId\r\n+      // Thông tin người dùng (có thể null nếu không đăng nhập)\r\n+      fullName: orderData.fullName || null,\r\n+      email: orderData.email || null,\r\n+      phone: orderData.phone || null,\r\n+      address: orderData.address || null,\r\n+      paymentMethod: orderData.paymentMethod || 'cod',\r\n+      userId: session?.user?.email || null\r\n     };\r\n \r\n     // Lưu vào database\r\n     const result = await db.collection('orders').insertOne(order);\r\n@@ -111,9 +100,9 @@\n     return NextResponse.json({\r\n       ok: true,\r\n       order: {\r\n         ...order,\r\n-        _id: order._id.toString()\r\n+        _id: result.insertedId.toString()\r\n       }\r\n     });\r\n   } catch (error) {\r\n     console.error('Error creating order:', error);\r\n@@ -125,18 +114,23 @@\n }\r\n \r\n export async function GET(request: Request) {\r\n   try {\r\n+    const session = await getServerSession(authOptions);\r\n     const { searchParams } = new URL(request.url);\r\n-    const email = searchParams.get('userId');\r\n+    const email = searchParams.get('email');\r\n \r\n     const { db } = await connectToDatabase();\r\n     let query = {};\r\n \r\n-    // Nếu có email, lọc theo email của người dùng\r\n+    // Nếu có email từ query params, lọc theo email\r\n     if (email) {\r\n       query = { email };\r\n     }\r\n+    // Nếu đã đăng nhập, lọc theo email của user\r\n+    else if (session?.user?.email) {\r\n+      query = { email: session.user.email };\r\n+    }\r\n \r\n     const orders = await db.collection('orders')\r\n       .find(query)\r\n       .sort({ createdAt: -1 })\r\n"
                },
                {
                    "date": 1747905021191,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,153 +1,95 @@\n import { NextResponse } from 'next/server';\r\n import { connectToDatabase } from '@/lib/mongodb';\r\n-import { ObjectId } from 'mongodb';\r\n-import { revalidatePath } from 'next/cache';\r\n import { getServerSession } from 'next-auth';\r\n import { authOptions } from '@/lib/auth';\r\n import { generateOrderCode } from '@/lib/utils';\r\n \r\n-export async function POST(request: Request) {\r\n+export async function POST(req: Request) {\r\n   try {\r\n     const session = await getServerSession(authOptions);\r\n-    const orderData = await request.json();\r\n+    const { items, shippingInfo, totalAmount, email } = await req.json();\r\n \r\n-    // Validate items array\r\n-    if (!Array.isArray(orderData.items) || orderData.items.length === 0) {\r\n+    if (!items || !shippingInfo || !totalAmount) {\r\n       return NextResponse.json(\r\n-        { ok: false, message: 'Order must have at least one item' },\r\n+        { error: 'Missing required fields' },\r\n         { status: 400 }\r\n       );\r\n     }\r\n \r\n     const { db } = await connectToDatabase();\r\n     const orderCode = generateOrderCode();\r\n \r\n-    // Cập nhật số lượng sản phẩm\r\n-    for (const item of orderData.items) {\r\n-      const product = await db.collection(\"products\").findOne({ _id: new ObjectId(item.id) });\r\n-      if (!product) {\r\n-        throw new Error(`Product not found: ${item.id}`);\r\n-      }\r\n-\r\n-      // Kiểm tra số lượng tồn kho\r\n-      const size = item.size?.toLowerCase();\r\n-      const quantityField = `quantity${size?.toUpperCase()}`;\r\n-      if (product[quantityField] < item.quantity) {\r\n-        throw new Error(`Insufficient stock for product: ${product.name} (${size})`);\r\n-      }\r\n-\r\n-      // Cập nhật số lượng\r\n-      const updateResult = await db.collection(\"products\").updateOne(\r\n-        { _id: new ObjectId(item.id) },\r\n-        { $inc: { [quantityField]: -item.quantity } }\r\n-      );\r\n-\r\n-      if (updateResult.modifiedCount === 0) {\r\n-        throw new Error(`Failed to update stock for product: ${product.name}`);\r\n-      }\r\n-\r\n-      // Kiểm tra nếu tất cả các size đều hết hàng\r\n-      const updatedProduct = await db.collection(\"products\").findOne({ _id: new ObjectId(item.id) });\r\n-      if (!updatedProduct) {\r\n-        throw new Error(`Failed to fetch updated product: ${item.id}`);\r\n-      }\r\n-\r\n-      const allSizesOutOfStock = ['M', 'L', 'XL', 'Hat'].every(size => \r\n-        (updatedProduct[`quantity${size}`] || 0) === 0\r\n-      );\r\n-\r\n-      if (allSizesOutOfStock) {\r\n-        await db.collection(\"products\").updateOne(\r\n-          { _id: new ObjectId(item.id) },\r\n-          { $set: { outOfStock: true } }\r\n-        );\r\n-      }\r\n-\r\n-      // Revalidate trang chi tiết sản phẩm\r\n-      revalidatePath(`/${product.slug}`);\r\n-    }\r\n-\r\n-    // Tạo đơn hàng mới với thông tin người dùng\r\n+    // Tạo đơn hàng mới\r\n     const order = {\r\n       orderCode,\r\n-      items: orderData.items,\r\n-      total: orderData.total,\r\n+      items,\r\n+      shippingInfo,\r\n+      totalAmount,\r\n       status: 'pending',\r\n       createdAt: new Date(),\r\n-      updatedAt: new Date(),\r\n+      email: email || (session?.user?.email || 'guest'),\r\n+      userId: session?.user?.email || null,\r\n       paymentStatus: 'pending',\r\n-      shippingStatus: 'pending',\r\n-      // Thông tin người dùng (có thể null nếu không đăng nhập)\r\n-      fullName: orderData.fullName || null,\r\n-      email: orderData.email || null,\r\n-      phone: orderData.phone || null,\r\n-      address: orderData.address || null,\r\n-      paymentMethod: orderData.paymentMethod || 'cod',\r\n-      userId: session?.user?.email || null\r\n+      paymentMethod: 'cod'\r\n     };\r\n \r\n-    // Lưu vào database\r\n     const result = await db.collection('orders').insertOne(order);\r\n \r\n     if (!result.acknowledged) {\r\n       throw new Error('Failed to create order');\r\n     }\r\n \r\n-    // Revalidate trang admin products và my-orders\r\n-    revalidatePath('/admin/products');\r\n-    revalidatePath('/my-orders');\r\n-\r\n     return NextResponse.json({\r\n       ok: true,\r\n+      orderCode,\r\n       order: {\r\n         ...order,\r\n-        _id: result.insertedId.toString()\r\n+        _id: result.insertedId\r\n       }\r\n     });\r\n+\r\n   } catch (error) {\r\n     console.error('Error creating order:', error);\r\n     return NextResponse.json(\r\n-      { ok: false, message: error instanceof Error ? error.message : 'Failed to create order' },\r\n+      { error: 'Failed to create order' },\r\n       { status: 500 }\r\n     );\r\n   }\r\n }\r\n \r\n-export async function GET(request: Request) {\r\n+export async function GET(req: Request) {\r\n   try {\r\n     const session = await getServerSession(authOptions);\r\n-    const { searchParams } = new URL(request.url);\r\n+    const { searchParams } = new URL(req.url);\r\n     const email = searchParams.get('email');\r\n \r\n+    if (!session?.user?.email && !email) {\r\n+      return NextResponse.json(\r\n+        { error: 'Unauthorized' },\r\n+        { status: 401 }\r\n+      );\r\n+    }\r\n+\r\n     const { db } = await connectToDatabase();\r\n-    let query = {};\r\n+    const query = session?.user?.email \r\n+      ? { $or: [{ userId: session.user.email }, { email: session.user.email }] }\r\n+      : { email };\r\n \r\n-    // Nếu có email từ query params, lọc theo email\r\n-    if (email) {\r\n-      query = { email };\r\n-    }\r\n-    // Nếu đã đăng nhập, lọc theo email của user\r\n-    else if (session?.user?.email) {\r\n-      query = { email: session.user.email };\r\n-    }\r\n-\r\n     const orders = await db.collection('orders')\r\n       .find(query)\r\n       .sort({ createdAt: -1 })\r\n       .toArray();\r\n \r\n     return NextResponse.json({\r\n       ok: true,\r\n-      orders: orders.map(order => ({\r\n-        ...order,\r\n-        _id: order._id.toString()\r\n-      }))\r\n+      orders\r\n     });\r\n+\r\n   } catch (error) {\r\n     console.error('Error fetching orders:', error);\r\n     return NextResponse.json(\r\n-      { ok: false, message: error instanceof Error ? error.message : 'Failed to fetch orders' },\r\n+      { error: 'Failed to fetch orders' },\r\n       { status: 500 }\r\n     );\r\n   }\r\n } \n\\ No newline at end of file\n"
                },
                {
                    "date": 1747905239707,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -6,13 +6,14 @@\n \r\n export async function POST(req: Request) {\r\n   try {\r\n     const session = await getServerSession(authOptions);\r\n-    const { items, shippingInfo, totalAmount, email } = await req.json();\r\n+    const orderData = await req.json();\r\n \r\n-    if (!items || !shippingInfo || !totalAmount) {\r\n+    // Validate items array\r\n+    if (!Array.isArray(orderData.items) || orderData.items.length === 0) {\r\n       return NextResponse.json(\r\n-        { error: 'Missing required fields' },\r\n+        { error: 'Order must have at least one item' },\r\n         { status: 400 }\r\n       );\r\n     }\r\n \r\n@@ -21,17 +22,23 @@\n \r\n     // Tạo đơn hàng mới\r\n     const order = {\r\n       orderCode,\r\n-      items,\r\n-      shippingInfo,\r\n-      totalAmount,\r\n+      items: orderData.items,\r\n+      totalAmount: orderData.totalAmount || orderData.total,\r\n       status: 'pending',\r\n       createdAt: new Date(),\r\n-      email: email || (session?.user?.email || 'guest'),\r\n+      email: orderData.email || session?.user?.email || 'guest',\r\n       userId: session?.user?.email || null,\r\n       paymentStatus: 'pending',\r\n-      paymentMethod: 'cod'\r\n+      paymentMethod: 'cod',\r\n+      // Thông tin giao hàng\r\n+      fullName: orderData.fullName || null,\r\n+      phone: orderData.phone || null,\r\n+      address: orderData.address || null,\r\n+      // Thông tin bổ sung\r\n+      note: orderData.note || null,\r\n+      shippingMethod: orderData.shippingMethod || 'standard'\r\n     };\r\n \r\n     const result = await db.collection('orders').insertOne(order);\r\n \r\n"
                },
                {
                    "date": 1747905782152,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -29,13 +29,16 @@\n       createdAt: new Date(),\r\n       email: orderData.email || session?.user?.email || 'guest',\r\n       userId: session?.user?.email || null,\r\n       paymentStatus: 'pending',\r\n-      paymentMethod: 'cod',\r\n+      paymentMethod: orderData.paymentMethod || 'cod',\r\n       // Thông tin giao hàng\r\n-      fullName: orderData.fullName || null,\r\n-      phone: orderData.phone || null,\r\n-      address: orderData.address || null,\r\n+      fullName: orderData.fullName,\r\n+      phone: orderData.phone,\r\n+      address: orderData.address,\r\n+      ward: orderData.ward,\r\n+      district: orderData.district,\r\n+      province: orderData.province,\r\n       // Thông tin bổ sung\r\n       note: orderData.note || null,\r\n       shippingMethod: orderData.shippingMethod || 'standard'\r\n     };\r\n"
                },
                {
                    "date": 1747906576289,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -69,22 +69,19 @@\n \r\n export async function GET(req: Request) {\r\n   try {\r\n     const session = await getServerSession(authOptions);\r\n-    const { searchParams } = new URL(req.url);\r\n-    const email = searchParams.get('email');\r\n-\r\n-    if (!session?.user?.email && !email) {\r\n+    \r\n+    // Chỉ cho phép xem đơn hàng khi đã đăng nhập\r\n+    if (!session?.user?.email) {\r\n       return NextResponse.json(\r\n         { error: 'Unauthorized' },\r\n         { status: 401 }\r\n       );\r\n     }\r\n \r\n     const { db } = await connectToDatabase();\r\n-    const query = session?.user?.email \r\n-      ? { $or: [{ userId: session.user.email }, { email: session.user.email }] }\r\n-      : { email };\r\n+    const query = { userId: session.user.email };\r\n \r\n     const orders = await db.collection('orders')\r\n       .find(query)\r\n       .sort({ createdAt: -1 })\r\n"
                },
                {
                    "date": 1747907208059,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -11,9 +11,9 @@\n \r\n     // Validate items array\r\n     if (!Array.isArray(orderData.items) || orderData.items.length === 0) {\r\n       return NextResponse.json(\r\n-        { error: 'Order must have at least one item' },\r\n+        { ok: false, message: 'Order must have at least one item' },\r\n         { status: 400 }\r\n       );\r\n     }\r\n \r\n@@ -23,12 +23,12 @@\n     // Tạo đơn hàng mới\r\n     const order = {\r\n       orderCode,\r\n       items: orderData.items,\r\n-      totalAmount: orderData.totalAmount || orderData.total,\r\n+      total: orderData.total,\r\n       status: 'pending',\r\n       createdAt: new Date(),\r\n-      email: orderData.email || session?.user?.email || 'guest',\r\n+      email: orderData.email,\r\n       userId: session?.user?.email || null,\r\n       paymentStatus: 'pending',\r\n       paymentMethod: orderData.paymentMethod || 'cod',\r\n       // Thông tin giao hàng\r\n@@ -50,19 +50,18 @@\n     }\r\n \r\n     return NextResponse.json({\r\n       ok: true,\r\n-      orderCode,\r\n       order: {\r\n         ...order,\r\n-        _id: result.insertedId\r\n+        _id: result.insertedId.toString()\r\n       }\r\n     });\r\n \r\n   } catch (error) {\r\n     console.error('Error creating order:', error);\r\n     return NextResponse.json(\r\n-      { error: 'Failed to create order' },\r\n+      { ok: false, message: error instanceof Error ? error.message : 'Failed to create order' },\r\n       { status: 500 }\r\n     );\r\n   }\r\n }\r\n@@ -73,9 +72,9 @@\n     \r\n     // Chỉ cho phép xem đơn hàng khi đã đăng nhập\r\n     if (!session?.user?.email) {\r\n       return NextResponse.json(\r\n-        { error: 'Unauthorized' },\r\n+        { ok: false, message: 'Unauthorized' },\r\n         { status: 401 }\r\n       );\r\n     }\r\n \r\n@@ -88,15 +87,18 @@\n       .toArray();\r\n \r\n     return NextResponse.json({\r\n       ok: true,\r\n-      orders\r\n+      orders: orders.map(order => ({\r\n+        ...order,\r\n+        _id: order._id.toString()\r\n+      }))\r\n     });\r\n \r\n   } catch (error) {\r\n     console.error('Error fetching orders:', error);\r\n     return NextResponse.json(\r\n-      { error: 'Failed to fetch orders' },\r\n+      { ok: false, message: error instanceof Error ? error.message : 'Failed to fetch orders' },\r\n       { status: 500 }\r\n     );\r\n   }\r\n } \n\\ No newline at end of file\n"
                },
                {
                    "date": 1747907506329,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -7,11 +7,14 @@\n export async function POST(req: Request) {\r\n   try {\r\n     const session = await getServerSession(authOptions);\r\n     const orderData = await req.json();\r\n+    \r\n+    console.log('Received order data:', orderData);\r\n \r\n     // Validate items array\r\n     if (!Array.isArray(orderData.items) || orderData.items.length === 0) {\r\n+      console.error('Invalid items array:', orderData.items);\r\n       return NextResponse.json(\r\n         { ok: false, message: 'Order must have at least one item' },\r\n         { status: 400 }\r\n       );\r\n@@ -42,14 +45,19 @@\n       note: orderData.note || null,\r\n       shippingMethod: orderData.shippingMethod || 'standard'\r\n     };\r\n \r\n+    console.log('Creating order with data:', order);\r\n+\r\n     const result = await db.collection('orders').insertOne(order);\r\n \r\n     if (!result.acknowledged) {\r\n+      console.error('Failed to insert order:', result);\r\n       throw new Error('Failed to create order');\r\n     }\r\n \r\n+    console.log('Order created successfully:', result.insertedId);\r\n+\r\n     return NextResponse.json({\r\n       ok: true,\r\n       order: {\r\n         ...order,\r\n"
                },
                {
                    "date": 1747907751685,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -10,8 +10,20 @@\n     const orderData = await req.json();\r\n     \r\n     console.log('Received order data:', orderData);\r\n \r\n+    // Validate required fields\r\n+    const requiredFields = ['email', 'fullName', 'phone', 'address', 'ward', 'district', 'province', 'items', 'total'];\r\n+    const missingFields = requiredFields.filter(field => !orderData[field]);\r\n+    \r\n+    if (missingFields.length > 0) {\r\n+      console.error('Missing required fields:', missingFields);\r\n+      return NextResponse.json(\r\n+        { ok: false, message: `Missing required fields: ${missingFields.join(', ')}` },\r\n+        { status: 400 }\r\n+      );\r\n+    }\r\n+\r\n     // Validate items array\r\n     if (!Array.isArray(orderData.items) || orderData.items.length === 0) {\r\n       console.error('Invalid items array:', orderData.items);\r\n       return NextResponse.json(\r\n@@ -19,8 +31,17 @@\n         { status: 400 }\r\n       );\r\n     }\r\n \r\n+    // Validate total amount\r\n+    if (typeof orderData.total !== 'number' || orderData.total <= 0) {\r\n+      console.error('Invalid total amount:', orderData.total);\r\n+      return NextResponse.json(\r\n+        { ok: false, message: 'Invalid total amount' },\r\n+        { status: 400 }\r\n+      );\r\n+    }\r\n+\r\n     const { db } = await connectToDatabase();\r\n     const orderCode = generateOrderCode();\r\n \r\n     // Tạo đơn hàng mới\r\n@@ -47,8 +68,18 @@\n     };\r\n \r\n     console.log('Creating order with data:', order);\r\n \r\n+    // Kiểm tra xem orderCode đã tồn tại chưa\r\n+    const existingOrder = await db.collection('orders').findOne({ orderCode });\r\n+    if (existingOrder) {\r\n+      console.error('Order code already exists:', orderCode);\r\n+      return NextResponse.json(\r\n+        { ok: false, message: 'Order code already exists' },\r\n+        { status: 400 }\r\n+      );\r\n+    }\r\n+\r\n     const result = await db.collection('orders').insertOne(order);\r\n \r\n     if (!result.acknowledged) {\r\n       console.error('Failed to insert order:', result);\r\n@@ -56,13 +87,20 @@\n     }\r\n \r\n     console.log('Order created successfully:', result.insertedId);\r\n \r\n+    // Verify the order was created\r\n+    const createdOrder = await db.collection('orders').findOne({ _id: result.insertedId });\r\n+    if (!createdOrder) {\r\n+      console.error('Order not found after creation');\r\n+      throw new Error('Order not found after creation');\r\n+    }\r\n+\r\n     return NextResponse.json({\r\n       ok: true,\r\n       order: {\r\n-        ...order,\r\n-        _id: result.insertedId.toString()\r\n+        ...createdOrder,\r\n+        _id: createdOrder._id.toString()\r\n       }\r\n     });\r\n \r\n   } catch (error) {\r\n"
                },
                {
                    "date": 1747908252156,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -2,108 +2,125 @@\n import { connectToDatabase } from '@/lib/mongodb';\r\n import { getServerSession } from 'next-auth';\r\n import { authOptions } from '@/lib/auth';\r\n import { generateOrderCode } from '@/lib/utils';\r\n+import { ObjectId } from 'mongodb';\r\n \r\n-export async function POST(req: Request) {\r\n+export async function POST(request: Request) {\r\n   try {\r\n     const session = await getServerSession(authOptions);\r\n-    const orderData = await req.json();\r\n-    \r\n+    const orderData = await request.json();\r\n+\r\n     console.log('Received order data:', orderData);\r\n \r\n     // Validate required fields\r\n-    const requiredFields = ['email', 'fullName', 'phone', 'address', 'ward', 'district', 'province', 'items', 'total'];\r\n-    const missingFields = requiredFields.filter(field => !orderData[field]);\r\n-    \r\n-    if (missingFields.length > 0) {\r\n-      console.error('Missing required fields:', missingFields);\r\n+    if (!orderData.items || orderData.items.length === 0) {\r\n+      console.error('Invalid items array');\r\n       return NextResponse.json(\r\n-        { ok: false, message: `Missing required fields: ${missingFields.join(', ')}` },\r\n+        { ok: false, message: 'Order must have at least one item' },\r\n         { status: 400 }\r\n       );\r\n     }\r\n \r\n-    // Validate items array\r\n-    if (!Array.isArray(orderData.items) || orderData.items.length === 0) {\r\n-      console.error('Invalid items array:', orderData.items);\r\n+    // Validate other required fields\r\n+    const requiredFields = ['email', 'fullName', 'phone', 'address', 'ward', 'district', 'province', 'total'];\r\n+    const missingFields = requiredFields.filter(field => !orderData[field]);\r\n+    if (missingFields.length > 0) {\r\n+      console.error('Missing required fields:', missingFields);\r\n       return NextResponse.json(\r\n-        { ok: false, message: 'Order must have at least one item' },\r\n+        { ok: false, message: `Missing required fields: ${missingFields.join(', ')}` },\r\n         { status: 400 }\r\n       );\r\n     }\r\n \r\n-    // Validate total amount\r\n+    // Validate total\r\n     if (typeof orderData.total !== 'number' || orderData.total <= 0) {\r\n-      console.error('Invalid total amount:', orderData.total);\r\n+      console.error('Invalid total amount');\r\n       return NextResponse.json(\r\n-        { ok: false, message: 'Invalid total amount' },\r\n+        { ok: false, message: 'Invalid order total' },\r\n         { status: 400 }\r\n       );\r\n     }\r\n \r\n     const { db } = await connectToDatabase();\r\n+\r\n+    // Check if orderCode already exists\r\n     const orderCode = generateOrderCode();\r\n+    const existingOrder = await db.collection('orders').findOne({ orderCode });\r\n+    if (existingOrder) {\r\n+      console.error('Order code already exists:', orderCode);\r\n+      return NextResponse.json(\r\n+        { ok: false, message: 'Failed to create order. Please try again.' },\r\n+        { status: 500 }\r\n+      );\r\n+    }\r\n \r\n-    // Tạo đơn hàng mới\r\n+    // Create order object\r\n     const order = {\r\n       orderCode,\r\n       items: orderData.items,\r\n       total: orderData.total,\r\n       status: 'pending',\r\n-      createdAt: new Date(),\r\n+      createdAt: new Date().toISOString(),\r\n+      userId: session?.user?.email || null,\r\n       email: orderData.email,\r\n-      userId: session?.user?.email || null,\r\n-      paymentStatus: 'pending',\r\n-      paymentMethod: orderData.paymentMethod || 'cod',\r\n-      // Thông tin giao hàng\r\n       fullName: orderData.fullName,\r\n       phone: orderData.phone,\r\n       address: orderData.address,\r\n       ward: orderData.ward,\r\n       district: orderData.district,\r\n       province: orderData.province,\r\n-      // Thông tin bổ sung\r\n-      note: orderData.note || null,\r\n-      shippingMethod: orderData.shippingMethod || 'standard'\r\n+      paymentMethod: orderData.paymentMethod\r\n     };\r\n \r\n-    console.log('Creating order with data:', order);\r\n+    console.log('Creating order:', order);\r\n \r\n-    // Kiểm tra xem orderCode đã tồn tại chưa\r\n-    const existingOrder = await db.collection('orders').findOne({ orderCode });\r\n-    if (existingOrder) {\r\n-      console.error('Order code already exists:', orderCode);\r\n-      return NextResponse.json(\r\n-        { ok: false, message: 'Order code already exists' },\r\n-        { status: 400 }\r\n-      );\r\n-    }\r\n+    // Start a session for transaction\r\n+    const session = await db.client.startSession();\r\n+    try {\r\n+      await session.withTransaction(async () => {\r\n+        // Insert order\r\n+        const result = await db.collection('orders').insertOne(order, { session });\r\n+        console.log('Order created with ID:', result.insertedId);\r\n \r\n-    const result = await db.collection('orders').insertOne(order);\r\n+        // Update product quantities\r\n+        for (const item of orderData.items) {\r\n+          const updateResult = await db.collection('products').updateOne(\r\n+            { \r\n+              _id: new ObjectId(item.id),\r\n+              'sizes.size': item.size,\r\n+              'sizes.quantity': { $gte: item.quantity }\r\n+            },\r\n+            { \r\n+              $inc: { 'sizes.$.quantity': -item.quantity }\r\n+            },\r\n+            { session }\r\n+          );\r\n \r\n-    if (!result.acknowledged) {\r\n-      console.error('Failed to insert order:', result);\r\n-      throw new Error('Failed to create order');\r\n-    }\r\n+          if (updateResult.matchedCount === 0) {\r\n+            throw new Error(`Insufficient stock for product ${item.id} with size ${item.size}`);\r\n+          }\r\n \r\n-    console.log('Order created successfully:', result.insertedId);\r\n+          console.log(`Updated quantity for product ${item.id}, size ${item.size}`);\r\n+        }\r\n+      });\r\n \r\n-    // Verify the order was created\r\n-    const createdOrder = await db.collection('orders').findOne({ _id: result.insertedId });\r\n-    if (!createdOrder) {\r\n-      console.error('Order not found after creation');\r\n-      throw new Error('Order not found after creation');\r\n+      return NextResponse.json({\r\n+        ok: true,\r\n+        order: {\r\n+          ...order,\r\n+          _id: result.insertedId.toString()\r\n+        }\r\n+      });\r\n+    } catch (error) {\r\n+      console.error('Transaction failed:', error);\r\n+      return NextResponse.json(\r\n+        { ok: false, message: error instanceof Error ? error.message : 'Failed to create order' },\r\n+        { status: 500 }\r\n+      );\r\n+    } finally {\r\n+      await session.endSession();\r\n     }\r\n-\r\n-    return NextResponse.json({\r\n-      ok: true,\r\n-      order: {\r\n-        ...createdOrder,\r\n-        _id: createdOrder._id.toString()\r\n-      }\r\n-    });\r\n-\r\n   } catch (error) {\r\n     console.error('Error creating order:', error);\r\n     return NextResponse.json(\r\n       { ok: false, message: error instanceof Error ? error.message : 'Failed to create order' },\r\n"
                },
                {
                    "date": 1747908267847,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -3,12 +3,15 @@\n import { getServerSession } from 'next-auth';\r\n import { authOptions } from '@/lib/auth';\r\n import { generateOrderCode } from '@/lib/utils';\r\n import { ObjectId } from 'mongodb';\r\n+import { ClientSession } from 'mongodb';\r\n \r\n export async function POST(request: Request) {\r\n+  let dbSession: ClientSession | null = null;\r\n+  \r\n   try {\r\n-    const session = await getServerSession(authOptions);\r\n+    const authSession = await getServerSession(authOptions);\r\n     const orderData = await request.json();\r\n \r\n     console.log('Received order data:', orderData);\r\n \r\n@@ -60,9 +63,9 @@\n       items: orderData.items,\r\n       total: orderData.total,\r\n       status: 'pending',\r\n       createdAt: new Date().toISOString(),\r\n-      userId: session?.user?.email || null,\r\n+      userId: authSession?.user?.email || null,\r\n       email: orderData.email,\r\n       fullName: orderData.fullName,\r\n       phone: orderData.phone,\r\n       address: orderData.address,\r\n@@ -74,59 +77,56 @@\n \r\n     console.log('Creating order:', order);\r\n \r\n     // Start a session for transaction\r\n-    const session = await db.client.startSession();\r\n-    try {\r\n-      await session.withTransaction(async () => {\r\n-        // Insert order\r\n-        const result = await db.collection('orders').insertOne(order, { session });\r\n-        console.log('Order created with ID:', result.insertedId);\r\n+    dbSession = await db.client.startSession();\r\n+    let result;\r\n \r\n-        // Update product quantities\r\n-        for (const item of orderData.items) {\r\n-          const updateResult = await db.collection('products').updateOne(\r\n-            { \r\n-              _id: new ObjectId(item.id),\r\n-              'sizes.size': item.size,\r\n-              'sizes.quantity': { $gte: item.quantity }\r\n-            },\r\n-            { \r\n-              $inc: { 'sizes.$.quantity': -item.quantity }\r\n-            },\r\n-            { session }\r\n-          );\r\n+    await dbSession.withTransaction(async () => {\r\n+      // Insert order\r\n+      result = await db.collection('orders').insertOne(order, { session: dbSession });\r\n+      console.log('Order created with ID:', result.insertedId);\r\n \r\n-          if (updateResult.matchedCount === 0) {\r\n-            throw new Error(`Insufficient stock for product ${item.id} with size ${item.size}`);\r\n-          }\r\n+      // Update product quantities\r\n+      for (const item of orderData.items) {\r\n+        const updateResult = await db.collection('products').updateOne(\r\n+          { \r\n+            _id: new ObjectId(item.id),\r\n+            'sizes.size': item.size,\r\n+            'sizes.quantity': { $gte: item.quantity }\r\n+          },\r\n+          { \r\n+            $inc: { 'sizes.$.quantity': -item.quantity }\r\n+          },\r\n+          { session: dbSession }\r\n+        );\r\n \r\n-          console.log(`Updated quantity for product ${item.id}, size ${item.size}`);\r\n+        if (updateResult.matchedCount === 0) {\r\n+          throw new Error(`Insufficient stock for product ${item.id} with size ${item.size}`);\r\n         }\r\n-      });\r\n \r\n-      return NextResponse.json({\r\n-        ok: true,\r\n-        order: {\r\n-          ...order,\r\n-          _id: result.insertedId.toString()\r\n-        }\r\n-      });\r\n-    } catch (error) {\r\n-      console.error('Transaction failed:', error);\r\n-      return NextResponse.json(\r\n-        { ok: false, message: error instanceof Error ? error.message : 'Failed to create order' },\r\n-        { status: 500 }\r\n-      );\r\n-    } finally {\r\n-      await session.endSession();\r\n-    }\r\n+        console.log(`Updated quantity for product ${item.id}, size ${item.size}`);\r\n+      }\r\n+    });\r\n+\r\n+    return NextResponse.json({\r\n+      ok: true,\r\n+      order: {\r\n+        ...order,\r\n+        _id: result.insertedId.toString()\r\n+      }\r\n+    });\r\n+\r\n   } catch (error) {\r\n     console.error('Error creating order:', error);\r\n     return NextResponse.json(\r\n       { ok: false, message: error instanceof Error ? error.message : 'Failed to create order' },\r\n       { status: 500 }\r\n     );\r\n+  } finally {\r\n+    if (dbSession) {\r\n+      await dbSession.endSession();\r\n+    }\r\n   }\r\n }\r\n \r\n export async function GET(req: Request) {\r\n"
                },
                {
                    "date": 1747908286155,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -2,13 +2,12 @@\n import { connectToDatabase } from '@/lib/mongodb';\r\n import { getServerSession } from 'next-auth';\r\n import { authOptions } from '@/lib/auth';\r\n import { generateOrderCode } from '@/lib/utils';\r\n-import { ObjectId } from 'mongodb';\r\n-import { ClientSession } from 'mongodb';\r\n+import { ObjectId, MongoClient } from 'mongodb';\r\n \r\n export async function POST(request: Request) {\r\n-  let dbSession: ClientSession | null = null;\r\n+  let mongoClient: MongoClient | null = null;\r\n   \r\n   try {\r\n     const authSession = await getServerSession(authOptions);\r\n     const orderData = await request.json();\r\n@@ -43,9 +42,10 @@\n         { status: 400 }\r\n       );\r\n     }\r\n \r\n-    const { db } = await connectToDatabase();\r\n+    const { db, client } = await connectToDatabase();\r\n+    mongoClient = client;\r\n \r\n     // Check if orderCode already exists\r\n     const orderCode = generateOrderCode();\r\n     const existingOrder = await db.collection('orders').findOne({ orderCode });\r\n@@ -77,55 +77,64 @@\n \r\n     console.log('Creating order:', order);\r\n \r\n     // Start a session for transaction\r\n-    dbSession = await db.client.startSession();\r\n-    let result;\r\n+    const dbSession = await client.startSession();\r\n+    let insertedId: string | undefined;\r\n \r\n-    await dbSession.withTransaction(async () => {\r\n-      // Insert order\r\n-      result = await db.collection('orders').insertOne(order, { session: dbSession });\r\n-      console.log('Order created with ID:', result.insertedId);\r\n+    try {\r\n+      await dbSession.withTransaction(async () => {\r\n+        // Insert order\r\n+        const result = await db.collection('orders').insertOne(order, { session: dbSession });\r\n+        console.log('Order created with ID:', result.insertedId);\r\n+        insertedId = result.insertedId.toString();\r\n \r\n-      // Update product quantities\r\n-      for (const item of orderData.items) {\r\n-        const updateResult = await db.collection('products').updateOne(\r\n-          { \r\n-            _id: new ObjectId(item.id),\r\n-            'sizes.size': item.size,\r\n-            'sizes.quantity': { $gte: item.quantity }\r\n-          },\r\n-          { \r\n-            $inc: { 'sizes.$.quantity': -item.quantity }\r\n-          },\r\n-          { session: dbSession }\r\n-        );\r\n+        // Update product quantities\r\n+        for (const item of orderData.items) {\r\n+          const updateResult = await db.collection('products').updateOne(\r\n+            { \r\n+              _id: new ObjectId(item.id),\r\n+              'sizes.size': item.size,\r\n+              'sizes.quantity': { $gte: item.quantity }\r\n+            },\r\n+            { \r\n+              $inc: { 'sizes.$.quantity': -item.quantity }\r\n+            },\r\n+            { session: dbSession }\r\n+          );\r\n \r\n-        if (updateResult.matchedCount === 0) {\r\n-          throw new Error(`Insufficient stock for product ${item.id} with size ${item.size}`);\r\n+          if (updateResult.matchedCount === 0) {\r\n+            throw new Error(`Insufficient stock for product ${item.id} with size ${item.size}`);\r\n+          }\r\n+\r\n+          console.log(`Updated quantity for product ${item.id}, size ${item.size}`);\r\n         }\r\n+      });\r\n \r\n-        console.log(`Updated quantity for product ${item.id}, size ${item.size}`);\r\n+      if (!insertedId) {\r\n+        throw new Error('Failed to create order');\r\n       }\r\n-    });\r\n \r\n-    return NextResponse.json({\r\n-      ok: true,\r\n-      order: {\r\n-        ...order,\r\n-        _id: result.insertedId.toString()\r\n-      }\r\n-    });\r\n+      return NextResponse.json({\r\n+        ok: true,\r\n+        order: {\r\n+          ...order,\r\n+          _id: insertedId\r\n+        }\r\n+      });\r\n+    } finally {\r\n+      await dbSession.endSession();\r\n+    }\r\n \r\n   } catch (error) {\r\n     console.error('Error creating order:', error);\r\n     return NextResponse.json(\r\n       { ok: false, message: error instanceof Error ? error.message : 'Failed to create order' },\r\n       { status: 500 }\r\n     );\r\n   } finally {\r\n-    if (dbSession) {\r\n-      await dbSession.endSession();\r\n+    if (mongoClient) {\r\n+      await mongoClient.close();\r\n     }\r\n   }\r\n }\r\n \r\n"
                },
                {
                    "date": 1747908417505,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -2,140 +2,76 @@\n import { connectToDatabase } from '@/lib/mongodb';\r\n import { getServerSession } from 'next-auth';\r\n import { authOptions } from '@/lib/auth';\r\n import { generateOrderCode } from '@/lib/utils';\r\n-import { ObjectId, MongoClient } from 'mongodb';\r\n \r\n-export async function POST(request: Request) {\r\n-  let mongoClient: MongoClient | null = null;\r\n-  \r\n+export async function POST(req: Request) {\r\n   try {\r\n-    const authSession = await getServerSession(authOptions);\r\n-    const orderData = await request.json();\r\n-\r\n+    const session = await getServerSession(authOptions);\r\n+    const orderData = await req.json();\r\n+    \r\n     console.log('Received order data:', orderData);\r\n \r\n-    // Validate required fields\r\n-    if (!orderData.items || orderData.items.length === 0) {\r\n-      console.error('Invalid items array');\r\n+    // Validate items array\r\n+    if (!Array.isArray(orderData.items) || orderData.items.length === 0) {\r\n+      console.error('Invalid items array:', orderData.items);\r\n       return NextResponse.json(\r\n         { ok: false, message: 'Order must have at least one item' },\r\n         { status: 400 }\r\n       );\r\n     }\r\n \r\n-    // Validate other required fields\r\n-    const requiredFields = ['email', 'fullName', 'phone', 'address', 'ward', 'district', 'province', 'total'];\r\n-    const missingFields = requiredFields.filter(field => !orderData[field]);\r\n-    if (missingFields.length > 0) {\r\n-      console.error('Missing required fields:', missingFields);\r\n-      return NextResponse.json(\r\n-        { ok: false, message: `Missing required fields: ${missingFields.join(', ')}` },\r\n-        { status: 400 }\r\n-      );\r\n-    }\r\n-\r\n-    // Validate total\r\n-    if (typeof orderData.total !== 'number' || orderData.total <= 0) {\r\n-      console.error('Invalid total amount');\r\n-      return NextResponse.json(\r\n-        { ok: false, message: 'Invalid order total' },\r\n-        { status: 400 }\r\n-      );\r\n-    }\r\n-\r\n-    const { db, client } = await connectToDatabase();\r\n-    mongoClient = client;\r\n-\r\n-    // Check if orderCode already exists\r\n+    const { db } = await connectToDatabase();\r\n     const orderCode = generateOrderCode();\r\n-    const existingOrder = await db.collection('orders').findOne({ orderCode });\r\n-    if (existingOrder) {\r\n-      console.error('Order code already exists:', orderCode);\r\n-      return NextResponse.json(\r\n-        { ok: false, message: 'Failed to create order. Please try again.' },\r\n-        { status: 500 }\r\n-      );\r\n-    }\r\n \r\n-    // Create order object\r\n+    // Tạo đơn hàng mới\r\n     const order = {\r\n       orderCode,\r\n       items: orderData.items,\r\n       total: orderData.total,\r\n       status: 'pending',\r\n-      createdAt: new Date().toISOString(),\r\n-      userId: authSession?.user?.email || null,\r\n+      createdAt: new Date(),\r\n       email: orderData.email,\r\n+      userId: session?.user?.email || null,\r\n+      paymentStatus: 'pending',\r\n+      paymentMethod: orderData.paymentMethod || 'cod',\r\n+      // Thông tin giao hàng\r\n       fullName: orderData.fullName,\r\n       phone: orderData.phone,\r\n       address: orderData.address,\r\n       ward: orderData.ward,\r\n       district: orderData.district,\r\n       province: orderData.province,\r\n-      paymentMethod: orderData.paymentMethod\r\n+      // Thông tin bổ sung\r\n+      note: orderData.note || null,\r\n+      shippingMethod: orderData.shippingMethod || 'standard'\r\n     };\r\n \r\n-    console.log('Creating order:', order);\r\n+    console.log('Creating order with data:', order);\r\n \r\n-    // Start a session for transaction\r\n-    const dbSession = await client.startSession();\r\n-    let insertedId: string | undefined;\r\n+    const result = await db.collection('orders').insertOne(order);\r\n \r\n-    try {\r\n-      await dbSession.withTransaction(async () => {\r\n-        // Insert order\r\n-        const result = await db.collection('orders').insertOne(order, { session: dbSession });\r\n-        console.log('Order created with ID:', result.insertedId);\r\n-        insertedId = result.insertedId.toString();\r\n+    if (!result.acknowledged) {\r\n+      console.error('Failed to insert order:', result);\r\n+      throw new Error('Failed to create order');\r\n+    }\r\n \r\n-        // Update product quantities\r\n-        for (const item of orderData.items) {\r\n-          const updateResult = await db.collection('products').updateOne(\r\n-            { \r\n-              _id: new ObjectId(item.id),\r\n-              'sizes.size': item.size,\r\n-              'sizes.quantity': { $gte: item.quantity }\r\n-            },\r\n-            { \r\n-              $inc: { 'sizes.$.quantity': -item.quantity }\r\n-            },\r\n-            { session: dbSession }\r\n-          );\r\n+    console.log('Order created successfully:', result.insertedId);\r\n \r\n-          if (updateResult.matchedCount === 0) {\r\n-            throw new Error(`Insufficient stock for product ${item.id} with size ${item.size}`);\r\n-          }\r\n-\r\n-          console.log(`Updated quantity for product ${item.id}, size ${item.size}`);\r\n-        }\r\n-      });\r\n-\r\n-      if (!insertedId) {\r\n-        throw new Error('Failed to create order');\r\n+    return NextResponse.json({\r\n+      ok: true,\r\n+      order: {\r\n+        ...order,\r\n+        _id: result.insertedId.toString()\r\n       }\r\n+    });\r\n \r\n-      return NextResponse.json({\r\n-        ok: true,\r\n-        order: {\r\n-          ...order,\r\n-          _id: insertedId\r\n-        }\r\n-      });\r\n-    } finally {\r\n-      await dbSession.endSession();\r\n-    }\r\n-\r\n   } catch (error) {\r\n     console.error('Error creating order:', error);\r\n     return NextResponse.json(\r\n       { ok: false, message: error instanceof Error ? error.message : 'Failed to create order' },\r\n       { status: 500 }\r\n     );\r\n-  } finally {\r\n-    if (mongoClient) {\r\n-      await mongoClient.close();\r\n-    }\r\n   }\r\n }\r\n \r\n export async function GET(req: Request) {\r\n"
                },
                {
                    "date": 1747908545316,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -2,8 +2,9 @@\n import { connectToDatabase } from '@/lib/mongodb';\r\n import { getServerSession } from 'next-auth';\r\n import { authOptions } from '@/lib/auth';\r\n import { generateOrderCode } from '@/lib/utils';\r\n+import { ObjectId } from 'mongodb';\r\n \r\n export async function POST(req: Request) {\r\n   try {\r\n     const session = await getServerSession(authOptions);\r\n@@ -47,25 +48,65 @@\n     };\r\n \r\n     console.log('Creating order with data:', order);\r\n \r\n-    const result = await db.collection('orders').insertOne(order);\r\n+    // Start a session for transaction\r\n+    const dbSession = await db.client.startSession();\r\n+    let result;\r\n \r\n-    if (!result.acknowledged) {\r\n-      console.error('Failed to insert order:', result);\r\n-      throw new Error('Failed to create order');\r\n-    }\r\n+    try {\r\n+      await dbSession.withTransaction(async () => {\r\n+        // Insert order\r\n+        result = await db.collection('orders').insertOne(order, { session: dbSession });\r\n+        console.log('Order created with ID:', result.insertedId);\r\n \r\n-    console.log('Order created successfully:', result.insertedId);\r\n+        // Update product quantities\r\n+        for (const item of orderData.items) {\r\n+          console.log('Updating quantity for item:', item);\r\n+          \r\n+          // Find the product and update the specific size quantity\r\n+          const updateResult = await db.collection('products').updateOne(\r\n+            { \r\n+              _id: new ObjectId(item.id),\r\n+              'sizes.size': item.size,\r\n+              'sizes.quantity': { $gte: item.quantity }\r\n+            },\r\n+            { \r\n+              $inc: { 'sizes.$.quantity': -item.quantity }\r\n+            },\r\n+            { session: dbSession }\r\n+          );\r\n \r\n-    return NextResponse.json({\r\n-      ok: true,\r\n-      order: {\r\n-        ...order,\r\n-        _id: result.insertedId.toString()\r\n+          if (updateResult.matchedCount === 0) {\r\n+            throw new Error(`Insufficient stock for product ${item.id} with size ${item.size}`);\r\n+          }\r\n+\r\n+          console.log(`Updated quantity for product ${item.id}, size ${item.size}`);\r\n+        }\r\n+      });\r\n+\r\n+      if (!result.acknowledged) {\r\n+        throw new Error('Failed to create order');\r\n       }\r\n-    });\r\n \r\n+      return NextResponse.json({\r\n+        ok: true,\r\n+        order: {\r\n+          ...order,\r\n+          _id: result.insertedId.toString()\r\n+        }\r\n+      });\r\n+\r\n+    } catch (error) {\r\n+      console.error('Transaction failed:', error);\r\n+      return NextResponse.json(\r\n+        { ok: false, message: error instanceof Error ? error.message : 'Failed to create order' },\r\n+        { status: 500 }\r\n+      );\r\n+    } finally {\r\n+      await dbSession.endSession();\r\n+    }\r\n+\r\n   } catch (error) {\r\n     console.error('Error creating order:', error);\r\n     return NextResponse.json(\r\n       { ok: false, message: error instanceof Error ? error.message : 'Failed to create order' },\r\n"
                },
                {
                    "date": 1747908564266,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -2,11 +2,13 @@\n import { connectToDatabase } from '@/lib/mongodb';\r\n import { getServerSession } from 'next-auth';\r\n import { authOptions } from '@/lib/auth';\r\n import { generateOrderCode } from '@/lib/utils';\r\n-import { ObjectId } from 'mongodb';\r\n+import { ObjectId, MongoClient } from 'mongodb';\r\n \r\n export async function POST(req: Request) {\r\n+  let mongoClient: MongoClient | null = null;\r\n+  \r\n   try {\r\n     const session = await getServerSession(authOptions);\r\n     const orderData = await req.json();\r\n     \r\n@@ -20,9 +22,10 @@\n         { status: 400 }\r\n       );\r\n     }\r\n \r\n-    const { db } = await connectToDatabase();\r\n+    const { db, client } = await connectToDatabase();\r\n+    mongoClient = client;\r\n     const orderCode = generateOrderCode();\r\n \r\n     // Tạo đơn hàng mới\r\n     const order = {\r\n@@ -49,16 +52,17 @@\n \r\n     console.log('Creating order with data:', order);\r\n \r\n     // Start a session for transaction\r\n-    const dbSession = await db.client.startSession();\r\n-    let result;\r\n+    const dbSession = await client.startSession();\r\n+    let insertedId: string | undefined;\r\n \r\n     try {\r\n       await dbSession.withTransaction(async () => {\r\n         // Insert order\r\n-        result = await db.collection('orders').insertOne(order, { session: dbSession });\r\n+        const result = await db.collection('orders').insertOne(order, { session: dbSession });\r\n         console.log('Order created with ID:', result.insertedId);\r\n+        insertedId = result.insertedId.toString();\r\n \r\n         // Update product quantities\r\n         for (const item of orderData.items) {\r\n           console.log('Updating quantity for item:', item);\r\n@@ -83,17 +87,17 @@\n           console.log(`Updated quantity for product ${item.id}, size ${item.size}`);\r\n         }\r\n       });\r\n \r\n-      if (!result.acknowledged) {\r\n+      if (!insertedId) {\r\n         throw new Error('Failed to create order');\r\n       }\r\n \r\n       return NextResponse.json({\r\n         ok: true,\r\n         order: {\r\n           ...order,\r\n-          _id: result.insertedId.toString()\r\n+          _id: insertedId\r\n         }\r\n       });\r\n \r\n     } catch (error) {\r\n@@ -111,8 +115,12 @@\n     return NextResponse.json(\r\n       { ok: false, message: error instanceof Error ? error.message : 'Failed to create order' },\r\n       { status: 500 }\r\n     );\r\n+  } finally {\r\n+    if (mongoClient) {\r\n+      await mongoClient.close();\r\n+    }\r\n   }\r\n }\r\n \r\n export async function GET(req: Request) {\r\n"
                },
                {
                    "date": 1747908835612,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -11,9 +11,9 @@\n   try {\r\n     const session = await getServerSession(authOptions);\r\n     const orderData = await req.json();\r\n     \r\n-    console.log('Received order data:', orderData);\r\n+    console.log('Received order data:', JSON.stringify(orderData, null, 2));\r\n \r\n     // Validate items array\r\n     if (!Array.isArray(orderData.items) || orderData.items.length === 0) {\r\n       console.error('Invalid items array:', orderData.items);\r\n@@ -22,8 +22,33 @@\n         { status: 400 }\r\n       );\r\n     }\r\n \r\n+    // Validate each item in the order\r\n+    for (const item of orderData.items) {\r\n+      if (!item.id) {\r\n+        console.error('Item missing id:', item);\r\n+        return NextResponse.json(\r\n+          { ok: false, message: 'Each item must have an id' },\r\n+          { status: 400 }\r\n+        );\r\n+      }\r\n+      if (!item.size) {\r\n+        console.error('Item missing size:', item);\r\n+        return NextResponse.json(\r\n+          { ok: false, message: 'Each item must have a size' },\r\n+          { status: 400 }\r\n+        );\r\n+      }\r\n+      if (!item.quantity || item.quantity <= 0) {\r\n+        console.error('Item missing or invalid quantity:', item);\r\n+        return NextResponse.json(\r\n+          { ok: false, message: 'Each item must have a valid quantity' },\r\n+          { status: 400 }\r\n+        );\r\n+      }\r\n+    }\r\n+\r\n     const { db, client } = await connectToDatabase();\r\n     mongoClient = client;\r\n     const orderCode = generateOrderCode();\r\n \r\n@@ -49,9 +74,9 @@\n       note: orderData.note || null,\r\n       shippingMethod: orderData.shippingMethod || 'standard'\r\n     };\r\n \r\n-    console.log('Creating order with data:', order);\r\n+    console.log('Creating order with data:', JSON.stringify(order, null, 2));\r\n \r\n     // Start a session for transaction\r\n     const dbSession = await client.startSession();\r\n     let insertedId: string | undefined;\r\n@@ -64,9 +89,9 @@\n         insertedId = result.insertedId.toString();\r\n \r\n         // Update product quantities\r\n         for (const item of orderData.items) {\r\n-          console.log('Updating quantity for item:', item);\r\n+          console.log('Updating quantity for item:', JSON.stringify(item, null, 2));\r\n           \r\n           // Find the product and update the specific size quantity\r\n           const updateResult = await db.collection('products').updateOne(\r\n             { \r\n@@ -79,8 +104,10 @@\n             },\r\n             { session: dbSession }\r\n           );\r\n \r\n+          console.log('Update result:', updateResult);\r\n+\r\n           if (updateResult.matchedCount === 0) {\r\n             throw new Error(`Insufficient stock for product ${item.id} with size ${item.size}`);\r\n           }\r\n \r\n"
                },
                {
                    "date": 1747909012030,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -91,25 +91,47 @@\n         // Update product quantities\r\n         for (const item of orderData.items) {\r\n           console.log('Updating quantity for item:', JSON.stringify(item, null, 2));\r\n           \r\n-          // Find the product and update the specific size quantity\r\n+          // First, find the product to check its current structure\r\n+          const product = await db.collection('products').findOne(\r\n+            { _id: new ObjectId(item.id) },\r\n+            { session: dbSession }\r\n+          );\r\n+\r\n+          if (!product) {\r\n+            throw new Error(`Product ${item.id} not found`);\r\n+          }\r\n+\r\n+          console.log('Found product:', JSON.stringify(product, null, 2));\r\n+\r\n+          // Find the size index in the sizes array\r\n+          const sizeIndex = product.sizes.findIndex(s => s.size === item.size);\r\n+          if (sizeIndex === -1) {\r\n+            throw new Error(`Size ${item.size} not found for product ${item.id}`);\r\n+          }\r\n+\r\n+          // Check if there's enough quantity\r\n+          if (product.sizes[sizeIndex].quantity < item.quantity) {\r\n+            throw new Error(`Insufficient stock for product ${item.id} with size ${item.size}`);\r\n+          }\r\n+\r\n+          // Update the quantity\r\n           const updateResult = await db.collection('products').updateOne(\r\n             { \r\n               _id: new ObjectId(item.id),\r\n-              'sizes.size': item.size,\r\n-              'sizes.quantity': { $gte: item.quantity }\r\n+              [`sizes.${sizeIndex}.size`]: item.size\r\n             },\r\n             { \r\n-              $inc: { 'sizes.$.quantity': -item.quantity }\r\n+              $inc: { [`sizes.${sizeIndex}.quantity`]: -item.quantity }\r\n             },\r\n             { session: dbSession }\r\n           );\r\n \r\n           console.log('Update result:', updateResult);\r\n \r\n           if (updateResult.matchedCount === 0) {\r\n-            throw new Error(`Insufficient stock for product ${item.id} with size ${item.size}`);\r\n+            throw new Error(`Failed to update quantity for product ${item.id} with size ${item.size}`);\r\n           }\r\n \r\n           console.log(`Updated quantity for product ${item.id}, size ${item.size}`);\r\n         }\r\n"
                },
                {
                    "date": 1747909090449,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,8 +4,18 @@\n import { authOptions } from '@/lib/auth';\r\n import { generateOrderCode } from '@/lib/utils';\r\n import { ObjectId, MongoClient } from 'mongodb';\r\n \r\n+interface ProductSize {\r\n+  size: string;\r\n+  quantity: number;\r\n+}\r\n+\r\n+interface Product {\r\n+  _id: ObjectId;\r\n+  sizes: ProductSize[];\r\n+}\r\n+\r\n export async function POST(req: Request) {\r\n   let mongoClient: MongoClient | null = null;\r\n   \r\n   try {\r\n@@ -95,18 +105,18 @@\n           // First, find the product to check its current structure\r\n           const product = await db.collection('products').findOne(\r\n             { _id: new ObjectId(item.id) },\r\n             { session: dbSession }\r\n-          );\r\n+          ) as Product | null;\r\n \r\n           if (!product) {\r\n             throw new Error(`Product ${item.id} not found`);\r\n           }\r\n \r\n           console.log('Found product:', JSON.stringify(product, null, 2));\r\n \r\n           // Find the size index in the sizes array\r\n-          const sizeIndex = product.sizes.findIndex(s => s.size === item.size);\r\n+          const sizeIndex = product.sizes.findIndex((s: ProductSize) => s.size === item.size);\r\n           if (sizeIndex === -1) {\r\n             throw new Error(`Size ${item.size} not found for product ${item.id}`);\r\n           }\r\n \r\n"
                },
                {
                    "date": 1747909295313,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,18 +4,8 @@\n import { authOptions } from '@/lib/auth';\r\n import { generateOrderCode } from '@/lib/utils';\r\n import { ObjectId, MongoClient } from 'mongodb';\r\n \r\n-interface ProductSize {\r\n-  size: string;\r\n-  quantity: number;\r\n-}\r\n-\r\n-interface Product {\r\n-  _id: ObjectId;\r\n-  sizes: ProductSize[];\r\n-}\r\n-\r\n export async function POST(req: Request) {\r\n   let mongoClient: MongoClient | null = null;\r\n   \r\n   try {\r\n@@ -105,18 +95,18 @@\n           // First, find the product to check its current structure\r\n           const product = await db.collection('products').findOne(\r\n             { _id: new ObjectId(item.id) },\r\n             { session: dbSession }\r\n-          ) as Product | null;\r\n+          );\r\n \r\n           if (!product) {\r\n             throw new Error(`Product ${item.id} not found`);\r\n           }\r\n \r\n           console.log('Found product:', JSON.stringify(product, null, 2));\r\n \r\n           // Find the size index in the sizes array\r\n-          const sizeIndex = product.sizes.findIndex((s: ProductSize) => s.size === item.size);\r\n+          const sizeIndex = product.sizes.findIndex(s => s.size === item.size);\r\n           if (sizeIndex === -1) {\r\n             throw new Error(`Size ${item.size} not found for product ${item.id}`);\r\n           }\r\n \r\n"
                },
                {
                    "date": 1747909324230,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -91,47 +91,25 @@\n         // Update product quantities\r\n         for (const item of orderData.items) {\r\n           console.log('Updating quantity for item:', JSON.stringify(item, null, 2));\r\n           \r\n-          // First, find the product to check its current structure\r\n-          const product = await db.collection('products').findOne(\r\n-            { _id: new ObjectId(item.id) },\r\n-            { session: dbSession }\r\n-          );\r\n-\r\n-          if (!product) {\r\n-            throw new Error(`Product ${item.id} not found`);\r\n-          }\r\n-\r\n-          console.log('Found product:', JSON.stringify(product, null, 2));\r\n-\r\n-          // Find the size index in the sizes array\r\n-          const sizeIndex = product.sizes.findIndex(s => s.size === item.size);\r\n-          if (sizeIndex === -1) {\r\n-            throw new Error(`Size ${item.size} not found for product ${item.id}`);\r\n-          }\r\n-\r\n-          // Check if there's enough quantity\r\n-          if (product.sizes[sizeIndex].quantity < item.quantity) {\r\n-            throw new Error(`Insufficient stock for product ${item.id} with size ${item.size}`);\r\n-          }\r\n-\r\n-          // Update the quantity\r\n+          // Find the product and update the specific size quantity\r\n           const updateResult = await db.collection('products').updateOne(\r\n             { \r\n               _id: new ObjectId(item.id),\r\n-              [`sizes.${sizeIndex}.size`]: item.size\r\n+              'sizes.size': item.size,\r\n+              'sizes.quantity': { $gte: item.quantity }\r\n             },\r\n             { \r\n-              $inc: { [`sizes.${sizeIndex}.quantity`]: -item.quantity }\r\n+              $inc: { 'sizes.$.quantity': -item.quantity }\r\n             },\r\n             { session: dbSession }\r\n           );\r\n \r\n           console.log('Update result:', updateResult);\r\n \r\n           if (updateResult.matchedCount === 0) {\r\n-            throw new Error(`Failed to update quantity for product ${item.id} with size ${item.size}`);\r\n+            throw new Error(`Insufficient stock for product ${item.id} with size ${item.size}`);\r\n           }\r\n \r\n           console.log(`Updated quantity for product ${item.id}, size ${item.size}`);\r\n         }\r\n"
                },
                {
                    "date": 1747909333230,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -2,18 +2,15 @@\n import { connectToDatabase } from '@/lib/mongodb';\r\n import { getServerSession } from 'next-auth';\r\n import { authOptions } from '@/lib/auth';\r\n import { generateOrderCode } from '@/lib/utils';\r\n-import { ObjectId, MongoClient } from 'mongodb';\r\n \r\n export async function POST(req: Request) {\r\n-  let mongoClient: MongoClient | null = null;\r\n-  \r\n   try {\r\n     const session = await getServerSession(authOptions);\r\n     const orderData = await req.json();\r\n     \r\n-    console.log('Received order data:', JSON.stringify(orderData, null, 2));\r\n+    console.log('Received order data:', orderData);\r\n \r\n     // Validate items array\r\n     if (!Array.isArray(orderData.items) || orderData.items.length === 0) {\r\n       console.error('Invalid items array:', orderData.items);\r\n@@ -22,35 +19,9 @@\n         { status: 400 }\r\n       );\r\n     }\r\n \r\n-    // Validate each item in the order\r\n-    for (const item of orderData.items) {\r\n-      if (!item.id) {\r\n-        console.error('Item missing id:', item);\r\n-        return NextResponse.json(\r\n-          { ok: false, message: 'Each item must have an id' },\r\n-          { status: 400 }\r\n-        );\r\n-      }\r\n-      if (!item.size) {\r\n-        console.error('Item missing size:', item);\r\n-        return NextResponse.json(\r\n-          { ok: false, message: 'Each item must have a size' },\r\n-          { status: 400 }\r\n-        );\r\n-      }\r\n-      if (!item.quantity || item.quantity <= 0) {\r\n-        console.error('Item missing or invalid quantity:', item);\r\n-        return NextResponse.json(\r\n-          { ok: false, message: 'Each item must have a valid quantity' },\r\n-          { status: 400 }\r\n-        );\r\n-      }\r\n-    }\r\n-\r\n-    const { db, client } = await connectToDatabase();\r\n-    mongoClient = client;\r\n+    const { db } = await connectToDatabase();\r\n     const orderCode = generateOrderCode();\r\n \r\n     // Tạo đơn hàng mới\r\n     const order = {\r\n@@ -74,80 +45,33 @@\n       note: orderData.note || null,\r\n       shippingMethod: orderData.shippingMethod || 'standard'\r\n     };\r\n \r\n-    console.log('Creating order with data:', JSON.stringify(order, null, 2));\r\n+    console.log('Creating order with data:', order);\r\n \r\n-    // Start a session for transaction\r\n-    const dbSession = await client.startSession();\r\n-    let insertedId: string | undefined;\r\n+    const result = await db.collection('orders').insertOne(order);\r\n \r\n-    try {\r\n-      await dbSession.withTransaction(async () => {\r\n-        // Insert order\r\n-        const result = await db.collection('orders').insertOne(order, { session: dbSession });\r\n-        console.log('Order created with ID:', result.insertedId);\r\n-        insertedId = result.insertedId.toString();\r\n+    if (!result.acknowledged) {\r\n+      console.error('Failed to insert order:', result);\r\n+      throw new Error('Failed to create order');\r\n+    }\r\n \r\n-        // Update product quantities\r\n-        for (const item of orderData.items) {\r\n-          console.log('Updating quantity for item:', JSON.stringify(item, null, 2));\r\n-          \r\n-          // Find the product and update the specific size quantity\r\n-          const updateResult = await db.collection('products').updateOne(\r\n-            { \r\n-              _id: new ObjectId(item.id),\r\n-              'sizes.size': item.size,\r\n-              'sizes.quantity': { $gte: item.quantity }\r\n-            },\r\n-            { \r\n-              $inc: { 'sizes.$.quantity': -item.quantity }\r\n-            },\r\n-            { session: dbSession }\r\n-          );\r\n+    console.log('Order created successfully:', result.insertedId);\r\n \r\n-          console.log('Update result:', updateResult);\r\n-\r\n-          if (updateResult.matchedCount === 0) {\r\n-            throw new Error(`Insufficient stock for product ${item.id} with size ${item.size}`);\r\n-          }\r\n-\r\n-          console.log(`Updated quantity for product ${item.id}, size ${item.size}`);\r\n-        }\r\n-      });\r\n-\r\n-      if (!insertedId) {\r\n-        throw new Error('Failed to create order');\r\n+    return NextResponse.json({\r\n+      ok: true,\r\n+      order: {\r\n+        ...order,\r\n+        _id: result.insertedId.toString()\r\n       }\r\n+    });\r\n \r\n-      return NextResponse.json({\r\n-        ok: true,\r\n-        order: {\r\n-          ...order,\r\n-          _id: insertedId\r\n-        }\r\n-      });\r\n-\r\n-    } catch (error) {\r\n-      console.error('Transaction failed:', error);\r\n-      return NextResponse.json(\r\n-        { ok: false, message: error instanceof Error ? error.message : 'Failed to create order' },\r\n-        { status: 500 }\r\n-      );\r\n-    } finally {\r\n-      await dbSession.endSession();\r\n-    }\r\n-\r\n   } catch (error) {\r\n     console.error('Error creating order:', error);\r\n     return NextResponse.json(\r\n       { ok: false, message: error instanceof Error ? error.message : 'Failed to create order' },\r\n       { status: 500 }\r\n     );\r\n-  } finally {\r\n-    if (mongoClient) {\r\n-      await mongoClient.close();\r\n-    }\r\n   }\r\n }\r\n \r\n export async function GET(req: Request) {\r\n"
                },
                {
                    "date": 1747909439923,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,112 +1,112 @@\n-import { NextResponse } from 'next/server';\r\n-import { connectToDatabase } from '@/lib/mongodb';\r\n-import { getServerSession } from 'next-auth';\r\n-import { authOptions } from '@/lib/auth';\r\n-import { generateOrderCode } from '@/lib/utils';\r\n-\r\n-export async function POST(req: Request) {\r\n-  try {\r\n-    const session = await getServerSession(authOptions);\r\n-    const orderData = await req.json();\r\n-    \r\n-    console.log('Received order data:', orderData);\r\n-\r\n-    // Validate items array\r\n-    if (!Array.isArray(orderData.items) || orderData.items.length === 0) {\r\n-      console.error('Invalid items array:', orderData.items);\r\n-      return NextResponse.json(\r\n-        { ok: false, message: 'Order must have at least one item' },\r\n-        { status: 400 }\r\n-      );\r\n-    }\r\n-\r\n-    const { db } = await connectToDatabase();\r\n-    const orderCode = generateOrderCode();\r\n-\r\n-    // Tạo đơn hàng mới\r\n-    const order = {\r\n-      orderCode,\r\n-      items: orderData.items,\r\n-      total: orderData.total,\r\n-      status: 'pending',\r\n-      createdAt: new Date(),\r\n-      email: orderData.email,\r\n-      userId: session?.user?.email || null,\r\n-      paymentStatus: 'pending',\r\n-      paymentMethod: orderData.paymentMethod || 'cod',\r\n-      // Thông tin giao hàng\r\n-      fullName: orderData.fullName,\r\n-      phone: orderData.phone,\r\n-      address: orderData.address,\r\n-      ward: orderData.ward,\r\n-      district: orderData.district,\r\n-      province: orderData.province,\r\n-      // Thông tin bổ sung\r\n-      note: orderData.note || null,\r\n-      shippingMethod: orderData.shippingMethod || 'standard'\r\n-    };\r\n-\r\n-    console.log('Creating order with data:', order);\r\n-\r\n-    const result = await db.collection('orders').insertOne(order);\r\n-\r\n-    if (!result.acknowledged) {\r\n-      console.error('Failed to insert order:', result);\r\n-      throw new Error('Failed to create order');\r\n-    }\r\n-\r\n-    console.log('Order created successfully:', result.insertedId);\r\n-\r\n-    return NextResponse.json({\r\n-      ok: true,\r\n-      order: {\r\n-        ...order,\r\n-        _id: result.insertedId.toString()\r\n-      }\r\n-    });\r\n-\r\n-  } catch (error) {\r\n-    console.error('Error creating order:', error);\r\n-    return NextResponse.json(\r\n-      { ok: false, message: error instanceof Error ? error.message : 'Failed to create order' },\r\n-      { status: 500 }\r\n-    );\r\n-  }\r\n-}\r\n-\r\n-export async function GET(req: Request) {\r\n-  try {\r\n-    const session = await getServerSession(authOptions);\r\n-    \r\n-    // Chỉ cho phép xem đơn hàng khi đã đăng nhập\r\n-    if (!session?.user?.email) {\r\n-      return NextResponse.json(\r\n-        { ok: false, message: 'Unauthorized' },\r\n-        { status: 401 }\r\n-      );\r\n-    }\r\n-\r\n-    const { db } = await connectToDatabase();\r\n-    const query = { userId: session.user.email };\r\n-\r\n-    const orders = await db.collection('orders')\r\n-      .find(query)\r\n-      .sort({ createdAt: -1 })\r\n-      .toArray();\r\n-\r\n-    return NextResponse.json({\r\n-      ok: true,\r\n-      orders: orders.map(order => ({\r\n-        ...order,\r\n-        _id: order._id.toString()\r\n-      }))\r\n-    });\r\n-\r\n-  } catch (error) {\r\n-    console.error('Error fetching orders:', error);\r\n-    return NextResponse.json(\r\n-      { ok: false, message: error instanceof Error ? error.message : 'Failed to fetch orders' },\r\n-      { status: 500 }\r\n-    );\r\n-  }\r\n+import { NextResponse } from 'next/server';\n+import { connectToDatabase } from '@/lib/mongodb';\n+import { getServerSession } from 'next-auth';\n+import { authOptions } from '@/lib/auth';\n+import { generateOrderCode } from '@/lib/utils';\n+\n+export async function POST(req: Request) {\n+  try {\n+    const session = await getServerSession(authOptions);\n+    const orderData = await req.json();\n+    \n+    console.log('Received order data:', orderData);\n+\n+    // Validate items array\n+    if (!Array.isArray(orderData.items) || orderData.items.length === 0) {\n+      console.error('Invalid items array:', orderData.items);\n+      return NextResponse.json(\n+        { ok: false, message: 'Order must have at least one item' },\n+        { status: 400 }\n+      );\n+    }\n+\n+    const { db } = await connectToDatabase();\n+    const orderCode = generateOrderCode();\n+\n+    // Tạo đơn hàng mới\n+    const order = {\n+      orderCode,\n+      items: orderData.items,\n+      total: orderData.total,\n+      status: 'pending',\n+      createdAt: new Date(),\n+      email: orderData.email,\n+      userId: session?.user?.email || null,\n+      paymentStatus: 'pending',\n+      paymentMethod: orderData.paymentMethod || 'cod',\n+      // Thông tin giao hàng\n+      fullName: orderData.fullName,\n+      phone: orderData.phone,\n+      address: orderData.address,\n+      ward: orderData.ward,\n+      district: orderData.district,\n+      province: orderData.province,\n+      // Thông tin bổ sung\n+      note: orderData.note || null,\n+      shippingMethod: orderData.shippingMethod || 'standard'\n+    };\n+\n+    console.log('Creating order with data:', order);\n+\n+    const result = await db.collection('orders').insertOne(order);\n+\n+    if (!result.acknowledged) {\n+      console.error('Failed to insert order:', result);\n+      throw new Error('Failed to create order');\n+    }\n+\n+    console.log('Order created successfully:', result.insertedId);\n+\n+    return NextResponse.json({\n+      ok: true,\n+      order: {\n+        ...order,\n+        _id: result.insertedId.toString()\n+      }\n+    });\n+\n+  } catch (error) {\n+    console.error('Error creating order:', error);\n+    return NextResponse.json(\n+      { ok: false, message: error instanceof Error ? error.message : 'Failed to create order' },\n+      { status: 500 }\n+    );\n+  }\n+}\n+\n+export async function GET(req: Request) {\n+  try {\n+    const session = await getServerSession(authOptions);\n+    \n+    // Chỉ cho phép xem đơn hàng khi đã đăng nhập\n+    if (!session?.user?.email) {\n+      return NextResponse.json(\n+        { ok: false, message: 'Unauthorized' },\n+        { status: 401 }\n+      );\n+    }\n+\n+    const { db } = await connectToDatabase();\n+    const query = { userId: session.user.email };\n+\n+    const orders = await db.collection('orders')\n+      .find(query)\n+      .sort({ createdAt: -1 })\n+      .toArray();\n+\n+    return NextResponse.json({\n+      ok: true,\n+      orders: orders.map(order => ({\n+        ...order,\n+        _id: order._id.toString()\n+      }))\n+    });\n+\n+  } catch (error) {\n+    console.error('Error fetching orders:', error);\n+    return NextResponse.json(\n+      { ok: false, message: error instanceof Error ? error.message : 'Failed to fetch orders' },\n+      { status: 500 }\n+    );\n+  }\n } \n\\ No newline at end of file\n"
                },
                {
                    "date": 1747909447266,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -2,15 +2,18 @@\n import { connectToDatabase } from '@/lib/mongodb';\n import { getServerSession } from 'next-auth';\n import { authOptions } from '@/lib/auth';\n import { generateOrderCode } from '@/lib/utils';\n+import { ObjectId, MongoClient } from 'mongodb';\n \n export async function POST(req: Request) {\n+  let mongoClient: MongoClient | null = null;\n+  \n   try {\n     const session = await getServerSession(authOptions);\n     const orderData = await req.json();\n     \n-    console.log('Received order data:', orderData);\n+    console.log('Received order data:', JSON.stringify(orderData, null, 2));\n \n     // Validate items array\n     if (!Array.isArray(orderData.items) || orderData.items.length === 0) {\n       console.error('Invalid items array:', orderData.items);\n@@ -19,9 +22,35 @@\n         { status: 400 }\n       );\n     }\n \n-    const { db } = await connectToDatabase();\n+    // Validate each item in the order\n+    for (const item of orderData.items) {\n+      if (!item.id) {\n+        console.error('Item missing id:', item);\n+        return NextResponse.json(\n+          { ok: false, message: 'Each item must have an id' },\n+          { status: 400 }\n+        );\n+      }\n+      if (!item.size) {\n+        console.error('Item missing size:', item);\n+        return NextResponse.json(\n+          { ok: false, message: 'Each item must have a size' },\n+          { status: 400 }\n+        );\n+      }\n+      if (!item.quantity || item.quantity <= 0) {\n+        console.error('Item missing or invalid quantity:', item);\n+        return NextResponse.json(\n+          { ok: false, message: 'Each item must have a valid quantity' },\n+          { status: 400 }\n+        );\n+      }\n+    }\n+\n+    const { db, client } = await connectToDatabase();\n+    mongoClient = client;\n     const orderCode = generateOrderCode();\n \n     // Tạo đơn hàng mới\n     const order = {\n@@ -45,33 +74,102 @@\n       note: orderData.note || null,\n       shippingMethod: orderData.shippingMethod || 'standard'\n     };\n \n-    console.log('Creating order with data:', order);\n+    console.log('Creating order with data:', JSON.stringify(order, null, 2));\n \n-    const result = await db.collection('orders').insertOne(order);\n+    // Start a session for transaction\n+    const dbSession = await client.startSession();\n+    let insertedId: string | undefined;\n \n-    if (!result.acknowledged) {\n-      console.error('Failed to insert order:', result);\n-      throw new Error('Failed to create order');\n-    }\n+    try {\n+      await dbSession.withTransaction(async () => {\n+        // Insert order\n+        const result = await db.collection('orders').insertOne(order, { session: dbSession });\n+        console.log('Order created with ID:', result.insertedId);\n+        insertedId = result.insertedId.toString();\n \n-    console.log('Order created successfully:', result.insertedId);\n+        // Update product quantities\n+        for (const item of orderData.items) {\n+          console.log('Updating quantity for item:', JSON.stringify(item, null, 2));\n+          \n+          // First, find the product to check its current structure\n+          const product = await db.collection('products').findOne(\n+            { _id: new ObjectId(item.id) },\n+            { session: dbSession }\n+          );\n \n-    return NextResponse.json({\n-      ok: true,\n-      order: {\n-        ...order,\n-        _id: result.insertedId.toString()\n+          if (!product) {\n+            throw new Error(`Product ${item.id} not found`);\n+          }\n+\n+          console.log('Found product:', JSON.stringify(product, null, 2));\n+\n+          // Find the size index in the sizes array\n+          const sizeIndex = product.sizes.findIndex(s => s.size === item.size);\n+          if (sizeIndex === -1) {\n+            throw new Error(`Size ${item.size} not found for product ${item.id}`);\n+          }\n+\n+          // Check if there's enough quantity\n+          if (product.sizes[sizeIndex].quantity < item.quantity) {\n+            throw new Error(`Insufficient stock for product ${item.id} with size ${item.size}`);\n+          }\n+\n+          // Update the quantity\n+          const updateResult = await db.collection('products').updateOne(\n+            { \n+              _id: new ObjectId(item.id),\n+              [`sizes.${sizeIndex}.size`]: item.size\n+            },\n+            { \n+              $inc: { [`sizes.${sizeIndex}.quantity`]: -item.quantity }\n+            },\n+            { session: dbSession }\n+          );\n+\n+          console.log('Update result:', updateResult);\n+\n+          if (updateResult.matchedCount === 0) {\n+            throw new Error(`Failed to update quantity for product ${item.id} with size ${item.size}`);\n+          }\n+\n+          console.log(`Updated quantity for product ${item.id}, size ${item.size}`);\n+        }\n+      });\n+\n+      if (!insertedId) {\n+        throw new Error('Failed to create order');\n       }\n-    });\n \n+      return NextResponse.json({\n+        ok: true,\n+        order: {\n+          ...order,\n+          _id: insertedId\n+        }\n+      });\n+\n+    } catch (error) {\n+      console.error('Transaction failed:', error);\n+      return NextResponse.json(\n+        { ok: false, message: error instanceof Error ? error.message : 'Failed to create order' },\n+        { status: 500 }\n+      );\n+    } finally {\n+      await dbSession.endSession();\n+    }\n+\n   } catch (error) {\n     console.error('Error creating order:', error);\n     return NextResponse.json(\n       { ok: false, message: error instanceof Error ? error.message : 'Failed to create order' },\n       { status: 500 }\n     );\n+  } finally {\n+    if (mongoClient) {\n+      await mongoClient.close();\n+    }\n   }\n }\n \n export async function GET(req: Request) {\n"
                },
                {
                    "date": 1747909457612,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,8 +4,18 @@\n import { authOptions } from '@/lib/auth';\n import { generateOrderCode } from '@/lib/utils';\n import { ObjectId, MongoClient } from 'mongodb';\n \n+interface ProductSize {\n+  size: string;\n+  quantity: number;\n+}\n+\n+interface Product {\n+  _id: ObjectId;\n+  sizes: ProductSize[];\n+}\n+\n export async function POST(req: Request) {\n   let mongoClient: MongoClient | null = null;\n   \n   try {\n@@ -95,18 +105,18 @@\n           // First, find the product to check its current structure\n           const product = await db.collection('products').findOne(\n             { _id: new ObjectId(item.id) },\n             { session: dbSession }\n-          );\n+          ) as Product | null;\n \n           if (!product) {\n             throw new Error(`Product ${item.id} not found`);\n           }\n \n           console.log('Found product:', JSON.stringify(product, null, 2));\n \n           // Find the size index in the sizes array\n-          const sizeIndex = product.sizes.findIndex(s => s.size === item.size);\n+          const sizeIndex = product.sizes.findIndex((s: ProductSize) => s.size === item.size);\n           if (sizeIndex === -1) {\n             throw new Error(`Size ${item.size} not found for product ${item.id}`);\n           }\n \n"
                },
                {
                    "date": 1747909483982,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,18 +4,8 @@\n import { authOptions } from '@/lib/auth';\n import { generateOrderCode } from '@/lib/utils';\n import { ObjectId, MongoClient } from 'mongodb';\n \n-interface ProductSize {\n-  size: string;\n-  quantity: number;\n-}\n-\n-interface Product {\n-  _id: ObjectId;\n-  sizes: ProductSize[];\n-}\n-\n export async function POST(req: Request) {\n   let mongoClient: MongoClient | null = null;\n   \n   try {\n@@ -101,47 +91,25 @@\n         // Update product quantities\n         for (const item of orderData.items) {\n           console.log('Updating quantity for item:', JSON.stringify(item, null, 2));\n           \n-          // First, find the product to check its current structure\n-          const product = await db.collection('products').findOne(\n-            { _id: new ObjectId(item.id) },\n-            { session: dbSession }\n-          ) as Product | null;\n-\n-          if (!product) {\n-            throw new Error(`Product ${item.id} not found`);\n-          }\n-\n-          console.log('Found product:', JSON.stringify(product, null, 2));\n-\n-          // Find the size index in the sizes array\n-          const sizeIndex = product.sizes.findIndex((s: ProductSize) => s.size === item.size);\n-          if (sizeIndex === -1) {\n-            throw new Error(`Size ${item.size} not found for product ${item.id}`);\n-          }\n-\n-          // Check if there's enough quantity\n-          if (product.sizes[sizeIndex].quantity < item.quantity) {\n-            throw new Error(`Insufficient stock for product ${item.id} with size ${item.size}`);\n-          }\n-\n-          // Update the quantity\n+          // Find the product and update the specific size quantity\n           const updateResult = await db.collection('products').updateOne(\n             { \n               _id: new ObjectId(item.id),\n-              [`sizes.${sizeIndex}.size`]: item.size\n+              'sizes.size': item.size,\n+              'sizes.quantity': { $gte: item.quantity }\n             },\n             { \n-              $inc: { [`sizes.${sizeIndex}.quantity`]: -item.quantity }\n+              $inc: { 'sizes.$.quantity': -item.quantity }\n             },\n             { session: dbSession }\n           );\n \n           console.log('Update result:', updateResult);\n \n           if (updateResult.matchedCount === 0) {\n-            throw new Error(`Failed to update quantity for product ${item.id} with size ${item.size}`);\n+            throw new Error(`Insufficient stock for product ${item.id} with size ${item.size}`);\n           }\n \n           console.log(`Updated quantity for product ${item.id}, size ${item.size}`);\n         }\n"
                },
                {
                    "date": 1747909496989,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -11,9 +11,9 @@\n   try {\n     const session = await getServerSession(authOptions);\n     const orderData = await req.json();\n     \n-    console.log('Received order data:', JSON.stringify(orderData, null, 2));\n+    console.log('Received order data:', orderData);\n \n     // Validate items array\n     if (!Array.isArray(orderData.items) || orderData.items.length === 0) {\n       console.error('Invalid items array:', orderData.items);\n@@ -22,33 +22,8 @@\n         { status: 400 }\n       );\n     }\n \n-    // Validate each item in the order\n-    for (const item of orderData.items) {\n-      if (!item.id) {\n-        console.error('Item missing id:', item);\n-        return NextResponse.json(\n-          { ok: false, message: 'Each item must have an id' },\n-          { status: 400 }\n-        );\n-      }\n-      if (!item.size) {\n-        console.error('Item missing size:', item);\n-        return NextResponse.json(\n-          { ok: false, message: 'Each item must have a size' },\n-          { status: 400 }\n-        );\n-      }\n-      if (!item.quantity || item.quantity <= 0) {\n-        console.error('Item missing or invalid quantity:', item);\n-        return NextResponse.json(\n-          { ok: false, message: 'Each item must have a valid quantity' },\n-          { status: 400 }\n-        );\n-      }\n-    }\n-\n     const { db, client } = await connectToDatabase();\n     mongoClient = client;\n     const orderCode = generateOrderCode();\n \n@@ -74,9 +49,9 @@\n       note: orderData.note || null,\n       shippingMethod: orderData.shippingMethod || 'standard'\n     };\n \n-    console.log('Creating order with data:', JSON.stringify(order, null, 2));\n+    console.log('Creating order with data:', order);\n \n     // Start a session for transaction\n     const dbSession = await client.startSession();\n     let insertedId: string | undefined;\n@@ -89,9 +64,9 @@\n         insertedId = result.insertedId.toString();\n \n         // Update product quantities\n         for (const item of orderData.items) {\n-          console.log('Updating quantity for item:', JSON.stringify(item, null, 2));\n+          console.log('Updating quantity for item:', item);\n           \n           // Find the product and update the specific size quantity\n           const updateResult = await db.collection('products').updateOne(\n             { \n@@ -104,10 +79,8 @@\n             },\n             { session: dbSession }\n           );\n \n-          console.log('Update result:', updateResult);\n-\n           if (updateResult.matchedCount === 0) {\n             throw new Error(`Insufficient stock for product ${item.id} with size ${item.size}`);\n           }\n \n@@ -184,5 +157,5 @@\n       { ok: false, message: error instanceof Error ? error.message : 'Failed to fetch orders' },\n       { status: 500 }\n     );\n   }\n-} \n\\ No newline at end of file\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1747909894557,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -2,13 +2,12 @@\n import { connectToDatabase } from '@/lib/mongodb';\n import { getServerSession } from 'next-auth';\n import { authOptions } from '@/lib/auth';\n import { generateOrderCode } from '@/lib/utils';\n-import { ObjectId, MongoClient } from 'mongodb';\n+import { ObjectId } from 'mongodb';\n+import { revalidatePath } from 'next/cache';\n \n export async function POST(req: Request) {\n-  let mongoClient: MongoClient | null = null;\n-  \n   try {\n     const session = await getServerSession(authOptions);\n     const orderData = await req.json();\n     \n@@ -22,10 +21,9 @@\n         { status: 400 }\n       );\n     }\n \n-    const { db, client } = await connectToDatabase();\n-    mongoClient = client;\n+    const { db } = await connectToDatabase();\n     const orderCode = generateOrderCode();\n \n     // Tạo đơn hàng mới\n     const order = {\n@@ -51,76 +49,68 @@\n     };\n \n     console.log('Creating order with data:', order);\n \n-    // Start a session for transaction\n-    const dbSession = await client.startSession();\n-    let insertedId: string | undefined;\n+    const result = await db.collection('orders').insertOne(order);\n \n-    try {\n-      await dbSession.withTransaction(async () => {\n-        // Insert order\n-        const result = await db.collection('orders').insertOne(order, { session: dbSession });\n-        console.log('Order created with ID:', result.insertedId);\n-        insertedId = result.insertedId.toString();\n+    if (!result.acknowledged) {\n+      console.error('Failed to insert order:', result);\n+      throw new Error('Failed to create order');\n+    }\n \n-        // Update product quantities\n-        for (const item of orderData.items) {\n-          console.log('Updating quantity for item:', item);\n-          \n-          // Find the product and update the specific size quantity\n-          const updateResult = await db.collection('products').updateOne(\n-            { \n-              _id: new ObjectId(item.id),\n-              'sizes.size': item.size,\n-              'sizes.quantity': { $gte: item.quantity }\n-            },\n-            { \n-              $inc: { 'sizes.$.quantity': -item.quantity }\n-            },\n-            { session: dbSession }\n-          );\n+    console.log('Order created successfully:', result.insertedId);\n \n-          if (updateResult.matchedCount === 0) {\n-            throw new Error(`Insufficient stock for product ${item.id} with size ${item.size}`);\n-          }\n-\n-          console.log(`Updated quantity for product ${item.id}, size ${item.size}`);\n-        }\n+    // Cập nhật số lượng sản phẩm sau khi tạo đơn hàng thành công\n+    for (const item of orderData.items) {\n+      const product = await db.collection('products').findOne({ \n+        _id: new ObjectId(item.productId) \n       });\n \n-      if (!insertedId) {\n-        throw new Error('Failed to create order');\n+      if (!product) {\n+        console.error(`Product not found: ${item.productId}`);\n+        continue;\n       }\n \n-      return NextResponse.json({\n-        ok: true,\n-        order: {\n-          ...order,\n-          _id: insertedId\n-        }\n+      // Cập nhật số lượng theo size\n+      const updateField = `quantity${item.size}`;\n+      const currentQuantity = product[updateField] || 0;\n+      const newQuantity = Math.max(0, currentQuantity - item.quantity);\n+\n+      console.log(`Updating product ${item.productId} - Size ${item.size}:`, {\n+        currentQuantity,\n+        orderedQuantity: item.quantity,\n+        newQuantity\n       });\n \n-    } catch (error) {\n-      console.error('Transaction failed:', error);\n-      return NextResponse.json(\n-        { ok: false, message: error instanceof Error ? error.message : 'Failed to create order' },\n-        { status: 500 }\n+      await db.collection('products').updateOne(\n+        { _id: new ObjectId(item.productId) },\n+        { \n+          $set: { \n+            [updateField]: newQuantity,\n+            updatedAt: new Date()\n+          }\n+        }\n       );\n-    } finally {\n-      await dbSession.endSession();\n     }\n \n+    // Revalidate các trang liên quan để cập nhật cache\n+    revalidatePath('/products');\n+    revalidatePath('/admin/products');\n+\n+    return NextResponse.json({\n+      ok: true,\n+      order: {\n+        ...order,\n+        _id: result.insertedId.toString()\n+      }\n+    });\n+\n   } catch (error) {\n     console.error('Error creating order:', error);\n     return NextResponse.json(\n       { ok: false, message: error instanceof Error ? error.message : 'Failed to create order' },\n       { status: 500 }\n     );\n-  } finally {\n-    if (mongoClient) {\n-      await mongoClient.close();\n-    }\n   }\n }\n \n export async function GET(req: Request) {\n@@ -157,5 +147,5 @@\n       { ok: false, message: error instanceof Error ? error.message : 'Failed to fetch orders' },\n       { status: 500 }\n     );\n   }\n-}\n\\ No newline at end of file\n+} \n\\ No newline at end of file\n"
                },
                {
                    "date": 1747910229736,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -10,9 +10,9 @@\n   try {\n     const session = await getServerSession(authOptions);\n     const orderData = await req.json();\n     \n-    console.log('Received order data:', orderData);\n+    console.log('Received order data:', JSON.stringify(orderData, null, 2));\n \n     // Validate items array\n     if (!Array.isArray(orderData.items) || orderData.items.length === 0) {\n       console.error('Invalid items array:', orderData.items);\n@@ -47,9 +47,9 @@\n       note: orderData.note || null,\n       shippingMethod: orderData.shippingMethod || 'standard'\n     };\n \n-    console.log('Creating order with data:', order);\n+    console.log('Creating order with data:', JSON.stringify(order, null, 2));\n \n     const result = await db.collection('orders').insertOne(order);\n \n     if (!result.acknowledged) {\n@@ -60,8 +60,15 @@\n     console.log('Order created successfully:', result.insertedId);\n \n     // Cập nhật số lượng sản phẩm sau khi tạo đơn hàng thành công\n     for (const item of orderData.items) {\n+      console.log('Processing item:', JSON.stringify(item, null, 2));\n+      \n+      if (!item.productId) {\n+        console.error('Missing productId in item:', item);\n+        continue;\n+      }\n+\n       const product = await db.collection('products').findOne({ \n         _id: new ObjectId(item.productId) \n       });\n \n@@ -69,33 +76,45 @@\n         console.error(`Product not found: ${item.productId}`);\n         continue;\n       }\n \n+      console.log('Found product:', JSON.stringify(product, null, 2));\n+\n       // Cập nhật số lượng theo size\n       const updateField = `quantity${item.size}`;\n       const currentQuantity = product[updateField] || 0;\n       const newQuantity = Math.max(0, currentQuantity - item.quantity);\n \n       console.log(`Updating product ${item.productId} - Size ${item.size}:`, {\n         currentQuantity,\n         orderedQuantity: item.quantity,\n-        newQuantity\n+        newQuantity,\n+        updateField\n       });\n \n-      await db.collection('products').updateOne(\n+      const updateResult = await db.collection('products').updateOne(\n         { _id: new ObjectId(item.productId) },\n         { \n           $set: { \n             [updateField]: newQuantity,\n             updatedAt: new Date()\n           }\n         }\n       );\n+\n+      console.log('Update result:', JSON.stringify(updateResult, null, 2));\n+\n+      // Verify the update\n+      const updatedProduct = await db.collection('products').findOne({ \n+        _id: new ObjectId(item.productId) \n+      });\n+      console.log('Product after update:', JSON.stringify(updatedProduct, null, 2));\n     }\n \n     // Revalidate các trang liên quan để cập nhật cache\n     revalidatePath('/products');\n     revalidatePath('/admin/products');\n+    revalidatePath(`/products/${orderData.items[0]?.productId}`);\n \n     return NextResponse.json({\n       ok: true,\n       order: {\n"
                },
                {
                    "date": 1747910250833,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -10,9 +10,9 @@\n   try {\n     const session = await getServerSession(authOptions);\n     const orderData = await req.json();\n     \n-    console.log('Received order data:', JSON.stringify(orderData, null, 2));\n+    console.log('Received order data:', orderData);\n \n     // Validate items array\n     if (!Array.isArray(orderData.items) || orderData.items.length === 0) {\n       console.error('Invalid items array:', orderData.items);\n@@ -47,9 +47,9 @@\n       note: orderData.note || null,\n       shippingMethod: orderData.shippingMethod || 'standard'\n     };\n \n-    console.log('Creating order with data:', JSON.stringify(order, null, 2));\n+    console.log('Creating order with data:', order);\n \n     const result = await db.collection('orders').insertOne(order);\n \n     if (!result.acknowledged) {\n@@ -60,15 +60,8 @@\n     console.log('Order created successfully:', result.insertedId);\n \n     // Cập nhật số lượng sản phẩm sau khi tạo đơn hàng thành công\n     for (const item of orderData.items) {\n-      console.log('Processing item:', JSON.stringify(item, null, 2));\n-      \n-      if (!item.productId) {\n-        console.error('Missing productId in item:', item);\n-        continue;\n-      }\n-\n       const product = await db.collection('products').findOne({ \n         _id: new ObjectId(item.productId) \n       });\n \n@@ -76,45 +69,33 @@\n         console.error(`Product not found: ${item.productId}`);\n         continue;\n       }\n \n-      console.log('Found product:', JSON.stringify(product, null, 2));\n-\n       // Cập nhật số lượng theo size\n       const updateField = `quantity${item.size}`;\n       const currentQuantity = product[updateField] || 0;\n       const newQuantity = Math.max(0, currentQuantity - item.quantity);\n \n       console.log(`Updating product ${item.productId} - Size ${item.size}:`, {\n         currentQuantity,\n         orderedQuantity: item.quantity,\n-        newQuantity,\n-        updateField\n+        newQuantity\n       });\n \n-      const updateResult = await db.collection('products').updateOne(\n+      await db.collection('products').updateOne(\n         { _id: new ObjectId(item.productId) },\n         { \n           $set: { \n             [updateField]: newQuantity,\n             updatedAt: new Date()\n           }\n         }\n       );\n-\n-      console.log('Update result:', JSON.stringify(updateResult, null, 2));\n-\n-      // Verify the update\n-      const updatedProduct = await db.collection('products').findOne({ \n-        _id: new ObjectId(item.productId) \n-      });\n-      console.log('Product after update:', JSON.stringify(updatedProduct, null, 2));\n     }\n \n     // Revalidate các trang liên quan để cập nhật cache\n     revalidatePath('/products');\n     revalidatePath('/admin/products');\n-    revalidatePath(`/products/${orderData.items[0]?.productId}`);\n \n     return NextResponse.json({\n       ok: true,\n       order: {\n"
                },
                {
                    "date": 1747910539734,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -2,12 +2,14 @@\n import { connectToDatabase } from '@/lib/mongodb';\n import { getServerSession } from 'next-auth';\n import { authOptions } from '@/lib/auth';\n import { generateOrderCode } from '@/lib/utils';\n-import { ObjectId } from 'mongodb';\n+import { ObjectId, MongoClient } from 'mongodb';\n import { revalidatePath } from 'next/cache';\n \n export async function POST(req: Request) {\n+  let mongoClient: MongoClient | null = null;\n+  \n   try {\n     const session = await getServerSession(authOptions);\n     const orderData = await req.json();\n     \n@@ -21,96 +23,161 @@\n         { status: 400 }\n       );\n     }\n \n-    const { db } = await connectToDatabase();\n-    const orderCode = generateOrderCode();\n+    // Connect to MongoDB with transaction support\n+    const { db, client } = await connectToDatabase();\n+    mongoClient = client;\n \n-    // Tạo đơn hàng mới\n-    const order = {\n-      orderCode,\n-      items: orderData.items,\n-      total: orderData.total,\n-      status: 'pending',\n-      createdAt: new Date(),\n-      email: orderData.email,\n-      userId: session?.user?.email || null,\n-      paymentStatus: 'pending',\n-      paymentMethod: orderData.paymentMethod || 'cod',\n-      // Thông tin giao hàng\n-      fullName: orderData.fullName,\n-      phone: orderData.phone,\n-      address: orderData.address,\n-      ward: orderData.ward,\n-      district: orderData.district,\n-      province: orderData.province,\n-      // Thông tin bổ sung\n-      note: orderData.note || null,\n-      shippingMethod: orderData.shippingMethod || 'standard'\n-    };\n+    // Start a session for transaction\n+    const dbSession = client.startSession();\n \n-    console.log('Creating order with data:', order);\n+    try {\n+      // Start transaction\n+      await dbSession.startTransaction();\n \n-    const result = await db.collection('orders').insertOne(order);\n+      const orderCode = generateOrderCode();\n \n-    if (!result.acknowledged) {\n-      console.error('Failed to insert order:', result);\n-      throw new Error('Failed to create order');\n-    }\n+      // Tạo đơn hàng mới\n+      const order = {\n+        orderCode,\n+        items: orderData.items,\n+        total: orderData.total,\n+        status: 'pending',\n+        createdAt: new Date(),\n+        email: orderData.email,\n+        userId: session?.user?.email || null,\n+        paymentStatus: 'pending',\n+        paymentMethod: orderData.paymentMethod || 'cod',\n+        // Thông tin giao hàng\n+        fullName: orderData.fullName,\n+        phone: orderData.phone,\n+        address: orderData.address,\n+        ward: orderData.ward,\n+        district: orderData.district,\n+        province: orderData.province,\n+        // Thông tin bổ sung\n+        note: orderData.note || null,\n+        shippingMethod: orderData.shippingMethod || 'standard'\n+      };\n \n-    console.log('Order created successfully:', result.insertedId);\n+      console.log('Creating order with data:', order);\n \n-    // Cập nhật số lượng sản phẩm sau khi tạo đơn hàng thành công\n-    for (const item of orderData.items) {\n-      const product = await db.collection('products').findOne({ \n-        _id: new ObjectId(item.productId) \n-      });\n+      const result = await db.collection('orders').insertOne(order, { session: dbSession });\n \n-      if (!product) {\n-        console.error(`Product not found: ${item.productId}`);\n-        continue;\n+      if (!result.acknowledged) {\n+        console.error('Failed to insert order:', result);\n+        throw new Error('Failed to create order');\n       }\n \n-      // Cập nhật số lượng theo size\n-      const updateField = `quantity${item.size}`;\n-      const currentQuantity = product[updateField] || 0;\n-      const newQuantity = Math.max(0, currentQuantity - item.quantity);\n+      console.log('Order created successfully:', result.insertedId);\n \n-      console.log(`Updating product ${item.productId} - Size ${item.size}:`, {\n-        currentQuantity,\n-        orderedQuantity: item.quantity,\n-        newQuantity\n-      });\n+      // Cập nhật số lượng sản phẩm sau khi tạo đơn hàng thành công\n+      for (const item of orderData.items) {\n+        const product = await db.collection('products').findOne(\n+          { _id: new ObjectId(item.productId) },\n+          { session: dbSession }\n+        );\n \n-      await db.collection('products').updateOne(\n-        { _id: new ObjectId(item.productId) },\n-        { \n-          $set: { \n-            [updateField]: newQuantity,\n-            updatedAt: new Date()\n-          }\n+        if (!product) {\n+          console.error(`Product not found: ${item.productId}`);\n+          throw new Error(`Product ${item.productId} not found`);\n         }\n-      );\n-    }\n \n-    // Revalidate các trang liên quan để cập nhật cache\n-    revalidatePath('/products');\n-    revalidatePath('/admin/products');\n+        // Cập nhật số lượng theo size\n+        const updateField = `quantity${item.size}`;\n+        const currentQuantity = product[updateField] || 0;\n+        const newQuantity = Math.max(0, currentQuantity - item.quantity);\n \n-    return NextResponse.json({\n-      ok: true,\n-      order: {\n-        ...order,\n-        _id: result.insertedId.toString()\n+        console.log(`Updating product ${item.productId} - Size ${item.size}:`, {\n+          currentQuantity,\n+          orderedQuantity: item.quantity,\n+          newQuantity\n+        });\n+\n+        // Cập nhật số lượng và trạng thái outOfStock\n+        const updateResult = await db.collection('products').updateOne(\n+          { _id: new ObjectId(item.productId) },\n+          { \n+            $set: { \n+              [updateField]: newQuantity,\n+              [`outOfStock${item.size}`]: newQuantity === 0,\n+              updatedAt: new Date()\n+            }\n+          },\n+          { session: dbSession }\n+        );\n+\n+        if (updateResult.modifiedCount === 0) {\n+          throw new Error(`Failed to update product ${item.productId}`);\n+        }\n+\n+        // Kiểm tra nếu tất cả các size đều hết hàng\n+        const updatedProduct = await db.collection('products').findOne(\n+          { _id: new ObjectId(item.productId) },\n+          { session: dbSession }\n+        );\n+\n+        if (!updatedProduct) {\n+          throw new Error(`Failed to fetch updated product: ${item.productId}`);\n+        }\n+\n+        const allSizesOutOfStock = ['M', 'L', 'XL', 'Hat'].every(size => \n+          (updatedProduct[`quantity${size}`] || 0) === 0\n+        );\n+\n+        if (allSizesOutOfStock) {\n+          await db.collection('products').updateOne(\n+            { _id: new ObjectId(item.productId) },\n+            { \n+              $set: { \n+                outOfStock: true,\n+                updatedAt: new Date()\n+              }\n+            },\n+            { session: dbSession }\n+          );\n+        }\n+\n+        // Revalidate trang chi tiết sản phẩm\n+        revalidatePath(`/${product.slug}`);\n       }\n-    });\n \n+      // Commit transaction\n+      await dbSession.commitTransaction();\n+\n+      // Revalidate các trang liên quan\n+      revalidatePath('/products');\n+      revalidatePath('/admin/products');\n+\n+      return NextResponse.json({\n+        ok: true,\n+        order: {\n+          ...order,\n+          _id: result.insertedId.toString()\n+        }\n+      });\n+\n+    } catch (error) {\n+      // Rollback transaction nếu có lỗi\n+      await dbSession.abortTransaction();\n+      throw error;\n+    } finally {\n+      // End session\n+      await dbSession.endSession();\n+    }\n+\n   } catch (error) {\n     console.error('Error creating order:', error);\n     return NextResponse.json(\n       { ok: false, message: error instanceof Error ? error.message : 'Failed to create order' },\n       { status: 500 }\n     );\n+  } finally {\n+    // Close MongoDB connection\n+    if (mongoClient) {\n+      await mongoClient.close();\n+    }\n   }\n }\n \n export async function GET(req: Request) {\n"
                },
                {
                    "date": 1748315131852,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -12,30 +12,49 @@\n   try {\n     const session = await getServerSession(authOptions);\n     const orderData = await req.json();\n     \n-    console.log('Received order data:', orderData);\n+    console.log('Dữ liệu đơn hàng nhận được:', orderData);\n \n-    // Validate items array\n+    // Kiểm tra mảng items\n     if (!Array.isArray(orderData.items) || orderData.items.length === 0) {\n-      console.error('Invalid items array:', orderData.items);\n+      console.error('Mảng items không hợp lệ:', orderData.items);\n       return NextResponse.json(\n-        { ok: false, message: 'Order must have at least one item' },\n+        { ok: false, message: 'Đơn hàng phải có ít nhất một sản phẩm' },\n         { status: 400 }\n       );\n     }\n \n-    // Connect to MongoDB with transaction support\n+    // Kết nối MongoDB với hỗ trợ transaction\n     const { db, client } = await connectToDatabase();\n     mongoClient = client;\n \n-    // Start a session for transaction\n+    // Bắt đầu session cho transaction\n     const dbSession = client.startSession();\n \n     try {\n-      // Start transaction\n+      // Bắt đầu transaction\n       await dbSession.startTransaction();\n \n+      // Kiểm tra số lượng sản phẩm trước khi tạo đơn hàng\n+      for (const item of orderData.items) {\n+        const product = await db.collection('products').findOne(\n+          { _id: new ObjectId(item.productId) },\n+          { session: dbSession }\n+        );\n+\n+        if (!product) {\n+          throw new Error(`Không tìm thấy sản phẩm với ID: ${item.productId}`);\n+        }\n+\n+        const quantityField = `quantity${item.size}`;\n+        const currentQuantity = product[quantityField] || 0;\n+\n+        if (currentQuantity < item.quantity) {\n+          throw new Error(`Số lượng sản phẩm ${product.name} (Size ${item.size}) không đủ. Còn lại: ${currentQuantity}`);\n+        }\n+      }\n+\n       const orderCode = generateOrderCode();\n \n       // Tạo đơn hàng mới\n       const order = {\n@@ -59,69 +78,69 @@\n         note: orderData.note || null,\n         shippingMethod: orderData.shippingMethod || 'standard'\n       };\n \n-      console.log('Creating order with data:', order);\n+      console.log('Đang tạo đơn hàng với dữ liệu:', order);\n \n       const result = await db.collection('orders').insertOne(order, { session: dbSession });\n \n       if (!result.acknowledged) {\n-        console.error('Failed to insert order:', result);\n-        throw new Error('Failed to create order');\n+        console.error('Không thể tạo đơn hàng:', result);\n+        throw new Error('Không thể tạo đơn hàng');\n       }\n \n-      console.log('Order created successfully:', result.insertedId);\n+      console.log('Đơn hàng được tạo thành công:', result.insertedId);\n \n       // Cập nhật số lượng sản phẩm sau khi tạo đơn hàng thành công\n       for (const item of orderData.items) {\n-        const product = await db.collection('products').findOne(\n-          { _id: new ObjectId(item.productId) },\n-          { session: dbSession }\n-        );\n+        const quantityField = `quantity${item.size}`;\n+        const outOfStockField = `outOfStock${item.size}`;\n \n-        if (!product) {\n-          console.error(`Product not found: ${item.productId}`);\n-          throw new Error(`Product ${item.productId} not found`);\n-        }\n-\n-        // Cập nhật số lượng theo size\n-        const updateField = `quantity${item.size}`;\n-        const currentQuantity = product[updateField] || 0;\n-        const newQuantity = Math.max(0, currentQuantity - item.quantity);\n-\n-        console.log(`Updating product ${item.productId} - Size ${item.size}:`, {\n-          currentQuantity,\n-          orderedQuantity: item.quantity,\n-          newQuantity\n-        });\n-\n-        // Cập nhật số lượng và trạng thái outOfStock\n+        // Cập nhật số lượng sử dụng $inc để đảm bảo tính atomic\n         const updateResult = await db.collection('products').updateOne(\n-          { _id: new ObjectId(item.productId) },\n           { \n+            _id: new ObjectId(item.productId),\n+            [quantityField]: { $gte: item.quantity } // Kiểm tra lại số lượng trước khi cập nhật\n+          },\n+          { \n+            $inc: { [quantityField]: -item.quantity },\n             $set: { \n-              [updateField]: newQuantity,\n-              [`outOfStock${item.size}`]: newQuantity === 0,\n+              [outOfStockField]: false,\n               updatedAt: new Date()\n             }\n           },\n           { session: dbSession }\n         );\n \n         if (updateResult.modifiedCount === 0) {\n-          throw new Error(`Failed to update product ${item.productId}`);\n+          throw new Error(`Không thể cập nhật số lượng sản phẩm ${item.productId}`);\n         }\n \n-        // Kiểm tra nếu tất cả các size đều hết hàng\n+        // Kiểm tra và cập nhật trạng thái outOfStock\n         const updatedProduct = await db.collection('products').findOne(\n           { _id: new ObjectId(item.productId) },\n           { session: dbSession }\n         );\n \n         if (!updatedProduct) {\n-          throw new Error(`Failed to fetch updated product: ${item.productId}`);\n+          throw new Error(`Không thể lấy thông tin sản phẩm sau khi cập nhật: ${item.productId}`);\n         }\n \n+        // Kiểm tra nếu số lượng mới = 0\n+        if (updatedProduct[quantityField] === 0) {\n+          await db.collection('products').updateOne(\n+            { _id: new ObjectId(item.productId) },\n+            { \n+              $set: { \n+                [outOfStockField]: true,\n+                updatedAt: new Date()\n+              }\n+            },\n+            { session: dbSession }\n+          );\n+        }\n+\n+        // Kiểm tra nếu tất cả các size đều hết hàng\n         const allSizesOutOfStock = ['M', 'L', 'XL', 'Hat'].every(size => \n           (updatedProduct[`quantity${size}`] || 0) === 0\n         );\n \n@@ -138,17 +157,18 @@\n           );\n         }\n \n         // Revalidate trang chi tiết sản phẩm\n-        revalidatePath(`/${product.slug}`);\n+        revalidatePath(`/products/${updatedProduct.slug}`);\n       }\n \n       // Commit transaction\n       await dbSession.commitTransaction();\n \n       // Revalidate các trang liên quan\n       revalidatePath('/products');\n       revalidatePath('/admin/products');\n+      revalidatePath('/orders');\n \n       return NextResponse.json({\n         ok: true,\n         order: {\n@@ -166,15 +186,19 @@\n       await dbSession.endSession();\n     }\n \n   } catch (error) {\n-    console.error('Error creating order:', error);\n+    console.error('Lỗi khi tạo đơn hàng:', error);\n     return NextResponse.json(\n-      { ok: false, message: error instanceof Error ? error.message : 'Failed to create order' },\n+      { \n+        ok: false, \n+        message: error instanceof Error ? error.message : 'Không thể tạo đơn hàng',\n+        error: error instanceof Error ? error.message : 'Unknown error'\n+      },\n       { status: 500 }\n     );\n   } finally {\n-    // Close MongoDB connection\n+    // Đóng kết nối MongoDB\n     if (mongoClient) {\n       await mongoClient.close();\n     }\n   }\n"
                },
                {
                    "date": 1748315151889,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -12,49 +12,30 @@\n   try {\n     const session = await getServerSession(authOptions);\n     const orderData = await req.json();\n     \n-    console.log('Dữ liệu đơn hàng nhận được:', orderData);\n+    console.log('Received order data:', orderData);\n \n-    // Kiểm tra mảng items\n+    // Validate items array\n     if (!Array.isArray(orderData.items) || orderData.items.length === 0) {\n-      console.error('Mảng items không hợp lệ:', orderData.items);\n+      console.error('Invalid items array:', orderData.items);\n       return NextResponse.json(\n-        { ok: false, message: 'Đơn hàng phải có ít nhất một sản phẩm' },\n+        { ok: false, message: 'Order must have at least one item' },\n         { status: 400 }\n       );\n     }\n \n-    // Kết nối MongoDB với hỗ trợ transaction\n+    // Connect to MongoDB with transaction support\n     const { db, client } = await connectToDatabase();\n     mongoClient = client;\n \n-    // Bắt đầu session cho transaction\n+    // Start a session for transaction\n     const dbSession = client.startSession();\n \n     try {\n-      // Bắt đầu transaction\n+      // Start transaction\n       await dbSession.startTransaction();\n \n-      // Kiểm tra số lượng sản phẩm trước khi tạo đơn hàng\n-      for (const item of orderData.items) {\n-        const product = await db.collection('products').findOne(\n-          { _id: new ObjectId(item.productId) },\n-          { session: dbSession }\n-        );\n-\n-        if (!product) {\n-          throw new Error(`Không tìm thấy sản phẩm với ID: ${item.productId}`);\n-        }\n-\n-        const quantityField = `quantity${item.size}`;\n-        const currentQuantity = product[quantityField] || 0;\n-\n-        if (currentQuantity < item.quantity) {\n-          throw new Error(`Số lượng sản phẩm ${product.name} (Size ${item.size}) không đủ. Còn lại: ${currentQuantity}`);\n-        }\n-      }\n-\n       const orderCode = generateOrderCode();\n \n       // Tạo đơn hàng mới\n       const order = {\n@@ -78,69 +59,69 @@\n         note: orderData.note || null,\n         shippingMethod: orderData.shippingMethod || 'standard'\n       };\n \n-      console.log('Đang tạo đơn hàng với dữ liệu:', order);\n+      console.log('Creating order with data:', order);\n \n       const result = await db.collection('orders').insertOne(order, { session: dbSession });\n \n       if (!result.acknowledged) {\n-        console.error('Không thể tạo đơn hàng:', result);\n-        throw new Error('Không thể tạo đơn hàng');\n+        console.error('Failed to insert order:', result);\n+        throw new Error('Failed to create order');\n       }\n \n-      console.log('Đơn hàng được tạo thành công:', result.insertedId);\n+      console.log('Order created successfully:', result.insertedId);\n \n       // Cập nhật số lượng sản phẩm sau khi tạo đơn hàng thành công\n       for (const item of orderData.items) {\n-        const quantityField = `quantity${item.size}`;\n-        const outOfStockField = `outOfStock${item.size}`;\n+        const product = await db.collection('products').findOne(\n+          { _id: new ObjectId(item.productId) },\n+          { session: dbSession }\n+        );\n \n-        // Cập nhật số lượng sử dụng $inc để đảm bảo tính atomic\n+        if (!product) {\n+          console.error(`Product not found: ${item.productId}`);\n+          throw new Error(`Product ${item.productId} not found`);\n+        }\n+\n+        // Cập nhật số lượng theo size\n+        const updateField = `quantity${item.size}`;\n+        const currentQuantity = product[updateField] || 0;\n+        const newQuantity = Math.max(0, currentQuantity - item.quantity);\n+\n+        console.log(`Updating product ${item.productId} - Size ${item.size}:`, {\n+          currentQuantity,\n+          orderedQuantity: item.quantity,\n+          newQuantity\n+        });\n+\n+        // Cập nhật số lượng và trạng thái outOfStock\n         const updateResult = await db.collection('products').updateOne(\n+          { _id: new ObjectId(item.productId) },\n           { \n-            _id: new ObjectId(item.productId),\n-            [quantityField]: { $gte: item.quantity } // Kiểm tra lại số lượng trước khi cập nhật\n-          },\n-          { \n-            $inc: { [quantityField]: -item.quantity },\n             $set: { \n-              [outOfStockField]: false,\n+              [updateField]: newQuantity,\n+              [`outOfStock${item.size}`]: newQuantity === 0,\n               updatedAt: new Date()\n             }\n           },\n           { session: dbSession }\n         );\n \n         if (updateResult.modifiedCount === 0) {\n-          throw new Error(`Không thể cập nhật số lượng sản phẩm ${item.productId}`);\n+          throw new Error(`Failed to update product ${item.productId}`);\n         }\n \n-        // Kiểm tra và cập nhật trạng thái outOfStock\n+        // Kiểm tra nếu tất cả các size đều hết hàng\n         const updatedProduct = await db.collection('products').findOne(\n           { _id: new ObjectId(item.productId) },\n           { session: dbSession }\n         );\n \n         if (!updatedProduct) {\n-          throw new Error(`Không thể lấy thông tin sản phẩm sau khi cập nhật: ${item.productId}`);\n+          throw new Error(`Failed to fetch updated product: ${item.productId}`);\n         }\n \n-        // Kiểm tra nếu số lượng mới = 0\n-        if (updatedProduct[quantityField] === 0) {\n-          await db.collection('products').updateOne(\n-            { _id: new ObjectId(item.productId) },\n-            { \n-              $set: { \n-                [outOfStockField]: true,\n-                updatedAt: new Date()\n-              }\n-            },\n-            { session: dbSession }\n-          );\n-        }\n-\n-        // Kiểm tra nếu tất cả các size đều hết hàng\n         const allSizesOutOfStock = ['M', 'L', 'XL', 'Hat'].every(size => \n           (updatedProduct[`quantity${size}`] || 0) === 0\n         );\n \n@@ -157,18 +138,17 @@\n           );\n         }\n \n         // Revalidate trang chi tiết sản phẩm\n-        revalidatePath(`/products/${updatedProduct.slug}`);\n+        revalidatePath(`/${product.slug}`);\n       }\n \n       // Commit transaction\n       await dbSession.commitTransaction();\n \n       // Revalidate các trang liên quan\n       revalidatePath('/products');\n       revalidatePath('/admin/products');\n-      revalidatePath('/orders');\n \n       return NextResponse.json({\n         ok: true,\n         order: {\n@@ -186,19 +166,15 @@\n       await dbSession.endSession();\n     }\n \n   } catch (error) {\n-    console.error('Lỗi khi tạo đơn hàng:', error);\n+    console.error('Error creating order:', error);\n     return NextResponse.json(\n-      { \n-        ok: false, \n-        message: error instanceof Error ? error.message : 'Không thể tạo đơn hàng',\n-        error: error instanceof Error ? error.message : 'Unknown error'\n-      },\n+      { ok: false, message: error instanceof Error ? error.message : 'Failed to create order' },\n       { status: 500 }\n     );\n   } finally {\n-    // Đóng kết nối MongoDB\n+    // Close MongoDB connection\n     if (mongoClient) {\n       await mongoClient.close();\n     }\n   }\n"
                },
                {
                    "date": 1748315195087,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -34,11 +34,30 @@\n     try {\n       // Start transaction\n       await dbSession.startTransaction();\n \n+      // Check product quantities before creating order\n+      for (const item of orderData.items) {\n+        const product = await db.collection('products').findOne(\n+          { _id: new ObjectId(item.productId) },\n+          { session: dbSession }\n+        );\n+\n+        if (!product) {\n+          throw new Error(`Product not found with ID: ${item.productId}`);\n+        }\n+\n+        const quantityField = `quantity${item.size}`;\n+        const currentQuantity = product[quantityField] || 0;\n+\n+        if (currentQuantity < item.quantity) {\n+          throw new Error(`Insufficient quantity for product ${product.name} (Size ${item.size}). Available: ${currentQuantity}`);\n+        }\n+      }\n+\n       const orderCode = generateOrderCode();\n \n-      // Tạo đơn hàng mới\n+      // Create new order\n       const order = {\n         orderCode,\n         items: orderData.items,\n         total: orderData.total,\n@@ -47,16 +66,16 @@\n         email: orderData.email,\n         userId: session?.user?.email || null,\n         paymentStatus: 'pending',\n         paymentMethod: orderData.paymentMethod || 'cod',\n-        // Thông tin giao hàng\n+        // Shipping information\n         fullName: orderData.fullName,\n         phone: orderData.phone,\n         address: orderData.address,\n         ward: orderData.ward,\n         district: orderData.district,\n         province: orderData.province,\n-        // Thông tin bổ sung\n+        // Additional information\n         note: orderData.note || null,\n         shippingMethod: orderData.shippingMethod || 'standard'\n       };\n \n@@ -70,49 +89,34 @@\n       }\n \n       console.log('Order created successfully:', result.insertedId);\n \n-      // Cập nhật số lượng sản phẩm sau khi tạo đơn hàng thành công\n+      // Update product quantities after successful order creation\n       for (const item of orderData.items) {\n-        const product = await db.collection('products').findOne(\n-          { _id: new ObjectId(item.productId) },\n-          { session: dbSession }\n-        );\n+        const quantityField = `quantity${item.size}`;\n+        const outOfStockField = `outOfStock${item.size}`;\n \n-        if (!product) {\n-          console.error(`Product not found: ${item.productId}`);\n-          throw new Error(`Product ${item.productId} not found`);\n-        }\n-\n-        // Cập nhật số lượng theo size\n-        const updateField = `quantity${item.size}`;\n-        const currentQuantity = product[updateField] || 0;\n-        const newQuantity = Math.max(0, currentQuantity - item.quantity);\n-\n-        console.log(`Updating product ${item.productId} - Size ${item.size}:`, {\n-          currentQuantity,\n-          orderedQuantity: item.quantity,\n-          newQuantity\n-        });\n-\n-        // Cập nhật số lượng và trạng thái outOfStock\n+        // Update quantity using $inc for atomic operation\n         const updateResult = await db.collection('products').updateOne(\n-          { _id: new ObjectId(item.productId) },\n           { \n+            _id: new ObjectId(item.productId),\n+            [quantityField]: { $gte: item.quantity } // Double check quantity before update\n+          },\n+          { \n+            $inc: { [quantityField]: -item.quantity },\n             $set: { \n-              [updateField]: newQuantity,\n-              [`outOfStock${item.size}`]: newQuantity === 0,\n+              [outOfStockField]: false,\n               updatedAt: new Date()\n             }\n           },\n           { session: dbSession }\n         );\n \n         if (updateResult.modifiedCount === 0) {\n-          throw new Error(`Failed to update product ${item.productId}`);\n+          throw new Error(`Failed to update product quantity ${item.productId}`);\n         }\n \n-        // Kiểm tra nếu tất cả các size đều hết hàng\n+        // Check and update outOfStock status\n         const updatedProduct = await db.collection('products').findOne(\n           { _id: new ObjectId(item.productId) },\n           { session: dbSession }\n         );\n@@ -120,8 +124,23 @@\n         if (!updatedProduct) {\n           throw new Error(`Failed to fetch updated product: ${item.productId}`);\n         }\n \n+        // Check if new quantity is 0\n+        if (updatedProduct[quantityField] === 0) {\n+          await db.collection('products').updateOne(\n+            { _id: new ObjectId(item.productId) },\n+            { \n+              $set: { \n+                [outOfStockField]: true,\n+                updatedAt: new Date()\n+              }\n+            },\n+            { session: dbSession }\n+          );\n+        }\n+\n+        // Check if all sizes are out of stock\n         const allSizesOutOfStock = ['M', 'L', 'XL', 'Hat'].every(size => \n           (updatedProduct[`quantity${size}`] || 0) === 0\n         );\n \n@@ -137,18 +156,19 @@\n             { session: dbSession }\n           );\n         }\n \n-        // Revalidate trang chi tiết sản phẩm\n-        revalidatePath(`/${product.slug}`);\n+        // Revalidate product detail page\n+        revalidatePath(`/products/${updatedProduct.slug}`);\n       }\n \n       // Commit transaction\n       await dbSession.commitTransaction();\n \n-      // Revalidate các trang liên quan\n+      // Revalidate related pages\n       revalidatePath('/products');\n       revalidatePath('/admin/products');\n+      revalidatePath('/orders');\n \n       return NextResponse.json({\n         ok: true,\n         order: {\n@@ -157,9 +177,9 @@\n         }\n       });\n \n     } catch (error) {\n-      // Rollback transaction nếu có lỗi\n+      // Rollback transaction on error\n       await dbSession.abortTransaction();\n       throw error;\n     } finally {\n       // End session\n@@ -168,9 +188,13 @@\n \n   } catch (error) {\n     console.error('Error creating order:', error);\n     return NextResponse.json(\n-      { ok: false, message: error instanceof Error ? error.message : 'Failed to create order' },\n+      { \n+        ok: false, \n+        message: error instanceof Error ? error.message : 'Failed to create order',\n+        error: error instanceof Error ? error.message : 'Unknown error'\n+      },\n       { status: 500 }\n     );\n   } finally {\n     // Close MongoDB connection\n"
                },
                {
                    "date": 1748318649255,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -12,9 +12,9 @@\n   try {\n     const session = await getServerSession(authOptions);\n     const orderData = await req.json();\n     \n-    console.log('Received order data:', orderData);\n+    console.log('Received order data:', JSON.stringify(orderData, null, 2));\n \n     // Validate items array\n     if (!Array.isArray(orderData.items) || orderData.items.length === 0) {\n       console.error('Invalid items array:', orderData.items);\n@@ -23,8 +23,19 @@\n         { status: 400 }\n       );\n     }\n \n+    // Validate each item has productId\n+    for (const item of orderData.items) {\n+      if (!item.productId) {\n+        console.error('Item missing productId:', item);\n+        return NextResponse.json(\n+          { ok: false, message: 'Each item must have a productId' },\n+          { status: 400 }\n+        );\n+      }\n+    }\n+\n     // Connect to MongoDB with transaction support\n     const { db, client } = await connectToDatabase();\n     mongoClient = client;\n \n@@ -36,8 +47,9 @@\n       await dbSession.startTransaction();\n \n       // Check product quantities before creating order\n       for (const item of orderData.items) {\n+        console.log('Checking product:', item.productId);\n         const product = await db.collection('products').findOne(\n           { _id: new ObjectId(item.productId) },\n           { session: dbSession }\n         );\n"
                },
                {
                    "date": 1748318755869,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -12,9 +12,9 @@\n   try {\n     const session = await getServerSession(authOptions);\n     const orderData = await req.json();\n     \n-    console.log('Received order data:', JSON.stringify(orderData, null, 2));\n+    console.log('Received order data:', orderData);\n \n     // Validate items array\n     if (!Array.isArray(orderData.items) || orderData.items.length === 0) {\n       console.error('Invalid items array:', orderData.items);\n@@ -23,19 +23,8 @@\n         { status: 400 }\n       );\n     }\n \n-    // Validate each item has productId\n-    for (const item of orderData.items) {\n-      if (!item.productId) {\n-        console.error('Item missing productId:', item);\n-        return NextResponse.json(\n-          { ok: false, message: 'Each item must have a productId' },\n-          { status: 400 }\n-        );\n-      }\n-    }\n-\n     // Connect to MongoDB with transaction support\n     const { db, client } = await connectToDatabase();\n     mongoClient = client;\n \n@@ -47,9 +36,8 @@\n       await dbSession.startTransaction();\n \n       // Check product quantities before creating order\n       for (const item of orderData.items) {\n-        console.log('Checking product:', item.productId);\n         const product = await db.collection('products').findOne(\n           { _id: new ObjectId(item.productId) },\n           { session: dbSession }\n         );\n"
                },
                {
                    "date": 1748320315844,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -78,9 +78,9 @@\n         note: orderData.note || null,\n         shippingMethod: orderData.shippingMethod || 'standard'\n       };\n \n-      console.log('Creating order with data:', order);\n+      console.log('Creating order with data:', JSON.stringify(order, null, 2));\n \n       const result = await db.collection('orders').insertOne(order, { session: dbSession });\n \n       if (!result.acknowledged) {\n"
                },
                {
                    "date": 1748320329415,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -78,9 +78,9 @@\n         note: orderData.note || null,\n         shippingMethod: orderData.shippingMethod || 'standard'\n       };\n \n-      console.log('Creating order with data:', JSON.stringify(order, null, 2));\n+      console.log('Creating order with data:', order);\n \n       const result = await db.collection('orders').insertOne(order, { session: dbSession });\n \n       if (!result.acknowledged) {\n"
                },
                {
                    "date": 1748321320144,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -218,8 +218,9 @@\n \n     const { db } = await connectToDatabase();\n     const query = { userId: session.user.email };\n \n+    // Lấy danh sách đơn hàng của user\n     const orders = await db.collection('orders')\n       .find(query)\n       .sort({ createdAt: -1 })\n       .toArray();\n@@ -234,9 +235,9 @@\n \n   } catch (error) {\n     console.error('Error fetching orders:', error);\n     return NextResponse.json(\n-      { ok: false, message: error instanceof Error ? error.message : 'Failed to fetch orders' },\n+      { ok: false, message: 'Failed to fetch orders' },\n       { status: 500 }\n     );\n   }\n } \n\\ No newline at end of file\n"
                },
                {
                    "date": 1748493118186,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -203,41 +203,67 @@\n     }\n   }\n }\n \n-export async function GET(req: Request) {\n+export async function GET(request: Request) {\n+  let mongoClient = null;\n+  \n   try {\n     const session = await getServerSession(authOptions);\n-    \n-    // Chỉ cho phép xem đơn hàng khi đã đăng nhập\n-    if (!session?.user?.email) {\n+    const { searchParams } = new URL(request.url);\n+    const email = searchParams.get('email');\n+\n+    console.log('Fetching orders for:', { email, sessionEmail: session?.user?.email });\n+\n+    if (!email && !session?.user?.email) {\n+      console.error('No email provided');\n       return NextResponse.json(\n-        { ok: false, message: 'Unauthorized' },\n-        { status: 401 }\n+        { ok: false, message: 'Email is required' },\n+        { status: 400 }\n       );\n     }\n \n-    const { db } = await connectToDatabase();\n-    const query = { userId: session.user.email };\n+    try {\n+      const { db, client } = await connectToDatabase();\n+      mongoClient = client;\n \n-    // Lấy danh sách đơn hàng của user\n-    const orders = await db.collection('orders')\n-      .find(query)\n-      .sort({ createdAt: -1 })\n-      .toArray();\n+      // Find orders by email\n+      const orders = await db.collection('orders')\n+        .find({ email: email || session?.user?.email })\n+        .sort({ createdAt: -1 })\n+        .toArray();\n \n-    return NextResponse.json({\n-      ok: true,\n-      orders: orders.map(order => ({\n-        ...order,\n-        _id: order._id.toString()\n-      }))\n-    });\n+      console.log('Found orders:', orders.length);\n \n+      return NextResponse.json({\n+        ok: true,\n+        orders: orders.map(order => ({\n+          ...order,\n+          _id: order._id.toString()\n+        }))\n+      });\n+\n+    } catch (dbError) {\n+      console.error('Database error:', dbError);\n+      throw dbError;\n+    }\n+\n   } catch (error) {\n     console.error('Error fetching orders:', error);\n     return NextResponse.json(\n-      { ok: false, message: 'Failed to fetch orders' },\n+      { \n+        ok: false, \n+        message: error instanceof Error ? error.message : 'Failed to fetch orders',\n+        error: error instanceof Error ? error.message : 'Unknown error'\n+      },\n       { status: 500 }\n     );\n+  } finally {\n+    if (mongoClient) {\n+      try {\n+        await mongoClient.close();\n+      } catch (closeError) {\n+        console.error('Error closing MongoDB connection:', closeError);\n+      }\n+    }\n   }\n } \n\\ No newline at end of file\n"
                },
                {
                    "date": 1748493168137,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -203,67 +203,40 @@\n     }\n   }\n }\n \n-export async function GET(request: Request) {\n-  let mongoClient = null;\n-  \n+export async function GET(req: Request) {\n   try {\n     const session = await getServerSession(authOptions);\n-    const { searchParams } = new URL(request.url);\n-    const email = searchParams.get('email');\n-\n-    console.log('Fetching orders for:', { email, sessionEmail: session?.user?.email });\n-\n-    if (!email && !session?.user?.email) {\n-      console.error('No email provided');\n+    \n+    // Chỉ cho phép xem đơn hàng khi đã đăng nhập\n+    if (!session?.user?.email) {\n       return NextResponse.json(\n-        { ok: false, message: 'Email is required' },\n-        { status: 400 }\n+        { ok: false, message: 'Unauthorized' },\n+        { status: 401 }\n       );\n     }\n \n-    try {\n-      const { db, client } = await connectToDatabase();\n-      mongoClient = client;\n+    const { db } = await connectToDatabase();\n+    const query = { userId: session.user.email };\n \n-      // Find orders by email\n-      const orders = await db.collection('orders')\n-        .find({ email: email || session?.user?.email })\n-        .sort({ createdAt: -1 })\n-        .toArray();\n+    const orders = await db.collection('orders')\n+      .find(query)\n+      .sort({ createdAt: -1 })\n+      .toArray();\n \n-      console.log('Found orders:', orders.length);\n+    return NextResponse.json({\n+      ok: true,\n+      orders: orders.map(order => ({\n+        ...order,\n+        _id: order._id.toString()\n+      }))\n+    });\n \n-      return NextResponse.json({\n-        ok: true,\n-        orders: orders.map(order => ({\n-          ...order,\n-          _id: order._id.toString()\n-        }))\n-      });\n-\n-    } catch (dbError) {\n-      console.error('Database error:', dbError);\n-      throw dbError;\n-    }\n-\n   } catch (error) {\n     console.error('Error fetching orders:', error);\n     return NextResponse.json(\n-      { \n-        ok: false, \n-        message: error instanceof Error ? error.message : 'Failed to fetch orders',\n-        error: error instanceof Error ? error.message : 'Unknown error'\n-      },\n+      { ok: false, message: error instanceof Error ? error.message : 'Failed to fetch orders' },\n       { status: 500 }\n     );\n-  } finally {\n-    if (mongoClient) {\n-      try {\n-        await mongoClient.close();\n-      } catch (closeError) {\n-        console.error('Error closing MongoDB connection:', closeError);\n-      }\n-    }\n   }\n } \n\\ No newline at end of file\n"
                },
                {
                    "date": 1748616042208,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -75,9 +75,13 @@\n         district: orderData.district,\n         province: orderData.province,\n         // Additional information\n         note: orderData.note || null,\n-        shippingMethod: orderData.shippingMethod || 'standard'\n+        shippingMethod: orderData.shippingMethod || 'standard',\n+        // Promo code information\n+        promoCode: orderData.promoCode || null,\n+        promoAmount: orderData.promoAmount || 0,\n+        subtotal: orderData.subtotal || orderData.total\n       };\n \n       console.log('Creating order with data:', order);\n \n"
                },
                {
                    "date": 1748618331746,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -167,8 +167,34 @@\n \n       // Commit transaction\n       await dbSession.commitTransaction();\n \n+      // Cập nhật mã giảm giá đã sử dụng (sau khi commit thành công)\n+      if (order.promoCode && order.email) { // Chỉ cập nhật nếu có mã giảm giá và có email người dùng\n+          try {\n+              const promoCollection = db.collection('promoCodes'); // Tên collection mã giảm giá\n+              const promoCodeDoc = await promoCollection.findOne({ code: order.promoCode.toUpperCase() });\n+\n+              if (promoCodeDoc) {\n+                  const update: any = { $inc: { usedCount: 1 } };\n+                  \n+                  // Thêm email người dùng vào usedByUsers nếu perUserLimit > 0\n+                  if (promoCodeDoc.perUserLimit > 0) {\n+                      const usedByUsers = promoCodeDoc.usedByUsers || [];\n+                      if (!usedByUsers.includes(order.email)) {\n+                          update.$push = { usedByUsers: order.email };\n+                      }\n+                  }\n+\n+                  await promoCollection.updateOne({ _id: promoCodeDoc._id }, update);\n+                  console.log('Promo code usage updated successfully', { code: order.promoCode, email: order.email });\n+              }\n+          } catch (promoUpdateError) {\n+              console.error('Error updating promo code usage:', promoUpdateError);\n+              // Log lỗi nhưng không rollback transaction chính vì đơn hàng đã được tạo thành công\n+          }\n+      }\n+\n       // Revalidate related pages\n       revalidatePath('/products');\n       revalidatePath('/admin/products');\n       revalidatePath('/orders');\n"
                },
                {
                    "date": 1748618431292,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -167,34 +167,8 @@\n \n       // Commit transaction\n       await dbSession.commitTransaction();\n \n-      // Cập nhật mã giảm giá đã sử dụng (sau khi commit thành công)\n-      if (order.promoCode && order.email) { // Chỉ cập nhật nếu có mã giảm giá và có email người dùng\n-          try {\n-              const promoCollection = db.collection('promoCodes'); // Tên collection mã giảm giá\n-              const promoCodeDoc = await promoCollection.findOne({ code: order.promoCode.toUpperCase() });\n-\n-              if (promoCodeDoc) {\n-                  const update: any = { $inc: { usedCount: 1 } };\n-                  \n-                  // Thêm email người dùng vào usedByUsers nếu perUserLimit > 0\n-                  if (promoCodeDoc.perUserLimit > 0) {\n-                      const usedByUsers = promoCodeDoc.usedByUsers || [];\n-                      if (!usedByUsers.includes(order.email)) {\n-                          update.$push = { usedByUsers: order.email };\n-                      }\n-                  }\n-\n-                  await promoCollection.updateOne({ _id: promoCodeDoc._id }, update);\n-                  console.log('Promo code usage updated successfully', { code: order.promoCode, email: order.email });\n-              }\n-          } catch (promoUpdateError) {\n-              console.error('Error updating promo code usage:', promoUpdateError);\n-              // Log lỗi nhưng không rollback transaction chính vì đơn hàng đã được tạo thành công\n-          }\n-      }\n-\n       // Revalidate related pages\n       revalidatePath('/products');\n       revalidatePath('/admin/products');\n       revalidatePath('/orders');\n"
                },
                {
                    "date": 1748619697861,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -77,9 +77,9 @@\n         // Additional information\n         note: orderData.note || null,\n         shippingMethod: orderData.shippingMethod || 'standard',\n         // Promo code information\n-        promoCode: orderData.promoCode || null,\n+        promoCode: orderData.promoCode && typeof orderData.promoCode === 'object' ? orderData.promoCode : null,\n         promoAmount: orderData.promoAmount || 0,\n         subtotal: orderData.subtotal || orderData.total\n       };\n \n@@ -167,8 +167,27 @@\n \n       // Commit transaction\n       await dbSession.commitTransaction();\n \n+      // Cập nhật mã giảm giá đã sử dụng sau khi commit thành công\n+      if (orderData.promoCode && typeof orderData.promoCode === 'object' && orderData.promoCode.id) {\n+          try {\n+              const promoId = new ObjectId(orderData.promoCode.id);\n+              const update: any = { $inc: { usedCount: 1 } };\n+\n+              // Thêm email người dùng vào usedByUsers nếu perUserLimit > 0 và có email người dùng\n+              if (orderData.promoCode.perUserLimit > 0 && session?.user?.email) {\n+                  update.$addToSet = { usedByUsers: session.user.email };\n+              }\n+\n+              await db.collection('notifications').updateOne({ _id: promoId }, update);\n+              console.log('Promo code usage updated successfully', { code: orderData.promoCode.code, email: session?.user?.email, orderId: result.insertedId });\n+          } catch (promoUpdateError) {\n+              console.error('Error updating promo code usage:', promoUpdateError);\n+              // Log lỗi nhưng không ảnh hưởng đến việc tạo đơn hàng đã commit\n+          }\n+      }\n+\n       // Revalidate related pages\n       revalidatePath('/products');\n       revalidatePath('/admin/products');\n       revalidatePath('/orders');\n"
                },
                {
                    "date": 1748621810784,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -175,9 +175,9 @@\n               const update: any = { $inc: { usedCount: 1 } };\n \n               // Thêm email người dùng vào usedByUsers nếu perUserLimit > 0 và có email người dùng\n               if (orderData.promoCode.perUserLimit > 0 && session?.user?.email) {\n-                  update.$addToSet = { usedByUsers: session.user.email };\n+                  update.$push = { usedByUsers: session.user.email };\n               }\n \n               await db.collection('notifications').updateOne({ _id: promoId }, update);\n               console.log('Promo code usage updated successfully', { code: orderData.promoCode.code, email: session?.user?.email, orderId: result.insertedId });\n"
                },
                {
                    "date": 1748622989266,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -34,9 +34,9 @@\n     try {\n       // Start transaction\n       await dbSession.startTransaction();\n \n-      // Check product quantities before creating order\n+      // Validate items array and check product quantities before creating order\n       for (const item of orderData.items) {\n         const product = await db.collection('products').findOne(\n           { _id: new ObjectId(item.productId) },\n           { session: dbSession }\n@@ -53,8 +53,71 @@\n           throw new Error(`Insufficient quantity for product ${product.name} (Size ${item.size}). Available: ${currentQuantity}`);\n         }\n       }\n \n+      // --- Start Promo Code Validation and Update in Transaction ---\n+      if (orderData.promoCode && typeof orderData.promoCode === 'object' && orderData.promoCode.id) {\n+          const promoId = new ObjectId(orderData.promoCode.id);\n+          const userEmail = session?.user?.email || orderData.email; // Use user email from session or order data\n+\n+          // Fetch the latest promo code document within the transaction\n+          const promoCodeDoc = await db.collection('notifications').findOne(\n+              { _id: promoId, type: 'promo' },\n+              { session: dbSession }\n+          );\n+\n+          if (!promoCodeDoc || !promoCodeDoc.isActive) {\n+              throw new Error('Mã giảm giá không hợp lệ hoặc đã hết hạn');\n+          }\n+\n+          // Re-check validation conditions (similar to apply-promo API)\n+\n+          // Kiểm tra ngày hết hạn\n+          if (promoCodeDoc.expiryDate) {\n+            const expiryDate = new Date(promoCodeDoc.expiryDate);\n+            if (expiryDate < new Date()) {\n+              throw new Error('Mã giảm giá đã hết hạn sử dụng');\n+            }\n+          }\n+\n+          // Kiểm tra yêu cầu đăng nhập\n+          if (promoCodeDoc.isLoginRequired && !userEmail) {\n+             throw new Error('Vui lòng đăng nhập để sử dụng mã này');\n+          }\n+\n+          // Kiểm tra giới hạn sử dụng trên mỗi người dùng\n+          if (promoCodeDoc.perUserLimit > 0 && userEmail) {\n+              const usedByUsers = promoCodeDoc.usedByUsers || [];\n+              const userUsageCount = usedByUsers.filter((email: string) => email === userEmail).length;\n+\n+              if (userUsageCount >= promoCodeDoc.perUserLimit) {\n+                  throw new Error(`Bạn đã sử dụng mã này quá số lần cho phép (${promoCodeDoc.perUserLimit} lần).`);\n+              }\n+          }\n+\n+          // Kiểm tra tổng số lần sử dụng nếu có limit\n+          if (promoCodeDoc.totalUsageLimit && promoCodeDoc.usedCount >= promoCodeDoc.totalUsageLimit) {\n+             throw new Error('Mã giảm giá đã hết lượt sử dụng');\n+          }\n+\n+          // --- If all checks pass, prepare update for promo code (within transaction) ---\n+          const update: any = { $inc: { usedCount: 1 } };\n+\n+          // Thêm email người dùng vào usedByUsers nếu perUserLimit > 0\n+          if (promoCodeDoc.perUserLimit > 0 && userEmail) {\n+              update.$push = { usedByUsers: userEmail };\n+          }\n+\n+          // Perform the update on the promo code within the transaction\n+           await db.collection('notifications').updateOne(\n+               { _id: promoId },\n+               { $set: { ...promoCodeDoc, usedCount: (promoCodeDoc.usedCount || 0) + 1, usedByUsers: update.$push ? [...(promoCodeDoc.usedByUsers || []), update.$push.usedByUsers] : promoCodeDoc.usedByUsers || [] } }, // Manually update object to use $set in transaction\n+               { session: dbSession }\n+           );\n+          console.log('Promo code update prepared within transaction', { code: promoCodeDoc.code, email: userEmail });\n+      }\n+      // --- End Promo Code Validation and Update in Transaction ---\n+\n       const orderCode = generateOrderCode();\n \n       // Create new order\n       const order = {\n@@ -167,27 +230,8 @@\n \n       // Commit transaction\n       await dbSession.commitTransaction();\n \n-      // Cập nhật mã giảm giá đã sử dụng sau khi commit thành công\n-      if (orderData.promoCode && typeof orderData.promoCode === 'object' && orderData.promoCode.id) {\n-          try {\n-              const promoId = new ObjectId(orderData.promoCode.id);\n-              const update: any = { $inc: { usedCount: 1 } };\n-\n-              // Thêm email người dùng vào usedByUsers nếu perUserLimit > 0 và có email người dùng\n-              if (orderData.promoCode.perUserLimit > 0 && session?.user?.email) {\n-                  update.$push = { usedByUsers: session.user.email };\n-              }\n-\n-              await db.collection('notifications').updateOne({ _id: promoId }, update);\n-              console.log('Promo code usage updated successfully', { code: orderData.promoCode.code, email: session?.user?.email, orderId: result.insertedId });\n-          } catch (promoUpdateError) {\n-              console.error('Error updating promo code usage:', promoUpdateError);\n-              // Log lỗi nhưng không ảnh hưởng đến việc tạo đơn hàng đã commit\n-          }\n-      }\n-\n       // Revalidate related pages\n       revalidatePath('/products');\n       revalidatePath('/admin/products');\n       revalidatePath('/orders');\n"
                },
                {
                    "date": 1748623178398,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -86,12 +86,20 @@\n \n           // Kiểm tra giới hạn sử dụng trên mỗi người dùng\n           if (promoCodeDoc.perUserLimit > 0 && userEmail) {\n               const usedByUsers = promoCodeDoc.usedByUsers || [];\n-              const userUsageCount = usedByUsers.filter((email: string) => email === userEmail).length;\n \n-              if (userUsageCount >= promoCodeDoc.perUserLimit) {\n-                  throw new Error(`Bạn đã sử dụng mã này quá số lần cho phép (${promoCodeDoc.perUserLimit} lần).`);\n+              if (promoCodeDoc.perUserLimit === 1) {\n+                  // Basic check for limit 1: see if the user's email is already in usedByUsers\n+                   if (usedByUsers.includes(userEmail)) {\n+                       throw new Error('Bạn chỉ có thể sử dụng mã này một lần.');\n+                   }\n+              } else {\n+                  // For limits greater than 1, count occurrences\n+                  const userUsageCount = usedByUsers.filter((email: string) => email === userEmail).length;\n+                  if (userUsageCount >= promoCodeDoc.perUserLimit) {\n+                      throw new Error(`Bạn đã sử dụng mã này quá số lần cho phép (${promoCodeDoc.perUserLimit} lần).`);\n+                  }\n               }\n           }\n \n           // Kiểm tra tổng số lần sử dụng nếu có limit\n@@ -99,19 +107,19 @@\n              throw new Error('Mã giảm giá đã hết lượt sử dụng');\n           }\n \n           // --- If all checks pass, prepare update for promo code (within transaction) ---\n-          const update: any = { $inc: { usedCount: 1 } };\n+          const updateFields: any = { $inc: { usedCount: 1 } };\n \n           // Thêm email người dùng vào usedByUsers nếu perUserLimit > 0\n           if (promoCodeDoc.perUserLimit > 0 && userEmail) {\n-              update.$push = { usedByUsers: userEmail };\n+              updateFields.$push = { usedByUsers: userEmail };\n           }\n \n           // Perform the update on the promo code within the transaction\n            await db.collection('notifications').updateOne(\n                { _id: promoId },\n-               { $set: { ...promoCodeDoc, usedCount: (promoCodeDoc.usedCount || 0) + 1, usedByUsers: update.$push ? [...(promoCodeDoc.usedByUsers || []), update.$push.usedByUsers] : promoCodeDoc.usedByUsers || [] } }, // Manually update object to use $set in transaction\n+               updateFields,\n                { session: dbSession }\n            );\n           console.log('Promo code update prepared within transaction', { code: promoCodeDoc.code, email: userEmail });\n       }\n"
                },
                {
                    "date": 1748623361672,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -86,20 +86,12 @@\n \n           // Kiểm tra giới hạn sử dụng trên mỗi người dùng\n           if (promoCodeDoc.perUserLimit > 0 && userEmail) {\n               const usedByUsers = promoCodeDoc.usedByUsers || [];\n+              const userUsageCount = usedByUsers.filter((email: string) => email === userEmail).length;\n \n-              if (promoCodeDoc.perUserLimit === 1) {\n-                  // Basic check for limit 1: see if the user's email is already in usedByUsers\n-                   if (usedByUsers.includes(userEmail)) {\n-                       throw new Error('Bạn chỉ có thể sử dụng mã này một lần.');\n-                   }\n-              } else {\n-                  // For limits greater than 1, count occurrences\n-                  const userUsageCount = usedByUsers.filter((email: string) => email === userEmail).length;\n-                  if (userUsageCount >= promoCodeDoc.perUserLimit) {\n-                      throw new Error(`Bạn đã sử dụng mã này quá số lần cho phép (${promoCodeDoc.perUserLimit} lần).`);\n-                  }\n+              if (userUsageCount >= promoCodeDoc.perUserLimit) {\n+                  throw new Error(`Bạn đã sử dụng mã này quá số lần cho phép (${promoCodeDoc.perUserLimit} lần).`);\n               }\n           }\n \n           // Kiểm tra tổng số lần sử dụng nếu có limit\n@@ -107,19 +99,19 @@\n              throw new Error('Mã giảm giá đã hết lượt sử dụng');\n           }\n \n           // --- If all checks pass, prepare update for promo code (within transaction) ---\n-          const updateFields: any = { $inc: { usedCount: 1 } };\n+          const update: any = { $inc: { usedCount: 1 } };\n \n           // Thêm email người dùng vào usedByUsers nếu perUserLimit > 0\n           if (promoCodeDoc.perUserLimit > 0 && userEmail) {\n-              updateFields.$push = { usedByUsers: userEmail };\n+              update.$push = { usedByUsers: userEmail };\n           }\n \n           // Perform the update on the promo code within the transaction\n            await db.collection('notifications').updateOne(\n                { _id: promoId },\n-               updateFields,\n+               { $set: { ...promoCodeDoc, usedCount: (promoCodeDoc.usedCount || 0) + 1, usedByUsers: update.$push ? [...(promoCodeDoc.usedByUsers || []), update.$push.usedByUsers] : promoCodeDoc.usedByUsers || [] } }, // Manually update object to use $set in transaction\n                { session: dbSession }\n            );\n           console.log('Promo code update prepared within transaction', { code: promoCodeDoc.code, email: userEmail });\n       }\n"
                },
                {
                    "date": 1748623473413,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -85,13 +85,30 @@\n           }\n \n           // Kiểm tra giới hạn sử dụng trên mỗi người dùng\n           if (promoCodeDoc.perUserLimit > 0 && userEmail) {\n-              const usedByUsers = promoCodeDoc.usedByUsers || [];\n-              const userUsageCount = usedByUsers.filter((email: string) => email === userEmail).length;\n \n-              if (userUsageCount >= promoCodeDoc.perUserLimit) {\n-                  throw new Error(`Bạn đã sử dụng mã này quá số lần cho phép (${promoCodeDoc.perUserLimit} lần).`);\n+              if (promoCodeDoc.perUserLimit === 1) {\n+                  // For limit 1: Check if the user has any completed orders with this promo code\n+                  const existingCompletedOrder = await db.collection('orders').findOne(\n+                      {\n+                          $or: [{ userId: userEmail }, { email: userEmail }], // Check by userId or email\n+                          \"promoCode.id\": orderData.promoCode.id, // Match the promo code ID\n+                          status: { $in: ['delivered'] } // Check for completed statuses\n+                      },\n+                      { session: dbSession } // Perform this check within the transaction\n+                  );\n+\n+                   if (existingCompletedOrder) {\n+                       throw new Error('Bạn chỉ có thể sử dụng mã này một lần.');\n+                   }\n+              } else {\n+                  // For limits greater than 1, count occurrences in usedByUsers (as a secondary check/info)\n+                  const usedByUsers = promoCodeDoc.usedByUsers || [];\n+                  const userUsageCount = usedByUsers.filter((email: string) => email === userEmail).length;\n+                  if (userUsageCount >= promoCodeDoc.perUserLimit) {\n+                      throw new Error(`Bạn đã sử dụng mã này quá số lần cho phép (${promoCodeDoc.perUserLimit} lần).`);\n+                  }\n               }\n           }\n \n           // Kiểm tra tổng số lần sử dụng nếu có limit\n"
                },
                {
                    "date": 1748623514262,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -85,30 +85,13 @@\n           }\n \n           // Kiểm tra giới hạn sử dụng trên mỗi người dùng\n           if (promoCodeDoc.perUserLimit > 0 && userEmail) {\n+              const usedByUsers = promoCodeDoc.usedByUsers || [];\n+              const userUsageCount = usedByUsers.filter((email: string) => email === userEmail).length;\n \n-              if (promoCodeDoc.perUserLimit === 1) {\n-                  // For limit 1: Check if the user has any completed orders with this promo code\n-                  const existingCompletedOrder = await db.collection('orders').findOne(\n-                      {\n-                          $or: [{ userId: userEmail }, { email: userEmail }], // Check by userId or email\n-                          \"promoCode.id\": orderData.promoCode.id, // Match the promo code ID\n-                          status: { $in: ['delivered'] } // Check for completed statuses\n-                      },\n-                      { session: dbSession } // Perform this check within the transaction\n-                  );\n-\n-                   if (existingCompletedOrder) {\n-                       throw new Error('Bạn chỉ có thể sử dụng mã này một lần.');\n-                   }\n-              } else {\n-                  // For limits greater than 1, count occurrences in usedByUsers (as a secondary check/info)\n-                  const usedByUsers = promoCodeDoc.usedByUsers || [];\n-                  const userUsageCount = usedByUsers.filter((email: string) => email === userEmail).length;\n-                  if (userUsageCount >= promoCodeDoc.perUserLimit) {\n-                      throw new Error(`Bạn đã sử dụng mã này quá số lần cho phép (${promoCodeDoc.perUserLimit} lần).`);\n-                  }\n+              if (userUsageCount >= promoCodeDoc.perUserLimit) {\n+                  throw new Error(`Bạn đã sử dụng mã này quá số lần cho phép (${promoCodeDoc.perUserLimit} lần).`);\n               }\n           }\n \n           // Kiểm tra tổng số lần sử dụng nếu có limit\n"
                },
                {
                    "date": 1748623548299,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -68,9 +68,9 @@\n           if (!promoCodeDoc || !promoCodeDoc.isActive) {\n               throw new Error('Mã giảm giá không hợp lệ hoặc đã hết hạn');\n           }\n \n-          // Re-check validation conditions (similar to apply-promo API)\n+          // Re-check validation conditions\n \n           // Kiểm tra ngày hết hạn\n           if (promoCodeDoc.expiryDate) {\n             const expiryDate = new Date(promoCodeDoc.expiryDate);\n@@ -85,35 +85,48 @@\n           }\n \n           // Kiểm tra giới hạn sử dụng trên mỗi người dùng\n           if (promoCodeDoc.perUserLimit > 0 && userEmail) {\n-              const usedByUsers = promoCodeDoc.usedByUsers || [];\n-              const userUsageCount = usedByUsers.filter((email: string) => email === userEmail).length;\n-\n-              if (userUsageCount >= promoCodeDoc.perUserLimit) {\n-                  throw new Error(`Bạn đã sử dụng mã này quá số lần cho phép (${promoCodeDoc.perUserLimit} lần).`);\n+              if (promoCodeDoc.perUserLimit === 1) {\n+                  // For limit 1: Check the specific single-user flag\n+                   if (promoCodeDoc.usedBySingleUser && promoCodeDoc.usedBySingleUser.email === userEmail) {\n+                       // If already used by this specific user\n+                        throw new Error('Bạn chỉ có thể sử dụng mã này một lần.');\n+                   } else if (promoCodeDoc.usedBySingleUser) {\n+                       // If used by another user (shouldn't happen with perUserLimit 1 and this logic, but as a safeguard)\n+                       throw new Error('Mã giảm giá đã được sử dụng tối đa số lần.');\n+                   }\n+              } else {\n+                  // For limits greater than 1, count occurrences in usedByUsers\n+                  const usedByUsers = promoCodeDoc.usedByUsers || [];\n+                  const userUsageCount = usedByUsers.filter((email: string) => email === userEmail).length;\n+                  if (userUsageCount >= promoCodeDoc.perUserLimit) {\n+                      throw new Error(`Bạn đã sử dụng mã này quá số lần cho phép (${promoCodeDoc.perUserLimit} lần).`);\n+                  }\n               }\n           }\n \n           // Kiểm tra tổng số lần sử dụng nếu có limit\n           if (promoCodeDoc.totalUsageLimit && promoCodeDoc.usedCount >= promoCodeDoc.totalUsageLimit) {\n-             throw new Error('Mã giảm giá đã hết lượt sử dụng');\n+             throw new Error('Mã giảm giá đã hết lượt sử dụng.');\n           }\n \n           // --- If all checks pass, prepare update for promo code (within transaction) ---\n-          const update: any = { $inc: { usedCount: 1 } };\n+           const updateFields: any = { $inc: { usedCount: 1 } };\n \n-          // Thêm email người dùng vào usedByUsers nếu perUserLimit > 0\n-          if (promoCodeDoc.perUserLimit > 0 && userEmail) {\n-              update.$push = { usedByUsers: userEmail };\n-          }\n+           if (promoCodeDoc.perUserLimit === 1 && userEmail) {\n+               // For limit 1, set the single-user flag\n+               updateFields.$set = { usedBySingleUser: { email: userEmail, orderId: null } }; // Set orderId after insert\n+           } else if (promoCodeDoc.perUserLimit > 1 && userEmail) {\n+               // For limit > 1, push email to usedByUsers array\n+               updateFields.$push = { usedByUsers: userEmail };\n+           }\n \n-          // Perform the update on the promo code within the transaction\n-           await db.collection('notifications').updateOne(\n-               { _id: promoId },\n-               { $set: { ...promoCodeDoc, usedCount: (promoCodeDoc.usedCount || 0) + 1, usedByUsers: update.$push ? [...(promoCodeDoc.usedByUsers || []), update.$push.usedByUsers] : promoCodeDoc.usedByUsers || [] } }, // Manually update object to use $set in transaction\n+            await db.collection('notifications').updateOne(\n+                { _id: promoId },\n+                updateFields,\n                { session: dbSession }\n-           );\n+            );\n           console.log('Promo code update prepared within transaction', { code: promoCodeDoc.code, email: userEmail });\n       }\n       // --- End Promo Code Validation and Update in Transaction ---\n \n@@ -149,11 +162,15 @@\n       console.log('Creating order with data:', order);\n \n       const result = await db.collection('orders').insertOne(order, { session: dbSession });\n \n-      if (!result.acknowledged) {\n-        console.error('Failed to insert order:', result);\n-        throw new Error('Failed to create order');\n+      // If order creation is successful, update the orderId in the promo code document (for limit 1)\n+      if (promoCodeDoc?.perUserLimit === 1 && userEmail && result.acknowledged) {\n+          await db.collection('notifications').updateOne(\n+              { _id: new ObjectId(orderData.promoCode.id) },\n+              { $set: { 'usedBySingleUser.orderId': result.insertedId.toString() } },\n+              { session: dbSession }\n+          );\n       }\n \n       console.log('Order created successfully:', result.insertedId);\n \n"
                },
                {
                    "date": 1748623556637,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -163,11 +163,13 @@\n \n       const result = await db.collection('orders').insertOne(order, { session: dbSession });\n \n       // If order creation is successful, update the orderId in the promo code document (for limit 1)\n-      if (promoCodeDoc?.perUserLimit === 1 && userEmail && result.acknowledged) {\n+      if (orderData.promoCode && typeof orderData.promoCode === 'object' && orderData.promoCode.id && orderData.promoCode.perUserLimit === 1 && (session?.user?.email || orderData.email) && result.acknowledged) {\n+          const promoId = new ObjectId(orderData.promoCode.id);\n+          const userEmail = session?.user?.email || orderData.email; // Ensure userEmail is defined\n           await db.collection('notifications').updateOne(\n-              { _id: new ObjectId(orderData.promoCode.id) },\n+              { _id: promoId },\n               { $set: { 'usedBySingleUser.orderId': result.insertedId.toString() } },\n               { session: dbSession }\n           );\n       }\n"
                },
                {
                    "date": 1748624285470,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -68,9 +68,9 @@\n           if (!promoCodeDoc || !promoCodeDoc.isActive) {\n               throw new Error('Mã giảm giá không hợp lệ hoặc đã hết hạn');\n           }\n \n-          // Re-check validation conditions\n+          // Re-check validation conditions (similar to apply-promo API)\n \n           // Kiểm tra ngày hết hạn\n           if (promoCodeDoc.expiryDate) {\n             const expiryDate = new Date(promoCodeDoc.expiryDate);\n@@ -85,48 +85,35 @@\n           }\n \n           // Kiểm tra giới hạn sử dụng trên mỗi người dùng\n           if (promoCodeDoc.perUserLimit > 0 && userEmail) {\n-              if (promoCodeDoc.perUserLimit === 1) {\n-                  // For limit 1: Check the specific single-user flag\n-                   if (promoCodeDoc.usedBySingleUser && promoCodeDoc.usedBySingleUser.email === userEmail) {\n-                       // If already used by this specific user\n-                        throw new Error('Bạn chỉ có thể sử dụng mã này một lần.');\n-                   } else if (promoCodeDoc.usedBySingleUser) {\n-                       // If used by another user (shouldn't happen with perUserLimit 1 and this logic, but as a safeguard)\n-                       throw new Error('Mã giảm giá đã được sử dụng tối đa số lần.');\n-                   }\n-              } else {\n-                  // For limits greater than 1, count occurrences in usedByUsers\n-                  const usedByUsers = promoCodeDoc.usedByUsers || [];\n-                  const userUsageCount = usedByUsers.filter((email: string) => email === userEmail).length;\n-                  if (userUsageCount >= promoCodeDoc.perUserLimit) {\n-                      throw new Error(`Bạn đã sử dụng mã này quá số lần cho phép (${promoCodeDoc.perUserLimit} lần).`);\n-                  }\n+              const usedByUsers = promoCodeDoc.usedByUsers || [];\n+              const userUsageCount = usedByUsers.filter((email: string) => email === userEmail).length;\n+\n+              if (userUsageCount >= promoCodeDoc.perUserLimit) {\n+                  throw new Error(`Bạn đã sử dụng mã này quá số lần cho phép (${promoCodeDoc.perUserLimit} lần).`);\n               }\n           }\n \n           // Kiểm tra tổng số lần sử dụng nếu có limit\n           if (promoCodeDoc.totalUsageLimit && promoCodeDoc.usedCount >= promoCodeDoc.totalUsageLimit) {\n-             throw new Error('Mã giảm giá đã hết lượt sử dụng.');\n+             throw new Error('Mã giảm giá đã hết lượt sử dụng');\n           }\n \n           // --- If all checks pass, prepare update for promo code (within transaction) ---\n-           const updateFields: any = { $inc: { usedCount: 1 } };\n+          const update: any = { $inc: { usedCount: 1 } };\n \n-           if (promoCodeDoc.perUserLimit === 1 && userEmail) {\n-               // For limit 1, set the single-user flag\n-               updateFields.$set = { usedBySingleUser: { email: userEmail, orderId: null } }; // Set orderId after insert\n-           } else if (promoCodeDoc.perUserLimit > 1 && userEmail) {\n-               // For limit > 1, push email to usedByUsers array\n-               updateFields.$push = { usedByUsers: userEmail };\n-           }\n+          // Thêm email người dùng vào usedByUsers nếu perUserLimit > 0\n+          if (promoCodeDoc.perUserLimit > 0 && userEmail) {\n+              update.$push = { usedByUsers: userEmail };\n+          }\n \n-            await db.collection('notifications').updateOne(\n-                { _id: promoId },\n-                updateFields,\n+          // Perform the update on the promo code within the transaction\n+           await db.collection('notifications').updateOne(\n+               { _id: promoId },\n+               { $set: { ...promoCodeDoc, usedCount: (promoCodeDoc.usedCount || 0) + 1, usedByUsers: update.$push ? [...(promoCodeDoc.usedByUsers || []), update.$push.usedByUsers] : promoCodeDoc.usedByUsers || [] } }, // Manually update object to use $set in transaction\n                { session: dbSession }\n-            );\n+           );\n           console.log('Promo code update prepared within transaction', { code: promoCodeDoc.code, email: userEmail });\n       }\n       // --- End Promo Code Validation and Update in Transaction ---\n \n@@ -162,17 +149,11 @@\n       console.log('Creating order with data:', order);\n \n       const result = await db.collection('orders').insertOne(order, { session: dbSession });\n \n-      // If order creation is successful, update the orderId in the promo code document (for limit 1)\n-      if (orderData.promoCode && typeof orderData.promoCode === 'object' && orderData.promoCode.id && orderData.promoCode.perUserLimit === 1 && (session?.user?.email || orderData.email) && result.acknowledged) {\n-          const promoId = new ObjectId(orderData.promoCode.id);\n-          const userEmail = session?.user?.email || orderData.email; // Ensure userEmail is defined\n-          await db.collection('notifications').updateOne(\n-              { _id: promoId },\n-              { $set: { 'usedBySingleUser.orderId': result.insertedId.toString() } },\n-              { session: dbSession }\n-          );\n+      if (!result.acknowledged) {\n+        console.error('Failed to insert order:', result);\n+        throw new Error('Failed to create order');\n       }\n \n       console.log('Order created successfully:', result.insertedId);\n \n"
                },
                {
                    "date": 1748624326285,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -85,13 +85,30 @@\n           }\n \n           // Kiểm tra giới hạn sử dụng trên mỗi người dùng\n           if (promoCodeDoc.perUserLimit > 0 && userEmail) {\n-              const usedByUsers = promoCodeDoc.usedByUsers || [];\n-              const userUsageCount = usedByUsers.filter((email: string) => email === userEmail).length;\n \n-              if (userUsageCount >= promoCodeDoc.perUserLimit) {\n-                  throw new Error(`Bạn đã sử dụng mã này quá số lần cho phép (${promoCodeDoc.perUserLimit} lần).`);\n+              if (promoCodeDoc.perUserLimit === 1) {\n+                  // For limit 1: Check if the user has any processed or completed orders with this promo code\n+                  const existingProcessedOrCompletedOrder = await db.collection('orders').findOne(\n+                      {\n+                          $or: [{ userId: userEmail }, { email: userEmail }], // Check by userId or email\n+                          \"promoCode.id\": orderData.promoCode.id, // Match the promo code ID\n+                          status: { $in: ['processing', 'shipped', 'delivered'] } // Check for processed/completed statuses\n+                      },\n+                      { session: dbSession } // Perform this check within the transaction\n+                  );\n+\n+                   if (existingProcessedOrCompletedOrder) {\n+                       throw new Error('Bạn chỉ có thể sử dụng mã này một lần.');\n+                   }\n+              } else {\n+                  // For limits greater than 1, count occurrences in usedByUsers\n+                  const usedByUsers = promoCodeDoc.usedByUsers || [];\n+                  const userUsageCount = usedByUsers.filter((email: string) => email === userEmail).length;\n+                  if (userUsageCount >= promoCodeDoc.perUserLimit) {\n+                      throw new Error(`Bạn đã sử dụng mã này quá số lần cho phép (${promoCodeDoc.perUserLimit} lần).`);\n+                  }\n               }\n           }\n \n           // Kiểm tra tổng số lần sử dụng nếu có limit\n@@ -99,19 +116,20 @@\n              throw new Error('Mã giảm giá đã hết lượt sử dụng');\n           }\n \n           // --- If all checks pass, prepare update for promo code (within transaction) ---\n-          const update: any = { $inc: { usedCount: 1 } };\n+          const updateFields: any = { $inc: { usedCount: 1 } };\n \n-          // Thêm email người dùng vào usedByUsers nếu perUserLimit > 0\n+          // Thêm email người dùng vào usedByUsers nếu perUserLimit > 0 (để theo dõi và sử dụng cho limit > 1)\n           if (promoCodeDoc.perUserLimit > 0 && userEmail) {\n-              update.$push = { usedByUsers: userEmail };\n+              // Use $push to record each usage instance for counting (relevant for limit > 1)\n+              updateFields.$push = { usedByUsers: userEmail };\n           }\n \n           // Perform the update on the promo code within the transaction\n            await db.collection('notifications').updateOne(\n                { _id: promoId },\n-               { $set: { ...promoCodeDoc, usedCount: (promoCodeDoc.usedCount || 0) + 1, usedByUsers: update.$push ? [...(promoCodeDoc.usedByUsers || []), update.$push.usedByUsers] : promoCodeDoc.usedByUsers || [] } }, // Manually update object to use $set in transaction\n+               updateFields,\n                { session: dbSession }\n            );\n           console.log('Promo code update prepared within transaction', { code: promoCodeDoc.code, email: userEmail });\n       }\n"
                },
                {
                    "date": 1748624418413,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -87,19 +87,19 @@\n           // Kiểm tra giới hạn sử dụng trên mỗi người dùng\n           if (promoCodeDoc.perUserLimit > 0 && userEmail) {\n \n               if (promoCodeDoc.perUserLimit === 1) {\n-                  // For limit 1: Check if the user has any processed or completed orders with this promo code\n-                  const existingProcessedOrCompletedOrder = await db.collection('orders').findOne(\n+                  // For limit 1: Check if the user has any previous orders with this promo code (regardless of status)\n+                  const existingOrderWithPromo = await db.collection('orders').findOne(\n                       {\n                           $or: [{ userId: userEmail }, { email: userEmail }], // Check by userId or email\n                           \"promoCode.id\": orderData.promoCode.id, // Match the promo code ID\n-                          status: { $in: ['processing', 'shipped', 'delivered'] } // Check for processed/completed statuses\n+                          // Removed status filter: status: { $in: ['processing', 'shipped', 'delivered'] }\n                       },\n                       { session: dbSession } // Perform this check within the transaction\n                   );\n \n-                   if (existingProcessedOrCompletedOrder) {\n+                   if (existingOrderWithPromo) {\n                        throw new Error('Bạn chỉ có thể sử dụng mã này một lần.');\n                    }\n               } else {\n                   // For limits greater than 1, count occurrences in usedByUsers\n"
                },
                {
                    "date": 1748624614123,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -87,19 +87,19 @@\n           // Kiểm tra giới hạn sử dụng trên mỗi người dùng\n           if (promoCodeDoc.perUserLimit > 0 && userEmail) {\n \n               if (promoCodeDoc.perUserLimit === 1) {\n-                  // For limit 1: Check if the user has any previous orders with this promo code (regardless of status)\n-                  const existingOrderWithPromo = await db.collection('orders').findOne(\n+                  // For limit 1: Check if the user has any processed or completed orders with this promo code\n+                  const existingProcessedOrCompletedOrder = await db.collection('orders').findOne(\n                       {\n                           $or: [{ userId: userEmail }, { email: userEmail }], // Check by userId or email\n                           \"promoCode.id\": orderData.promoCode.id, // Match the promo code ID\n-                          // Removed status filter: status: { $in: ['processing', 'shipped', 'delivered'] }\n+                          status: { $in: ['processing', 'shipped', 'delivered'] } // Check for processed/completed statuses\n                       },\n                       { session: dbSession } // Perform this check within the transaction\n                   );\n \n-                   if (existingOrderWithPromo) {\n+                   if (existingProcessedOrCompletedOrder) {\n                        throw new Error('Bạn chỉ có thể sử dụng mã này một lần.');\n                    }\n               } else {\n                   // For limits greater than 1, count occurrences in usedByUsers\n"
                },
                {
                    "date": 1748624619386,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -85,30 +85,13 @@\n           }\n \n           // Kiểm tra giới hạn sử dụng trên mỗi người dùng\n           if (promoCodeDoc.perUserLimit > 0 && userEmail) {\n+              const usedByUsers = promoCodeDoc.usedByUsers || [];\n+              const userUsageCount = usedByUsers.filter((email: string) => email === userEmail).length;\n \n-              if (promoCodeDoc.perUserLimit === 1) {\n-                  // For limit 1: Check if the user has any processed or completed orders with this promo code\n-                  const existingProcessedOrCompletedOrder = await db.collection('orders').findOne(\n-                      {\n-                          $or: [{ userId: userEmail }, { email: userEmail }], // Check by userId or email\n-                          \"promoCode.id\": orderData.promoCode.id, // Match the promo code ID\n-                          status: { $in: ['processing', 'shipped', 'delivered'] } // Check for processed/completed statuses\n-                      },\n-                      { session: dbSession } // Perform this check within the transaction\n-                  );\n-\n-                   if (existingProcessedOrCompletedOrder) {\n-                       throw new Error('Bạn chỉ có thể sử dụng mã này một lần.');\n-                   }\n-              } else {\n-                  // For limits greater than 1, count occurrences in usedByUsers\n-                  const usedByUsers = promoCodeDoc.usedByUsers || [];\n-                  const userUsageCount = usedByUsers.filter((email: string) => email === userEmail).length;\n-                  if (userUsageCount >= promoCodeDoc.perUserLimit) {\n-                      throw new Error(`Bạn đã sử dụng mã này quá số lần cho phép (${promoCodeDoc.perUserLimit} lần).`);\n-                  }\n+              if (userUsageCount >= promoCodeDoc.perUserLimit) {\n+                  throw new Error(`Bạn đã sử dụng mã này quá số lần cho phép (${promoCodeDoc.perUserLimit} lần).`);\n               }\n           }\n \n           // Kiểm tra tổng số lần sử dụng nếu có limit\n@@ -116,20 +99,19 @@\n              throw new Error('Mã giảm giá đã hết lượt sử dụng');\n           }\n \n           // --- If all checks pass, prepare update for promo code (within transaction) ---\n-          const updateFields: any = { $inc: { usedCount: 1 } };\n+          const update: any = { $inc: { usedCount: 1 } };\n \n-          // Thêm email người dùng vào usedByUsers nếu perUserLimit > 0 (để theo dõi và sử dụng cho limit > 1)\n+          // Thêm email người dùng vào usedByUsers nếu perUserLimit > 0\n           if (promoCodeDoc.perUserLimit > 0 && userEmail) {\n-              // Use $push to record each usage instance for counting (relevant for limit > 1)\n-              updateFields.$push = { usedByUsers: userEmail };\n+              update.$push = { usedByUsers: userEmail };\n           }\n \n           // Perform the update on the promo code within the transaction\n            await db.collection('notifications').updateOne(\n                { _id: promoId },\n-               updateFields,\n+               { $set: { ...promoCodeDoc, usedCount: (promoCodeDoc.usedCount || 0) + 1, usedByUsers: update.$push ? [...(promoCodeDoc.usedByUsers || []), update.$push.usedByUsers] : promoCodeDoc.usedByUsers || [] } }, // Manually update object to use $set in transaction\n                { session: dbSession }\n            );\n           console.log('Promo code update prepared within transaction', { code: promoCodeDoc.code, email: userEmail });\n       }\n"
                },
                {
                    "date": 1748624669438,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -68,9 +68,9 @@\n           if (!promoCodeDoc || !promoCodeDoc.isActive) {\n               throw new Error('Mã giảm giá không hợp lệ hoặc đã hết hạn');\n           }\n \n-          // Re-check validation conditions (similar to apply-promo API)\n+          // Re-check validation conditions\n \n           // Kiểm tra ngày hết hạn\n           if (promoCodeDoc.expiryDate) {\n             const expiryDate = new Date(promoCodeDoc.expiryDate);\n@@ -85,36 +85,51 @@\n           }\n \n           // Kiểm tra giới hạn sử dụng trên mỗi người dùng\n           if (promoCodeDoc.perUserLimit > 0 && userEmail) {\n-              const usedByUsers = promoCodeDoc.usedByUsers || [];\n-              const userUsageCount = usedByUsers.filter((email: string) => email === userEmail).length;\n+              if (promoCodeDoc.perUserLimit === 1) {\n+                  // For limit 1: Check if the user has any previous orders with this promo code (regardless of status)\n+                  const existingOrderWithPromo = await db.collection('orders').findOne(\n+                      {\n+                          $or: [{ userId: userEmail }, { email: userEmail }], // Check by userId or email\n+                          \"promoCode.id\": orderData.promoCode.id, // Match the promo code ID\n+                          // No status filter: count any previous order using this promo code\n+                      },\n+                      { session: dbSession } // Perform this check within the transaction\n+                  );\n \n-              if (userUsageCount >= promoCodeDoc.perUserLimit) {\n-                  throw new Error(`Bạn đã sử dụng mã này quá số lần cho phép (${promoCodeDoc.perUserLimit} lần).`);\n+                   if (existingOrderWithPromo) {\n+                       throw new Error('Bạn chỉ có thể sử dụng mã này một lần.');\n+                   }\n+              } else {\n+                  // For limits greater than 1, count occurrences in usedByUsers\n+                  const usedByUsers = promoCodeDoc.usedByUsers || [];\n+                  const userUsageCount = usedByUsers.filter((email: string) => email === userEmail).length;\n+                  if (userUsageCount >= promoCodeDoc.perUserLimit) {\n+                      throw new Error(`Bạn đã sử dụng mã này quá số lần cho phép (${promoCodeDoc.perUserLimit} lần).`);\n+                  }\n               }\n           }\n \n           // Kiểm tra tổng số lần sử dụng nếu có limit\n           if (promoCodeDoc.totalUsageLimit && promoCodeDoc.usedCount >= promoCodeDoc.totalUsageLimit) {\n-             throw new Error('Mã giảm giá đã hết lượt sử dụng');\n+             throw new Error('Mã giảm giá đã hết lượt sử dụng.');\n           }\n \n-          // --- If all checks pass, prepare update for promo code (within transaction) ---\n-          const update: any = { $inc: { usedCount: 1 } };\n+          // --- If all checks pass, update promo code using atomic operators (within transaction) ---\n+           const updateFields: any = { $inc: { usedCount: 1 } };\n \n-          // Thêm email người dùng vào usedByUsers nếu perUserLimit > 0\n-          if (promoCodeDoc.perUserLimit > 0 && userEmail) {\n-              update.$push = { usedByUsers: userEmail };\n-          }\n+           // Use $push to add user email to usedByUsers array (relevant for all perUserLimit > 0)\n+           if (promoCodeDoc.perUserLimit > 0 && userEmail) {\n+               updateFields.$push = { usedByUsers: userEmail };\n+           }\n \n-          // Perform the update on the promo code within the transaction\n-           await db.collection('notifications').updateOne(\n-               { _id: promoId },\n-               { $set: { ...promoCodeDoc, usedCount: (promoCodeDoc.usedCount || 0) + 1, usedByUsers: update.$push ? [...(promoCodeDoc.usedByUsers || []), update.$push.usedByUsers] : promoCodeDoc.usedByUsers || [] } }, // Manually update object to use $set in transaction\n+            await db.collection('notifications').updateOne(\n+                { _id: promoId },\n+                updateFields,\n                { session: dbSession }\n-           );\n-          console.log('Promo code update prepared within transaction', { code: promoCodeDoc.code, email: userEmail });\n+            );\n+          console.log('Promo code update performed within transaction', { code: promoCodeDoc.code, email: userEmail });\n       }\n       // --- End Promo Code Validation and Update in Transaction ---\n \n       const orderCode = generateOrderCode();\n"
                },
                {
                    "date": 1748624855821,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -85,29 +85,21 @@\n           }\n \n           // Kiểm tra giới hạn sử dụng trên mỗi người dùng\n           if (promoCodeDoc.perUserLimit > 0 && userEmail) {\n-              if (promoCodeDoc.perUserLimit === 1) {\n-                  // For limit 1: Check if the user has any previous orders with this promo code (regardless of status)\n-                  const existingOrderWithPromo = await db.collection('orders').findOne(\n-                      {\n-                          $or: [{ userId: userEmail }, { email: userEmail }], // Check by userId or email\n-                          \"promoCode.id\": orderData.promoCode.id, // Match the promo code ID\n-                          // No status filter: count any previous order using this promo code\n-                      },\n-                      { session: dbSession } // Perform this check within the transaction\n-                  );\n \n-                   if (existingOrderWithPromo) {\n-                       throw new Error('Bạn chỉ có thể sử dụng mã này một lần.');\n-                   }\n-              } else {\n-                  // For limits greater than 1, count occurrences in usedByUsers\n-                  const usedByUsers = promoCodeDoc.usedByUsers || [];\n-                  const userUsageCount = usedByUsers.filter((email: string) => email === userEmail).length;\n-                  if (userUsageCount >= promoCodeDoc.perUserLimit) {\n-                      throw new Error(`Bạn đã sử dụng mã này quá số lần cho phép (${promoCodeDoc.perUserLimit} lần).`);\n-                  }\n+              // Query orders collection within the transaction to count user's previous completed/processed orders with this promo code\n+              const userUsageCountInOrders = await db.collection('orders').countDocuments(\n+                  {\n+                      $or: [{ userId: userEmail }, { email: userEmail }], // Check by userId or email\n+                      \"promoCode.id\": orderData.promoCode.id, // Match the promo code ID\n+                      status: { $in: ['processing', 'shipped', 'delivered'] } // Count only processed/completed orders\n+                  },\n+                  { session: dbSession } // Perform this count within the transaction\n+              );\n+\n+              if (userUsageCountInOrders >= promoCodeDoc.perUserLimit) {\n+                  throw new Error(`Bạn đã sử dụng mã này quá số lần cho phép (${promoCodeDoc.perUserLimit} lần).`);\n               }\n           }\n \n           // Kiểm tra tổng số lần sử dụng nếu có limit\n@@ -117,10 +109,10 @@\n \n           // --- If all checks pass, update promo code using atomic operators (within transaction) ---\n            const updateFields: any = { $inc: { usedCount: 1 } };\n \n-           // Use $push to add user email to usedByUsers array (relevant for all perUserLimit > 0)\n-           if (promoCodeDoc.perUserLimit > 0 && userEmail) {\n+           // Optionally: Use $push to add user email to usedByUsers array (for tracking, not for limit enforcement anymore)\n+           if (userEmail) { // Push email regardless of perUserLimit > 0, for general tracking\n                updateFields.$push = { usedByUsers: userEmail };\n            }\n \n             await db.collection('notifications').updateOne(\n"
                },
                {
                    "date": 1748624945426,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -91,9 +91,8 @@\n               const userUsageCountInOrders = await db.collection('orders').countDocuments(\n                   {\n                       $or: [{ userId: userEmail }, { email: userEmail }], // Check by userId or email\n                       \"promoCode.id\": orderData.promoCode.id, // Match the promo code ID\n-                      status: { $in: ['processing', 'shipped', 'delivered'] } // Count only processed/completed orders\n                   },\n                   { session: dbSession } // Perform this count within the transaction\n               );\n \n"
                },
                {
                    "date": 1748625149542,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -86,18 +86,24 @@\n \n           // Kiểm tra giới hạn sử dụng trên mỗi người dùng\n           if (promoCodeDoc.perUserLimit > 0 && userEmail) {\n \n+              console.log(`Checking perUserLimit for user: ${userEmail}, promoCodeId: ${orderData.promoCode.id}, limit: ${promoCodeDoc.perUserLimit}`);\n+\n               // Query orders collection within the transaction to count user's previous completed/processed orders with this promo code\n               const userUsageCountInOrders = await db.collection('orders').countDocuments(\n                   {\n                       $or: [{ userId: userEmail }, { email: userEmail }], // Check by userId or email\n                       \"promoCode.id\": orderData.promoCode.id, // Match the promo code ID\n+                      // No status filter: count any previous order using this promo code\n                   },\n                   { session: dbSession } // Perform this count within the transaction\n               );\n \n+              console.log(`Found ${userUsageCountInOrders} previous orders for user ${userEmail} with promo code ${orderData.promoCode.code}`);\n+\n               if (userUsageCountInOrders >= promoCodeDoc.perUserLimit) {\n+                  console.log(`User ${userEmail} exceeded perUserLimit for promo code ${orderData.promoCode.code}. Limit: ${promoCodeDoc.perUserLimit}, Found: ${userUsageCountInOrders}`);\n                   throw new Error(`Bạn đã sử dụng mã này quá số lần cho phép (${promoCodeDoc.perUserLimit} lần).`);\n               }\n           }\n \n"
                },
                {
                    "date": 1748625614356,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -14,8 +14,23 @@\n     const orderData = await req.json();\n     \n     console.log('Received order data:', orderData);\n \n+    // Check if promoCode is a JSON string and parse it\n+    let promoCodeObject = null;\n+    if (orderData.promoCode) {\n+        if (typeof orderData.promoCode === 'string') {\n+            try {\n+                promoCodeObject = JSON.parse(orderData.promoCode);\n+            } catch (e) {\n+                console.error('Failed to parse promoCode JSON string:', e);\n+                // Keep it null if parsing fails\n+            }\n+        } else if (typeof orderData.promoCode === 'object') {\n+            promoCodeObject = orderData.promoCode;\n+        }\n+    }\n+\n     // Validate items array\n     if (!Array.isArray(orderData.items) || orderData.items.length === 0) {\n       console.error('Invalid items array:', orderData.items);\n       return NextResponse.json(\n@@ -54,10 +69,10 @@\n         }\n       }\n \n       // --- Start Promo Code Validation and Update in Transaction ---\n-      if (orderData.promoCode && typeof orderData.promoCode === 'object' && orderData.promoCode.id) {\n-          const promoId = new ObjectId(orderData.promoCode.id);\n+      if (promoCodeObject && promoCodeObject.id) {\n+          const promoId = new ObjectId(promoCodeObject.id);\n           const userEmail = session?.user?.email || orderData.email; // Use user email from session or order data\n \n           // Fetch the latest promo code document within the transaction\n           const promoCodeDoc = await db.collection('notifications').findOne(\n@@ -86,24 +101,24 @@\n \n           // Kiểm tra giới hạn sử dụng trên mỗi người dùng\n           if (promoCodeDoc.perUserLimit > 0 && userEmail) {\n \n-              console.log(`Checking perUserLimit for user: ${userEmail}, promoCodeId: ${orderData.promoCode.id}, limit: ${promoCodeDoc.perUserLimit}`);\n+              console.log(`Checking perUserLimit for user: ${userEmail}, promoCodeId: ${promoCodeObject.id}, limit: ${promoCodeDoc.perUserLimit}`);\n \n               // Query orders collection within the transaction to count user's previous completed/processed orders with this promo code\n               const userUsageCountInOrders = await db.collection('orders').countDocuments(\n                   {\n                       $or: [{ userId: userEmail }, { email: userEmail }], // Check by userId or email\n-                      \"promoCode.id\": orderData.promoCode.id, // Match the promo code ID\n+                      \"promoCode.id\": promoCodeObject.id, // Match the promo code ID (using parsed object)\n                       // No status filter: count any previous order using this promo code\n                   },\n                   { session: dbSession } // Perform this count within the transaction\n               );\n \n-              console.log(`Found ${userUsageCountInOrders} previous orders for user ${userEmail} with promo code ${orderData.promoCode.code}`);\n+              console.log(`Found ${userUsageCountInOrders} previous orders for user ${userEmail} with promo code ${promoCodeObject.code}`);\n \n               if (userUsageCountInOrders >= promoCodeDoc.perUserLimit) {\n-                  console.log(`User ${userEmail} exceeded perUserLimit for promo code ${orderData.promoCode.code}. Limit: ${promoCodeDoc.perUserLimit}, Found: ${userUsageCountInOrders}`);\n+                  console.log(`User ${userEmail} exceeded perUserLimit for promo code ${promoCodeObject.code}. Limit: ${promoCodeDoc.perUserLimit}, Found: ${userUsageCountInOrders}`);\n                   throw new Error(`Bạn đã sử dụng mã này quá số lần cho phép (${promoCodeDoc.perUserLimit} lần).`);\n               }\n           }\n \n@@ -114,9 +129,9 @@\n \n           // --- If all checks pass, update promo code using atomic operators (within transaction) ---\n            const updateFields: any = { $inc: { usedCount: 1 } };\n \n-           // Optionally: Use $push to add user email to usedByUsers array (for tracking, not for limit enforcement anymore)\n+           // Use $push to add user email to usedByUsers array (relevant for all perUserLimit > 0)\n            if (userEmail) { // Push email regardless of perUserLimit > 0, for general tracking\n                updateFields.$push = { usedByUsers: userEmail };\n            }\n \n@@ -151,10 +166,10 @@\n         province: orderData.province,\n         // Additional information\n         note: orderData.note || null,\n         shippingMethod: orderData.shippingMethod || 'standard',\n-        // Promo code information\n-        promoCode: orderData.promoCode && typeof orderData.promoCode === 'object' ? orderData.promoCode : null,\n+        // Promo code information - use the parsed object for saving\n+        promoCode: promoCodeObject, // Save the parsed object\n         promoAmount: orderData.promoAmount || 0,\n         subtotal: orderData.subtotal || orderData.total\n       };\n \n"
                },
                {
                    "date": 1748625839645,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -104,14 +104,18 @@\n \n               console.log(`Checking perUserLimit for user: ${userEmail}, promoCodeId: ${promoCodeObject.id}, limit: ${promoCodeDoc.perUserLimit}`);\n \n               // Query orders collection within the transaction to count user's previous completed/processed orders with this promo code\n+              const queryFilter = {\n+                  $or: [{ userId: userEmail }, { email: userEmail }], // Check by userId or email\n+                  \"promoCode.id\": promoCodeObject.id, // Match the promo code ID (using parsed object)\n+                  // No status filter: count any previous order using this promo code\n+              };\n+\n+              console.log('CountDocuments query filter:', JSON.stringify(queryFilter, null, 2));\n+\n               const userUsageCountInOrders = await db.collection('orders').countDocuments(\n-                  {\n-                      $or: [{ userId: userEmail }, { email: userEmail }], // Check by userId or email\n-                      \"promoCode.id\": promoCodeObject.id, // Match the promo code ID (using parsed object)\n-                      // No status filter: count any previous order using this promo code\n-                  },\n+                  queryFilter,\n                   { session: dbSession } // Perform this count within the transaction\n               );\n \n               console.log(`Found ${userUsageCountInOrders} previous orders for user ${userEmail} with promo code ${promoCodeObject.code}`);\n"
                },
                {
                    "date": 1748625855057,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -104,18 +104,14 @@\n \n               console.log(`Checking perUserLimit for user: ${userEmail}, promoCodeId: ${promoCodeObject.id}, limit: ${promoCodeDoc.perUserLimit}`);\n \n               // Query orders collection within the transaction to count user's previous completed/processed orders with this promo code\n-              const queryFilter = {\n-                  $or: [{ userId: userEmail }, { email: userEmail }], // Check by userId or email\n-                  \"promoCode.id\": promoCodeObject.id, // Match the promo code ID (using parsed object)\n-                  // No status filter: count any previous order using this promo code\n-              };\n-\n-              console.log('CountDocuments query filter:', JSON.stringify(queryFilter, null, 2));\n-\n               const userUsageCountInOrders = await db.collection('orders').countDocuments(\n-                  queryFilter,\n+                  {\n+                      $or: [{ userId: userEmail }, { email: userEmail }], // Check by userId or email\n+                      \"promoCode.id\": promoCodeObject.id, // Match the promo code ID (using parsed object)\n+                      // No status filter: count any previous order using this promo code\n+                  },\n                   { session: dbSession } // Perform this count within the transaction\n               );\n \n               console.log(`Found ${userUsageCountInOrders} previous orders for user ${userEmail} with promo code ${promoCodeObject.code}`);\n"
                },
                {
                    "date": 1748626003389,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -68,12 +68,12 @@\n           throw new Error(`Insufficient quantity for product ${product.name} (Size ${item.size}). Available: ${currentQuantity}`);\n         }\n       }\n \n-      // --- Start Promo Code Validation and Update in Transaction ---\n-      if (promoCodeObject && promoCodeObject.id) {\n+      // --- Promo Code Validation and Update in Transaction ---\n+      if (orderData.promoCode && typeof orderData.promoCode === 'object' && orderData.promoCode.id) {\n           const promoId = new ObjectId(promoCodeObject.id);\n-          const userEmail = session?.user?.email || orderData.email; // Use user email from session or order data\n+          const userEmail = session?.user?.email || orderData.email;\n \n           // Fetch the latest promo code document within the transaction\n           const promoCodeDoc = await db.collection('notifications').findOne(\n               { _id: promoId, type: 'promo' },\n@@ -84,9 +84,8 @@\n               throw new Error('Mã giảm giá không hợp lệ hoặc đã hết hạn');\n           }\n \n           // Re-check validation conditions\n-\n           // Kiểm tra ngày hết hạn\n           if (promoCodeDoc.expiryDate) {\n             const expiryDate = new Date(promoCodeDoc.expiryDate);\n             if (expiryDate < new Date()) {\n@@ -100,48 +99,38 @@\n           }\n \n           // Kiểm tra giới hạn sử dụng trên mỗi người dùng\n           if (promoCodeDoc.perUserLimit > 0 && userEmail) {\n-\n-              console.log(`Checking perUserLimit for user: ${userEmail}, promoCodeId: ${promoCodeObject.id}, limit: ${promoCodeDoc.perUserLimit}`);\n-\n-              // Query orders collection within the transaction to count user's previous completed/processed orders with this promo code\n+              // Query orders collection within the transaction to count user's previous orders with this promo code\n               const userUsageCountInOrders = await db.collection('orders').countDocuments(\n                   {\n-                      $or: [{ userId: userEmail }, { email: userEmail }], // Check by userId or email\n-                      \"promoCode.id\": promoCodeObject.id, // Match the promo code ID (using parsed object)\n-                      // No status filter: count any previous order using this promo code\n+                      $or: [{ userId: userEmail }, { email: userEmail }],\n+                      \"promoCode.id\": promoCodeObject.id,\n                   },\n-                  { session: dbSession } // Perform this count within the transaction\n+                  { session: dbSession }\n               );\n \n-              console.log(`Found ${userUsageCountInOrders} previous orders for user ${userEmail} with promo code ${promoCodeObject.code}`);\n-\n               if (userUsageCountInOrders >= promoCodeDoc.perUserLimit) {\n-                  console.log(`User ${userEmail} exceeded perUserLimit for promo code ${promoCodeObject.code}. Limit: ${promoCodeDoc.perUserLimit}, Found: ${userUsageCountInOrders}`);\n-                  throw new Error(`Bạn đã sử dụng mã này quá số lần cho phép (${promoCodeDoc.perUserLimit} lần).`);\n+                  throw new Error(`Bạn đã sử dụng mã này quá số lần cho phép (${promoCodeDoc.perUserLimit} lần)`);\n               }\n           }\n \n           // Kiểm tra tổng số lần sử dụng nếu có limit\n           if (promoCodeDoc.totalUsageLimit && promoCodeDoc.usedCount >= promoCodeDoc.totalUsageLimit) {\n              throw new Error('Mã giảm giá đã hết lượt sử dụng.');\n           }\n \n-          // --- If all checks pass, update promo code using atomic operators (within transaction) ---\n-           const updateFields: any = { $inc: { usedCount: 1 } };\n+          // Update promo code usage within the transaction\n+          const updateFields: any = { $inc: { usedCount: 1 } };\n+          if (userEmail) {\n+              updateFields.$push = { usedByUsers: userEmail };\n+          }\n \n-           // Use $push to add user email to usedByUsers array (relevant for all perUserLimit > 0)\n-           if (userEmail) { // Push email regardless of perUserLimit > 0, for general tracking\n-               updateFields.$push = { usedByUsers: userEmail };\n-           }\n-\n-            await db.collection('notifications').updateOne(\n-                { _id: promoId },\n-                updateFields,\n-               { session: dbSession }\n-            );\n-          console.log('Promo code update performed within transaction', { code: promoCodeDoc.code, email: userEmail });\n+          await db.collection('notifications').updateOne(\n+              { _id: promoId },\n+              updateFields,\n+              { session: dbSession }\n+          );\n       }\n       // --- End Promo Code Validation and Update in Transaction ---\n \n       const orderCode = generateOrderCode();\n"
                },
                {
                    "date": 1748626859245,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -155,10 +155,19 @@\n         province: orderData.province,\n         // Additional information\n         note: orderData.note || null,\n         shippingMethod: orderData.shippingMethod || 'standard',\n-        // Promo code information - use the parsed object for saving\n-        promoCode: promoCodeObject, // Save the parsed object\n+        // Promo code information - only save necessary fields\n+        promoCode: promoCodeObject ? {\n+          id: promoCodeObject.id,\n+          code: promoCodeObject.code,\n+          type: promoCodeObject.type,\n+          value: promoCodeObject.value,\n+          maxAmount: promoCodeObject.maxAmount || null,\n+          isLoginRequired: Boolean(promoCodeObject.isLoginRequired),\n+          perUserLimit: Number(promoCodeObject.perUserLimit) || 0,\n+          expiryDate: promoCodeObject.expiryDate ? new Date(promoCodeObject.expiryDate).toISOString() : null\n+        } : null,\n         promoAmount: orderData.promoAmount || 0,\n         subtotal: orderData.subtotal || orderData.total\n       };\n \n"
                },
                {
                    "date": 1748626885794,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -157,19 +157,14 @@\n         note: orderData.note || null,\n         shippingMethod: orderData.shippingMethod || 'standard',\n         // Promo code information - only save necessary fields\n         promoCode: promoCodeObject ? {\n-          id: promoCodeObject.id,\n           code: promoCodeObject.code,\n           type: promoCodeObject.type,\n           value: promoCodeObject.value,\n-          maxAmount: promoCodeObject.maxAmount || null,\n-          isLoginRequired: Boolean(promoCodeObject.isLoginRequired),\n-          perUserLimit: Number(promoCodeObject.perUserLimit) || 0,\n-          expiryDate: promoCodeObject.expiryDate ? new Date(promoCodeObject.expiryDate).toISOString() : null\n+          maxAmount: promoCodeObject.maxAmount || null\n         } : null,\n-        promoAmount: orderData.promoAmount || 0,\n-        subtotal: orderData.subtotal || orderData.total\n+        promoAmount: orderData.promoAmount || 0\n       };\n \n       console.log('Creating order with data:', order);\n \n"
                },
                {
                    "date": 1748627146521,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -103,9 +103,9 @@\n               // Query orders collection within the transaction to count user's previous orders with this promo code\n               const userUsageCountInOrders = await db.collection('orders').countDocuments(\n                   {\n                       $or: [{ userId: userEmail }, { email: userEmail }],\n-                      \"promoCode.id\": promoCodeObject.id,\n+                      \"promoCode.code\": promoCodeObject.code\n                   },\n                   { session: dbSession }\n               );\n \n"
                },
                {
                    "date": 1748627271129,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -103,9 +103,9 @@\n               // Query orders collection within the transaction to count user's previous orders with this promo code\n               const userUsageCountInOrders = await db.collection('orders').countDocuments(\n                   {\n                       $or: [{ userId: userEmail }, { email: userEmail }],\n-                      \"promoCode.code\": promoCodeObject.code\n+                      \"promoCode.id\": promoCodeObject.id,\n                   },\n                   { session: dbSession }\n               );\n \n"
                },
                {
                    "date": 1748627296583,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -157,14 +157,19 @@\n         note: orderData.note || null,\n         shippingMethod: orderData.shippingMethod || 'standard',\n         // Promo code information - only save necessary fields\n         promoCode: promoCodeObject ? {\n+          id: promoCodeObject.id,\n           code: promoCodeObject.code,\n           type: promoCodeObject.type,\n           value: promoCodeObject.value,\n-          maxAmount: promoCodeObject.maxAmount || null\n+          maxAmount: promoCodeObject.maxAmount || null,\n+          isLoginRequired: Boolean(promoCodeObject.isLoginRequired),\n+          perUserLimit: Number(promoCodeObject.perUserLimit) || 0,\n+          expiryDate: promoCodeObject.expiryDate ? new Date(promoCodeObject.expiryDate).toISOString() : null\n         } : null,\n-        promoAmount: orderData.promoAmount || 0\n+        promoAmount: orderData.promoAmount || 0,\n+        subtotal: orderData.subtotal || orderData.total\n       };\n \n       console.log('Creating order with data:', order);\n \n"
                },
                {
                    "date": 1748627868605,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -157,19 +157,14 @@\n         note: orderData.note || null,\n         shippingMethod: orderData.shippingMethod || 'standard',\n         // Promo code information - only save necessary fields\n         promoCode: promoCodeObject ? {\n-          id: promoCodeObject.id,\n           code: promoCodeObject.code,\n           type: promoCodeObject.type,\n           value: promoCodeObject.value,\n-          maxAmount: promoCodeObject.maxAmount || null,\n-          isLoginRequired: Boolean(promoCodeObject.isLoginRequired),\n-          perUserLimit: Number(promoCodeObject.perUserLimit) || 0,\n-          expiryDate: promoCodeObject.expiryDate ? new Date(promoCodeObject.expiryDate).toISOString() : null\n+          maxAmount: promoCodeObject.maxAmount || null\n         } : null,\n-        promoAmount: orderData.promoAmount || 0,\n-        subtotal: orderData.subtotal || orderData.total\n+        promoAmount: orderData.promoAmount || 0\n       };\n \n       console.log('Creating order with data:', order);\n \n"
                },
                {
                    "date": 1748628445029,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -157,14 +157,19 @@\n         note: orderData.note || null,\n         shippingMethod: orderData.shippingMethod || 'standard',\n         // Promo code information - only save necessary fields\n         promoCode: promoCodeObject ? {\n+          id: promoCodeObject.id,\n           code: promoCodeObject.code,\n           type: promoCodeObject.type,\n           value: promoCodeObject.value,\n-          maxAmount: promoCodeObject.maxAmount || null\n+          maxAmount: promoCodeObject.maxAmount || null,\n+          isLoginRequired: Boolean(promoCodeObject.isLoginRequired),\n+          perUserLimit: Number(promoCodeObject.perUserLimit) || 0,\n+          expiryDate: promoCodeObject.expiryDate ? new Date(promoCodeObject.expiryDate).toISOString() : null\n         } : null,\n-        promoAmount: orderData.promoAmount || 0\n+        promoAmount: orderData.promoAmount || 0,\n+        subtotal: orderData.subtotal || orderData.total\n       };\n \n       console.log('Creating order with data:', order);\n \n"
                },
                {
                    "date": 1748628743711,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -157,19 +157,14 @@\n         note: orderData.note || null,\n         shippingMethod: orderData.shippingMethod || 'standard',\n         // Promo code information - only save necessary fields\n         promoCode: promoCodeObject ? {\n-          id: promoCodeObject.id,\n           code: promoCodeObject.code,\n           type: promoCodeObject.type,\n           value: promoCodeObject.value,\n-          maxAmount: promoCodeObject.maxAmount || null,\n-          isLoginRequired: Boolean(promoCodeObject.isLoginRequired),\n-          perUserLimit: Number(promoCodeObject.perUserLimit) || 0,\n-          expiryDate: promoCodeObject.expiryDate ? new Date(promoCodeObject.expiryDate).toISOString() : null\n+          maxAmount: promoCodeObject.maxAmount || null\n         } : null,\n-        promoAmount: orderData.promoAmount || 0,\n-        subtotal: orderData.subtotal || orderData.total\n+        promoAmount: orderData.promoAmount || 0\n       };\n \n       console.log('Creating order with data:', order);\n \n"
                },
                {
                    "date": 1748628756778,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -157,14 +157,19 @@\n         note: orderData.note || null,\n         shippingMethod: orderData.shippingMethod || 'standard',\n         // Promo code information - only save necessary fields\n         promoCode: promoCodeObject ? {\n+          id: promoCodeObject.id,\n           code: promoCodeObject.code,\n           type: promoCodeObject.type,\n           value: promoCodeObject.value,\n-          maxAmount: promoCodeObject.maxAmount || null\n+          maxAmount: promoCodeObject.maxAmount || null,\n+          isLoginRequired: Boolean(promoCodeObject.isLoginRequired),\n+          perUserLimit: Number(promoCodeObject.perUserLimit) || 0,\n+          expiryDate: promoCodeObject.expiryDate ? new Date(promoCodeObject.expiryDate).toISOString() : null\n         } : null,\n-        promoAmount: orderData.promoAmount || 0\n+        promoAmount: orderData.promoAmount || 0,\n+        subtotal: orderData.subtotal || orderData.total\n       };\n \n       console.log('Creating order with data:', order);\n \n"
                },
                {
                    "date": 1749537506699,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -74,10 +74,10 @@\n           const promoId = new ObjectId(promoCodeObject.id);\n           const userEmail = session?.user?.email || orderData.email;\n \n           // Fetch the latest promo code document within the transaction\n-          const promoCodeDoc = await db.collection('notifications').findOne(\n-              { _id: promoId, type: 'promo' },\n+          const promoCodeDoc = await db.collection('promoCodes').findOne(\n+              { _id: promoId },\n               { session: dbSession }\n           );\n \n           if (!promoCodeDoc || !promoCodeDoc.isActive) {\n@@ -124,9 +124,9 @@\n           if (userEmail) {\n               updateFields.$push = { usedByUsers: userEmail };\n           }\n \n-          await db.collection('notifications').updateOne(\n+          await db.collection('promoCodes').updateOne(\n               { _id: promoId },\n               updateFields,\n               { session: dbSession }\n           );\n"
                },
                {
                    "date": 1750472276517,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -155,8 +155,9 @@\n         province: orderData.province,\n         // Additional information\n         note: orderData.note || null,\n         shippingMethod: orderData.shippingMethod || 'standard',\n+        shippingFee: orderData.shippingFee || 'Free (Express)',\n         // Promo code information - only save necessary fields\n         promoCode: promoCodeObject ? {\n           id: promoCodeObject.id,\n           code: promoCodeObject.code,\n"
                },
                {
                    "date": 1751249782819,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -60,10 +60,15 @@\n         if (!product) {\n           throw new Error(`Product not found with ID: ${item.productId}`);\n         }\n \n-        const quantityField = `quantity${item.size}`;\n-        const currentQuantity = product[quantityField] || 0;\n+        let currentQuantity = 0;\n+        if (product.category === 'CAP') {\n+          currentQuantity = product.quantityHat || 0;\n+        } else {\n+          const quantityField = `quantity${item.size}`;\n+          currentQuantity = product[quantityField] || 0;\n+        }\n \n         if (currentQuantity < item.quantity) {\n           throw new Error(`Insufficient quantity for product ${product.name} (Size ${item.size}). Available: ${currentQuantity}`);\n         }\n@@ -184,11 +189,21 @@\n       console.log('Order created successfully:', result.insertedId);\n \n       // Update product quantities after successful order creation\n       for (const item of orderData.items) {\n-        const quantityField = `quantity${item.size}`;\n-        const outOfStockField = `outOfStock${item.size}`;\n-\n+        const product = await db.collection('products').findOne(\n+          { _id: new ObjectId(item.productId) },\n+          { session: dbSession }\n+        );\n+        if (!product) {\n+          throw new Error(`Product not found with ID: ${item.productId}`);\n+        }\n+        let quantityField = `quantity${item.size}`;\n+        let outOfStockField = `outOfStock${item.size}`;\n+        if (product.category === 'CAP') {\n+          quantityField = 'quantityHat';\n+          outOfStockField = 'outOfStockHat';\n+        }\n         // Update quantity using $inc for atomic operation\n         const updateResult = await db.collection('products').updateOne(\n           { \n             _id: new ObjectId(item.productId),\n"
                }
            ],
            "date": 1747807963740,
            "name": "Commit-0",
            "content": "import { NextResponse } from 'next/server';\r\nimport { connectToDatabase } from '@/lib/mongodb';\r\nimport { ObjectId } from 'mongodb';\r\n\r\nexport async function POST(request: Request) {\r\n  try {\r\n    const orderData = await request.json();\r\n    const { db } = await connectToDatabase();\r\n\r\n    // Tạo đơn hàng mới\r\n    const order = {\r\n      ...orderData,\r\n      _id: new ObjectId(),\r\n      createdAt: new Date(),\r\n      updatedAt: new Date(),\r\n      status: 'pending',\r\n      paymentStatus: 'pending',\r\n      shippingStatus: 'pending'\r\n    };\r\n\r\n    // Lưu vào database\r\n    const result = await db.collection('orders').insertOne(order);\r\n\r\n    if (!result.acknowledged) {\r\n      throw new Error('Failed to create order');\r\n    }\r\n\r\n    return NextResponse.json({\r\n      ok: true,\r\n      order: {\r\n        ...order,\r\n        _id: order._id.toString()\r\n      }\r\n    });\r\n  } catch (error) {\r\n    console.error('Error creating order:', error);\r\n    return NextResponse.json(\r\n      { ok: false, message: 'Failed to create order' },\r\n      { status: 500 }\r\n    );\r\n  }\r\n}\r\n\r\nexport async function GET(request: Request) {\r\n  try {\r\n    const { searchParams } = new URL(request.url);\r\n    const orderCode = searchParams.get('orderCode');\r\n\r\n    if (!orderCode) {\r\n      return NextResponse.json(\r\n        { ok: false, message: 'Order code is required' },\r\n        { status: 400 }\r\n      );\r\n    }\r\n\r\n    const { db } = await connectToDatabase();\r\n    const order = await db.collection('orders').findOne({ orderCode });\r\n\r\n    if (!order) {\r\n      return NextResponse.json(\r\n        { ok: false, message: 'Order not found' },\r\n        { status: 404 }\r\n      );\r\n    }\r\n\r\n    return NextResponse.json({\r\n      ok: true,\r\n      order: {\r\n        ...order,\r\n        _id: order._id.toString()\r\n      }\r\n    });\r\n  } catch (error) {\r\n    console.error('Error fetching order:', error);\r\n    return NextResponse.json(\r\n      { ok: false, message: 'Failed to fetch order' },\r\n      { status: 500 }\r\n    );\r\n  }\r\n} "
        }
    ]
}