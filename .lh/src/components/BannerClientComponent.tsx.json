{
    "sourceFile": "src/components/BannerClientComponent.tsx",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 45,
            "patches": [
                {
                    "date": 1750476985213,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1750476997829,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -7,15 +7,33 @@\n \r\n const DEFAULT_BANNER_IMAGE = \"/images/image1.jpg\";\r\n const SCROLL_ANIMATION_DURATION = 700;\r\n \r\n-function easeInOutCubic(t) {\r\n+// Type definitions\r\n+interface Banner {\r\n+  _id: string;\r\n+  imageUrl: string;\r\n+  title?: string;\r\n+  isMobile: boolean;\r\n+  blurDataURL?: string;\r\n+}\r\n+\r\n+interface BannerItemProps {\r\n+  banner: Banner;\r\n+  idx: number;\r\n+}\r\n+\r\n+interface BannerClientComponentProps {\r\n+  initialBanners: Banner[];\r\n+}\r\n+\r\n+function easeInOutCubic(t: number) {\r\n   return t < 0.5\r\n     ? 4 * t * t * t\r\n     : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;\r\n }\r\n \r\n-const BannerItem = React.memo(({ banner, idx }) => (\r\n+const BannerItem = React.memo(({ banner, idx }: BannerItemProps) => (\r\n   <div\r\n     key={banner._id || idx}\r\n     className=\"relative w-full h-screen flex items-center justify-center m-0 p-0 overflow-hidden\"\r\n   >\r\n@@ -45,17 +63,17 @@\n ));\r\n BannerItem.displayName = 'BannerItem';\r\n \r\n \r\n-export default function BannerClientComponent({ initialBanners }) {\r\n+export default function BannerClientComponent({ initialBanners }: BannerClientComponentProps) {\r\n   const [currentImage, setCurrentImage] = useState(0);\r\n   const [banners, setBanners] = useState(initialBanners);\r\n   const [isScrolling, setIsScrolling] = useState(false);\r\n   const router = useRouter();\r\n \r\n   // Scroll handler\r\n   const handleScroll = useCallback(\r\n-    (e) => {\r\n+    (e: WheelEvent) => {\r\n       if (isScrolling || banners.length < 2) return;\r\n       \r\n       e.preventDefault();\r\n       \r\n@@ -73,9 +91,9 @@\n       const start = window.scrollY;\r\n       const end = newIdx * winH;\r\n       const startTime = performance.now();\r\n \r\n-      function animateScroll(now) {\r\n+      function animateScroll(now: number) {\r\n         const elapsed = now - startTime;\r\n         const progress = Math.min(elapsed / SCROLL_ANIMATION_DURATION, 1);\r\n         window.scrollTo(0, start + (end - start) * easeInOutCubic(progress));\r\n         if (progress < 1) {\r\n@@ -94,17 +112,17 @@\n   useEffect(() => {\r\n     // Set scroll to top on mount\r\n     window.scrollTo(0, 0);\r\n \r\n-    const debouncedScroll = (e) => {\r\n+    const debouncedScroll = (e: WheelEvent) => {\r\n         // Simple debounce, main logic is in handleScroll\r\n         if (!isScrolling) {\r\n             handleScroll(e);\r\n         }\r\n     };\r\n \r\n-    window.addEventListener(\"wheel\", debouncedScroll, { passive: false });\r\n-    return () => window.removeEventListener(\"wheel\", debouncedScroll);\r\n+    window.addEventListener(\"wheel\", debouncedScroll as EventListener, { passive: false });\r\n+    return () => window.removeEventListener(\"wheel\", debouncedScroll as EventListener);\r\n   }, [handleScroll, isScrolling]);\r\n \r\n \r\n   // Memoize banner items to prevent unnecessary re-renders\r\n"
                },
                {
                    "date": 1750477999563,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,174 +1,1 @@\n-\"use client\";\r\n-import { useState, useEffect, useCallback, useMemo } from \"react\";\r\n-import { useRouter } from \"next/navigation\";\r\n-import { motion } from \"framer-motion\";\r\n-import Image from \"next/image\";\r\n-import React from \"react\";\r\n-\r\n-const DEFAULT_BANNER_IMAGE = \"/images/image1.jpg\";\r\n-const SCROLL_ANIMATION_DURATION = 700;\r\n-\r\n-// Type definitions\r\n-interface Banner {\r\n-  _id: string;\r\n-  imageUrl: string;\r\n-  title?: string;\r\n-  isMobile: boolean;\r\n-  blurDataURL?: string;\r\n-}\r\n-\r\n-interface BannerItemProps {\r\n-  banner: Banner;\r\n-  idx: number;\r\n-}\r\n-\r\n-interface BannerClientComponentProps {\r\n-  initialBanners: Banner[];\r\n-}\r\n-\r\n-function easeInOutCubic(t: number) {\r\n-  return t < 0.5\r\n-    ? 4 * t * t * t\r\n-    : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;\r\n-}\r\n-\r\n-const BannerItem = React.memo(({ banner, idx }: BannerItemProps) => (\r\n-  <div\r\n-    key={banner._id || idx}\r\n-    className=\"relative w-full h-screen flex items-center justify-center m-0 p-0 overflow-hidden\"\r\n-  >\r\n-    <div className=\"relative w-full h-full flex items-center justify-center bg-black m-0 p-0\">\r\n-      <Image\r\n-        src={banner.imageUrl}\r\n-        alt={banner.title || `Banner ${idx + 1}`}\r\n-        fill\r\n-        className=\"object-cover\"\r\n-        priority={idx === 0} // Only prioritize the first image\r\n-        loading={idx === 0 ? \"eager\" : \"lazy\"} // Eager load the first, lazy load the rest\r\n-        sizes=\"100vw\"\r\n-        quality={90}\r\n-        placeholder=\"blur\"\r\n-        blurDataURL={banner.blurDataURL || \"data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7\"}\r\n-        style={{\r\n-          objectFit: 'cover',\r\n-          objectPosition: 'center',\r\n-          willChange: 'transform',\r\n-        }}\r\n-        onError={(e) => {\r\n-          e.currentTarget.src = DEFAULT_BANNER_IMAGE;\r\n-        }}\r\n-      />\r\n-    </div>\r\n-  </div>\r\n-));\r\n-BannerItem.displayName = 'BannerItem';\r\n-\r\n-\r\n-export default function BannerClientComponent({ initialBanners }: BannerClientComponentProps) {\r\n-  const [currentImage, setCurrentImage] = useState(0);\r\n-  const [banners, setBanners] = useState(initialBanners);\r\n-  const [isScrolling, setIsScrolling] = useState(false);\r\n-  const router = useRouter();\r\n-\r\n-  // Scroll handler\r\n-  const handleScroll = useCallback(\r\n-    (e: WheelEvent) => {\r\n-      if (isScrolling || banners.length < 2) return;\r\n-      \r\n-      e.preventDefault();\r\n-      \r\n-      const delta = Math.sign(e.deltaY);\r\n-      const newIdx = currentImage + delta;\r\n-\r\n-      if (newIdx < 0 || newIdx >= banners.length) {\r\n-        return;\r\n-      }\r\n-      \r\n-      setIsScrolling(true);\r\n-      setCurrentImage(newIdx);\r\n-\r\n-      const winH = window.innerHeight;\r\n-      const start = window.scrollY;\r\n-      const end = newIdx * winH;\r\n-      const startTime = performance.now();\r\n-\r\n-      function animateScroll(now: number) {\r\n-        const elapsed = now - startTime;\r\n-        const progress = Math.min(elapsed / SCROLL_ANIMATION_DURATION, 1);\r\n-        window.scrollTo(0, start + (end - start) * easeInOutCubic(progress));\r\n-        if (progress < 1) {\r\n-          requestAnimationFrame(animateScroll);\r\n-        } else {\r\n-          // A short delay to prevent immediate re-triggering\r\n-          setTimeout(() => setIsScrolling(false), 100); \r\n-        }\r\n-      }\r\n-      requestAnimationFrame(animateScroll);\r\n-    },\r\n-    [banners.length, currentImage, isScrolling]\r\n-  );\r\n-  \r\n-  // Attach scroll listener\r\n-  useEffect(() => {\r\n-    // Set scroll to top on mount\r\n-    window.scrollTo(0, 0);\r\n-\r\n-    const debouncedScroll = (e: WheelEvent) => {\r\n-        // Simple debounce, main logic is in handleScroll\r\n-        if (!isScrolling) {\r\n-            handleScroll(e);\r\n-        }\r\n-    };\r\n-\r\n-    window.addEventListener(\"wheel\", debouncedScroll as EventListener, { passive: false });\r\n-    return () => window.removeEventListener(\"wheel\", debouncedScroll as EventListener);\r\n-  }, [handleScroll, isScrolling]);\r\n-\r\n-\r\n-  // Memoize banner items to prevent unnecessary re-renders\r\n-  const bannerItems = useMemo(() => {\r\n-    return banners.map((banner, idx) => (\r\n-      <BannerItem\r\n-        key={banner._id || idx}\r\n-        banner={banner}\r\n-        idx={idx}\r\n-      />\r\n-    ));\r\n-  }, [banners]);\r\n-  \r\n-  if (!banners || banners.length === 0) {\r\n-    return (\r\n-       <div className=\"relative w-full h-screen flex items-center justify-center m-0 p-0 overflow-hidden bg-black\">\r\n-          <div className=\"text-white text-center\">\r\n-              <h2 className=\"text-2xl font-bold mb-4\">Welcome to AISH</h2>\r\n-              <p>No active banners at the moment. Please check back later.</p>\r\n-          </div>\r\n-       </div>\r\n-    );\r\n-  }\r\n-\r\n-  return (\r\n-    <div className=\"relative w-full bg-black overflow-hidden\">\r\n-        <div className=\"flex flex-col\" style={{ height: `${banners.length * 100}vh` }}>\r\n-            <div className=\"sticky top-0 h-screen\">\r\n-                 {bannerItems[currentImage]}\r\n-            </div>\r\n-        </div>\r\n-\r\n-      {/* SHOP NOW text */}\r\n-      <motion.div\r\n-        initial={{ opacity: 0, y: 20 }}\r\n-        animate={{ opacity: 1, y: 0 }}\r\n-        whileHover={{ scale: 1.05 }}\r\n-        className=\"fixed top-24 left-8 z-20\"\r\n-      >\r\n-        <button\r\n-          onClick={() => router.push(\"/products\")}\r\n-          className=\"bg-white text-black px-4 py-1.5 md:px-6 md:py-2 text-xs md:text-sm font-semibold hover:bg-black hover:text-white transition-all duration-300\"\r\n-        >\r\n-          SHOP NOW\r\n-        </button>\r\n-      </motion.div>\r\n-    </div>\r\n-  );\r\n-} \n\\ No newline at end of file\n+ \n\\ No newline at end of file\n"
                },
                {
                    "date": 1750478492130,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,1 +1,157 @@\n- \n\\ No newline at end of file\n+\"use client\";\r\n+import { useState, useEffect, useCallback, useMemo } from \"react\";\r\n+import { useRouter } from \"next/navigation\";\r\n+import { motion } from \"framer-motion\";\r\n+import Image from \"next/image\";\r\n+import React from \"react\";\r\n+\r\n+const DEFAULT_BANNER_IMAGE = \"/images/image1.jpg\";\r\n+const SCROLL_ANIMATION_DURATION = 700;\r\n+\r\n+// Type definitions\r\n+interface Banner {\r\n+  _id: string;\r\n+  imageUrl: string;\r\n+  title?: string;\r\n+  isMobile: boolean;\r\n+  blurDataURL?: string;\r\n+}\r\n+\r\n+interface BannerItemProps {\r\n+  banner: Banner;\r\n+  idx: number;\r\n+}\r\n+\r\n+interface BannerClientComponentProps {\r\n+  initialBanners: Banner[];\r\n+}\r\n+\r\n+function easeInOutCubic(t: number) {\r\n+  return t < 0.5\r\n+    ? 4 * t * t * t\r\n+    : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;\r\n+}\r\n+\r\n+const BannerItem = React.memo(({ banner, idx }: BannerItemProps) => (\r\n+  <div\r\n+    key={banner._id || idx}\r\n+    className=\"relative w-full h-screen flex items-center justify-center m-0 p-0 overflow-hidden\"\r\n+  >\r\n+    <div className=\"relative w-full h-full flex items-center justify-center bg-black m-0 p-0\">\r\n+      <Image\r\n+        src={banner.imageUrl}\r\n+        alt={banner.title || `Banner ${idx + 1}`}\r\n+        fill\r\n+        className=\"object-cover\"\r\n+        priority={idx === 0}\r\n+        loading={idx === 0 ? \"eager\" : \"lazy\"}\r\n+        sizes=\"100vw\"\r\n+        quality={90}\r\n+        placeholder=\"blur\"\r\n+        blurDataURL={banner.blurDataURL || \"data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7\"}\r\n+        style={{\r\n+          objectFit: 'cover',\r\n+          objectPosition: 'center',\r\n+          willChange: 'transform',\r\n+        }}\r\n+        onError={(e) => {\r\n+          e.currentTarget.src = DEFAULT_BANNER_IMAGE;\r\n+        }}\r\n+      />\r\n+    </div>\r\n+  </div>\r\n+));\r\n+BannerItem.displayName = 'BannerItem';\r\n+\r\n+\r\n+export default function BannerClientComponent({ initialBanners }: BannerClientComponentProps) {\r\n+  const [currentImage, setCurrentImage] = useState(0);\r\n+  const [banners] = useState(initialBanners);\r\n+  const [isScrolling, setIsScrolling] = useState(false);\r\n+  const router = useRouter();\r\n+\r\n+  const handleScroll = useCallback((e: WheelEvent) => {\r\n+      if (isScrolling || banners.length < 2) return;\r\n+      \r\n+      e.preventDefault();\r\n+      \r\n+      const delta = Math.sign(e.deltaY);\r\n+      const newIdx = currentImage + delta;\r\n+\r\n+      if (newIdx < 0 || newIdx >= banners.length) {\r\n+        return;\r\n+      }\r\n+      \r\n+      setIsScrolling(true);\r\n+      \r\n+      const targetElement = document.getElementById(`banner-section-${newIdx}`);\r\n+      if (targetElement) {\r\n+          targetElement.scrollIntoView({ behavior: 'smooth' });\r\n+      }\r\n+\r\n+      // We need a way to know when scrolling is finished to set isScrolling to false.\r\n+      // A timeout is a simple way, but IntersectionObserver would be more robust.\r\n+      setTimeout(() => {\r\n+          setCurrentImage(newIdx);\r\n+          setIsScrolling(false)\r\n+      }, SCROLL_ANIMATION_DURATION + 100); // Allow some buffer\r\n+      \r\n+    }, [banners.length, currentImage, isScrolling]);\r\n+  \r\n+  useEffect(() => {\r\n+    const handleWheel = (e: WheelEvent) => {\r\n+        if(!isScrolling) {\r\n+            handleScroll(e);\r\n+        } else {\r\n+            e.preventDefault();\r\n+        }\r\n+    }\r\n+    window.addEventListener(\"wheel\", handleWheel, { passive: false });\r\n+    return () => window.removeEventListener(\"wheel\", handleWheel);\r\n+  }, [handleScroll, isScrolling]);\r\n+\r\n+  const bannerItems = useMemo(() => {\r\n+    return banners.map((banner, idx) => (\r\n+        <section\r\n+            id={`banner-section-${idx}`}\r\n+            key={banner._id || idx}\r\n+            className=\"h-screen w-full snap-start\"\r\n+        >\r\n+            <BannerItem\r\n+                banner={banner}\r\n+                idx={idx}\r\n+            />\r\n+        </section>\r\n+    ));\r\n+  }, [banners]);\r\n+  \r\n+  if (!banners || banners.length === 0) {\r\n+    return (\r\n+       <div className=\"relative w-full h-screen flex items-center justify-center m-0 p-0 overflow-hidden bg-black\">\r\n+          <div className=\"text-white text-center\">\r\n+              <h2 className=\"text-2xl font-bold mb-4\">Welcome to AISH</h2>\r\n+              <p>No active banners at the moment. Please check back later.</p>\r\n+          </div>\r\n+       </div>\r\n+    );\r\n+  }\r\n+\r\n+  return (\r\n+    <div className=\"relative w-full bg-black overflow-hidden snap-y snap-mandatory h-screen\">\r\n+      {bannerItems}\r\n+      <motion.div\r\n+        initial={{ opacity: 0, y: 20 }}\r\n+        animate={{ opacity: 1, y: 0 }}\r\n+        whileHover={{ scale: 1.05 }}\r\n+        className=\"fixed top-24 left-8 z-20\"\r\n+      >\r\n+        <button\r\n+          onClick={() => router.push(\"/products\")}\r\n+          className=\"bg-white text-black px-4 py-1.5 md:px-6 md:py-2 text-xs md:text-sm font-semibold hover:bg-black hover:text-white transition-all duration-300\"\r\n+        >\r\n+          SHOP NOW\r\n+        </button>\r\n+      </motion.div>\r\n+    </div>\r\n+  );\r\n+} \n\\ No newline at end of file\n"
                },
                {
                    "date": 1750478812330,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,157 +1,1 @@\n-\"use client\";\r\n-import { useState, useEffect, useCallback, useMemo } from \"react\";\r\n-import { useRouter } from \"next/navigation\";\r\n-import { motion } from \"framer-motion\";\r\n-import Image from \"next/image\";\r\n-import React from \"react\";\r\n-\r\n-const DEFAULT_BANNER_IMAGE = \"/images/image1.jpg\";\r\n-const SCROLL_ANIMATION_DURATION = 700;\r\n-\r\n-// Type definitions\r\n-interface Banner {\r\n-  _id: string;\r\n-  imageUrl: string;\r\n-  title?: string;\r\n-  isMobile: boolean;\r\n-  blurDataURL?: string;\r\n-}\r\n-\r\n-interface BannerItemProps {\r\n-  banner: Banner;\r\n-  idx: number;\r\n-}\r\n-\r\n-interface BannerClientComponentProps {\r\n-  initialBanners: Banner[];\r\n-}\r\n-\r\n-function easeInOutCubic(t: number) {\r\n-  return t < 0.5\r\n-    ? 4 * t * t * t\r\n-    : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;\r\n-}\r\n-\r\n-const BannerItem = React.memo(({ banner, idx }: BannerItemProps) => (\r\n-  <div\r\n-    key={banner._id || idx}\r\n-    className=\"relative w-full h-screen flex items-center justify-center m-0 p-0 overflow-hidden\"\r\n-  >\r\n-    <div className=\"relative w-full h-full flex items-center justify-center bg-black m-0 p-0\">\r\n-      <Image\r\n-        src={banner.imageUrl}\r\n-        alt={banner.title || `Banner ${idx + 1}`}\r\n-        fill\r\n-        className=\"object-cover\"\r\n-        priority={idx === 0}\r\n-        loading={idx === 0 ? \"eager\" : \"lazy\"}\r\n-        sizes=\"100vw\"\r\n-        quality={90}\r\n-        placeholder=\"blur\"\r\n-        blurDataURL={banner.blurDataURL || \"data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7\"}\r\n-        style={{\r\n-          objectFit: 'cover',\r\n-          objectPosition: 'center',\r\n-          willChange: 'transform',\r\n-        }}\r\n-        onError={(e) => {\r\n-          e.currentTarget.src = DEFAULT_BANNER_IMAGE;\r\n-        }}\r\n-      />\r\n-    </div>\r\n-  </div>\r\n-));\r\n-BannerItem.displayName = 'BannerItem';\r\n-\r\n-\r\n-export default function BannerClientComponent({ initialBanners }: BannerClientComponentProps) {\r\n-  const [currentImage, setCurrentImage] = useState(0);\r\n-  const [banners] = useState(initialBanners);\r\n-  const [isScrolling, setIsScrolling] = useState(false);\r\n-  const router = useRouter();\r\n-\r\n-  const handleScroll = useCallback((e: WheelEvent) => {\r\n-      if (isScrolling || banners.length < 2) return;\r\n-      \r\n-      e.preventDefault();\r\n-      \r\n-      const delta = Math.sign(e.deltaY);\r\n-      const newIdx = currentImage + delta;\r\n-\r\n-      if (newIdx < 0 || newIdx >= banners.length) {\r\n-        return;\r\n-      }\r\n-      \r\n-      setIsScrolling(true);\r\n-      \r\n-      const targetElement = document.getElementById(`banner-section-${newIdx}`);\r\n-      if (targetElement) {\r\n-          targetElement.scrollIntoView({ behavior: 'smooth' });\r\n-      }\r\n-\r\n-      // We need a way to know when scrolling is finished to set isScrolling to false.\r\n-      // A timeout is a simple way, but IntersectionObserver would be more robust.\r\n-      setTimeout(() => {\r\n-          setCurrentImage(newIdx);\r\n-          setIsScrolling(false)\r\n-      }, SCROLL_ANIMATION_DURATION + 100); // Allow some buffer\r\n-      \r\n-    }, [banners.length, currentImage, isScrolling]);\r\n-  \r\n-  useEffect(() => {\r\n-    const handleWheel = (e: WheelEvent) => {\r\n-        if(!isScrolling) {\r\n-            handleScroll(e);\r\n-        } else {\r\n-            e.preventDefault();\r\n-        }\r\n-    }\r\n-    window.addEventListener(\"wheel\", handleWheel, { passive: false });\r\n-    return () => window.removeEventListener(\"wheel\", handleWheel);\r\n-  }, [handleScroll, isScrolling]);\r\n-\r\n-  const bannerItems = useMemo(() => {\r\n-    return banners.map((banner, idx) => (\r\n-        <section\r\n-            id={`banner-section-${idx}`}\r\n-            key={banner._id || idx}\r\n-            className=\"h-screen w-full snap-start\"\r\n-        >\r\n-            <BannerItem\r\n-                banner={banner}\r\n-                idx={idx}\r\n-            />\r\n-        </section>\r\n-    ));\r\n-  }, [banners]);\r\n-  \r\n-  if (!banners || banners.length === 0) {\r\n-    return (\r\n-       <div className=\"relative w-full h-screen flex items-center justify-center m-0 p-0 overflow-hidden bg-black\">\r\n-          <div className=\"text-white text-center\">\r\n-              <h2 className=\"text-2xl font-bold mb-4\">Welcome to AISH</h2>\r\n-              <p>No active banners at the moment. Please check back later.</p>\r\n-          </div>\r\n-       </div>\r\n-    );\r\n-  }\r\n-\r\n-  return (\r\n-    <div className=\"relative w-full bg-black overflow-hidden snap-y snap-mandatory h-screen\">\r\n-      {bannerItems}\r\n-      <motion.div\r\n-        initial={{ opacity: 0, y: 20 }}\r\n-        animate={{ opacity: 1, y: 0 }}\r\n-        whileHover={{ scale: 1.05 }}\r\n-        className=\"fixed top-24 left-8 z-20\"\r\n-      >\r\n-        <button\r\n-          onClick={() => router.push(\"/products\")}\r\n-          className=\"bg-white text-black px-4 py-1.5 md:px-6 md:py-2 text-xs md:text-sm font-semibold hover:bg-black hover:text-white transition-all duration-300\"\r\n-        >\r\n-          SHOP NOW\r\n-        </button>\r\n-      </motion.div>\r\n-    </div>\r\n-  );\r\n-} \n\\ No newline at end of file\n+ \n\\ No newline at end of file\n"
                },
                {
                    "date": 1750479065561,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,1 +1,183 @@\n- \n\\ No newline at end of file\n+\"use client\";\r\n+import { useState, useEffect, useCallback, useMemo } from \"react\";\r\n+import { useRouter } from \"next/navigation\";\r\n+import { motion } from \"framer-motion\";\r\n+import Image from \"next/image\";\r\n+import React from \"react\";\r\n+import Head from 'next/head';\r\n+\r\n+// Type definitions\r\n+interface Banner {\r\n+  _id: string;\r\n+  imageUrl: string;\r\n+  title?: string;\r\n+  isMobile: boolean;\r\n+  blurDataURL?: string;\r\n+}\r\n+\r\n+interface BannerItemProps {\r\n+  banner: Banner;\r\n+  idx: number;\r\n+}\r\n+\r\n+interface BannerClientComponentProps {\r\n+  initialBanners: Banner[];\r\n+}\r\n+\r\n+\r\n+const DEFAULT_BANNER_IMAGE = \"/images/image1.jpg\";\r\n+const SCROLL_ANIMATION_DURATION = 700;\r\n+\r\n+function easeInOutCubic(t: number) {\r\n+  return t < 0.5\r\n+    ? 4 * t * t * t\r\n+    : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;\r\n+}\r\n+\r\n+const BannerItem = React.memo(({ banner, idx }: BannerItemProps) => (\r\n+  <div\r\n+    key={banner._id || idx}\r\n+    className=\"relative w-full h-screen flex items-center justify-center m-0 p-0 overflow-hidden\"\r\n+  >\r\n+    <div className=\"relative w-full h-full flex items-center justify-center bg-black m-0 p-0\">\r\n+      <Image\r\n+        src={banner.imageUrl}\r\n+        alt={banner.title || `Banner ${idx + 1}`}\r\n+        fill\r\n+        className=\"object-cover\"\r\n+        priority={idx === 0} // Prioritize first image\r\n+        loading={idx === 0 ? \"eager\" : \"lazy\"} // Eager load first, lazy the rest\r\n+        sizes=\"100vw\"\r\n+        quality={90}\r\n+        placeholder=\"blur\"\r\n+        blurDataURL={banner.blurDataURL || \"data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7\"}\r\n+        style={{\r\n+          objectFit: 'cover',\r\n+          objectPosition: 'center',\r\n+          willChange: 'transform',\r\n+        }}\r\n+        onError={(e) => {\r\n+          (e.target as HTMLImageElement).src = DEFAULT_BANNER_IMAGE;\r\n+        }}\r\n+      />\r\n+    </div>\r\n+  </div>\r\n+));\r\n+BannerItem.displayName = 'BannerItem';\r\n+\r\n+\r\n+export default function BannerClientComponent({ initialBanners }: BannerClientComponentProps) {\r\n+  const [currentImage, setCurrentImage] = useState(0);\r\n+  const [banners] = useState(initialBanners); // Receive banners as prop\r\n+  const [isScrolling, setIsScrolling] = useState(false);\r\n+  const router = useRouter();\r\n+\r\n+  // Preload images - This logic is preserved\r\n+  useEffect(() => {\r\n+    const preloadImages = (urls: string[]) => {\r\n+      urls.forEach(url => {\r\n+        const img = new (window as any).Image();\r\n+        img.src = url;\r\n+      });\r\n+    };\r\n+\r\n+    if (banners.length > 0) {\r\n+      preloadImages(banners.map(b => b.imageUrl));\r\n+    }\r\n+  }, [banners]);\r\n+\r\n+  // Scroll handler - This logic is IDENTICAL to the original page.js\r\n+  const handleScroll = useCallback(\r\n+    (e: WheelEvent) => {\r\n+      if (banners.length < 2) return;\r\n+      const scrollY = window.scrollY;\r\n+      const winH = window.innerHeight;\r\n+      const imageIdx = Math.floor(scrollY / winH);\r\n+      if (imageIdx === banners.length - 1 && e.deltaY > 0) return;\r\n+      e.preventDefault();\r\n+      if (isScrolling) return;\r\n+      const delta = Math.sign(e.deltaY);\r\n+      const newIdx = Math.max(0, Math.min(banners.length - 1, imageIdx + delta));\r\n+      if (newIdx === currentImage) return;\r\n+      setIsScrolling(true);\r\n+      setCurrentImage(newIdx);\r\n+      const start = scrollY;\r\n+      const end = newIdx * winH;\r\n+      const startTime = performance.now();\r\n+      function animateScroll(now: number) {\r\n+        const elapsed = now - startTime;\r\n+        const progress = Math.min(elapsed / SCROLL_ANIMATION_DURATION, 1);\r\n+        window.scrollTo(0, start + (end - start) * easeInOutCubic(progress));\r\n+        if (progress < 1) {\r\n+          requestAnimationFrame(animateScroll);\r\n+        } else {\r\n+          setIsScrolling(false);\r\n+        }\r\n+      }\r\n+      requestAnimationFrame(animateScroll);\r\n+    },\r\n+    [banners.length, currentImage, isScrolling]\r\n+  );\r\n+\r\n+  useEffect(() => {\r\n+    window.addEventListener(\"wheel\", handleScroll as EventListener, { passive: false });\r\n+    return () => window.removeEventListener(\"wheel\", handleScroll as EventListener);\r\n+  }, [handleScroll]);\r\n+\r\n+  // Memoize banner items to prevent unnecessary re-renders\r\n+  const bannerItems = useMemo(() => {\r\n+    return banners.map((banner, idx) => (\r\n+      <BannerItem\r\n+        key={banner._id || idx}\r\n+        banner={banner}\r\n+        idx={idx}\r\n+      />\r\n+    ));\r\n+  }, [banners]);\r\n+\r\n+  if (!banners || banners.length === 0) {\r\n+    return (\r\n+       <div className=\"relative w-full h-screen flex items-center justify-center m-0 p-0 overflow-hidden bg-black\">\r\n+          <div className=\"text-white text-center\">\r\n+              <h2 className=\"text-2xl font-bold mb-4\">Welcome to AISH</h2>\r\n+              <p>No active banners at the moment. Please check back later.</p>\r\n+          </div>\r\n+       </div>\r\n+    );\r\n+  }\r\n+\r\n+  return (\r\n+    <>\r\n+      <Head>\r\n+        {banners.map((banner, idx) => (\r\n+          <link\r\n+            key={banner._id || idx}\r\n+            rel=\"preload\"\r\n+            href={banner.imageUrl}\r\n+            as=\"image\"\r\n+          />\r\n+        ))}\r\n+      </Head>\r\n+      <div className=\"relative w-full bg-black overflow-hidden\">\r\n+        <div className=\"flex flex-col\">\r\n+          {bannerItems}\r\n+        </div>\r\n+\r\n+        {/* SHOP NOW text */}\r\n+        <motion.div\r\n+          initial={{ opacity: 0, y: 20 }}\r\n+          animate={{ opacity: 1, y: 0 }}\r\n+          whileHover={{ scale: 1.05 }}\r\n+          className=\"fixed top-24 left-8 z-20\"\r\n+        >\r\n+          <button\r\n+            onClick={() => router.push(\"/products\")}\r\n+            className=\"bg-white text-black px-4 py-1.5 md:px-6 md:py-2 text-xs md:text-sm font-semibold hover:bg-black hover:text-white transition-all duration-300\"\r\n+          >\r\n+            SHOP NOW\r\n+          </button>\r\n+        </motion.div>\r\n+      </div>\r\n+    </>\r\n+  );\r\n+} \n\\ No newline at end of file\n"
                },
                {
                    "date": 1750479559853,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -10,9 +10,9 @@\n interface Banner {\r\n   _id: string;\r\n   imageUrl: string;\r\n   title?: string;\r\n-  isMobile: boolean;\r\n+  isMobile?: boolean; // isMobile is now optional as it's determined on the client\r\n   blurDataURL?: string;\r\n }\r\n \r\n interface BannerItemProps {\r\n@@ -23,9 +23,8 @@\n interface BannerClientComponentProps {\r\n   initialBanners: Banner[];\r\n }\r\n \r\n-\r\n const DEFAULT_BANNER_IMAGE = \"/images/image1.jpg\";\r\n const SCROLL_ANIMATION_DURATION = 700;\r\n \r\n function easeInOutCubic(t: number) {\r\n@@ -44,14 +43,12 @@\n         src={banner.imageUrl}\r\n         alt={banner.title || `Banner ${idx + 1}`}\r\n         fill\r\n         className=\"object-cover\"\r\n-        priority={idx === 0} // Prioritize first image\r\n-        loading={idx === 0 ? \"eager\" : \"lazy\"} // Eager load first, lazy the rest\r\n+        priority={idx === 0}\r\n+        loading={idx === 0 ? \"eager\" : \"lazy\"}\r\n         sizes=\"100vw\"\r\n         quality={90}\r\n-        placeholder=\"blur\"\r\n-        blurDataURL={banner.blurDataURL || \"data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7\"}\r\n         style={{\r\n           objectFit: 'cover',\r\n           objectPosition: 'center',\r\n           willChange: 'transform',\r\n@@ -64,41 +61,68 @@\n   </div>\r\n ));\r\n BannerItem.displayName = 'BannerItem';\r\n \r\n-\r\n export default function BannerClientComponent({ initialBanners }: BannerClientComponentProps) {\r\n   const [currentImage, setCurrentImage] = useState(0);\r\n-  const [banners] = useState(initialBanners); // Receive banners as prop\r\n+  const [banners, setBanners] = useState<Banner[]>([]); // This will hold the processed banners\r\n   const [isScrolling, setIsScrolling] = useState(false);\r\n+  const [isMobileDevice, setIsMobileDevice] = useState(false);\r\n   const router = useRouter();\r\n \r\n-  // Preload images - This logic is preserved\r\n+  // Re-implement the original logic to determine if a banner is for mobile\r\n   useEffect(() => {\r\n-    const preloadImages = (urls: string[]) => {\r\n-      urls.forEach(url => {\r\n-        const img = new (window as any).Image();\r\n-        img.src = url;\r\n-      });\r\n-    };\r\n+    let ignore = false;\r\n+    const processBanners = async () => {\r\n+        const processed = await Promise.all(initialBanners.map(async (banner) => {\r\n+            const isMobile = await new Promise<boolean>((resolve) => {\r\n+              const img = new (window as any).Image();\r\n+              img.onload = () => resolve(img.height > img.width);\r\n+              img.onerror = () => resolve(false); // Default to not mobile on error\r\n+              img.src = banner.imageUrl;\r\n+            });\r\n+            return { ...banner, isMobile };\r\n+        }));\r\n \r\n-    if (banners.length > 0) {\r\n-      preloadImages(banners.map(b => b.imageUrl));\r\n+        if (!ignore) {\r\n+            setBanners(processed);\r\n+        }\r\n     }\r\n-  }, [banners]);\r\n+    \r\n+    if (initialBanners.length > 0) {\r\n+        processBanners();\r\n+    }\r\n \r\n+    return () => { ignore = true; };\r\n+  }, [initialBanners]);\r\n+\r\n+  // Re-implement the original logic to check device type\r\n+  useEffect(() => {\r\n+    const checkMobile = () => {\r\n+      setIsMobileDevice(window.innerWidth < 768);\r\n+    };\r\n+    checkMobile();\r\n+    window.addEventListener('resize', checkMobile);\r\n+    return () => window.removeEventListener('resize', checkMobile);\r\n+  }, []);\r\n+\r\n+  // Re-implement the original logic to filter banners\r\n+  const filteredBanners = useMemo(() => {\r\n+    return banners.filter(banner => banner.isMobile === isMobileDevice);\r\n+  }, [banners, isMobileDevice]);\r\n+\r\n   // Scroll handler - This logic is IDENTICAL to the original page.js\r\n   const handleScroll = useCallback(\r\n     (e: WheelEvent) => {\r\n-      if (banners.length < 2) return;\r\n+      if (filteredBanners.length < 2) return;\r\n       const scrollY = window.scrollY;\r\n       const winH = window.innerHeight;\r\n       const imageIdx = Math.floor(scrollY / winH);\r\n-      if (imageIdx === banners.length - 1 && e.deltaY > 0) return;\r\n+      if (imageIdx === filteredBanners.length - 1 && e.deltaY > 0) return;\r\n       e.preventDefault();\r\n       if (isScrolling) return;\r\n       const delta = Math.sign(e.deltaY);\r\n-      const newIdx = Math.max(0, Math.min(banners.length - 1, imageIdx + delta));\r\n+      const newIdx = Math.max(0, Math.min(filteredBanners.length - 1, imageIdx + delta));\r\n       if (newIdx === currentImage) return;\r\n       setIsScrolling(true);\r\n       setCurrentImage(newIdx);\r\n       const start = scrollY;\r\n@@ -115,9 +139,9 @@\n         }\r\n       }\r\n       requestAnimationFrame(animateScroll);\r\n     },\r\n-    [banners.length, currentImage, isScrolling]\r\n+    [filteredBanners.length, currentImage, isScrolling]\r\n   );\r\n \r\n   useEffect(() => {\r\n     window.addEventListener(\"wheel\", handleScroll as EventListener, { passive: false });\r\n@@ -125,32 +149,41 @@\n   }, [handleScroll]);\r\n \r\n   // Memoize banner items to prevent unnecessary re-renders\r\n   const bannerItems = useMemo(() => {\r\n-    return banners.map((banner, idx) => (\r\n+    return filteredBanners.map((banner, idx) => (\r\n       <BannerItem\r\n         key={banner._id || idx}\r\n         banner={banner}\r\n         idx={idx}\r\n       />\r\n     ));\r\n-  }, [banners]);\r\n+  }, [filteredBanners]);\r\n \r\n-  if (!banners || banners.length === 0) {\r\n+  // Show a loading state while banners are being processed client-side\r\n+  if (banners.length === 0 && initialBanners.length > 0) {\r\n     return (\r\n+        <div className=\"w-full h-screen bg-gradient-to-b from-gray-900 to-black flex items-center justify-center\">\r\n+            <div className=\"w-16 h-16 border-4 border-white border-t-transparent rounded-full animate-spin\"></div>\r\n+        </div>\r\n+    );\r\n+  }\r\n+  \r\n+  if (bannerItems.length === 0) {\r\n+    return (\r\n        <div className=\"relative w-full h-screen flex items-center justify-center m-0 p-0 overflow-hidden bg-black\">\r\n           <div className=\"text-white text-center\">\r\n               <h2 className=\"text-2xl font-bold mb-4\">Welcome to AISH</h2>\r\n-              <p>No active banners at the moment. Please check back later.</p>\r\n+              <p>No active banners for your device at the moment.</p>\r\n           </div>\r\n        </div>\r\n     );\r\n   }\r\n \r\n   return (\r\n     <>\r\n       <Head>\r\n-        {banners.map((banner, idx) => (\r\n+        {filteredBanners.map((banner, idx) => (\r\n           <link\r\n             key={banner._id || idx}\r\n             rel=\"preload\"\r\n             href={banner.imageUrl}\r\n"
                },
                {
                    "date": 1750480874848,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -10,9 +10,9 @@\n interface Banner {\r\n   _id: string;\r\n   imageUrl: string;\r\n   title?: string;\r\n-  isMobile?: boolean; // isMobile is now optional as it's determined on the client\r\n+  isMobile?: boolean;\r\n   blurDataURL?: string;\r\n }\r\n \r\n interface BannerItemProps {\r\n@@ -63,22 +63,22 @@\n BannerItem.displayName = 'BannerItem';\r\n \r\n export default function BannerClientComponent({ initialBanners }: BannerClientComponentProps) {\r\n   const [currentImage, setCurrentImage] = useState(0);\r\n-  const [banners, setBanners] = useState<Banner[]>([]); // This will hold the processed banners\r\n+  const [banners, setBanners] = useState<Banner[]>([]);\r\n   const [isScrolling, setIsScrolling] = useState(false);\r\n   const [isMobileDevice, setIsMobileDevice] = useState(false);\r\n   const router = useRouter();\r\n \r\n-  // Re-implement the original logic to determine if a banner is for mobile\r\n+  // Process banners to determine mobile/desktop\r\n   useEffect(() => {\r\n     let ignore = false;\r\n     const processBanners = async () => {\r\n         const processed = await Promise.all(initialBanners.map(async (banner) => {\r\n             const isMobile = await new Promise<boolean>((resolve) => {\r\n               const img = new (window as any).Image();\r\n               img.onload = () => resolve(img.height > img.width);\r\n-              img.onerror = () => resolve(false); // Default to not mobile on error\r\n+              img.onerror = () => resolve(false);\r\n               img.src = banner.imageUrl;\r\n             });\r\n             return { ...banner, isMobile };\r\n         }));\r\n@@ -94,9 +94,9 @@\n \r\n     return () => { ignore = true; };\r\n   }, [initialBanners]);\r\n \r\n-  // Re-implement the original logic to check device type\r\n+  // Check device type\r\n   useEffect(() => {\r\n     const checkMobile = () => {\r\n       setIsMobileDevice(window.innerWidth < 768);\r\n     };\r\n@@ -104,52 +104,68 @@\n     window.addEventListener('resize', checkMobile);\r\n     return () => window.removeEventListener('resize', checkMobile);\r\n   }, []);\r\n \r\n-  // Re-implement the original logic to filter banners\r\n+  // Filter banners by device type\r\n   const filteredBanners = useMemo(() => {\r\n     return banners.filter(banner => banner.isMobile === isMobileDevice);\r\n   }, [banners, isMobileDevice]);\r\n \r\n-  // Scroll handler - This logic is IDENTICAL to the original page.js\r\n+  // Simplified scroll handler\r\n   const handleScroll = useCallback(\r\n     (e: WheelEvent) => {\r\n       if (filteredBanners.length < 2) return;\r\n-      const scrollY = window.scrollY;\r\n-      const winH = window.innerHeight;\r\n-      const imageIdx = Math.floor(scrollY / winH);\r\n-      if (imageIdx === filteredBanners.length - 1 && e.deltaY > 0) return;\r\n+      \r\n       e.preventDefault();\r\n+      \r\n       if (isScrolling) return;\r\n+      \r\n       const delta = Math.sign(e.deltaY);\r\n-      const newIdx = Math.max(0, Math.min(filteredBanners.length - 1, imageIdx + delta));\r\n-      if (newIdx === currentImage) return;\r\n+      const currentScrollY = window.scrollY;\r\n+      const windowHeight = window.innerHeight;\r\n+      const currentIndex = Math.round(currentScrollY / windowHeight);\r\n+      \r\n+      let newIndex = currentIndex + delta;\r\n+      \r\n+      // Ensure newIndex is within bounds\r\n+      if (newIndex < 0) newIndex = 0;\r\n+      if (newIndex >= filteredBanners.length) newIndex = filteredBanners.length - 1;\r\n+      \r\n+      // Don't scroll if we're already at the target position\r\n+      if (newIndex === currentIndex) return;\r\n+      \r\n       setIsScrolling(true);\r\n-      setCurrentImage(newIdx);\r\n-      const start = scrollY;\r\n-      const end = newIdx * winH;\r\n+      setCurrentImage(newIndex);\r\n+      \r\n+      const targetScrollY = newIndex * windowHeight;\r\n       const startTime = performance.now();\r\n+      \r\n       function animateScroll(now: number) {\r\n         const elapsed = now - startTime;\r\n         const progress = Math.min(elapsed / SCROLL_ANIMATION_DURATION, 1);\r\n-        window.scrollTo(0, start + (end - start) * easeInOutCubic(progress));\r\n+        \r\n+        const newScrollY = currentScrollY + (targetScrollY - currentScrollY) * easeInOutCubic(progress);\r\n+        window.scrollTo(0, newScrollY);\r\n+        \r\n         if (progress < 1) {\r\n           requestAnimationFrame(animateScroll);\r\n         } else {\r\n           setIsScrolling(false);\r\n         }\r\n       }\r\n+      \r\n       requestAnimationFrame(animateScroll);\r\n     },\r\n-    [filteredBanners.length, currentImage, isScrolling]\r\n+    [filteredBanners.length, isScrolling]\r\n   );\r\n \r\n+  // Add scroll listener\r\n   useEffect(() => {\r\n     window.addEventListener(\"wheel\", handleScroll as EventListener, { passive: false });\r\n     return () => window.removeEventListener(\"wheel\", handleScroll as EventListener);\r\n   }, [handleScroll]);\r\n \r\n-  // Memoize banner items to prevent unnecessary re-renders\r\n+  // Memoize banner items\r\n   const bannerItems = useMemo(() => {\r\n     return filteredBanners.map((banner, idx) => (\r\n       <BannerItem\r\n         key={banner._id || idx}\r\n@@ -158,17 +174,18 @@\n       />\r\n     ));\r\n   }, [filteredBanners]);\r\n \r\n-  // Show a loading state while banners are being processed client-side\r\n+  // Loading state\r\n   if (banners.length === 0 && initialBanners.length > 0) {\r\n     return (\r\n         <div className=\"w-full h-screen bg-gradient-to-b from-gray-900 to-black flex items-center justify-center\">\r\n             <div className=\"w-16 h-16 border-4 border-white border-t-transparent rounded-full animate-spin\"></div>\r\n         </div>\r\n     );\r\n   }\r\n   \r\n+  // No banners state\r\n   if (bannerItems.length === 0) {\r\n     return (\r\n        <div className=\"relative w-full h-screen flex items-center justify-center m-0 p-0 overflow-hidden bg-black\">\r\n           <div className=\"text-white text-center\">\r\n"
                },
                {
                    "date": 1750481492753,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -114,17 +114,27 @@\n   const handleScroll = useCallback(\r\n     (e: WheelEvent) => {\r\n       if (filteredBanners.length < 2) return;\r\n       \r\n-      e.preventDefault();\r\n-      \r\n-      if (isScrolling) return;\r\n-      \r\n       const delta = Math.sign(e.deltaY);\r\n       const currentScrollY = window.scrollY;\r\n       const windowHeight = window.innerHeight;\r\n       const currentIndex = Math.round(currentScrollY / windowHeight);\r\n       \r\n+      // If scrolling down and we're at the last banner, allow normal scroll to footer\r\n+      if (delta > 0 && currentIndex >= filteredBanners.length - 1) {\r\n+        return; // Allow normal scroll behavior\r\n+      }\r\n+      \r\n+      // If scrolling up and we're at the top, allow normal scroll\r\n+      if (delta < 0 && currentIndex <= 0) {\r\n+        return; // Allow normal scroll behavior\r\n+      }\r\n+      \r\n+      e.preventDefault();\r\n+      \r\n+      if (isScrolling) return;\r\n+      \r\n       let newIndex = currentIndex + delta;\r\n       \r\n       // Ensure newIndex is within bounds\r\n       if (newIndex < 0) newIndex = 0;\r\n"
                },
                {
                    "date": 1750482172495,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,6 +1,6 @@\n \"use client\";\r\n-import { useState, useEffect, useCallback, useMemo } from \"react\";\r\n+import { useState, useEffect, useCallback, useMemo, useRef } from \"react\";\r\n import { useRouter } from \"next/navigation\";\r\n import { motion } from \"framer-motion\";\r\n import Image from \"next/image\";\r\n import React from \"react\";\r\n@@ -24,16 +24,29 @@\n   initialBanners: Banner[];\r\n }\r\n \r\n const DEFAULT_BANNER_IMAGE = \"/images/image1.jpg\";\r\n-const SCROLL_ANIMATION_DURATION = 700;\r\n+const SCROLL_ANIMATION_DURATION = 800;\r\n+const SCROLL_THRESHOLD = 50;\r\n \r\n function easeInOutCubic(t: number) {\r\n   return t < 0.5\r\n     ? 4 * t * t * t\r\n     : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;\r\n }\r\n \r\n+// Debounce function\r\n+function debounce<T extends (...args: any[]) => any>(\r\n+  func: T,\r\n+  wait: number\r\n+): (...args: Parameters<T>) => void {\r\n+  let timeout: NodeJS.Timeout;\r\n+  return (...args: Parameters<T>) => {\r\n+    clearTimeout(timeout);\r\n+    timeout = setTimeout(() => func(...args), wait);\r\n+  };\r\n+}\r\n+\r\n const BannerItem = React.memo(({ banner, idx }: BannerItemProps) => (\r\n   <div\r\n     key={banner._id || idx}\r\n     className=\"relative w-full h-screen flex items-center justify-center m-0 p-0 overflow-hidden\"\r\n@@ -67,8 +80,10 @@\n   const [banners, setBanners] = useState<Banner[]>([]);\r\n   const [isScrolling, setIsScrolling] = useState(false);\r\n   const [isMobileDevice, setIsMobileDevice] = useState(false);\r\n   const router = useRouter();\r\n+  const scrollTimeoutRef = useRef<NodeJS.Timeout>();\r\n+  const lastScrollTimeRef = useRef(0);\r\n \r\n   // Process banners to determine mobile/desktop\r\n   useEffect(() => {\r\n     let ignore = false;\r\n@@ -109,13 +124,17 @@\n   const filteredBanners = useMemo(() => {\r\n     return banners.filter(banner => banner.isMobile === isMobileDevice);\r\n   }, [banners, isMobileDevice]);\r\n \r\n-  // Simplified scroll handler\r\n+  // Improved scroll handler with better smoothness\r\n   const handleScroll = useCallback(\r\n     (e: WheelEvent) => {\r\n       if (filteredBanners.length < 2) return;\r\n       \r\n+      const now = Date.now();\r\n+      if (now - lastScrollTimeRef.current < 100) return; // Prevent rapid scrolling\r\n+      lastScrollTimeRef.current = now;\r\n+      \r\n       const delta = Math.sign(e.deltaY);\r\n       const currentScrollY = window.scrollY;\r\n       const windowHeight = window.innerHeight;\r\n       const currentIndex = Math.round(currentScrollY / windowHeight);\r\n@@ -158,22 +177,35 @@\n         \r\n         if (progress < 1) {\r\n           requestAnimationFrame(animateScroll);\r\n         } else {\r\n-          setIsScrolling(false);\r\n+          // Add a small delay before allowing next scroll\r\n+          setTimeout(() => {\r\n+            setIsScrolling(false);\r\n+          }, 150);\r\n         }\r\n       }\r\n       \r\n       requestAnimationFrame(animateScroll);\r\n     },\r\n     [filteredBanners.length, isScrolling]\r\n   );\r\n \r\n-  // Add scroll listener\r\n+  // Debounced scroll handler\r\n+  const debouncedScrollHandler = useMemo(\r\n+    () => debounce(handleScroll, 50),\r\n+    [handleScroll]\r\n+  );\r\n+\r\n+  // Add scroll listener with passive option for better performance\r\n   useEffect(() => {\r\n-    window.addEventListener(\"wheel\", handleScroll as EventListener, { passive: false });\r\n-    return () => window.removeEventListener(\"wheel\", handleScroll as EventListener);\r\n-  }, [handleScroll]);\r\n+    const handleWheel = (e: WheelEvent) => {\r\n+      debouncedScrollHandler(e);\r\n+    };\r\n+    \r\n+    window.addEventListener(\"wheel\", handleWheel, { passive: false });\r\n+    return () => window.removeEventListener(\"wheel\", handleWheel);\r\n+  }, [debouncedScrollHandler]);\r\n \r\n   // Memoize banner items\r\n   const bannerItems = useMemo(() => {\r\n     return filteredBanners.map((banner, idx) => (\r\n"
                },
                {
                    "date": 1750482181340,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -38,11 +38,11 @@\n function debounce<T extends (...args: any[]) => any>(\r\n   func: T,\r\n   wait: number\r\n ): (...args: Parameters<T>) => void {\r\n-  let timeout: NodeJS.Timeout;\r\n+  let timeout: NodeJS.Timeout | undefined;\r\n   return (...args: Parameters<T>) => {\r\n-    clearTimeout(timeout);\r\n+    if (timeout) clearTimeout(timeout);\r\n     timeout = setTimeout(() => func(...args), wait);\r\n   };\r\n }\r\n \r\n"
                },
                {
                    "date": 1750482198688,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -80,9 +80,8 @@\n   const [banners, setBanners] = useState<Banner[]>([]);\r\n   const [isScrolling, setIsScrolling] = useState(false);\r\n   const [isMobileDevice, setIsMobileDevice] = useState(false);\r\n   const router = useRouter();\r\n-  const scrollTimeoutRef = useRef<NodeJS.Timeout>();\r\n   const lastScrollTimeRef = useRef(0);\r\n \r\n   // Process banners to determine mobile/desktop\r\n   useEffect(() => {\r\n@@ -130,9 +129,9 @@\n     (e: WheelEvent) => {\r\n       if (filteredBanners.length < 2) return;\r\n       \r\n       const now = Date.now();\r\n-      if (now - lastScrollTimeRef.current < 100) return; // Prevent rapid scrolling\r\n+      if (now - lastScrollTimeRef.current < 150) return; // Prevent rapid scrolling\r\n       lastScrollTimeRef.current = now;\r\n       \r\n       const delta = Math.sign(e.deltaY);\r\n       const currentScrollY = window.scrollY;\r\n@@ -180,32 +179,26 @@\n         } else {\r\n           // Add a small delay before allowing next scroll\r\n           setTimeout(() => {\r\n             setIsScrolling(false);\r\n-          }, 150);\r\n+          }, 200);\r\n         }\r\n       }\r\n       \r\n       requestAnimationFrame(animateScroll);\r\n     },\r\n     [filteredBanners.length, isScrolling]\r\n   );\r\n \r\n-  // Debounced scroll handler\r\n-  const debouncedScrollHandler = useMemo(\r\n-    () => debounce(handleScroll, 50),\r\n-    [handleScroll]\r\n-  );\r\n-\r\n-  // Add scroll listener with passive option for better performance\r\n+  // Add scroll listener with better performance\r\n   useEffect(() => {\r\n     const handleWheel = (e: WheelEvent) => {\r\n-      debouncedScrollHandler(e);\r\n+      handleScroll(e);\r\n     };\r\n     \r\n     window.addEventListener(\"wheel\", handleWheel, { passive: false });\r\n     return () => window.removeEventListener(\"wheel\", handleWheel);\r\n-  }, [debouncedScrollHandler]);\r\n+  }, [handleScroll]);\r\n \r\n   // Memoize banner items\r\n   const bannerItems = useMemo(() => {\r\n     return filteredBanners.map((banner, idx) => (\r\n"
                },
                {
                    "date": 1750482534403,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -129,9 +129,9 @@\n     (e: WheelEvent) => {\r\n       if (filteredBanners.length < 2) return;\r\n       \r\n       const now = Date.now();\r\n-      if (now - lastScrollTimeRef.current < 150) return; // Prevent rapid scrolling\r\n+      if (now - lastScrollTimeRef.current < 100) return; // Giảm thời gian chờ\r\n       lastScrollTimeRef.current = now;\r\n       \r\n       const delta = Math.sign(e.deltaY);\r\n       const currentScrollY = window.scrollY;\r\n@@ -176,12 +176,12 @@\n         \r\n         if (progress < 1) {\r\n           requestAnimationFrame(animateScroll);\r\n         } else {\r\n-          // Add a small delay before allowing next scroll\r\n+          // Giảm delay để scroll nhanh hơn\r\n           setTimeout(() => {\r\n             setIsScrolling(false);\r\n-          }, 200);\r\n+          }, 100);\r\n         }\r\n       }\r\n       \r\n       requestAnimationFrame(animateScroll);\r\n"
                },
                {
                    "date": 1750482540748,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -129,9 +129,9 @@\n     (e: WheelEvent) => {\r\n       if (filteredBanners.length < 2) return;\r\n       \r\n       const now = Date.now();\r\n-      if (now - lastScrollTimeRef.current < 100) return; // Giảm thời gian chờ\r\n+      if (now - lastScrollTimeRef.current < 150) return; // Prevent rapid scrolling\r\n       lastScrollTimeRef.current = now;\r\n       \r\n       const delta = Math.sign(e.deltaY);\r\n       const currentScrollY = window.scrollY;\r\n@@ -176,12 +176,12 @@\n         \r\n         if (progress < 1) {\r\n           requestAnimationFrame(animateScroll);\r\n         } else {\r\n-          // Giảm delay để scroll nhanh hơn\r\n+          // Add a small delay before allowing next scroll\r\n           setTimeout(() => {\r\n             setIsScrolling(false);\r\n-          }, 100);\r\n+          }, 200);\r\n         }\r\n       }\r\n       \r\n       requestAnimationFrame(animateScroll);\r\n"
                },
                {
                    "date": 1750482563956,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -129,9 +129,9 @@\n     (e: WheelEvent) => {\r\n       if (filteredBanners.length < 2) return;\r\n       \r\n       const now = Date.now();\r\n-      if (now - lastScrollTimeRef.current < 150) return; // Prevent rapid scrolling\r\n+      if (now - lastScrollTimeRef.current < 100) return; // Giảm thời gian chờ\r\n       lastScrollTimeRef.current = now;\r\n       \r\n       const delta = Math.sign(e.deltaY);\r\n       const currentScrollY = window.scrollY;\r\n@@ -176,12 +176,12 @@\n         \r\n         if (progress < 1) {\r\n           requestAnimationFrame(animateScroll);\r\n         } else {\r\n-          // Add a small delay before allowing next scroll\r\n+          // Giảm delay để scroll nhanh hơn\r\n           setTimeout(() => {\r\n             setIsScrolling(false);\r\n-          }, 200);\r\n+          }, 100);\r\n         }\r\n       }\r\n       \r\n       requestAnimationFrame(animateScroll);\r\n"
                },
                {
                    "date": 1750482577979,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -191,8 +191,9 @@\n \r\n   // Add scroll listener with better performance\r\n   useEffect(() => {\r\n     const handleWheel = (e: WheelEvent) => {\r\n+      // Scroll ngay lập tức khi lăn chuột\r\n       handleScroll(e);\r\n     };\r\n     \r\n     window.addEventListener(\"wheel\", handleWheel, { passive: false });\r\n@@ -243,9 +244,9 @@\n           />\r\n         ))}\r\n       </Head>\r\n       <div className=\"relative w-full bg-black overflow-hidden\">\r\n-        <div className=\"flex flex-col\">\r\n+        <div className=\"flex flex-col\" style={{ height: `${filteredBanners.length * 100}vh` }}>\r\n           {bannerItems}\r\n         </div>\r\n \r\n         {/* SHOP NOW text */}\r\n"
                },
                {
                    "date": 1750482714489,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -129,9 +129,9 @@\n     (e: WheelEvent) => {\r\n       if (filteredBanners.length < 2) return;\r\n       \r\n       const now = Date.now();\r\n-      if (now - lastScrollTimeRef.current < 100) return; // Giảm thời gian chờ\r\n+      if (now - lastScrollTimeRef.current < 50) return; // Giảm thời gian chờ để responsive hơn\r\n       lastScrollTimeRef.current = now;\r\n       \r\n       const delta = Math.sign(e.deltaY);\r\n       const currentScrollY = window.scrollY;\r\n@@ -149,9 +149,12 @@\n       }\r\n       \r\n       e.preventDefault();\r\n       \r\n-      if (isScrolling) return;\r\n+      if (isScrolling) {\r\n+        // Nếu đang scroll, dừng animation hiện tại và bắt đầu animation mới\r\n+        return;\r\n+      }\r\n       \r\n       let newIndex = currentIndex + delta;\r\n       \r\n       // Ensure newIndex is within bounds\r\n@@ -179,9 +182,9 @@\n         } else {\r\n           // Giảm delay để scroll nhanh hơn\r\n           setTimeout(() => {\r\n             setIsScrolling(false);\r\n-          }, 100);\r\n+          }, 50);\r\n         }\r\n       }\r\n       \r\n       requestAnimationFrame(animateScroll);\r\n"
                },
                {
                    "date": 1750482721744,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -45,8 +45,23 @@\n     timeout = setTimeout(() => func(...args), wait);\r\n   };\r\n }\r\n \r\n+// Throttle function để xử lý scroll mạnh\r\n+function throttle<T extends (...args: any[]) => any>(\r\n+  func: T,\r\n+  limit: number\r\n+): (...args: Parameters<T>) => void {\r\n+  let inThrottle: boolean;\r\n+  return (...args: Parameters<T>) => {\r\n+    if (!inThrottle) {\r\n+      func(...args);\r\n+      inThrottle = true;\r\n+      setTimeout(() => inThrottle = false, limit);\r\n+    }\r\n+  };\r\n+}\r\n+\r\n const BannerItem = React.memo(({ banner, idx }: BannerItemProps) => (\r\n   <div\r\n     key={banner._id || idx}\r\n     className=\"relative w-full h-screen flex items-center justify-center m-0 p-0 overflow-hidden\"\r\n"
                },
                {
                    "date": 1750482728527,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -208,11 +208,13 @@\n   );\r\n \r\n   // Add scroll listener with better performance\r\n   useEffect(() => {\r\n+    const throttledScrollHandler = throttle(handleScroll, 100);\r\n+    \r\n     const handleWheel = (e: WheelEvent) => {\r\n       // Scroll ngay lập tức khi lăn chuột\r\n-      handleScroll(e);\r\n+      throttledScrollHandler(e);\r\n     };\r\n     \r\n     window.addEventListener(\"wheel\", handleWheel, { passive: false });\r\n     return () => window.removeEventListener(\"wheel\", handleWheel);\r\n"
                },
                {
                    "date": 1750482866672,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -144,9 +144,9 @@\n     (e: WheelEvent) => {\r\n       if (filteredBanners.length < 2) return;\r\n       \r\n       const now = Date.now();\r\n-      if (now - lastScrollTimeRef.current < 50) return; // Giảm thời gian chờ để responsive hơn\r\n+      if (now - lastScrollTimeRef.current < 30) return; // Giảm thời gian chờ để responsive hơn\r\n       lastScrollTimeRef.current = now;\r\n       \r\n       const delta = Math.sign(e.deltaY);\r\n       const currentScrollY = window.scrollY;\r\n@@ -164,11 +164,11 @@\n       }\r\n       \r\n       e.preventDefault();\r\n       \r\n+      // Nếu đang scroll, dừng animation hiện tại và bắt đầu ngay lập tức\r\n       if (isScrolling) {\r\n-        // Nếu đang scroll, dừng animation hiện tại và bắt đầu animation mới\r\n-        return;\r\n+        setIsScrolling(false);\r\n       }\r\n       \r\n       let newIndex = currentIndex + delta;\r\n       \r\n@@ -182,28 +182,16 @@\n       setIsScrolling(true);\r\n       setCurrentImage(newIndex);\r\n       \r\n       const targetScrollY = newIndex * windowHeight;\r\n-      const startTime = performance.now();\r\n       \r\n-      function animateScroll(now: number) {\r\n-        const elapsed = now - startTime;\r\n-        const progress = Math.min(elapsed / SCROLL_ANIMATION_DURATION, 1);\r\n-        \r\n-        const newScrollY = currentScrollY + (targetScrollY - currentScrollY) * easeInOutCubic(progress);\r\n-        window.scrollTo(0, newScrollY);\r\n-        \r\n-        if (progress < 1) {\r\n-          requestAnimationFrame(animateScroll);\r\n-        } else {\r\n-          // Giảm delay để scroll nhanh hơn\r\n-          setTimeout(() => {\r\n-            setIsScrolling(false);\r\n-          }, 50);\r\n-        }\r\n-      }\r\n+      // Scroll trực tiếp đến vị trí mới để tránh giật\r\n+      window.scrollTo(0, targetScrollY);\r\n       \r\n-      requestAnimationFrame(animateScroll);\r\n+      // Chỉ set isScrolling = false sau một khoảng thời gian ngắn\r\n+      setTimeout(() => {\r\n+        setIsScrolling(false);\r\n+      }, 100);\r\n     },\r\n     [filteredBanners.length, isScrolling]\r\n   );\r\n \r\n"
                },
                {
                    "date": 1750482880218,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -196,9 +196,9 @@\n   );\r\n \r\n   // Add scroll listener with better performance\r\n   useEffect(() => {\r\n-    const throttledScrollHandler = throttle(handleScroll, 100);\r\n+    const throttledScrollHandler = throttle(handleScroll, 50); // Giảm throttle time\r\n     \r\n     const handleWheel = (e: WheelEvent) => {\r\n       // Scroll ngay lập tức khi lăn chuột\r\n       throttledScrollHandler(e);\r\n"
                },
                {
                    "date": 1750483018798,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -182,16 +182,28 @@\n       setIsScrolling(true);\r\n       setCurrentImage(newIndex);\r\n       \r\n       const targetScrollY = newIndex * windowHeight;\r\n+      const startTime = performance.now();\r\n       \r\n-      // Scroll trực tiếp đến vị trí mới để tránh giật\r\n-      window.scrollTo(0, targetScrollY);\r\n+      function animateScroll(now: number) {\r\n+        const elapsed = now - startTime;\r\n+        const progress = Math.min(elapsed / SCROLL_ANIMATION_DURATION, 1);\r\n+        \r\n+        const newScrollY = currentScrollY + (targetScrollY - currentScrollY) * easeInOutCubic(progress);\r\n+        window.scrollTo(0, newScrollY);\r\n+        \r\n+        if (progress < 1) {\r\n+          requestAnimationFrame(animateScroll);\r\n+        } else {\r\n+          // Chỉ set isScrolling = false sau khi animation hoàn thành\r\n+          setTimeout(() => {\r\n+            setIsScrolling(false);\r\n+          }, 50);\r\n+        }\r\n+      }\r\n       \r\n-      // Chỉ set isScrolling = false sau một khoảng thời gian ngắn\r\n-      setTimeout(() => {\r\n-        setIsScrolling(false);\r\n-      }, 100);\r\n+      requestAnimationFrame(animateScroll);\r\n     },\r\n     [filteredBanners.length, isScrolling]\r\n   );\r\n \r\n"
                },
                {
                    "date": 1750483025935,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -24,9 +24,9 @@\n   initialBanners: Banner[];\r\n }\r\n \r\n const DEFAULT_BANNER_IMAGE = \"/images/image1.jpg\";\r\n-const SCROLL_ANIMATION_DURATION = 800;\r\n+const SCROLL_ANIMATION_DURATION = 600;\r\n const SCROLL_THRESHOLD = 50;\r\n \r\n function easeInOutCubic(t: number) {\r\n   return t < 0.5\r\n"
                },
                {
                    "date": 1750483046110,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -96,8 +96,9 @@\n   const [isScrolling, setIsScrolling] = useState(false);\r\n   const [isMobileDevice, setIsMobileDevice] = useState(false);\r\n   const router = useRouter();\r\n   const lastScrollTimeRef = useRef(0);\r\n+  const animationRef = useRef<number>(); // Thêm ref để track animation\r\n \r\n   // Process banners to determine mobile/desktop\r\n   useEffect(() => {\r\n     let ignore = false;\r\n@@ -164,8 +165,13 @@\n       }\r\n       \r\n       e.preventDefault();\r\n       \r\n+      // Dừng animation hiện tại nếu có\r\n+      if (animationRef.current) {\r\n+        cancelAnimationFrame(animationRef.current);\r\n+      }\r\n+      \r\n       // Nếu đang scroll, dừng animation hiện tại và bắt đầu ngay lập tức\r\n       if (isScrolling) {\r\n         setIsScrolling(false);\r\n       }\r\n@@ -192,18 +198,19 @@\n         const newScrollY = currentScrollY + (targetScrollY - currentScrollY) * easeInOutCubic(progress);\r\n         window.scrollTo(0, newScrollY);\r\n         \r\n         if (progress < 1) {\r\n-          requestAnimationFrame(animateScroll);\r\n+          animationRef.current = requestAnimationFrame(animateScroll);\r\n         } else {\r\n           // Chỉ set isScrolling = false sau khi animation hoàn thành\r\n           setTimeout(() => {\r\n             setIsScrolling(false);\r\n+            animationRef.current = undefined;\r\n           }, 50);\r\n         }\r\n       }\r\n       \r\n-      requestAnimationFrame(animateScroll);\r\n+      animationRef.current = requestAnimationFrame(animateScroll);\r\n     },\r\n     [filteredBanners.length, isScrolling]\r\n   );\r\n \r\n"
                },
                {
                    "date": 1750483063002,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -96,9 +96,9 @@\n   const [isScrolling, setIsScrolling] = useState(false);\r\n   const [isMobileDevice, setIsMobileDevice] = useState(false);\r\n   const router = useRouter();\r\n   const lastScrollTimeRef = useRef(0);\r\n-  const animationRef = useRef<number>(); // Thêm ref để track animation\r\n+  const animationRef = useRef<number | undefined>();\r\n \r\n   // Process banners to determine mobile/desktop\r\n   useEffect(() => {\r\n     let ignore = false;\r\n"
                },
                {
                    "date": 1750483072104,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -96,9 +96,9 @@\n   const [isScrolling, setIsScrolling] = useState(false);\r\n   const [isMobileDevice, setIsMobileDevice] = useState(false);\r\n   const router = useRouter();\r\n   const lastScrollTimeRef = useRef(0);\r\n-  const animationRef = useRef<number | undefined>();\r\n+  const animationRef = useRef<number | undefined>(undefined);\r\n \r\n   // Process banners to determine mobile/desktop\r\n   useEffect(() => {\r\n     let ignore = false;\r\n"
                },
                {
                    "date": 1750483250368,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -24,10 +24,11 @@\n   initialBanners: Banner[];\r\n }\r\n \r\n const DEFAULT_BANNER_IMAGE = \"/images/image1.jpg\";\r\n-const SCROLL_ANIMATION_DURATION = 600;\r\n+const SCROLL_ANIMATION_DURATION = 800;\r\n const SCROLL_THRESHOLD = 50;\r\n+const SCROLL_FOLLOW_DURATION = 200;\r\n \r\n function easeInOutCubic(t: number) {\r\n   return t < 0.5\r\n     ? 4 * t * t * t\r\n"
                },
                {
                    "date": 1750483265878,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -189,29 +189,52 @@\n       setIsScrolling(true);\r\n       setCurrentImage(newIndex);\r\n       \r\n       const targetScrollY = newIndex * windowHeight;\r\n-      const startTime = performance.now();\r\n       \r\n-      function animateScroll(now: number) {\r\n-        const elapsed = now - startTime;\r\n-        const progress = Math.min(elapsed / SCROLL_ANIMATION_DURATION, 1);\r\n+      // Đầu tiên, cho ảnh giật theo scroll trong 0.2s\r\n+      const scrollStartTime = performance.now();\r\n+      const initialScrollY = currentScrollY;\r\n+      \r\n+      function followScroll(now: number) {\r\n+        const elapsed = now - scrollStartTime;\r\n+        const progress = Math.min(elapsed / SCROLL_FOLLOW_DURATION, 1);\r\n         \r\n-        const newScrollY = currentScrollY + (targetScrollY - currentScrollY) * easeInOutCubic(progress);\r\n-        window.scrollTo(0, newScrollY);\r\n+        // Tính toán vị trí scroll theo hướng của delta\r\n+        const followDistance = delta * windowHeight * 0.3; // Giật 30% khoảng cách\r\n+        const currentFollowY = initialScrollY + followDistance * progress;\r\n         \r\n+        window.scrollTo(0, currentFollowY);\r\n+        \r\n         if (progress < 1) {\r\n+          animationRef.current = requestAnimationFrame(followScroll);\r\n+        } else {\r\n+          // Sau khi giật xong, bắt đầu animation mượt\r\n+          const smoothStartTime = performance.now();\r\n+          \r\n+          function animateScroll(now: number) {\r\n+            const elapsed = now - smoothStartTime;\r\n+            const progress = Math.min(elapsed / SCROLL_ANIMATION_DURATION, 1);\r\n+            \r\n+            const newScrollY = currentFollowY + (targetScrollY - currentFollowY) * easeInOutCubic(progress);\r\n+            window.scrollTo(0, newScrollY);\r\n+            \r\n+            if (progress < 1) {\r\n+              animationRef.current = requestAnimationFrame(animateScroll);\r\n+            } else {\r\n+              // Chỉ set isScrolling = false sau khi animation hoàn thành\r\n+              setTimeout(() => {\r\n+                setIsScrolling(false);\r\n+                animationRef.current = undefined;\r\n+              }, 50);\r\n+            }\r\n+          }\r\n+          \r\n           animationRef.current = requestAnimationFrame(animateScroll);\r\n-        } else {\r\n-          // Chỉ set isScrolling = false sau khi animation hoàn thành\r\n-          setTimeout(() => {\r\n-            setIsScrolling(false);\r\n-            animationRef.current = undefined;\r\n-          }, 50);\r\n         }\r\n       }\r\n       \r\n-      animationRef.current = requestAnimationFrame(animateScroll);\r\n+      animationRef.current = requestAnimationFrame(followScroll);\r\n     },\r\n     [filteredBanners.length, isScrolling]\r\n   );\r\n \r\n"
                },
                {
                    "date": 1750483280681,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -24,11 +24,10 @@\n   initialBanners: Banner[];\r\n }\r\n \r\n const DEFAULT_BANNER_IMAGE = \"/images/image1.jpg\";\r\n-const SCROLL_ANIMATION_DURATION = 800;\r\n+const SCROLL_ANIMATION_DURATION = 600;\r\n const SCROLL_THRESHOLD = 50;\r\n-const SCROLL_FOLLOW_DURATION = 200;\r\n \r\n function easeInOutCubic(t: number) {\r\n   return t < 0.5\r\n     ? 4 * t * t * t\r\n@@ -189,52 +188,29 @@\n       setIsScrolling(true);\r\n       setCurrentImage(newIndex);\r\n       \r\n       const targetScrollY = newIndex * windowHeight;\r\n+      const startTime = performance.now();\r\n       \r\n-      // Đầu tiên, cho ảnh giật theo scroll trong 0.2s\r\n-      const scrollStartTime = performance.now();\r\n-      const initialScrollY = currentScrollY;\r\n-      \r\n-      function followScroll(now: number) {\r\n-        const elapsed = now - scrollStartTime;\r\n-        const progress = Math.min(elapsed / SCROLL_FOLLOW_DURATION, 1);\r\n+      function animateScroll(now: number) {\r\n+        const elapsed = now - startTime;\r\n+        const progress = Math.min(elapsed / SCROLL_ANIMATION_DURATION, 1);\r\n         \r\n-        // Tính toán vị trí scroll theo hướng của delta\r\n-        const followDistance = delta * windowHeight * 0.3; // Giật 30% khoảng cách\r\n-        const currentFollowY = initialScrollY + followDistance * progress;\r\n+        const newScrollY = currentScrollY + (targetScrollY - currentScrollY) * easeInOutCubic(progress);\r\n+        window.scrollTo(0, newScrollY);\r\n         \r\n-        window.scrollTo(0, currentFollowY);\r\n-        \r\n         if (progress < 1) {\r\n-          animationRef.current = requestAnimationFrame(followScroll);\r\n+          animationRef.current = requestAnimationFrame(animateScroll);\r\n         } else {\r\n-          // Sau khi giật xong, bắt đầu animation mượt\r\n-          const smoothStartTime = performance.now();\r\n-          \r\n-          function animateScroll(now: number) {\r\n-            const elapsed = now - smoothStartTime;\r\n-            const progress = Math.min(elapsed / SCROLL_ANIMATION_DURATION, 1);\r\n-            \r\n-            const newScrollY = currentFollowY + (targetScrollY - currentFollowY) * easeInOutCubic(progress);\r\n-            window.scrollTo(0, newScrollY);\r\n-            \r\n-            if (progress < 1) {\r\n-              animationRef.current = requestAnimationFrame(animateScroll);\r\n-            } else {\r\n-              // Chỉ set isScrolling = false sau khi animation hoàn thành\r\n-              setTimeout(() => {\r\n-                setIsScrolling(false);\r\n-                animationRef.current = undefined;\r\n-              }, 50);\r\n-            }\r\n-          }\r\n-          \r\n-          animationRef.current = requestAnimationFrame(animateScroll);\r\n+          // Chỉ set isScrolling = false sau khi animation hoàn thành\r\n+          setTimeout(() => {\r\n+            setIsScrolling(false);\r\n+            animationRef.current = undefined;\r\n+          }, 50);\r\n         }\r\n       }\r\n       \r\n-      animationRef.current = requestAnimationFrame(followScroll);\r\n+      animationRef.current = requestAnimationFrame(animateScroll);\r\n     },\r\n     [filteredBanners.length, isScrolling]\r\n   );\r\n \r\n"
                },
                {
                    "date": 1750483289994,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -26,8 +26,9 @@\n \r\n const DEFAULT_BANNER_IMAGE = \"/images/image1.jpg\";\r\n const SCROLL_ANIMATION_DURATION = 600;\r\n const SCROLL_THRESHOLD = 50;\r\n+const SCROLL_FOLLOW_DURATION = 200;\r\n \r\n function easeInOutCubic(t: number) {\r\n   return t < 0.5\r\n     ? 4 * t * t * t\r\n@@ -188,29 +189,52 @@\n       setIsScrolling(true);\r\n       setCurrentImage(newIndex);\r\n       \r\n       const targetScrollY = newIndex * windowHeight;\r\n-      const startTime = performance.now();\r\n       \r\n-      function animateScroll(now: number) {\r\n-        const elapsed = now - startTime;\r\n-        const progress = Math.min(elapsed / SCROLL_ANIMATION_DURATION, 1);\r\n+      // Đầu tiên, cho ảnh giật theo scroll trong 0.2s\r\n+      const scrollStartTime = performance.now();\r\n+      const initialScrollY = currentScrollY;\r\n+      \r\n+      function followScroll(now: number) {\r\n+        const elapsed = now - scrollStartTime;\r\n+        const progress = Math.min(elapsed / SCROLL_FOLLOW_DURATION, 1);\r\n         \r\n-        const newScrollY = currentScrollY + (targetScrollY - currentScrollY) * easeInOutCubic(progress);\r\n-        window.scrollTo(0, newScrollY);\r\n+        // Tính toán vị trí scroll theo hướng của delta\r\n+        const followDistance = delta * windowHeight * 0.3; // Giật 30% khoảng cách\r\n+        const currentFollowY = initialScrollY + followDistance * progress;\r\n         \r\n+        window.scrollTo(0, currentFollowY);\r\n+        \r\n         if (progress < 1) {\r\n+          animationRef.current = requestAnimationFrame(followScroll);\r\n+        } else {\r\n+          // Sau khi giật xong, bắt đầu animation mượt\r\n+          const smoothStartTime = performance.now();\r\n+          \r\n+          function animateScroll(now: number) {\r\n+            const elapsed = now - smoothStartTime;\r\n+            const progress = Math.min(elapsed / SCROLL_ANIMATION_DURATION, 1);\r\n+            \r\n+            const newScrollY = currentFollowY + (targetScrollY - currentFollowY) * easeInOutCubic(progress);\r\n+            window.scrollTo(0, newScrollY);\r\n+            \r\n+            if (progress < 1) {\r\n+              animationRef.current = requestAnimationFrame(animateScroll);\r\n+            } else {\r\n+              // Chỉ set isScrolling = false sau khi animation hoàn thành\r\n+              setTimeout(() => {\r\n+                setIsScrolling(false);\r\n+                animationRef.current = undefined;\r\n+              }, 50);\r\n+            }\r\n+          }\r\n+          \r\n           animationRef.current = requestAnimationFrame(animateScroll);\r\n-        } else {\r\n-          // Chỉ set isScrolling = false sau khi animation hoàn thành\r\n-          setTimeout(() => {\r\n-            setIsScrolling(false);\r\n-            animationRef.current = undefined;\r\n-          }, 50);\r\n         }\r\n       }\r\n       \r\n-      animationRef.current = requestAnimationFrame(animateScroll);\r\n+      animationRef.current = requestAnimationFrame(followScroll);\r\n     },\r\n     [filteredBanners.length, isScrolling]\r\n   );\r\n \r\n"
                },
                {
                    "date": 1750483318582,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -24,11 +24,10 @@\n   initialBanners: Banner[];\r\n }\r\n \r\n const DEFAULT_BANNER_IMAGE = \"/images/image1.jpg\";\r\n-const SCROLL_ANIMATION_DURATION = 600;\r\n+const SCROLL_ANIMATION_DURATION = 800;\r\n const SCROLL_THRESHOLD = 50;\r\n-const SCROLL_FOLLOW_DURATION = 200;\r\n \r\n function easeInOutCubic(t: number) {\r\n   return t < 0.5\r\n     ? 4 * t * t * t\r\n@@ -189,52 +188,29 @@\n       setIsScrolling(true);\r\n       setCurrentImage(newIndex);\r\n       \r\n       const targetScrollY = newIndex * windowHeight;\r\n+      const startTime = performance.now();\r\n       \r\n-      // Đầu tiên, cho ảnh giật theo scroll trong 0.2s\r\n-      const scrollStartTime = performance.now();\r\n-      const initialScrollY = currentScrollY;\r\n-      \r\n-      function followScroll(now: number) {\r\n-        const elapsed = now - scrollStartTime;\r\n-        const progress = Math.min(elapsed / SCROLL_FOLLOW_DURATION, 1);\r\n+      function animateScroll(now: number) {\r\n+        const elapsed = now - startTime;\r\n+        const progress = Math.min(elapsed / SCROLL_ANIMATION_DURATION, 1);\r\n         \r\n-        // Tính toán vị trí scroll theo hướng của delta\r\n-        const followDistance = delta * windowHeight * 0.3; // Giật 30% khoảng cách\r\n-        const currentFollowY = initialScrollY + followDistance * progress;\r\n+        const newScrollY = currentScrollY + (targetScrollY - currentScrollY) * easeInOutCubic(progress);\r\n+        window.scrollTo(0, newScrollY);\r\n         \r\n-        window.scrollTo(0, currentFollowY);\r\n-        \r\n         if (progress < 1) {\r\n-          animationRef.current = requestAnimationFrame(followScroll);\r\n+          animationRef.current = requestAnimationFrame(animateScroll);\r\n         } else {\r\n-          // Sau khi giật xong, bắt đầu animation mượt\r\n-          const smoothStartTime = performance.now();\r\n-          \r\n-          function animateScroll(now: number) {\r\n-            const elapsed = now - smoothStartTime;\r\n-            const progress = Math.min(elapsed / SCROLL_ANIMATION_DURATION, 1);\r\n-            \r\n-            const newScrollY = currentFollowY + (targetScrollY - currentFollowY) * easeInOutCubic(progress);\r\n-            window.scrollTo(0, newScrollY);\r\n-            \r\n-            if (progress < 1) {\r\n-              animationRef.current = requestAnimationFrame(animateScroll);\r\n-            } else {\r\n-              // Chỉ set isScrolling = false sau khi animation hoàn thành\r\n-              setTimeout(() => {\r\n-                setIsScrolling(false);\r\n-                animationRef.current = undefined;\r\n-              }, 50);\r\n-            }\r\n-          }\r\n-          \r\n-          animationRef.current = requestAnimationFrame(animateScroll);\r\n+          // Chỉ set isScrolling = false sau khi animation hoàn thành\r\n+          setTimeout(() => {\r\n+            setIsScrolling(false);\r\n+            animationRef.current = undefined;\r\n+          }, 50);\r\n         }\r\n       }\r\n       \r\n-      animationRef.current = requestAnimationFrame(followScroll);\r\n+      animationRef.current = requestAnimationFrame(animateScroll);\r\n     },\r\n     [filteredBanners.length, isScrolling]\r\n   );\r\n \r\n"
                },
                {
                    "date": 1750483331214,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -145,9 +145,9 @@\n     (e: WheelEvent) => {\r\n       if (filteredBanners.length < 2) return;\r\n       \r\n       const now = Date.now();\r\n-      if (now - lastScrollTimeRef.current < 30) return; // Giảm thời gian chờ để responsive hơn\r\n+      if (now - lastScrollTimeRef.current < 50) return; // Tăng thời gian chờ để tránh giật\r\n       lastScrollTimeRef.current = now;\r\n       \r\n       const delta = Math.sign(e.deltaY);\r\n       const currentScrollY = window.scrollY;\r\n@@ -170,11 +170,11 @@\n       if (animationRef.current) {\r\n         cancelAnimationFrame(animationRef.current);\r\n       }\r\n       \r\n-      // Nếu đang scroll, dừng animation hiện tại và bắt đầu ngay lập tức\r\n+      // Nếu đang scroll, đợi animation cũ hoàn thành\r\n       if (isScrolling) {\r\n-        setIsScrolling(false);\r\n+        return; // Không bắt đầu animation mới nếu đang scroll\r\n       }\r\n       \r\n       let newIndex = currentIndex + delta;\r\n       \r\n@@ -204,9 +204,9 @@\n           // Chỉ set isScrolling = false sau khi animation hoàn thành\r\n           setTimeout(() => {\r\n             setIsScrolling(false);\r\n             animationRef.current = undefined;\r\n-          }, 50);\r\n+          }, 100); // Tăng delay để đảm bảo animation hoàn thành\r\n         }\r\n       }\r\n       \r\n       animationRef.current = requestAnimationFrame(animateScroll);\r\n"
                },
                {
                    "date": 1750483338383,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -215,9 +215,9 @@\n   );\r\n \r\n   // Add scroll listener with better performance\r\n   useEffect(() => {\r\n-    const throttledScrollHandler = throttle(handleScroll, 50); // Giảm throttle time\r\n+    const throttledScrollHandler = throttle(handleScroll, 100); // Tăng throttle time để tránh giật\r\n     \r\n     const handleWheel = (e: WheelEvent) => {\r\n       // Scroll ngay lập tức khi lăn chuột\r\n       throttledScrollHandler(e);\r\n"
                },
                {
                    "date": 1750483528588,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -145,9 +145,9 @@\n     (e: WheelEvent) => {\r\n       if (filteredBanners.length < 2) return;\r\n       \r\n       const now = Date.now();\r\n-      if (now - lastScrollTimeRef.current < 50) return; // Tăng thời gian chờ để tránh giật\r\n+      if (now - lastScrollTimeRef.current < 30) return; // Giảm thời gian chờ để responsive hơn\r\n       lastScrollTimeRef.current = now;\r\n       \r\n       const delta = Math.sign(e.deltaY);\r\n       const currentScrollY = window.scrollY;\r\n@@ -170,11 +170,11 @@\n       if (animationRef.current) {\r\n         cancelAnimationFrame(animationRef.current);\r\n       }\r\n       \r\n-      // Nếu đang scroll, đợi animation cũ hoàn thành\r\n+      // Luôn luôn bắt đầu animation mới, dù đang scroll hay không\r\n       if (isScrolling) {\r\n-        return; // Không bắt đầu animation mới nếu đang scroll\r\n+        setIsScrolling(false);\r\n       }\r\n       \r\n       let newIndex = currentIndex + delta;\r\n       \r\n@@ -204,9 +204,9 @@\n           // Chỉ set isScrolling = false sau khi animation hoàn thành\r\n           setTimeout(() => {\r\n             setIsScrolling(false);\r\n             animationRef.current = undefined;\r\n-          }, 100); // Tăng delay để đảm bảo animation hoàn thành\r\n+          }, 50);\r\n         }\r\n       }\r\n       \r\n       animationRef.current = requestAnimationFrame(animateScroll);\r\n"
                },
                {
                    "date": 1750483536389,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -215,9 +215,9 @@\n   );\r\n \r\n   // Add scroll listener with better performance\r\n   useEffect(() => {\r\n-    const throttledScrollHandler = throttle(handleScroll, 100); // Tăng throttle time để tránh giật\r\n+    const throttledScrollHandler = throttle(handleScroll, 50); // Giảm throttle time để responsive hơn\r\n     \r\n     const handleWheel = (e: WheelEvent) => {\r\n       // Scroll ngay lập tức khi lăn chuột\r\n       throttledScrollHandler(e);\r\n"
                },
                {
                    "date": 1750483810011,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -24,9 +24,9 @@\n   initialBanners: Banner[];\r\n }\r\n \r\n const DEFAULT_BANNER_IMAGE = \"/images/image1.jpg\";\r\n-const SCROLL_ANIMATION_DURATION = 800;\r\n+const SCROLL_ANIMATION_DURATION = 1000;\r\n const SCROLL_THRESHOLD = 50;\r\n \r\n function easeInOutCubic(t: number) {\r\n   return t < 0.5\r\n"
                },
                {
                    "date": 1750483819708,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -134,8 +134,14 @@\n     window.addEventListener('resize', checkMobile);\r\n     return () => window.removeEventListener('resize', checkMobile);\r\n   }, []);\r\n \r\n+  // Scroll to top when component mounts\r\n+  useEffect(() => {\r\n+    // Scroll về đầu trang khi vào website\r\n+    window.scrollTo(0, 0);\r\n+  }, []);\r\n+\r\n   // Filter banners by device type\r\n   const filteredBanners = useMemo(() => {\r\n     return banners.filter(banner => banner.isMobile === isMobileDevice);\r\n   }, [banners, isMobileDevice]);\r\n"
                },
                {
                    "date": 1750483827436,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -33,8 +33,15 @@\n     ? 4 * t * t * t\r\n     : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;\r\n }\r\n \r\n+// Thêm easing function mượt hơn\r\n+function easeInOutQuart(t: number) {\r\n+  return t < 0.5\r\n+    ? 8 * t * t * t * t\r\n+    : 1 - 8 * (--t) * t * t * t;\r\n+}\r\n+\r\n // Debounce function\r\n function debounce<T extends (...args: any[]) => any>(\r\n   func: T,\r\n   wait: number\r\n"
                },
                {
                    "date": 1750483836990,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -207,9 +207,9 @@\n       function animateScroll(now: number) {\r\n         const elapsed = now - startTime;\r\n         const progress = Math.min(elapsed / SCROLL_ANIMATION_DURATION, 1);\r\n         \r\n-        const newScrollY = currentScrollY + (targetScrollY - currentScrollY) * easeInOutCubic(progress);\r\n+        const newScrollY = currentScrollY + (targetScrollY - currentScrollY) * easeInOutQuart(progress);\r\n         window.scrollTo(0, newScrollY);\r\n         \r\n         if (progress < 1) {\r\n           animationRef.current = requestAnimationFrame(animateScroll);\r\n"
                },
                {
                    "date": 1750484077743,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -158,9 +158,9 @@\n     (e: WheelEvent) => {\r\n       if (filteredBanners.length < 2) return;\r\n       \r\n       const now = Date.now();\r\n-      if (now - lastScrollTimeRef.current < 30) return; // Giảm thời gian chờ để responsive hơn\r\n+      if (now - lastScrollTimeRef.current < 50) return; // Tăng thời gian chờ để tránh giật\r\n       lastScrollTimeRef.current = now;\r\n       \r\n       const delta = Math.sign(e.deltaY);\r\n       const currentScrollY = window.scrollY;\r\n@@ -178,16 +178,11 @@\n       }\r\n       \r\n       e.preventDefault();\r\n       \r\n-      // Dừng animation hiện tại nếu có\r\n-      if (animationRef.current) {\r\n-        cancelAnimationFrame(animationRef.current);\r\n-      }\r\n-      \r\n-      // Luôn luôn bắt đầu animation mới, dù đang scroll hay không\r\n+      // Nếu đang scroll, không bắt đầu animation mới\r\n       if (isScrolling) {\r\n-        setIsScrolling(false);\r\n+        return;\r\n       }\r\n       \r\n       let newIndex = currentIndex + delta;\r\n       \r\n@@ -217,12 +212,17 @@\n           // Chỉ set isScrolling = false sau khi animation hoàn thành\r\n           setTimeout(() => {\r\n             setIsScrolling(false);\r\n             animationRef.current = undefined;\r\n-          }, 50);\r\n+          }, 100); // Tăng delay để đảm bảo animation hoàn thành\r\n         }\r\n       }\r\n       \r\n+      // Dừng animation hiện tại nếu có\r\n+      if (animationRef.current) {\r\n+        cancelAnimationFrame(animationRef.current);\r\n+      }\r\n+      \r\n       animationRef.current = requestAnimationFrame(animateScroll);\r\n     },\r\n     [filteredBanners.length, isScrolling]\r\n   );\r\n"
                },
                {
                    "date": 1750484086052,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -228,13 +228,11 @@\n   );\r\n \r\n   // Add scroll listener with better performance\r\n   useEffect(() => {\r\n-    const throttledScrollHandler = throttle(handleScroll, 50); // Giảm throttle time để responsive hơn\r\n-    \r\n     const handleWheel = (e: WheelEvent) => {\r\n       // Scroll ngay lập tức khi lăn chuột\r\n-      throttledScrollHandler(e);\r\n+      handleScroll(e);\r\n     };\r\n     \r\n     window.addEventListener(\"wheel\", handleWheel, { passive: false });\r\n     return () => window.removeEventListener(\"wheel\", handleWheel);\r\n"
                },
                {
                    "date": 1750484191139,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -52,23 +52,8 @@\n     timeout = setTimeout(() => func(...args), wait);\r\n   };\r\n }\r\n \r\n-// Throttle function để xử lý scroll mạnh\r\n-function throttle<T extends (...args: any[]) => any>(\r\n-  func: T,\r\n-  limit: number\r\n-): (...args: Parameters<T>) => void {\r\n-  let inThrottle: boolean;\r\n-  return (...args: Parameters<T>) => {\r\n-    if (!inThrottle) {\r\n-      func(...args);\r\n-      inThrottle = true;\r\n-      setTimeout(() => inThrottle = false, limit);\r\n-    }\r\n-  };\r\n-}\r\n-\r\n const BannerItem = React.memo(({ banner, idx }: BannerItemProps) => (\r\n   <div\r\n     key={banner._id || idx}\r\n     className=\"relative w-full h-screen flex items-center justify-center m-0 p-0 overflow-hidden\"\r\n"
                },
                {
                    "date": 1750484462671,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -24,9 +24,9 @@\n   initialBanners: Banner[];\r\n }\r\n \r\n const DEFAULT_BANNER_IMAGE = \"/images/image1.jpg\";\r\n-const SCROLL_ANIMATION_DURATION = 1000;\r\n+const SCROLL_ANIMATION_DURATION = 1200; // Tăng thời gian animation\r\n const SCROLL_THRESHOLD = 50;\r\n \r\n function easeInOutCubic(t: number) {\r\n   return t < 0.5\r\n@@ -52,8 +52,23 @@\n     timeout = setTimeout(() => func(...args), wait);\r\n   };\r\n }\r\n \r\n+// Throttle function để xử lý scroll mạnh\r\n+function throttle<T extends (...args: any[]) => any>(\r\n+  func: T,\r\n+  limit: number\r\n+): (...args: Parameters<T>) => void {\r\n+  let inThrottle: boolean;\r\n+  return (...args: Parameters<T>) => {\r\n+    if (!inThrottle) {\r\n+      func(...args);\r\n+      inThrottle = true;\r\n+      setTimeout(() => inThrottle = false, limit);\r\n+    }\r\n+  };\r\n+}\r\n+\r\n const BannerItem = React.memo(({ banner, idx }: BannerItemProps) => (\r\n   <div\r\n     key={banner._id || idx}\r\n     className=\"relative w-full h-screen flex items-center justify-center m-0 p-0 overflow-hidden\"\r\n@@ -89,8 +104,10 @@\n   const [isMobileDevice, setIsMobileDevice] = useState(false);\r\n   const router = useRouter();\r\n   const lastScrollTimeRef = useRef(0);\r\n   const animationRef = useRef<number | undefined>(undefined);\r\n+  const scrollQueueRef = useRef<number[]>([]); // Queue để lưu các scroll event\r\n+  const isAnimatingRef = useRef(false); // Ref để track animation state\r\n \r\n   // Process banners to determine mobile/desktop\r\n   useEffect(() => {\r\n     let ignore = false;\r\n@@ -137,17 +154,65 @@\n   const filteredBanners = useMemo(() => {\r\n     return banners.filter(banner => banner.isMobile === isMobileDevice);\r\n   }, [banners, isMobileDevice]);\r\n \r\n-  // Improved scroll handler with better smoothness\r\n+  // Function để xử lý scroll animation\r\n+  const performScrollAnimation = useCallback((targetIndex: number) => {\r\n+    if (isAnimatingRef.current) return; // Nếu đang animate, không làm gì\r\n+    \r\n+    const currentScrollY = window.scrollY;\r\n+    const windowHeight = window.innerHeight;\r\n+    const targetScrollY = targetIndex * windowHeight;\r\n+    \r\n+    // Nếu đã ở vị trí đích, không cần animate\r\n+    if (Math.abs(currentScrollY - targetScrollY) < 10) {\r\n+      return;\r\n+    }\r\n+    \r\n+    isAnimatingRef.current = true;\r\n+    setIsScrolling(true);\r\n+    setCurrentImage(targetIndex);\r\n+    \r\n+    const startTime = performance.now();\r\n+    \r\n+    function animateScroll(now: number) {\r\n+      const elapsed = now - startTime;\r\n+      const progress = Math.min(elapsed / SCROLL_ANIMATION_DURATION, 1);\r\n+      \r\n+      const newScrollY = currentScrollY + (targetScrollY - currentScrollY) * easeInOutQuart(progress);\r\n+      window.scrollTo(0, newScrollY);\r\n+      \r\n+      if (progress < 1) {\r\n+        animationRef.current = requestAnimationFrame(animateScroll);\r\n+      } else {\r\n+        // Animation hoàn thành\r\n+        isAnimatingRef.current = false;\r\n+        setIsScrolling(false);\r\n+        animationRef.current = undefined;\r\n+        \r\n+        // Xử lý queue nếu có\r\n+        if (scrollQueueRef.current.length > 0) {\r\n+          const nextTarget = scrollQueueRef.current.shift();\r\n+          if (nextTarget !== undefined) {\r\n+            setTimeout(() => performScrollAnimation(nextTarget), 50);\r\n+          }\r\n+        }\r\n+      }\r\n+    }\r\n+    \r\n+    // Dừng animation hiện tại nếu có\r\n+    if (animationRef.current) {\r\n+      cancelAnimationFrame(animationRef.current);\r\n+    }\r\n+    \r\n+    animationRef.current = requestAnimationFrame(animateScroll);\r\n+  }, []);\r\n+\r\n+  // Improved scroll handler with queue system\r\n   const handleScroll = useCallback(\r\n     (e: WheelEvent) => {\r\n       if (filteredBanners.length < 2) return;\r\n       \r\n-      const now = Date.now();\r\n-      if (now - lastScrollTimeRef.current < 50) return; // Tăng thời gian chờ để tránh giật\r\n-      lastScrollTimeRef.current = now;\r\n-      \r\n       const delta = Math.sign(e.deltaY);\r\n       const currentScrollY = window.scrollY;\r\n       const windowHeight = window.innerHeight;\r\n       const currentIndex = Math.round(currentScrollY / windowHeight);\r\n@@ -163,13 +228,8 @@\n       }\r\n       \r\n       e.preventDefault();\r\n       \r\n-      // Nếu đang scroll, không bắt đầu animation mới\r\n-      if (isScrolling) {\r\n-        return;\r\n-      }\r\n-      \r\n       let newIndex = currentIndex + delta;\r\n       \r\n       // Ensure newIndex is within bounds\r\n       if (newIndex < 0) newIndex = 0;\r\n@@ -177,40 +237,19 @@\n       \r\n       // Don't scroll if we're already at the target position\r\n       if (newIndex === currentIndex) return;\r\n       \r\n-      setIsScrolling(true);\r\n-      setCurrentImage(newIndex);\r\n-      \r\n-      const targetScrollY = newIndex * windowHeight;\r\n-      const startTime = performance.now();\r\n-      \r\n-      function animateScroll(now: number) {\r\n-        const elapsed = now - startTime;\r\n-        const progress = Math.min(elapsed / SCROLL_ANIMATION_DURATION, 1);\r\n-        \r\n-        const newScrollY = currentScrollY + (targetScrollY - currentScrollY) * easeInOutQuart(progress);\r\n-        window.scrollTo(0, newScrollY);\r\n-        \r\n-        if (progress < 1) {\r\n-          animationRef.current = requestAnimationFrame(animateScroll);\r\n-        } else {\r\n-          // Chỉ set isScrolling = false sau khi animation hoàn thành\r\n-          setTimeout(() => {\r\n-            setIsScrolling(false);\r\n-            animationRef.current = undefined;\r\n-          }, 100); // Tăng delay để đảm bảo animation hoàn thành\r\n-        }\r\n+      // Nếu đang animate, thêm vào queue\r\n+      if (isAnimatingRef.current) {\r\n+        // Chỉ giữ lại target cuối cùng trong queue để tránh queue quá dài\r\n+        scrollQueueRef.current = [newIndex];\r\n+        return;\r\n       }\r\n       \r\n-      // Dừng animation hiện tại nếu có\r\n-      if (animationRef.current) {\r\n-        cancelAnimationFrame(animationRef.current);\r\n-      }\r\n-      \r\n-      animationRef.current = requestAnimationFrame(animateScroll);\r\n+      // Thực hiện animation ngay lập tức\r\n+      performScrollAnimation(newIndex);\r\n     },\r\n-    [filteredBanners.length, isScrolling]\r\n+    [filteredBanners.length, performScrollAnimation]\r\n   );\r\n \r\n   // Add scroll listener with better performance\r\n   useEffect(() => {\r\n@@ -222,8 +261,17 @@\n     window.addEventListener(\"wheel\", handleWheel, { passive: false });\r\n     return () => window.removeEventListener(\"wheel\", handleWheel);\r\n   }, [handleScroll]);\r\n \r\n+  // Cleanup on unmount\r\n+  useEffect(() => {\r\n+    return () => {\r\n+      if (animationRef.current) {\r\n+        cancelAnimationFrame(animationRef.current);\r\n+      }\r\n+    };\r\n+  }, []);\r\n+\r\n   // Memoize banner items\r\n   const bannerItems = useMemo(() => {\r\n     return filteredBanners.map((banner, idx) => (\r\n       <BannerItem\r\n"
                },
                {
                    "date": 1750484609596,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -24,9 +24,9 @@\n   initialBanners: Banner[];\r\n }\r\n \r\n const DEFAULT_BANNER_IMAGE = \"/images/image1.jpg\";\r\n-const SCROLL_ANIMATION_DURATION = 1200; // Tăng thời gian animation\r\n+const SCROLL_ANIMATION_DURATION = 600; // Giảm thời gian animation để tăng tốc độ\r\n const SCROLL_THRESHOLD = 50;\r\n \r\n function easeInOutCubic(t: number) {\r\n   return t < 0.5\r\n"
                },
                {
                    "date": 1750484618823,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -24,9 +24,9 @@\n   initialBanners: Banner[];\r\n }\r\n \r\n const DEFAULT_BANNER_IMAGE = \"/images/image1.jpg\";\r\n-const SCROLL_ANIMATION_DURATION = 600; // Giảm thời gian animation để tăng tốc độ\r\n+const SCROLL_ANIMATION_DURATION = 1200; // Tăng thời gian animation\r\n const SCROLL_THRESHOLD = 50;\r\n \r\n function easeInOutCubic(t: number) {\r\n   return t < 0.5\r\n"
                },
                {
                    "date": 1750484628273,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -24,9 +24,9 @@\n   initialBanners: Banner[];\r\n }\r\n \r\n const DEFAULT_BANNER_IMAGE = \"/images/image1.jpg\";\r\n-const SCROLL_ANIMATION_DURATION = 1200; // Tăng thời gian animation\r\n+const SCROLL_ANIMATION_DURATION = 850; // Tăng thời gian animation\r\n const SCROLL_THRESHOLD = 50;\r\n \r\n function easeInOutCubic(t: number) {\r\n   return t < 0.5\r\n"
                }
            ],
            "date": 1750476985213,
            "name": "Commit-0",
            "content": "\"use client\";\r\nimport { useState, useEffect, useCallback, useMemo } from \"react\";\r\nimport { useRouter } from \"next/navigation\";\r\nimport { motion } from \"framer-motion\";\r\nimport Image from \"next/image\";\r\nimport React from \"react\";\r\n\r\nconst DEFAULT_BANNER_IMAGE = \"/images/image1.jpg\";\r\nconst SCROLL_ANIMATION_DURATION = 700;\r\n\r\nfunction easeInOutCubic(t) {\r\n  return t < 0.5\r\n    ? 4 * t * t * t\r\n    : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;\r\n}\r\n\r\nconst BannerItem = React.memo(({ banner, idx }) => (\r\n  <div\r\n    key={banner._id || idx}\r\n    className=\"relative w-full h-screen flex items-center justify-center m-0 p-0 overflow-hidden\"\r\n  >\r\n    <div className=\"relative w-full h-full flex items-center justify-center bg-black m-0 p-0\">\r\n      <Image\r\n        src={banner.imageUrl}\r\n        alt={banner.title || `Banner ${idx + 1}`}\r\n        fill\r\n        className=\"object-cover\"\r\n        priority={idx === 0} // Only prioritize the first image\r\n        loading={idx === 0 ? \"eager\" : \"lazy\"} // Eager load the first, lazy load the rest\r\n        sizes=\"100vw\"\r\n        quality={90}\r\n        placeholder=\"blur\"\r\n        blurDataURL={banner.blurDataURL || \"data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7\"}\r\n        style={{\r\n          objectFit: 'cover',\r\n          objectPosition: 'center',\r\n          willChange: 'transform',\r\n        }}\r\n        onError={(e) => {\r\n          e.currentTarget.src = DEFAULT_BANNER_IMAGE;\r\n        }}\r\n      />\r\n    </div>\r\n  </div>\r\n));\r\nBannerItem.displayName = 'BannerItem';\r\n\r\n\r\nexport default function BannerClientComponent({ initialBanners }) {\r\n  const [currentImage, setCurrentImage] = useState(0);\r\n  const [banners, setBanners] = useState(initialBanners);\r\n  const [isScrolling, setIsScrolling] = useState(false);\r\n  const router = useRouter();\r\n\r\n  // Scroll handler\r\n  const handleScroll = useCallback(\r\n    (e) => {\r\n      if (isScrolling || banners.length < 2) return;\r\n      \r\n      e.preventDefault();\r\n      \r\n      const delta = Math.sign(e.deltaY);\r\n      const newIdx = currentImage + delta;\r\n\r\n      if (newIdx < 0 || newIdx >= banners.length) {\r\n        return;\r\n      }\r\n      \r\n      setIsScrolling(true);\r\n      setCurrentImage(newIdx);\r\n\r\n      const winH = window.innerHeight;\r\n      const start = window.scrollY;\r\n      const end = newIdx * winH;\r\n      const startTime = performance.now();\r\n\r\n      function animateScroll(now) {\r\n        const elapsed = now - startTime;\r\n        const progress = Math.min(elapsed / SCROLL_ANIMATION_DURATION, 1);\r\n        window.scrollTo(0, start + (end - start) * easeInOutCubic(progress));\r\n        if (progress < 1) {\r\n          requestAnimationFrame(animateScroll);\r\n        } else {\r\n          // A short delay to prevent immediate re-triggering\r\n          setTimeout(() => setIsScrolling(false), 100); \r\n        }\r\n      }\r\n      requestAnimationFrame(animateScroll);\r\n    },\r\n    [banners.length, currentImage, isScrolling]\r\n  );\r\n  \r\n  // Attach scroll listener\r\n  useEffect(() => {\r\n    // Set scroll to top on mount\r\n    window.scrollTo(0, 0);\r\n\r\n    const debouncedScroll = (e) => {\r\n        // Simple debounce, main logic is in handleScroll\r\n        if (!isScrolling) {\r\n            handleScroll(e);\r\n        }\r\n    };\r\n\r\n    window.addEventListener(\"wheel\", debouncedScroll, { passive: false });\r\n    return () => window.removeEventListener(\"wheel\", debouncedScroll);\r\n  }, [handleScroll, isScrolling]);\r\n\r\n\r\n  // Memoize banner items to prevent unnecessary re-renders\r\n  const bannerItems = useMemo(() => {\r\n    return banners.map((banner, idx) => (\r\n      <BannerItem\r\n        key={banner._id || idx}\r\n        banner={banner}\r\n        idx={idx}\r\n      />\r\n    ));\r\n  }, [banners]);\r\n  \r\n  if (!banners || banners.length === 0) {\r\n    return (\r\n       <div className=\"relative w-full h-screen flex items-center justify-center m-0 p-0 overflow-hidden bg-black\">\r\n          <div className=\"text-white text-center\">\r\n              <h2 className=\"text-2xl font-bold mb-4\">Welcome to AISH</h2>\r\n              <p>No active banners at the moment. Please check back later.</p>\r\n          </div>\r\n       </div>\r\n    );\r\n  }\r\n\r\n  return (\r\n    <div className=\"relative w-full bg-black overflow-hidden\">\r\n        <div className=\"flex flex-col\" style={{ height: `${banners.length * 100}vh` }}>\r\n            <div className=\"sticky top-0 h-screen\">\r\n                 {bannerItems[currentImage]}\r\n            </div>\r\n        </div>\r\n\r\n      {/* SHOP NOW text */}\r\n      <motion.div\r\n        initial={{ opacity: 0, y: 20 }}\r\n        animate={{ opacity: 1, y: 0 }}\r\n        whileHover={{ scale: 1.05 }}\r\n        className=\"fixed top-24 left-8 z-20\"\r\n      >\r\n        <button\r\n          onClick={() => router.push(\"/products\")}\r\n          className=\"bg-white text-black px-4 py-1.5 md:px-6 md:py-2 text-xs md:text-sm font-semibold hover:bg-black hover:text-white transition-all duration-300\"\r\n        >\r\n          SHOP NOW\r\n        </button>\r\n      </motion.div>\r\n    </div>\r\n  );\r\n} "
        }
    ]
}