{
    "sourceFile": ".next/build/chunks/node_modules_b5d1def4._.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891704227,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "module.exports = {\n\n\"[project]/node_modules/picocolors/picocolors.js [postcss] (ecmascript)\": (function(__turbopack_context__) {\n\nvar { g: global, __dirname, m: module, e: exports } = __turbopack_context__;\n{\nlet p = process || {}, argv = p.argv || [], env = p.env || {};\nlet isColorSupported = !(!!env.NO_COLOR || argv.includes(\"--no-color\")) && (!!env.FORCE_COLOR || argv.includes(\"--color\") || p.platform === \"win32\" || (p.stdout || {}).isTTY && env.TERM !== \"dumb\" || !!env.CI);\nlet formatter = (open, close, replace = open)=>(input)=>{\n        let string = \"\" + input, index = string.indexOf(close, open.length);\n        return ~index ? open + replaceClose(string, close, replace, index) + close : open + string + close;\n    };\nlet replaceClose = (string, close, replace, index)=>{\n    let result = \"\", cursor = 0;\n    do {\n        result += string.substring(cursor, index) + replace;\n        cursor = index + close.length;\n        index = string.indexOf(close, cursor);\n    }while (~index)\n    return result + string.substring(cursor);\n};\nlet createColors = (enabled = isColorSupported)=>{\n    let f = enabled ? formatter : ()=>String;\n    return {\n        isColorSupported: enabled,\n        reset: f(\"\\x1b[0m\", \"\\x1b[0m\"),\n        bold: f(\"\\x1b[1m\", \"\\x1b[22m\", \"\\x1b[22m\\x1b[1m\"),\n        dim: f(\"\\x1b[2m\", \"\\x1b[22m\", \"\\x1b[22m\\x1b[2m\"),\n        italic: f(\"\\x1b[3m\", \"\\x1b[23m\"),\n        underline: f(\"\\x1b[4m\", \"\\x1b[24m\"),\n        inverse: f(\"\\x1b[7m\", \"\\x1b[27m\"),\n        hidden: f(\"\\x1b[8m\", \"\\x1b[28m\"),\n        strikethrough: f(\"\\x1b[9m\", \"\\x1b[29m\"),\n        black: f(\"\\x1b[30m\", \"\\x1b[39m\"),\n        red: f(\"\\x1b[31m\", \"\\x1b[39m\"),\n        green: f(\"\\x1b[32m\", \"\\x1b[39m\"),\n        yellow: f(\"\\x1b[33m\", \"\\x1b[39m\"),\n        blue: f(\"\\x1b[34m\", \"\\x1b[39m\"),\n        magenta: f(\"\\x1b[35m\", \"\\x1b[39m\"),\n        cyan: f(\"\\x1b[36m\", \"\\x1b[39m\"),\n        white: f(\"\\x1b[37m\", \"\\x1b[39m\"),\n        gray: f(\"\\x1b[90m\", \"\\x1b[39m\"),\n        bgBlack: f(\"\\x1b[40m\", \"\\x1b[49m\"),\n        bgRed: f(\"\\x1b[41m\", \"\\x1b[49m\"),\n        bgGreen: f(\"\\x1b[42m\", \"\\x1b[49m\"),\n        bgYellow: f(\"\\x1b[43m\", \"\\x1b[49m\"),\n        bgBlue: f(\"\\x1b[44m\", \"\\x1b[49m\"),\n        bgMagenta: f(\"\\x1b[45m\", \"\\x1b[49m\"),\n        bgCyan: f(\"\\x1b[46m\", \"\\x1b[49m\"),\n        bgWhite: f(\"\\x1b[47m\", \"\\x1b[49m\"),\n        blackBright: f(\"\\x1b[90m\", \"\\x1b[39m\"),\n        redBright: f(\"\\x1b[91m\", \"\\x1b[39m\"),\n        greenBright: f(\"\\x1b[92m\", \"\\x1b[39m\"),\n        yellowBright: f(\"\\x1b[93m\", \"\\x1b[39m\"),\n        blueBright: f(\"\\x1b[94m\", \"\\x1b[39m\"),\n        magentaBright: f(\"\\x1b[95m\", \"\\x1b[39m\"),\n        cyanBright: f(\"\\x1b[96m\", \"\\x1b[39m\"),\n        whiteBright: f(\"\\x1b[97m\", \"\\x1b[39m\"),\n        bgBlackBright: f(\"\\x1b[100m\", \"\\x1b[49m\"),\n        bgRedBright: f(\"\\x1b[101m\", \"\\x1b[49m\"),\n        bgGreenBright: f(\"\\x1b[102m\", \"\\x1b[49m\"),\n        bgYellowBright: f(\"\\x1b[103m\", \"\\x1b[49m\"),\n        bgBlueBright: f(\"\\x1b[104m\", \"\\x1b[49m\"),\n        bgMagentaBright: f(\"\\x1b[105m\", \"\\x1b[49m\"),\n        bgCyanBright: f(\"\\x1b[106m\", \"\\x1b[49m\"),\n        bgWhiteBright: f(\"\\x1b[107m\", \"\\x1b[49m\")\n    };\n};\nmodule.exports = createColors();\nmodule.exports.createColors = createColors;\n}}),\n\"[project]/node_modules/postcss/lib/tokenize.js [postcss] (ecmascript)\": (function(__turbopack_context__) {\n\nvar { g: global, __dirname, m: module, e: exports } = __turbopack_context__;\n{\n'use strict';\nconst SINGLE_QUOTE = \"'\".charCodeAt(0);\nconst DOUBLE_QUOTE = '\"'.charCodeAt(0);\nconst BACKSLASH = '\\\\'.charCodeAt(0);\nconst SLASH = '/'.charCodeAt(0);\nconst NEWLINE = '\\n'.charCodeAt(0);\nconst SPACE = ' '.charCodeAt(0);\nconst FEED = '\\f'.charCodeAt(0);\nconst TAB = '\\t'.charCodeAt(0);\nconst CR = '\\r'.charCodeAt(0);\nconst OPEN_SQUARE = '['.charCodeAt(0);\nconst CLOSE_SQUARE = ']'.charCodeAt(0);\nconst OPEN_PARENTHESES = '('.charCodeAt(0);\nconst CLOSE_PARENTHESES = ')'.charCodeAt(0);\nconst OPEN_CURLY = '{'.charCodeAt(0);\nconst CLOSE_CURLY = '}'.charCodeAt(0);\nconst SEMICOLON = ';'.charCodeAt(0);\nconst ASTERISK = '*'.charCodeAt(0);\nconst COLON = ':'.charCodeAt(0);\nconst AT = '@'.charCodeAt(0);\nconst RE_AT_END = /[\\t\\n\\f\\r \"#'()/;[\\\\\\]{}]/g;\nconst RE_WORD_END = /[\\t\\n\\f\\r !\"#'():;@[\\\\\\]{}]|\\/(?=\\*)/g;\nconst RE_BAD_BRACKET = /.[\\r\\n\"'(/\\\\]/;\nconst RE_HEX_ESCAPE = /[\\da-f]/i;\nmodule.exports = function tokenizer(input, options = {}) {\n    let css = input.css.valueOf();\n    let ignore = options.ignoreErrors;\n    let code, content, escape, next, quote;\n    let currentToken, escaped, escapePos, n, prev;\n    let length = css.length;\n    let pos = 0;\n    let buffer = [];\n    let returned = [];\n    function position() {\n        return pos;\n    }\n    function unclosed(what) {\n        throw input.error('Unclosed ' + what, pos);\n    }\n    function endOfFile() {\n        return returned.length === 0 && pos >= length;\n    }\n    function nextToken(opts) {\n        if (returned.length) return returned.pop();\n        if (pos >= length) return;\n        let ignoreUnclosed = opts ? opts.ignoreUnclosed : false;\n        code = css.charCodeAt(pos);\n        switch(code){\n            case NEWLINE:\n            case SPACE:\n            case TAB:\n            case CR:\n            case FEED:\n                {\n                    next = pos;\n                    do {\n                        next += 1;\n                        code = css.charCodeAt(next);\n                    }while (code === SPACE || code === NEWLINE || code === TAB || code === CR || code === FEED)\n                    currentToken = [\n                        'space',\n                        css.slice(pos, next)\n                    ];\n                    pos = next - 1;\n                    break;\n                }\n            case OPEN_SQUARE:\n            case CLOSE_SQUARE:\n            case OPEN_CURLY:\n            case CLOSE_CURLY:\n            case COLON:\n            case SEMICOLON:\n            case CLOSE_PARENTHESES:\n                {\n                    let controlChar = String.fromCharCode(code);\n                    currentToken = [\n                        controlChar,\n                        controlChar,\n                        pos\n                    ];\n                    break;\n                }\n            case OPEN_PARENTHESES:\n                {\n                    prev = buffer.length ? buffer.pop()[1] : '';\n                    n = css.charCodeAt(pos + 1);\n                    if (prev === 'url' && n !== SINGLE_QUOTE && n !== DOUBLE_QUOTE && n !== SPACE && n !== NEWLINE && n !== TAB && n !== FEED && n !== CR) {\n                        next = pos;\n                        do {\n                            escaped = false;\n                            next = css.indexOf(')', next + 1);\n                            if (next === -1) {\n                                if (ignore || ignoreUnclosed) {\n                                    next = pos;\n                                    break;\n                                } else {\n                                    unclosed('bracket');\n                                }\n                            }\n                            escapePos = next;\n                            while(css.charCodeAt(escapePos - 1) === BACKSLASH){\n                                escapePos -= 1;\n                                escaped = !escaped;\n                            }\n                        }while (escaped)\n                        currentToken = [\n                            'brackets',\n                            css.slice(pos, next + 1),\n                            pos,\n                            next\n                        ];\n                        pos = next;\n                    } else {\n                        next = css.indexOf(')', pos + 1);\n                        content = css.slice(pos, next + 1);\n                        if (next === -1 || RE_BAD_BRACKET.test(content)) {\n                            currentToken = [\n                                '(',\n                                '(',\n                                pos\n                            ];\n                        } else {\n                            currentToken = [\n                                'brackets',\n                                content,\n                                pos,\n                                next\n                            ];\n                            pos = next;\n                        }\n                    }\n                    break;\n                }\n            case SINGLE_QUOTE:\n            case DOUBLE_QUOTE:\n                {\n                    quote = code === SINGLE_QUOTE ? \"'\" : '\"';\n                    next = pos;\n                    do {\n                        escaped = false;\n                        next = css.indexOf(quote, next + 1);\n                        if (next === -1) {\n                            if (ignore || ignoreUnclosed) {\n                                next = pos + 1;\n                                break;\n                            } else {\n                                unclosed('string');\n                            }\n                        }\n                        escapePos = next;\n                        while(css.charCodeAt(escapePos - 1) === BACKSLASH){\n                            escapePos -= 1;\n                            escaped = !escaped;\n                        }\n                    }while (escaped)\n                    currentToken = [\n                        'string',\n                        css.slice(pos, next + 1),\n                        pos,\n                        next\n                    ];\n                    pos = next;\n                    break;\n                }\n            case AT:\n                {\n                    RE_AT_END.lastIndex = pos + 1;\n                    RE_AT_END.test(css);\n                    if (RE_AT_END.lastIndex === 0) {\n                        next = css.length - 1;\n                    } else {\n                        next = RE_AT_END.lastIndex - 2;\n                    }\n                    currentToken = [\n                        'at-word',\n                        css.slice(pos, next + 1),\n                        pos,\n                        next\n                    ];\n                    pos = next;\n                    break;\n                }\n            case BACKSLASH:\n                {\n                    next = pos;\n                    escape = true;\n                    while(css.charCodeAt(next + 1) === BACKSLASH){\n                        next += 1;\n                        escape = !escape;\n                    }\n                    code = css.charCodeAt(next + 1);\n                    if (escape && code !== SLASH && code !== SPACE && code !== NEWLINE && code !== TAB && code !== CR && code !== FEED) {\n                        next += 1;\n                        if (RE_HEX_ESCAPE.test(css.charAt(next))) {\n                            while(RE_HEX_ESCAPE.test(css.charAt(next + 1))){\n                                next += 1;\n                            }\n                            if (css.charCodeAt(next + 1) === SPACE) {\n                                next += 1;\n                            }\n                        }\n                    }\n                    currentToken = [\n                        'word',\n                        css.slice(pos, next + 1),\n                        pos,\n                        next\n                    ];\n                    pos = next;\n                    break;\n                }\n            default:\n                {\n                    if (code === SLASH && css.charCodeAt(pos + 1) === ASTERISK) {\n                        next = css.indexOf('*/', pos + 2) + 1;\n                        if (next === 0) {\n                            if (ignore || ignoreUnclosed) {\n                                next = css.length;\n                            } else {\n                                unclosed('comment');\n                            }\n                        }\n                        currentToken = [\n                            'comment',\n                            css.slice(pos, next + 1),\n                            pos,\n                            next\n                        ];\n                        pos = next;\n                    } else {\n                        RE_WORD_END.lastIndex = pos + 1;\n                        RE_WORD_END.test(css);\n                        if (RE_WORD_END.lastIndex === 0) {\n                            next = css.length - 1;\n                        } else {\n                            next = RE_WORD_END.lastIndex - 2;\n                        }\n                        currentToken = [\n                            'word',\n                            css.slice(pos, next + 1),\n                            pos,\n                            next\n                        ];\n                        buffer.push(currentToken);\n                        pos = next;\n                    }\n                    break;\n                }\n        }\n        pos++;\n        return currentToken;\n    }\n    function back(token) {\n        returned.push(token);\n    }\n    return {\n        back,\n        endOfFile,\n        nextToken,\n        position\n    };\n};\n}}),\n\"[project]/node_modules/postcss/lib/terminal-highlight.js [postcss] (ecmascript)\": (function(__turbopack_context__) {\n\nvar { g: global, __dirname, m: module, e: exports } = __turbopack_context__;\n{\n'use strict';\nlet pico = __turbopack_context__.r(\"[project]/node_modules/picocolors/picocolors.js [postcss] (ecmascript)\");\nlet tokenizer = __turbopack_context__.r(\"[project]/node_modules/postcss/lib/tokenize.js [postcss] (ecmascript)\");\nlet Input;\nfunction registerInput(dependant) {\n    Input = dependant;\n}\nconst HIGHLIGHT_THEME = {\n    ';': pico.yellow,\n    ':': pico.yellow,\n    '(': pico.cyan,\n    ')': pico.cyan,\n    '[': pico.yellow,\n    ']': pico.yellow,\n    '{': pico.yellow,\n    '}': pico.yellow,\n    'at-word': pico.cyan,\n    'brackets': pico.cyan,\n    'call': pico.cyan,\n    'class': pico.yellow,\n    'comment': pico.gray,\n    'hash': pico.magenta,\n    'string': pico.green\n};\nfunction getTokenType([type, value], processor) {\n    if (type === 'word') {\n        if (value[0] === '.') {\n            return 'class';\n        }\n        if (value[0] === '#') {\n            return 'hash';\n        }\n    }\n    if (!processor.endOfFile()) {\n        let next = processor.nextToken();\n        processor.back(next);\n        if (next[0] === 'brackets' || next[0] === '(') return 'call';\n    }\n    return type;\n}\nfunction terminalHighlight(css) {\n    let processor = tokenizer(new Input(css), {\n        ignoreErrors: true\n    });\n    let result = '';\n    while(!processor.endOfFile()){\n        let token = processor.nextToken();\n        let color = HIGHLIGHT_THEME[getTokenType(token, processor)];\n        if (color) {\n            result += token[1].split(/\\r?\\n/).map((i)=>color(i)).join('\\n');\n        } else {\n            result += token[1];\n        }\n    }\n    return result;\n}\nterminalHighlight.registerInput = registerInput;\nmodule.exports = terminalHighlight;\n}}),\n\"[project]/node_modules/postcss/lib/css-syntax-error.js [postcss] (ecmascript)\": (function(__turbopack_context__) {\n\nvar { g: global, __dirname, m: module, e: exports } = __turbopack_context__;\n{\n'use strict';\nlet pico = __turbopack_context__.r(\"[project]/node_modules/picocolors/picocolors.js [postcss] (ecmascript)\");\nlet terminalHighlight = __turbopack_context__.r(\"[project]/node_modules/postcss/lib/terminal-highlight.js [postcss] (ecmascript)\");\nclass CssSyntaxError extends Error {\n    constructor(message, line, column, source, file, plugin){\n        super(message);\n        this.name = 'CssSyntaxError';\n        this.reason = message;\n        if (file) {\n            this.file = file;\n        }\n        if (source) {\n            this.source = source;\n        }\n        if (plugin) {\n            this.plugin = plugin;\n        }\n        if (typeof line !== 'undefined' && typeof column !== 'undefined') {\n            if (typeof line === 'number') {\n                this.line = line;\n                this.column = column;\n            } else {\n                this.line = line.line;\n                this.column = line.column;\n                this.endLine = column.line;\n                this.endColumn = column.column;\n            }\n        }\n        this.setMessage();\n        if (Error.captureStackTrace) {\n            Error.captureStackTrace(this, CssSyntaxError);\n        }\n    }\n    setMessage() {\n        this.message = this.plugin ? this.plugin + ': ' : '';\n        this.message += this.file ? this.file : '<css input>';\n        if (typeof this.line !== 'undefined') {\n            this.message += ':' + this.line + ':' + this.column;\n        }\n        this.message += ': ' + this.reason;\n    }\n    showSourceCode(color) {\n        if (!this.source) return '';\n        let css = this.source;\n        if (color == null) color = pico.isColorSupported;\n        let aside = (text)=>text;\n        let mark = (text)=>text;\n        let highlight = (text)=>text;\n        if (color) {\n            let { bold, gray, red } = pico.createColors(true);\n            mark = (text)=>bold(red(text));\n            aside = (text)=>gray(text);\n            if (terminalHighlight) {\n                highlight = (text)=>terminalHighlight(text);\n            }\n        }\n        let lines = css.split(/\\r?\\n/);\n        let start = Math.max(this.line - 3, 0);\n        let end = Math.min(this.line + 2, lines.length);\n        let maxWidth = String(end).length;\n        return lines.slice(start, end).map((line, index)=>{\n            let number = start + 1 + index;\n            let gutter = ' ' + (' ' + number).slice(-maxWidth) + ' | ';\n            if (number === this.line) {\n                if (line.length > 160) {\n                    let padding = 20;\n                    let subLineStart = Math.max(0, this.column - padding);\n                    let subLineEnd = Math.max(this.column + padding, this.endColumn + padding);\n                    let subLine = line.slice(subLineStart, subLineEnd);\n                    let spacing = aside(gutter.replace(/\\d/g, ' ')) + line.slice(0, Math.min(this.column - 1, padding - 1)).replace(/[^\\t]/g, ' ');\n                    return mark('>') + aside(gutter) + highlight(subLine) + '\\n ' + spacing + mark('^');\n                }\n                let spacing = aside(gutter.replace(/\\d/g, ' ')) + line.slice(0, this.column - 1).replace(/[^\\t]/g, ' ');\n                return mark('>') + aside(gutter) + highlight(line) + '\\n ' + spacing + mark('^');\n            }\n            return ' ' + aside(gutter) + highlight(line);\n        }).join('\\n');\n    }\n    toString() {\n        let code = this.showSourceCode();\n        if (code) {\n            code = '\\n\\n' + code + '\\n';\n        }\n        return this.name + ': ' + this.message + code;\n    }\n}\nmodule.exports = CssSyntaxError;\nCssSyntaxError.default = CssSyntaxError;\n}}),\n\"[project]/node_modules/postcss/lib/stringifier.js [postcss] (ecmascript)\": (function(__turbopack_context__) {\n\nvar { g: global, __dirname, m: module, e: exports } = __turbopack_context__;\n{\n'use strict';\nconst DEFAULT_RAW = {\n    after: '\\n',\n    beforeClose: '\\n',\n    beforeComment: '\\n',\n    beforeDecl: '\\n',\n    beforeOpen: ' ',\n    beforeRule: '\\n',\n    colon: ': ',\n    commentLeft: ' ',\n    commentRight: ' ',\n    emptyBody: '',\n    indent: '    ',\n    semicolon: false\n};\nfunction capitalize(str) {\n    return str[0].toUpperCase() + str.slice(1);\n}\nclass Stringifier {\n    constructor(builder){\n        this.builder = builder;\n    }\n    atrule(node, semicolon) {\n        let name = '@' + node.name;\n        let params = node.params ? this.rawValue(node, 'params') : '';\n        if (typeof node.raws.afterName !== 'undefined') {\n            name += node.raws.afterName;\n        } else if (params) {\n            name += ' ';\n        }\n        if (node.nodes) {\n            this.block(node, name + params);\n        } else {\n            let end = (node.raws.between || '') + (semicolon ? ';' : '');\n            this.builder(name + params + end, node);\n        }\n    }\n    beforeAfter(node, detect) {\n        let value;\n        if (node.type === 'decl') {\n            value = this.raw(node, null, 'beforeDecl');\n        } else if (node.type === 'comment') {\n            value = this.raw(node, null, 'beforeComment');\n        } else if (detect === 'before') {\n            value = this.raw(node, null, 'beforeRule');\n        } else {\n            value = this.raw(node, null, 'beforeClose');\n        }\n        let buf = node.parent;\n        let depth = 0;\n        while(buf && buf.type !== 'root'){\n            depth += 1;\n            buf = buf.parent;\n        }\n        if (value.includes('\\n')) {\n            let indent = this.raw(node, null, 'indent');\n            if (indent.length) {\n                for(let step = 0; step < depth; step++)value += indent;\n            }\n        }\n        return value;\n    }\n    block(node, start) {\n        let between = this.raw(node, 'between', 'beforeOpen');\n        this.builder(start + between + '{', node, 'start');\n        let after;\n        if (node.nodes && node.nodes.length) {\n            this.body(node);\n            after = this.raw(node, 'after');\n        } else {\n            after = this.raw(node, 'after', 'emptyBody');\n        }\n        if (after) this.builder(after);\n        this.builder('}', node, 'end');\n    }\n    body(node) {\n        let last = node.nodes.length - 1;\n        while(last > 0){\n            if (node.nodes[last].type !== 'comment') break;\n            last -= 1;\n        }\n        let semicolon = this.raw(node, 'semicolon');\n        for(let i = 0; i < node.nodes.length; i++){\n            let child = node.nodes[i];\n            let before = this.raw(child, 'before');\n            if (before) this.builder(before);\n            this.stringify(child, last !== i || semicolon);\n        }\n    }\n    comment(node) {\n        let left = this.raw(node, 'left', 'commentLeft');\n        let right = this.raw(node, 'right', 'commentRight');\n        this.builder('/*' + left + node.text + right + '*/', node);\n    }\n    decl(node, semicolon) {\n        let between = this.raw(node, 'between', 'colon');\n        let string = node.prop + between + this.rawValue(node, 'value');\n        if (node.important) {\n            string += node.raws.important || ' !important';\n        }\n        if (semicolon) string += ';';\n        this.builder(string, node);\n    }\n    document(node) {\n        this.body(node);\n    }\n    raw(node, own, detect) {\n        let value;\n        if (!detect) detect = own;\n        // Already had\n        if (own) {\n            value = node.raws[own];\n            if (typeof value !== 'undefined') return value;\n        }\n        let parent = node.parent;\n        if (detect === 'before') {\n            // Hack for first rule in CSS\n            if (!parent || parent.type === 'root' && parent.first === node) {\n                return '';\n            }\n            // `root` nodes in `document` should use only their own raws\n            if (parent && parent.type === 'document') {\n                return '';\n            }\n        }\n        // Floating child without parent\n        if (!parent) return DEFAULT_RAW[detect];\n        // Detect style by other nodes\n        let root = node.root();\n        if (!root.rawCache) root.rawCache = {};\n        if (typeof root.rawCache[detect] !== 'undefined') {\n            return root.rawCache[detect];\n        }\n        if (detect === 'before' || detect === 'after') {\n            return this.beforeAfter(node, detect);\n        } else {\n            let method = 'raw' + capitalize(detect);\n            if (this[method]) {\n                value = this[method](root, node);\n            } else {\n                root.walk((i)=>{\n                    value = i.raws[own];\n                    if (typeof value !== 'undefined') return false;\n                });\n            }\n        }\n        if (typeof value === 'undefined') value = DEFAULT_RAW[detect];\n        root.rawCache[detect] = value;\n        return value;\n    }\n    rawBeforeClose(root) {\n        let value;\n        root.walk((i)=>{\n            if (i.nodes && i.nodes.length > 0) {\n                if (typeof i.raws.after !== 'undefined') {\n                    value = i.raws.after;\n                    if (value.includes('\\n')) {\n                        value = value.replace(/[^\\n]+$/, '');\n                    }\n                    return false;\n                }\n            }\n        });\n        if (value) value = value.replace(/\\S/g, '');\n        return value;\n    }\n    rawBeforeComment(root, node) {\n        let value;\n        root.walkComments((i)=>{\n            if (typeof i.raws.before !== 'undefined') {\n                value = i.raws.before;\n                if (value.includes('\\n')) {\n                    value = value.replace(/[^\\n]+$/, '');\n                }\n                return false;\n            }\n        });\n        if (typeof value === 'undefined') {\n            value = this.raw(node, null, 'beforeDecl');\n        } else if (value) {\n            value = value.replace(/\\S/g, '');\n        }\n        return value;\n    }\n    rawBeforeDecl(root, node) {\n        let value;\n        root.walkDecls((i)=>{\n            if (typeof i.raws.before !== 'undefined') {\n                value = i.raws.before;\n                if (value.includes('\\n')) {\n                    value = value.replace(/[^\\n]+$/, '');\n                }\n                return false;\n            }\n        });\n        if (typeof value === 'undefined') {\n            value = this.raw(node, null, 'beforeRule');\n        } else if (value) {\n            value = value.replace(/\\S/g, '');\n        }\n        return value;\n    }\n    rawBeforeOpen(root) {\n        let value;\n        root.walk((i)=>{\n            if (i.type !== 'decl') {\n                value = i.raws.between;\n                if (typeof value !== 'undefined') return false;\n            }\n        });\n        return value;\n    }\n    rawBeforeRule(root) {\n        let value;\n        root.walk((i)=>{\n            if (i.nodes && (i.parent !== root || root.first !== i)) {\n                if (typeof i.raws.before !== 'undefined') {\n                    value = i.raws.before;\n                    if (value.includes('\\n')) {\n                        value = value.replace(/[^\\n]+$/, '');\n                    }\n                    return false;\n                }\n            }\n        });\n        if (value) value = value.replace(/\\S/g, '');\n        return value;\n    }\n    rawColon(root) {\n        let value;\n        root.walkDecls((i)=>{\n            if (typeof i.raws.between !== 'undefined') {\n                value = i.raws.between.replace(/[^\\s:]/g, '');\n                return false;\n            }\n        });\n        return value;\n    }\n    rawEmptyBody(root) {\n        let value;\n        root.walk((i)=>{\n            if (i.nodes && i.nodes.length === 0) {\n                value = i.raws.after;\n                if (typeof value !== 'undefined') return false;\n            }\n        });\n        return value;\n    }\n    rawIndent(root) {\n        if (root.raws.indent) return root.raws.indent;\n        let value;\n        root.walk((i)=>{\n            let p = i.parent;\n            if (p && p !== root && p.parent && p.parent === root) {\n                if (typeof i.raws.before !== 'undefined') {\n                    let parts = i.raws.before.split('\\n');\n                    value = parts[parts.length - 1];\n                    value = value.replace(/\\S/g, '');\n                    return false;\n                }\n            }\n        });\n        return value;\n    }\n    rawSemicolon(root) {\n        let value;\n        root.walk((i)=>{\n            if (i.nodes && i.nodes.length && i.last.type === 'decl') {\n                value = i.raws.semicolon;\n                if (typeof value !== 'undefined') return false;\n            }\n        });\n        return value;\n    }\n    rawValue(node, prop) {\n        let value = node[prop];\n        let raw = node.raws[prop];\n        if (raw && raw.value === value) {\n            return raw.raw;\n        }\n        return value;\n    }\n    root(node) {\n        this.body(node);\n        if (node.raws.after) this.builder(node.raws.after);\n    }\n    rule(node) {\n        this.block(node, this.rawValue(node, 'selector'));\n        if (node.raws.ownSemicolon) {\n            this.builder(node.raws.ownSemicolon, node, 'end');\n        }\n    }\n    stringify(node, semicolon) {\n        /* c8 ignore start */ if (!this[node.type]) {\n            throw new Error('Unknown AST node type ' + node.type + '. ' + 'Maybe you need to change PostCSS stringifier.');\n        }\n        /* c8 ignore stop */ this[node.type](node, semicolon);\n    }\n}\nmodule.exports = Stringifier;\nStringifier.default = Stringifier;\n}}),\n\"[project]/node_modules/postcss/lib/stringify.js [postcss] (ecmascript)\": (function(__turbopack_context__) {\n\nvar { g: global, __dirname, m: module, e: exports } = __turbopack_context__;\n{\n'use strict';\nlet Stringifier = __turbopack_context__.r(\"[project]/node_modules/postcss/lib/stringifier.js [postcss] (ecmascript)\");\nfunction stringify(node, builder) {\n    let str = new Stringifier(builder);\n    str.stringify(node);\n}\nmodule.exports = stringify;\nstringify.default = stringify;\n}}),\n\"[project]/node_modules/postcss/lib/symbols.js [postcss] (ecmascript)\": (function(__turbopack_context__) {\n\nvar { g: global, __dirname, m: module, e: exports } = __turbopack_context__;\n{\n'use strict';\nmodule.exports.isClean = Symbol('isClean');\nmodule.exports.my = Symbol('my');\n}}),\n\"[project]/node_modules/postcss/lib/node.js [postcss] (ecmascript)\": (function(__turbopack_context__) {\n\nvar { g: global, __dirname, m: module, e: exports } = __turbopack_context__;\n{\n'use strict';\nlet CssSyntaxError = __turbopack_context__.r(\"[project]/node_modules/postcss/lib/css-syntax-error.js [postcss] (ecmascript)\");\nlet Stringifier = __turbopack_context__.r(\"[project]/node_modules/postcss/lib/stringifier.js [postcss] (ecmascript)\");\nlet stringify = __turbopack_context__.r(\"[project]/node_modules/postcss/lib/stringify.js [postcss] (ecmascript)\");\nlet { isClean, my } = __turbopack_context__.r(\"[project]/node_modules/postcss/lib/symbols.js [postcss] (ecmascript)\");\nfunction cloneNode(obj, parent) {\n    let cloned = new obj.constructor();\n    for(let i in obj){\n        if (!Object.prototype.hasOwnProperty.call(obj, i)) {\n            continue;\n        }\n        if (i === 'proxyCache') continue;\n        let value = obj[i];\n        let type = typeof value;\n        if (i === 'parent' && type === 'object') {\n            if (parent) cloned[i] = parent;\n        } else if (i === 'source') {\n            cloned[i] = value;\n        } else if (Array.isArray(value)) {\n            cloned[i] = value.map((j)=>cloneNode(j, cloned));\n        } else {\n            if (type === 'object' && value !== null) value = cloneNode(value);\n            cloned[i] = value;\n        }\n    }\n    return cloned;\n}\nfunction sourceOffset(inputCSS, position) {\n    // Not all custom syntaxes support `offset` in `source.start` and `source.end`\n    if (position && typeof position.offset !== 'undefined') {\n        return position.offset;\n    }\n    let column = 1;\n    let line = 1;\n    let offset = 0;\n    for(let i = 0; i < inputCSS.length; i++){\n        if (line === position.line && column === position.column) {\n            offset = i;\n            break;\n        }\n        if (inputCSS[i] === '\\n') {\n            column = 1;\n            line += 1;\n        } else {\n            column += 1;\n        }\n    }\n    return offset;\n}\nclass Node {\n    get proxyOf() {\n        return this;\n    }\n    constructor(defaults = {}){\n        this.raws = {};\n        this[isClean] = false;\n        this[my] = true;\n        for(let name in defaults){\n            if (name === 'nodes') {\n                this.nodes = [];\n                for (let node of defaults[name]){\n                    if (typeof node.clone === 'function') {\n                        this.append(node.clone());\n                    } else {\n                        this.append(node);\n                    }\n                }\n            } else {\n                this[name] = defaults[name];\n            }\n        }\n    }\n    addToError(error) {\n        error.postcssNode = this;\n        if (error.stack && this.source && /\\n\\s{4}at /.test(error.stack)) {\n            let s = this.source;\n            error.stack = error.stack.replace(/\\n\\s{4}at /, `$&${s.input.from}:${s.start.line}:${s.start.column}$&`);\n        }\n        return error;\n    }\n    after(add) {\n        this.parent.insertAfter(this, add);\n        return this;\n    }\n    assign(overrides = {}) {\n        for(let name in overrides){\n            this[name] = overrides[name];\n        }\n        return this;\n    }\n    before(add) {\n        this.parent.insertBefore(this, add);\n        return this;\n    }\n    cleanRaws(keepBetween) {\n        delete this.raws.before;\n        delete this.raws.after;\n        if (!keepBetween) delete this.raws.between;\n    }\n    clone(overrides = {}) {\n        let cloned = cloneNode(this);\n        for(let name in overrides){\n            cloned[name] = overrides[name];\n        }\n        return cloned;\n    }\n    cloneAfter(overrides = {}) {\n        let cloned = this.clone(overrides);\n        this.parent.insertAfter(this, cloned);\n        return cloned;\n    }\n    cloneBefore(overrides = {}) {\n        let cloned = this.clone(overrides);\n        this.parent.insertBefore(this, cloned);\n        return cloned;\n    }\n    error(message, opts = {}) {\n        if (this.source) {\n            let { end, start } = this.rangeBy(opts);\n            return this.source.input.error(message, {\n                column: start.column,\n                line: start.line\n            }, {\n                column: end.column,\n                line: end.line\n            }, opts);\n        }\n        return new CssSyntaxError(message);\n    }\n    getProxyProcessor() {\n        return {\n            get (node, prop) {\n                if (prop === 'proxyOf') {\n                    return node;\n                } else if (prop === 'root') {\n                    return ()=>node.root().toProxy();\n                } else {\n                    return node[prop];\n                }\n            },\n            set (node, prop, value) {\n                if (node[prop] === value) return true;\n                node[prop] = value;\n                if (prop === 'prop' || prop === 'value' || prop === 'name' || prop === 'params' || prop === 'important' || /* c8 ignore next */ prop === 'text') {\n                    node.markDirty();\n                }\n                return true;\n            }\n        };\n    }\n    /* c8 ignore next 3 */ markClean() {\n        this[isClean] = true;\n    }\n    markDirty() {\n        if (this[isClean]) {\n            this[isClean] = false;\n            let next = this;\n            while(next = next.parent){\n                next[isClean] = false;\n            }\n        }\n    }\n    next() {\n        if (!this.parent) return undefined;\n        let index = this.parent.index(this);\n        return this.parent.nodes[index + 1];\n    }\n    positionBy(opts) {\n        let pos = this.source.start;\n        if (opts.index) {\n            pos = this.positionInside(opts.index);\n        } else if (opts.word) {\n            let inputString = 'document' in this.source.input ? this.source.input.document : this.source.input.css;\n            let stringRepresentation = inputString.slice(sourceOffset(inputString, this.source.start), sourceOffset(inputString, this.source.end));\n            let index = stringRepresentation.indexOf(opts.word);\n            if (index !== -1) pos = this.positionInside(index);\n        }\n        return pos;\n    }\n    positionInside(index) {\n        let column = this.source.start.column;\n        let line = this.source.start.line;\n        let inputString = 'document' in this.source.input ? this.source.input.document : this.source.input.css;\n        let offset = sourceOffset(inputString, this.source.start);\n        let end = offset + index;\n        for(let i = offset; i < end; i++){\n            if (inputString[i] === '\\n') {\n                column = 1;\n                line += 1;\n            } else {\n                column += 1;\n            }\n        }\n        return {\n            column,\n            line\n        };\n    }\n    prev() {\n        if (!this.parent) return undefined;\n        let index = this.parent.index(this);\n        return this.parent.nodes[index - 1];\n    }\n    rangeBy(opts) {\n        let start = {\n            column: this.source.start.column,\n            line: this.source.start.line\n        };\n        let end = this.source.end ? {\n            column: this.source.end.column + 1,\n            line: this.source.end.line\n        } : {\n            column: start.column + 1,\n            line: start.line\n        };\n        if (opts.word) {\n            let inputString = 'document' in this.source.input ? this.source.input.document : this.source.input.css;\n            let stringRepresentation = inputString.slice(sourceOffset(inputString, this.source.start), sourceOffset(inputString, this.source.end));\n            let index = stringRepresentation.indexOf(opts.word);\n            if (index !== -1) {\n                start = this.positionInside(index);\n                end = this.positionInside(index + opts.word.length);\n            }\n        } else {\n            if (opts.start) {\n                start = {\n                    column: opts.start.column,\n                    line: opts.start.line\n                };\n            } else if (opts.index) {\n                start = this.positionInside(opts.index);\n            }\n            if (opts.end) {\n                end = {\n                    column: opts.end.column,\n                    line: opts.end.line\n                };\n            } else if (typeof opts.endIndex === 'number') {\n                end = this.positionInside(opts.endIndex);\n            } else if (opts.index) {\n                end = this.positionInside(opts.index + 1);\n            }\n        }\n        if (end.line < start.line || end.line === start.line && end.column <= start.column) {\n            end = {\n                column: start.column + 1,\n                line: start.line\n            };\n        }\n        return {\n            end,\n            start\n        };\n    }\n    raw(prop, defaultType) {\n        let str = new Stringifier();\n        return str.raw(this, prop, defaultType);\n    }\n    remove() {\n        if (this.parent) {\n            this.parent.removeChild(this);\n        }\n        this.parent = undefined;\n        return this;\n    }\n    replaceWith(...nodes) {\n        if (this.parent) {\n            let bookmark = this;\n            let foundSelf = false;\n            for (let node of nodes){\n                if (node === this) {\n                    foundSelf = true;\n                } else if (foundSelf) {\n                    this.parent.insertAfter(bookmark, node);\n                    bookmark = node;\n                } else {\n                    this.parent.insertBefore(bookmark, node);\n                }\n            }\n            if (!foundSelf) {\n                this.remove();\n            }\n        }\n        return this;\n    }\n    root() {\n        let result = this;\n        while(result.parent && result.parent.type !== 'document'){\n            result = result.parent;\n        }\n        return result;\n    }\n    toJSON(_, inputs) {\n        let fixed = {};\n        let emitInputs = inputs == null;\n        inputs = inputs || new Map();\n        let inputsNextIndex = 0;\n        for(let name in this){\n            if (!Object.prototype.hasOwnProperty.call(this, name)) {\n                continue;\n            }\n            if (name === 'parent' || name === 'proxyCache') continue;\n            let value = this[name];\n            if (Array.isArray(value)) {\n                fixed[name] = value.map((i)=>{\n                    if (typeof i === 'object' && i.toJSON) {\n                        return i.toJSON(null, inputs);\n                    } else {\n                        return i;\n                    }\n                });\n            } else if (typeof value === 'object' && value.toJSON) {\n                fixed[name] = value.toJSON(null, inputs);\n            } else if (name === 'source') {\n                let inputId = inputs.get(value.input);\n                if (inputId == null) {\n                    inputId = inputsNextIndex;\n                    inputs.set(value.input, inputsNextIndex);\n                    inputsNextIndex++;\n                }\n                fixed[name] = {\n                    end: value.end,\n                    inputId,\n                    start: value.start\n                };\n            } else {\n                fixed[name] = value;\n            }\n        }\n        if (emitInputs) {\n            fixed.inputs = [\n                ...inputs.keys()\n            ].map((input)=>input.toJSON());\n        }\n        return fixed;\n    }\n    toProxy() {\n        if (!this.proxyCache) {\n            this.proxyCache = new Proxy(this, this.getProxyProcessor());\n        }\n        return this.proxyCache;\n    }\n    toString(stringifier = stringify) {\n        if (stringifier.stringify) stringifier = stringifier.stringify;\n        let result = '';\n        stringifier(this, (i)=>{\n            result += i;\n        });\n        return result;\n    }\n    warn(result, text, opts) {\n        let data = {\n            node: this\n        };\n        for(let i in opts)data[i] = opts[i];\n        return result.warn(text, data);\n    }\n}\nmodule.exports = Node;\nNode.default = Node;\n}}),\n\"[project]/node_modules/postcss/lib/comment.js [postcss] (ecmascript)\": (function(__turbopack_context__) {\n\nvar { g: global, __dirname, m: module, e: exports } = __turbopack_context__;\n{\n'use strict';\nlet Node = __turbopack_context__.r(\"[project]/node_modules/postcss/lib/node.js [postcss] (ecmascript)\");\nclass Comment extends Node {\n    constructor(defaults){\n        super(defaults);\n        this.type = 'comment';\n    }\n}\nmodule.exports = Comment;\nComment.default = Comment;\n}}),\n\"[project]/node_modules/postcss/lib/declaration.js [postcss] (ecmascript)\": (function(__turbopack_context__) {\n\nvar { g: global, __dirname, m: module, e: exports } = __turbopack_context__;\n{\n'use strict';\nlet Node = __turbopack_context__.r(\"[project]/node_modules/postcss/lib/node.js [postcss] (ecmascript)\");\nclass Declaration extends Node {\n    get variable() {\n        return this.prop.startsWith('--') || this.prop[0] === '$';\n    }\n    constructor(defaults){\n        if (defaults && typeof defaults.value !== 'undefined' && typeof defaults.value !== 'string') {\n            defaults = {\n                ...defaults,\n                value: String(defaults.value)\n            };\n        }\n        super(defaults);\n        this.type = 'decl';\n    }\n}\nmodule.exports = Declaration;\nDeclaration.default = Declaration;\n}}),\n\"[project]/node_modules/postcss/lib/container.js [postcss] (ecmascript)\": (function(__turbopack_context__) {\n\nvar { g: global, __dirname, m: module, e: exports } = __turbopack_context__;\n{\n'use strict';\nlet Comment = __turbopack_context__.r(\"[project]/node_modules/postcss/lib/comment.js [postcss] (ecmascript)\");\nlet Declaration = __turbopack_context__.r(\"[project]/node_modules/postcss/lib/declaration.js [postcss] (ecmascript)\");\nlet Node = __turbopack_context__.r(\"[project]/node_modules/postcss/lib/node.js [postcss] (ecmascript)\");\nlet { isClean, my } = __turbopack_context__.r(\"[project]/node_modules/postcss/lib/symbols.js [postcss] (ecmascript)\");\nlet AtRule, parse, Root, Rule;\nfunction cleanSource(nodes) {\n    return nodes.map((i)=>{\n        if (i.nodes) i.nodes = cleanSource(i.nodes);\n        delete i.source;\n        return i;\n    });\n}\nfunction markTreeDirty(node) {\n    node[isClean] = false;\n    if (node.proxyOf.nodes) {\n        for (let i of node.proxyOf.nodes){\n            markTreeDirty(i);\n        }\n    }\n}\nclass Container extends Node {\n    get first() {\n        if (!this.proxyOf.nodes) return undefined;\n        return this.proxyOf.nodes[0];\n    }\n    get last() {\n        if (!this.proxyOf.nodes) return undefined;\n        return this.proxyOf.nodes[this.proxyOf.nodes.length - 1];\n    }\n    append(...children) {\n        for (let child of children){\n            let nodes = this.normalize(child, this.last);\n            for (let node of nodes)this.proxyOf.nodes.push(node);\n        }\n        this.markDirty();\n        return this;\n    }\n    cleanRaws(keepBetween) {\n        super.cleanRaws(keepBetween);\n        if (this.nodes) {\n            for (let node of this.nodes)node.cleanRaws(keepBetween);\n        }\n    }\n    each(callback) {\n        if (!this.proxyOf.nodes) return undefined;\n        let iterator = this.getIterator();\n        let index, result;\n        while(this.indexes[iterator] < this.proxyOf.nodes.length){\n            index = this.indexes[iterator];\n            result = callback(this.proxyOf.nodes[index], index);\n            if (result === false) break;\n            this.indexes[iterator] += 1;\n        }\n        delete this.indexes[iterator];\n        return result;\n    }\n    every(condition) {\n        return this.nodes.every(condition);\n    }\n    getIterator() {\n        if (!this.lastEach) this.lastEach = 0;\n        if (!this.indexes) this.indexes = {};\n        this.lastEach += 1;\n        let iterator = this.lastEach;\n        this.indexes[iterator] = 0;\n        return iterator;\n    }\n    getProxyProcessor() {\n        return {\n            get (node, prop) {\n                if (prop === 'proxyOf') {\n                    return node;\n                } else if (!node[prop]) {\n                    return node[prop];\n                } else if (prop === 'each' || typeof prop === 'string' && prop.startsWith('walk')) {\n                    return (...args)=>{\n                        return node[prop](...args.map((i)=>{\n                            if (typeof i === 'function') {\n                                return (child, index)=>i(child.toProxy(), index);\n                            } else {\n                                return i;\n                            }\n                        }));\n                    };\n                } else if (prop === 'every' || prop === 'some') {\n                    return (cb)=>{\n                        return node[prop]((child, ...other)=>cb(child.toProxy(), ...other));\n                    };\n                } else if (prop === 'root') {\n                    return ()=>node.root().toProxy();\n                } else if (prop === 'nodes') {\n                    return node.nodes.map((i)=>i.toProxy());\n                } else if (prop === 'first' || prop === 'last') {\n                    return node[prop].toProxy();\n                } else {\n                    return node[prop];\n                }\n            },\n            set (node, prop, value) {\n                if (node[prop] === value) return true;\n                node[prop] = value;\n                if (prop === 'name' || prop === 'params' || prop === 'selector') {\n                    node.markDirty();\n                }\n                return true;\n            }\n        };\n    }\n    index(child) {\n        if (typeof child === 'number') return child;\n        if (child.proxyOf) child = child.proxyOf;\n        return this.proxyOf.nodes.indexOf(child);\n    }\n    insertAfter(exist, add) {\n        let existIndex = this.index(exist);\n        let nodes = this.normalize(add, this.proxyOf.nodes[existIndex]).reverse();\n        existIndex = this.index(exist);\n        for (let node of nodes)this.proxyOf.nodes.splice(existIndex + 1, 0, node);\n        let index;\n        for(let id in this.indexes){\n            index = this.indexes[id];\n            if (existIndex < index) {\n                this.indexes[id] = index + nodes.length;\n            }\n        }\n        this.markDirty();\n        return this;\n    }\n    insertBefore(exist, add) {\n        let existIndex = this.index(exist);\n        let type = existIndex === 0 ? 'prepend' : false;\n        let nodes = this.normalize(add, this.proxyOf.nodes[existIndex], type).reverse();\n        existIndex = this.index(exist);\n        for (let node of nodes)this.proxyOf.nodes.splice(existIndex, 0, node);\n        let index;\n        for(let id in this.indexes){\n            index = this.indexes[id];\n            if (existIndex <= index) {\n                this.indexes[id] = index + nodes.length;\n            }\n        }\n        this.markDirty();\n        return this;\n    }\n    normalize(nodes, sample) {\n        if (typeof nodes === 'string') {\n            nodes = cleanSource(parse(nodes).nodes);\n        } else if (typeof nodes === 'undefined') {\n            nodes = [];\n        } else if (Array.isArray(nodes)) {\n            nodes = nodes.slice(0);\n            for (let i of nodes){\n                if (i.parent) i.parent.removeChild(i, 'ignore');\n            }\n        } else if (nodes.type === 'root' && this.type !== 'document') {\n            nodes = nodes.nodes.slice(0);\n            for (let i of nodes){\n                if (i.parent) i.parent.removeChild(i, 'ignore');\n            }\n        } else if (nodes.type) {\n            nodes = [\n                nodes\n            ];\n        } else if (nodes.prop) {\n            if (typeof nodes.value === 'undefined') {\n                throw new Error('Value field is missed in node creation');\n            } else if (typeof nodes.value !== 'string') {\n                nodes.value = String(nodes.value);\n            }\n            nodes = [\n                new Declaration(nodes)\n            ];\n        } else if (nodes.selector || nodes.selectors) {\n            nodes = [\n                new Rule(nodes)\n            ];\n        } else if (nodes.name) {\n            nodes = [\n                new AtRule(nodes)\n            ];\n        } else if (nodes.text) {\n            nodes = [\n                new Comment(nodes)\n            ];\n        } else {\n            throw new Error('Unknown node type in node creation');\n        }\n        let processed = nodes.map((i)=>{\n            /* c8 ignore next */ if (!i[my]) Container.rebuild(i);\n            i = i.proxyOf;\n            if (i.parent) i.parent.removeChild(i);\n            if (i[isClean]) markTreeDirty(i);\n            if (!i.raws) i.raws = {};\n            if (typeof i.raws.before === 'undefined') {\n                if (sample && typeof sample.raws.before !== 'undefined') {\n                    i.raws.before = sample.raws.before.replace(/\\S/g, '');\n                }\n            }\n            i.parent = this.proxyOf;\n            return i;\n        });\n        return processed;\n    }\n    prepend(...children) {\n        children = children.reverse();\n        for (let child of children){\n            let nodes = this.normalize(child, this.first, 'prepend').reverse();\n            for (let node of nodes)this.proxyOf.nodes.unshift(node);\n            for(let id in this.indexes){\n                this.indexes[id] = this.indexes[id] + nodes.length;\n            }\n        }\n        this.markDirty();\n        return this;\n    }\n    push(child) {\n        child.parent = this;\n        this.proxyOf.nodes.push(child);\n        return this;\n    }\n    removeAll() {\n        for (let node of this.proxyOf.nodes)node.parent = undefined;\n        this.proxyOf.nodes = [];\n        this.markDirty();\n        return this;\n    }\n    removeChild(child) {\n        child = this.index(child);\n        this.proxyOf.nodes[child].parent = undefined;\n        this.proxyOf.nodes.splice(child, 1);\n        let index;\n        for(let id in this.indexes){\n            index = this.indexes[id];\n            if (index >= child) {\n                this.indexes[id] = index - 1;\n            }\n        }\n        this.markDirty();\n        return this;\n    }\n    replaceValues(pattern, opts, callback) {\n        if (!callback) {\n            callback = opts;\n            opts = {};\n        }\n        this.walkDecls((decl)=>{\n            if (opts.props && !opts.props.includes(decl.prop)) return;\n            if (opts.fast && !decl.value.includes(opts.fast)) return;\n            decl.value = decl.value.replace(pattern, callback);\n        });\n        this.markDirty();\n        return this;\n    }\n    some(condition) {\n        return this.nodes.some(condition);\n    }\n    walk(callback) {\n        return this.each((child, i)=>{\n            let result;\n            try {\n                result = callback(child, i);\n            } catch (e) {\n                throw child.addToError(e);\n            }\n            if (result !== false && child.walk) {\n                result = child.walk(callback);\n            }\n            return result;\n        });\n    }\n    walkAtRules(name, callback) {\n        if (!callback) {\n            callback = name;\n            return this.walk((child, i)=>{\n                if (child.type === 'atrule') {\n                    return callback(child, i);\n                }\n            });\n        }\n        if (name instanceof RegExp) {\n            return this.walk((child, i)=>{\n                if (child.type === 'atrule' && name.test(child.name)) {\n                    return callback(child, i);\n                }\n            });\n        }\n        return this.walk((child, i)=>{\n            if (child.type === 'atrule' && child.name === name) {\n                return callback(child, i);\n            }\n        });\n    }\n    walkComments(callback) {\n        return this.walk((child, i)=>{\n            if (child.type === 'comment') {\n                return callback(child, i);\n            }\n        });\n    }\n    walkDecls(prop, callback) {\n        if (!callback) {\n            callback = prop;\n            return this.walk((child, i)=>{\n                if (child.type === 'decl') {\n                    return callback(child, i);\n                }\n            });\n        }\n        if (prop instanceof RegExp) {\n            return this.walk((child, i)=>{\n                if (child.type === 'decl' && prop.test(child.prop)) {\n                    return callback(child, i);\n                }\n            });\n        }\n        return this.walk((child, i)=>{\n            if (child.type === 'decl' && child.prop === prop) {\n                return callback(child, i);\n            }\n        });\n    }\n    walkRules(selector, callback) {\n        if (!callback) {\n            callback = selector;\n            return this.walk((child, i)=>{\n                if (child.type === 'rule') {\n                    return callback(child, i);\n                }\n            });\n        }\n        if (selector instanceof RegExp) {\n            return this.walk((child, i)=>{\n                if (child.type === 'rule' && selector.test(child.selector)) {\n                    return callback(child, i);\n                }\n            });\n        }\n        return this.walk((child, i)=>{\n            if (child.type === 'rule' && child.selector === selector) {\n                return callback(child, i);\n            }\n        });\n    }\n}\nContainer.registerParse = (dependant)=>{\n    parse = dependant;\n};\nContainer.registerRule = (dependant)=>{\n    Rule = dependant;\n};\nContainer.registerAtRule = (dependant)=>{\n    AtRule = dependant;\n};\nContainer.registerRoot = (dependant)=>{\n    Root = dependant;\n};\nmodule.exports = Container;\nContainer.default = Container;\n/* c8 ignore start */ Container.rebuild = (node)=>{\n    if (node.type === 'atrule') {\n        Object.setPrototypeOf(node, AtRule.prototype);\n    } else if (node.type === 'rule') {\n        Object.setPrototypeOf(node, Rule.prototype);\n    } else if (node.type === 'decl') {\n        Object.setPrototypeOf(node, Declaration.prototype);\n    } else if (node.type === 'comment') {\n        Object.setPrototypeOf(node, Comment.prototype);\n    } else if (node.type === 'root') {\n        Object.setPrototypeOf(node, Root.prototype);\n    }\n    node[my] = true;\n    if (node.nodes) {\n        node.nodes.forEach((child)=>{\n            Container.rebuild(child);\n        });\n    }\n} /* c8 ignore stop */ ;\n}}),\n\"[project]/node_modules/postcss/lib/at-rule.js [postcss] (ecmascript)\": (function(__turbopack_context__) {\n\nvar { g: global, __dirname, m: module, e: exports } = __turbopack_context__;\n{\n'use strict';\nlet Container = __turbopack_context__.r(\"[project]/node_modules/postcss/lib/container.js [postcss] (ecmascript)\");\nclass AtRule extends Container {\n    constructor(defaults){\n        super(defaults);\n        this.type = 'atrule';\n    }\n    append(...children) {\n        if (!this.proxyOf.nodes) this.nodes = [];\n        return super.append(...children);\n    }\n    prepend(...children) {\n        if (!this.proxyOf.nodes) this.nodes = [];\n        return super.prepend(...children);\n    }\n}\nmodule.exports = AtRule;\nAtRule.default = AtRule;\nContainer.registerAtRule(AtRule);\n}}),\n\"[project]/node_modules/postcss/lib/document.js [postcss] (ecmascript)\": (function(__turbopack_context__) {\n\nvar { g: global, __dirname, m: module, e: exports } = __turbopack_context__;\n{\n'use strict';\nlet Container = __turbopack_context__.r(\"[project]/node_modules/postcss/lib/container.js [postcss] (ecmascript)\");\nlet LazyResult, Processor;\nclass Document extends Container {\n    constructor(defaults){\n        // type needs to be passed to super, otherwise child roots won't be normalized correctly\n        super({\n            type: 'document',\n            ...defaults\n        });\n        if (!this.nodes) {\n            this.nodes = [];\n        }\n    }\n    toResult(opts = {}) {\n        let lazy = new LazyResult(new Processor(), this, opts);\n        return lazy.stringify();\n    }\n}\nDocument.registerLazyResult = (dependant)=>{\n    LazyResult = dependant;\n};\nDocument.registerProcessor = (dependant)=>{\n    Processor = dependant;\n};\nmodule.exports = Document;\nDocument.default = Document;\n}}),\n\"[project]/node_modules/nanoid/non-secure/index.cjs [postcss] (ecmascript)\": (function(__turbopack_context__) {\n\nvar { g: global, __dirname, m: module, e: exports } = __turbopack_context__;\n{\n// This alphabet uses `A-Za-z0-9_-` symbols.\n// The order of characters is optimized for better gzip and brotli compression.\n// References to the same file (works both for gzip and brotli):\n// `'use`, `andom`, and `rict'`\n// References to the brotli default dictionary:\n// `-26T`, `1983`, `40px`, `75px`, `bush`, `jack`, `mind`, `very`, and `wolf`\nlet urlAlphabet = 'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict';\nlet customAlphabet = (alphabet, defaultSize = 21)=>{\n    return (size = defaultSize)=>{\n        let id = '';\n        // A compact alternative for `for (var i = 0; i < step; i++)`.\n        let i = size | 0;\n        while(i--){\n            // `| 0` is more compact and faster than `Math.floor()`.\n            id += alphabet[Math.random() * alphabet.length | 0];\n        }\n        return id;\n    };\n};\nlet nanoid = (size = 21)=>{\n    let id = '';\n    // A compact alternative for `for (var i = 0; i < step; i++)`.\n    let i = size | 0;\n    while(i--){\n        // `| 0` is more compact and faster than `Math.floor()`.\n        id += urlAlphabet[Math.random() * 64 | 0];\n    }\n    return id;\n};\nmodule.exports = {\n    nanoid,\n    customAlphabet\n};\n}}),\n\"[project]/node_modules/source-map-js/lib/base64.js [postcss] (ecmascript)\": (function(__turbopack_context__) {\n\nvar { g: global, __dirname, m: module, e: exports } = __turbopack_context__;\n{\n/* -*- Mode: js; js-indent-level: 2; -*- */ /*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */ var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');\n/**\n * Encode an integer in the range of 0 to 63 to a single base 64 digit.\n */ exports.encode = function(number) {\n    if (0 <= number && number < intToCharMap.length) {\n        return intToCharMap[number];\n    }\n    throw new TypeError(\"Must be between 0 and 63: \" + number);\n};\n/**\n * Decode a single base 64 character code digit to an integer. Returns -1 on\n * failure.\n */ exports.decode = function(charCode) {\n    var bigA = 65; // 'A'\n    var bigZ = 90; // 'Z'\n    var littleA = 97; // 'a'\n    var littleZ = 122; // 'z'\n    var zero = 48; // '0'\n    var nine = 57; // '9'\n    var plus = 43; // '+'\n    var slash = 47; // '/'\n    var littleOffset = 26;\n    var numberOffset = 52;\n    // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ\n    if (bigA <= charCode && charCode <= bigZ) {\n        return charCode - bigA;\n    }\n    // 26 - 51: abcdefghijklmnopqrstuvwxyz\n    if (littleA <= charCode && charCode <= littleZ) {\n        return charCode - littleA + littleOffset;\n    }\n    // 52 - 61: 0123456789\n    if (zero <= charCode && charCode <= nine) {\n        return charCode - zero + numberOffset;\n    }\n    // 62: +\n    if (charCode == plus) {\n        return 62;\n    }\n    // 63: /\n    if (charCode == slash) {\n        return 63;\n    }\n    // Invalid base64 digit.\n    return -1;\n};\n}}),\n\"[project]/node_modules/source-map-js/lib/base64-vlq.js [postcss] (ecmascript)\": (function(__turbopack_context__) {\n\nvar { g: global, __dirname, m: module, e: exports } = __turbopack_context__;\n{\n/* -*- Mode: js; js-indent-level: 2; -*- */ /*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n *\n * Based on the Base 64 VLQ implementation in Closure Compiler:\n * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java\n *\n * Copyright 2011 The Closure Compiler Authors. All rights reserved.\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *  * Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above\n *    copyright notice, this list of conditions and the following\n *    disclaimer in the documentation and/or other materials provided\n *    with the distribution.\n *  * Neither the name of Google Inc. nor the names of its\n *    contributors may be used to endorse or promote products derived\n *    from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */ var base64 = __turbopack_context__.r(\"[project]/node_modules/source-map-js/lib/base64.js [postcss] (ecmascript)\");\n// A single base 64 digit can contain 6 bits of data. For the base 64 variable\n// length quantities we use in the source map spec, the first bit is the sign,\n// the next four bits are the actual value, and the 6th bit is the\n// continuation bit. The continuation bit tells us whether there are more\n// digits in this value following this digit.\n//\n//   Continuation\n//   |    Sign\n//   |    |\n//   V    V\n//   101011\nvar VLQ_BASE_SHIFT = 5;\n// binary: 100000\nvar VLQ_BASE = 1 << VLQ_BASE_SHIFT;\n// binary: 011111\nvar VLQ_BASE_MASK = VLQ_BASE - 1;\n// binary: 100000\nvar VLQ_CONTINUATION_BIT = VLQ_BASE;\n/**\n * Converts from a two-complement value to a value where the sign bit is\n * placed in the least significant bit.  For example, as decimals:\n *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)\n *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)\n */ function toVLQSigned(aValue) {\n    return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;\n}\n/**\n * Converts to a two-complement value from a value where the sign bit is\n * placed in the least significant bit.  For example, as decimals:\n *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1\n *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2\n */ function fromVLQSigned(aValue) {\n    var isNegative = (aValue & 1) === 1;\n    var shifted = aValue >> 1;\n    return isNegative ? -shifted : shifted;\n}\n/**\n * Returns the base 64 VLQ encoded value.\n */ exports.encode = function base64VLQ_encode(aValue) {\n    var encoded = \"\";\n    var digit;\n    var vlq = toVLQSigned(aValue);\n    do {\n        digit = vlq & VLQ_BASE_MASK;\n        vlq >>>= VLQ_BASE_SHIFT;\n        if (vlq > 0) {\n            // There are still more digits in this value, so we must make sure the\n            // continuation bit is marked.\n            digit |= VLQ_CONTINUATION_BIT;\n        }\n        encoded += base64.encode(digit);\n    }while (vlq > 0)\n    return encoded;\n};\n/**\n * Decodes the next base 64 VLQ value from the given string and returns the\n * value and the rest of the string via the out parameter.\n */ exports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {\n    var strLen = aStr.length;\n    var result = 0;\n    var shift = 0;\n    var continuation, digit;\n    do {\n        if (aIndex >= strLen) {\n            throw new Error(\"Expected more digits in base 64 VLQ value.\");\n        }\n        digit = base64.decode(aStr.charCodeAt(aIndex++));\n        if (digit === -1) {\n            throw new Error(\"Invalid base64 digit: \" + aStr.charAt(aIndex - 1));\n        }\n        continuation = !!(digit & VLQ_CONTINUATION_BIT);\n        digit &= VLQ_BASE_MASK;\n        result = result + (digit << shift);\n        shift += VLQ_BASE_SHIFT;\n    }while (continuation)\n    aOutParam.value = fromVLQSigned(result);\n    aOutParam.rest = aIndex;\n};\n}}),\n\"[project]/node_modules/source-map-js/lib/util.js [postcss] (ecmascript)\": (function(__turbopack_context__) {\n\nvar { g: global, __dirname, m: module, e: exports } = __turbopack_context__;\n{\n/* -*- Mode: js; js-indent-level: 2; -*- */ /*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */ /**\n * This is a helper function for getting values from parameter/options\n * objects.\n *\n * @param args The object we are extracting values from\n * @param name The name of the property we are getting.\n * @param defaultValue An optional value to return if the property is missing\n * from the object. If this is not specified and the property is missing, an\n * error will be thrown.\n */ function getArg(aArgs, aName, aDefaultValue) {\n    if (aName in aArgs) {\n        return aArgs[aName];\n    } else if (arguments.length === 3) {\n        return aDefaultValue;\n    } else {\n        throw new Error('\"' + aName + '\" is a required argument.');\n    }\n}\nexports.getArg = getArg;\nvar urlRegexp = /^(?:([\\w+\\-.]+):)?\\/\\/(?:(\\w+:\\w+)@)?([\\w.-]*)(?::(\\d+))?(.*)$/;\nvar dataUrlRegexp = /^data:.+\\,.+$/;\nfunction urlParse(aUrl) {\n    var match = aUrl.match(urlRegexp);\n    if (!match) {\n        return null;\n    }\n    return {\n        scheme: match[1],\n        auth: match[2],\n        host: match[3],\n        port: match[4],\n        path: match[5]\n    };\n}\nexports.urlParse = urlParse;\nfunction urlGenerate(aParsedUrl) {\n    var url = '';\n    if (aParsedUrl.scheme) {\n        url += aParsedUrl.scheme + ':';\n    }\n    url += '//';\n    if (aParsedUrl.auth) {\n        url += aParsedUrl.auth + '@';\n    }\n    if (aParsedUrl.host) {\n        url += aParsedUrl.host;\n    }\n    if (aParsedUrl.port) {\n        url += \":\" + aParsedUrl.port;\n    }\n    if (aParsedUrl.path) {\n        url += aParsedUrl.path;\n    }\n    return url;\n}\nexports.urlGenerate = urlGenerate;\nvar MAX_CACHED_INPUTS = 32;\n/**\n * Takes some function `f(input) -> result` and returns a memoized version of\n * `f`.\n *\n * We keep at most `MAX_CACHED_INPUTS` memoized results of `f` alive. The\n * memoization is a dumb-simple, linear least-recently-used cache.\n */ function lruMemoize(f) {\n    var cache = [];\n    return function(input) {\n        for(var i = 0; i < cache.length; i++){\n            if (cache[i].input === input) {\n                var temp = cache[0];\n                cache[0] = cache[i];\n                cache[i] = temp;\n                return cache[0].result;\n            }\n        }\n        var result = f(input);\n        cache.unshift({\n            input,\n            result\n        });\n        if (cache.length > MAX_CACHED_INPUTS) {\n            cache.pop();\n        }\n        return result;\n    };\n}\n/**\n * Normalizes a path, or the path portion of a URL:\n *\n * - Replaces consecutive slashes with one slash.\n * - Removes unnecessary '.' parts.\n * - Removes unnecessary '<dir>/..' parts.\n *\n * Based on code in the Node.js 'path' core module.\n *\n * @param aPath The path or url to normalize.\n */ var normalize = lruMemoize(function normalize(aPath) {\n    var path = aPath;\n    var url = urlParse(aPath);\n    if (url) {\n        if (!url.path) {\n            return aPath;\n        }\n        path = url.path;\n    }\n    var isAbsolute = exports.isAbsolute(path);\n    // Split the path into parts between `/` characters. This is much faster than\n    // using `.split(/\\/+/g)`.\n    var parts = [];\n    var start = 0;\n    var i = 0;\n    while(true){\n        start = i;\n        i = path.indexOf(\"/\", start);\n        if (i === -1) {\n            parts.push(path.slice(start));\n            break;\n        } else {\n            parts.push(path.slice(start, i));\n            while(i < path.length && path[i] === \"/\"){\n                i++;\n            }\n        }\n    }\n    for(var part, up = 0, i = parts.length - 1; i >= 0; i--){\n        part = parts[i];\n        if (part === '.') {\n            parts.splice(i, 1);\n        } else if (part === '..') {\n            up++;\n        } else if (up > 0) {\n            if (part === '') {\n                // The first part is blank if the path is absolute. Trying to go\n                // above the root is a no-op. Therefore we can remove all '..' parts\n                // directly after the root.\n                parts.splice(i + 1, up);\n                up = 0;\n            } else {\n                parts.splice(i, 2);\n                up--;\n            }\n        }\n    }\n    path = parts.join('/');\n    if (path === '') {\n        path = isAbsolute ? '/' : '.';\n    }\n    if (url) {\n        url.path = path;\n        return urlGenerate(url);\n    }\n    return path;\n});\nexports.normalize = normalize;\n/**\n * Joins two paths/URLs.\n *\n * @param aRoot The root path or URL.\n * @param aPath The path or URL to be joined with the root.\n *\n * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a\n *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended\n *   first.\n * - Otherwise aPath is a path. If aRoot is a URL, then its path portion\n *   is updated with the result and aRoot is returned. Otherwise the result\n *   is returned.\n *   - If aPath is absolute, the result is aPath.\n *   - Otherwise the two paths are joined with a slash.\n * - Joining for example 'http://' and 'www.example.com' is also supported.\n */ function join(aRoot, aPath) {\n    if (aRoot === \"\") {\n        aRoot = \".\";\n    }\n    if (aPath === \"\") {\n        aPath = \".\";\n    }\n    var aPathUrl = urlParse(aPath);\n    var aRootUrl = urlParse(aRoot);\n    if (aRootUrl) {\n        aRoot = aRootUrl.path || '/';\n    }\n    // `join(foo, '//www.example.org')`\n    if (aPathUrl && !aPathUrl.scheme) {\n        if (aRootUrl) {\n            aPathUrl.scheme = aRootUrl.scheme;\n        }\n        return urlGenerate(aPathUrl);\n    }\n    if (aPathUrl || aPath.match(dataUrlRegexp)) {\n        return aPath;\n    }\n    // `join('http://', 'www.example.com')`\n    if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {\n        aRootUrl.host = aPath;\n        return urlGenerate(aRootUrl);\n    }\n    var joined = aPath.charAt(0) === '/' ? aPath : normalize(aRoot.replace(/\\/+$/, '') + '/' + aPath);\n    if (aRootUrl) {\n        aRootUrl.path = joined;\n        return urlGenerate(aRootUrl);\n    }\n    return joined;\n}\nexports.join = join;\nexports.isAbsolute = function(aPath) {\n    return aPath.charAt(0) === '/' || urlRegexp.test(aPath);\n};\n/**\n * Make a path relative to a URL or another path.\n *\n * @param aRoot The root path or URL.\n * @param aPath The path or URL to be made relative to aRoot.\n */ function relative(aRoot, aPath) {\n    if (aRoot === \"\") {\n        aRoot = \".\";\n    }\n    aRoot = aRoot.replace(/\\/$/, '');\n    // It is possible for the path to be above the root. In this case, simply\n    // checking whether the root is a prefix of the path won't work. Instead, we\n    // need to remove components from the root one by one, until either we find\n    // a prefix that fits, or we run out of components to remove.\n    var level = 0;\n    while(aPath.indexOf(aRoot + '/') !== 0){\n        var index = aRoot.lastIndexOf(\"/\");\n        if (index < 0) {\n            return aPath;\n        }\n        // If the only part of the root that is left is the scheme (i.e. http://,\n        // file:///, etc.), one or more slashes (/), or simply nothing at all, we\n        // have exhausted all components, so the path is not relative to the root.\n        aRoot = aRoot.slice(0, index);\n        if (aRoot.match(/^([^\\/]+:\\/)?\\/*$/)) {\n            return aPath;\n        }\n        ++level;\n    }\n    // Make sure we add a \"../\" for each component we removed from the root.\n    return Array(level + 1).join(\"../\") + aPath.substr(aRoot.length + 1);\n}\nexports.relative = relative;\nvar supportsNullProto = function() {\n    var obj = Object.create(null);\n    return !('__proto__' in obj);\n}();\nfunction identity(s) {\n    return s;\n}\n/**\n * Because behavior goes wacky when you set `__proto__` on objects, we\n * have to prefix all the strings in our set with an arbitrary character.\n *\n * See https://github.com/mozilla/source-map/pull/31 and\n * https://github.com/mozilla/source-map/issues/30\n *\n * @param String aStr\n */ function toSetString(aStr) {\n    if (isProtoString(aStr)) {\n        return '$' + aStr;\n    }\n    return aStr;\n}\nexports.toSetString = supportsNullProto ? identity : toSetString;\nfunction fromSetString(aStr) {\n    if (isProtoString(aStr)) {\n        return aStr.slice(1);\n    }\n    return aStr;\n}\nexports.fromSetString = supportsNullProto ? identity : fromSetString;\nfunction isProtoString(s) {\n    if (!s) {\n        return false;\n    }\n    var length = s.length;\n    if (length < 9 /* \"__proto__\".length */ ) {\n        return false;\n    }\n    if (s.charCodeAt(length - 1) !== 95 /* '_' */  || s.charCodeAt(length - 2) !== 95 /* '_' */  || s.charCodeAt(length - 3) !== 111 /* 'o' */  || s.charCodeAt(length - 4) !== 116 /* 't' */  || s.charCodeAt(length - 5) !== 111 /* 'o' */  || s.charCodeAt(length - 6) !== 114 /* 'r' */  || s.charCodeAt(length - 7) !== 112 /* 'p' */  || s.charCodeAt(length - 8) !== 95 /* '_' */  || s.charCodeAt(length - 9) !== 95 /* '_' */ ) {\n        return false;\n    }\n    for(var i = length - 10; i >= 0; i--){\n        if (s.charCodeAt(i) !== 36 /* '$' */ ) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Comparator between two mappings where the original positions are compared.\n *\n * Optionally pass in `true` as `onlyCompareGenerated` to consider two\n * mappings with the same original source/line/column, but different generated\n * line and column the same. Useful when searching for a mapping with a\n * stubbed out mapping.\n */ function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {\n    var cmp = strcmp(mappingA.source, mappingB.source);\n    if (cmp !== 0) {\n        return cmp;\n    }\n    cmp = mappingA.originalLine - mappingB.originalLine;\n    if (cmp !== 0) {\n        return cmp;\n    }\n    cmp = mappingA.originalColumn - mappingB.originalColumn;\n    if (cmp !== 0 || onlyCompareOriginal) {\n        return cmp;\n    }\n    cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n    if (cmp !== 0) {\n        return cmp;\n    }\n    cmp = mappingA.generatedLine - mappingB.generatedLine;\n    if (cmp !== 0) {\n        return cmp;\n    }\n    return strcmp(mappingA.name, mappingB.name);\n}\nexports.compareByOriginalPositions = compareByOriginalPositions;\nfunction compareByOriginalPositionsNoSource(mappingA, mappingB, onlyCompareOriginal) {\n    var cmp;\n    cmp = mappingA.originalLine - mappingB.originalLine;\n    if (cmp !== 0) {\n        return cmp;\n    }\n    cmp = mappingA.originalColumn - mappingB.originalColumn;\n    if (cmp !== 0 || onlyCompareOriginal) {\n        return cmp;\n    }\n    cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n    if (cmp !== 0) {\n        return cmp;\n    }\n    cmp = mappingA.generatedLine - mappingB.generatedLine;\n    if (cmp !== 0) {\n        return cmp;\n    }\n    return strcmp(mappingA.name, mappingB.name);\n}\nexports.compareByOriginalPositionsNoSource = compareByOriginalPositionsNoSource;\n/**\n * Comparator between two mappings with deflated source and name indices where\n * the generated positions are compared.\n *\n * Optionally pass in `true` as `onlyCompareGenerated` to consider two\n * mappings with the same generated line and column, but different\n * source/name/original line and column the same. Useful when searching for a\n * mapping with a stubbed out mapping.\n */ function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {\n    var cmp = mappingA.generatedLine - mappingB.generatedLine;\n    if (cmp !== 0) {\n        return cmp;\n    }\n    cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n    if (cmp !== 0 || onlyCompareGenerated) {\n        return cmp;\n    }\n    cmp = strcmp(mappingA.source, mappingB.source);\n    if (cmp !== 0) {\n        return cmp;\n    }\n    cmp = mappingA.originalLine - mappingB.originalLine;\n    if (cmp !== 0) {\n        return cmp;\n    }\n    cmp = mappingA.originalColumn - mappingB.originalColumn;\n    if (cmp !== 0) {\n        return cmp;\n    }\n    return strcmp(mappingA.name, mappingB.name);\n}\nexports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;\nfunction compareByGeneratedPositionsDeflatedNoLine(mappingA, mappingB, onlyCompareGenerated) {\n    var cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n    if (cmp !== 0 || onlyCompareGenerated) {\n        return cmp;\n    }\n    cmp = strcmp(mappingA.source, mappingB.source);\n    if (cmp !== 0) {\n        return cmp;\n    }\n    cmp = mappingA.originalLine - mappingB.originalLine;\n    if (cmp !== 0) {\n        return cmp;\n    }\n    cmp = mappingA.originalColumn - mappingB.originalColumn;\n    if (cmp !== 0) {\n        return cmp;\n    }\n    return strcmp(mappingA.name, mappingB.name);\n}\nexports.compareByGeneratedPositionsDeflatedNoLine = compareByGeneratedPositionsDeflatedNoLine;\nfunction strcmp(aStr1, aStr2) {\n    if (aStr1 === aStr2) {\n        return 0;\n    }\n    if (aStr1 === null) {\n        return 1; // aStr2 !== null\n    }\n    if (aStr2 === null) {\n        return -1; // aStr1 !== null\n    }\n    if (aStr1 > aStr2) {\n        return 1;\n    }\n    return -1;\n}\n/**\n * Comparator between two mappings with inflated source and name strings where\n * the generated positions are compared.\n */ function compareByGeneratedPositionsInflated(mappingA, mappingB) {\n    var cmp = mappingA.generatedLine - mappingB.generatedLine;\n    if (cmp !== 0) {\n        return cmp;\n    }\n    cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n    if (cmp !== 0) {\n        return cmp;\n    }\n    cmp = strcmp(mappingA.source, mappingB.source);\n    if (cmp !== 0) {\n        return cmp;\n    }\n    cmp = mappingA.originalLine - mappingB.originalLine;\n    if (cmp !== 0) {\n        return cmp;\n    }\n    cmp = mappingA.originalColumn - mappingB.originalColumn;\n    if (cmp !== 0) {\n        return cmp;\n    }\n    return strcmp(mappingA.name, mappingB.name);\n}\nexports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;\n/**\n * Strip any JSON XSSI avoidance prefix from the string (as documented\n * in the source maps specification), and then parse the string as\n * JSON.\n */ function parseSourceMapInput(str) {\n    return JSON.parse(str.replace(/^\\)]}'[^\\n]*\\n/, ''));\n}\nexports.parseSourceMapInput = parseSourceMapInput;\n/**\n * Compute the URL of a source given the the source root, the source's\n * URL, and the source map's URL.\n */ function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {\n    sourceURL = sourceURL || '';\n    if (sourceRoot) {\n        // This follows what Chrome does.\n        if (sourceRoot[sourceRoot.length - 1] !== '/' && sourceURL[0] !== '/') {\n            sourceRoot += '/';\n        }\n        // The spec says:\n        //   Line 4: An optional source root, useful for relocating source\n        //   files on a server or removing repeated values in the\n        //   sources entry.  This value is prepended to the individual\n        //   entries in the source field.\n        sourceURL = sourceRoot + sourceURL;\n    }\n    // Historically, SourceMapConsumer did not take the sourceMapURL as\n    // a parameter.  This mode is still somewhat supported, which is why\n    // this code block is conditional.  However, it's preferable to pass\n    // the source map URL to SourceMapConsumer, so that this function\n    // can implement the source URL resolution algorithm as outlined in\n    // the spec.  This block is basically the equivalent of:\n    //    new URL(sourceURL, sourceMapURL).toString()\n    // ... except it avoids using URL, which wasn't available in the\n    // older releases of node still supported by this library.\n    //\n    // The spec says:\n    //   If the sources are not absolute URLs after prepending of the\n    //   sourceRoot, the sources are resolved relative to the\n    //   SourceMap (like resolving script src in a html document).\n    if (sourceMapURL) {\n        var parsed = urlParse(sourceMapURL);\n        if (!parsed) {\n            throw new Error(\"sourceMapURL could not be parsed\");\n        }\n        if (parsed.path) {\n            // Strip the last path component, but keep the \"/\".\n            var index = parsed.path.lastIndexOf('/');\n            if (index >= 0) {\n                parsed.path = parsed.path.substring(0, index + 1);\n            }\n        }\n        sourceURL = join(urlGenerate(parsed), sourceURL);\n    }\n    return normalize(sourceURL);\n}\nexports.computeSourceURL = computeSourceURL;\n}}),\n\"[project]/node_modules/source-map-js/lib/array-set.js [postcss] (ecmascript)\": (function(__turbopack_context__) {\n\nvar { g: global, __dirname, m: module, e: exports } = __turbopack_context__;\n{\n/* -*- Mode: js; js-indent-level: 2; -*- */ /*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */ var util = __turbopack_context__.r(\"[project]/node_modules/source-map-js/lib/util.js [postcss] (ecmascript)\");\nvar has = Object.prototype.hasOwnProperty;\nvar hasNativeMap = typeof Map !== \"undefined\";\n/**\n * A data structure which is a combination of an array and a set. Adding a new\n * member is O(1), testing for membership is O(1), and finding the index of an\n * element is O(1). Removing elements from the set is not supported. Only\n * strings are supported for membership.\n */ function ArraySet() {\n    this._array = [];\n    this._set = hasNativeMap ? new Map() : Object.create(null);\n}\n/**\n * Static method for creating ArraySet instances from an existing array.\n */ ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {\n    var set = new ArraySet();\n    for(var i = 0, len = aArray.length; i < len; i++){\n        set.add(aArray[i], aAllowDuplicates);\n    }\n    return set;\n};\n/**\n * Return how many unique items are in this ArraySet. If duplicates have been\n * added, than those do not count towards the size.\n *\n * @returns Number\n */ ArraySet.prototype.size = function ArraySet_size() {\n    return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;\n};\n/**\n * Add the given string to this set.\n *\n * @param String aStr\n */ ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {\n    var sStr = hasNativeMap ? aStr : util.toSetString(aStr);\n    var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);\n    var idx = this._array.length;\n    if (!isDuplicate || aAllowDuplicates) {\n        this._array.push(aStr);\n    }\n    if (!isDuplicate) {\n        if (hasNativeMap) {\n            this._set.set(aStr, idx);\n        } else {\n            this._set[sStr] = idx;\n        }\n    }\n};\n/**\n * Is the given string a member of this set?\n *\n * @param String aStr\n */ ArraySet.prototype.has = function ArraySet_has(aStr) {\n    if (hasNativeMap) {\n        return this._set.has(aStr);\n    } else {\n        var sStr = util.toSetString(aStr);\n        return has.call(this._set, sStr);\n    }\n};\n/**\n * What is the index of the given string in the array?\n *\n * @param String aStr\n */ ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {\n    if (hasNativeMap) {\n        var idx = this._set.get(aStr);\n        if (idx >= 0) {\n            return idx;\n        }\n    } else {\n        var sStr = util.toSetString(aStr);\n        if (has.call(this._set, sStr)) {\n            return this._set[sStr];\n        }\n    }\n    throw new Error('\"' + aStr + '\" is not in the set.');\n};\n/**\n * What is the element at the given index?\n *\n * @param Number aIdx\n */ ArraySet.prototype.at = function ArraySet_at(aIdx) {\n    if (aIdx >= 0 && aIdx < this._array.length) {\n        return this._array[aIdx];\n    }\n    throw new Error('No element indexed by ' + aIdx);\n};\n/**\n * Returns the array representation of this set (which has the proper indices\n * indicated by indexOf). Note that this is a copy of the internal array used\n * for storing the members so that no one can mess with internal state.\n */ ArraySet.prototype.toArray = function ArraySet_toArray() {\n    return this._array.slice();\n};\nexports.ArraySet = ArraySet;\n}}),\n\"[project]/node_modules/source-map-js/lib/mapping-list.js [postcss] (ecmascript)\": (function(__turbopack_context__) {\n\nvar { g: global, __dirname, m: module, e: exports } = __turbopack_context__;\n{\n/* -*- Mode: js; js-indent-level: 2; -*- */ /*\n * Copyright 2014 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */ var util = __turbopack_context__.r(\"[project]/node_modules/source-map-js/lib/util.js [postcss] (ecmascript)\");\n/**\n * Determine whether mappingB is after mappingA with respect to generated\n * position.\n */ function generatedPositionAfter(mappingA, mappingB) {\n    // Optimized for most common case\n    var lineA = mappingA.generatedLine;\n    var lineB = mappingB.generatedLine;\n    var columnA = mappingA.generatedColumn;\n    var columnB = mappingB.generatedColumn;\n    return lineB > lineA || lineB == lineA && columnB >= columnA || util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;\n}\n/**\n * A data structure to provide a sorted view of accumulated mappings in a\n * performance conscious manner. It trades a neglibable overhead in general\n * case for a large speedup in case of mappings being added in order.\n */ function MappingList() {\n    this._array = [];\n    this._sorted = true;\n    // Serves as infimum\n    this._last = {\n        generatedLine: -1,\n        generatedColumn: 0\n    };\n}\n/**\n * Iterate through internal items. This method takes the same arguments that\n * `Array.prototype.forEach` takes.\n *\n * NOTE: The order of the mappings is NOT guaranteed.\n */ MappingList.prototype.unsortedForEach = function MappingList_forEach(aCallback, aThisArg) {\n    this._array.forEach(aCallback, aThisArg);\n};\n/**\n * Add the given source mapping.\n *\n * @param Object aMapping\n */ MappingList.prototype.add = function MappingList_add(aMapping) {\n    if (generatedPositionAfter(this._last, aMapping)) {\n        this._last = aMapping;\n        this._array.push(aMapping);\n    } else {\n        this._sorted = false;\n        this._array.push(aMapping);\n    }\n};\n/**\n * Returns the flat, sorted array of mappings. The mappings are sorted by\n * generated position.\n *\n * WARNING: This method returns internal data without copying, for\n * performance. The return value must NOT be mutated, and should be treated as\n * an immutable borrow. If you want to take ownership, you must make your own\n * copy.\n */ MappingList.prototype.toArray = function MappingList_toArray() {\n    if (!this._sorted) {\n        this._array.sort(util.compareByGeneratedPositionsInflated);\n        this._sorted = true;\n    }\n    return this._array;\n};\nexports.MappingList = MappingList;\n}}),\n\"[project]/node_modules/source-map-js/lib/source-map-generator.js [postcss] (ecmascript)\": (function(__turbopack_context__) {\n\nvar { g: global, __dirname, m: module, e: exports } = __turbopack_context__;\n{\n/* -*- Mode: js; js-indent-level: 2; -*- */ /*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */ var base64VLQ = __turbopack_context__.r(\"[project]/node_modules/source-map-js/lib/base64-vlq.js [postcss] (ecmascript)\");\nvar util = __turbopack_context__.r(\"[project]/node_modules/source-map-js/lib/util.js [postcss] (ecmascript)\");\nvar ArraySet = __turbopack_context__.r(\"[project]/node_modules/source-map-js/lib/array-set.js [postcss] (ecmascript)\").ArraySet;\nvar MappingList = __turbopack_context__.r(\"[project]/node_modules/source-map-js/lib/mapping-list.js [postcss] (ecmascript)\").MappingList;\n/**\n * An instance of the SourceMapGenerator represents a source map which is\n * being built incrementally. You may pass an object with the following\n * properties:\n *\n *   - file: The filename of the generated source.\n *   - sourceRoot: A root for all relative URLs in this source map.\n */ function SourceMapGenerator(aArgs) {\n    if (!aArgs) {\n        aArgs = {};\n    }\n    this._file = util.getArg(aArgs, 'file', null);\n    this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);\n    this._skipValidation = util.getArg(aArgs, 'skipValidation', false);\n    this._ignoreInvalidMapping = util.getArg(aArgs, 'ignoreInvalidMapping', false);\n    this._sources = new ArraySet();\n    this._names = new ArraySet();\n    this._mappings = new MappingList();\n    this._sourcesContents = null;\n}\nSourceMapGenerator.prototype._version = 3;\n/**\n * Creates a new SourceMapGenerator based on a SourceMapConsumer\n *\n * @param aSourceMapConsumer The SourceMap.\n */ SourceMapGenerator.fromSourceMap = function SourceMapGenerator_fromSourceMap(aSourceMapConsumer, generatorOps) {\n    var sourceRoot = aSourceMapConsumer.sourceRoot;\n    var generator = new SourceMapGenerator(Object.assign(generatorOps || {}, {\n        file: aSourceMapConsumer.file,\n        sourceRoot: sourceRoot\n    }));\n    aSourceMapConsumer.eachMapping(function(mapping) {\n        var newMapping = {\n            generated: {\n                line: mapping.generatedLine,\n                column: mapping.generatedColumn\n            }\n        };\n        if (mapping.source != null) {\n            newMapping.source = mapping.source;\n            if (sourceRoot != null) {\n                newMapping.source = util.relative(sourceRoot, newMapping.source);\n            }\n            newMapping.original = {\n                line: mapping.originalLine,\n                column: mapping.originalColumn\n            };\n            if (mapping.name != null) {\n                newMapping.name = mapping.name;\n            }\n        }\n        generator.addMapping(newMapping);\n    });\n    aSourceMapConsumer.sources.forEach(function(sourceFile) {\n        var sourceRelative = sourceFile;\n        if (sourceRoot !== null) {\n            sourceRelative = util.relative(sourceRoot, sourceFile);\n        }\n        if (!generator._sources.has(sourceRelative)) {\n            generator._sources.add(sourceRelative);\n        }\n        var content = aSourceMapConsumer.sourceContentFor(sourceFile);\n        if (content != null) {\n            generator.setSourceContent(sourceFile, content);\n        }\n    });\n    return generator;\n};\n/**\n * Add a single mapping from original source line and column to the generated\n * source's line and column for this source map being created. The mapping\n * object should have the following properties:\n *\n *   - generated: An object with the generated line and column positions.\n *   - original: An object with the original line and column positions.\n *   - source: The original source file (relative to the sourceRoot).\n *   - name: An optional original token name for this mapping.\n */ SourceMapGenerator.prototype.addMapping = function SourceMapGenerator_addMapping(aArgs) {\n    var generated = util.getArg(aArgs, 'generated');\n    var original = util.getArg(aArgs, 'original', null);\n    var source = util.getArg(aArgs, 'source', null);\n    var name = util.getArg(aArgs, 'name', null);\n    if (!this._skipValidation) {\n        if (this._validateMapping(generated, original, source, name) === false) {\n            return;\n        }\n    }\n    if (source != null) {\n        source = String(source);\n        if (!this._sources.has(source)) {\n            this._sources.add(source);\n        }\n    }\n    if (name != null) {\n        name = String(name);\n        if (!this._names.has(name)) {\n            this._names.add(name);\n        }\n    }\n    this._mappings.add({\n        generatedLine: generated.line,\n        generatedColumn: generated.column,\n        originalLine: original != null && original.line,\n        originalColumn: original != null && original.column,\n        source: source,\n        name: name\n    });\n};\n/**\n * Set the source content for a source file.\n */ SourceMapGenerator.prototype.setSourceContent = function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {\n    var source = aSourceFile;\n    if (this._sourceRoot != null) {\n        source = util.relative(this._sourceRoot, source);\n    }\n    if (aSourceContent != null) {\n        // Add the source content to the _sourcesContents map.\n        // Create a new _sourcesContents map if the property is null.\n        if (!this._sourcesContents) {\n            this._sourcesContents = Object.create(null);\n        }\n        this._sourcesContents[util.toSetString(source)] = aSourceContent;\n    } else if (this._sourcesContents) {\n        // Remove the source file from the _sourcesContents map.\n        // If the _sourcesContents map is empty, set the property to null.\n        delete this._sourcesContents[util.toSetString(source)];\n        if (Object.keys(this._sourcesContents).length === 0) {\n            this._sourcesContents = null;\n        }\n    }\n};\n/**\n * Applies the mappings of a sub-source-map for a specific source file to the\n * source map being generated. Each mapping to the supplied source file is\n * rewritten using the supplied source map. Note: The resolution for the\n * resulting mappings is the minimium of this map and the supplied map.\n *\n * @param aSourceMapConsumer The source map to be applied.\n * @param aSourceFile Optional. The filename of the source file.\n *        If omitted, SourceMapConsumer's file property will be used.\n * @param aSourceMapPath Optional. The dirname of the path to the source map\n *        to be applied. If relative, it is relative to the SourceMapConsumer.\n *        This parameter is needed when the two source maps aren't in the same\n *        directory, and the source map to be applied contains relative source\n *        paths. If so, those relative source paths need to be rewritten\n *        relative to the SourceMapGenerator.\n */ SourceMapGenerator.prototype.applySourceMap = function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {\n    var sourceFile = aSourceFile;\n    // If aSourceFile is omitted, we will use the file property of the SourceMap\n    if (aSourceFile == null) {\n        if (aSourceMapConsumer.file == null) {\n            throw new Error('SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' + 'or the source map\\'s \"file\" property. Both were omitted.');\n        }\n        sourceFile = aSourceMapConsumer.file;\n    }\n    var sourceRoot = this._sourceRoot;\n    // Make \"sourceFile\" relative if an absolute Url is passed.\n    if (sourceRoot != null) {\n        sourceFile = util.relative(sourceRoot, sourceFile);\n    }\n    // Applying the SourceMap can add and remove items from the sources and\n    // the names array.\n    var newSources = new ArraySet();\n    var newNames = new ArraySet();\n    // Find mappings for the \"sourceFile\"\n    this._mappings.unsortedForEach(function(mapping) {\n        if (mapping.source === sourceFile && mapping.originalLine != null) {\n            // Check if it can be mapped by the source map, then update the mapping.\n            var original = aSourceMapConsumer.originalPositionFor({\n                line: mapping.originalLine,\n                column: mapping.originalColumn\n            });\n            if (original.source != null) {\n                // Copy mapping\n                mapping.source = original.source;\n                if (aSourceMapPath != null) {\n                    mapping.source = util.join(aSourceMapPath, mapping.source);\n                }\n                if (sourceRoot != null) {\n                    mapping.source = util.relative(sourceRoot, mapping.source);\n                }\n                mapping.originalLine = original.line;\n                mapping.originalColumn = original.column;\n                if (original.name != null) {\n                    mapping.name = original.name;\n                }\n            }\n        }\n        var source = mapping.source;\n        if (source != null && !newSources.has(source)) {\n            newSources.add(source);\n        }\n        var name = mapping.name;\n        if (name != null && !newNames.has(name)) {\n            newNames.add(name);\n        }\n    }, this);\n    this._sources = newSources;\n    this._names = newNames;\n    // Copy sourcesContents of applied map.\n    aSourceMapConsumer.sources.forEach(function(sourceFile) {\n        var content = aSourceMapConsumer.sourceContentFor(sourceFile);\n        if (content != null) {\n            if (aSourceMapPath != null) {\n                sourceFile = util.join(aSourceMapPath, sourceFile);\n            }\n            if (sourceRoot != null) {\n                sourceFile = util.relative(sourceRoot, sourceFile);\n            }\n            this.setSourceContent(sourceFile, content);\n        }\n    }, this);\n};\n/**\n * A mapping can have one of the three levels of data:\n *\n *   1. Just the generated position.\n *   2. The Generated position, original position, and original source.\n *   3. Generated and original position, original source, as well as a name\n *      token.\n *\n * To maintain consistency, we validate that any new mapping being added falls\n * in to one of these categories.\n */ SourceMapGenerator.prototype._validateMapping = function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource, aName) {\n    // When aOriginal is truthy but has empty values for .line and .column,\n    // it is most likely a programmer error. In this case we throw a very\n    // specific error message to try to guide them the right way.\n    // For example: https://github.com/Polymer/polymer-bundler/pull/519\n    if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {\n        var message = 'original.line and original.column are not numbers -- you probably meant to omit ' + 'the original mapping entirely and only map the generated position. If so, pass ' + 'null for the original mapping instead of an object with empty or null values.';\n        if (this._ignoreInvalidMapping) {\n            if (typeof console !== 'undefined' && console.warn) {\n                console.warn(message);\n            }\n            return false;\n        } else {\n            throw new Error(message);\n        }\n    }\n    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated && aGenerated.line > 0 && aGenerated.column >= 0 && !aOriginal && !aSource && !aName) {\n        // Case 1.\n        return;\n    } else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated && aOriginal && 'line' in aOriginal && 'column' in aOriginal && aGenerated.line > 0 && aGenerated.column >= 0 && aOriginal.line > 0 && aOriginal.column >= 0 && aSource) {\n        // Cases 2 and 3.\n        return;\n    } else {\n        var message = 'Invalid mapping: ' + JSON.stringify({\n            generated: aGenerated,\n            source: aSource,\n            original: aOriginal,\n            name: aName\n        });\n        if (this._ignoreInvalidMapping) {\n            if (typeof console !== 'undefined' && console.warn) {\n                console.warn(message);\n            }\n            return false;\n        } else {\n            throw new Error(message);\n        }\n    }\n};\n/**\n * Serialize the accumulated mappings in to the stream of base 64 VLQs\n * specified by the source map format.\n */ SourceMapGenerator.prototype._serializeMappings = function SourceMapGenerator_serializeMappings() {\n    var previousGeneratedColumn = 0;\n    var previousGeneratedLine = 1;\n    var previousOriginalColumn = 0;\n    var previousOriginalLine = 0;\n    var previousName = 0;\n    var previousSource = 0;\n    var result = '';\n    var next;\n    var mapping;\n    var nameIdx;\n    var sourceIdx;\n    var mappings = this._mappings.toArray();\n    for(var i = 0, len = mappings.length; i < len; i++){\n        mapping = mappings[i];\n        next = '';\n        if (mapping.generatedLine !== previousGeneratedLine) {\n            previousGeneratedColumn = 0;\n            while(mapping.generatedLine !== previousGeneratedLine){\n                next += ';';\n                previousGeneratedLine++;\n            }\n        } else {\n            if (i > 0) {\n                if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {\n                    continue;\n                }\n                next += ',';\n            }\n        }\n        next += base64VLQ.encode(mapping.generatedColumn - previousGeneratedColumn);\n        previousGeneratedColumn = mapping.generatedColumn;\n        if (mapping.source != null) {\n            sourceIdx = this._sources.indexOf(mapping.source);\n            next += base64VLQ.encode(sourceIdx - previousSource);\n            previousSource = sourceIdx;\n            // lines are stored 0-based in SourceMap spec version 3\n            next += base64VLQ.encode(mapping.originalLine - 1 - previousOriginalLine);\n            previousOriginalLine = mapping.originalLine - 1;\n            next += base64VLQ.encode(mapping.originalColumn - previousOriginalColumn);\n            previousOriginalColumn = mapping.originalColumn;\n            if (mapping.name != null) {\n                nameIdx = this._names.indexOf(mapping.name);\n                next += base64VLQ.encode(nameIdx - previousName);\n                previousName = nameIdx;\n            }\n        }\n        result += next;\n    }\n    return result;\n};\nSourceMapGenerator.prototype._generateSourcesContent = function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {\n    return aSources.map(function(source) {\n        if (!this._sourcesContents) {\n            return null;\n        }\n        if (aSourceRoot != null) {\n            source = util.relative(aSourceRoot, source);\n        }\n        var key = util.toSetString(source);\n        return Object.prototype.hasOwnProperty.call(this._sourcesContents, key) ? this._sourcesContents[key] : null;\n    }, this);\n};\n/**\n * Externalize the source map.\n */ SourceMapGenerator.prototype.toJSON = function SourceMapGenerator_toJSON() {\n    var map = {\n        version: this._version,\n        sources: this._sources.toArray(),\n        names: this._names.toArray(),\n        mappings: this._serializeMappings()\n    };\n    if (this._file != null) {\n        map.file = this._file;\n    }\n    if (this._sourceRoot != null) {\n        map.sourceRoot = this._sourceRoot;\n    }\n    if (this._sourcesContents) {\n        map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);\n    }\n    return map;\n};\n/**\n * Render the source map being generated to a string.\n */ SourceMapGenerator.prototype.toString = function SourceMapGenerator_toString() {\n    return JSON.stringify(this.toJSON());\n};\nexports.SourceMapGenerator = SourceMapGenerator;\n}}),\n\"[project]/node_modules/source-map-js/lib/binary-search.js [postcss] (ecmascript)\": (function(__turbopack_context__) {\n\nvar { g: global, __dirname, m: module, e: exports } = __turbopack_context__;\n{\n/* -*- Mode: js; js-indent-level: 2; -*- */ /*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */ exports.GREATEST_LOWER_BOUND = 1;\nexports.LEAST_UPPER_BOUND = 2;\n/**\n * Recursive implementation of binary search.\n *\n * @param aLow Indices here and lower do not contain the needle.\n * @param aHigh Indices here and higher do not contain the needle.\n * @param aNeedle The element being searched for.\n * @param aHaystack The non-empty array being searched.\n * @param aCompare Function which takes two elements and returns -1, 0, or 1.\n * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or\n *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the\n *     closest element that is smaller than or greater than the one we are\n *     searching for, respectively, if the exact element cannot be found.\n */ function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {\n    // This function terminates when one of the following is true:\n    //\n    //   1. We find the exact element we are looking for.\n    //\n    //   2. We did not find the exact element, but we can return the index of\n    //      the next-closest element.\n    //\n    //   3. We did not find the exact element, and there is no next-closest\n    //      element than the one we are searching for, so we return -1.\n    var mid = Math.floor((aHigh - aLow) / 2) + aLow;\n    var cmp = aCompare(aNeedle, aHaystack[mid], true);\n    if (cmp === 0) {\n        // Found the element we are looking for.\n        return mid;\n    } else if (cmp > 0) {\n        // Our needle is greater than aHaystack[mid].\n        if (aHigh - mid > 1) {\n            // The element is in the upper half.\n            return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);\n        }\n        // The exact needle element was not found in this haystack. Determine if\n        // we are in termination case (3) or (2) and return the appropriate thing.\n        if (aBias == exports.LEAST_UPPER_BOUND) {\n            return aHigh < aHaystack.length ? aHigh : -1;\n        } else {\n            return mid;\n        }\n    } else {\n        // Our needle is less than aHaystack[mid].\n        if (mid - aLow > 1) {\n            // The element is in the lower half.\n            return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);\n        }\n        // we are in termination case (3) or (2) and return the appropriate thing.\n        if (aBias == exports.LEAST_UPPER_BOUND) {\n            return mid;\n        } else {\n            return aLow < 0 ? -1 : aLow;\n        }\n    }\n}\n/**\n * This is an implementation of binary search which will always try and return\n * the index of the closest element if there is no exact hit. This is because\n * mappings between original and generated line/col pairs are single points,\n * and there is an implicit region between each of them, so a miss just means\n * that you aren't on the very start of a region.\n *\n * @param aNeedle The element you are looking for.\n * @param aHaystack The array that is being searched.\n * @param aCompare A function which takes the needle and an element in the\n *     array and returns -1, 0, or 1 depending on whether the needle is less\n *     than, equal to, or greater than the element, respectively.\n * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or\n *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the\n *     closest element that is smaller than or greater than the one we are\n *     searching for, respectively, if the exact element cannot be found.\n *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.\n */ exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {\n    if (aHaystack.length === 0) {\n        return -1;\n    }\n    var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack, aCompare, aBias || exports.GREATEST_LOWER_BOUND);\n    if (index < 0) {\n        return -1;\n    }\n    // We have found either the exact element, or the next-closest element than\n    // the one we are searching for. However, there may be more than one such\n    // element. Make sure we always return the smallest of these.\n    while(index - 1 >= 0){\n        if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {\n            break;\n        }\n        --index;\n    }\n    return index;\n};\n}}),\n\"[project]/node_modules/source-map-js/lib/quick-sort.js [postcss] (ecmascript)\": (function(__turbopack_context__) {\n\nvar { g: global, __dirname, m: module, e: exports } = __turbopack_context__;\n{\n/* -*- Mode: js; js-indent-level: 2; -*- */ /*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */ // It turns out that some (most?) JavaScript engines don't self-host\n// `Array.prototype.sort`. This makes sense because C++ will likely remain\n// faster than JS when doing raw CPU-intensive sorting. However, when using a\n// custom comparator function, calling back and forth between the VM's C++ and\n// JIT'd JS is rather slow *and* loses JIT type information, resulting in\n// worse generated code for the comparator function than would be optimal. In\n// fact, when sorting with a comparator, these costs outweigh the benefits of\n// sorting in C++. By using our own JS-implemented Quick Sort (below), we get\n// a ~3500ms mean speed-up in `bench/bench.html`.\nfunction SortTemplate(comparator) {\n    /**\n * Swap the elements indexed by `x` and `y` in the array `ary`.\n *\n * @param {Array} ary\n *        The array.\n * @param {Number} x\n *        The index of the first item.\n * @param {Number} y\n *        The index of the second item.\n */ function swap(ary, x, y) {\n        var temp = ary[x];\n        ary[x] = ary[y];\n        ary[y] = temp;\n    }\n    /**\n * Returns a random integer within the range `low .. high` inclusive.\n *\n * @param {Number} low\n *        The lower bound on the range.\n * @param {Number} high\n *        The upper bound on the range.\n */ function randomIntInRange(low, high) {\n        return Math.round(low + Math.random() * (high - low));\n    }\n    /**\n * The Quick Sort algorithm.\n *\n * @param {Array} ary\n *        An array to sort.\n * @param {function} comparator\n *        Function to use to compare two items.\n * @param {Number} p\n *        Start index of the array\n * @param {Number} r\n *        End index of the array\n */ function doQuickSort(ary, comparator, p, r) {\n        // If our lower bound is less than our upper bound, we (1) partition the\n        // array into two pieces and (2) recurse on each half. If it is not, this is\n        // the empty array and our base case.\n        if (p < r) {\n            // (1) Partitioning.\n            //\n            // The partitioning chooses a pivot between `p` and `r` and moves all\n            // elements that are less than or equal to the pivot to the before it, and\n            // all the elements that are greater than it after it. The effect is that\n            // once partition is done, the pivot is in the exact place it will be when\n            // the array is put in sorted order, and it will not need to be moved\n            // again. This runs in O(n) time.\n            // Always choose a random pivot so that an input array which is reverse\n            // sorted does not cause O(n^2) running time.\n            var pivotIndex = randomIntInRange(p, r);\n            var i = p - 1;\n            swap(ary, pivotIndex, r);\n            var pivot = ary[r];\n            // Immediately after `j` is incremented in this loop, the following hold\n            // true:\n            //\n            //   * Every element in `ary[p .. i]` is less than or equal to the pivot.\n            //\n            //   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.\n            for(var j = p; j < r; j++){\n                if (comparator(ary[j], pivot, false) <= 0) {\n                    i += 1;\n                    swap(ary, i, j);\n                }\n            }\n            swap(ary, i + 1, j);\n            var q = i + 1;\n            // (2) Recurse on each half.\n            doQuickSort(ary, comparator, p, q - 1);\n            doQuickSort(ary, comparator, q + 1, r);\n        }\n    }\n    return doQuickSort;\n}\nfunction cloneSort(comparator) {\n    let template = SortTemplate.toString();\n    let templateFn = new Function(`return ${template}`)();\n    return templateFn(comparator);\n}\n/**\n * Sort the given array in-place with the given comparator function.\n *\n * @param {Array} ary\n *        An array to sort.\n * @param {function} comparator\n *        Function to use to compare two items.\n */ let sortCache = new WeakMap();\nexports.quickSort = function(ary, comparator, start = 0) {\n    let doQuickSort = sortCache.get(comparator);\n    if (doQuickSort === void 0) {\n        doQuickSort = cloneSort(comparator);\n        sortCache.set(comparator, doQuickSort);\n    }\n    doQuickSort(ary, comparator, start, ary.length - 1);\n};\n}}),\n\"[project]/node_modules/source-map-js/lib/source-map-consumer.js [postcss] (ecmascript)\": (function(__turbopack_context__) {\n\nvar { g: global, __dirname, m: module, e: exports } = __turbopack_context__;\n{\n/* -*- Mode: js; js-indent-level: 2; -*- */ /*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */ var util = __turbopack_context__.r(\"[project]/node_modules/source-map-js/lib/util.js [postcss] (ecmascript)\");\nvar binarySearch = __turbopack_context__.r(\"[project]/node_modules/source-map-js/lib/binary-search.js [postcss] (ecmascript)\");\nvar ArraySet = __turbopack_context__.r(\"[project]/node_modules/source-map-js/lib/array-set.js [postcss] (ecmascript)\").ArraySet;\nvar base64VLQ = __turbopack_context__.r(\"[project]/node_modules/source-map-js/lib/base64-vlq.js [postcss] (ecmascript)\");\nvar quickSort = __turbopack_context__.r(\"[project]/node_modules/source-map-js/lib/quick-sort.js [postcss] (ecmascript)\").quickSort;\nfunction SourceMapConsumer(aSourceMap, aSourceMapURL) {\n    var sourceMap = aSourceMap;\n    if (typeof aSourceMap === 'string') {\n        sourceMap = util.parseSourceMapInput(aSourceMap);\n    }\n    return sourceMap.sections != null ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL) : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);\n}\nSourceMapConsumer.fromSourceMap = function(aSourceMap, aSourceMapURL) {\n    return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);\n};\n/**\n * The version of the source mapping spec that we are consuming.\n */ SourceMapConsumer.prototype._version = 3;\n// `__generatedMappings` and `__originalMappings` are arrays that hold the\n// parsed mapping coordinates from the source map's \"mappings\" attribute. They\n// are lazily instantiated, accessed via the `_generatedMappings` and\n// `_originalMappings` getters respectively, and we only parse the mappings\n// and create these arrays once queried for a source location. We jump through\n// these hoops because there can be many thousands of mappings, and parsing\n// them is expensive, so we only want to do it if we must.\n//\n// Each object in the arrays is of the form:\n//\n//     {\n//       generatedLine: The line number in the generated code,\n//       generatedColumn: The column number in the generated code,\n//       source: The path to the original source file that generated this\n//               chunk of code,\n//       originalLine: The line number in the original source that\n//                     corresponds to this chunk of generated code,\n//       originalColumn: The column number in the original source that\n//                       corresponds to this chunk of generated code,\n//       name: The name of the original symbol which generated this chunk of\n//             code.\n//     }\n//\n// All properties except for `generatedLine` and `generatedColumn` can be\n// `null`.\n//\n// `_generatedMappings` is ordered by the generated positions.\n//\n// `_originalMappings` is ordered by the original positions.\nSourceMapConsumer.prototype.__generatedMappings = null;\nObject.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {\n    configurable: true,\n    enumerable: true,\n    get: function() {\n        if (!this.__generatedMappings) {\n            this._parseMappings(this._mappings, this.sourceRoot);\n        }\n        return this.__generatedMappings;\n    }\n});\nSourceMapConsumer.prototype.__originalMappings = null;\nObject.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {\n    configurable: true,\n    enumerable: true,\n    get: function() {\n        if (!this.__originalMappings) {\n            this._parseMappings(this._mappings, this.sourceRoot);\n        }\n        return this.__originalMappings;\n    }\n});\nSourceMapConsumer.prototype._charIsMappingSeparator = function SourceMapConsumer_charIsMappingSeparator(aStr, index) {\n    var c = aStr.charAt(index);\n    return c === \";\" || c === \",\";\n};\n/**\n * Parse the mappings in a string in to a data structure which we can easily\n * query (the ordered arrays in the `this.__generatedMappings` and\n * `this.__originalMappings` properties).\n */ SourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {\n    throw new Error(\"Subclasses must implement _parseMappings\");\n};\nSourceMapConsumer.GENERATED_ORDER = 1;\nSourceMapConsumer.ORIGINAL_ORDER = 2;\nSourceMapConsumer.GREATEST_LOWER_BOUND = 1;\nSourceMapConsumer.LEAST_UPPER_BOUND = 2;\n/**\n * Iterate over each mapping between an original source/line/column and a\n * generated line/column in this source map.\n *\n * @param Function aCallback\n *        The function that is called with each mapping.\n * @param Object aContext\n *        Optional. If specified, this object will be the value of `this` every\n *        time that `aCallback` is called.\n * @param aOrder\n *        Either `SourceMapConsumer.GENERATED_ORDER` or\n *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to\n *        iterate over the mappings sorted by the generated file's line/column\n *        order or the original's source/line/column order, respectively. Defaults to\n *        `SourceMapConsumer.GENERATED_ORDER`.\n */ SourceMapConsumer.prototype.eachMapping = function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {\n    var context = aContext || null;\n    var order = aOrder || SourceMapConsumer.GENERATED_ORDER;\n    var mappings;\n    switch(order){\n        case SourceMapConsumer.GENERATED_ORDER:\n            mappings = this._generatedMappings;\n            break;\n        case SourceMapConsumer.ORIGINAL_ORDER:\n            mappings = this._originalMappings;\n            break;\n        default:\n            throw new Error(\"Unknown order of iteration.\");\n    }\n    var sourceRoot = this.sourceRoot;\n    var boundCallback = aCallback.bind(context);\n    var names = this._names;\n    var sources = this._sources;\n    var sourceMapURL = this._sourceMapURL;\n    for(var i = 0, n = mappings.length; i < n; i++){\n        var mapping = mappings[i];\n        var source = mapping.source === null ? null : sources.at(mapping.source);\n        if (source !== null) {\n            source = util.computeSourceURL(sourceRoot, source, sourceMapURL);\n        }\n        boundCallback({\n            source: source,\n            generatedLine: mapping.generatedLine,\n            generatedColumn: mapping.generatedColumn,\n            originalLine: mapping.originalLine,\n            originalColumn: mapping.originalColumn,\n            name: mapping.name === null ? null : names.at(mapping.name)\n        });\n    }\n};\n/**\n * Returns all generated line and column information for the original source,\n * line, and column provided. If no column is provided, returns all mappings\n * corresponding to a either the line we are searching for or the next\n * closest line that has any mappings. Otherwise, returns all mappings\n * corresponding to the given line and either the column we are searching for\n * or the next closest column that has any offsets.\n *\n * The only argument is an object with the following properties:\n *\n *   - source: The filename of the original source.\n *   - line: The line number in the original source.  The line number is 1-based.\n *   - column: Optional. the column number in the original source.\n *    The column number is 0-based.\n *\n * and an array of objects is returned, each with the following properties:\n *\n *   - line: The line number in the generated source, or null.  The\n *    line number is 1-based.\n *   - column: The column number in the generated source, or null.\n *    The column number is 0-based.\n */ SourceMapConsumer.prototype.allGeneratedPositionsFor = function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {\n    var line = util.getArg(aArgs, 'line');\n    // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping\n    // returns the index of the closest mapping less than the needle. By\n    // setting needle.originalColumn to 0, we thus find the last mapping for\n    // the given line, provided such a mapping exists.\n    var needle = {\n        source: util.getArg(aArgs, 'source'),\n        originalLine: line,\n        originalColumn: util.getArg(aArgs, 'column', 0)\n    };\n    needle.source = this._findSourceIndex(needle.source);\n    if (needle.source < 0) {\n        return [];\n    }\n    var mappings = [];\n    var index = this._findMapping(needle, this._originalMappings, \"originalLine\", \"originalColumn\", util.compareByOriginalPositions, binarySearch.LEAST_UPPER_BOUND);\n    if (index >= 0) {\n        var mapping = this._originalMappings[index];\n        if (aArgs.column === undefined) {\n            var originalLine = mapping.originalLine;\n            // Iterate until either we run out of mappings, or we run into\n            // a mapping for a different line than the one we found. Since\n            // mappings are sorted, this is guaranteed to find all mappings for\n            // the line we found.\n            while(mapping && mapping.originalLine === originalLine){\n                mappings.push({\n                    line: util.getArg(mapping, 'generatedLine', null),\n                    column: util.getArg(mapping, 'generatedColumn', null),\n                    lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)\n                });\n                mapping = this._originalMappings[++index];\n            }\n        } else {\n            var originalColumn = mapping.originalColumn;\n            // Iterate until either we run out of mappings, or we run into\n            // a mapping for a different line than the one we were searching for.\n            // Since mappings are sorted, this is guaranteed to find all mappings for\n            // the line we are searching for.\n            while(mapping && mapping.originalLine === line && mapping.originalColumn == originalColumn){\n                mappings.push({\n                    line: util.getArg(mapping, 'generatedLine', null),\n                    column: util.getArg(mapping, 'generatedColumn', null),\n                    lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)\n                });\n                mapping = this._originalMappings[++index];\n            }\n        }\n    }\n    return mappings;\n};\nexports.SourceMapConsumer = SourceMapConsumer;\n/**\n * A BasicSourceMapConsumer instance represents a parsed source map which we can\n * query for information about the original file positions by giving it a file\n * position in the generated source.\n *\n * The first parameter is the raw source map (either as a JSON string, or\n * already parsed to an object). According to the spec, source maps have the\n * following attributes:\n *\n *   - version: Which version of the source map spec this map is following.\n *   - sources: An array of URLs to the original source files.\n *   - names: An array of identifiers which can be referrenced by individual mappings.\n *   - sourceRoot: Optional. The URL root from which all sources are relative.\n *   - sourcesContent: Optional. An array of contents of the original source files.\n *   - mappings: A string of base64 VLQs which contain the actual mappings.\n *   - file: Optional. The generated file this source map is associated with.\n *\n * Here is an example source map, taken from the source map spec[0]:\n *\n *     {\n *       version : 3,\n *       file: \"out.js\",\n *       sourceRoot : \"\",\n *       sources: [\"foo.js\", \"bar.js\"],\n *       names: [\"src\", \"maps\", \"are\", \"fun\"],\n *       mappings: \"AA,AB;;ABCDE;\"\n *     }\n *\n * The second parameter, if given, is a string whose value is the URL\n * at which the source map was found.  This URL is used to compute the\n * sources array.\n *\n * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#\n */ function BasicSourceMapConsumer(aSourceMap, aSourceMapURL) {\n    var sourceMap = aSourceMap;\n    if (typeof aSourceMap === 'string') {\n        sourceMap = util.parseSourceMapInput(aSourceMap);\n    }\n    var version = util.getArg(sourceMap, 'version');\n    var sources = util.getArg(sourceMap, 'sources');\n    // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which\n    // requires the array) to play nice here.\n    var names = util.getArg(sourceMap, 'names', []);\n    var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);\n    var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);\n    var mappings = util.getArg(sourceMap, 'mappings');\n    var file = util.getArg(sourceMap, 'file', null);\n    // Once again, Sass deviates from the spec and supplies the version as a\n    // string rather than a number, so we use loose equality checking here.\n    if (version != this._version) {\n        throw new Error('Unsupported version: ' + version);\n    }\n    if (sourceRoot) {\n        sourceRoot = util.normalize(sourceRoot);\n    }\n    sources = sources.map(String)// Some source maps produce relative source paths like \"./foo.js\" instead of\n    // \"foo.js\".  Normalize these first so that future comparisons will succeed.\n    // See bugzil.la/1090768.\n    .map(util.normalize)// Always ensure that absolute sources are internally stored relative to\n    // the source root, if the source root is absolute. Not doing this would\n    // be particularly problematic when the source root is a prefix of the\n    // source (valid, but why??). See github issue #199 and bugzil.la/1188982.\n    .map(function(source) {\n        return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source) ? util.relative(sourceRoot, source) : source;\n    });\n    // Pass `true` below to allow duplicate names and sources. While source maps\n    // are intended to be compressed and deduplicated, the TypeScript compiler\n    // sometimes generates source maps with duplicates in them. See Github issue\n    // #72 and bugzil.la/889492.\n    this._names = ArraySet.fromArray(names.map(String), true);\n    this._sources = ArraySet.fromArray(sources, true);\n    this._absoluteSources = this._sources.toArray().map(function(s) {\n        return util.computeSourceURL(sourceRoot, s, aSourceMapURL);\n    });\n    this.sourceRoot = sourceRoot;\n    this.sourcesContent = sourcesContent;\n    this._mappings = mappings;\n    this._sourceMapURL = aSourceMapURL;\n    this.file = file;\n}\nBasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);\nBasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;\n/**\n * Utility function to find the index of a source.  Returns -1 if not\n * found.\n */ BasicSourceMapConsumer.prototype._findSourceIndex = function(aSource) {\n    var relativeSource = aSource;\n    if (this.sourceRoot != null) {\n        relativeSource = util.relative(this.sourceRoot, relativeSource);\n    }\n    if (this._sources.has(relativeSource)) {\n        return this._sources.indexOf(relativeSource);\n    }\n    // Maybe aSource is an absolute URL as returned by |sources|.  In\n    // this case we can't simply undo the transform.\n    var i;\n    for(i = 0; i < this._absoluteSources.length; ++i){\n        if (this._absoluteSources[i] == aSource) {\n            return i;\n        }\n    }\n    return -1;\n};\n/**\n * Create a BasicSourceMapConsumer from a SourceMapGenerator.\n *\n * @param SourceMapGenerator aSourceMap\n *        The source map that will be consumed.\n * @param String aSourceMapURL\n *        The URL at which the source map can be found (optional)\n * @returns BasicSourceMapConsumer\n */ BasicSourceMapConsumer.fromSourceMap = function SourceMapConsumer_fromSourceMap(aSourceMap, aSourceMapURL) {\n    var smc = Object.create(BasicSourceMapConsumer.prototype);\n    var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);\n    var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);\n    smc.sourceRoot = aSourceMap._sourceRoot;\n    smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(), smc.sourceRoot);\n    smc.file = aSourceMap._file;\n    smc._sourceMapURL = aSourceMapURL;\n    smc._absoluteSources = smc._sources.toArray().map(function(s) {\n        return util.computeSourceURL(smc.sourceRoot, s, aSourceMapURL);\n    });\n    // Because we are modifying the entries (by converting string sources and\n    // names to indices into the sources and names ArraySets), we have to make\n    // a copy of the entry or else bad things happen. Shared mutable state\n    // strikes again! See github issue #191.\n    var generatedMappings = aSourceMap._mappings.toArray().slice();\n    var destGeneratedMappings = smc.__generatedMappings = [];\n    var destOriginalMappings = smc.__originalMappings = [];\n    for(var i = 0, length = generatedMappings.length; i < length; i++){\n        var srcMapping = generatedMappings[i];\n        var destMapping = new Mapping;\n        destMapping.generatedLine = srcMapping.generatedLine;\n        destMapping.generatedColumn = srcMapping.generatedColumn;\n        if (srcMapping.source) {\n            destMapping.source = sources.indexOf(srcMapping.source);\n            destMapping.originalLine = srcMapping.originalLine;\n            destMapping.originalColumn = srcMapping.originalColumn;\n            if (srcMapping.name) {\n                destMapping.name = names.indexOf(srcMapping.name);\n            }\n            destOriginalMappings.push(destMapping);\n        }\n        destGeneratedMappings.push(destMapping);\n    }\n    quickSort(smc.__originalMappings, util.compareByOriginalPositions);\n    return smc;\n};\n/**\n * The version of the source mapping spec that we are consuming.\n */ BasicSourceMapConsumer.prototype._version = 3;\n/**\n * The list of original sources.\n */ Object.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {\n    get: function() {\n        return this._absoluteSources.slice();\n    }\n});\n/**\n * Provide the JIT with a nice shape / hidden class.\n */ function Mapping() {\n    this.generatedLine = 0;\n    this.generatedColumn = 0;\n    this.source = null;\n    this.originalLine = null;\n    this.originalColumn = null;\n    this.name = null;\n}\n/**\n * Parse the mappings in a string in to a data structure which we can easily\n * query (the ordered arrays in the `this.__generatedMappings` and\n * `this.__originalMappings` properties).\n */ const compareGenerated = util.compareByGeneratedPositionsDeflatedNoLine;\nfunction sortGenerated(array, start) {\n    let l = array.length;\n    let n = array.length - start;\n    if (n <= 1) {\n        return;\n    } else if (n == 2) {\n        let a = array[start];\n        let b = array[start + 1];\n        if (compareGenerated(a, b) > 0) {\n            array[start] = b;\n            array[start + 1] = a;\n        }\n    } else if (n < 20) {\n        for(let i = start; i < l; i++){\n            for(let j = i; j > start; j--){\n                let a = array[j - 1];\n                let b = array[j];\n                if (compareGenerated(a, b) <= 0) {\n                    break;\n                }\n                array[j - 1] = b;\n                array[j] = a;\n            }\n        }\n    } else {\n        quickSort(array, compareGenerated, start);\n    }\n}\nBasicSourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {\n    var generatedLine = 1;\n    var previousGeneratedColumn = 0;\n    var previousOriginalLine = 0;\n    var previousOriginalColumn = 0;\n    var previousSource = 0;\n    var previousName = 0;\n    var length = aStr.length;\n    var index = 0;\n    var cachedSegments = {};\n    var temp = {};\n    var originalMappings = [];\n    var generatedMappings = [];\n    var mapping, str, segment, end, value;\n    let subarrayStart = 0;\n    while(index < length){\n        if (aStr.charAt(index) === ';') {\n            generatedLine++;\n            index++;\n            previousGeneratedColumn = 0;\n            sortGenerated(generatedMappings, subarrayStart);\n            subarrayStart = generatedMappings.length;\n        } else if (aStr.charAt(index) === ',') {\n            index++;\n        } else {\n            mapping = new Mapping();\n            mapping.generatedLine = generatedLine;\n            for(end = index; end < length; end++){\n                if (this._charIsMappingSeparator(aStr, end)) {\n                    break;\n                }\n            }\n            str = aStr.slice(index, end);\n            segment = [];\n            while(index < end){\n                base64VLQ.decode(aStr, index, temp);\n                value = temp.value;\n                index = temp.rest;\n                segment.push(value);\n            }\n            if (segment.length === 2) {\n                throw new Error('Found a source, but no line and column');\n            }\n            if (segment.length === 3) {\n                throw new Error('Found a source and line, but no column');\n            }\n            // Generated column.\n            mapping.generatedColumn = previousGeneratedColumn + segment[0];\n            previousGeneratedColumn = mapping.generatedColumn;\n            if (segment.length > 1) {\n                // Original source.\n                mapping.source = previousSource + segment[1];\n                previousSource += segment[1];\n                // Original line.\n                mapping.originalLine = previousOriginalLine + segment[2];\n                previousOriginalLine = mapping.originalLine;\n                // Lines are stored 0-based\n                mapping.originalLine += 1;\n                // Original column.\n                mapping.originalColumn = previousOriginalColumn + segment[3];\n                previousOriginalColumn = mapping.originalColumn;\n                if (segment.length > 4) {\n                    // Original name.\n                    mapping.name = previousName + segment[4];\n                    previousName += segment[4];\n                }\n            }\n            generatedMappings.push(mapping);\n            if (typeof mapping.originalLine === 'number') {\n                let currentSource = mapping.source;\n                while(originalMappings.length <= currentSource){\n                    originalMappings.push(null);\n                }\n                if (originalMappings[currentSource] === null) {\n                    originalMappings[currentSource] = [];\n                }\n                originalMappings[currentSource].push(mapping);\n            }\n        }\n    }\n    sortGenerated(generatedMappings, subarrayStart);\n    this.__generatedMappings = generatedMappings;\n    for(var i = 0; i < originalMappings.length; i++){\n        if (originalMappings[i] != null) {\n            quickSort(originalMappings[i], util.compareByOriginalPositionsNoSource);\n        }\n    }\n    this.__originalMappings = [].concat(...originalMappings);\n};\n/**\n * Find the mapping that best matches the hypothetical \"needle\" mapping that\n * we are searching for in the given \"haystack\" of mappings.\n */ BasicSourceMapConsumer.prototype._findMapping = function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName, aColumnName, aComparator, aBias) {\n    // To return the position we are searching for, we must first find the\n    // mapping for the given position and then return the opposite position it\n    // points to. Because the mappings are sorted, we can use binary search to\n    // find the best mapping.\n    if (aNeedle[aLineName] <= 0) {\n        throw new TypeError('Line must be greater than or equal to 1, got ' + aNeedle[aLineName]);\n    }\n    if (aNeedle[aColumnName] < 0) {\n        throw new TypeError('Column must be greater than or equal to 0, got ' + aNeedle[aColumnName]);\n    }\n    return binarySearch.search(aNeedle, aMappings, aComparator, aBias);\n};\n/**\n * Compute the last column for each generated mapping. The last column is\n * inclusive.\n */ BasicSourceMapConsumer.prototype.computeColumnSpans = function SourceMapConsumer_computeColumnSpans() {\n    for(var index = 0; index < this._generatedMappings.length; ++index){\n        var mapping = this._generatedMappings[index];\n        // Mappings do not contain a field for the last generated columnt. We\n        // can come up with an optimistic estimate, however, by assuming that\n        // mappings are contiguous (i.e. given two consecutive mappings, the\n        // first mapping ends where the second one starts).\n        if (index + 1 < this._generatedMappings.length) {\n            var nextMapping = this._generatedMappings[index + 1];\n            if (mapping.generatedLine === nextMapping.generatedLine) {\n                mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;\n                continue;\n            }\n        }\n        // The last mapping for each line spans the entire line.\n        mapping.lastGeneratedColumn = Infinity;\n    }\n};\n/**\n * Returns the original source, line, and column information for the generated\n * source's line and column positions provided. The only argument is an object\n * with the following properties:\n *\n *   - line: The line number in the generated source.  The line number\n *     is 1-based.\n *   - column: The column number in the generated source.  The column\n *     number is 0-based.\n *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or\n *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the\n *     closest element that is smaller than or greater than the one we are\n *     searching for, respectively, if the exact element cannot be found.\n *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.\n *\n * and an object is returned with the following properties:\n *\n *   - source: The original source file, or null.\n *   - line: The line number in the original source, or null.  The\n *     line number is 1-based.\n *   - column: The column number in the original source, or null.  The\n *     column number is 0-based.\n *   - name: The original identifier, or null.\n */ BasicSourceMapConsumer.prototype.originalPositionFor = function SourceMapConsumer_originalPositionFor(aArgs) {\n    var needle = {\n        generatedLine: util.getArg(aArgs, 'line'),\n        generatedColumn: util.getArg(aArgs, 'column')\n    };\n    var index = this._findMapping(needle, this._generatedMappings, \"generatedLine\", \"generatedColumn\", util.compareByGeneratedPositionsDeflated, util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND));\n    if (index >= 0) {\n        var mapping = this._generatedMappings[index];\n        if (mapping.generatedLine === needle.generatedLine) {\n            var source = util.getArg(mapping, 'source', null);\n            if (source !== null) {\n                source = this._sources.at(source);\n                source = util.computeSourceURL(this.sourceRoot, source, this._sourceMapURL);\n            }\n            var name = util.getArg(mapping, 'name', null);\n            if (name !== null) {\n                name = this._names.at(name);\n            }\n            return {\n                source: source,\n                line: util.getArg(mapping, 'originalLine', null),\n                column: util.getArg(mapping, 'originalColumn', null),\n                name: name\n            };\n        }\n    }\n    return {\n        source: null,\n        line: null,\n        column: null,\n        name: null\n    };\n};\n/**\n * Return true if we have the source content for every source in the source\n * map, false otherwise.\n */ BasicSourceMapConsumer.prototype.hasContentsOfAllSources = function BasicSourceMapConsumer_hasContentsOfAllSources() {\n    if (!this.sourcesContent) {\n        return false;\n    }\n    return this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function(sc) {\n        return sc == null;\n    });\n};\n/**\n * Returns the original source content. The only argument is the url of the\n * original source file. Returns null if no original source content is\n * available.\n */ BasicSourceMapConsumer.prototype.sourceContentFor = function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {\n    if (!this.sourcesContent) {\n        return null;\n    }\n    var index = this._findSourceIndex(aSource);\n    if (index >= 0) {\n        return this.sourcesContent[index];\n    }\n    var relativeSource = aSource;\n    if (this.sourceRoot != null) {\n        relativeSource = util.relative(this.sourceRoot, relativeSource);\n    }\n    var url;\n    if (this.sourceRoot != null && (url = util.urlParse(this.sourceRoot))) {\n        // XXX: file:// URIs and absolute paths lead to unexpected behavior for\n        // many users. We can help them out when they expect file:// URIs to\n        // behave like it would if they were running a local HTTP server. See\n        // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.\n        var fileUriAbsPath = relativeSource.replace(/^file:\\/\\//, \"\");\n        if (url.scheme == \"file\" && this._sources.has(fileUriAbsPath)) {\n            return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];\n        }\n        if ((!url.path || url.path == \"/\") && this._sources.has(\"/\" + relativeSource)) {\n            return this.sourcesContent[this._sources.indexOf(\"/\" + relativeSource)];\n        }\n    }\n    // This function is used recursively from\n    // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we\n    // don't want to throw if we can't find the source - we just want to\n    // return null, so we provide a flag to exit gracefully.\n    if (nullOnMissing) {\n        return null;\n    } else {\n        throw new Error('\"' + relativeSource + '\" is not in the SourceMap.');\n    }\n};\n/**\n * Returns the generated line and column information for the original source,\n * line, and column positions provided. The only argument is an object with\n * the following properties:\n *\n *   - source: The filename of the original source.\n *   - line: The line number in the original source.  The line number\n *     is 1-based.\n *   - column: The column number in the original source.  The column\n *     number is 0-based.\n *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or\n *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the\n *     closest element that is smaller than or greater than the one we are\n *     searching for, respectively, if the exact element cannot be found.\n *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.\n *\n * and an object is returned with the following properties:\n *\n *   - line: The line number in the generated source, or null.  The\n *     line number is 1-based.\n *   - column: The column number in the generated source, or null.\n *     The column number is 0-based.\n */ BasicSourceMapConsumer.prototype.generatedPositionFor = function SourceMapConsumer_generatedPositionFor(aArgs) {\n    var source = util.getArg(aArgs, 'source');\n    source = this._findSourceIndex(source);\n    if (source < 0) {\n        return {\n            line: null,\n            column: null,\n            lastColumn: null\n        };\n    }\n    var needle = {\n        source: source,\n        originalLine: util.getArg(aArgs, 'line'),\n        originalColumn: util.getArg(aArgs, 'column')\n    };\n    var index = this._findMapping(needle, this._originalMappings, \"originalLine\", \"originalColumn\", util.compareByOriginalPositions, util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND));\n    if (index >= 0) {\n        var mapping = this._originalMappings[index];\n        if (mapping.source === needle.source) {\n            return {\n                line: util.getArg(mapping, 'generatedLine', null),\n                column: util.getArg(mapping, 'generatedColumn', null),\n                lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)\n            };\n        }\n    }\n    return {\n        line: null,\n        column: null,\n        lastColumn: null\n    };\n};\nexports.BasicSourceMapConsumer = BasicSourceMapConsumer;\n/**\n * An IndexedSourceMapConsumer instance represents a parsed source map which\n * we can query for information. It differs from BasicSourceMapConsumer in\n * that it takes \"indexed\" source maps (i.e. ones with a \"sections\" field) as\n * input.\n *\n * The first parameter is a raw source map (either as a JSON string, or already\n * parsed to an object). According to the spec for indexed source maps, they\n * have the following attributes:\n *\n *   - version: Which version of the source map spec this map is following.\n *   - file: Optional. The generated file this source map is associated with.\n *   - sections: A list of section definitions.\n *\n * Each value under the \"sections\" field has two fields:\n *   - offset: The offset into the original specified at which this section\n *       begins to apply, defined as an object with a \"line\" and \"column\"\n *       field.\n *   - map: A source map definition. This source map could also be indexed,\n *       but doesn't have to be.\n *\n * Instead of the \"map\" field, it's also possible to have a \"url\" field\n * specifying a URL to retrieve a source map from, but that's currently\n * unsupported.\n *\n * Here's an example source map, taken from the source map spec[0], but\n * modified to omit a section which uses the \"url\" field.\n *\n *  {\n *    version : 3,\n *    file: \"app.js\",\n *    sections: [{\n *      offset: {line:100, column:10},\n *      map: {\n *        version : 3,\n *        file: \"section.js\",\n *        sources: [\"foo.js\", \"bar.js\"],\n *        names: [\"src\", \"maps\", \"are\", \"fun\"],\n *        mappings: \"AAAA,E;;ABCDE;\"\n *      }\n *    }],\n *  }\n *\n * The second parameter, if given, is a string whose value is the URL\n * at which the source map was found.  This URL is used to compute the\n * sources array.\n *\n * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt\n */ function IndexedSourceMapConsumer(aSourceMap, aSourceMapURL) {\n    var sourceMap = aSourceMap;\n    if (typeof aSourceMap === 'string') {\n        sourceMap = util.parseSourceMapInput(aSourceMap);\n    }\n    var version = util.getArg(sourceMap, 'version');\n    var sections = util.getArg(sourceMap, 'sections');\n    if (version != this._version) {\n        throw new Error('Unsupported version: ' + version);\n    }\n    this._sources = new ArraySet();\n    this._names = new ArraySet();\n    var lastOffset = {\n        line: -1,\n        column: 0\n    };\n    this._sections = sections.map(function(s) {\n        if (s.url) {\n            // The url field will require support for asynchronicity.\n            // See https://github.com/mozilla/source-map/issues/16\n            throw new Error('Support for url field in sections not implemented.');\n        }\n        var offset = util.getArg(s, 'offset');\n        var offsetLine = util.getArg(offset, 'line');\n        var offsetColumn = util.getArg(offset, 'column');\n        if (offsetLine < lastOffset.line || offsetLine === lastOffset.line && offsetColumn < lastOffset.column) {\n            throw new Error('Section offsets must be ordered and non-overlapping.');\n        }\n        lastOffset = offset;\n        return {\n            generatedOffset: {\n                // The offset fields are 0-based, but we use 1-based indices when\n                // encoding/decoding from VLQ.\n                generatedLine: offsetLine + 1,\n                generatedColumn: offsetColumn + 1\n            },\n            consumer: new SourceMapConsumer(util.getArg(s, 'map'), aSourceMapURL)\n        };\n    });\n}\nIndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);\nIndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;\n/**\n * The version of the source mapping spec that we are consuming.\n */ IndexedSourceMapConsumer.prototype._version = 3;\n/**\n * The list of original sources.\n */ Object.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {\n    get: function() {\n        var sources = [];\n        for(var i = 0; i < this._sections.length; i++){\n            for(var j = 0; j < this._sections[i].consumer.sources.length; j++){\n                sources.push(this._sections[i].consumer.sources[j]);\n            }\n        }\n        return sources;\n    }\n});\n/**\n * Returns the original source, line, and column information for the generated\n * source's line and column positions provided. The only argument is an object\n * with the following properties:\n *\n *   - line: The line number in the generated source.  The line number\n *     is 1-based.\n *   - column: The column number in the generated source.  The column\n *     number is 0-based.\n *\n * and an object is returned with the following properties:\n *\n *   - source: The original source file, or null.\n *   - line: The line number in the original source, or null.  The\n *     line number is 1-based.\n *   - column: The column number in the original source, or null.  The\n *     column number is 0-based.\n *   - name: The original identifier, or null.\n */ IndexedSourceMapConsumer.prototype.originalPositionFor = function IndexedSourceMapConsumer_originalPositionFor(aArgs) {\n    var needle = {\n        generatedLine: util.getArg(aArgs, 'line'),\n        generatedColumn: util.getArg(aArgs, 'column')\n    };\n    // Find the section containing the generated position we're trying to map\n    // to an original position.\n    var sectionIndex = binarySearch.search(needle, this._sections, function(needle, section) {\n        var cmp = needle.generatedLine - section.generatedOffset.generatedLine;\n        if (cmp) {\n            return cmp;\n        }\n        return needle.generatedColumn - section.generatedOffset.generatedColumn;\n    });\n    var section = this._sections[sectionIndex];\n    if (!section) {\n        return {\n            source: null,\n            line: null,\n            column: null,\n            name: null\n        };\n    }\n    return section.consumer.originalPositionFor({\n        line: needle.generatedLine - (section.generatedOffset.generatedLine - 1),\n        column: needle.generatedColumn - (section.generatedOffset.generatedLine === needle.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),\n        bias: aArgs.bias\n    });\n};\n/**\n * Return true if we have the source content for every source in the source\n * map, false otherwise.\n */ IndexedSourceMapConsumer.prototype.hasContentsOfAllSources = function IndexedSourceMapConsumer_hasContentsOfAllSources() {\n    return this._sections.every(function(s) {\n        return s.consumer.hasContentsOfAllSources();\n    });\n};\n/**\n * Returns the original source content. The only argument is the url of the\n * original source file. Returns null if no original source content is\n * available.\n */ IndexedSourceMapConsumer.prototype.sourceContentFor = function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {\n    for(var i = 0; i < this._sections.length; i++){\n        var section = this._sections[i];\n        var content = section.consumer.sourceContentFor(aSource, true);\n        if (content || content === '') {\n            return content;\n        }\n    }\n    if (nullOnMissing) {\n        return null;\n    } else {\n        throw new Error('\"' + aSource + '\" is not in the SourceMap.');\n    }\n};\n/**\n * Returns the generated line and column information for the original source,\n * line, and column positions provided. The only argument is an object with\n * the following properties:\n *\n *   - source: The filename of the original source.\n *   - line: The line number in the original source.  The line number\n *     is 1-based.\n *   - column: The column number in the original source.  The column\n *     number is 0-based.\n *\n * and an object is returned with the following properties:\n *\n *   - line: The line number in the generated source, or null.  The\n *     line number is 1-based. \n *   - column: The column number in the generated source, or null.\n *     The column number is 0-based.\n */ IndexedSourceMapConsumer.prototype.generatedPositionFor = function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {\n    for(var i = 0; i < this._sections.length; i++){\n        var section = this._sections[i];\n        // Only consider this section if the requested source is in the list of\n        // sources of the consumer.\n        if (section.consumer._findSourceIndex(util.getArg(aArgs, 'source')) === -1) {\n            continue;\n        }\n        var generatedPosition = section.consumer.generatedPositionFor(aArgs);\n        if (generatedPosition) {\n            var ret = {\n                line: generatedPosition.line + (section.generatedOffset.generatedLine - 1),\n                column: generatedPosition.column + (section.generatedOffset.generatedLine === generatedPosition.line ? section.generatedOffset.generatedColumn - 1 : 0)\n            };\n            return ret;\n        }\n    }\n    return {\n        line: null,\n        column: null\n    };\n};\n/**\n * Parse the mappings in a string in to a data structure which we can easily\n * query (the ordered arrays in the `this.__generatedMappings` and\n * `this.__originalMappings` properties).\n */ IndexedSourceMapConsumer.prototype._parseMappings = function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {\n    this.__generatedMappings = [];\n    this.__originalMappings = [];\n    for(var i = 0; i < this._sections.length; i++){\n        var section = this._sections[i];\n        var sectionMappings = section.consumer._generatedMappings;\n        for(var j = 0; j < sectionMappings.length; j++){\n            var mapping = sectionMappings[j];\n            var source = section.consumer._sources.at(mapping.source);\n            if (source !== null) {\n                source = util.computeSourceURL(section.consumer.sourceRoot, source, this._sourceMapURL);\n            }\n            this._sources.add(source);\n            source = this._sources.indexOf(source);\n            var name = null;\n            if (mapping.name) {\n                name = section.consumer._names.at(mapping.name);\n                this._names.add(name);\n                name = this._names.indexOf(name);\n            }\n            // The mappings coming from the consumer for the section have\n            // generated positions relative to the start of the section, so we\n            // need to offset them to be relative to the start of the concatenated\n            // generated file.\n            var adjustedMapping = {\n                source: source,\n                generatedLine: mapping.generatedLine + (section.generatedOffset.generatedLine - 1),\n                generatedColumn: mapping.generatedColumn + (section.generatedOffset.generatedLine === mapping.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),\n                originalLine: mapping.originalLine,\n                originalColumn: mapping.originalColumn,\n                name: name\n            };\n            this.__generatedMappings.push(adjustedMapping);\n            if (typeof adjustedMapping.originalLine === 'number') {\n                this.__originalMappings.push(adjustedMapping);\n            }\n        }\n    }\n    quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);\n    quickSort(this.__originalMappings, util.compareByOriginalPositions);\n};\nexports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;\n}}),\n\"[project]/node_modules/source-map-js/lib/source-node.js [postcss] (ecmascript)\": (function(__turbopack_context__) {\n\nvar { g: global, __dirname, m: module, e: exports } = __turbopack_context__;\n{\n/* -*- Mode: js; js-indent-level: 2; -*- */ /*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */ var SourceMapGenerator = __turbopack_context__.r(\"[project]/node_modules/source-map-js/lib/source-map-generator.js [postcss] (ecmascript)\").SourceMapGenerator;\nvar util = __turbopack_context__.r(\"[project]/node_modules/source-map-js/lib/util.js [postcss] (ecmascript)\");\n// Matches a Windows-style `\\r\\n` newline or a `\\n` newline used by all other\n// operating systems these days (capturing the result).\nvar REGEX_NEWLINE = /(\\r?\\n)/;\n// Newline character code for charCodeAt() comparisons\nvar NEWLINE_CODE = 10;\n// Private symbol for identifying `SourceNode`s when multiple versions of\n// the source-map library are loaded. This MUST NOT CHANGE across\n// versions!\nvar isSourceNode = \"$$$isSourceNode$$$\";\n/**\n * SourceNodes provide a way to abstract over interpolating/concatenating\n * snippets of generated JavaScript source code while maintaining the line and\n * column information associated with the original source code.\n *\n * @param aLine The original line number.\n * @param aColumn The original column number.\n * @param aSource The original source's filename.\n * @param aChunks Optional. An array of strings which are snippets of\n *        generated JS, or other SourceNodes.\n * @param aName The original identifier.\n */ function SourceNode(aLine, aColumn, aSource, aChunks, aName) {\n    this.children = [];\n    this.sourceContents = {};\n    this.line = aLine == null ? null : aLine;\n    this.column = aColumn == null ? null : aColumn;\n    this.source = aSource == null ? null : aSource;\n    this.name = aName == null ? null : aName;\n    this[isSourceNode] = true;\n    if (aChunks != null) this.add(aChunks);\n}\n/**\n * Creates a SourceNode from generated code and a SourceMapConsumer.\n *\n * @param aGeneratedCode The generated code\n * @param aSourceMapConsumer The SourceMap for the generated code\n * @param aRelativePath Optional. The path that relative sources in the\n *        SourceMapConsumer should be relative to.\n */ SourceNode.fromStringWithSourceMap = function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {\n    // The SourceNode we want to fill with the generated code\n    // and the SourceMap\n    var node = new SourceNode();\n    // All even indices of this array are one line of the generated code,\n    // while all odd indices are the newlines between two adjacent lines\n    // (since `REGEX_NEWLINE` captures its match).\n    // Processed fragments are accessed by calling `shiftNextLine`.\n    var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);\n    var remainingLinesIndex = 0;\n    var shiftNextLine = function() {\n        var lineContents = getNextLine();\n        // The last line of a file might not have a newline.\n        var newLine = getNextLine() || \"\";\n        return lineContents + newLine;\n        \"TURBOPACK unreachable\";\n        function getNextLine() {\n            return remainingLinesIndex < remainingLines.length ? remainingLines[remainingLinesIndex++] : undefined;\n        }\n    };\n    // We need to remember the position of \"remainingLines\"\n    var lastGeneratedLine = 1, lastGeneratedColumn = 0;\n    // The generate SourceNodes we need a code range.\n    // To extract it current and last mapping is used.\n    // Here we store the last mapping.\n    var lastMapping = null;\n    aSourceMapConsumer.eachMapping(function(mapping) {\n        if (lastMapping !== null) {\n            // We add the code from \"lastMapping\" to \"mapping\":\n            // First check if there is a new line in between.\n            if (lastGeneratedLine < mapping.generatedLine) {\n                // Associate first line with \"lastMapping\"\n                addMappingWithCode(lastMapping, shiftNextLine());\n                lastGeneratedLine++;\n                lastGeneratedColumn = 0;\n            // The remaining code is added without mapping\n            } else {\n                // There is no new line in between.\n                // Associate the code between \"lastGeneratedColumn\" and\n                // \"mapping.generatedColumn\" with \"lastMapping\"\n                var nextLine = remainingLines[remainingLinesIndex] || '';\n                var code = nextLine.substr(0, mapping.generatedColumn - lastGeneratedColumn);\n                remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn - lastGeneratedColumn);\n                lastGeneratedColumn = mapping.generatedColumn;\n                addMappingWithCode(lastMapping, code);\n                // No more remaining code, continue\n                lastMapping = mapping;\n                return;\n            }\n        }\n        // We add the generated code until the first mapping\n        // to the SourceNode without any mapping.\n        // Each line is added as separate string.\n        while(lastGeneratedLine < mapping.generatedLine){\n            node.add(shiftNextLine());\n            lastGeneratedLine++;\n        }\n        if (lastGeneratedColumn < mapping.generatedColumn) {\n            var nextLine = remainingLines[remainingLinesIndex] || '';\n            node.add(nextLine.substr(0, mapping.generatedColumn));\n            remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);\n            lastGeneratedColumn = mapping.generatedColumn;\n        }\n        lastMapping = mapping;\n    }, this);\n    // We have processed all mappings.\n    if (remainingLinesIndex < remainingLines.length) {\n        if (lastMapping) {\n            // Associate the remaining code in the current line with \"lastMapping\"\n            addMappingWithCode(lastMapping, shiftNextLine());\n        }\n        // and add the remaining lines without any mapping\n        node.add(remainingLines.splice(remainingLinesIndex).join(\"\"));\n    }\n    // Copy sourcesContent into SourceNode\n    aSourceMapConsumer.sources.forEach(function(sourceFile) {\n        var content = aSourceMapConsumer.sourceContentFor(sourceFile);\n        if (content != null) {\n            if (aRelativePath != null) {\n                sourceFile = util.join(aRelativePath, sourceFile);\n            }\n            node.setSourceContent(sourceFile, content);\n        }\n    });\n    return node;\n    \"TURBOPACK unreachable\";\n    function addMappingWithCode(mapping, code) {\n        if (mapping === null || mapping.source === undefined) {\n            node.add(code);\n        } else {\n            var source = aRelativePath ? util.join(aRelativePath, mapping.source) : mapping.source;\n            node.add(new SourceNode(mapping.originalLine, mapping.originalColumn, source, code, mapping.name));\n        }\n    }\n};\n/**\n * Add a chunk of generated JS to this source node.\n *\n * @param aChunk A string snippet of generated JS code, another instance of\n *        SourceNode, or an array where each member is one of those things.\n */ SourceNode.prototype.add = function SourceNode_add(aChunk) {\n    if (Array.isArray(aChunk)) {\n        aChunk.forEach(function(chunk) {\n            this.add(chunk);\n        }, this);\n    } else if (aChunk[isSourceNode] || typeof aChunk === \"string\") {\n        if (aChunk) {\n            this.children.push(aChunk);\n        }\n    } else {\n        throw new TypeError(\"Expected a SourceNode, string, or an array of SourceNodes and strings. Got \" + aChunk);\n    }\n    return this;\n};\n/**\n * Add a chunk of generated JS to the beginning of this source node.\n *\n * @param aChunk A string snippet of generated JS code, another instance of\n *        SourceNode, or an array where each member is one of those things.\n */ SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {\n    if (Array.isArray(aChunk)) {\n        for(var i = aChunk.length - 1; i >= 0; i--){\n            this.prepend(aChunk[i]);\n        }\n    } else if (aChunk[isSourceNode] || typeof aChunk === \"string\") {\n        this.children.unshift(aChunk);\n    } else {\n        throw new TypeError(\"Expected a SourceNode, string, or an array of SourceNodes and strings. Got \" + aChunk);\n    }\n    return this;\n};\n/**\n * Walk over the tree of JS snippets in this node and its children. The\n * walking function is called once for each snippet of JS and is passed that\n * snippet and the its original associated source's line/column location.\n *\n * @param aFn The traversal function.\n */ SourceNode.prototype.walk = function SourceNode_walk(aFn) {\n    var chunk;\n    for(var i = 0, len = this.children.length; i < len; i++){\n        chunk = this.children[i];\n        if (chunk[isSourceNode]) {\n            chunk.walk(aFn);\n        } else {\n            if (chunk !== '') {\n                aFn(chunk, {\n                    source: this.source,\n                    line: this.line,\n                    column: this.column,\n                    name: this.name\n                });\n            }\n        }\n    }\n};\n/**\n * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between\n * each of `this.children`.\n *\n * @param aSep The separator.\n */ SourceNode.prototype.join = function SourceNode_join(aSep) {\n    var newChildren;\n    var i;\n    var len = this.children.length;\n    if (len > 0) {\n        newChildren = [];\n        for(i = 0; i < len - 1; i++){\n            newChildren.push(this.children[i]);\n            newChildren.push(aSep);\n        }\n        newChildren.push(this.children[i]);\n        this.children = newChildren;\n    }\n    return this;\n};\n/**\n * Call String.prototype.replace on the very right-most source snippet. Useful\n * for trimming whitespace from the end of a source node, etc.\n *\n * @param aPattern The pattern to replace.\n * @param aReplacement The thing to replace the pattern with.\n */ SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {\n    var lastChild = this.children[this.children.length - 1];\n    if (lastChild[isSourceNode]) {\n        lastChild.replaceRight(aPattern, aReplacement);\n    } else if (typeof lastChild === 'string') {\n        this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);\n    } else {\n        this.children.push(''.replace(aPattern, aReplacement));\n    }\n    return this;\n};\n/**\n * Set the source content for a source file. This will be added to the SourceMapGenerator\n * in the sourcesContent field.\n *\n * @param aSourceFile The filename of the source file\n * @param aSourceContent The content of the source file\n */ SourceNode.prototype.setSourceContent = function SourceNode_setSourceContent(aSourceFile, aSourceContent) {\n    this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;\n};\n/**\n * Walk over the tree of SourceNodes. The walking function is called for each\n * source file content and is passed the filename and source content.\n *\n * @param aFn The traversal function.\n */ SourceNode.prototype.walkSourceContents = function SourceNode_walkSourceContents(aFn) {\n    for(var i = 0, len = this.children.length; i < len; i++){\n        if (this.children[i][isSourceNode]) {\n            this.children[i].walkSourceContents(aFn);\n        }\n    }\n    var sources = Object.keys(this.sourceContents);\n    for(var i = 0, len = sources.length; i < len; i++){\n        aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);\n    }\n};\n/**\n * Return the string representation of this source node. Walks over the tree\n * and concatenates all the various snippets together to one string.\n */ SourceNode.prototype.toString = function SourceNode_toString() {\n    var str = \"\";\n    this.walk(function(chunk) {\n        str += chunk;\n    });\n    return str;\n};\n/**\n * Returns the string representation of this source node along with a source\n * map.\n */ SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {\n    var generated = {\n        code: \"\",\n        line: 1,\n        column: 0\n    };\n    var map = new SourceMapGenerator(aArgs);\n    var sourceMappingActive = false;\n    var lastOriginalSource = null;\n    var lastOriginalLine = null;\n    var lastOriginalColumn = null;\n    var lastOriginalName = null;\n    this.walk(function(chunk, original) {\n        generated.code += chunk;\n        if (original.source !== null && original.line !== null && original.column !== null) {\n            if (lastOriginalSource !== original.source || lastOriginalLine !== original.line || lastOriginalColumn !== original.column || lastOriginalName !== original.name) {\n                map.addMapping({\n                    source: original.source,\n                    original: {\n                        line: original.line,\n                        column: original.column\n                    },\n                    generated: {\n                        line: generated.line,\n                        column: generated.column\n                    },\n                    name: original.name\n                });\n            }\n            lastOriginalSource = original.source;\n            lastOriginalLine = original.line;\n            lastOriginalColumn = original.column;\n            lastOriginalName = original.name;\n            sourceMappingActive = true;\n        } else if (sourceMappingActive) {\n            map.addMapping({\n                generated: {\n                    line: generated.line,\n                    column: generated.column\n                }\n            });\n            lastOriginalSource = null;\n            sourceMappingActive = false;\n        }\n        for(var idx = 0, length = chunk.length; idx < length; idx++){\n            if (chunk.charCodeAt(idx) === NEWLINE_CODE) {\n                generated.line++;\n                generated.column = 0;\n                // Mappings end at eol\n                if (idx + 1 === length) {\n                    lastOriginalSource = null;\n                    sourceMappingActive = false;\n                } else if (sourceMappingActive) {\n                    map.addMapping({\n                        source: original.source,\n                        original: {\n                            line: original.line,\n                            column: original.column\n                        },\n                        generated: {\n                            line: generated.line,\n                            column: generated.column\n                        },\n                        name: original.name\n                    });\n                }\n            } else {\n                generated.column++;\n            }\n        }\n    });\n    this.walkSourceContents(function(sourceFile, sourceContent) {\n        map.setSourceContent(sourceFile, sourceContent);\n    });\n    return {\n        code: generated.code,\n        map: map\n    };\n};\nexports.SourceNode = SourceNode;\n}}),\n\"[project]/node_modules/source-map-js/source-map.js [postcss] (ecmascript)\": (function(__turbopack_context__) {\n\nvar { g: global, __dirname, m: module, e: exports } = __turbopack_context__;\n{\n/*\n * Copyright 2009-2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE.txt or:\n * http://opensource.org/licenses/BSD-3-Clause\n */ exports.SourceMapGenerator = __turbopack_context__.r(\"[project]/node_modules/source-map-js/lib/source-map-generator.js [postcss] (ecmascript)\").SourceMapGenerator;\nexports.SourceMapConsumer = __turbopack_context__.r(\"[project]/node_modules/source-map-js/lib/source-map-consumer.js [postcss] (ecmascript)\").SourceMapConsumer;\nexports.SourceNode = __turbopack_context__.r(\"[project]/node_modules/source-map-js/lib/source-node.js [postcss] (ecmascript)\").SourceNode;\n}}),\n\"[project]/node_modules/postcss/lib/previous-map.js [postcss] (ecmascript)\": (function(__turbopack_context__) {\n\nvar { g: global, __dirname, m: module, e: exports } = __turbopack_context__;\n{\n'use strict';\nlet { existsSync, readFileSync } = __turbopack_context__.r(\"[externals]/fs [external] (fs, cjs)\");\nlet { dirname, join } = __turbopack_context__.r(\"[externals]/path [external] (path, cjs)\");\nlet { SourceMapConsumer, SourceMapGenerator } = __turbopack_context__.r(\"[project]/node_modules/source-map-js/source-map.js [postcss] (ecmascript)\");\nfunction fromBase64(str) {\n    if (\"TURBOPACK compile-time truthy\", 1) {\n        return Buffer.from(str, 'base64').toString();\n    } else {\n        \"TURBOPACK unreachable\";\n    }\n}\nclass PreviousMap {\n    constructor(css, opts){\n        if (opts.map === false) return;\n        this.loadAnnotation(css);\n        this.inline = this.startWith(this.annotation, 'data:');\n        let prev = opts.map ? opts.map.prev : undefined;\n        let text = this.loadMap(opts.from, prev);\n        if (!this.mapFile && opts.from) {\n            this.mapFile = opts.from;\n        }\n        if (this.mapFile) this.root = dirname(this.mapFile);\n        if (text) this.text = text;\n    }\n    consumer() {\n        if (!this.consumerCache) {\n            this.consumerCache = new SourceMapConsumer(this.text);\n        }\n        return this.consumerCache;\n    }\n    decodeInline(text) {\n        let baseCharsetUri = /^data:application\\/json;charset=utf-?8;base64,/;\n        let baseUri = /^data:application\\/json;base64,/;\n        let charsetUri = /^data:application\\/json;charset=utf-?8,/;\n        let uri = /^data:application\\/json,/;\n        let uriMatch = text.match(charsetUri) || text.match(uri);\n        if (uriMatch) {\n            return decodeURIComponent(text.substr(uriMatch[0].length));\n        }\n        let baseUriMatch = text.match(baseCharsetUri) || text.match(baseUri);\n        if (baseUriMatch) {\n            return fromBase64(text.substr(baseUriMatch[0].length));\n        }\n        let encoding = text.match(/data:application\\/json;([^,]+),/)[1];\n        throw new Error('Unsupported source map encoding ' + encoding);\n    }\n    getAnnotationURL(sourceMapString) {\n        return sourceMapString.replace(/^\\/\\*\\s*# sourceMappingURL=/, '').trim();\n    }\n    isMap(map) {\n        if (typeof map !== 'object') return false;\n        return typeof map.mappings === 'string' || typeof map._mappings === 'string' || Array.isArray(map.sections);\n    }\n    loadAnnotation(css) {\n        let comments = css.match(/\\/\\*\\s*# sourceMappingURL=/g);\n        if (!comments) return;\n        // sourceMappingURLs from comments, strings, etc.\n        let start = css.lastIndexOf(comments.pop());\n        let end = css.indexOf('*/', start);\n        if (start > -1 && end > -1) {\n            // Locate the last sourceMappingURL to avoid pickin\n            this.annotation = this.getAnnotationURL(css.substring(start, end));\n        }\n    }\n    loadFile(path) {\n        this.root = dirname(path);\n        if (existsSync(path)) {\n            this.mapFile = path;\n            return readFileSync(path, 'utf-8').toString().trim();\n        }\n    }\n    loadMap(file, prev) {\n        if (prev === false) return false;\n        if (prev) {\n            if (typeof prev === 'string') {\n                return prev;\n            } else if (typeof prev === 'function') {\n                let prevPath = prev(file);\n                if (prevPath) {\n                    let map = this.loadFile(prevPath);\n                    if (!map) {\n                        throw new Error('Unable to load previous source map: ' + prevPath.toString());\n                    }\n                    return map;\n                }\n            } else if (prev instanceof SourceMapConsumer) {\n                return SourceMapGenerator.fromSourceMap(prev).toString();\n            } else if (prev instanceof SourceMapGenerator) {\n                return prev.toString();\n            } else if (this.isMap(prev)) {\n                return JSON.stringify(prev);\n            } else {\n                throw new Error('Unsupported previous source map format: ' + prev.toString());\n            }\n        } else if (this.inline) {\n            return this.decodeInline(this.annotation);\n        } else if (this.annotation) {\n            let map = this.annotation;\n            if (file) map = join(dirname(file), map);\n            return this.loadFile(map);\n        }\n    }\n    startWith(string, start) {\n        if (!string) return false;\n        return string.substr(0, start.length) === start;\n    }\n    withContent() {\n        return !!(this.consumer().sourcesContent && this.consumer().sourcesContent.length > 0);\n    }\n}\nmodule.exports = PreviousMap;\nPreviousMap.default = PreviousMap;\n}}),\n\"[project]/node_modules/postcss/lib/input.js [postcss] (ecmascript)\": (function(__turbopack_context__) {\n\nvar { g: global, __dirname, m: module, e: exports } = __turbopack_context__;\n{\n'use strict';\nlet { nanoid } = __turbopack_context__.r(\"[project]/node_modules/nanoid/non-secure/index.cjs [postcss] (ecmascript)\");\nlet { isAbsolute, resolve } = __turbopack_context__.r(\"[externals]/path [external] (path, cjs)\");\nlet { SourceMapConsumer, SourceMapGenerator } = __turbopack_context__.r(\"[project]/node_modules/source-map-js/source-map.js [postcss] (ecmascript)\");\nlet { fileURLToPath, pathToFileURL } = __turbopack_context__.r(\"[externals]/url [external] (url, cjs)\");\nlet CssSyntaxError = __turbopack_context__.r(\"[project]/node_modules/postcss/lib/css-syntax-error.js [postcss] (ecmascript)\");\nlet PreviousMap = __turbopack_context__.r(\"[project]/node_modules/postcss/lib/previous-map.js [postcss] (ecmascript)\");\nlet terminalHighlight = __turbopack_context__.r(\"[project]/node_modules/postcss/lib/terminal-highlight.js [postcss] (ecmascript)\");\nlet fromOffsetCache = Symbol('fromOffsetCache');\nlet sourceMapAvailable = Boolean(SourceMapConsumer && SourceMapGenerator);\nlet pathAvailable = Boolean(resolve && isAbsolute);\nclass Input {\n    get from() {\n        return this.file || this.id;\n    }\n    constructor(css, opts = {}){\n        if (css === null || typeof css === 'undefined' || typeof css === 'object' && !css.toString) {\n            throw new Error(`PostCSS received ${css} instead of CSS string`);\n        }\n        this.css = css.toString();\n        if (this.css[0] === '\\uFEFF' || this.css[0] === '\\uFFFE') {\n            this.hasBOM = true;\n            this.css = this.css.slice(1);\n        } else {\n            this.hasBOM = false;\n        }\n        this.document = this.css;\n        if (opts.document) this.document = opts.document.toString();\n        if (opts.from) {\n            if (!pathAvailable || /^\\w+:\\/\\//.test(opts.from) || isAbsolute(opts.from)) {\n                this.file = opts.from;\n            } else {\n                this.file = resolve(opts.from);\n            }\n        }\n        if (pathAvailable && sourceMapAvailable) {\n            let map = new PreviousMap(this.css, opts);\n            if (map.text) {\n                this.map = map;\n                let file = map.consumer().file;\n                if (!this.file && file) this.file = this.mapResolve(file);\n            }\n        }\n        if (!this.file) {\n            this.id = '<input css ' + nanoid(6) + '>';\n        }\n        if (this.map) this.map.file = this.from;\n    }\n    error(message, line, column, opts = {}) {\n        let endColumn, endLine, result;\n        if (line && typeof line === 'object') {\n            let start = line;\n            let end = column;\n            if (typeof start.offset === 'number') {\n                let pos = this.fromOffset(start.offset);\n                line = pos.line;\n                column = pos.col;\n            } else {\n                line = start.line;\n                column = start.column;\n            }\n            if (typeof end.offset === 'number') {\n                let pos = this.fromOffset(end.offset);\n                endLine = pos.line;\n                endColumn = pos.col;\n            } else {\n                endLine = end.line;\n                endColumn = end.column;\n            }\n        } else if (!column) {\n            let pos = this.fromOffset(line);\n            line = pos.line;\n            column = pos.col;\n        }\n        let origin = this.origin(line, column, endLine, endColumn);\n        if (origin) {\n            result = new CssSyntaxError(message, origin.endLine === undefined ? origin.line : {\n                column: origin.column,\n                line: origin.line\n            }, origin.endLine === undefined ? origin.column : {\n                column: origin.endColumn,\n                line: origin.endLine\n            }, origin.source, origin.file, opts.plugin);\n        } else {\n            result = new CssSyntaxError(message, endLine === undefined ? line : {\n                column,\n                line\n            }, endLine === undefined ? column : {\n                column: endColumn,\n                line: endLine\n            }, this.css, this.file, opts.plugin);\n        }\n        result.input = {\n            column,\n            endColumn,\n            endLine,\n            line,\n            source: this.css\n        };\n        if (this.file) {\n            if (pathToFileURL) {\n                result.input.url = pathToFileURL(this.file).toString();\n            }\n            result.input.file = this.file;\n        }\n        return result;\n    }\n    fromOffset(offset) {\n        let lastLine, lineToIndex;\n        if (!this[fromOffsetCache]) {\n            let lines = this.css.split('\\n');\n            lineToIndex = new Array(lines.length);\n            let prevIndex = 0;\n            for(let i = 0, l = lines.length; i < l; i++){\n                lineToIndex[i] = prevIndex;\n                prevIndex += lines[i].length + 1;\n            }\n            this[fromOffsetCache] = lineToIndex;\n        } else {\n            lineToIndex = this[fromOffsetCache];\n        }\n        lastLine = lineToIndex[lineToIndex.length - 1];\n        let min = 0;\n        if (offset >= lastLine) {\n            min = lineToIndex.length - 1;\n        } else {\n            let max = lineToIndex.length - 2;\n            let mid;\n            while(min < max){\n                mid = min + (max - min >> 1);\n                if (offset < lineToIndex[mid]) {\n                    max = mid - 1;\n                } else if (offset >= lineToIndex[mid + 1]) {\n                    min = mid + 1;\n                } else {\n                    min = mid;\n                    break;\n                }\n            }\n        }\n        return {\n            col: offset - lineToIndex[min] + 1,\n            line: min + 1\n        };\n    }\n    mapResolve(file) {\n        if (/^\\w+:\\/\\//.test(file)) {\n            return file;\n        }\n        return resolve(this.map.consumer().sourceRoot || this.map.root || '.', file);\n    }\n    origin(line, column, endLine, endColumn) {\n        if (!this.map) return false;\n        let consumer = this.map.consumer();\n        let from = consumer.originalPositionFor({\n            column,\n            line\n        });\n        if (!from.source) return false;\n        let to;\n        if (typeof endLine === 'number') {\n            to = consumer.originalPositionFor({\n                column: endColumn,\n                line: endLine\n            });\n        }\n        let fromUrl;\n        if (isAbsolute(from.source)) {\n            fromUrl = pathToFileURL(from.source);\n        } else {\n            fromUrl = new URL(from.source, this.map.consumer().sourceRoot || pathToFileURL(this.map.mapFile));\n        }\n        let result = {\n            column: from.column,\n            endColumn: to && to.column,\n            endLine: to && to.line,\n            line: from.line,\n            url: fromUrl.toString()\n        };\n        if (fromUrl.protocol === 'file:') {\n            if (fileURLToPath) {\n                result.file = fileURLToPath(fromUrl);\n            } else {\n                /* c8 ignore next 2 */ throw new Error(`file: protocol is not available in this PostCSS build`);\n            }\n        }\n        let source = consumer.sourceContentFor(from.source);\n        if (source) result.source = source;\n        return result;\n    }\n    toJSON() {\n        let json = {};\n        for (let name of [\n            'hasBOM',\n            'css',\n            'file',\n            'id'\n        ]){\n            if (this[name] != null) {\n                json[name] = this[name];\n            }\n        }\n        if (this.map) {\n            json.map = {\n                ...this.map\n            };\n            if (json.map.consumerCache) {\n                json.map.consumerCache = undefined;\n            }\n        }\n        return json;\n    }\n}\nmodule.exports = Input;\nInput.default = Input;\nif (terminalHighlight && terminalHighlight.registerInput) {\n    terminalHighlight.registerInput(Input);\n}\n}}),\n\"[project]/node_modules/postcss/lib/root.js [postcss] (ecmascript)\": (function(__turbopack_context__) {\n\nvar { g: global, __dirname, m: module, e: exports } = __turbopack_context__;\n{\n'use strict';\nlet Container = __turbopack_context__.r(\"[project]/node_modules/postcss/lib/container.js [postcss] (ecmascript)\");\nlet LazyResult, Processor;\nclass Root extends Container {\n    constructor(defaults){\n        super(defaults);\n        this.type = 'root';\n        if (!this.nodes) this.nodes = [];\n    }\n    normalize(child, sample, type) {\n        let nodes = super.normalize(child);\n        if (sample) {\n            if (type === 'prepend') {\n                if (this.nodes.length > 1) {\n                    sample.raws.before = this.nodes[1].raws.before;\n                } else {\n                    delete sample.raws.before;\n                }\n            } else if (this.first !== sample) {\n                for (let node of nodes){\n                    node.raws.before = sample.raws.before;\n                }\n            }\n        }\n        return nodes;\n    }\n    removeChild(child, ignore) {\n        let index = this.index(child);\n        if (!ignore && index === 0 && this.nodes.length > 1) {\n            this.nodes[1].raws.before = this.nodes[index].raws.before;\n        }\n        return super.removeChild(child);\n    }\n    toResult(opts = {}) {\n        let lazy = new LazyResult(new Processor(), this, opts);\n        return lazy.stringify();\n    }\n}\nRoot.registerLazyResult = (dependant)=>{\n    LazyResult = dependant;\n};\nRoot.registerProcessor = (dependant)=>{\n    Processor = dependant;\n};\nmodule.exports = Root;\nRoot.default = Root;\nContainer.registerRoot(Root);\n}}),\n\"[project]/node_modules/postcss/lib/list.js [postcss] (ecmascript)\": (function(__turbopack_context__) {\n\nvar { g: global, __dirname, m: module, e: exports } = __turbopack_context__;\n{\n'use strict';\nlet list = {\n    comma (string) {\n        return list.split(string, [\n            ','\n        ], true);\n    },\n    space (string) {\n        let spaces = [\n            ' ',\n            '\\n',\n            '\\t'\n        ];\n        return list.split(string, spaces);\n    },\n    split (string, separators, last) {\n        let array = [];\n        let current = '';\n        let split = false;\n        let func = 0;\n        let inQuote = false;\n        let prevQuote = '';\n        let escape = false;\n        for (let letter of string){\n            if (escape) {\n                escape = false;\n            } else if (letter === '\\\\') {\n                escape = true;\n            } else if (inQuote) {\n                if (letter === prevQuote) {\n                    inQuote = false;\n                }\n            } else if (letter === '\"' || letter === \"'\") {\n                inQuote = true;\n                prevQuote = letter;\n            } else if (letter === '(') {\n                func += 1;\n            } else if (letter === ')') {\n                if (func > 0) func -= 1;\n            } else if (func === 0) {\n                if (separators.includes(letter)) split = true;\n            }\n            if (split) {\n                if (current !== '') array.push(current.trim());\n                current = '';\n                split = false;\n            } else {\n                current += letter;\n            }\n        }\n        if (last || current !== '') array.push(current.trim());\n        return array;\n    }\n};\nmodule.exports = list;\nlist.default = list;\n}}),\n\"[project]/node_modules/postcss/lib/rule.js [postcss] (ecmascript)\": (function(__turbopack_context__) {\n\nvar { g: global, __dirname, m: module, e: exports } = __turbopack_context__;\n{\n'use strict';\nlet Container = __turbopack_context__.r(\"[project]/node_modules/postcss/lib/container.js [postcss] (ecmascript)\");\nlet list = __turbopack_context__.r(\"[project]/node_modules/postcss/lib/list.js [postcss] (ecmascript)\");\nclass Rule extends Container {\n    get selectors() {\n        return list.comma(this.selector);\n    }\n    set selectors(values) {\n        let match = this.selector ? this.selector.match(/,\\s*/) : null;\n        let sep = match ? match[0] : ',' + this.raw('between', 'beforeOpen');\n        this.selector = values.join(sep);\n    }\n    constructor(defaults){\n        super(defaults);\n        this.type = 'rule';\n        if (!this.nodes) this.nodes = [];\n    }\n}\nmodule.exports = Rule;\nRule.default = Rule;\nContainer.registerRule(Rule);\n}}),\n\"[project]/node_modules/postcss/lib/fromJSON.js [postcss] (ecmascript)\": (function(__turbopack_context__) {\n\nvar { g: global, __dirname, m: module, e: exports } = __turbopack_context__;\n{\n'use strict';\nlet AtRule = __turbopack_context__.r(\"[project]/node_modules/postcss/lib/at-rule.js [postcss] (ecmascript)\");\nlet Comment = __turbopack_context__.r(\"[project]/node_modules/postcss/lib/comment.js [postcss] (ecmascript)\");\nlet Declaration = __turbopack_context__.r(\"[project]/node_modules/postcss/lib/declaration.js [postcss] (ecmascript)\");\nlet Input = __turbopack_context__.r(\"[project]/node_modules/postcss/lib/input.js [postcss] (ecmascript)\");\nlet PreviousMap = __turbopack_context__.r(\"[project]/node_modules/postcss/lib/previous-map.js [postcss] (ecmascript)\");\nlet Root = __turbopack_context__.r(\"[project]/node_modules/postcss/lib/root.js [postcss] (ecmascript)\");\nlet Rule = __turbopack_context__.r(\"[project]/node_modules/postcss/lib/rule.js [postcss] (ecmascript)\");\nfunction fromJSON(json, inputs) {\n    if (Array.isArray(json)) return json.map((n)=>fromJSON(n));\n    let { inputs: ownInputs, ...defaults } = json;\n    if (ownInputs) {\n        inputs = [];\n        for (let input of ownInputs){\n            let inputHydrated = {\n                ...input,\n                __proto__: Input.prototype\n            };\n            if (inputHydrated.map) {\n                inputHydrated.map = {\n                    ...inputHydrated.map,\n                    __proto__: PreviousMap.prototype\n                };\n            }\n            inputs.push(inputHydrated);\n        }\n    }\n    if (defaults.nodes) {\n        defaults.nodes = json.nodes.map((n)=>fromJSON(n, inputs));\n    }\n    if (defaults.source) {\n        let { inputId, ...source } = defaults.source;\n        defaults.source = source;\n        if (inputId != null) {\n            defaults.source.input = inputs[inputId];\n        }\n    }\n    if (defaults.type === 'root') {\n        return new Root(defaults);\n    } else if (defaults.type === 'decl') {\n        return new Declaration(defaults);\n    } else if (defaults.type === 'rule') {\n        return new Rule(defaults);\n    } else if (defaults.type === 'comment') {\n        return new Comment(defaults);\n    } else if (defaults.type === 'atrule') {\n        return new AtRule(defaults);\n    } else {\n        throw new Error('Unknown node type: ' + json.type);\n    }\n}\nmodule.exports = fromJSON;\nfromJSON.default = fromJSON;\n}}),\n\"[project]/node_modules/postcss/lib/map-generator.js [postcss] (ecmascript)\": (function(__turbopack_context__) {\n\nvar { g: global, __dirname, m: module, e: exports } = __turbopack_context__;\n{\n'use strict';\nlet { dirname, relative, resolve, sep } = __turbopack_context__.r(\"[externals]/path [external] (path, cjs)\");\nlet { SourceMapConsumer, SourceMapGenerator } = __turbopack_context__.r(\"[project]/node_modules/source-map-js/source-map.js [postcss] (ecmascript)\");\nlet { pathToFileURL } = __turbopack_context__.r(\"[externals]/url [external] (url, cjs)\");\nlet Input = __turbopack_context__.r(\"[project]/node_modules/postcss/lib/input.js [postcss] (ecmascript)\");\nlet sourceMapAvailable = Boolean(SourceMapConsumer && SourceMapGenerator);\nlet pathAvailable = Boolean(dirname && resolve && relative && sep);\nclass MapGenerator {\n    constructor(stringify, root, opts, cssString){\n        this.stringify = stringify;\n        this.mapOpts = opts.map || {};\n        this.root = root;\n        this.opts = opts;\n        this.css = cssString;\n        this.originalCSS = cssString;\n        this.usesFileUrls = !this.mapOpts.from && this.mapOpts.absolute;\n        this.memoizedFileURLs = new Map();\n        this.memoizedPaths = new Map();\n        this.memoizedURLs = new Map();\n    }\n    addAnnotation() {\n        let content;\n        if (this.isInline()) {\n            content = 'data:application/json;base64,' + this.toBase64(this.map.toString());\n        } else if (typeof this.mapOpts.annotation === 'string') {\n            content = this.mapOpts.annotation;\n        } else if (typeof this.mapOpts.annotation === 'function') {\n            content = this.mapOpts.annotation(this.opts.to, this.root);\n        } else {\n            content = this.outputFile() + '.map';\n        }\n        let eol = '\\n';\n        if (this.css.includes('\\r\\n')) eol = '\\r\\n';\n        this.css += eol + '/*# sourceMappingURL=' + content + ' */';\n    }\n    applyPrevMaps() {\n        for (let prev of this.previous()){\n            let from = this.toUrl(this.path(prev.file));\n            let root = prev.root || dirname(prev.file);\n            let map;\n            if (this.mapOpts.sourcesContent === false) {\n                map = new SourceMapConsumer(prev.text);\n                if (map.sourcesContent) {\n                    map.sourcesContent = null;\n                }\n            } else {\n                map = prev.consumer();\n            }\n            this.map.applySourceMap(map, from, this.toUrl(this.path(root)));\n        }\n    }\n    clearAnnotation() {\n        if (this.mapOpts.annotation === false) return;\n        if (this.root) {\n            let node;\n            for(let i = this.root.nodes.length - 1; i >= 0; i--){\n                node = this.root.nodes[i];\n                if (node.type !== 'comment') continue;\n                if (node.text.startsWith('# sourceMappingURL=')) {\n                    this.root.removeChild(i);\n                }\n            }\n        } else if (this.css) {\n            this.css = this.css.replace(/\\n*\\/\\*#[\\S\\s]*?\\*\\/$/gm, '');\n        }\n    }\n    generate() {\n        this.clearAnnotation();\n        if (pathAvailable && sourceMapAvailable && this.isMap()) {\n            return this.generateMap();\n        } else {\n            let result = '';\n            this.stringify(this.root, (i)=>{\n                result += i;\n            });\n            return [\n                result\n            ];\n        }\n    }\n    generateMap() {\n        if (this.root) {\n            this.generateString();\n        } else if (this.previous().length === 1) {\n            let prev = this.previous()[0].consumer();\n            prev.file = this.outputFile();\n            this.map = SourceMapGenerator.fromSourceMap(prev, {\n                ignoreInvalidMapping: true\n            });\n        } else {\n            this.map = new SourceMapGenerator({\n                file: this.outputFile(),\n                ignoreInvalidMapping: true\n            });\n            this.map.addMapping({\n                generated: {\n                    column: 0,\n                    line: 1\n                },\n                original: {\n                    column: 0,\n                    line: 1\n                },\n                source: this.opts.from ? this.toUrl(this.path(this.opts.from)) : '<no source>'\n            });\n        }\n        if (this.isSourcesContent()) this.setSourcesContent();\n        if (this.root && this.previous().length > 0) this.applyPrevMaps();\n        if (this.isAnnotation()) this.addAnnotation();\n        if (this.isInline()) {\n            return [\n                this.css\n            ];\n        } else {\n            return [\n                this.css,\n                this.map\n            ];\n        }\n    }\n    generateString() {\n        this.css = '';\n        this.map = new SourceMapGenerator({\n            file: this.outputFile(),\n            ignoreInvalidMapping: true\n        });\n        let line = 1;\n        let column = 1;\n        let noSource = '<no source>';\n        let mapping = {\n            generated: {\n                column: 0,\n                line: 0\n            },\n            original: {\n                column: 0,\n                line: 0\n            },\n            source: ''\n        };\n        let last, lines;\n        this.stringify(this.root, (str, node, type)=>{\n            this.css += str;\n            if (node && type !== 'end') {\n                mapping.generated.line = line;\n                mapping.generated.column = column - 1;\n                if (node.source && node.source.start) {\n                    mapping.source = this.sourcePath(node);\n                    mapping.original.line = node.source.start.line;\n                    mapping.original.column = node.source.start.column - 1;\n                    this.map.addMapping(mapping);\n                } else {\n                    mapping.source = noSource;\n                    mapping.original.line = 1;\n                    mapping.original.column = 0;\n                    this.map.addMapping(mapping);\n                }\n            }\n            lines = str.match(/\\n/g);\n            if (lines) {\n                line += lines.length;\n                last = str.lastIndexOf('\\n');\n                column = str.length - last;\n            } else {\n                column += str.length;\n            }\n            if (node && type !== 'start') {\n                let p = node.parent || {\n                    raws: {}\n                };\n                let childless = node.type === 'decl' || node.type === 'atrule' && !node.nodes;\n                if (!childless || node !== p.last || p.raws.semicolon) {\n                    if (node.source && node.source.end) {\n                        mapping.source = this.sourcePath(node);\n                        mapping.original.line = node.source.end.line;\n                        mapping.original.column = node.source.end.column - 1;\n                        mapping.generated.line = line;\n                        mapping.generated.column = column - 2;\n                        this.map.addMapping(mapping);\n                    } else {\n                        mapping.source = noSource;\n                        mapping.original.line = 1;\n                        mapping.original.column = 0;\n                        mapping.generated.line = line;\n                        mapping.generated.column = column - 1;\n                        this.map.addMapping(mapping);\n                    }\n                }\n            }\n        });\n    }\n    isAnnotation() {\n        if (this.isInline()) {\n            return true;\n        }\n        if (typeof this.mapOpts.annotation !== 'undefined') {\n            return this.mapOpts.annotation;\n        }\n        if (this.previous().length) {\n            return this.previous().some((i)=>i.annotation);\n        }\n        return true;\n    }\n    isInline() {\n        if (typeof this.mapOpts.inline !== 'undefined') {\n            return this.mapOpts.inline;\n        }\n        let annotation = this.mapOpts.annotation;\n        if (typeof annotation !== 'undefined' && annotation !== true) {\n            return false;\n        }\n        if (this.previous().length) {\n            return this.previous().some((i)=>i.inline);\n        }\n        return true;\n    }\n    isMap() {\n        if (typeof this.opts.map !== 'undefined') {\n            return !!this.opts.map;\n        }\n        return this.previous().length > 0;\n    }\n    isSourcesContent() {\n        if (typeof this.mapOpts.sourcesContent !== 'undefined') {\n            return this.mapOpts.sourcesContent;\n        }\n        if (this.previous().length) {\n            return this.previous().some((i)=>i.withContent());\n        }\n        return true;\n    }\n    outputFile() {\n        if (this.opts.to) {\n            return this.path(this.opts.to);\n        } else if (this.opts.from) {\n            return this.path(this.opts.from);\n        } else {\n            return 'to.css';\n        }\n    }\n    path(file) {\n        if (this.mapOpts.absolute) return file;\n        if (file.charCodeAt(0) === 60 /* `<` */ ) return file;\n        if (/^\\w+:\\/\\//.test(file)) return file;\n        let cached = this.memoizedPaths.get(file);\n        if (cached) return cached;\n        let from = this.opts.to ? dirname(this.opts.to) : '.';\n        if (typeof this.mapOpts.annotation === 'string') {\n            from = dirname(resolve(from, this.mapOpts.annotation));\n        }\n        let path = relative(from, file);\n        this.memoizedPaths.set(file, path);\n        return path;\n    }\n    previous() {\n        if (!this.previousMaps) {\n            this.previousMaps = [];\n            if (this.root) {\n                this.root.walk((node)=>{\n                    if (node.source && node.source.input.map) {\n                        let map = node.source.input.map;\n                        if (!this.previousMaps.includes(map)) {\n                            this.previousMaps.push(map);\n                        }\n                    }\n                });\n            } else {\n                let input = new Input(this.originalCSS, this.opts);\n                if (input.map) this.previousMaps.push(input.map);\n            }\n        }\n        return this.previousMaps;\n    }\n    setSourcesContent() {\n        let already = {};\n        if (this.root) {\n            this.root.walk((node)=>{\n                if (node.source) {\n                    let from = node.source.input.from;\n                    if (from && !already[from]) {\n                        already[from] = true;\n                        let fromUrl = this.usesFileUrls ? this.toFileUrl(from) : this.toUrl(this.path(from));\n                        this.map.setSourceContent(fromUrl, node.source.input.css);\n                    }\n                }\n            });\n        } else if (this.css) {\n            let from = this.opts.from ? this.toUrl(this.path(this.opts.from)) : '<no source>';\n            this.map.setSourceContent(from, this.css);\n        }\n    }\n    sourcePath(node) {\n        if (this.mapOpts.from) {\n            return this.toUrl(this.mapOpts.from);\n        } else if (this.usesFileUrls) {\n            return this.toFileUrl(node.source.input.from);\n        } else {\n            return this.toUrl(this.path(node.source.input.from));\n        }\n    }\n    toBase64(str) {\n        if (\"TURBOPACK compile-time truthy\", 1) {\n            return Buffer.from(str).toString('base64');\n        } else {\n            \"TURBOPACK unreachable\";\n        }\n    }\n    toFileUrl(path) {\n        let cached = this.memoizedFileURLs.get(path);\n        if (cached) return cached;\n        if (pathToFileURL) {\n            let fileURL = pathToFileURL(path).toString();\n            this.memoizedFileURLs.set(path, fileURL);\n            return fileURL;\n        } else {\n            throw new Error('`map.absolute` option is not available in this PostCSS build');\n        }\n    }\n    toUrl(path) {\n        let cached = this.memoizedURLs.get(path);\n        if (cached) return cached;\n        if (sep === '\\\\') {\n            path = path.replace(/\\\\/g, '/');\n        }\n        let url = encodeURI(path).replace(/[#?]/g, encodeURIComponent);\n        this.memoizedURLs.set(path, url);\n        return url;\n    }\n}\nmodule.exports = MapGenerator;\n}}),\n\"[project]/node_modules/postcss/lib/parser.js [postcss] (ecmascript)\": (function(__turbopack_context__) {\n\nvar { g: global, __dirname, m: module, e: exports } = __turbopack_context__;\n{\n'use strict';\nlet AtRule = __turbopack_context__.r(\"[project]/node_modules/postcss/lib/at-rule.js [postcss] (ecmascript)\");\nlet Comment = __turbopack_context__.r(\"[project]/node_modules/postcss/lib/comment.js [postcss] (ecmascript)\");\nlet Declaration = __turbopack_context__.r(\"[project]/node_modules/postcss/lib/declaration.js [postcss] (ecmascript)\");\nlet Root = __turbopack_context__.r(\"[project]/node_modules/postcss/lib/root.js [postcss] (ecmascript)\");\nlet Rule = __turbopack_context__.r(\"[project]/node_modules/postcss/lib/rule.js [postcss] (ecmascript)\");\nlet tokenizer = __turbopack_context__.r(\"[project]/node_modules/postcss/lib/tokenize.js [postcss] (ecmascript)\");\nconst SAFE_COMMENT_NEIGHBOR = {\n    empty: true,\n    space: true\n};\nfunction findLastWithPosition(tokens) {\n    for(let i = tokens.length - 1; i >= 0; i--){\n        let token = tokens[i];\n        let pos = token[3] || token[2];\n        if (pos) return pos;\n    }\n}\nclass Parser {\n    constructor(input){\n        this.input = input;\n        this.root = new Root();\n        this.current = this.root;\n        this.spaces = '';\n        this.semicolon = false;\n        this.createTokenizer();\n        this.root.source = {\n            input,\n            start: {\n                column: 1,\n                line: 1,\n                offset: 0\n            }\n        };\n    }\n    atrule(token) {\n        let node = new AtRule();\n        node.name = token[1].slice(1);\n        if (node.name === '') {\n            this.unnamedAtrule(node, token);\n        }\n        this.init(node, token[2]);\n        let type;\n        let prev;\n        let shift;\n        let last = false;\n        let open = false;\n        let params = [];\n        let brackets = [];\n        while(!this.tokenizer.endOfFile()){\n            token = this.tokenizer.nextToken();\n            type = token[0];\n            if (type === '(' || type === '[') {\n                brackets.push(type === '(' ? ')' : ']');\n            } else if (type === '{' && brackets.length > 0) {\n                brackets.push('}');\n            } else if (type === brackets[brackets.length - 1]) {\n                brackets.pop();\n            }\n            if (brackets.length === 0) {\n                if (type === ';') {\n                    node.source.end = this.getPosition(token[2]);\n                    node.source.end.offset++;\n                    this.semicolon = true;\n                    break;\n                } else if (type === '{') {\n                    open = true;\n                    break;\n                } else if (type === '}') {\n                    if (params.length > 0) {\n                        shift = params.length - 1;\n                        prev = params[shift];\n                        while(prev && prev[0] === 'space'){\n                            prev = params[--shift];\n                        }\n                        if (prev) {\n                            node.source.end = this.getPosition(prev[3] || prev[2]);\n                            node.source.end.offset++;\n                        }\n                    }\n                    this.end(token);\n                    break;\n                } else {\n                    params.push(token);\n                }\n            } else {\n                params.push(token);\n            }\n            if (this.tokenizer.endOfFile()) {\n                last = true;\n                break;\n            }\n        }\n        node.raws.between = this.spacesAndCommentsFromEnd(params);\n        if (params.length) {\n            node.raws.afterName = this.spacesAndCommentsFromStart(params);\n            this.raw(node, 'params', params);\n            if (last) {\n                token = params[params.length - 1];\n                node.source.end = this.getPosition(token[3] || token[2]);\n                node.source.end.offset++;\n                this.spaces = node.raws.between;\n                node.raws.between = '';\n            }\n        } else {\n            node.raws.afterName = '';\n            node.params = '';\n        }\n        if (open) {\n            node.nodes = [];\n            this.current = node;\n        }\n    }\n    checkMissedSemicolon(tokens) {\n        let colon = this.colon(tokens);\n        if (colon === false) return;\n        let founded = 0;\n        let token;\n        for(let j = colon - 1; j >= 0; j--){\n            token = tokens[j];\n            if (token[0] !== 'space') {\n                founded += 1;\n                if (founded === 2) break;\n            }\n        }\n        // If the token is a word, e.g. `!important`, `red` or any other valid property's value.\n        // Then we need to return the colon after that word token. [3] is the \"end\" colon of that word.\n        // And because we need it after that one we do +1 to get the next one.\n        throw this.input.error('Missed semicolon', token[0] === 'word' ? token[3] + 1 : token[2]);\n    }\n    colon(tokens) {\n        let brackets = 0;\n        let prev, token, type;\n        for (let [i, element] of tokens.entries()){\n            token = element;\n            type = token[0];\n            if (type === '(') {\n                brackets += 1;\n            }\n            if (type === ')') {\n                brackets -= 1;\n            }\n            if (brackets === 0 && type === ':') {\n                if (!prev) {\n                    this.doubleColon(token);\n                } else if (prev[0] === 'word' && prev[1] === 'progid') {\n                    continue;\n                } else {\n                    return i;\n                }\n            }\n            prev = token;\n        }\n        return false;\n    }\n    comment(token) {\n        let node = new Comment();\n        this.init(node, token[2]);\n        node.source.end = this.getPosition(token[3] || token[2]);\n        node.source.end.offset++;\n        let text = token[1].slice(2, -2);\n        if (/^\\s*$/.test(text)) {\n            node.text = '';\n            node.raws.left = text;\n            node.raws.right = '';\n        } else {\n            let match = text.match(/^(\\s*)([^]*\\S)(\\s*)$/);\n            node.text = match[2];\n            node.raws.left = match[1];\n            node.raws.right = match[3];\n        }\n    }\n    createTokenizer() {\n        this.tokenizer = tokenizer(this.input);\n    }\n    decl(tokens, customProperty) {\n        let node = new Declaration();\n        this.init(node, tokens[0][2]);\n        let last = tokens[tokens.length - 1];\n        if (last[0] === ';') {\n            this.semicolon = true;\n            tokens.pop();\n        }\n        node.source.end = this.getPosition(last[3] || last[2] || findLastWithPosition(tokens));\n        node.source.end.offset++;\n        while(tokens[0][0] !== 'word'){\n            if (tokens.length === 1) this.unknownWord(tokens);\n            node.raws.before += tokens.shift()[1];\n        }\n        node.source.start = this.getPosition(tokens[0][2]);\n        node.prop = '';\n        while(tokens.length){\n            let type = tokens[0][0];\n            if (type === ':' || type === 'space' || type === 'comment') {\n                break;\n            }\n            node.prop += tokens.shift()[1];\n        }\n        node.raws.between = '';\n        let token;\n        while(tokens.length){\n            token = tokens.shift();\n            if (token[0] === ':') {\n                node.raws.between += token[1];\n                break;\n            } else {\n                if (token[0] === 'word' && /\\w/.test(token[1])) {\n                    this.unknownWord([\n                        token\n                    ]);\n                }\n                node.raws.between += token[1];\n            }\n        }\n        if (node.prop[0] === '_' || node.prop[0] === '*') {\n            node.raws.before += node.prop[0];\n            node.prop = node.prop.slice(1);\n        }\n        let firstSpaces = [];\n        let next;\n        while(tokens.length){\n            next = tokens[0][0];\n            if (next !== 'space' && next !== 'comment') break;\n            firstSpaces.push(tokens.shift());\n        }\n        this.precheckMissedSemicolon(tokens);\n        for(let i = tokens.length - 1; i >= 0; i--){\n            token = tokens[i];\n            if (token[1].toLowerCase() === '!important') {\n                node.important = true;\n                let string = this.stringFrom(tokens, i);\n                string = this.spacesFromEnd(tokens) + string;\n                if (string !== ' !important') node.raws.important = string;\n                break;\n            } else if (token[1].toLowerCase() === 'important') {\n                let cache = tokens.slice(0);\n                let str = '';\n                for(let j = i; j > 0; j--){\n                    let type = cache[j][0];\n                    if (str.trim().startsWith('!') && type !== 'space') {\n                        break;\n                    }\n                    str = cache.pop()[1] + str;\n                }\n                if (str.trim().startsWith('!')) {\n                    node.important = true;\n                    node.raws.important = str;\n                    tokens = cache;\n                }\n            }\n            if (token[0] !== 'space' && token[0] !== 'comment') {\n                break;\n            }\n        }\n        let hasWord = tokens.some((i)=>i[0] !== 'space' && i[0] !== 'comment');\n        if (hasWord) {\n            node.raws.between += firstSpaces.map((i)=>i[1]).join('');\n            firstSpaces = [];\n        }\n        this.raw(node, 'value', firstSpaces.concat(tokens), customProperty);\n        if (node.value.includes(':') && !customProperty) {\n            this.checkMissedSemicolon(tokens);\n        }\n    }\n    doubleColon(token) {\n        throw this.input.error('Double colon', {\n            offset: token[2]\n        }, {\n            offset: token[2] + token[1].length\n        });\n    }\n    emptyRule(token) {\n        let node = new Rule();\n        this.init(node, token[2]);\n        node.selector = '';\n        node.raws.between = '';\n        this.current = node;\n    }\n    end(token) {\n        if (this.current.nodes && this.current.nodes.length) {\n            this.current.raws.semicolon = this.semicolon;\n        }\n        this.semicolon = false;\n        this.current.raws.after = (this.current.raws.after || '') + this.spaces;\n        this.spaces = '';\n        if (this.current.parent) {\n            this.current.source.end = this.getPosition(token[2]);\n            this.current.source.end.offset++;\n            this.current = this.current.parent;\n        } else {\n            this.unexpectedClose(token);\n        }\n    }\n    endFile() {\n        if (this.current.parent) this.unclosedBlock();\n        if (this.current.nodes && this.current.nodes.length) {\n            this.current.raws.semicolon = this.semicolon;\n        }\n        this.current.raws.after = (this.current.raws.after || '') + this.spaces;\n        this.root.source.end = this.getPosition(this.tokenizer.position());\n    }\n    freeSemicolon(token) {\n        this.spaces += token[1];\n        if (this.current.nodes) {\n            let prev = this.current.nodes[this.current.nodes.length - 1];\n            if (prev && prev.type === 'rule' && !prev.raws.ownSemicolon) {\n                prev.raws.ownSemicolon = this.spaces;\n                this.spaces = '';\n                prev.source.end = this.getPosition(token[2]);\n                prev.source.end.offset += prev.raws.ownSemicolon.length;\n            }\n        }\n    }\n    // Helpers\n    getPosition(offset) {\n        let pos = this.input.fromOffset(offset);\n        return {\n            column: pos.col,\n            line: pos.line,\n            offset\n        };\n    }\n    init(node, offset) {\n        this.current.push(node);\n        node.source = {\n            input: this.input,\n            start: this.getPosition(offset)\n        };\n        node.raws.before = this.spaces;\n        this.spaces = '';\n        if (node.type !== 'comment') this.semicolon = false;\n    }\n    other(start) {\n        let end = false;\n        let type = null;\n        let colon = false;\n        let bracket = null;\n        let brackets = [];\n        let customProperty = start[1].startsWith('--');\n        let tokens = [];\n        let token = start;\n        while(token){\n            type = token[0];\n            tokens.push(token);\n            if (type === '(' || type === '[') {\n                if (!bracket) bracket = token;\n                brackets.push(type === '(' ? ')' : ']');\n            } else if (customProperty && colon && type === '{') {\n                if (!bracket) bracket = token;\n                brackets.push('}');\n            } else if (brackets.length === 0) {\n                if (type === ';') {\n                    if (colon) {\n                        this.decl(tokens, customProperty);\n                        return;\n                    } else {\n                        break;\n                    }\n                } else if (type === '{') {\n                    this.rule(tokens);\n                    return;\n                } else if (type === '}') {\n                    this.tokenizer.back(tokens.pop());\n                    end = true;\n                    break;\n                } else if (type === ':') {\n                    colon = true;\n                }\n            } else if (type === brackets[brackets.length - 1]) {\n                brackets.pop();\n                if (brackets.length === 0) bracket = null;\n            }\n            token = this.tokenizer.nextToken();\n        }\n        if (this.tokenizer.endOfFile()) end = true;\n        if (brackets.length > 0) this.unclosedBracket(bracket);\n        if (end && colon) {\n            if (!customProperty) {\n                while(tokens.length){\n                    token = tokens[tokens.length - 1][0];\n                    if (token !== 'space' && token !== 'comment') break;\n                    this.tokenizer.back(tokens.pop());\n                }\n            }\n            this.decl(tokens, customProperty);\n        } else {\n            this.unknownWord(tokens);\n        }\n    }\n    parse() {\n        let token;\n        while(!this.tokenizer.endOfFile()){\n            token = this.tokenizer.nextToken();\n            switch(token[0]){\n                case 'space':\n                    this.spaces += token[1];\n                    break;\n                case ';':\n                    this.freeSemicolon(token);\n                    break;\n                case '}':\n                    this.end(token);\n                    break;\n                case 'comment':\n                    this.comment(token);\n                    break;\n                case 'at-word':\n                    this.atrule(token);\n                    break;\n                case '{':\n                    this.emptyRule(token);\n                    break;\n                default:\n                    this.other(token);\n                    break;\n            }\n        }\n        this.endFile();\n    }\n    precheckMissedSemicolon() {\n    // Hook for Safe Parser\n    }\n    raw(node, prop, tokens, customProperty) {\n        let token, type;\n        let length = tokens.length;\n        let value = '';\n        let clean = true;\n        let next, prev;\n        for(let i = 0; i < length; i += 1){\n            token = tokens[i];\n            type = token[0];\n            if (type === 'space' && i === length - 1 && !customProperty) {\n                clean = false;\n            } else if (type === 'comment') {\n                prev = tokens[i - 1] ? tokens[i - 1][0] : 'empty';\n                next = tokens[i + 1] ? tokens[i + 1][0] : 'empty';\n                if (!SAFE_COMMENT_NEIGHBOR[prev] && !SAFE_COMMENT_NEIGHBOR[next]) {\n                    if (value.slice(-1) === ',') {\n                        clean = false;\n                    } else {\n                        value += token[1];\n                    }\n                } else {\n                    clean = false;\n                }\n            } else {\n                value += token[1];\n            }\n        }\n        if (!clean) {\n            let raw = tokens.reduce((all, i)=>all + i[1], '');\n            node.raws[prop] = {\n                raw,\n                value\n            };\n        }\n        node[prop] = value;\n    }\n    rule(tokens) {\n        tokens.pop();\n        let node = new Rule();\n        this.init(node, tokens[0][2]);\n        node.raws.between = this.spacesAndCommentsFromEnd(tokens);\n        this.raw(node, 'selector', tokens);\n        this.current = node;\n    }\n    spacesAndCommentsFromEnd(tokens) {\n        let lastTokenType;\n        let spaces = '';\n        while(tokens.length){\n            lastTokenType = tokens[tokens.length - 1][0];\n            if (lastTokenType !== 'space' && lastTokenType !== 'comment') break;\n            spaces = tokens.pop()[1] + spaces;\n        }\n        return spaces;\n    }\n    // Errors\n    spacesAndCommentsFromStart(tokens) {\n        let next;\n        let spaces = '';\n        while(tokens.length){\n            next = tokens[0][0];\n            if (next !== 'space' && next !== 'comment') break;\n            spaces += tokens.shift()[1];\n        }\n        return spaces;\n    }\n    spacesFromEnd(tokens) {\n        let lastTokenType;\n        let spaces = '';\n        while(tokens.length){\n            lastTokenType = tokens[tokens.length - 1][0];\n            if (lastTokenType !== 'space') break;\n            spaces = tokens.pop()[1] + spaces;\n        }\n        return spaces;\n    }\n    stringFrom(tokens, from) {\n        let result = '';\n        for(let i = from; i < tokens.length; i++){\n            result += tokens[i][1];\n        }\n        tokens.splice(from, tokens.length - from);\n        return result;\n    }\n    unclosedBlock() {\n        let pos = this.current.source.start;\n        throw this.input.error('Unclosed block', pos.line, pos.column);\n    }\n    unclosedBracket(bracket) {\n        throw this.input.error('Unclosed bracket', {\n            offset: bracket[2]\n        }, {\n            offset: bracket[2] + 1\n        });\n    }\n    unexpectedClose(token) {\n        throw this.input.error('Unexpected }', {\n            offset: token[2]\n        }, {\n            offset: token[2] + 1\n        });\n    }\n    unknownWord(tokens) {\n        throw this.input.error('Unknown word ' + tokens[0][1], {\n            offset: tokens[0][2]\n        }, {\n            offset: tokens[0][2] + tokens[0][1].length\n        });\n    }\n    unnamedAtrule(node, token) {\n        throw this.input.error('At-rule without name', {\n            offset: token[2]\n        }, {\n            offset: token[2] + token[1].length\n        });\n    }\n}\nmodule.exports = Parser;\n}}),\n\"[project]/node_modules/postcss/lib/parse.js [postcss] (ecmascript)\": (function(__turbopack_context__) {\n\nvar { g: global, __dirname, m: module, e: exports } = __turbopack_context__;\n{\n'use strict';\nlet Container = __turbopack_context__.r(\"[project]/node_modules/postcss/lib/container.js [postcss] (ecmascript)\");\nlet Input = __turbopack_context__.r(\"[project]/node_modules/postcss/lib/input.js [postcss] (ecmascript)\");\nlet Parser = __turbopack_context__.r(\"[project]/node_modules/postcss/lib/parser.js [postcss] (ecmascript)\");\nfunction parse(css, opts) {\n    let input = new Input(css, opts);\n    let parser = new Parser(input);\n    try {\n        parser.parse();\n    } catch (e) {\n        if (\"TURBOPACK compile-time truthy\", 1) {\n            if (e.name === 'CssSyntaxError' && opts && opts.from) {\n                if (/\\.scss$/i.test(opts.from)) {\n                    e.message += '\\nYou tried to parse SCSS with ' + 'the standard CSS parser; ' + 'try again with the postcss-scss parser';\n                } else if (/\\.sass/i.test(opts.from)) {\n                    e.message += '\\nYou tried to parse Sass with ' + 'the standard CSS parser; ' + 'try again with the postcss-sass parser';\n                } else if (/\\.less$/i.test(opts.from)) {\n                    e.message += '\\nYou tried to parse Less with ' + 'the standard CSS parser; ' + 'try again with the postcss-less parser';\n                }\n            }\n        }\n        throw e;\n    }\n    return parser.root;\n}\nmodule.exports = parse;\nparse.default = parse;\nContainer.registerParse(parse);\n}}),\n\"[project]/node_modules/postcss/lib/warning.js [postcss] (ecmascript)\": (function(__turbopack_context__) {\n\nvar { g: global, __dirname, m: module, e: exports } = __turbopack_context__;\n{\n'use strict';\nclass Warning {\n    constructor(text, opts = {}){\n        this.type = 'warning';\n        this.text = text;\n        if (opts.node && opts.node.source) {\n            let range = opts.node.rangeBy(opts);\n            this.line = range.start.line;\n            this.column = range.start.column;\n            this.endLine = range.end.line;\n            this.endColumn = range.end.column;\n        }\n        for(let opt in opts)this[opt] = opts[opt];\n    }\n    toString() {\n        if (this.node) {\n            return this.node.error(this.text, {\n                index: this.index,\n                plugin: this.plugin,\n                word: this.word\n            }).message;\n        }\n        if (this.plugin) {\n            return this.plugin + ': ' + this.text;\n        }\n        return this.text;\n    }\n}\nmodule.exports = Warning;\nWarning.default = Warning;\n}}),\n\"[project]/node_modules/postcss/lib/result.js [postcss] (ecmascript)\": (function(__turbopack_context__) {\n\nvar { g: global, __dirname, m: module, e: exports } = __turbopack_context__;\n{\n'use strict';\nlet Warning = __turbopack_context__.r(\"[project]/node_modules/postcss/lib/warning.js [postcss] (ecmascript)\");\nclass Result {\n    get content() {\n        return this.css;\n    }\n    constructor(processor, root, opts){\n        this.processor = processor;\n        this.messages = [];\n        this.root = root;\n        this.opts = opts;\n        this.css = undefined;\n        this.map = undefined;\n    }\n    toString() {\n        return this.css;\n    }\n    warn(text, opts = {}) {\n        if (!opts.plugin) {\n            if (this.lastPlugin && this.lastPlugin.postcssPlugin) {\n                opts.plugin = this.lastPlugin.postcssPlugin;\n            }\n        }\n        let warning = new Warning(text, opts);\n        this.messages.push(warning);\n        return warning;\n    }\n    warnings() {\n        return this.messages.filter((i)=>i.type === 'warning');\n    }\n}\nmodule.exports = Result;\nResult.default = Result;\n}}),\n\"[project]/node_modules/postcss/lib/warn-once.js [postcss] (ecmascript)\": (function(__turbopack_context__) {\n\nvar { g: global, __dirname, m: module, e: exports } = __turbopack_context__;\n{\n/* eslint-disable no-console */ 'use strict';\nlet printed = {};\nmodule.exports = function warnOnce(message) {\n    if (printed[message]) return;\n    printed[message] = true;\n    if (typeof console !== 'undefined' && console.warn) {\n        console.warn(message);\n    }\n};\n}}),\n\"[project]/node_modules/postcss/lib/lazy-result.js [postcss] (ecmascript)\": (function(__turbopack_context__) {\n\nvar { g: global, __dirname, m: module, e: exports } = __turbopack_context__;\n{\n'use strict';\nlet Container = __turbopack_context__.r(\"[project]/node_modules/postcss/lib/container.js [postcss] (ecmascript)\");\nlet Document = __turbopack_context__.r(\"[project]/node_modules/postcss/lib/document.js [postcss] (ecmascript)\");\nlet MapGenerator = __turbopack_context__.r(\"[project]/node_modules/postcss/lib/map-generator.js [postcss] (ecmascript)\");\nlet parse = __turbopack_context__.r(\"[project]/node_modules/postcss/lib/parse.js [postcss] (ecmascript)\");\nlet Result = __turbopack_context__.r(\"[project]/node_modules/postcss/lib/result.js [postcss] (ecmascript)\");\nlet Root = __turbopack_context__.r(\"[project]/node_modules/postcss/lib/root.js [postcss] (ecmascript)\");\nlet stringify = __turbopack_context__.r(\"[project]/node_modules/postcss/lib/stringify.js [postcss] (ecmascript)\");\nlet { isClean, my } = __turbopack_context__.r(\"[project]/node_modules/postcss/lib/symbols.js [postcss] (ecmascript)\");\nlet warnOnce = __turbopack_context__.r(\"[project]/node_modules/postcss/lib/warn-once.js [postcss] (ecmascript)\");\nconst TYPE_TO_CLASS_NAME = {\n    atrule: 'AtRule',\n    comment: 'Comment',\n    decl: 'Declaration',\n    document: 'Document',\n    root: 'Root',\n    rule: 'Rule'\n};\nconst PLUGIN_PROPS = {\n    AtRule: true,\n    AtRuleExit: true,\n    Comment: true,\n    CommentExit: true,\n    Declaration: true,\n    DeclarationExit: true,\n    Document: true,\n    DocumentExit: true,\n    Once: true,\n    OnceExit: true,\n    postcssPlugin: true,\n    prepare: true,\n    Root: true,\n    RootExit: true,\n    Rule: true,\n    RuleExit: true\n};\nconst NOT_VISITORS = {\n    Once: true,\n    postcssPlugin: true,\n    prepare: true\n};\nconst CHILDREN = 0;\nfunction isPromise(obj) {\n    return typeof obj === 'object' && typeof obj.then === 'function';\n}\nfunction getEvents(node) {\n    let key = false;\n    let type = TYPE_TO_CLASS_NAME[node.type];\n    if (node.type === 'decl') {\n        key = node.prop.toLowerCase();\n    } else if (node.type === 'atrule') {\n        key = node.name.toLowerCase();\n    }\n    if (key && node.append) {\n        return [\n            type,\n            type + '-' + key,\n            CHILDREN,\n            type + 'Exit',\n            type + 'Exit-' + key\n        ];\n    } else if (key) {\n        return [\n            type,\n            type + '-' + key,\n            type + 'Exit',\n            type + 'Exit-' + key\n        ];\n    } else if (node.append) {\n        return [\n            type,\n            CHILDREN,\n            type + 'Exit'\n        ];\n    } else {\n        return [\n            type,\n            type + 'Exit'\n        ];\n    }\n}\nfunction toStack(node) {\n    let events;\n    if (node.type === 'document') {\n        events = [\n            'Document',\n            CHILDREN,\n            'DocumentExit'\n        ];\n    } else if (node.type === 'root') {\n        events = [\n            'Root',\n            CHILDREN,\n            'RootExit'\n        ];\n    } else {\n        events = getEvents(node);\n    }\n    return {\n        eventIndex: 0,\n        events,\n        iterator: 0,\n        node,\n        visitorIndex: 0,\n        visitors: []\n    };\n}\nfunction cleanMarks(node) {\n    node[isClean] = false;\n    if (node.nodes) node.nodes.forEach((i)=>cleanMarks(i));\n    return node;\n}\nlet postcss = {};\nclass LazyResult {\n    get content() {\n        return this.stringify().content;\n    }\n    get css() {\n        return this.stringify().css;\n    }\n    get map() {\n        return this.stringify().map;\n    }\n    get messages() {\n        return this.sync().messages;\n    }\n    get opts() {\n        return this.result.opts;\n    }\n    get processor() {\n        return this.result.processor;\n    }\n    get root() {\n        return this.sync().root;\n    }\n    get [Symbol.toStringTag]() {\n        return 'LazyResult';\n    }\n    constructor(processor, css, opts){\n        this.stringified = false;\n        this.processed = false;\n        let root;\n        if (typeof css === 'object' && css !== null && (css.type === 'root' || css.type === 'document')) {\n            root = cleanMarks(css);\n        } else if (css instanceof LazyResult || css instanceof Result) {\n            root = cleanMarks(css.root);\n            if (css.map) {\n                if (typeof opts.map === 'undefined') opts.map = {};\n                if (!opts.map.inline) opts.map.inline = false;\n                opts.map.prev = css.map;\n            }\n        } else {\n            let parser = parse;\n            if (opts.syntax) parser = opts.syntax.parse;\n            if (opts.parser) parser = opts.parser;\n            if (parser.parse) parser = parser.parse;\n            try {\n                root = parser(css, opts);\n            } catch (error) {\n                this.processed = true;\n                this.error = error;\n            }\n            if (root && !root[my]) {\n                /* c8 ignore next 2 */ Container.rebuild(root);\n            }\n        }\n        this.result = new Result(processor, root, opts);\n        this.helpers = {\n            ...postcss,\n            postcss,\n            result: this.result\n        };\n        this.plugins = this.processor.plugins.map((plugin)=>{\n            if (typeof plugin === 'object' && plugin.prepare) {\n                return {\n                    ...plugin,\n                    ...plugin.prepare(this.result)\n                };\n            } else {\n                return plugin;\n            }\n        });\n    }\n    async() {\n        if (this.error) return Promise.reject(this.error);\n        if (this.processed) return Promise.resolve(this.result);\n        if (!this.processing) {\n            this.processing = this.runAsync();\n        }\n        return this.processing;\n    }\n    catch(onRejected) {\n        return this.async().catch(onRejected);\n    }\n    finally(onFinally) {\n        return this.async().then(onFinally, onFinally);\n    }\n    getAsyncError() {\n        throw new Error('Use process(css).then(cb) to work with async plugins');\n    }\n    handleError(error, node) {\n        let plugin = this.result.lastPlugin;\n        try {\n            if (node) node.addToError(error);\n            this.error = error;\n            if (error.name === 'CssSyntaxError' && !error.plugin) {\n                error.plugin = plugin.postcssPlugin;\n                error.setMessage();\n            } else if (plugin.postcssVersion) {\n                if (\"TURBOPACK compile-time truthy\", 1) {\n                    let pluginName = plugin.postcssPlugin;\n                    let pluginVer = plugin.postcssVersion;\n                    let runtimeVer = this.result.processor.version;\n                    let a = pluginVer.split('.');\n                    let b = runtimeVer.split('.');\n                    if (a[0] !== b[0] || parseInt(a[1]) > parseInt(b[1])) {\n                        // eslint-disable-next-line no-console\n                        console.error('Unknown error from PostCSS plugin. Your current PostCSS ' + 'version is ' + runtimeVer + ', but ' + pluginName + ' uses ' + pluginVer + '. Perhaps this is the source of the error below.');\n                    }\n                }\n            }\n        } catch (err) {\n            /* c8 ignore next 3 */ // eslint-disable-next-line no-console\n            if (console && console.error) console.error(err);\n        }\n        return error;\n    }\n    prepareVisitors() {\n        this.listeners = {};\n        let add = (plugin, type, cb)=>{\n            if (!this.listeners[type]) this.listeners[type] = [];\n            this.listeners[type].push([\n                plugin,\n                cb\n            ]);\n        };\n        for (let plugin of this.plugins){\n            if (typeof plugin === 'object') {\n                for(let event in plugin){\n                    if (!PLUGIN_PROPS[event] && /^[A-Z]/.test(event)) {\n                        throw new Error(`Unknown event ${event} in ${plugin.postcssPlugin}. ` + `Try to update PostCSS (${this.processor.version} now).`);\n                    }\n                    if (!NOT_VISITORS[event]) {\n                        if (typeof plugin[event] === 'object') {\n                            for(let filter in plugin[event]){\n                                if (filter === '*') {\n                                    add(plugin, event, plugin[event][filter]);\n                                } else {\n                                    add(plugin, event + '-' + filter.toLowerCase(), plugin[event][filter]);\n                                }\n                            }\n                        } else if (typeof plugin[event] === 'function') {\n                            add(plugin, event, plugin[event]);\n                        }\n                    }\n                }\n            }\n        }\n        this.hasListener = Object.keys(this.listeners).length > 0;\n    }\n    async runAsync() {\n        this.plugin = 0;\n        for(let i = 0; i < this.plugins.length; i++){\n            let plugin = this.plugins[i];\n            let promise = this.runOnRoot(plugin);\n            if (isPromise(promise)) {\n                try {\n                    await promise;\n                } catch (error) {\n                    throw this.handleError(error);\n                }\n            }\n        }\n        this.prepareVisitors();\n        if (this.hasListener) {\n            let root = this.result.root;\n            while(!root[isClean]){\n                root[isClean] = true;\n                let stack = [\n                    toStack(root)\n                ];\n                while(stack.length > 0){\n                    let promise = this.visitTick(stack);\n                    if (isPromise(promise)) {\n                        try {\n                            await promise;\n                        } catch (e) {\n                            let node = stack[stack.length - 1].node;\n                            throw this.handleError(e, node);\n                        }\n                    }\n                }\n            }\n            if (this.listeners.OnceExit) {\n                for (let [plugin, visitor] of this.listeners.OnceExit){\n                    this.result.lastPlugin = plugin;\n                    try {\n                        if (root.type === 'document') {\n                            let roots = root.nodes.map((subRoot)=>visitor(subRoot, this.helpers));\n                            await Promise.all(roots);\n                        } else {\n                            await visitor(root, this.helpers);\n                        }\n                    } catch (e) {\n                        throw this.handleError(e);\n                    }\n                }\n            }\n        }\n        this.processed = true;\n        return this.stringify();\n    }\n    runOnRoot(plugin) {\n        this.result.lastPlugin = plugin;\n        try {\n            if (typeof plugin === 'object' && plugin.Once) {\n                if (this.result.root.type === 'document') {\n                    let roots = this.result.root.nodes.map((root)=>plugin.Once(root, this.helpers));\n                    if (isPromise(roots[0])) {\n                        return Promise.all(roots);\n                    }\n                    return roots;\n                }\n                return plugin.Once(this.result.root, this.helpers);\n            } else if (typeof plugin === 'function') {\n                return plugin(this.result.root, this.result);\n            }\n        } catch (error) {\n            throw this.handleError(error);\n        }\n    }\n    stringify() {\n        if (this.error) throw this.error;\n        if (this.stringified) return this.result;\n        this.stringified = true;\n        this.sync();\n        let opts = this.result.opts;\n        let str = stringify;\n        if (opts.syntax) str = opts.syntax.stringify;\n        if (opts.stringifier) str = opts.stringifier;\n        if (str.stringify) str = str.stringify;\n        let map = new MapGenerator(str, this.result.root, this.result.opts);\n        let data = map.generate();\n        this.result.css = data[0];\n        this.result.map = data[1];\n        return this.result;\n    }\n    sync() {\n        if (this.error) throw this.error;\n        if (this.processed) return this.result;\n        this.processed = true;\n        if (this.processing) {\n            throw this.getAsyncError();\n        }\n        for (let plugin of this.plugins){\n            let promise = this.runOnRoot(plugin);\n            if (isPromise(promise)) {\n                throw this.getAsyncError();\n            }\n        }\n        this.prepareVisitors();\n        if (this.hasListener) {\n            let root = this.result.root;\n            while(!root[isClean]){\n                root[isClean] = true;\n                this.walkSync(root);\n            }\n            if (this.listeners.OnceExit) {\n                if (root.type === 'document') {\n                    for (let subRoot of root.nodes){\n                        this.visitSync(this.listeners.OnceExit, subRoot);\n                    }\n                } else {\n                    this.visitSync(this.listeners.OnceExit, root);\n                }\n            }\n        }\n        return this.result;\n    }\n    then(onFulfilled, onRejected) {\n        if (\"TURBOPACK compile-time truthy\", 1) {\n            if (!('from' in this.opts)) {\n                warnOnce('Without `from` option PostCSS could generate wrong source map ' + 'and will not find Browserslist config. Set it to CSS file path ' + 'or to `undefined` to prevent this warning.');\n            }\n        }\n        return this.async().then(onFulfilled, onRejected);\n    }\n    toString() {\n        return this.css;\n    }\n    visitSync(visitors, node) {\n        for (let [plugin, visitor] of visitors){\n            this.result.lastPlugin = plugin;\n            let promise;\n            try {\n                promise = visitor(node, this.helpers);\n            } catch (e) {\n                throw this.handleError(e, node.proxyOf);\n            }\n            if (node.type !== 'root' && node.type !== 'document' && !node.parent) {\n                return true;\n            }\n            if (isPromise(promise)) {\n                throw this.getAsyncError();\n            }\n        }\n    }\n    visitTick(stack) {\n        let visit = stack[stack.length - 1];\n        let { node, visitors } = visit;\n        if (node.type !== 'root' && node.type !== 'document' && !node.parent) {\n            stack.pop();\n            return;\n        }\n        if (visitors.length > 0 && visit.visitorIndex < visitors.length) {\n            let [plugin, visitor] = visitors[visit.visitorIndex];\n            visit.visitorIndex += 1;\n            if (visit.visitorIndex === visitors.length) {\n                visit.visitors = [];\n                visit.visitorIndex = 0;\n            }\n            this.result.lastPlugin = plugin;\n            try {\n                return visitor(node.toProxy(), this.helpers);\n            } catch (e) {\n                throw this.handleError(e, node);\n            }\n        }\n        if (visit.iterator !== 0) {\n            let iterator = visit.iterator;\n            let child;\n            while(child = node.nodes[node.indexes[iterator]]){\n                node.indexes[iterator] += 1;\n                if (!child[isClean]) {\n                    child[isClean] = true;\n                    stack.push(toStack(child));\n                    return;\n                }\n            }\n            visit.iterator = 0;\n            delete node.indexes[iterator];\n        }\n        let events = visit.events;\n        while(visit.eventIndex < events.length){\n            let event = events[visit.eventIndex];\n            visit.eventIndex += 1;\n            if (event === CHILDREN) {\n                if (node.nodes && node.nodes.length) {\n                    node[isClean] = true;\n                    visit.iterator = node.getIterator();\n                }\n                return;\n            } else if (this.listeners[event]) {\n                visit.visitors = this.listeners[event];\n                return;\n            }\n        }\n        stack.pop();\n    }\n    walkSync(node) {\n        node[isClean] = true;\n        let events = getEvents(node);\n        for (let event of events){\n            if (event === CHILDREN) {\n                if (node.nodes) {\n                    node.each((child)=>{\n                        if (!child[isClean]) this.walkSync(child);\n                    });\n                }\n            } else {\n                let visitors = this.listeners[event];\n                if (visitors) {\n                    if (this.visitSync(visitors, node.toProxy())) return;\n                }\n            }\n        }\n    }\n    warnings() {\n        return this.sync().warnings();\n    }\n}\nLazyResult.registerPostcss = (dependant)=>{\n    postcss = dependant;\n};\nmodule.exports = LazyResult;\nLazyResult.default = LazyResult;\nRoot.registerLazyResult(LazyResult);\nDocument.registerLazyResult(LazyResult);\n}}),\n\"[project]/node_modules/postcss/lib/no-work-result.js [postcss] (ecmascript)\": (function(__turbopack_context__) {\n\nvar { g: global, __dirname, m: module, e: exports } = __turbopack_context__;\n{\n'use strict';\nlet MapGenerator = __turbopack_context__.r(\"[project]/node_modules/postcss/lib/map-generator.js [postcss] (ecmascript)\");\nlet parse = __turbopack_context__.r(\"[project]/node_modules/postcss/lib/parse.js [postcss] (ecmascript)\");\nconst Result = __turbopack_context__.r(\"[project]/node_modules/postcss/lib/result.js [postcss] (ecmascript)\");\nlet stringify = __turbopack_context__.r(\"[project]/node_modules/postcss/lib/stringify.js [postcss] (ecmascript)\");\nlet warnOnce = __turbopack_context__.r(\"[project]/node_modules/postcss/lib/warn-once.js [postcss] (ecmascript)\");\nclass NoWorkResult {\n    get content() {\n        return this.result.css;\n    }\n    get css() {\n        return this.result.css;\n    }\n    get map() {\n        return this.result.map;\n    }\n    get messages() {\n        return [];\n    }\n    get opts() {\n        return this.result.opts;\n    }\n    get processor() {\n        return this.result.processor;\n    }\n    get root() {\n        if (this._root) {\n            return this._root;\n        }\n        let root;\n        let parser = parse;\n        try {\n            root = parser(this._css, this._opts);\n        } catch (error) {\n            this.error = error;\n        }\n        if (this.error) {\n            throw this.error;\n        } else {\n            this._root = root;\n            return root;\n        }\n    }\n    get [Symbol.toStringTag]() {\n        return 'NoWorkResult';\n    }\n    constructor(processor, css, opts){\n        css = css.toString();\n        this.stringified = false;\n        this._processor = processor;\n        this._css = css;\n        this._opts = opts;\n        this._map = undefined;\n        let root;\n        let str = stringify;\n        this.result = new Result(this._processor, root, this._opts);\n        this.result.css = css;\n        let self = this;\n        Object.defineProperty(this.result, 'root', {\n            get () {\n                return self.root;\n            }\n        });\n        let map = new MapGenerator(str, root, this._opts, css);\n        if (map.isMap()) {\n            let [generatedCSS, generatedMap] = map.generate();\n            if (generatedCSS) {\n                this.result.css = generatedCSS;\n            }\n            if (generatedMap) {\n                this.result.map = generatedMap;\n            }\n        } else {\n            map.clearAnnotation();\n            this.result.css = map.css;\n        }\n    }\n    async() {\n        if (this.error) return Promise.reject(this.error);\n        return Promise.resolve(this.result);\n    }\n    catch(onRejected) {\n        return this.async().catch(onRejected);\n    }\n    finally(onFinally) {\n        return this.async().then(onFinally, onFinally);\n    }\n    sync() {\n        if (this.error) throw this.error;\n        return this.result;\n    }\n    then(onFulfilled, onRejected) {\n        if (\"TURBOPACK compile-time truthy\", 1) {\n            if (!('from' in this._opts)) {\n                warnOnce('Without `from` option PostCSS could generate wrong source map ' + 'and will not find Browserslist config. Set it to CSS file path ' + 'or to `undefined` to prevent this warning.');\n            }\n        }\n        return this.async().then(onFulfilled, onRejected);\n    }\n    toString() {\n        return this._css;\n    }\n    warnings() {\n        return [];\n    }\n}\nmodule.exports = NoWorkResult;\nNoWorkResult.default = NoWorkResult;\n}}),\n\"[project]/node_modules/postcss/lib/processor.js [postcss] (ecmascript)\": (function(__turbopack_context__) {\n\nvar { g: global, __dirname, m: module, e: exports } = __turbopack_context__;\n{\n'use strict';\nlet Document = __turbopack_context__.r(\"[project]/node_modules/postcss/lib/document.js [postcss] (ecmascript)\");\nlet LazyResult = __turbopack_context__.r(\"[project]/node_modules/postcss/lib/lazy-result.js [postcss] (ecmascript)\");\nlet NoWorkResult = __turbopack_context__.r(\"[project]/node_modules/postcss/lib/no-work-result.js [postcss] (ecmascript)\");\nlet Root = __turbopack_context__.r(\"[project]/node_modules/postcss/lib/root.js [postcss] (ecmascript)\");\nclass Processor {\n    constructor(plugins = []){\n        this.version = '8.5.3';\n        this.plugins = this.normalize(plugins);\n    }\n    normalize(plugins) {\n        let normalized = [];\n        for (let i of plugins){\n            if (i.postcss === true) {\n                i = i();\n            } else if (i.postcss) {\n                i = i.postcss;\n            }\n            if (typeof i === 'object' && Array.isArray(i.plugins)) {\n                normalized = normalized.concat(i.plugins);\n            } else if (typeof i === 'object' && i.postcssPlugin) {\n                normalized.push(i);\n            } else if (typeof i === 'function') {\n                normalized.push(i);\n            } else if (typeof i === 'object' && (i.parse || i.stringify)) {\n                if (\"TURBOPACK compile-time truthy\", 1) {\n                    throw new Error('PostCSS syntaxes cannot be used as plugins. Instead, please use ' + 'one of the syntax/parser/stringifier options as outlined ' + 'in your PostCSS runner documentation.');\n                }\n            } else {\n                throw new Error(i + ' is not a PostCSS plugin');\n            }\n        }\n        return normalized;\n    }\n    process(css, opts = {}) {\n        if (!this.plugins.length && !opts.parser && !opts.stringifier && !opts.syntax) {\n            return new NoWorkResult(this, css, opts);\n        } else {\n            return new LazyResult(this, css, opts);\n        }\n    }\n    use(plugin) {\n        this.plugins = this.plugins.concat(this.normalize([\n            plugin\n        ]));\n        return this;\n    }\n}\nmodule.exports = Processor;\nProcessor.default = Processor;\nRoot.registerProcessor(Processor);\nDocument.registerProcessor(Processor);\n}}),\n\"[project]/node_modules/postcss/lib/postcss.js [postcss] (ecmascript)\": (function(__turbopack_context__) {\n\nvar { g: global, __dirname, m: module, e: exports } = __turbopack_context__;\n{\n'use strict';\nlet AtRule = __turbopack_context__.r(\"[project]/node_modules/postcss/lib/at-rule.js [postcss] (ecmascript)\");\nlet Comment = __turbopack_context__.r(\"[project]/node_modules/postcss/lib/comment.js [postcss] (ecmascript)\");\nlet Container = __turbopack_context__.r(\"[project]/node_modules/postcss/lib/container.js [postcss] (ecmascript)\");\nlet CssSyntaxError = __turbopack_context__.r(\"[project]/node_modules/postcss/lib/css-syntax-error.js [postcss] (ecmascript)\");\nlet Declaration = __turbopack_context__.r(\"[project]/node_modules/postcss/lib/declaration.js [postcss] (ecmascript)\");\nlet Document = __turbopack_context__.r(\"[project]/node_modules/postcss/lib/document.js [postcss] (ecmascript)\");\nlet fromJSON = __turbopack_context__.r(\"[project]/node_modules/postcss/lib/fromJSON.js [postcss] (ecmascript)\");\nlet Input = __turbopack_context__.r(\"[project]/node_modules/postcss/lib/input.js [postcss] (ecmascript)\");\nlet LazyResult = __turbopack_context__.r(\"[project]/node_modules/postcss/lib/lazy-result.js [postcss] (ecmascript)\");\nlet list = __turbopack_context__.r(\"[project]/node_modules/postcss/lib/list.js [postcss] (ecmascript)\");\nlet Node = __turbopack_context__.r(\"[project]/node_modules/postcss/lib/node.js [postcss] (ecmascript)\");\nlet parse = __turbopack_context__.r(\"[project]/node_modules/postcss/lib/parse.js [postcss] (ecmascript)\");\nlet Processor = __turbopack_context__.r(\"[project]/node_modules/postcss/lib/processor.js [postcss] (ecmascript)\");\nlet Result = __turbopack_context__.r(\"[project]/node_modules/postcss/lib/result.js [postcss] (ecmascript)\");\nlet Root = __turbopack_context__.r(\"[project]/node_modules/postcss/lib/root.js [postcss] (ecmascript)\");\nlet Rule = __turbopack_context__.r(\"[project]/node_modules/postcss/lib/rule.js [postcss] (ecmascript)\");\nlet stringify = __turbopack_context__.r(\"[project]/node_modules/postcss/lib/stringify.js [postcss] (ecmascript)\");\nlet Warning = __turbopack_context__.r(\"[project]/node_modules/postcss/lib/warning.js [postcss] (ecmascript)\");\nfunction postcss(...plugins) {\n    if (plugins.length === 1 && Array.isArray(plugins[0])) {\n        plugins = plugins[0];\n    }\n    return new Processor(plugins);\n}\npostcss.plugin = function plugin(name, initializer) {\n    let warningPrinted = false;\n    function creator(...args) {\n        // eslint-disable-next-line no-console\n        if (console && console.warn && !warningPrinted) {\n            warningPrinted = true;\n            // eslint-disable-next-line no-console\n            console.warn(name + ': postcss.plugin was deprecated. Migration guide:\\n' + 'https://evilmartians.com/chronicles/postcss-8-plugin-migration');\n            if (process.env.LANG && process.env.LANG.startsWith('cn')) {\n                /* c8 ignore next 7 */ // eslint-disable-next-line no-console\n                console.warn(name + ':  postcss.plugin . :\\n' + 'https://www.w3ctech.com/topic/2226');\n            }\n        }\n        let transformer = initializer(...args);\n        transformer.postcssPlugin = name;\n        transformer.postcssVersion = new Processor().version;\n        return transformer;\n    }\n    let cache;\n    Object.defineProperty(creator, 'postcss', {\n        get () {\n            if (!cache) cache = creator();\n            return cache;\n        }\n    });\n    creator.process = function(css, processOpts, pluginOpts) {\n        return postcss([\n            creator(pluginOpts)\n        ]).process(css, processOpts);\n    };\n    return creator;\n};\npostcss.stringify = stringify;\npostcss.parse = parse;\npostcss.fromJSON = fromJSON;\npostcss.list = list;\npostcss.comment = (defaults)=>new Comment(defaults);\npostcss.atRule = (defaults)=>new AtRule(defaults);\npostcss.decl = (defaults)=>new Declaration(defaults);\npostcss.rule = (defaults)=>new Rule(defaults);\npostcss.root = (defaults)=>new Root(defaults);\npostcss.document = (defaults)=>new Document(defaults);\npostcss.CssSyntaxError = CssSyntaxError;\npostcss.Declaration = Declaration;\npostcss.Container = Container;\npostcss.Processor = Processor;\npostcss.Document = Document;\npostcss.Comment = Comment;\npostcss.Warning = Warning;\npostcss.AtRule = AtRule;\npostcss.Result = Result;\npostcss.Input = Input;\npostcss.Rule = Rule;\npostcss.Root = Root;\npostcss.Node = Node;\nLazyResult.registerPostcss(postcss);\nmodule.exports = postcss;\npostcss.default = postcss;\n}}),\n\"[project]/node_modules/postcss/lib/postcss.mjs [postcss] (ecmascript)\": ((__turbopack_context__) => {\n\"use strict\";\n\nvar { g: global, __dirname } = __turbopack_context__;\n{\n__turbopack_context__.s({\n    \"AtRule\": (()=>AtRule),\n    \"Comment\": (()=>Comment),\n    \"Container\": (()=>Container),\n    \"CssSyntaxError\": (()=>CssSyntaxError),\n    \"Declaration\": (()=>Declaration),\n    \"Document\": (()=>Document),\n    \"Input\": (()=>Input),\n    \"Node\": (()=>Node),\n    \"Processor\": (()=>Processor),\n    \"Result\": (()=>Result),\n    \"Root\": (()=>Root),\n    \"Rule\": (()=>Rule),\n    \"Warning\": (()=>Warning),\n    \"atRule\": (()=>atRule),\n    \"comment\": (()=>comment),\n    \"decl\": (()=>decl),\n    \"default\": (()=>__TURBOPACK__default__export__),\n    \"document\": (()=>document),\n    \"fromJSON\": (()=>fromJSON),\n    \"list\": (()=>list),\n    \"parse\": (()=>parse),\n    \"plugin\": (()=>plugin),\n    \"root\": (()=>root),\n    \"rule\": (()=>rule),\n    \"stringify\": (()=>stringify)\n});\nvar __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$postcss$2f$lib$2f$postcss$2e$js__$5b$postcss$5d$__$28$ecmascript$29$__ = __turbopack_context__.i(\"[project]/node_modules/postcss/lib/postcss.js [postcss] (ecmascript)\");\n;\nconst __TURBOPACK__default__export__ = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$postcss$2f$lib$2f$postcss$2e$js__$5b$postcss$5d$__$28$ecmascript$29$__[\"default\"];\nconst stringify = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$postcss$2f$lib$2f$postcss$2e$js__$5b$postcss$5d$__$28$ecmascript$29$__[\"default\"].stringify;\nconst fromJSON = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$postcss$2f$lib$2f$postcss$2e$js__$5b$postcss$5d$__$28$ecmascript$29$__[\"default\"].fromJSON;\nconst plugin = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$postcss$2f$lib$2f$postcss$2e$js__$5b$postcss$5d$__$28$ecmascript$29$__[\"default\"].plugin;\nconst parse = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$postcss$2f$lib$2f$postcss$2e$js__$5b$postcss$5d$__$28$ecmascript$29$__[\"default\"].parse;\nconst list = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$postcss$2f$lib$2f$postcss$2e$js__$5b$postcss$5d$__$28$ecmascript$29$__[\"default\"].list;\nconst document = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$postcss$2f$lib$2f$postcss$2e$js__$5b$postcss$5d$__$28$ecmascript$29$__[\"default\"].document;\nconst comment = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$postcss$2f$lib$2f$postcss$2e$js__$5b$postcss$5d$__$28$ecmascript$29$__[\"default\"].comment;\nconst atRule = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$postcss$2f$lib$2f$postcss$2e$js__$5b$postcss$5d$__$28$ecmascript$29$__[\"default\"].atRule;\nconst rule = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$postcss$2f$lib$2f$postcss$2e$js__$5b$postcss$5d$__$28$ecmascript$29$__[\"default\"].rule;\nconst decl = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$postcss$2f$lib$2f$postcss$2e$js__$5b$postcss$5d$__$28$ecmascript$29$__[\"default\"].decl;\nconst root = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$postcss$2f$lib$2f$postcss$2e$js__$5b$postcss$5d$__$28$ecmascript$29$__[\"default\"].root;\nconst CssSyntaxError = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$postcss$2f$lib$2f$postcss$2e$js__$5b$postcss$5d$__$28$ecmascript$29$__[\"default\"].CssSyntaxError;\nconst Declaration = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$postcss$2f$lib$2f$postcss$2e$js__$5b$postcss$5d$__$28$ecmascript$29$__[\"default\"].Declaration;\nconst Container = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$postcss$2f$lib$2f$postcss$2e$js__$5b$postcss$5d$__$28$ecmascript$29$__[\"default\"].Container;\nconst Processor = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$postcss$2f$lib$2f$postcss$2e$js__$5b$postcss$5d$__$28$ecmascript$29$__[\"default\"].Processor;\nconst Document = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$postcss$2f$lib$2f$postcss$2e$js__$5b$postcss$5d$__$28$ecmascript$29$__[\"default\"].Document;\nconst Comment = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$postcss$2f$lib$2f$postcss$2e$js__$5b$postcss$5d$__$28$ecmascript$29$__[\"default\"].Comment;\nconst Warning = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$postcss$2f$lib$2f$postcss$2e$js__$5b$postcss$5d$__$28$ecmascript$29$__[\"default\"].Warning;\nconst AtRule = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$postcss$2f$lib$2f$postcss$2e$js__$5b$postcss$5d$__$28$ecmascript$29$__[\"default\"].AtRule;\nconst Result = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$postcss$2f$lib$2f$postcss$2e$js__$5b$postcss$5d$__$28$ecmascript$29$__[\"default\"].Result;\nconst Input = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$postcss$2f$lib$2f$postcss$2e$js__$5b$postcss$5d$__$28$ecmascript$29$__[\"default\"].Input;\nconst Rule = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$postcss$2f$lib$2f$postcss$2e$js__$5b$postcss$5d$__$28$ecmascript$29$__[\"default\"].Rule;\nconst Root = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$postcss$2f$lib$2f$postcss$2e$js__$5b$postcss$5d$__$28$ecmascript$29$__[\"default\"].Root;\nconst Node = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$postcss$2f$lib$2f$postcss$2e$js__$5b$postcss$5d$__$28$ecmascript$29$__[\"default\"].Node;\n}}),\n\n};\n\n//# sourceMappingURL=node_modules_b5d1def4._.js.map"
        }
    ]
}