{
    "sourceFile": ".next/static/chunks/pages__app_049595de._.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891741425,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "(globalThis.TURBOPACK = globalThis.TURBOPACK || []).push([\n    typeof document === \"object\" ? document.currentScript : undefined,\n    {},\n    {\"otherChunks\":[\"static/chunks/[root-of-the-server]__ec07ee34._.js\",\"static/chunks/node_modules_react-dom_82bb97c6._.js\",\"static/chunks/node_modules_a51498a5._.js\",\"static/chunks/[root-of-the-server]__49fd8634._.js\"],\"runtimeModuleIds\":[\"[project]/node_modules/next/dist/compiled/@next/react-refresh-utils/dist/runtime.js [client] (ecmascript)\",\"[project]/node_modules/next/dist/client/next-dev-turbopack.js [client] (ecmascript)\",\"[project]/pages/_app (hmr-entry)\"]}\n]);\n(() => {\nif (!Array.isArray(globalThis.TURBOPACK)) {\n    return;\n}\n\nconst CHUNK_BASE_PATH = \"/_next/\";\nconst CHUNK_SUFFIX_PATH = \"\";\nconst RELATIVE_ROOT_PATH = \"/ROOT\";\nconst RUNTIME_PUBLIC_PATH = \"/_next/\";\n/**\r\n * This file contains runtime types and functions that are shared between all\r\n * TurboPack ECMAScript runtimes.\r\n *\r\n * It will be prepended to the runtime code of each runtime.\r\n */ /* eslint-disable @typescript-eslint/no-unused-vars */ /// <reference path=\"./runtime-types.d.ts\" />\nconst REEXPORTED_OBJECTS = Symbol(\"reexported objects\");\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\nconst toStringTag = typeof Symbol !== \"undefined\" && Symbol.toStringTag;\nfunction defineProp(obj, name, options) {\n    if (!hasOwnProperty.call(obj, name)) Object.defineProperty(obj, name, options);\n}\n/**\r\n * Adds the getters to the exports object.\r\n */ function esm(exports, getters) {\n    defineProp(exports, \"__esModule\", {\n        value: true\n    });\n    if (toStringTag) defineProp(exports, toStringTag, {\n        value: \"Module\"\n    });\n    for(const key in getters){\n        const item = getters[key];\n        if (Array.isArray(item)) {\n            defineProp(exports, key, {\n                get: item[0],\n                set: item[1],\n                enumerable: true\n            });\n        } else {\n            defineProp(exports, key, {\n                get: item,\n                enumerable: true\n            });\n        }\n    }\n    Object.seal(exports);\n}\n/**\r\n * Makes the module an ESM with exports\r\n */ function esmExport(module, exports, getters) {\n    module.namespaceObject = module.exports;\n    esm(exports, getters);\n}\nfunction ensureDynamicExports(module, exports) {\n    let reexportedObjects = module[REEXPORTED_OBJECTS];\n    if (!reexportedObjects) {\n        reexportedObjects = module[REEXPORTED_OBJECTS] = [];\n        module.exports = module.namespaceObject = new Proxy(exports, {\n            get (target, prop) {\n                if (hasOwnProperty.call(target, prop) || prop === \"default\" || prop === \"__esModule\") {\n                    return Reflect.get(target, prop);\n                }\n                for (const obj of reexportedObjects){\n                    const value = Reflect.get(obj, prop);\n                    if (value !== undefined) return value;\n                }\n                return undefined;\n            },\n            ownKeys (target) {\n                const keys = Reflect.ownKeys(target);\n                for (const obj of reexportedObjects){\n                    for (const key of Reflect.ownKeys(obj)){\n                        if (key !== \"default\" && !keys.includes(key)) keys.push(key);\n                    }\n                }\n                return keys;\n            }\n        });\n    }\n}\n/**\r\n * Dynamically exports properties from an object\r\n */ function dynamicExport(module, exports, object) {\n    ensureDynamicExports(module, exports);\n    if (typeof object === \"object\" && object !== null) {\n        module[REEXPORTED_OBJECTS].push(object);\n    }\n}\nfunction exportValue(module, value) {\n    module.exports = value;\n}\nfunction exportNamespace(module, namespace) {\n    module.exports = module.namespaceObject = namespace;\n}\nfunction createGetter(obj, key) {\n    return ()=>obj[key];\n}\n/**\r\n * @returns prototype of the object\r\n */ const getProto = Object.getPrototypeOf ? (obj)=>Object.getPrototypeOf(obj) : (obj)=>obj.__proto__;\n/** Prototypes that are not expanded for exports */ const LEAF_PROTOTYPES = [\n    null,\n    getProto({}),\n    getProto([]),\n    getProto(getProto)\n];\n/**\r\n * @param raw\r\n * @param ns\r\n * @param allowExportDefault\r\n *   * `false`: will have the raw module as default export\r\n *   * `true`: will have the default property as default export\r\n */ function interopEsm(raw, ns, allowExportDefault) {\n    const getters = Object.create(null);\n    for(let current = raw; (typeof current === \"object\" || typeof current === \"function\") && !LEAF_PROTOTYPES.includes(current); current = getProto(current)){\n        for (const key of Object.getOwnPropertyNames(current)){\n            getters[key] = createGetter(raw, key);\n        }\n    }\n    // this is not really correct\n    // we should set the `default` getter if the imported module is a `.cjs file`\n    if (!(allowExportDefault && \"default\" in getters)) {\n        getters[\"default\"] = ()=>raw;\n    }\n    esm(ns, getters);\n    return ns;\n}\nfunction createNS(raw) {\n    if (typeof raw === \"function\") {\n        return function(...args) {\n            return raw.apply(this, args);\n        };\n    } else {\n        return Object.create(null);\n    }\n}\nfunction esmImport(sourceModule, id) {\n    const module = getOrInstantiateModuleFromParent(id, sourceModule);\n    if (module.error) throw module.error;\n    // any ES module has to have `module.namespaceObject` defined.\n    if (module.namespaceObject) return module.namespaceObject;\n    // only ESM can be an async module, so we don't need to worry about exports being a promise here.\n    const raw = module.exports;\n    return module.namespaceObject = interopEsm(raw, createNS(raw), raw && raw.__esModule);\n}\n// Add a simple runtime require so that environments without one can still pass\n// `typeof require` CommonJS checks so that exports are correctly registered.\nconst runtimeRequire = // @ts-ignore\ntypeof require === \"function\" ? require : function require1() {\n    throw new Error(\"Unexpected use of runtime require\");\n};\nfunction commonJsRequire(sourceModule, id) {\n    const module = getOrInstantiateModuleFromParent(id, sourceModule);\n    if (module.error) throw module.error;\n    return module.exports;\n}\n/**\r\n * `require.context` and require/import expression runtime.\r\n */ function moduleContext(map) {\n    function moduleContext(id) {\n        if (hasOwnProperty.call(map, id)) {\n            return map[id].module();\n        }\n        const e = new Error(`Cannot find module '${id}'`);\n        e.code = \"MODULE_NOT_FOUND\";\n        throw e;\n    }\n    moduleContext.keys = ()=>{\n        return Object.keys(map);\n    };\n    moduleContext.resolve = (id)=>{\n        if (hasOwnProperty.call(map, id)) {\n            return map[id].id();\n        }\n        const e = new Error(`Cannot find module '${id}'`);\n        e.code = \"MODULE_NOT_FOUND\";\n        throw e;\n    };\n    moduleContext.import = async (id)=>{\n        return await moduleContext(id);\n    };\n    return moduleContext;\n}\n/**\r\n * Returns the path of a chunk defined by its data.\r\n */ function getChunkPath(chunkData) {\n    return typeof chunkData === \"string\" ? chunkData : chunkData.path;\n}\nfunction isPromise(maybePromise) {\n    return maybePromise != null && typeof maybePromise === \"object\" && \"then\" in maybePromise && typeof maybePromise.then === \"function\";\n}\nfunction isAsyncModuleExt(obj) {\n    return turbopackQueues in obj;\n}\nfunction createPromise() {\n    let resolve;\n    let reject;\n    const promise = new Promise((res, rej)=>{\n        reject = rej;\n        resolve = res;\n    });\n    return {\n        promise,\n        resolve: resolve,\n        reject: reject\n    };\n}\n// everything below is adapted from webpack\n// https://github.com/webpack/webpack/blob/6be4065ade1e252c1d8dcba4af0f43e32af1bdc1/lib/runtime/AsyncModuleRuntimeModule.js#L13\nconst turbopackQueues = Symbol(\"turbopack queues\");\nconst turbopackExports = Symbol(\"turbopack exports\");\nconst turbopackError = Symbol(\"turbopack error\");\nfunction resolveQueue(queue) {\n    if (queue && queue.status !== 1) {\n        queue.status = 1;\n        queue.forEach((fn)=>fn.queueCount--);\n        queue.forEach((fn)=>fn.queueCount-- ? fn.queueCount++ : fn());\n    }\n}\nfunction wrapDeps(deps) {\n    return deps.map((dep)=>{\n        if (dep !== null && typeof dep === \"object\") {\n            if (isAsyncModuleExt(dep)) return dep;\n            if (isPromise(dep)) {\n                const queue = Object.assign([], {\n                    status: 0\n                });\n                const obj = {\n                    [turbopackExports]: {},\n                    [turbopackQueues]: (fn)=>fn(queue)\n                };\n                dep.then((res)=>{\n                    obj[turbopackExports] = res;\n                    resolveQueue(queue);\n                }, (err)=>{\n                    obj[turbopackError] = err;\n                    resolveQueue(queue);\n                });\n                return obj;\n            }\n        }\n        return {\n            [turbopackExports]: dep,\n            [turbopackQueues]: ()=>{}\n        };\n    });\n}\nfunction asyncModule(module, body, hasAwait) {\n    const queue = hasAwait ? Object.assign([], {\n        status: -1\n    }) : undefined;\n    const depQueues = new Set();\n    const { resolve, reject, promise: rawPromise } = createPromise();\n    const promise = Object.assign(rawPromise, {\n        [turbopackExports]: module.exports,\n        [turbopackQueues]: (fn)=>{\n            queue && fn(queue);\n            depQueues.forEach(fn);\n            promise[\"catch\"](()=>{});\n        }\n    });\n    const attributes = {\n        get () {\n            return promise;\n        },\n        set (v) {\n            // Calling `esmExport` leads to this.\n            if (v !== promise) {\n                promise[turbopackExports] = v;\n            }\n        }\n    };\n    Object.defineProperty(module, \"exports\", attributes);\n    Object.defineProperty(module, \"namespaceObject\", attributes);\n    function handleAsyncDependencies(deps) {\n        const currentDeps = wrapDeps(deps);\n        const getResult = ()=>currentDeps.map((d)=>{\n                if (d[turbopackError]) throw d[turbopackError];\n                return d[turbopackExports];\n            });\n        const { promise, resolve } = createPromise();\n        const fn = Object.assign(()=>resolve(getResult), {\n            queueCount: 0\n        });\n        function fnQueue(q) {\n            if (q !== queue && !depQueues.has(q)) {\n                depQueues.add(q);\n                if (q && q.status === 0) {\n                    fn.queueCount++;\n                    q.push(fn);\n                }\n            }\n        }\n        currentDeps.map((dep)=>dep[turbopackQueues](fnQueue));\n        return fn.queueCount ? promise : getResult();\n    }\n    function asyncResult(err) {\n        if (err) {\n            reject(promise[turbopackError] = err);\n        } else {\n            resolve(promise[turbopackExports]);\n        }\n        resolveQueue(queue);\n    }\n    body(handleAsyncDependencies, asyncResult);\n    if (queue && queue.status === -1) {\n        queue.status = 0;\n    }\n}\n/**\r\n * A pseudo \"fake\" URL object to resolve to its relative path.\r\n *\r\n * When UrlRewriteBehavior is set to relative, calls to the `new URL()` will construct url without base using this\r\n * runtime function to generate context-agnostic urls between different rendering context, i.e ssr / client to avoid\r\n * hydration mismatch.\r\n *\r\n * This is based on webpack's existing implementation:\r\n * https://github.com/webpack/webpack/blob/87660921808566ef3b8796f8df61bd79fc026108/lib/runtime/RelativeUrlRuntimeModule.js\r\n */ const relativeURL = function relativeURL(inputUrl) {\n    const realUrl = new URL(inputUrl, \"x:/\");\n    const values = {};\n    for(const key in realUrl)values[key] = realUrl[key];\n    values.href = inputUrl;\n    values.pathname = inputUrl.replace(/[?#].*/, \"\");\n    values.origin = values.protocol = \"\";\n    values.toString = values.toJSON = (..._args)=>inputUrl;\n    for(const key in values)Object.defineProperty(this, key, {\n        enumerable: true,\n        configurable: true,\n        value: values[key]\n    });\n};\nrelativeURL.prototype = URL.prototype;\n/**\r\n * Utility function to ensure all variants of an enum are handled.\r\n */ function invariant(never, computeMessage) {\n    throw new Error(`Invariant: ${computeMessage(never)}`);\n}\n/**\r\n * A stub function to make `require` available but non-functional in ESM.\r\n */ function requireStub(_moduleId) {\n    throw new Error(\"dynamic usage of require is not supported\");\n}\n/**\r\n * This file contains runtime types and functions that are shared between all\r\n * Turbopack *development* ECMAScript runtimes.\r\n *\r\n * It will be appended to the runtime code of each runtime right after the\r\n * shared runtime utils.\r\n */ /* eslint-disable @typescript-eslint/no-unused-vars */ /// <reference path=\"../base/globals.d.ts\" />\n/// <reference path=\"../../../shared/runtime-utils.ts\" />\n// Used in WebWorkers to tell the runtime about the chunk base path\nvar SourceType = /*#__PURE__*/ function(SourceType) {\n    /**\r\n   * The module was instantiated because it was included in an evaluated chunk's\r\n   * runtime.\r\n   */ SourceType[SourceType[\"Runtime\"] = 0] = \"Runtime\";\n    /**\r\n   * The module was instantiated because a parent module imported it.\r\n   */ SourceType[SourceType[\"Parent\"] = 1] = \"Parent\";\n    /**\r\n   * The module was instantiated because it was included in a chunk's hot module\r\n   * update.\r\n   */ SourceType[SourceType[\"Update\"] = 2] = \"Update\";\n    return SourceType;\n}(SourceType || {});\nconst moduleFactories = Object.create(null);\n/**\r\n * Module IDs that are instantiated as part of the runtime of a chunk.\r\n */ const runtimeModules = new Set();\n/**\r\n * Map from module ID to the chunks that contain this module.\r\n *\r\n * In HMR, we need to keep track of which modules are contained in which so\r\n * chunks. This is so we don't eagerly dispose of a module when it is removed\r\n * from chunk A, but still exists in chunk B.\r\n */ const moduleChunksMap = new Map();\n/**\r\n * Map from a chunk path to all modules it contains.\r\n */ const chunkModulesMap = new Map();\n/**\r\n * Chunk lists that contain a runtime. When these chunk lists receive an update\r\n * that can't be reconciled with the current state of the page, we need to\r\n * reload the runtime entirely.\r\n */ const runtimeChunkLists = new Set();\n/**\r\n * Map from a chunk list to the chunk paths it contains.\r\n */ const chunkListChunksMap = new Map();\n/**\r\n * Map from a chunk path to the chunk lists it belongs to.\r\n */ const chunkChunkListsMap = new Map();\nconst availableModules = new Map();\nconst availableModuleChunks = new Map();\nasync function loadChunk(source, chunkData) {\n    if (typeof chunkData === \"string\") {\n        return loadChunkPath(source, chunkData);\n    }\n    const includedList = chunkData.included || [];\n    const modulesPromises = includedList.map((included)=>{\n        if (moduleFactories[included]) return true;\n        return availableModules.get(included);\n    });\n    if (modulesPromises.length > 0 && modulesPromises.every((p)=>p)) {\n        // When all included items are already loaded or loading, we can skip loading ourselves\n        return Promise.all(modulesPromises);\n    }\n    const includedModuleChunksList = chunkData.moduleChunks || [];\n    const moduleChunksPromises = includedModuleChunksList.map((included)=>{\n        // TODO(alexkirsz) Do we need this check?\n        // if (moduleFactories[included]) return true;\n        return availableModuleChunks.get(included);\n    }).filter((p)=>p);\n    let promise;\n    if (moduleChunksPromises.length > 0) {\n        // Some module chunks are already loaded or loading.\n        if (moduleChunksPromises.length === includedModuleChunksList.length) {\n            // When all included module chunks are already loaded or loading, we can skip loading ourselves\n            return Promise.all(moduleChunksPromises);\n        }\n        const moduleChunksToLoad = new Set();\n        for (const moduleChunk of includedModuleChunksList){\n            if (!availableModuleChunks.has(moduleChunk)) {\n                moduleChunksToLoad.add(moduleChunk);\n            }\n        }\n        for (const moduleChunkToLoad of moduleChunksToLoad){\n            const promise = loadChunkPath(source, moduleChunkToLoad);\n            availableModuleChunks.set(moduleChunkToLoad, promise);\n            moduleChunksPromises.push(promise);\n        }\n        promise = Promise.all(moduleChunksPromises);\n    } else {\n        promise = loadChunkPath(source, chunkData.path);\n        // Mark all included module chunks as loading if they are not already loaded or loading.\n        for (const includedModuleChunk of includedModuleChunksList){\n            if (!availableModuleChunks.has(includedModuleChunk)) {\n                availableModuleChunks.set(includedModuleChunk, promise);\n            }\n        }\n    }\n    for (const included of includedList){\n        if (!availableModules.has(included)) {\n            // It might be better to race old and new promises, but it's rare that the new promise will be faster than a request started earlier.\n            // In production it's even more rare, because the chunk optimization tries to deduplicate modules anyway.\n            availableModules.set(included, promise);\n        }\n    }\n    return promise;\n}\nasync function loadChunkByUrl(source, chunkUrl) {\n    try {\n        await BACKEND.loadChunk(chunkUrl, source);\n    } catch (error) {\n        let loadReason;\n        switch(source.type){\n            case 0:\n                loadReason = `as a runtime dependency of chunk ${source.chunkPath}`;\n                break;\n            case 1:\n                loadReason = `from module ${source.parentId}`;\n                break;\n            case 2:\n                loadReason = \"from an HMR update\";\n                break;\n            default:\n                invariant(source, (source)=>`Unknown source type: ${source?.type}`);\n        }\n        throw new Error(`Failed to load chunk ${chunkUrl} ${loadReason}${error ? `: ${error}` : \"\"}`, error ? {\n            cause: error\n        } : undefined);\n    }\n}\nasync function loadChunkPath(source, chunkPath) {\n    const url = getChunkRelativeUrl(chunkPath);\n    return loadChunkByUrl(source, url);\n}\n/**\r\n * Returns an absolute url to an asset.\r\n */ function createResolvePathFromModule(resolver) {\n    return function resolvePathFromModule(moduleId) {\n        const exported = resolver(moduleId);\n        return exported?.default ?? exported;\n    };\n}\n/**\r\n * no-op for browser\r\n * @param modulePath\r\n */ function resolveAbsolutePath(modulePath) {\n    return `/ROOT/${modulePath ?? \"\"}`;\n}\nfunction getWorkerBlobURL(chunks) {\n    let bootstrap = `self.TURBOPACK_WORKER_LOCATION = ${JSON.stringify(location.origin)};\nself.TURBOPACK_NEXT_CHUNK_URLS = ${JSON.stringify(chunks.reverse().map(getChunkRelativeUrl), null, 2)};\nimportScripts(...self.TURBOPACK_NEXT_CHUNK_URLS.map(c => self.TURBOPACK_WORKER_LOCATION + c).reverse());`;\n    let blob = new Blob([\n        bootstrap\n    ], {\n        type: \"text/javascript\"\n    });\n    return URL.createObjectURL(blob);\n}\n/**\r\n * Adds a module to a chunk.\r\n */ function addModuleToChunk(moduleId, chunkPath) {\n    let moduleChunks = moduleChunksMap.get(moduleId);\n    if (!moduleChunks) {\n        moduleChunks = new Set([\n            chunkPath\n        ]);\n        moduleChunksMap.set(moduleId, moduleChunks);\n    } else {\n        moduleChunks.add(chunkPath);\n    }\n    let chunkModules = chunkModulesMap.get(chunkPath);\n    if (!chunkModules) {\n        chunkModules = new Set([\n            moduleId\n        ]);\n        chunkModulesMap.set(chunkPath, chunkModules);\n    } else {\n        chunkModules.add(moduleId);\n    }\n}\n/**\r\n * Returns the first chunk that included a module.\r\n * This is used by the Node.js backend, hence why it's marked as unused in this\r\n * file.\r\n */ function getFirstModuleChunk(moduleId) {\n    const moduleChunkPaths = moduleChunksMap.get(moduleId);\n    if (moduleChunkPaths == null) {\n        return null;\n    }\n    return moduleChunkPaths.values().next().value;\n}\n/**\r\n * Instantiates a runtime module.\r\n */ function instantiateRuntimeModule(moduleId, chunkPath) {\n    return instantiateModule(moduleId, {\n        type: 0,\n        chunkPath\n    });\n}\n/**\r\n * Returns the URL relative to the origin where a chunk can be fetched from.\r\n */ function getChunkRelativeUrl(chunkPath) {\n    return `${CHUNK_BASE_PATH}${chunkPath.split(\"/\").map((p)=>encodeURIComponent(p)).join(\"/\")}${CHUNK_SUFFIX_PATH}`;\n}\nfunction getPathFromScript(chunkScript) {\n    if (typeof chunkScript === \"string\") {\n        return chunkScript;\n    }\n    const chunkUrl = typeof TURBOPACK_NEXT_CHUNK_URLS !== \"undefined\" ? TURBOPACK_NEXT_CHUNK_URLS.pop() : chunkScript.getAttribute(\"src\");\n    const src = decodeURIComponent(chunkUrl.replace(/[?#].*$/, \"\"));\n    const path = src.startsWith(CHUNK_BASE_PATH) ? src.slice(CHUNK_BASE_PATH.length) : src;\n    return path;\n}\n/**\r\n * Marks a chunk list as a runtime chunk list. There can be more than one\r\n * runtime chunk list. For instance, integration tests can have multiple chunk\r\n * groups loaded at runtime, each with its own chunk list.\r\n */ function markChunkListAsRuntime(chunkListPath) {\n    runtimeChunkLists.add(chunkListPath);\n}\nfunction registerChunk([chunkScript, chunkModules, runtimeParams]) {\n    const chunkPath = getPathFromScript(chunkScript);\n    for (const [moduleId, moduleFactory] of Object.entries(chunkModules)){\n        if (!moduleFactories[moduleId]) {\n            moduleFactories[moduleId] = moduleFactory;\n        }\n        addModuleToChunk(moduleId, chunkPath);\n    }\n    return BACKEND.registerChunk(chunkPath, runtimeParams);\n}\nconst regexJsUrl = /\\.js(?:\\?[^#]*)?(?:#.*)?$/;\n/**\r\n * Checks if a given path/URL ends with .js, optionally followed by ?query or #fragment.\r\n */ function isJs(chunkUrlOrPath) {\n    return regexJsUrl.test(chunkUrlOrPath);\n}\nconst regexCssUrl = /\\.css(?:\\?[^#]*)?(?:#.*)?$/;\n/**\r\n * Checks if a given path/URL ends with .css, optionally followed by ?query or #fragment.\r\n */ function isCss(chunkUrl) {\n    return regexCssUrl.test(chunkUrl);\n}\n/// <reference path=\"./dev-globals.d.ts\" />\n/// <reference path=\"./dev-protocol.d.ts\" />\n/// <reference path=\"./dev-extensions.ts\" />\n/**\r\n * This file contains runtime types and functions that are shared between all\r\n * Turbopack *development* ECMAScript runtimes.\r\n *\r\n * It will be appended to the runtime code of each runtime right after the\r\n * shared runtime utils.\r\n */ /* eslint-disable @typescript-eslint/no-unused-vars */ const devModuleCache = Object.create(null);\nclass UpdateApplyError extends Error {\n    name = \"UpdateApplyError\";\n    dependencyChain;\n    constructor(message, dependencyChain){\n        super(message);\n        this.dependencyChain = dependencyChain;\n    }\n}\n/**\r\n * Maps module IDs to persisted data between executions of their hot module\r\n * implementation (`hot.data`).\r\n */ const moduleHotData = new Map();\n/**\r\n * Maps module instances to their hot module state.\r\n */ const moduleHotState = new Map();\n/**\r\n * Modules that call `module.hot.invalidate()` (while being updated).\r\n */ const queuedInvalidatedModules = new Set();\n/**\r\n * Gets or instantiates a runtime module.\r\n */ // @ts-ignore\nfunction getOrInstantiateRuntimeModule(moduleId, chunkPath) {\n    const module = devModuleCache[moduleId];\n    if (module) {\n        if (module.error) {\n            throw module.error;\n        }\n        return module;\n    }\n    // @ts-ignore\n    return instantiateModule(moduleId, {\n        type: SourceType.Runtime,\n        chunkPath\n    });\n}\n/**\r\n * Retrieves a module from the cache, or instantiate it if it is not cached.\r\n */ // @ts-ignore Defined in `runtime-utils.ts`\nconst getOrInstantiateModuleFromParent = (id, sourceModule)=>{\n    if (!sourceModule.hot.active) {\n        console.warn(`Unexpected import of module ${id} from module ${sourceModule.id}, which was deleted by an HMR update`);\n    }\n    const module = devModuleCache[id];\n    if (sourceModule.children.indexOf(id) === -1) {\n        sourceModule.children.push(id);\n    }\n    if (module) {\n        if (module.parents.indexOf(sourceModule.id) === -1) {\n            module.parents.push(sourceModule.id);\n        }\n        return module;\n    }\n    return instantiateModule(id, {\n        type: SourceType.Parent,\n        parentId: sourceModule.id\n    });\n};\n// @ts-ignore Defined in `runtime-base.ts`\nfunction instantiateModule(id, source) {\n    const moduleFactory = moduleFactories[id];\n    if (typeof moduleFactory !== \"function\") {\n        // This can happen if modules incorrectly handle HMR disposes/updates,\n        // e.g. when they keep a `setTimeout` around which still executes old code\n        // and contains e.g. a `require(\"something\")` call.\n        let instantiationReason;\n        switch(source.type){\n            case SourceType.Runtime:\n                instantiationReason = `as a runtime entry of chunk ${source.chunkPath}`;\n                break;\n            case SourceType.Parent:\n                instantiationReason = `because it was required from module ${source.parentId}`;\n                break;\n            case SourceType.Update:\n                instantiationReason = \"because of an HMR update\";\n                break;\n            default:\n                invariant(source, (source)=>`Unknown source type: ${source?.type}`);\n        }\n        throw new Error(`Module ${id} was instantiated ${instantiationReason}, but the module factory is not available. It might have been deleted in an HMR update.`);\n    }\n    const hotData = moduleHotData.get(id);\n    const { hot, hotState } = createModuleHot(id, hotData);\n    let parents;\n    switch(source.type){\n        case SourceType.Runtime:\n            runtimeModules.add(id);\n            parents = [];\n            break;\n        case SourceType.Parent:\n            // No need to add this module as a child of the parent module here, this\n            // has already been taken care of in `getOrInstantiateModuleFromParent`.\n            parents = [\n                source.parentId\n            ];\n            break;\n        case SourceType.Update:\n            parents = source.parents || [];\n            break;\n        default:\n            invariant(source, (source)=>`Unknown source type: ${source?.type}`);\n    }\n    const module = {\n        exports: {},\n        error: undefined,\n        loaded: false,\n        id,\n        parents,\n        children: [],\n        namespaceObject: undefined,\n        hot\n    };\n    devModuleCache[id] = module;\n    moduleHotState.set(module, hotState);\n    // NOTE(alexkirsz) This can fail when the module encounters a runtime error.\n    try {\n        const sourceInfo = {\n            type: SourceType.Parent,\n            parentId: id\n        };\n        runModuleExecutionHooks(module, (refresh)=>{\n            const r = commonJsRequire.bind(null, module);\n            moduleFactory.call(module.exports, augmentContext({\n                a: asyncModule.bind(null, module),\n                e: module.exports,\n                r: commonJsRequire.bind(null, module),\n                t: runtimeRequire,\n                f: moduleContext,\n                i: esmImport.bind(null, module),\n                s: esmExport.bind(null, module, module.exports),\n                j: dynamicExport.bind(null, module, module.exports),\n                v: exportValue.bind(null, module),\n                n: exportNamespace.bind(null, module),\n                m: module,\n                c: devModuleCache,\n                M: moduleFactories,\n                l: loadChunk.bind(null, sourceInfo),\n                L: loadChunkByUrl.bind(null, sourceInfo),\n                w: loadWebAssembly.bind(null, sourceInfo),\n                u: loadWebAssemblyModule.bind(null, sourceInfo),\n                g: globalThis,\n                P: resolveAbsolutePath,\n                U: relativeURL,\n                k: refresh,\n                R: createResolvePathFromModule(r),\n                b: getWorkerBlobURL,\n                z: requireStub,\n                d: typeof module.id === \"string\" ? module.id.replace(/(^|\\/)\\/+$/, \"\") : module.id\n            }));\n        });\n    } catch (error) {\n        module.error = error;\n        throw error;\n    }\n    module.loaded = true;\n    if (module.namespaceObject && module.exports !== module.namespaceObject) {\n        // in case of a circular dependency: cjs1 -> esm2 -> cjs1\n        interopEsm(module.exports, module.namespaceObject);\n    }\n    return module;\n}\n/**\r\n * NOTE(alexkirsz) Webpack has a \"module execution\" interception hook that\r\n * Next.js' React Refresh runtime hooks into to add module context to the\r\n * refresh registry.\r\n */ function runModuleExecutionHooks(module, executeModule) {\n    const cleanupReactRefreshIntercept = typeof globalThis.$RefreshInterceptModuleExecution$ === \"function\" ? globalThis.$RefreshInterceptModuleExecution$(module.id) : ()=>{};\n    try {\n        executeModule({\n            register: globalThis.$RefreshReg$,\n            signature: globalThis.$RefreshSig$,\n            registerExports: registerExportsAndSetupBoundaryForReactRefresh\n        });\n    } catch (e) {\n        throw e;\n    } finally{\n        // Always cleanup the intercept, even if module execution failed.\n        cleanupReactRefreshIntercept();\n    }\n}\n/**\r\n * This is adapted from https://github.com/vercel/next.js/blob/3466862d9dc9c8bb3131712134d38757b918d1c0/packages/react-refresh-utils/internal/ReactRefreshModule.runtime.ts\r\n */ function registerExportsAndSetupBoundaryForReactRefresh(module, helpers) {\n    const currentExports = module.exports;\n    const prevExports = module.hot.data.prevExports ?? null;\n    helpers.registerExportsForReactRefresh(currentExports, module.id);\n    // A module can be accepted automatically based on its exports, e.g. when\n    // it is a Refresh Boundary.\n    if (helpers.isReactRefreshBoundary(currentExports)) {\n        // Save the previous exports on update, so we can compare the boundary\n        // signatures.\n        module.hot.dispose((data)=>{\n            data.prevExports = currentExports;\n        });\n        // Unconditionally accept an update to this module, we'll check if it's\n        // still a Refresh Boundary later.\n        module.hot.accept();\n        // This field is set when the previous version of this module was a\n        // Refresh Boundary, letting us know we need to check for invalidation or\n        // enqueue an update.\n        if (prevExports !== null) {\n            // A boundary can become ineligible if its exports are incompatible\n            // with the previous exports.\n            //\n            // For example, if you add/remove/change exports, we'll want to\n            // re-execute the importing modules, and force those components to\n            // re-render. Similarly, if you convert a class component to a\n            // function, we want to invalidate the boundary.\n            if (helpers.shouldInvalidateReactRefreshBoundary(helpers.getRefreshBoundarySignature(prevExports), helpers.getRefreshBoundarySignature(currentExports))) {\n                module.hot.invalidate();\n            } else {\n                helpers.scheduleUpdate();\n            }\n        }\n    } else {\n        // Since we just executed the code for the module, it's possible that the\n        // new exports made it ineligible for being a boundary.\n        // We only care about the case when we were _previously_ a boundary,\n        // because we already accepted this update (accidental side effect).\n        const isNoLongerABoundary = prevExports !== null;\n        if (isNoLongerABoundary) {\n            module.hot.invalidate();\n        }\n    }\n}\nfunction formatDependencyChain(dependencyChain) {\n    return `Dependency chain: ${dependencyChain.join(\" -> \")}`;\n}\nfunction computeOutdatedModules(added, modified) {\n    const newModuleFactories = new Map();\n    for (const [moduleId, entry] of added){\n        if (entry != null) {\n            newModuleFactories.set(moduleId, _eval(entry));\n        }\n    }\n    const outdatedModules = computedInvalidatedModules(modified.keys());\n    for (const [moduleId, entry] of modified){\n        newModuleFactories.set(moduleId, _eval(entry));\n    }\n    return {\n        outdatedModules,\n        newModuleFactories\n    };\n}\nfunction computedInvalidatedModules(invalidated) {\n    const outdatedModules = new Set();\n    for (const moduleId of invalidated){\n        const effect = getAffectedModuleEffects(moduleId);\n        switch(effect.type){\n            case \"unaccepted\":\n                throw new UpdateApplyError(`cannot apply update: unaccepted module. ${formatDependencyChain(effect.dependencyChain)}.`, effect.dependencyChain);\n            case \"self-declined\":\n                throw new UpdateApplyError(`cannot apply update: self-declined module. ${formatDependencyChain(effect.dependencyChain)}.`, effect.dependencyChain);\n            case \"accepted\":\n                for (const outdatedModuleId of effect.outdatedModules){\n                    outdatedModules.add(outdatedModuleId);\n                }\n                break;\n            // TODO(alexkirsz) Dependencies: handle dependencies effects.\n            default:\n                invariant(effect, (effect)=>`Unknown effect type: ${effect?.type}`);\n        }\n    }\n    return outdatedModules;\n}\nfunction computeOutdatedSelfAcceptedModules(outdatedModules) {\n    const outdatedSelfAcceptedModules = [];\n    for (const moduleId of outdatedModules){\n        const module = devModuleCache[moduleId];\n        const hotState = moduleHotState.get(module);\n        if (module && hotState.selfAccepted && !hotState.selfInvalidated) {\n            outdatedSelfAcceptedModules.push({\n                moduleId,\n                errorHandler: hotState.selfAccepted\n            });\n        }\n    }\n    return outdatedSelfAcceptedModules;\n}\n/**\r\n * Adds, deletes, and moves modules between chunks. This must happen before the\r\n * dispose phase as it needs to know which modules were removed from all chunks,\r\n * which we can only compute *after* taking care of added and moved modules.\r\n */ function updateChunksPhase(chunksAddedModules, chunksDeletedModules) {\n    for (const [chunkPath, addedModuleIds] of chunksAddedModules){\n        for (const moduleId of addedModuleIds){\n            addModuleToChunk(moduleId, chunkPath);\n        }\n    }\n    const disposedModules = new Set();\n    for (const [chunkPath, addedModuleIds] of chunksDeletedModules){\n        for (const moduleId of addedModuleIds){\n            if (removeModuleFromChunk(moduleId, chunkPath)) {\n                disposedModules.add(moduleId);\n            }\n        }\n    }\n    return {\n        disposedModules\n    };\n}\nfunction disposePhase(outdatedModules, disposedModules) {\n    for (const moduleId of outdatedModules){\n        disposeModule(moduleId, \"replace\");\n    }\n    for (const moduleId of disposedModules){\n        disposeModule(moduleId, \"clear\");\n    }\n    // Removing modules from the module cache is a separate step.\n    // We also want to keep track of previous parents of the outdated modules.\n    const outdatedModuleParents = new Map();\n    for (const moduleId of outdatedModules){\n        const oldModule = devModuleCache[moduleId];\n        outdatedModuleParents.set(moduleId, oldModule?.parents);\n        delete devModuleCache[moduleId];\n    }\n    // TODO(alexkirsz) Dependencies: remove outdated dependency from module\n    // children.\n    return {\n        outdatedModuleParents\n    };\n}\n/**\r\n * Disposes of an instance of a module.\r\n *\r\n * Returns the persistent hot data that should be kept for the next module\r\n * instance.\r\n *\r\n * NOTE: mode = \"replace\" will not remove modules from the devModuleCache\r\n * This must be done in a separate step afterwards.\r\n * This is important because all modules need to be disposed to update the\r\n * parent/child relationships before they are actually removed from the devModuleCache.\r\n * If this was done in this method, the following disposeModule calls won't find\r\n * the module from the module id in the cache.\r\n */ function disposeModule(moduleId, mode) {\n    const module = devModuleCache[moduleId];\n    if (!module) {\n        return;\n    }\n    const hotState = moduleHotState.get(module);\n    const data = {};\n    // Run the `hot.dispose` handler, if any, passing in the persistent\n    // `hot.data` object.\n    for (const disposeHandler of hotState.disposeHandlers){\n        disposeHandler(data);\n    }\n    // This used to warn in `getOrInstantiateModuleFromParent` when a disposed\n    // module is still importing other modules.\n    module.hot.active = false;\n    moduleHotState.delete(module);\n    // TODO(alexkirsz) Dependencies: delete the module from outdated deps.\n    // Remove the disposed module from its children's parent list.\n    // It will be added back once the module re-instantiates and imports its\n    // children again.\n    for (const childId of module.children){\n        const child = devModuleCache[childId];\n        if (!child) {\n            continue;\n        }\n        const idx = child.parents.indexOf(module.id);\n        if (idx >= 0) {\n            child.parents.splice(idx, 1);\n        }\n    }\n    switch(mode){\n        case \"clear\":\n            delete devModuleCache[module.id];\n            moduleHotData.delete(module.id);\n            break;\n        case \"replace\":\n            moduleHotData.set(module.id, data);\n            break;\n        default:\n            invariant(mode, (mode)=>`invalid mode: ${mode}`);\n    }\n}\nfunction applyPhase(outdatedSelfAcceptedModules, newModuleFactories, outdatedModuleParents, reportError) {\n    // Update module factories.\n    for (const [moduleId, factory] of newModuleFactories.entries()){\n        moduleFactories[moduleId] = factory;\n    }\n    // TODO(alexkirsz) Run new runtime entries here.\n    // TODO(alexkirsz) Dependencies: call accept handlers for outdated deps.\n    // Re-instantiate all outdated self-accepted modules.\n    for (const { moduleId, errorHandler } of outdatedSelfAcceptedModules){\n        try {\n            instantiateModule(moduleId, {\n                type: SourceType.Update,\n                parents: outdatedModuleParents.get(moduleId)\n            });\n        } catch (err) {\n            if (typeof errorHandler === \"function\") {\n                try {\n                    errorHandler(err, {\n                        moduleId,\n                        module: devModuleCache[moduleId]\n                    });\n                } catch (err2) {\n                    reportError(err2);\n                    reportError(err);\n                }\n            } else {\n                reportError(err);\n            }\n        }\n    }\n}\nfunction applyUpdate(update) {\n    switch(update.type){\n        case \"ChunkListUpdate\":\n            applyChunkListUpdate(update);\n            break;\n        default:\n            invariant(update, (update)=>`Unknown update type: ${update.type}`);\n    }\n}\nfunction applyChunkListUpdate(update) {\n    if (update.merged != null) {\n        for (const merged of update.merged){\n            switch(merged.type){\n                case \"EcmascriptMergedUpdate\":\n                    applyEcmascriptMergedUpdate(merged);\n                    break;\n                default:\n                    invariant(merged, (merged)=>`Unknown merged type: ${merged.type}`);\n            }\n        }\n    }\n    if (update.chunks != null) {\n        for (const [chunkPath, chunkUpdate] of Object.entries(update.chunks)){\n            const chunkUrl = getChunkRelativeUrl(chunkPath);\n            switch(chunkUpdate.type){\n                case \"added\":\n                    BACKEND.loadChunk(chunkUrl, {\n                        type: SourceType.Update\n                    });\n                    break;\n                case \"total\":\n                    DEV_BACKEND.reloadChunk?.(chunkUrl);\n                    break;\n                case \"deleted\":\n                    DEV_BACKEND.unloadChunk?.(chunkUrl);\n                    break;\n                case \"partial\":\n                    invariant(chunkUpdate.instruction, (instruction)=>`Unknown partial instruction: ${JSON.stringify(instruction)}.`);\n                    break;\n                default:\n                    invariant(chunkUpdate, (chunkUpdate)=>`Unknown chunk update type: ${chunkUpdate.type}`);\n            }\n        }\n    }\n}\nfunction applyEcmascriptMergedUpdate(update) {\n    const { entries = {}, chunks = {} } = update;\n    const { added, modified, chunksAdded, chunksDeleted } = computeChangedModules(entries, chunks);\n    const { outdatedModules, newModuleFactories } = computeOutdatedModules(added, modified);\n    const { disposedModules } = updateChunksPhase(chunksAdded, chunksDeleted);\n    applyInternal(outdatedModules, disposedModules, newModuleFactories);\n}\nfunction applyInvalidatedModules(outdatedModules) {\n    if (queuedInvalidatedModules.size > 0) {\n        computedInvalidatedModules(queuedInvalidatedModules).forEach((moduleId)=>{\n            outdatedModules.add(moduleId);\n        });\n        queuedInvalidatedModules.clear();\n    }\n    return outdatedModules;\n}\nfunction applyInternal(outdatedModules, disposedModules, newModuleFactories) {\n    outdatedModules = applyInvalidatedModules(outdatedModules);\n    const outdatedSelfAcceptedModules = computeOutdatedSelfAcceptedModules(outdatedModules);\n    const { outdatedModuleParents } = disposePhase(outdatedModules, disposedModules);\n    // we want to continue on error and only throw the error after we tried applying all updates\n    let error;\n    function reportError(err) {\n        if (!error) error = err;\n    }\n    applyPhase(outdatedSelfAcceptedModules, newModuleFactories, outdatedModuleParents, reportError);\n    if (error) {\n        throw error;\n    }\n    if (queuedInvalidatedModules.size > 0) {\n        applyInternal(new Set(), [], new Map());\n    }\n}\nfunction computeChangedModules(entries, updates) {\n    const chunksAdded = new Map();\n    const chunksDeleted = new Map();\n    const added = new Map();\n    const modified = new Map();\n    const deleted = new Set();\n    for (const [chunkPath, mergedChunkUpdate] of Object.entries(updates)){\n        switch(mergedChunkUpdate.type){\n            case \"added\":\n                {\n                    const updateAdded = new Set(mergedChunkUpdate.modules);\n                    for (const moduleId of updateAdded){\n                        added.set(moduleId, entries[moduleId]);\n                    }\n                    chunksAdded.set(chunkPath, updateAdded);\n                    break;\n                }\n            case \"deleted\":\n                {\n                    // We could also use `mergedChunkUpdate.modules` here.\n                    const updateDeleted = new Set(chunkModulesMap.get(chunkPath));\n                    for (const moduleId of updateDeleted){\n                        deleted.add(moduleId);\n                    }\n                    chunksDeleted.set(chunkPath, updateDeleted);\n                    break;\n                }\n            case \"partial\":\n                {\n                    const updateAdded = new Set(mergedChunkUpdate.added);\n                    const updateDeleted = new Set(mergedChunkUpdate.deleted);\n                    for (const moduleId of updateAdded){\n                        added.set(moduleId, entries[moduleId]);\n                    }\n                    for (const moduleId of updateDeleted){\n                        deleted.add(moduleId);\n                    }\n                    chunksAdded.set(chunkPath, updateAdded);\n                    chunksDeleted.set(chunkPath, updateDeleted);\n                    break;\n                }\n            default:\n                invariant(mergedChunkUpdate, (mergedChunkUpdate)=>`Unknown merged chunk update type: ${mergedChunkUpdate.type}`);\n        }\n    }\n    // If a module was added from one chunk and deleted from another in the same update,\n    // consider it to be modified, as it means the module was moved from one chunk to another\n    // AND has new code in a single update.\n    for (const moduleId of added.keys()){\n        if (deleted.has(moduleId)) {\n            added.delete(moduleId);\n            deleted.delete(moduleId);\n        }\n    }\n    for (const [moduleId, entry] of Object.entries(entries)){\n        // Modules that haven't been added to any chunk but have new code are considered\n        // to be modified.\n        // This needs to be under the previous loop, as we need it to get rid of modules\n        // that were added and deleted in the same update.\n        if (!added.has(moduleId)) {\n            modified.set(moduleId, entry);\n        }\n    }\n    return {\n        added,\n        deleted,\n        modified,\n        chunksAdded,\n        chunksDeleted\n    };\n}\nfunction getAffectedModuleEffects(moduleId) {\n    const outdatedModules = new Set();\n    const queue = [\n        {\n            moduleId,\n            dependencyChain: []\n        }\n    ];\n    let nextItem;\n    while(nextItem = queue.shift()){\n        const { moduleId, dependencyChain } = nextItem;\n        if (moduleId != null) {\n            if (outdatedModules.has(moduleId)) {\n                continue;\n            }\n            outdatedModules.add(moduleId);\n        }\n        // We've arrived at the runtime of the chunk, which means that nothing\n        // else above can accept this update.\n        if (moduleId === undefined) {\n            return {\n                type: \"unaccepted\",\n                dependencyChain\n            };\n        }\n        const module = devModuleCache[moduleId];\n        const hotState = moduleHotState.get(module);\n        if (// The module is not in the cache. Since this is a \"modified\" update,\n        // it means that the module was never instantiated before.\n        !module || hotState.selfAccepted && !hotState.selfInvalidated) {\n            continue;\n        }\n        if (hotState.selfDeclined) {\n            return {\n                type: \"self-declined\",\n                dependencyChain,\n                moduleId\n            };\n        }\n        if (runtimeModules.has(moduleId)) {\n            queue.push({\n                moduleId: undefined,\n                dependencyChain: [\n                    ...dependencyChain,\n                    moduleId\n                ]\n            });\n            continue;\n        }\n        for (const parentId of module.parents){\n            const parent = devModuleCache[parentId];\n            if (!parent) {\n                continue;\n            }\n            // TODO(alexkirsz) Dependencies: check accepted and declined\n            // dependencies here.\n            queue.push({\n                moduleId: parentId,\n                dependencyChain: [\n                    ...dependencyChain,\n                    moduleId\n                ]\n            });\n        }\n    }\n    return {\n        type: \"accepted\",\n        moduleId,\n        outdatedModules\n    };\n}\nfunction handleApply(chunkListPath, update) {\n    switch(update.type){\n        case \"partial\":\n            {\n                // This indicates that the update is can be applied to the current state of the application.\n                applyUpdate(update.instruction);\n                break;\n            }\n        case \"restart\":\n            {\n                // This indicates that there is no way to apply the update to the\n                // current state of the application, and that the application must be\n                // restarted.\n                DEV_BACKEND.restart();\n                break;\n            }\n        case \"notFound\":\n            {\n                // This indicates that the chunk list no longer exists: either the dynamic import which created it was removed,\n                // or the page itself was deleted.\n                // If it is a dynamic import, we simply discard all modules that the chunk has exclusive access to.\n                // If it is a runtime chunk list, we restart the application.\n                if (runtimeChunkLists.has(chunkListPath)) {\n                    DEV_BACKEND.restart();\n                } else {\n                    disposeChunkList(chunkListPath);\n                }\n                break;\n            }\n        default:\n            throw new Error(`Unknown update type: ${update.type}`);\n    }\n}\nfunction createModuleHot(moduleId, hotData) {\n    const hotState = {\n        selfAccepted: false,\n        selfDeclined: false,\n        selfInvalidated: false,\n        disposeHandlers: []\n    };\n    const hot = {\n        // TODO(alexkirsz) This is not defined in the HMR API. It was used to\n        // decide whether to warn whenever an HMR-disposed module required other\n        // modules. We might want to remove it.\n        active: true,\n        data: hotData ?? {},\n        // TODO(alexkirsz) Support full (dep, callback, errorHandler) form.\n        accept: (modules, _callback, _errorHandler)=>{\n            if (modules === undefined) {\n                hotState.selfAccepted = true;\n            } else if (typeof modules === \"function\") {\n                hotState.selfAccepted = modules;\n            } else {\n                throw new Error(\"unsupported `accept` signature\");\n            }\n        },\n        decline: (dep)=>{\n            if (dep === undefined) {\n                hotState.selfDeclined = true;\n            } else {\n                throw new Error(\"unsupported `decline` signature\");\n            }\n        },\n        dispose: (callback)=>{\n            hotState.disposeHandlers.push(callback);\n        },\n        addDisposeHandler: (callback)=>{\n            hotState.disposeHandlers.push(callback);\n        },\n        removeDisposeHandler: (callback)=>{\n            const idx = hotState.disposeHandlers.indexOf(callback);\n            if (idx >= 0) {\n                hotState.disposeHandlers.splice(idx, 1);\n            }\n        },\n        invalidate: ()=>{\n            hotState.selfInvalidated = true;\n            queuedInvalidatedModules.add(moduleId);\n        },\n        // NOTE(alexkirsz) This is part of the management API, which we don't\n        // implement, but the Next.js React Refresh runtime uses this to decide\n        // whether to schedule an update.\n        status: ()=>\"idle\",\n        // NOTE(alexkirsz) Since we always return \"idle\" for now, these are no-ops.\n        addStatusHandler: (_handler)=>{},\n        removeStatusHandler: (_handler)=>{},\n        // NOTE(jridgewell) Check returns the list of updated modules, but we don't\n        // want the webpack code paths to ever update (the turbopack paths handle\n        // this already).\n        check: ()=>Promise.resolve(null)\n    };\n    return {\n        hot,\n        hotState\n    };\n}\n/**\r\n * Removes a module from a chunk.\r\n * Returns `true` if there are no remaining chunks including this module.\r\n */ function removeModuleFromChunk(moduleId, chunkPath) {\n    const moduleChunks = moduleChunksMap.get(moduleId);\n    moduleChunks.delete(chunkPath);\n    const chunkModules = chunkModulesMap.get(chunkPath);\n    chunkModules.delete(moduleId);\n    const noRemainingModules = chunkModules.size === 0;\n    if (noRemainingModules) {\n        chunkModulesMap.delete(chunkPath);\n    }\n    const noRemainingChunks = moduleChunks.size === 0;\n    if (noRemainingChunks) {\n        moduleChunksMap.delete(moduleId);\n    }\n    return noRemainingChunks;\n}\n/**\r\n * Disposes of a chunk list and its corresponding exclusive chunks.\r\n */ function disposeChunkList(chunkListPath) {\n    const chunkPaths = chunkListChunksMap.get(chunkListPath);\n    if (chunkPaths == null) {\n        return false;\n    }\n    chunkListChunksMap.delete(chunkListPath);\n    for (const chunkPath of chunkPaths){\n        const chunkChunkLists = chunkChunkListsMap.get(chunkPath);\n        chunkChunkLists.delete(chunkListPath);\n        if (chunkChunkLists.size === 0) {\n            chunkChunkListsMap.delete(chunkPath);\n            disposeChunk(chunkPath);\n        }\n    }\n    // We must also dispose of the chunk list's chunk itself to ensure it may\n    // be reloaded properly in the future.\n    const chunkListUrl = getChunkRelativeUrl(chunkListPath);\n    DEV_BACKEND.unloadChunk?.(chunkListUrl);\n    return true;\n}\n/**\r\n * Disposes of a chunk and its corresponding exclusive modules.\r\n *\r\n * @returns Whether the chunk was disposed of.\r\n */ function disposeChunk(chunkPath) {\n    const chunkUrl = getChunkRelativeUrl(chunkPath);\n    // This should happen whether the chunk has any modules in it or not.\n    // For instance, CSS chunks have no modules in them, but they still need to be unloaded.\n    DEV_BACKEND.unloadChunk?.(chunkUrl);\n    const chunkModules = chunkModulesMap.get(chunkPath);\n    if (chunkModules == null) {\n        return false;\n    }\n    chunkModules.delete(chunkPath);\n    for (const moduleId of chunkModules){\n        const moduleChunks = moduleChunksMap.get(moduleId);\n        moduleChunks.delete(chunkPath);\n        const noRemainingChunks = moduleChunks.size === 0;\n        if (noRemainingChunks) {\n            moduleChunksMap.delete(moduleId);\n            disposeModule(moduleId, \"clear\");\n            availableModules.delete(moduleId);\n        }\n    }\n    return true;\n}\n/**\r\n * Subscribes to chunk list updates from the update server and applies them.\r\n */ function registerChunkList(chunkList) {\n    const chunkListScript = chunkList.script;\n    const chunkListPath = getPathFromScript(chunkListScript);\n    // The \"chunk\" is also registered to finish the loading in the backend\n    BACKEND.registerChunk(chunkListPath);\n    globalThis.TURBOPACK_CHUNK_UPDATE_LISTENERS.push([\n        chunkListPath,\n        handleApply.bind(null, chunkListPath)\n    ]);\n    // Adding chunks to chunk lists and vice versa.\n    const chunkPaths = new Set(chunkList.chunks.map(getChunkPath));\n    chunkListChunksMap.set(chunkListPath, chunkPaths);\n    for (const chunkPath of chunkPaths){\n        let chunkChunkLists = chunkChunkListsMap.get(chunkPath);\n        if (!chunkChunkLists) {\n            chunkChunkLists = new Set([\n                chunkListPath\n            ]);\n            chunkChunkListsMap.set(chunkPath, chunkChunkLists);\n        } else {\n            chunkChunkLists.add(chunkListPath);\n        }\n    }\n    if (chunkList.source === \"entry\") {\n        markChunkListAsRuntime(chunkListPath);\n    }\n}\nglobalThis.TURBOPACK_CHUNK_UPDATE_LISTENERS ??= [];\n/**\r\n * This file contains the runtime code specific to the Turbopack development\r\n * ECMAScript DOM runtime.\r\n *\r\n * It will be appended to the base development runtime code.\r\n */ /* eslint-disable @typescript-eslint/no-unused-vars */ /// <reference path=\"../../../browser/runtime/base/runtime-base.ts\" />\n/// <reference path=\"../../../shared/runtime-types.d.ts\" />\nlet BACKEND;\nfunction augmentContext(context) {\n    return context;\n}\nfunction fetchWebAssembly(wasmChunkPath) {\n    return fetch(getChunkRelativeUrl(wasmChunkPath));\n}\nasync function loadWebAssembly(_source, wasmChunkPath, importsObj) {\n    const req = fetchWebAssembly(wasmChunkPath);\n    const { instance } = await WebAssembly.instantiateStreaming(req, importsObj);\n    return instance.exports;\n}\nasync function loadWebAssemblyModule(_source, wasmChunkPath) {\n    const req = fetchWebAssembly(wasmChunkPath);\n    return await WebAssembly.compileStreaming(req);\n}\n/**\r\n * Maps chunk paths to the corresponding resolver.\r\n */ const chunkResolvers = new Map();\n(()=>{\n    BACKEND = {\n        async registerChunk (chunkPath, params) {\n            const chunkUrl = getChunkRelativeUrl(chunkPath);\n            const resolver = getOrCreateResolver(chunkUrl);\n            resolver.resolve();\n            if (params == null) {\n                return;\n            }\n            for (const otherChunkData of params.otherChunks){\n                const otherChunkPath = getChunkPath(otherChunkData);\n                const otherChunkUrl = getChunkRelativeUrl(otherChunkPath);\n                // Chunk might have started loading, so we want to avoid triggering another load.\n                getOrCreateResolver(otherChunkUrl);\n            }\n            // This waits for chunks to be loaded, but also marks included items as available.\n            await Promise.all(params.otherChunks.map((otherChunkData)=>loadChunk({\n                    type: SourceType.Runtime,\n                    chunkPath\n                }, otherChunkData)));\n            if (params.runtimeModuleIds.length > 0) {\n                for (const moduleId of params.runtimeModuleIds){\n                    getOrInstantiateRuntimeModule(moduleId, chunkPath);\n                }\n            }\n        },\n        /**\r\n     * Loads the given chunk, and returns a promise that resolves once the chunk\r\n     * has been loaded.\r\n    */ loadChunk (chunkUrl, source) {\n            return doLoadChunk(chunkUrl, source);\n        }\n    };\n    function getOrCreateResolver(chunkUrl) {\n        let resolver = chunkResolvers.get(chunkUrl);\n        if (!resolver) {\n            let resolve;\n            let reject;\n            const promise = new Promise((innerResolve, innerReject)=>{\n                resolve = innerResolve;\n                reject = innerReject;\n            });\n            resolver = {\n                resolved: false,\n                promise,\n                resolve: ()=>{\n                    resolver.resolved = true;\n                    resolve();\n                },\n                reject: reject\n            };\n            chunkResolvers.set(chunkUrl, resolver);\n        }\n        return resolver;\n    }\n    /**\r\n    * Loads the given chunk, and returns a promise that resolves once the chunk\r\n    * has been loaded.\r\n    */ function doLoadChunk(chunkUrl, source) {\n        const resolver = getOrCreateResolver(chunkUrl);\n        if (resolver.resolved) {\n            return resolver.promise;\n        }\n        if (source.type === SourceType.Runtime) {\n            // We don't need to load chunks references from runtime code, as they're already\n            // present in the DOM.\n            if (isCss(chunkUrl)) {\n                // CSS chunks do not register themselves, and as such must be marked as\n                // loaded instantly.\n                resolver.resolve();\n            }\n            // We need to wait for JS chunks to register themselves within `registerChunk`\n            // before we can start instantiating runtime modules, hence the absence of\n            // `resolver.resolve()` in this branch.\n            return resolver.promise;\n        }\n        if (typeof importScripts === \"function\") {\n            // We're in a web worker\n            if (isCss(chunkUrl)) {\n            // ignore\n            } else if (isJs(chunkUrl)) {\n                self.TURBOPACK_NEXT_CHUNK_URLS.push(chunkUrl);\n                importScripts(TURBOPACK_WORKER_LOCATION + chunkUrl);\n            } else {\n                throw new Error(`can't infer type of chunk from URL ${chunkUrl} in worker`);\n            }\n        } else {\n            // TODO(PACK-2140): remove this once all filenames are guaranteed to be escaped.\n            const decodedChunkUrl = decodeURI(chunkUrl);\n            if (isCss(chunkUrl)) {\n                const previousLinks = document.querySelectorAll(`link[rel=stylesheet][href=\"${chunkUrl}\"],link[rel=stylesheet][href^=\"${chunkUrl}?\"],link[rel=stylesheet][href=\"${decodedChunkUrl}\"],link[rel=stylesheet][href^=\"${decodedChunkUrl}?\"]`);\n                if (previousLinks.length > 0) {\n                    // CSS chunks do not register themselves, and as such must be marked as\n                    // loaded instantly.\n                    resolver.resolve();\n                } else {\n                    const link = document.createElement(\"link\");\n                    link.rel = \"stylesheet\";\n                    link.href = chunkUrl;\n                    link.onerror = ()=>{\n                        resolver.reject();\n                    };\n                    link.onload = ()=>{\n                        // CSS chunks do not register themselves, and as such must be marked as\n                        // loaded instantly.\n                        resolver.resolve();\n                    };\n                    document.body.appendChild(link);\n                }\n            } else if (isJs(chunkUrl)) {\n                const previousScripts = document.querySelectorAll(`script[src=\"${chunkUrl}\"],script[src^=\"${chunkUrl}?\"],script[src=\"${decodedChunkUrl}\"],script[src^=\"${decodedChunkUrl}?\"]`);\n                if (previousScripts.length > 0) {\n                    // There is this edge where the script already failed loading, but we\n                    // can't detect that. The Promise will never resolve in this case.\n                    for (const script of Array.from(previousScripts)){\n                        script.addEventListener(\"error\", ()=>{\n                            resolver.reject();\n                        });\n                    }\n                } else {\n                    const script = document.createElement(\"script\");\n                    script.src = chunkUrl;\n                    // We'll only mark the chunk as loaded once the script has been executed,\n                    // which happens in `registerChunk`. Hence the absence of `resolve()` in\n                    // this branch.\n                    script.onerror = ()=>{\n                        resolver.reject();\n                    };\n                    document.body.appendChild(script);\n                }\n            } else {\n                throw new Error(`can't infer type of chunk from URL ${chunkUrl}`);\n            }\n        }\n        return resolver.promise;\n    }\n})();\n/**\r\n * This file contains the runtime code specific to the Turbopack development\r\n * ECMAScript DOM runtime.\r\n *\r\n * It will be appended to the base development runtime code.\r\n */ /* eslint-disable @typescript-eslint/no-unused-vars */ /// <reference path=\"../base/runtime-base.ts\" />\n/// <reference path=\"../base/dev-base.ts\" />\n/// <reference path=\"./runtime-backend-dom.ts\" />\n/// <reference path=\"../../../shared/require-type.d.ts\" />\nlet DEV_BACKEND;\n(()=>{\n    DEV_BACKEND = {\n        unloadChunk (chunkUrl) {\n            deleteResolver(chunkUrl);\n            // TODO(PACK-2140): remove this once all filenames are guaranteed to be escaped.\n            const decodedChunkUrl = decodeURI(chunkUrl);\n            if (isCss(chunkUrl)) {\n                const links = document.querySelectorAll(`link[href=\"${chunkUrl}\"],link[href^=\"${chunkUrl}?\"],link[href=\"${decodedChunkUrl}\"],link[href^=\"${decodedChunkUrl}?\"]`);\n                for (const link of Array.from(links)){\n                    link.remove();\n                }\n            } else if (isJs(chunkUrl)) {\n                // Unloading a JS chunk would have no effect, as it lives in the JS\n                // runtime once evaluated.\n                // However, we still want to remove the script tag from the DOM to keep\n                // the HTML somewhat consistent from the user's perspective.\n                const scripts = document.querySelectorAll(`script[src=\"${chunkUrl}\"],script[src^=\"${chunkUrl}?\"],script[src=\"${decodedChunkUrl}\"],script[src^=\"${decodedChunkUrl}?\"]`);\n                for (const script of Array.from(scripts)){\n                    script.remove();\n                }\n            } else {\n                throw new Error(`can't infer type of chunk from URL ${chunkUrl}`);\n            }\n        },\n        reloadChunk (chunkUrl) {\n            return new Promise((resolve, reject)=>{\n                if (!isCss(chunkUrl)) {\n                    reject(new Error(\"The DOM backend can only reload CSS chunks\"));\n                    return;\n                }\n                const decodedChunkUrl = decodeURI(chunkUrl);\n                const previousLinks = document.querySelectorAll(`link[rel=stylesheet][href=\"${chunkUrl}\"],link[rel=stylesheet][href^=\"${chunkUrl}?\"],link[rel=stylesheet][href=\"${decodedChunkUrl}\"],link[rel=stylesheet][href^=\"${decodedChunkUrl}?\"]`);\n                if (previousLinks.length === 0) {\n                    reject(new Error(`No link element found for chunk ${chunkUrl}`));\n                    return;\n                }\n                const link = document.createElement(\"link\");\n                link.rel = \"stylesheet\";\n                if (navigator.userAgent.includes(\"Firefox\")) {\n                    // Firefox won't reload CSS files that were previously loaded on the current page,\n                    // we need to add a query param to make sure CSS is actually reloaded from the server.\n                    //\n                    // I believe this is this issue: https://bugzilla.mozilla.org/show_bug.cgi?id=1037506\n                    //\n                    // Safari has a similar issue, but only if you have a `<link rel=preload ... />` tag\n                    // pointing to the same URL as the stylesheet: https://bugs.webkit.org/show_bug.cgi?id=187726\n                    link.href = `${chunkUrl}?ts=${Date.now()}`;\n                } else {\n                    link.href = chunkUrl;\n                }\n                link.onerror = ()=>{\n                    reject();\n                };\n                link.onload = ()=>{\n                    // First load the new CSS, then remove the old ones. This prevents visible\n                    // flickering that would happen in-between removing the previous CSS and\n                    // loading the new one.\n                    for (const previousLink of Array.from(previousLinks))previousLink.remove();\n                    // CSS chunks do not register themselves, and as such must be marked as\n                    // loaded instantly.\n                    resolve();\n                };\n                // Make sure to insert the new CSS right after the previous one, so that\n                // its precedence is higher.\n                previousLinks[0].parentElement.insertBefore(link, previousLinks[0].nextSibling);\n            });\n        },\n        restart: ()=>self.location.reload()\n    };\n    function deleteResolver(chunkUrl) {\n        chunkResolvers.delete(chunkUrl);\n    }\n})();\nfunction _eval({ code, url, map }) {\n    code += `\\n\\n//# sourceURL=${encodeURI(location.origin + CHUNK_BASE_PATH + url + CHUNK_SUFFIX_PATH)}`;\n    if (map) {\n        code += `\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,${btoa(// btoa doesn't handle nonlatin characters, so escape them as \\x sequences\n        // See https://stackoverflow.com/a/26603875\n        unescape(encodeURIComponent(map)))}`;\n    }\n    // eslint-disable-next-line no-eval\n    return eval(code);\n}\nconst chunksToRegister = globalThis.TURBOPACK;\nglobalThis.TURBOPACK = { push: registerChunk };\nchunksToRegister.forEach(registerChunk);\nconst chunkListsToRegister = globalThis.TURBOPACK_CHUNK_LISTS || [];\nchunkListsToRegister.forEach(registerChunkList);\nglobalThis.TURBOPACK_CHUNK_LISTS = { push: registerChunkList };\n})();\n\n\n//# sourceMappingURL=pages__app_049595de._.js.map"
        }
    ]
}