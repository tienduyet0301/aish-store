{
    "sourceFile": ".next/static/chunks/[turbopack]_browser_dev_hmr-client_hmr-client_ts_61dcf9ba._.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891746905,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "(globalThis.TURBOPACK = globalThis.TURBOPACK || []).push([typeof document === \"object\" ? document.currentScript : undefined, {\n\n\"[turbopack]/browser/dev/hmr-client/hmr-client.ts [app-client] (ecmascript)\": ((__turbopack_context__) => {\n\"use strict\";\n\nvar { g: global, __dirname } = __turbopack_context__;\n{\n/// <reference path=\"../../../shared/runtime-types.d.ts\" />\n/// <reference path=\"../../runtime/base/dev-globals.d.ts\" />\n/// <reference path=\"../../runtime/base/dev-protocol.d.ts\" />\n/// <reference path=\"../../runtime/base/dev-extensions.ts\" />\n__turbopack_context__.s({\n    \"connect\": (()=>connect),\n    \"setHooks\": (()=>setHooks),\n    \"subscribeToUpdate\": (()=>subscribeToUpdate)\n});\nfunction connect({ addMessageListener, sendMessage, onUpdateError = console.error }) {\n    addMessageListener((msg)=>{\n        switch(msg.type){\n            case \"turbopack-connected\":\n                handleSocketConnected(sendMessage);\n                break;\n            default:\n                try {\n                    if (Array.isArray(msg.data)) {\n                        for(let i = 0; i < msg.data.length; i++){\n                            handleSocketMessage(msg.data[i]);\n                        }\n                    } else {\n                        handleSocketMessage(msg.data);\n                    }\n                    applyAggregatedUpdates();\n                } catch (e) {\n                    console.warn(\"[Fast Refresh] performing full reload\\n\\n\" + \"Fast Refresh will perform a full reload when you edit a file that's imported by modules outside of the React rendering tree.\\n\" + \"You might have a file which exports a React component but also exports a value that is imported by a non-React component file.\\n\" + \"Consider migrating the non-React component export to a separate file and importing it into both files.\\n\\n\" + \"It is also possible the parent component of the component you edited is a class component, which disables Fast Refresh.\\n\" + \"Fast Refresh requires at least one parent function component in your React tree.\");\n                    onUpdateError(e);\n                    location.reload();\n                }\n                break;\n        }\n    });\n    const queued = globalThis.TURBOPACK_CHUNK_UPDATE_LISTENERS;\n    if (queued != null && !Array.isArray(queued)) {\n        throw new Error(\"A separate HMR handler was already registered\");\n    }\n    globalThis.TURBOPACK_CHUNK_UPDATE_LISTENERS = {\n        push: ([chunkPath, callback])=>{\n            subscribeToChunkUpdate(chunkPath, sendMessage, callback);\n        }\n    };\n    if (Array.isArray(queued)) {\n        for (const [chunkPath, callback] of queued){\n            subscribeToChunkUpdate(chunkPath, sendMessage, callback);\n        }\n    }\n}\nconst updateCallbackSets = new Map();\nfunction sendJSON(sendMessage, message) {\n    sendMessage(JSON.stringify(message));\n}\nfunction resourceKey(resource) {\n    return JSON.stringify({\n        path: resource.path,\n        headers: resource.headers || null\n    });\n}\nfunction subscribeToUpdates(sendMessage, resource) {\n    sendJSON(sendMessage, {\n        type: \"turbopack-subscribe\",\n        ...resource\n    });\n    return ()=>{\n        sendJSON(sendMessage, {\n            type: \"turbopack-unsubscribe\",\n            ...resource\n        });\n    };\n}\nfunction handleSocketConnected(sendMessage) {\n    for (const key of updateCallbackSets.keys()){\n        subscribeToUpdates(sendMessage, JSON.parse(key));\n    }\n}\n// we aggregate all pending updates until the issues are resolved\nconst chunkListsWithPendingUpdates = new Map();\nfunction aggregateUpdates(msg) {\n    const key = resourceKey(msg.resource);\n    let aggregated = chunkListsWithPendingUpdates.get(key);\n    if (aggregated) {\n        aggregated.instruction = mergeChunkListUpdates(aggregated.instruction, msg.instruction);\n    } else {\n        chunkListsWithPendingUpdates.set(key, msg);\n    }\n}\nfunction applyAggregatedUpdates() {\n    if (chunkListsWithPendingUpdates.size === 0) return;\n    hooks.beforeRefresh();\n    for (const msg of chunkListsWithPendingUpdates.values()){\n        triggerUpdate(msg);\n    }\n    chunkListsWithPendingUpdates.clear();\n    finalizeUpdate();\n}\nfunction mergeChunkListUpdates(updateA, updateB) {\n    let chunks;\n    if (updateA.chunks != null) {\n        if (updateB.chunks == null) {\n            chunks = updateA.chunks;\n        } else {\n            chunks = mergeChunkListChunks(updateA.chunks, updateB.chunks);\n        }\n    } else if (updateB.chunks != null) {\n        chunks = updateB.chunks;\n    }\n    let merged;\n    if (updateA.merged != null) {\n        if (updateB.merged == null) {\n            merged = updateA.merged;\n        } else {\n            // Since `merged` is an array of updates, we need to merge them all into\n            // one, consistent update.\n            // Since there can only be `EcmascriptMergeUpdates` in the array, there is\n            // no need to key on the `type` field.\n            let update = updateA.merged[0];\n            for(let i = 1; i < updateA.merged.length; i++){\n                update = mergeChunkListEcmascriptMergedUpdates(update, updateA.merged[i]);\n            }\n            for(let i = 0; i < updateB.merged.length; i++){\n                update = mergeChunkListEcmascriptMergedUpdates(update, updateB.merged[i]);\n            }\n            merged = [\n                update\n            ];\n        }\n    } else if (updateB.merged != null) {\n        merged = updateB.merged;\n    }\n    return {\n        type: \"ChunkListUpdate\",\n        chunks,\n        merged\n    };\n}\nfunction mergeChunkListChunks(chunksA, chunksB) {\n    const chunks = {};\n    for (const [chunkPath, chunkUpdateA] of Object.entries(chunksA)){\n        const chunkUpdateB = chunksB[chunkPath];\n        if (chunkUpdateB != null) {\n            const mergedUpdate = mergeChunkUpdates(chunkUpdateA, chunkUpdateB);\n            if (mergedUpdate != null) {\n                chunks[chunkPath] = mergedUpdate;\n            }\n        } else {\n            chunks[chunkPath] = chunkUpdateA;\n        }\n    }\n    for (const [chunkPath, chunkUpdateB] of Object.entries(chunksB)){\n        if (chunks[chunkPath] == null) {\n            chunks[chunkPath] = chunkUpdateB;\n        }\n    }\n    return chunks;\n}\nfunction mergeChunkUpdates(updateA, updateB) {\n    if (updateA.type === \"added\" && updateB.type === \"deleted\" || updateA.type === \"deleted\" && updateB.type === \"added\") {\n        return undefined;\n    }\n    if (updateA.type === \"partial\") {\n        invariant(updateA.instruction, \"Partial updates are unsupported\");\n    }\n    if (updateB.type === \"partial\") {\n        invariant(updateB.instruction, \"Partial updates are unsupported\");\n    }\n    return undefined;\n}\nfunction mergeChunkListEcmascriptMergedUpdates(mergedA, mergedB) {\n    const entries = mergeEcmascriptChunkEntries(mergedA.entries, mergedB.entries);\n    const chunks = mergeEcmascriptChunksUpdates(mergedA.chunks, mergedB.chunks);\n    return {\n        type: \"EcmascriptMergedUpdate\",\n        entries,\n        chunks\n    };\n}\nfunction mergeEcmascriptChunkEntries(entriesA, entriesB) {\n    return {\n        ...entriesA,\n        ...entriesB\n    };\n}\nfunction mergeEcmascriptChunksUpdates(chunksA, chunksB) {\n    if (chunksA == null) {\n        return chunksB;\n    }\n    if (chunksB == null) {\n        return chunksA;\n    }\n    const chunks = {};\n    for (const [chunkPath, chunkUpdateA] of Object.entries(chunksA)){\n        const chunkUpdateB = chunksB[chunkPath];\n        if (chunkUpdateB != null) {\n            const mergedUpdate = mergeEcmascriptChunkUpdates(chunkUpdateA, chunkUpdateB);\n            if (mergedUpdate != null) {\n                chunks[chunkPath] = mergedUpdate;\n            }\n        } else {\n            chunks[chunkPath] = chunkUpdateA;\n        }\n    }\n    for (const [chunkPath, chunkUpdateB] of Object.entries(chunksB)){\n        if (chunks[chunkPath] == null) {\n            chunks[chunkPath] = chunkUpdateB;\n        }\n    }\n    if (Object.keys(chunks).length === 0) {\n        return undefined;\n    }\n    return chunks;\n}\nfunction mergeEcmascriptChunkUpdates(updateA, updateB) {\n    if (updateA.type === \"added\" && updateB.type === \"deleted\") {\n        // These two completely cancel each other out.\n        return undefined;\n    }\n    if (updateA.type === \"deleted\" && updateB.type === \"added\") {\n        const added = [];\n        const deleted = [];\n        const deletedModules = new Set(updateA.modules ?? []);\n        const addedModules = new Set(updateB.modules ?? []);\n        for (const moduleId of addedModules){\n            if (!deletedModules.has(moduleId)) {\n                added.push(moduleId);\n            }\n        }\n        for (const moduleId of deletedModules){\n            if (!addedModules.has(moduleId)) {\n                deleted.push(moduleId);\n            }\n        }\n        if (added.length === 0 && deleted.length === 0) {\n            return undefined;\n        }\n        return {\n            type: \"partial\",\n            added,\n            deleted\n        };\n    }\n    if (updateA.type === \"partial\" && updateB.type === \"partial\") {\n        const added = new Set([\n            ...updateA.added ?? [],\n            ...updateB.added ?? []\n        ]);\n        const deleted = new Set([\n            ...updateA.deleted ?? [],\n            ...updateB.deleted ?? []\n        ]);\n        if (updateB.added != null) {\n            for (const moduleId of updateB.added){\n                deleted.delete(moduleId);\n            }\n        }\n        if (updateB.deleted != null) {\n            for (const moduleId of updateB.deleted){\n                added.delete(moduleId);\n            }\n        }\n        return {\n            type: \"partial\",\n            added: [\n                ...added\n            ],\n            deleted: [\n                ...deleted\n            ]\n        };\n    }\n    if (updateA.type === \"added\" && updateB.type === \"partial\") {\n        const modules = new Set([\n            ...updateA.modules ?? [],\n            ...updateB.added ?? []\n        ]);\n        for (const moduleId of updateB.deleted ?? []){\n            modules.delete(moduleId);\n        }\n        return {\n            type: \"added\",\n            modules: [\n                ...modules\n            ]\n        };\n    }\n    if (updateA.type === \"partial\" && updateB.type === \"deleted\") {\n        // We could eagerly return `updateB` here, but this would potentially be\n        // incorrect if `updateA` has added modules.\n        const modules = new Set(updateB.modules ?? []);\n        if (updateA.added != null) {\n            for (const moduleId of updateA.added){\n                modules.delete(moduleId);\n            }\n        }\n        return {\n            type: \"deleted\",\n            modules: [\n                ...modules\n            ]\n        };\n    }\n    // Any other update combination is invalid.\n    return undefined;\n}\nfunction invariant(_, message) {\n    throw new Error(`Invariant: ${message}`);\n}\nconst CRITICAL = [\n    \"bug\",\n    \"error\",\n    \"fatal\"\n];\nfunction compareByList(list, a, b) {\n    const aI = list.indexOf(a) + 1 || list.length;\n    const bI = list.indexOf(b) + 1 || list.length;\n    return aI - bI;\n}\nconst chunksWithIssues = new Map();\nfunction emitIssues() {\n    const issues = [];\n    const deduplicationSet = new Set();\n    for (const [_, chunkIssues] of chunksWithIssues){\n        for (const chunkIssue of chunkIssues){\n            if (deduplicationSet.has(chunkIssue.formatted)) continue;\n            issues.push(chunkIssue);\n            deduplicationSet.add(chunkIssue.formatted);\n        }\n    }\n    sortIssues(issues);\n    hooks.issues(issues);\n}\nfunction handleIssues(msg) {\n    const key = resourceKey(msg.resource);\n    let hasCriticalIssues = false;\n    for (const issue of msg.issues){\n        if (CRITICAL.includes(issue.severity)) {\n            hasCriticalIssues = true;\n        }\n    }\n    if (msg.issues.length > 0) {\n        chunksWithIssues.set(key, msg.issues);\n    } else if (chunksWithIssues.has(key)) {\n        chunksWithIssues.delete(key);\n    }\n    emitIssues();\n    return hasCriticalIssues;\n}\nconst SEVERITY_ORDER = [\n    \"bug\",\n    \"fatal\",\n    \"error\",\n    \"warning\",\n    \"info\",\n    \"log\"\n];\nconst CATEGORY_ORDER = [\n    \"parse\",\n    \"resolve\",\n    \"code generation\",\n    \"rendering\",\n    \"typescript\",\n    \"other\"\n];\nfunction sortIssues(issues) {\n    issues.sort((a, b)=>{\n        const first = compareByList(SEVERITY_ORDER, a.severity, b.severity);\n        if (first !== 0) return first;\n        return compareByList(CATEGORY_ORDER, a.category, b.category);\n    });\n}\nconst hooks = {\n    beforeRefresh: ()=>{},\n    refresh: ()=>{},\n    buildOk: ()=>{},\n    issues: (_issues)=>{}\n};\nfunction setHooks(newHooks) {\n    Object.assign(hooks, newHooks);\n}\nfunction handleSocketMessage(msg) {\n    sortIssues(msg.issues);\n    handleIssues(msg);\n    switch(msg.type){\n        case \"issues\":\n            break;\n        case \"partial\":\n            // aggregate updates\n            aggregateUpdates(msg);\n            break;\n        default:\n            // run single update\n            const runHooks = chunkListsWithPendingUpdates.size === 0;\n            if (runHooks) hooks.beforeRefresh();\n            triggerUpdate(msg);\n            if (runHooks) finalizeUpdate();\n            break;\n    }\n}\nfunction finalizeUpdate() {\n    hooks.refresh();\n    hooks.buildOk();\n    // This is used by the Next.js integration test suite to notify it when HMR\n    // updates have been completed.\n    // TODO: Only run this in test environments (gate by `process.env.__NEXT_TEST_MODE`)\n    if (globalThis.__NEXT_HMR_CB) {\n        globalThis.__NEXT_HMR_CB();\n        globalThis.__NEXT_HMR_CB = null;\n    }\n}\nfunction subscribeToChunkUpdate(chunkListPath, sendMessage, callback) {\n    return subscribeToUpdate({\n        path: chunkListPath\n    }, sendMessage, callback);\n}\nfunction subscribeToUpdate(resource, sendMessage, callback) {\n    const key = resourceKey(resource);\n    let callbackSet;\n    const existingCallbackSet = updateCallbackSets.get(key);\n    if (!existingCallbackSet) {\n        callbackSet = {\n            callbacks: new Set([\n                callback\n            ]),\n            unsubscribe: subscribeToUpdates(sendMessage, resource)\n        };\n        updateCallbackSets.set(key, callbackSet);\n    } else {\n        existingCallbackSet.callbacks.add(callback);\n        callbackSet = existingCallbackSet;\n    }\n    return ()=>{\n        callbackSet.callbacks.delete(callback);\n        if (callbackSet.callbacks.size === 0) {\n            callbackSet.unsubscribe();\n            updateCallbackSets.delete(key);\n        }\n    };\n}\nfunction triggerUpdate(msg) {\n    const key = resourceKey(msg.resource);\n    const callbackSet = updateCallbackSets.get(key);\n    if (!callbackSet) {\n        return;\n    }\n    for (const callback of callbackSet.callbacks){\n        callback(msg);\n    }\n    if (msg.type === \"notFound\") {\n        // This indicates that the resource which we subscribed to either does not exist or\n        // has been deleted. In either case, we should clear all update callbacks, so if a\n        // new subscription is created for the same resource, it will send a new \"subscribe\"\n        // message to the server.\n        // No need to send an \"unsubscribe\" message to the server, it will have already\n        // dropped the update stream before sending the \"notFound\" message.\n        updateCallbackSets.delete(key);\n    }\n}\n}}),\n}]);\n\n//# sourceMappingURL=%5Bturbopack%5D_browser_dev_hmr-client_hmr-client_ts_61dcf9ba._.js.map"
        }
    ]
}