{
    "sourceFile": ".next/server/chunks/[turbopack]_runtime.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891737189,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "const RUNTIME_PUBLIC_PATH = \"server/chunks/[turbopack]_runtime.js\";\nconst RELATIVE_ROOT_PATH = \"..\";\nconst ASSET_PREFIX = \"/\";\n/**\r\n * This file contains runtime types and functions that are shared between all\r\n * TurboPack ECMAScript runtimes.\r\n *\r\n * It will be prepended to the runtime code of each runtime.\r\n */ /* eslint-disable @typescript-eslint/no-unused-vars */ /// <reference path=\"./runtime-types.d.ts\" />\nconst REEXPORTED_OBJECTS = Symbol(\"reexported objects\");\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\nconst toStringTag = typeof Symbol !== \"undefined\" && Symbol.toStringTag;\nfunction defineProp(obj, name, options) {\n    if (!hasOwnProperty.call(obj, name)) Object.defineProperty(obj, name, options);\n}\n/**\r\n * Adds the getters to the exports object.\r\n */ function esm(exports, getters) {\n    defineProp(exports, \"__esModule\", {\n        value: true\n    });\n    if (toStringTag) defineProp(exports, toStringTag, {\n        value: \"Module\"\n    });\n    for(const key in getters){\n        const item = getters[key];\n        if (Array.isArray(item)) {\n            defineProp(exports, key, {\n                get: item[0],\n                set: item[1],\n                enumerable: true\n            });\n        } else {\n            defineProp(exports, key, {\n                get: item,\n                enumerable: true\n            });\n        }\n    }\n    Object.seal(exports);\n}\n/**\r\n * Makes the module an ESM with exports\r\n */ function esmExport(module, exports, getters) {\n    module.namespaceObject = module.exports;\n    esm(exports, getters);\n}\nfunction ensureDynamicExports(module, exports) {\n    let reexportedObjects = module[REEXPORTED_OBJECTS];\n    if (!reexportedObjects) {\n        reexportedObjects = module[REEXPORTED_OBJECTS] = [];\n        module.exports = module.namespaceObject = new Proxy(exports, {\n            get (target, prop) {\n                if (hasOwnProperty.call(target, prop) || prop === \"default\" || prop === \"__esModule\") {\n                    return Reflect.get(target, prop);\n                }\n                for (const obj of reexportedObjects){\n                    const value = Reflect.get(obj, prop);\n                    if (value !== undefined) return value;\n                }\n                return undefined;\n            },\n            ownKeys (target) {\n                const keys = Reflect.ownKeys(target);\n                for (const obj of reexportedObjects){\n                    for (const key of Reflect.ownKeys(obj)){\n                        if (key !== \"default\" && !keys.includes(key)) keys.push(key);\n                    }\n                }\n                return keys;\n            }\n        });\n    }\n}\n/**\r\n * Dynamically exports properties from an object\r\n */ function dynamicExport(module, exports, object) {\n    ensureDynamicExports(module, exports);\n    if (typeof object === \"object\" && object !== null) {\n        module[REEXPORTED_OBJECTS].push(object);\n    }\n}\nfunction exportValue(module, value) {\n    module.exports = value;\n}\nfunction exportNamespace(module, namespace) {\n    module.exports = module.namespaceObject = namespace;\n}\nfunction createGetter(obj, key) {\n    return ()=>obj[key];\n}\n/**\r\n * @returns prototype of the object\r\n */ const getProto = Object.getPrototypeOf ? (obj)=>Object.getPrototypeOf(obj) : (obj)=>obj.__proto__;\n/** Prototypes that are not expanded for exports */ const LEAF_PROTOTYPES = [\n    null,\n    getProto({}),\n    getProto([]),\n    getProto(getProto)\n];\n/**\r\n * @param raw\r\n * @param ns\r\n * @param allowExportDefault\r\n *   * `false`: will have the raw module as default export\r\n *   * `true`: will have the default property as default export\r\n */ function interopEsm(raw, ns, allowExportDefault) {\n    const getters = Object.create(null);\n    for(let current = raw; (typeof current === \"object\" || typeof current === \"function\") && !LEAF_PROTOTYPES.includes(current); current = getProto(current)){\n        for (const key of Object.getOwnPropertyNames(current)){\n            getters[key] = createGetter(raw, key);\n        }\n    }\n    // this is not really correct\n    // we should set the `default` getter if the imported module is a `.cjs file`\n    if (!(allowExportDefault && \"default\" in getters)) {\n        getters[\"default\"] = ()=>raw;\n    }\n    esm(ns, getters);\n    return ns;\n}\nfunction createNS(raw) {\n    if (typeof raw === \"function\") {\n        return function(...args) {\n            return raw.apply(this, args);\n        };\n    } else {\n        return Object.create(null);\n    }\n}\nfunction esmImport(sourceModule, id) {\n    const module = getOrInstantiateModuleFromParent(id, sourceModule);\n    if (module.error) throw module.error;\n    // any ES module has to have `module.namespaceObject` defined.\n    if (module.namespaceObject) return module.namespaceObject;\n    // only ESM can be an async module, so we don't need to worry about exports being a promise here.\n    const raw = module.exports;\n    return module.namespaceObject = interopEsm(raw, createNS(raw), raw && raw.__esModule);\n}\n// Add a simple runtime require so that environments without one can still pass\n// `typeof require` CommonJS checks so that exports are correctly registered.\nconst runtimeRequire = // @ts-ignore\ntypeof require === \"function\" ? require : function require1() {\n    throw new Error(\"Unexpected use of runtime require\");\n};\nfunction commonJsRequire(sourceModule, id) {\n    const module = getOrInstantiateModuleFromParent(id, sourceModule);\n    if (module.error) throw module.error;\n    return module.exports;\n}\n/**\r\n * `require.context` and require/import expression runtime.\r\n */ function moduleContext(map) {\n    function moduleContext(id) {\n        if (hasOwnProperty.call(map, id)) {\n            return map[id].module();\n        }\n        const e = new Error(`Cannot find module '${id}'`);\n        e.code = \"MODULE_NOT_FOUND\";\n        throw e;\n    }\n    moduleContext.keys = ()=>{\n        return Object.keys(map);\n    };\n    moduleContext.resolve = (id)=>{\n        if (hasOwnProperty.call(map, id)) {\n            return map[id].id();\n        }\n        const e = new Error(`Cannot find module '${id}'`);\n        e.code = \"MODULE_NOT_FOUND\";\n        throw e;\n    };\n    moduleContext.import = async (id)=>{\n        return await moduleContext(id);\n    };\n    return moduleContext;\n}\n/**\r\n * Returns the path of a chunk defined by its data.\r\n */ function getChunkPath(chunkData) {\n    return typeof chunkData === \"string\" ? chunkData : chunkData.path;\n}\nfunction isPromise(maybePromise) {\n    return maybePromise != null && typeof maybePromise === \"object\" && \"then\" in maybePromise && typeof maybePromise.then === \"function\";\n}\nfunction isAsyncModuleExt(obj) {\n    return turbopackQueues in obj;\n}\nfunction createPromise() {\n    let resolve;\n    let reject;\n    const promise = new Promise((res, rej)=>{\n        reject = rej;\n        resolve = res;\n    });\n    return {\n        promise,\n        resolve: resolve,\n        reject: reject\n    };\n}\n// everything below is adapted from webpack\n// https://github.com/webpack/webpack/blob/6be4065ade1e252c1d8dcba4af0f43e32af1bdc1/lib/runtime/AsyncModuleRuntimeModule.js#L13\nconst turbopackQueues = Symbol(\"turbopack queues\");\nconst turbopackExports = Symbol(\"turbopack exports\");\nconst turbopackError = Symbol(\"turbopack error\");\nfunction resolveQueue(queue) {\n    if (queue && queue.status !== 1) {\n        queue.status = 1;\n        queue.forEach((fn)=>fn.queueCount--);\n        queue.forEach((fn)=>fn.queueCount-- ? fn.queueCount++ : fn());\n    }\n}\nfunction wrapDeps(deps) {\n    return deps.map((dep)=>{\n        if (dep !== null && typeof dep === \"object\") {\n            if (isAsyncModuleExt(dep)) return dep;\n            if (isPromise(dep)) {\n                const queue = Object.assign([], {\n                    status: 0\n                });\n                const obj = {\n                    [turbopackExports]: {},\n                    [turbopackQueues]: (fn)=>fn(queue)\n                };\n                dep.then((res)=>{\n                    obj[turbopackExports] = res;\n                    resolveQueue(queue);\n                }, (err)=>{\n                    obj[turbopackError] = err;\n                    resolveQueue(queue);\n                });\n                return obj;\n            }\n        }\n        return {\n            [turbopackExports]: dep,\n            [turbopackQueues]: ()=>{}\n        };\n    });\n}\nfunction asyncModule(module, body, hasAwait) {\n    const queue = hasAwait ? Object.assign([], {\n        status: -1\n    }) : undefined;\n    const depQueues = new Set();\n    const { resolve, reject, promise: rawPromise } = createPromise();\n    const promise = Object.assign(rawPromise, {\n        [turbopackExports]: module.exports,\n        [turbopackQueues]: (fn)=>{\n            queue && fn(queue);\n            depQueues.forEach(fn);\n            promise[\"catch\"](()=>{});\n        }\n    });\n    const attributes = {\n        get () {\n            return promise;\n        },\n        set (v) {\n            // Calling `esmExport` leads to this.\n            if (v !== promise) {\n                promise[turbopackExports] = v;\n            }\n        }\n    };\n    Object.defineProperty(module, \"exports\", attributes);\n    Object.defineProperty(module, \"namespaceObject\", attributes);\n    function handleAsyncDependencies(deps) {\n        const currentDeps = wrapDeps(deps);\n        const getResult = ()=>currentDeps.map((d)=>{\n                if (d[turbopackError]) throw d[turbopackError];\n                return d[turbopackExports];\n            });\n        const { promise, resolve } = createPromise();\n        const fn = Object.assign(()=>resolve(getResult), {\n            queueCount: 0\n        });\n        function fnQueue(q) {\n            if (q !== queue && !depQueues.has(q)) {\n                depQueues.add(q);\n                if (q && q.status === 0) {\n                    fn.queueCount++;\n                    q.push(fn);\n                }\n            }\n        }\n        currentDeps.map((dep)=>dep[turbopackQueues](fnQueue));\n        return fn.queueCount ? promise : getResult();\n    }\n    function asyncResult(err) {\n        if (err) {\n            reject(promise[turbopackError] = err);\n        } else {\n            resolve(promise[turbopackExports]);\n        }\n        resolveQueue(queue);\n    }\n    body(handleAsyncDependencies, asyncResult);\n    if (queue && queue.status === -1) {\n        queue.status = 0;\n    }\n}\n/**\r\n * A pseudo \"fake\" URL object to resolve to its relative path.\r\n *\r\n * When UrlRewriteBehavior is set to relative, calls to the `new URL()` will construct url without base using this\r\n * runtime function to generate context-agnostic urls between different rendering context, i.e ssr / client to avoid\r\n * hydration mismatch.\r\n *\r\n * This is based on webpack's existing implementation:\r\n * https://github.com/webpack/webpack/blob/87660921808566ef3b8796f8df61bd79fc026108/lib/runtime/RelativeUrlRuntimeModule.js\r\n */ const relativeURL = function relativeURL(inputUrl) {\n    const realUrl = new URL(inputUrl, \"x:/\");\n    const values = {};\n    for(const key in realUrl)values[key] = realUrl[key];\n    values.href = inputUrl;\n    values.pathname = inputUrl.replace(/[?#].*/, \"\");\n    values.origin = values.protocol = \"\";\n    values.toString = values.toJSON = (..._args)=>inputUrl;\n    for(const key in values)Object.defineProperty(this, key, {\n        enumerable: true,\n        configurable: true,\n        value: values[key]\n    });\n};\nrelativeURL.prototype = URL.prototype;\n/**\r\n * Utility function to ensure all variants of an enum are handled.\r\n */ function invariant(never, computeMessage) {\n    throw new Error(`Invariant: ${computeMessage(never)}`);\n}\n/**\r\n * A stub function to make `require` available but non-functional in ESM.\r\n */ function requireStub(_moduleId) {\n    throw new Error(\"dynamic usage of require is not supported\");\n}\n/* eslint-disable @typescript-eslint/no-unused-vars */ /// <reference path=\"../shared/runtime-utils.ts\" />\n/// A 'base' utilities to support runtime can have externals.\n/// Currently this is for node.js / edge runtime both.\n/// If a fn requires node.js specific behavior, it should be placed in `node-external-utils` instead.\nasync function externalImport(id) {\n    let raw;\n    try {\n        raw = await import(id);\n    } catch (err) {\n        // TODO(alexkirsz) This can happen when a client-side module tries to load\n        // an external module we don't provide a shim for (e.g. querystring, url).\n        // For now, we fail semi-silently, but in the future this should be a\n        // compilation error.\n        throw new Error(`Failed to load external module ${id}: ${err}`);\n    }\n    if (raw && raw.__esModule && raw.default && 'default' in raw.default) {\n        return interopEsm(raw.default, createNS(raw), true);\n    }\n    return raw;\n}\nfunction externalRequire(id, thunk, esm = false) {\n    let raw;\n    try {\n        raw = thunk();\n    } catch (err) {\n        // TODO(alexkirsz) This can happen when a client-side module tries to load\n        // an external module we don't provide a shim for (e.g. querystring, url).\n        // For now, we fail semi-silently, but in the future this should be a\n        // compilation error.\n        throw new Error(`Failed to load external module ${id}: ${err}`);\n    }\n    if (!esm || raw.__esModule) {\n        return raw;\n    }\n    return interopEsm(raw, createNS(raw), true);\n}\nexternalRequire.resolve = (id, options)=>{\n    return require.resolve(id, options);\n};\n/* eslint-disable @typescript-eslint/no-unused-vars */ const path = require(\"path\");\nconst relativePathToRuntimeRoot = path.relative(RUNTIME_PUBLIC_PATH, \".\");\n// Compute the relative path to the `distDir`.\nconst relativePathToDistRoot = path.join(relativePathToRuntimeRoot, RELATIVE_ROOT_PATH);\nconst RUNTIME_ROOT = path.resolve(__filename, relativePathToRuntimeRoot);\n// Compute the absolute path to the root, by stripping distDir from the absolute path to this file.\nconst ABSOLUTE_ROOT = path.resolve(__filename, relativePathToDistRoot);\n/**\r\n * Returns an absolute path to the given module path.\r\n * Module path should be relative, either path to a file or a directory.\r\n *\r\n * This fn allows to calculate an absolute path for some global static values, such as\r\n * `__dirname` or `import.meta.url` that Turbopack will not embeds in compile time.\r\n * See ImportMetaBinding::code_generation for the usage.\r\n */ function resolveAbsolutePath(modulePath) {\n    if (modulePath) {\n        return path.join(ABSOLUTE_ROOT, modulePath);\n    }\n    return ABSOLUTE_ROOT;\n}\n/* eslint-disable @typescript-eslint/no-unused-vars */ /// <reference path=\"../shared/runtime-utils.ts\" />\nfunction readWebAssemblyAsResponse(path) {\n    const { createReadStream } = require(\"fs\");\n    const { Readable } = require(\"stream\");\n    const stream = createReadStream(path);\n    // @ts-ignore unfortunately there's a slight type mismatch with the stream.\n    return new Response(Readable.toWeb(stream), {\n        headers: {\n            \"content-type\": \"application/wasm\"\n        }\n    });\n}\nasync function compileWebAssemblyFromPath(path) {\n    const response = readWebAssemblyAsResponse(path);\n    return await WebAssembly.compileStreaming(response);\n}\nasync function instantiateWebAssemblyFromPath(path, importsObj) {\n    const response = readWebAssemblyAsResponse(path);\n    const { instance } = await WebAssembly.instantiateStreaming(response, importsObj);\n    return instance.exports;\n}\n/* eslint-disable @typescript-eslint/no-unused-vars */ /// <reference path=\"../shared/runtime-utils.ts\" />\n/// <reference path=\"../shared-node/base-externals-utils.ts\" />\n/// <reference path=\"../shared-node/node-externals-utils.ts\" />\n/// <reference path=\"../shared-node/node-wasm-utils.ts\" />\nvar SourceType = /*#__PURE__*/ function(SourceType) {\n    /**\r\n   * The module was instantiated because it was included in an evaluated chunk's\r\n   * runtime.\r\n   */ SourceType[SourceType[\"Runtime\"] = 0] = \"Runtime\";\n    /**\r\n   * The module was instantiated because a parent module imported it.\r\n   */ SourceType[SourceType[\"Parent\"] = 1] = \"Parent\";\n    return SourceType;\n}(SourceType || {});\nprocess.env.TURBOPACK = '1';\nfunction stringifySourceInfo(source) {\n    switch(source.type){\n        case 0:\n            return `runtime for chunk ${source.chunkPath}`;\n        case 1:\n            return `parent module ${source.parentId}`;\n        default:\n            invariant(source, (source)=>`Unknown source type: ${source?.type}`);\n    }\n}\nconst url = require(\"url\");\nconst fs = require(\"fs/promises\");\nconst moduleFactories = Object.create(null);\nconst moduleCache = Object.create(null);\n/**\r\n * Returns an absolute path to the given module's id.\r\n */ function createResolvePathFromModule(resolver) {\n    return function resolvePathFromModule(moduleId) {\n        const exported = resolver(moduleId);\n        const exportedPath = exported?.default ?? exported;\n        if (typeof exportedPath !== \"string\") {\n            return exported;\n        }\n        const strippedAssetPrefix = exportedPath.slice(ASSET_PREFIX.length);\n        const resolved = path.resolve(RUNTIME_ROOT, strippedAssetPrefix);\n        return url.pathToFileURL(resolved).href;\n    };\n}\nfunction loadChunk(chunkData, source) {\n    if (typeof chunkData === \"string\") {\n        return loadChunkPath(chunkData, source);\n    } else {\n        return loadChunkPath(chunkData.path, source);\n    }\n}\nfunction loadChunkPath(chunkPath, source) {\n    if (!isJs(chunkPath)) {\n        // We only support loading JS chunks in Node.js.\n        // This branch can be hit when trying to load a CSS chunk.\n        return;\n    }\n    try {\n        const resolved = path.resolve(RUNTIME_ROOT, chunkPath);\n        const chunkModules = require(resolved);\n        for (const [moduleId, moduleFactory] of Object.entries(chunkModules)){\n            if (!moduleFactories[moduleId]) {\n                moduleFactories[moduleId] = moduleFactory;\n            }\n        }\n    } catch (e) {\n        let errorMessage = `Failed to load chunk ${chunkPath}`;\n        if (source) {\n            errorMessage += ` from ${stringifySourceInfo(source)}`;\n        }\n        throw new Error(errorMessage, {\n            cause: e\n        });\n    }\n}\nasync function loadChunkAsync(source, chunkData) {\n    const chunkPath = typeof chunkData === \"string\" ? chunkData : chunkData.path;\n    if (!isJs(chunkPath)) {\n        // We only support loading JS chunks in Node.js.\n        // This branch can be hit when trying to load a CSS chunk.\n        return;\n    }\n    const resolved = path.resolve(RUNTIME_ROOT, chunkPath);\n    try {\n        const contents = await fs.readFile(resolved, \"utf-8\");\n        const localRequire = (id)=>{\n            let resolvedId = require.resolve(id, {\n                paths: [\n                    path.dirname(resolved)\n                ]\n            });\n            return require(resolvedId);\n        };\n        const module1 = {\n            exports: {}\n        };\n        // TODO: Use vm.runInThisContext once our minimal supported Node.js version includes https://github.com/nodejs/node/pull/52153\n        // eslint-disable-next-line no-eval -- Can't use vm.runInThisContext due to https://github.com/nodejs/node/issues/52102\n        (0, eval)(\"(function(module, exports, require, __dirname, __filename) {\" + contents + \"\\n})\" + \"\\n//# sourceURL=\" + url.pathToFileURL(resolved))(module1, module1.exports, localRequire, path.dirname(resolved), resolved);\n        const chunkModules = module1.exports;\n        for (const [moduleId, moduleFactory] of Object.entries(chunkModules)){\n            if (!moduleFactories[moduleId]) {\n                moduleFactories[moduleId] = moduleFactory;\n            }\n        }\n    } catch (e) {\n        let errorMessage = `Failed to load chunk ${chunkPath}`;\n        if (source) {\n            errorMessage += ` from ${stringifySourceInfo(source)}`;\n        }\n        throw new Error(errorMessage, {\n            cause: e\n        });\n    }\n}\nasync function loadChunkAsyncByUrl(source, chunkUrl) {\n    const path1 = url.fileURLToPath(new URL(chunkUrl, RUNTIME_ROOT));\n    return loadChunkAsync(source, path1);\n}\nfunction loadWebAssembly(chunkPath, imports) {\n    const resolved = path.resolve(RUNTIME_ROOT, chunkPath);\n    return instantiateWebAssemblyFromPath(resolved, imports);\n}\nfunction loadWebAssemblyModule(chunkPath) {\n    const resolved = path.resolve(RUNTIME_ROOT, chunkPath);\n    return compileWebAssemblyFromPath(resolved);\n}\nfunction getWorkerBlobURL(_chunks) {\n    throw new Error(\"Worker blobs are not implemented yet for Node.js\");\n}\nfunction instantiateModule(id, source) {\n    const moduleFactory = moduleFactories[id];\n    if (typeof moduleFactory !== \"function\") {\n        // This can happen if modules incorrectly handle HMR disposes/updates,\n        // e.g. when they keep a `setTimeout` around which still executes old code\n        // and contains e.g. a `require(\"something\")` call.\n        let instantiationReason;\n        switch(source.type){\n            case 0:\n                instantiationReason = `as a runtime entry of chunk ${source.chunkPath}`;\n                break;\n            case 1:\n                instantiationReason = `because it was required from module ${source.parentId}`;\n                break;\n            default:\n                invariant(source, (source)=>`Unknown source type: ${source?.type}`);\n        }\n        throw new Error(`Module ${id} was instantiated ${instantiationReason}, but the module factory is not available. It might have been deleted in an HMR update.`);\n    }\n    let parents;\n    switch(source.type){\n        case 0:\n            parents = [];\n            break;\n        case 1:\n            // No need to add this module as a child of the parent module here, this\n            // has already been taken care of in `getOrInstantiateModuleFromParent`.\n            parents = [\n                source.parentId\n            ];\n            break;\n        default:\n            invariant(source, (source)=>`Unknown source type: ${source?.type}`);\n    }\n    const module1 = {\n        exports: {},\n        error: undefined,\n        loaded: false,\n        id,\n        parents,\n        children: [],\n        namespaceObject: undefined\n    };\n    moduleCache[id] = module1;\n    // NOTE(alexkirsz) This can fail when the module encounters a runtime error.\n    try {\n        const r = commonJsRequire.bind(null, module1);\n        moduleFactory.call(module1.exports, {\n            a: asyncModule.bind(null, module1),\n            e: module1.exports,\n            r,\n            t: runtimeRequire,\n            x: externalRequire,\n            y: externalImport,\n            f: moduleContext,\n            i: esmImport.bind(null, module1),\n            s: esmExport.bind(null, module1, module1.exports),\n            j: dynamicExport.bind(null, module1, module1.exports),\n            v: exportValue.bind(null, module1),\n            n: exportNamespace.bind(null, module1),\n            m: module1,\n            c: moduleCache,\n            M: moduleFactories,\n            l: loadChunkAsync.bind(null, {\n                type: 1,\n                parentId: id\n            }),\n            L: loadChunkAsyncByUrl.bind(null, {\n                type: 1,\n                parentId: id\n            }),\n            w: loadWebAssembly,\n            u: loadWebAssemblyModule,\n            g: globalThis,\n            P: resolveAbsolutePath,\n            U: relativeURL,\n            R: createResolvePathFromModule(r),\n            b: getWorkerBlobURL,\n            z: requireStub,\n            __dirname: typeof module1.id === \"string\" ? module1.id.replace(/(^|\\/)\\/+$/, \"\") : module1.id\n        });\n    } catch (error) {\n        module1.error = error;\n        throw error;\n    }\n    module1.loaded = true;\n    if (module1.namespaceObject && module1.exports !== module1.namespaceObject) {\n        // in case of a circular dependency: cjs1 -> esm2 -> cjs1\n        interopEsm(module1.exports, module1.namespaceObject);\n    }\n    return module1;\n}\n/**\r\n * Retrieves a module from the cache, or instantiate it if it is not cached.\r\n */ // @ts-ignore\nfunction getOrInstantiateModuleFromParent(id, sourceModule) {\n    const module1 = moduleCache[id];\n    if (sourceModule.children.indexOf(id) === -1) {\n        sourceModule.children.push(id);\n    }\n    if (module1) {\n        if (module1.parents.indexOf(sourceModule.id) === -1) {\n            module1.parents.push(sourceModule.id);\n        }\n        return module1;\n    }\n    return instantiateModule(id, {\n        type: 1,\n        parentId: sourceModule.id\n    });\n}\n/**\r\n * Instantiates a runtime module.\r\n */ function instantiateRuntimeModule(moduleId, chunkPath) {\n    return instantiateModule(moduleId, {\n        type: 0,\n        chunkPath\n    });\n}\n/**\r\n * Retrieves a module from the cache, or instantiate it as a runtime module if it is not cached.\r\n */ // @ts-ignore TypeScript doesn't separate this module space from the browser runtime\nfunction getOrInstantiateRuntimeModule(moduleId, chunkPath) {\n    const module1 = moduleCache[moduleId];\n    if (module1) {\n        if (module1.error) {\n            throw module1.error;\n        }\n        return module1;\n    }\n    return instantiateRuntimeModule(moduleId, chunkPath);\n}\nconst regexJsUrl = /\\.js(?:\\?[^#]*)?(?:#.*)?$/;\n/**\r\n * Checks if a given path/URL ends with .js, optionally followed by ?query or #fragment.\r\n */ function isJs(chunkUrlOrPath) {\n    return regexJsUrl.test(chunkUrlOrPath);\n}\nmodule.exports = {\n    getOrInstantiateRuntimeModule,\n    loadChunk\n};\n"
        }
    ]
}